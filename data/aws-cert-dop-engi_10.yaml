- en: 'Chapter 8: Creating Workloads with CodeCommit and CodeBuild'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：使用 CodeCommit 和 CodeBuild 创建工作负载
- en: AWS has come up with an admirable set of tools to help developers and organizations
    run their CI/CD operations entirely from the Amazon ecosystem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 提供了一套值得称赞的工具，帮助开发人员和组织完全依赖 Amazon 生态系统来运行他们的 CI/CD 操作。
- en: Continuous integration starts with the process of source code versioning and
    then building and testing your code in a repeatable, automated fashion. Two of
    the tools provided by the **AWS Codes Services Suite**, **CodeCommit** and **CodeBuild**,
    help engineers achieve these goals.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成从源代码版本控制过程开始，然后以可重复、自动化的方式构建和测试代码。**AWS 代码服务套件**中的两个工具，**CodeCommit** 和
    **CodeBuild**，帮助工程师实现这些目标。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Using CodeCommit for code versioning
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CodeCommit 进行代码版本控制
- en: Setting up your CodeCommit repository
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置你的 CodeCommit 仓库
- en: Approvals in CodeCommit
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CodeCommit 中的审批
- en: Using AWS CodeBuild
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AWS CodeBuild
- en: Creating a `buildspec` file
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `buildspec` 文件
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As we start on this path, a few assumptions are going to be made, especially
    with pursuing the professional DevOps certification. The first is that you have
    a basic knowledge of using the software versioning system known as Git. This basic
    knowledge includes creating a bare repository, creating a branch, making a commit
    to that branch, and then pushing that commit to a remote repository. If you need
    to get up to speed with Git, then using the tutorial *Getting Started with Git
    and AWS CodeCommit* is suggested. You can find it at [https://docs.aws.amazon.com/codecommit/latest/userguide/getting-started.html](https://docs.aws.amazon.com/codecommit/latest/userguide/getting-started.html).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始这条路时，假设有几个前提，尤其是在追求专业 DevOps 认证时。第一个前提是你对使用软件版本控制系统 Git 有基本的了解。这个基本知识包括创建一个裸仓库、创建一个分支、对该分支进行提交，然后将提交推送到远程仓库。如果你需要熟悉
    Git，建议使用教程 *《Git 和 AWS CodeCommit 入门》*。你可以在 [https://docs.aws.amazon.com/codecommit/latest/userguide/getting-started.html](https://docs.aws.amazon.com/codecommit/latest/userguide/getting-started.html)
    找到该教程。
- en: The second assumption is that you already have Git installed on your laptop
    or workstation. Suppose you don't have Git installed yet or cannot access it due
    to a lack of administrative permissions. In that case, a perfect alternative is
    to spin up an Amazon EC2 instance in your AWS account that you can install Git
    on so that you can follow along with the exercises.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个假设是你已经在笔记本电脑或工作站上安装了 Git。假设你还没有安装 Git，或者由于缺乏管理员权限而无法访问它，完美的替代方案是启动一个 Amazon
    EC2 实例，在你的 AWS 账户中安装 Git，这样你就可以跟随练习进行操作。
- en: If Git is not installed on your local workstation and you either cannot install
    it or would not like to install it, AWS provides the Cloud9 development environment,
    which allows you to create code inside of a browser window.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Git 没有安装在你的本地工作站上，并且你无法安装它或不想安装它，AWS 提供了 Cloud9 开发环境，它允许你在浏览器窗口中创建代码。
- en: Using CodeCommit for code versioning
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CodeCommit 进行代码版本控制
- en: There are plenty of choices regarding where you can store your code, both on-premises
    and within SaaS solutions. Features and values are what tend to drive decisions
    on which product to use. AWS CodeCommit provides both a robust set of features
    and the value of being a pay-per-use service, containing elements such as native
    connectivity to AWS services, along with them complying with multiple assurance
    programs such as SOC2, PCI, HIPAA, and others.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 关于存储代码的地方，无论是在本地还是在 SaaS 解决方案中，你有很多选择。功能和价值是驱动决策的因素，决定使用哪种产品。AWS CodeCommit
    提供了强大的功能集，并且是按使用付费的服务，包含与 AWS 服务的原生连接，以及符合多个保证计划，如 SOC2、PCI、HIPAA 等。
- en: 'In [*Chapter 6*](B17405_06_Final_JM_ePub.xhtml#_idTextAnchor166), *Understanding
    CI/CD and the SDLC*, we discussed the four major phases of the software development
    life cycle: source, build, test, and deploy. The initial phase, source, is what
    we will be concentrating on in this section. As a quick recap, the source phase
    allows you to check your code into a central repository and also allows multiple
    people to collaborate on the same code base.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第6章*](B17405_06_Final_JM_ePub.xhtml#_idTextAnchor166)，*了解 CI/CD 和软件开发生命周期
    (SDLC)* 中，我们讨论了软件开发生命周期的四个主要阶段：源代码、构建、测试和部署。初始阶段，即源代码阶段，是我们将在本节中集中讨论的内容。简要回顾一下，源代码阶段允许你将代码检查到中央仓库，并且允许多人在同一代码库上进行协作。
- en: What is CodeCommit?
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 CodeCommit？
- en: CodeCommit is a secure, highly scalable, managed source control service that
    hosts private Git repositories. This may sound a bit foreign initially, but you
    have probably used a SaaS service to host code already if you have used BitBucket
    or GitHub private repositories.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: CodeCommit是一个安全、高度可扩展的托管源代码控制服务，承载私有Git仓库。这听起来可能有些陌生，但如果你使用过BitBucket或GitHub私有仓库，你可能已经使用过类似的SaaS服务来托管代码。
- en: The fundamental object in CodeCommit is the repository. The repository is where
    users store code and objects of any type and size for their projects. CodeCommit
    also stores and tracks changes that have been made to uploaded files, along with
    changes that have been made to files. You can configure the repository to send
    notifications when events happen, such as branch merges or comments being added
    to code. It also allows users to work on their local systems and then push changes
    to the CodeCommit storage system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: CodeCommit中的基本对象是仓库。仓库是用户存储代码和任何类型、大小对象的地方。CodeCommit还存储和跟踪对上传文件所做的更改，以及对文件所做的更改。你可以配置仓库，以便在发生事件时发送通知，例如分支合并或向代码中添加评论。它还允许用户在本地系统上工作，然后将更改推送到CodeCommit存储系统。
- en: Benefits of CodeCommit
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CodeCommit的好处
- en: 'As part of the AWS ecosystem, CodeCommit can integrate with services such as
    KMS for encryption, as well as CloudWatch to incorporate metrics and alarms for
    our repositories, and this doesn''t even touch on some of the development tools
    that are tightly integrated with the CodeCommit service. Aside from just being
    tightly coupled with numerous other AWS services, CodeCommit provides many other
    benefits:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 作为AWS生态系统的一部分，CodeCommit可以与KMS等服务集成以实现加密，还可以与CloudWatch集成，以便为我们的仓库整合指标和警报，甚至不包括与CodeCommit服务紧密集成的某些开发工具。除了与众多其他AWS服务紧密耦合外，CodeCommit还提供许多其他好处：
- en: IAM for CodeCommit provides high service availability and durability.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CodeCommit的IAM提供高服务可用性和耐久性。
- en: CodeCommit repositories are encrypted at rest and in transit, so you know that
    your code is always secure.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CodeCommit仓库在静态和传输过程中都进行了加密，因此你可以放心，代码始终是安全的。
- en: It scales easily and has no limits on the size of repositories or the types
    and sizes of the files you can store.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以轻松扩展，并且对仓库的大小、以及你可以存储的文件类型和大小没有限制。
- en: Seamlessly integrates with several AWS services (Lambda, SNS, CodePipeline).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无缝集成多个AWS服务（Lambda、SNS、CodePipeline）。
- en: Allows you to migrate from other remote Git-based repositories easily.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许你轻松地从其他远程Git仓库迁移。
- en: Allows you to use the Git tools and commands that you already know.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许你使用你已经熟悉的Git工具和命令。
- en: With this overview and the benefits of AWS CodeCommit under our belt, we will
    look at the available access control features before creating our repository and
    our new group specifically for CodeCommit access.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了AWS CodeCommit的概述和好处之后，我们将查看可用的访问控制功能，然后再创建我们的仓库和专门用于CodeCommit访问的新用户组。
- en: Controlling access to repositories
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制对仓库的访问
- en: Before we go through the process of creating the CodeCommit repository, we need
    to do a little pre-work as far as permissions are concerned. Up until this point,
    we have been doing most things as an administrative user. We are starting to add
    developers and development teams into the mix, some of which only need access
    to the CodeCommit repositories and no other services. We are going to create a
    new IAM group and then add a developer entity to that group. This will demonstrate
    good GitFlow practices of the developer contributing code and then asking for
    their branch to be merged into the main branch.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建CodeCommit仓库的过程之前，我们需要做一些权限方面的预先工作。直到这一点为止，我们大部分操作都是以管理员用户身份进行的。现在我们开始将开发人员和开发团队加入其中，其中一些只需要访问CodeCommit仓库而不需要访问其他服务。我们将创建一个新的IAM用户组，然后将一个开发者实体添加到该用户组。这将演示良好的GitFlow实践，即开发者提交代码后，请求将其分支合并到主分支。
- en: This works when the developers are all part of the same account where we are
    creating our CodeCommit repositories. There are other scenarios that we need to
    be aware of as well. For example, what happens when a developer in another account
    needs access to CodeCommit repositories in our account? CodeCommit can provide
    cross-account access to users and roles in another AWS account. This can solve
    the issue of not having to add external developers to your IAM list of users if
    they already have an AWS account.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有开发者都属于同一个账户时，可以顺利创建 CodeCommit 仓库。然而，还有其他一些场景需要注意。例如，当另一个账户中的开发者需要访问我们账户中的
    CodeCommit 仓库时该怎么办？CodeCommit 可以为另一个 AWS 账户中的用户和角色提供跨账户访问。这可以解决不必将外部开发者添加到 IAM
    用户列表中的问题，前提是他们已经拥有 AWS 账户。
- en: Setting up your CodeCommit repository
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置你的 CodeCommit 仓库
- en: A CodeCommit repository can be created via the CLI. However, when using the
    AWS management console, there are some additional features, such as the info panel,
    that are only available in that environment.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 CLI 创建 CodeCommit 仓库。然而，当使用 AWS 管理控制台时，有一些附加功能，如信息面板，这些功能只有在该环境中才可用。
- en: Before we create the repository, be sure to open your browser to the AWS CodeCommit
    home page, [https://console.aws.amazon.com/codesuite/codecommit/home](https://console.aws.amazon.com/codesuite/codecommit/home),
    and sign in if prompted.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建仓库之前，确保打开浏览器访问 AWS CodeCommit 主页，[https://console.aws.amazon.com/codesuite/codecommit/home](https://console.aws.amazon.com/codesuite/codecommit/home)，并在提示时登录。
- en: 'Once you have signed in, we can go through the process of creating a repository
    in CodeCommit:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你登录，我们可以开始创建 CodeCommit 仓库的过程：
- en: Once you're on the `CodeCommit` main page for the region you are working in
    (we are doing everything in our examples in the Ohio region/`us-east-2`), click
    on the orange **Create repository** button in the top right-hand corner to start
    the process of creating a new repository:![Figure 8.1 – Create repository button
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你进入了你所在地区的`CodeCommit`主页（在我们的示例中，我们使用的是俄亥俄地区/`us-east-2`），点击右上角的橙色**创建仓库**按钮，开始创建新仓库的过程：![图
    8.1 – 创建仓库按钮
- en: '](img/Figure_8.1_B17405.jpg)'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.1_B17405.jpg)'
- en: Figure 8.1 – Create repository button
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.1 – 创建仓库按钮
- en: On the `chapter8` for the name of the repository. If you like, you can add a
    description for the repository, but it is not necessary. You may wish to enable
    the CodeGuru reviewer at this point; however, since this is a new feature, we
    will not be going over this:![Figure 8.2 – New code commit repository settings
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chapter8`中设置仓库名称。如果你愿意，可以为仓库添加描述，但这不是必要的。你可能希望此时启用 CodeGuru 审阅器；然而，由于这是一个新功能，我们将不进行讨论：![图
    8.2 – 新的 CodeCommit 仓库设置
- en: '](img/Figure_8.2_B17405.jpg)'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.2_B17405.jpg)'
- en: Figure 8.2 – New code commit repository settings
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.2 – 新的 CodeCommit 仓库设置
- en: Note
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The Amazon CodeGuru reviewer is an optional feature and an additional service
    of AWS that, at the time of publishing, only works for the Java and Python languages.
    More languages may be available at a later time.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Amazon CodeGuru 审阅器是一个可选功能，是 AWS 的附加服务，在发布时仅支持 Java 和 Python 语言。未来可能会支持更多语言。
- en: Once you have created your repository, you will be taken to a screen showing
    the connection steps for connecting to your new repository in several ways. These
    include HTTPS, `SSH`, and the git-remote-connect protocol over HTTPS. Take a moment
    to look over these. We will be using this section more once our developer has
    been created and we are using their set of permissions. Scroll down past the connection
    steps. At the bottom of the page, you will see a button called **Create file**.
    Click this button so that we can set up our main branch:![Figure 8.3 – Creating
    an initial file for our CodeCommit repository
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建仓库后，你将看到一个显示连接步骤的页面，这些步骤展示了如何通过多种方式连接到你的新仓库，包括 HTTPS、`SSH` 和通过 HTTPS 的 git-remote-connect
    协议。花一点时间浏览这些步骤。我们将在开发者账户创建完成，并且使用其权限集时，更加深入地使用这一部分。向下滚动，越过连接步骤，页面底部会看到一个名为**创建文件**的按钮。点击该按钮以便设置我们的主分支：![图
    8.3 – 为我们的 CodeCommit 仓库创建初始文件
- en: '](img/Figure_8.3_B17405.jpg)'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.3_B17405.jpg)'
- en: Figure 8.3 – Creating an initial file for our CodeCommit repository
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.3 – 为我们的 CodeCommit 仓库创建初始文件
- en: On the `Welcome to my repository`. Once you have done this, in the `sample.txt`.
    You will also have to enter a name and an **Email address** for the commit on
    the web interface, as shown in the following screenshot:![Figure 8.4 – Committing
    the change to CodeCommit via the web interface
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Welcome to my repository`。完成此操作后，在 `sample.txt` 中，你还需要为提交输入一个名称和一个**电子邮件地址**，如以下截图所示：![图
    8.4 – 通过 Web 界面提交更改到 CodeCommit
- en: '](img/Figure_8.4_B17405.jpg)'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.4_B17405.jpg)'
- en: Figure 8.4 – Committing the change to CodeCommit via the web interface
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.4 – 通过 Web 界面提交更改到 CodeCommit
- en: 'Once you''ve entered this information, you can press the orange **Commit changes**
    button. From here, you will be taken to the file in the repository; however, it''s
    more important to note that, in the top right-hand corner of the screen, we have
    successfully created the **main** branch:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入这些信息后，你可以点击橙色的 **Commit changes** 按钮。接下来，你将被带到仓库中的文件，但更重要的是要注意，在屏幕的右上角，我们已经成功创建了
    **main** 分支：
- en: '![Figure 8.5 – The main branch of our CodeCommit repository'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.5 – 我们的 CodeCommit 仓库的主分支'
- en: '](img/Figure_8.5_B17405.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.5_B17405.jpg)'
- en: Figure 8.5 – The main branch of our CodeCommit repository
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 我们的 CodeCommit 仓库的主分支
- en: With our repository and main branch now created, we can start creating the permission
    set that our developers will use to push code up to the repository. Depending
    on how your organization is structured, you may give all developers the ability
    to create new repositories and merge pull requests to the main branch.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了仓库和主分支，我们可以开始创建开发人员用来将代码推送到仓库的权限集。根据你的组织结构，你可能会赋予所有开发人员创建新仓库和将拉取请求合并到主分支的权限。
- en: In our example scenario, as we work through the exercises, we will be separating
    the duties from what a developer can do versus an administrator or DevOps power
    user. It's imperative to think about how to divide responsibilities as you prepare
    for the exam, as well as some of the questions and scenarios that may be presented.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例场景中，当我们进行练习时，我们将区分开发人员可以做的事情与管理员或 DevOps 高级用户的职责。准备考试时，考虑如何划分责任是非常重要的，此外，还有一些可能出现的问题和场景需要注意。
- en: Creating your IAM group for developers
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为开发人员创建 IAM 组
- en: 'Before we begin, make sure that you download the files from this book''s GitHub
    repository, from the `Chapter-8` folder. We will start by creating the IAM policy
    for the developers. Once our policy has been uploaded, we will create the developer
    group and then attach our policy to the newly created group:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请确保从本书的 GitHub 仓库下载文件，路径是 `Chapter-8` 文件夹。我们将首先为开发人员创建 IAM 策略。一旦策略上传完毕，我们将创建开发人员组，并将策略附加到新创建的组上：
- en: Open your terminal so that you have access to your AWS CLI.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，以便可以访问你的 AWS CLI。
- en: 'We want to create a group just for our code commit developers. You may have
    made a developers group previously, but we want to make a new group just for this
    chapter:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想为我们的代码提交开发人员创建一个组。你可能以前创建过一个开发人员组，但我们现在要为本章创建一个新的组：
- en: '[PRE0]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now that you have created the group, we will attach the policy to it. We will
    need the policy ARN from when we created our `CC_Developers` policy just a few
    moments ago:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经创建了组，我们将把策略附加到该组。我们需要从之前创建的 `CC_Developers` 策略中获取策略 ARN：
- en: '[PRE1]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we have created the `CC_Developers` group, we can create our developer
    and allow them to log in and add their `SSH` key to start using `CodeCommit`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然我们已经创建了 `CC_Developers` 组，我们可以创建我们的开发人员，并允许他们登录并添加他们的 `SSH` 密钥以开始使用 `CodeCommit`。
- en: Creating your developer
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建你的开发人员
- en: 'In this section, we are going to create a fictional developer called `Mariel`.
    If you like, you can change the name of the developer from `Mariel` to something
    else. If you haven''t already, download the `change-password.json` file and follow
    these steps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个虚拟的开发人员，名为 `Mariel`。如果你愿意，你可以将开发人员的名称从 `Mariel` 改为其他名字。如果你还没有下载，先下载
    `change-password.json` 文件并按照以下步骤操作：
- en: 'If your terminal isn''t open still, open it back up so that you can perform
    commands in the AWS CLI. Use the `create-user` command from `iam`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的终端仍未打开，请重新打开它，以便可以在 AWS CLI 中执行命令。使用 `iam` 的 `create-user` 命令：
- en: '[PRE2]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once this command has finished running, it should return a `JSON` statement
    that shows, among other things, the User ID, as shown in the following example:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当这个命令运行完成后，它应该返回一个 `JSON` 语句，显示包括用户 ID 在内的其他信息，如以下示例所示：
- en: '[PRE3]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With our user created, we can attach them to the `CC_Developers` group and
    allow them to inherit all the group''s permissions:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建的用户，可以将其添加到`CC_Developers`组，并允许他们继承该组的所有权限：
- en: '[PRE4]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we''ve created our user and attached them to the `CC_Developers` group,
    we will need to create an initial password for the user so that they can log into
    the management console and upload their `SSH` key. It is also a good idea to require
    them to reset their password:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了用户并将其添加到`CC_Developers`组中，我们需要为该用户创建一个初始密码，以便他们可以登录到管理控制台并上传他们的`SSH`密钥。要求他们重置密码也是一个好主意：
- en: '[PRE5]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With that, we have created an initial password for our user to configure their
    `SSH` key settings in the console and view the CodeCommit branches via the console.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就为用户创建了一个初始密码，以便他们能够在控制台中配置`SSH`密钥设置，并通过控制台查看CodeCommit分支。
- en: Now that we've created our developer using the AWS CLI, we can switch contexts
    and assume the role of the developer as we continue.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用AWS CLI创建了开发者用户，我们可以切换上下文并继续假设为开发者角色。
- en: Adding your developer's SSH key
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加开发者的SSH密钥
- en: Now that we have created our developer, we will switch from the CLI and move
    to the `SSH` key pair in our working environment that we can use to authenticate
    ourselves when creating code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了开发者用户，我们将从CLI切换到工作环境中的`SSH`密钥对，以便在创建代码时用于身份验证。
- en: Tip
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: When using a specific repository or set of repositories for an account, client,
    or specific purpose, it's a good idea to create a particular key just for that
    project, account, or client. Using distinct keys is part of an overall risk mitigation
    strategy in case anything were to happen to the servers, SaaS offerings, or your
    workstation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当为账户、客户或特定用途使用特定的仓库或仓库集时，最好为该项目、账户或客户创建一个专用的密钥。使用不同的密钥是整体风险管理策略的一部分，以防服务器、SaaS服务或工作站出现任何问题。
- en: Let's start by creating an `SSH` key pair that's specific for our developer
    to be able to add to the AWS IAM console.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个专门供开发者使用的`SSH`密钥对，以便能够将其添加到AWS IAM控制台中。
- en: 'In your terminal, use the following command to generate a new key pair file
    for Linux or macOS users:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，使用以下命令为Linux或macOS用户生成一个新的密钥对文件：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Running this command will start by asking you a few prompts, the first of which
    will be where you want to save your key. The default should be in your local `.ssh`
    folder, but with an `id_rsa` name. Instead, we will use a custom name for our
    key so that we know it is specifically for our code commit project:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令时，会首先要求你回答一些提示问题，第一个问题是你希望将密钥保存在哪里。默认情况下应该保存在本地的`.ssh`文件夹中，但名称为`id_rsa`。我们将使用一个自定义的密钥名称，以便我们知道这是专门为我们的代码提交项目准备的：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After you have chosen where to save you key with its name, then you will be
    presented with a prompt for a `passphrase`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 选择保存密钥的位置和名称后，你将看到一个提示，要求输入`passphrase`：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have no requirements for a passphrase, so just hit *Enter* twice to leave
    this blank. At this point, you should see statements saying where your identity
    and public key have been saved, along with something that looks like ASCII art.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要设置密码，因此只需按*Enter*键两次以保持空白。此时，你应该会看到一些信息，说明你的身份和公钥已保存，并显示类似ASCII艺术的内容。
- en: You will need to cat out your public key and have that available when we log
    into the AWS console as the developer.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要使用`cat`命令查看你的公钥，并在登录AWS控制台时准备好它，作为开发者用户进行登录。
- en: After you have generated your key
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成密钥后
- en: Now that we have generated our key, we need to log into the AWS console using
    the developer's username and credentials that we just created (and not the DevOps
    user who has administrator privileges, which is what we have been using up to
    this point.)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经生成了密钥，需要使用我们刚创建的开发者用户名和凭证登录AWS控制台（而不是我们一直在使用的具有管理员权限的DevOps用户）。
- en: Tip
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You may want to use a different browser or start an incognito/private session,
    just to be sure that you don't have any lingering cookies.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要使用不同的浏览器，或者开启隐身/私密会话，以确保没有遗留的Cookies。
- en: 'In your new browser, log in as the developer user that we just created:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的浏览器中，登录为我们刚刚创建的开发者用户：
- en: We will now use the developer account instead of our administrator account.
    Log into your account at [https://aws.amazon.com/](https://aws.amazon.com/) and
    use the developer's name (`mariel`, in our case) and password (`Dev0psPRO`) to
    sign into the AWS Management Console initially.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将使用开发者账户，而不是管理员账户。请登录到 [https://aws.amazon.com/](https://aws.amazon.com/)，并使用开发者的名字（`mariel`，在我们的例子中）和密码（`Dev0psPRO`）首次登录
    AWS 管理控制台。
- en: Once signed in, you will be immediately prompted to change your password from
    the initial password that was set to one of your choosing. If you previously put
    a password policy in the **IAM Account** settings, you must adhere to these guidelines
    when changing the password:![Figure 8.6 – Mandatory password change for the developer
    user
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，系统会立即提示您将初始密码更改为您选择的密码。如果您之前在 **IAM 账户** 设置中设置了密码策略，则必须在更改密码时遵守这些指南：![图
    8.6 – 开发者用户强制密码更改
- en: '](img/Figure_8.6_B17405.jpg)'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.6_B17405.jpg)'
- en: Figure 8.6 – Mandatory password change for the developer user
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.6 – 开发者用户强制密码更改
- en: Once you have changed the password, you will be brought to the main page of
    the AWS management console. Now, we need to type **IAM** in the search box to
    go to the **IAM service**.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您更改了密码，您将进入 AWS 管理控制台的主页。现在，我们需要在搜索框中输入 **IAM**，以进入 **IAM 服务**。
- en: Once you have reached the IAM service, it will look as if you don't have permission
    to do anything. However, this is only because the developer role has a limited
    scope of permissions. This user can list users and update information about their
    user. Click on the **Users** menu item on the left-hand menu.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您进入了 IAM 服务，您会发现似乎没有权限进行任何操作。然而，这只是因为开发者角色的权限范围有限。这个用户可以列出用户并更新他们的用户信息。在左侧菜单中点击
    **用户** 菜单项。
- en: Once you're on the user's menu, you will see a list of users. Click on the name
    of the developer that we created (in our case, `mariel`):![Figure 8.7 – List of
    IAM users
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入用户菜单后，您将看到一列用户。点击我们创建的开发者的名字（在我们的例子中是 `mariel`）：![图 8.7 – IAM 用户列表
- en: '](img/Figure_8.7_B17405.jpg)'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.7_B17405.jpg)'
- en: Figure 8.7 – List of IAM users
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.7 – IAM 用户列表
- en: On the **Summary** page for the user, you will be met by a few red boxes, but
    here, we are interested in the **Security credentials** tab. Click on this tab
    so that you can start modifying the **Security credentials** page:![Figure 8.8
    – IAM user summary top menu
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户的 **概览** 页面上，您会看到一些红框，但这里我们感兴趣的是 **安全凭证** 标签。点击此标签，您可以开始修改 **安全凭证** 页面：![图
    8.8 – IAM 用户概览顶部菜单
- en: '](img/Figure_8.8_B17405.jpg)'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.8_B17405.jpg)'
- en: Figure 8.8 – IAM user summary top menu
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.8 – IAM 用户概览顶部菜单
- en: Scrolling down on the `SSH``SSH``public key` not only available but in your
    clipboard, ready to paste. Press the `SSH` **public key** button to continue.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下滚动，确保 `SSH` **公钥** 不仅已准备好，而且已经复制到剪贴板，随时可以粘贴。点击 `SSH` **公钥** 按钮继续。
- en: When the pop-up window appears, paste your public key into the text box and
    then click the blue `SSH``SSH` **key ID** listing. Take note of this as we need
    this ID in just a moment for our local setup:![Figure 8.9 – The SSH key ID is
    given in the IAM console once the SSH public key has been uploaded
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当弹出窗口出现时，将您的公钥粘贴到文本框中，然后点击蓝色的`SSH``SSH` **密钥 ID** 列表。请注意这一点，因为我们接下来会用到这个 ID
    来进行本地设置：![图 8.9 – 一旦上传了 SSH 公钥，IAM 控制台将显示 SSH 密钥 ID
- en: '](img/Figure_8.9_B17405.jpg)'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.9_B17405.jpg)'
- en: Figure 8.9 – The SSH key ID is given in the IAM console once the SSH public
    key has been uploaded
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.9 – 一旦上传了 SSH 公钥，IAM 控制台将显示 SSH 密钥 ID
- en: 'Back in your workstation, we need to either create a `.ssh/config` file or
    modify the existing `config` file by adding a few lines specific to the code commit.
    Use your editor of choice to create or open `~/.ssh/config` and then add the following
    lines. Be sure to change out the sample user ID for the one that the AWS console
    returned to you after uploading your key. Also, if you created a different name
    for your `SSH` key, you will have to substitute that in the `IdentityFile` line:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到您的工作站，我们需要创建一个 `.ssh/config` 文件，或者通过添加几行与代码提交相关的内容来修改现有的 `config` 文件。使用您喜欢的编辑器创建或打开
    `~/.ssh/config`，然后添加以下几行。确保将示例的用户 ID 替换为您在上传密钥后 AWS 控制台返回的 ID。另外，如果您为 `SSH` 密钥创建了不同的名称，您需要在
    `IdentityFile` 行中替换成该名称：
- en: '[PRE9]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Going back to the browser and the AWS Management console, we will now switch
    over to the CodeCommit service so that we can get the repository information to
    clone the repository. In the top search box, type `CodeCommit` and then click
    on the icon to be taken to the **CodeCommit** service page.![Figure 8.10 – The
    CodeCommit icon from the search bar in the AWS Management Console
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到浏览器和 AWS 管理控制台，我们现在将切换到 CodeCommit 服务，以便获取仓库信息并克隆该仓库。在顶部的搜索框中输入 `CodeCommit`，然后点击图标进入
    **CodeCommit** 服务页面。![图 8.10 – AWS 管理控制台搜索栏中的 CodeCommit 图标
- en: '](img/Figure_8.10_B17405.jpg)'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.10_B17405.jpg)'
- en: Figure 8.10 – The CodeCommit icon from the search bar in the AWS Management
    Console
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.10 – AWS 管理控制台搜索栏中的 CodeCommit 图标
- en: Once on the `SSH` link on the right-hand side to copy the **Clone URL** property:![Figure
    8.11 - The CodeCommit repository as it appears to the developer user
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦在右侧的 `SSH` 链接上复制了 **克隆 URL** 属性：![图 8.11 - CodeCommit 仓库在开发者用户端的显示方式
- en: '](img/Figure_8.11_B17405.jpg)'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.11_B17405.jpg)'
- en: Figure 8.11 - The CodeCommit repository as it appears to the developer user
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.11 - CodeCommit 仓库在开发者用户端的显示方式
- en: 'Switch back to your terminal and navigate to the root of your home folder.
    Then, cut and paste the copied URL after the `git clone` command, as shown here:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换回终端，进入你的主文件夹根目录。然后，将复制的 URL 粘贴到 `git clone` 命令后，如下所示：
- en: '[PRE10]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Finally, move to the `chapter8` directory. Now, you are ready to start adding
    some code or objects.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，进入 `chapter8` 目录。现在，你准备好开始添加一些代码或对象了。
- en: At this point, we have created an `SSH` key and added that to our development
    user. Then, we updated our local `SSH` config to let CodeCommit know that when
    working with code commit, which user and keypair are connected. Finally, we downloaded
    the repository that the administrative user had created earlier. We are now ready
    to create our developer branch and start pushing up some commits.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经创建了一个`SSH`密钥并将其添加到我们的开发用户中。然后，我们更新了本地的`SSH`配置，告知 CodeCommit 在处理代码提交时使用哪个用户和密钥对。最后，我们下载了管理员用户之前创建的仓库。现在我们准备创建开发者分支并开始提交一些更改。
- en: Creating a developer branch and pushing commits to that branch
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建开发者分支并将提交推送到该分支
- en: Now that we have successfully cloned our repository to our local workstation,
    it's time to create a branch and submit it. All of these actions will happen in
    the directory where you cloned your repository. If you followed the same naming
    convention as in the preceding examples, you should go to your home directory
    and find the `chapter8` folder.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功将仓库克隆到本地工作站，接下来是创建一个分支并提交。所有这些操作将在你克隆仓库所在的目录中进行。如果你遵循了前面的命名约定，那么你应该进入你的主目录，并找到
    `chapter8` 文件夹。
- en: 'The first thing that we will do is create a feature branch off of the main
    branch:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的第一件事是从主分支创建一个特性分支：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we're in our branch, we can start adding some files to make the commit.
    There are two sample files (`hello.py` and `loops.py`) in the `Chapter-8` folder
    of the GitHub repository. You can view these files and then cut and paste the
    raw contents into new files of the same name in the `chapter8` CodeCommit repository
    that we have downloaded.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在自己的分支中，可以开始添加一些文件来进行提交。GitHub 仓库的 `Chapter-8` 文件夹中有两个示例文件（`hello.py`
    和 `loops.py`）。你可以查看这些文件，然后将原始内容剪切并粘贴到我们下载的 `chapter8` CodeCommit 仓库中新创建的同名文件中。
- en: 'Before we make our commits, we should check the status of our files in our
    directory:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行提交之前，我们应该检查目录中文件的状态：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After using the `status` command, we should see an output similar to the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`status`命令后，我们应该看到类似以下的输出：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we need to add the two files to the commit. Since they are both of the
    same types, we can use a wildcard in our commit command. As an alternative, you
    can use just a pure wildcard and add all the untracked files to the commit at
    once:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将这两个文件添加到提交中。由于它们都是相同类型的文件，我们可以在提交命令中使用通配符。或者，你也可以使用纯粹的通配符，一次性将所有未跟踪的文件添加到提交中：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At this point, we need to commit the files to our feature branch:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们需要将文件提交到我们的特性分支：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, with the two files committed to the feature branch, it''s time to
    push that feature branch up to CodeCommit:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将这两个文件提交到特性分支后，就可以将该特性分支推送到 CodeCommit：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Upon successfully pushing the new feature branch, you should receive confirmation
    from the command line:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 成功推送新特性分支后，你应该会从命令行收到确认信息：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that we have made the commit to our feature branch and pushed it up to the
    CodeCommit repository, it's time to make the merge request. This merge request
    will allow our code to become part of the main branch for everyone else who is
    working off of the same code repository, along with keeping up to date with the
    main branch.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将提交推送到我们的功能分支，并上传到了CodeCommit仓库，接下来是发起合并请求。这个合并请求将允许我们的代码成为主分支的一部分，供其他所有使用相同代码仓库的开发者使用，同时保持与主分支同步。
- en: 'We will go back to the AWS console as our developer user to create the pull
    request. If you still have your developer''s separate session open in a web browser,
    then you can switch back to that browser session; otherwise, log into your account
    at [https://aws.amazon.com/](https://aws.amazon.com/) and then use the developer''s
    username (`mariel`, in our case) and the new password you changed for your developer
    user:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将作为开发者用户返回到AWS控制台以创建拉取请求。如果你仍然打开着开发者的单独会话，可以切换回该浏览器会话；否则，请登录[https://aws.amazon.com/](https://aws.amazon.com/)，然后使用开发者的用户名（在我们的例子中是`mariel`）和你为开发者用户更改的新密码：
- en: In the search box at the top, type `CodeCommit` and then click on the **CodeCommit**
    icon to be brought to the **Service** page.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部的搜索框中，输入`CodeCommit`，然后点击**CodeCommit**图标，进入**服务**页面。
- en: You should see your repository, as shown in *Figure 8.7*. Click on the name
    of the repository (`chapter8`).
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该能看到你的仓库，如*图8.7*所示。点击仓库名称（`chapter8`）。
- en: In the top menu, you will see a dropdown that currently says **main**. Click
    on this dropdown and select your branch (**feature1**). Once you've done this,
    the two files that you have uploaded will appear.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部菜单中，你会看到一个下拉框，当前显示为**main**。点击该下拉框，选择你的分支（**feature1**）。完成后，你上传的两个文件将会显示出来。
- en: Now that your branch name is showing in the top menu, you should see a button
    called **Create pull request**. Click on this button to start the merge request:![Figure
    8.12 – The Create pull request button alongside the branch name
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你在顶部菜单中看到了你的分支名称，应该会看到一个名为**创建拉取请求**的按钮。点击这个按钮开始合并请求：![图8.12 – 创建拉取请求按钮与分支名称一起显示
- en: '](img/Figure_8.12_B17405.jpg)'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.12_B17405.jpg)'
- en: Figure 8.12 – The Create pull request button alongside the branch name
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.12 – 创建拉取请求按钮与分支名称一起显示
- en: A green box should appear, showing that we don't currently have any conflicts
    between our branch and the main branch. Before you create the merge request, you
    will need to add something to the `Python files`. With the title filled in, click
    on the orange **Create pull request** button at the bottom of the screen:![Figure
    8.13 – The pull request showing that it has no conflicts
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该会出现一个绿色框，显示我们目前没有分支与主分支之间的冲突。在创建合并请求之前，你需要在`Python文件`中添加一些内容。填写标题后，点击屏幕底部的橙色**创建拉取请求**按钮：![图8.13
    – 显示没有冲突的拉取请求
- en: '](img/Figure_8.13_B17405.jpg)'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.13_B17405.jpg)'
- en: Figure 8.13 – The pull request showing that it has no conflicts
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.13 – 显示没有冲突的拉取请求
- en: Once you have created the pull request, you will be taken to a screen where
    you can view the details of the currently opened pull request.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你创建了拉取请求，系统将带你进入一个页面，在那里你可以查看当前打开的拉取请求的详细信息。
- en: Now that we have entered the pull request, this is where the developer user
    stops. The IAM policy that we have allocated will not allow them to merge the
    branches, and this is by design.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经进入了拉取请求页面，这就是开发者用户停止的地方。我们分配的IAM策略不会允许他们合并分支，这是有意设计的。
- en: Next, using our administrator, we will learn how to merge the request into the
    main branch.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用我们的管理员身份，我们将学习如何将请求合并到主分支中。
- en: Approvals in CodeCommit
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CodeCommit中的审批
- en: As developers update code and then push those updates to the CodeCommit repository,
    especially if they are using their feature branches, there needs to be a process
    for incorporating their changes into the main branch. Let's walk through how to
    take the code that our developer created on their branch and merge it into the
    main branch.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 随着开发者更新代码并将这些更新推送到CodeCommit仓库，尤其是当他们使用自己的功能分支时，需要有一个过程将他们的更改合并到主分支中。让我们一起看看如何将开发者在分支上创建的代码合并到主分支。
- en: Merging your developer branch with the main branch
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将开发者分支与主分支合并
- en: 'At this point, we haven''t enabled any notifications for our repository, but
    in a real-world scenario, this is an excellent way to add notifications for when
    someone has created a pull request. Our developer has created a branch on our
    repository, which is now ready to be merged. As the account user with merge privileges,
    we will log in and merge the feature branch and the main branch:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们还没有为仓库启用任何通知，但在实际情况下，这是一个很好的方法，用来添加通知，当有人创建拉取请求时。我们的开发者已经在仓库中创建了一个分支，现在可以进行合并。作为具有合并权限的帐户用户，我们将登录并合并功能分支和主分支：
- en: Open your console and log into **Amazon Web Console** as the primary administrative
    user that you have been using up to this point, not the developer user.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的控制台，并以你到目前为止使用的主管理员用户登录**Amazon Web Console**，而不是开发者用户。
- en: Navigate to the `CodeCommit` in the top search bar in the middle of the screen.
    Once the **CodeCommit** icon becomes visible, click on it:![Figure 8.14 – Searching
    for CodeCommit in the top search box for services
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕中间的顶部搜索栏中导航到 `CodeCommit`。一旦**CodeCommit**图标显示出来，点击它：![图 8.14 – 在服务的顶部搜索框中搜索
    CodeCommit
- en: '](img/Figure_8.14_B17405.jpg)'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.14_B17405.jpg)'
- en: Figure 8.14 – Searching for CodeCommit in the top search box for services
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.14 – 在服务的顶部搜索框中搜索 CodeCommit
- en: Once on the main CodeCommit screen, so long as you are in the correct region,
    you should see the repository that we created earlier by the developer user named
    **chapter8**. Click on this repository name to be taken into the repository:![Figure
    8.15 – The chapter8 repository inside of CodeCommit
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入主 CodeCommit 屏幕，只要你处于正确的区域，你应该能看到我们之前由开发者用户创建的名为**chapter8**的仓库。点击此仓库名称，即可进入该仓库：![图
    8.15 – CodeCommit 中的 chapter8 仓库
- en: '](img/Figure_8.15_B17405.jpg)'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.15_B17405.jpg)'
- en: Figure 8.15 – The chapter8 repository inside of CodeCommit
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.15 – CodeCommit 中的 chapter8 仓库
- en: After clicking the repository's name, a set of menu options will appear on the
    left-hand side of the screen, under **Repositories**. Here, you will find a sub-heading
    called **Pull requests** that will show us any outstanding pull requests, including
    the one that was created by our developer user previously. Click on the **Pull
    requests** menu item to be taken to the pull requests screen:![Figure 8.16 – Pull
    requests on the Repositories menu of CodeCommit
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击仓库名称后，屏幕左侧会出现一组菜单选项，位于**Repositories**下。这里，你会看到一个子标题叫做**Pull requests**，它会展示我们任何未完成的拉取请求，包括之前由开发者用户创建的那个。点击**Pull
    requests**菜单项，进入拉取请求屏幕：![图 8.16 – CodeCommit 仓库菜单中的拉取请求
- en: '](img/Figure_8.16_B17405.jpg)'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.16_B17405.jpg)'
- en: Figure 8.16 – Pull requests on the Repositories menu of CodeCommit
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.16 – CodeCommit 仓库菜单中的拉取请求
- en: Our pull request name should be **Python Files**, predicated by number one.
    **Python Files** was the name that our developer user used when creating the pull
    request originally. We should also see a blue status of **Open** on the right-hand
    side of the pull request name. Click on the pull request's name, **1:Python files**,
    to be taken to the **Merge** screen:![Figure 8.17 – Pull request with status
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的拉取请求名称应该是**Python 文件**，并以数字 1 为前缀。**Python 文件**是我们的开发者用户在最初创建拉取请求时使用的名称。我们还应该在拉取请求名称的右侧看到蓝色状态标记**开放**。点击拉取请求名称**1：Python
    文件**，进入**合并**屏幕：![图 8.17 – 带状态的拉取请求
- en: '](img/Figure_8.17_B17405.jpg)'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.17_B17405.jpg)'
- en: Figure 8.17 – Pull request with status
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.17 – 带状态的拉取请求
- en: 'Now, on the pull requests screen, which will be labeled with **1: Python files**
    at the top of the screen, you should see three colored labels right below the
    heading: **Open** (in blue), **No approval rule** (in dark gray), and **No merge
    conflicts** (in green). The latter is telling us that we can easily merge our
    pull request into the main branch. Do this by clicking on the orange **Merge**
    button at the top right-hand side of the screen:![Figure 8.18 – Notifications
    about the CodeCommit pull request'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在拉取请求屏幕上，屏幕顶部会显示**1：Python 文件**，在标题下方你应该能看到三个彩色标签：**开放**（蓝色），**无审批规则**（深灰色），以及**无合并冲突**（绿色）。后者表示我们可以轻松地将拉取请求合并到主分支。点击屏幕右上角的橙色**合并**按钮来完成此操作：![图
    8.18 – 关于 CodeCommit 拉取请求的通知
- en: '](img/Figure_8.18_B17405.jpg)'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.18_B17405.jpg)'
- en: Figure 8.18 – Notifications about the CodeCommit pull request
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.18 – 关于 CodeCommit 拉取请求的通知
- en: At this point, we will come to the **Merge pull request** screen. This screen
    is all about the merge strategy, but for this exercise, we are going to leave
    the defaults as-is. This includes keeping the box checked at the bottom that will
    delete the branch that is being merged in and using the fast forward merge strategy.
    Click the orange **Merge pull request** button at the bottom right of the page
    to merge the feature branch into the main branch.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，我们将进入**合并拉取请求**屏幕。这个屏幕主要是关于合并策略，但在这个练习中，我们将保持默认设置不变。包括保持底部勾选框，该框将删除被合并的分支，并使用快速前进合并策略。点击页面右下角的橙色**合并拉取请求**按钮，将功能分支合并到主分支。
- en: Finally, you should see a notification at the top of the screen in green, telling
    you that your `feature1` branch has been merged into the main branch.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你应该会看到屏幕顶部有一个绿色的通知，告诉你你的`feature1`分支已经合并到主分支。
- en: 'We have just taken a thorough look at the CodeCommit service and looked at
    how to perform commits and merges from the perspective of multiple team members.
    With our source code in order, we will look at an AWS service that can produce
    packages along with test software: AWS CodeBuild.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚彻底了解了CodeCommit服务，并从多个团队成员的角度看了如何进行提交和合并。整理好源代码后，我们将来看一个可以生成软件包和测试软件的AWS服务：AWS
    CodeBuild。
- en: Using AWS CodeBuild
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS CodeBuild
- en: '`buildspec` file and the job is initiated, CodeBuild will allocate the specified
    resources.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当`buildspec`文件和任务启动时，CodeBuild将分配指定的资源。
- en: This is in contrast to other build systems, where you need to manually provision
    the compute for the workers or perform complex setups to ensure that autoscaling
    environments are available for heavy build and test periods.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这与其他构建系统不同，在其他系统中，你需要手动为工作节点配置计算资源，或者执行复杂的设置，以确保在高负载构建和测试期间有自动扩展的环境可用。
- en: You can run AWS CodeBuild as a standalone service, or it can be integrated with
    other services, such as **CodeCommit** and **AWS CodePipeline**, to create a repeatable,
    automated process that is part of your continuous integration life cycle.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将AWS CodeBuild作为独立服务运行，或者将其与其他服务（如**CodeCommit**和**AWS CodePipeline**）集成，创建一个可重复的、自动化的过程，成为你持续集成生命周期的一部分。
- en: Features to know about CodeBuild
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解CodeBuild的功能
- en: 'The following are some of the features you should know about CodeBuild:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你应该了解的一些CodeBuild的功能：
- en: '**It''s a fully managed build service**: There is no need to set up, patch,
    or update any servers or software.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它是一个完全托管的构建服务**：无需设置、修补或更新任何服务器或软件。'
- en: '**It scales to meet your needs**: CodeBuild can scale up and down to meet the
    demand you place on it.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它可以根据需求进行扩展**：CodeBuild能够根据你的需求进行自动扩展和收缩。'
- en: '**It''s securely backed by AWS**: With optional encryption powered by KMS,
    along with permissions down to the specific job with IAM, you can feel confident
    in securing your build environment.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它由AWS提供安全保障**：通过KMS支持的可选加密功能，以及通过IAM对特定任务的权限控制，你可以放心地确保你的构建环境的安全性。'
- en: It's one of the AWS developer tools that tightly integrates with CodeCommit,
    CodeDeploy, and CodePipeline.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是AWS开发者工具之一，能够与CodeCommit、CodeDeploy和CodePipeline紧密集成。
- en: CodeBuild integrates natively with **CloudWatch Events** so that failed builds
    and items can be triggered, such as sending SNS messages.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CodeBuild与**CloudWatch Events**原生集成，以便触发失败的构建和项目，例如发送SNS消息。
- en: Logs can be set as output to S3 or **CloudWatch Logs**.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志可以设置为输出到S3或**CloudWatch日志**。
- en: CloudWatch metrics and alarms can be used to monitor CodeBuild thresholds.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用CloudWatch指标和警报来监控CodeBuild的阈值。
- en: Creating a CodeBuild job
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建CodeBuild任务
- en: 'CodeBuild is very versatile in the tasks it can perform. For our example, we
    will create an `buildspec` file to create a Docker image, and then push that Docker
    image to the ECR:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: CodeBuild在执行任务时非常灵活。以我们的例子为例，我们将创建一个`buildspec`文件来创建一个Docker镜像，然后将该Docker镜像推送到ECR：
- en: '![Figure 8.19 – Layout of what the example CodeBuild job does'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.19 – 示例CodeBuild任务的布局'
- en: '](img/Figure_8.19_B17405.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.19_B17405.jpg)'
- en: Figure 8.19 – Layout of what the example CodeBuild job does
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19 – 示例CodeBuild任务的布局
- en: 'If you haven''t already downloaded the `Chapter-8` files from this book''s
    GitHub repository, then now is the perfect time since we will be using the `docker`
    directory in our first CodeBuild exercise:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有从本书的GitHub仓库下载`Chapter-8`文件，那么现在正是最佳时机，因为我们将在第一个CodeBuild练习中使用`docker`目录：
- en: 'Navigate to the directory where you have downloaded the `Chapter-8` files.
    Do not go into the `docker` directory, as we will upload all of the files at once
    using a recursive command:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到您下载 `Chapter-8` 文件的目录。不要进入 `docker` 目录，因为我们将使用递归命令一次性上传所有文件：
- en: '[PRE18]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'First, we''re going to create our ECR repository so that our container has
    a place to go once it''s been built:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建我们的 ECR 仓库，以便容器在构建完成后有地方存放：
- en: '[PRE19]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With our ECR repository created, we will open the AWS Console to complete the
    rest of the CodeBuild project. Make sure that you do this using the administrative
    user and not the developer user. Once your AWS console is open, search for `CodeBuild`
    in the top search box and then click on the icon to be taken to the CodeBuild
    service.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了 ECR 仓库后，我们将打开 AWS 控制台，完成 CodeBuild 项目的其余部分。确保使用管理员用户而不是开发者用户进行此操作。一旦 AWS
    控制台打开，搜索框中输入 `CodeBuild`，然后点击图标以进入 CodeBuild 服务。
- en: On the CodeBuild service, click the orange button at the top right-hand corner
    that says **Create build project**.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 CodeBuild 服务中，点击右上角的橙色按钮，按钮上写着**创建构建项目**。
- en: 'To create our project, we will start with the initial section: `chapter8_docker`'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建我们的项目，我们将从初始部分开始：`chapter8_docker`
- en: 'b. `An example build for chapter 8`:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. `chapter 8 的一个示例构建`：
- en: '![Figure 8.20 – Project configuration on the CodeBuild Create build project
    page'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.20 – CodeBuild 创建构建项目页面上的项目配置'
- en: '](img/Figure_8.20_B17405.jpg)'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.20_B17405.jpg)'
- en: Figure 8.20 – Project configuration on the CodeBuild Create build project page
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.20 – CodeBuild 创建构建项目页面上的项目配置
- en: Next, we will move to the `devopspro-beyond`. Finally, we will provide the key
    that is asking for the folder that we uploaded the files in. In our case, this
    would be `docker/`. We don't have any versioning on our bucket, so we can leave
    this field blank:![Figure 8.21 – Source declaration in the CodeBuild project
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将移动到 `devopspro-beyond`。最后，我们将提供请求的密钥，这是我们上传文件所在的文件夹。在我们的例子中，这将是 `docker/`。我们没有对存储桶进行版本控制，因此可以将此字段留空：![图
    8.21 – CodeBuild 项目中的源声明
- en: '](img/Figure_8.21_B17405.jpg)'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.21_B17405.jpg)'
- en: Figure 8.21 – Source declaration in the CodeBuild project
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.21 – CodeBuild 项目中的源声明
- en: Next, we will be taken to the
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将进入
- en: b. `aws/codebuild/standard:5.0`
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. `aws/codebuild/standard:5.0`
- en: 'e. **Image version**: **Always use the latest version for this runtime version**'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: e. **镜像版本**：**始终使用此运行时版本的最新版本**
- en: 'f. **Environment type**: **Linux**'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: f. **环境类型**：**Linux**
- en: 'g. **Service role**: **New service role**'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: g. **服务角色**：**新建服务角色**
- en: Note
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: For the image in the CodeBuild project, we have specified version 5.0 here.
    However, you may want to look for the latest version available from AWS.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 CodeBuild 项目中的镜像，我们在这里指定了版本 5.0。然而，您可能想查找 AWS 提供的最新版本。
- en: At this point, you can leave the rest of the options as they are, scroll down
    to the bottom of the page, and click on the orange **Create build project** button.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，您可以将其余选项保持不变，滚动到页面底部，然后点击橙色的**创建构建项目**按钮。
- en: You should now be taken to the screen of your build project. At the top, you
    will see a green banner stating that your build project has been created:![Figure
    8.22 – A successful project created in AWS CodeBuild
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您应该进入到构建项目的页面。顶部会看到一条绿色横幅，显示您的构建项目已创建：![图 8.22 – 在 AWS CodeBuild 中创建的成功项目
- en: '](img/Figure_8.22_B17405.jpg)'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.22_B17405.jpg)'
- en: Figure 8.22 – A successful project created in AWS CodeBuild
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.22 – 在 AWS CodeBuild 中创建的成功项目
- en: Now, we can try to run our job and see how it turns out. If you would like to
    run the job and start a build, then click the orange **Start build** button at
    the top right-hand corner of the screen.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以尝试运行我们的任务，看看结果如何。如果您想运行任务并开始构建，请点击屏幕右上角的橙色**开始构建**按钮。
- en: This is just a base project and doesn't have to be the stopping point. We can
    still edit both the job and the `buildspec` file to add enhancements to the job
    if we so wish.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个基础项目，并不需要是停止点。如果我们愿意，仍然可以编辑任务和 `buildspec` 文件，向任务添加增强功能。
- en: 'With our project created via the console using an S3 bucket as the source,
    we will now take a closer look at the actual file that runs the CodeBuild job:
    the `buildspec` file.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通过控制台使用 S3 存储桶作为源创建项目后，我们将仔细查看实际运行 CodeBuild 任务的文件：`buildspec` 文件。
- en: Constructing the buildspec file
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 buildspec 文件
- en: 'The `buildspec` file is what drives the CodeBuild process and has a few strict
    requirements:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildspec` 文件是驱动 CodeBuild 过程的文件，并且有一些严格的要求：'
- en: It must be named `buildspec.yml`, and it can go by no other names.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须命名为 `buildspec.yml`，不能使用其他名称。
- en: It must be in the `root directory` of your source code folder.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须位于源代码文件夹的 `root directory` 中。
- en: It must be in the YAML language.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须使用 YAML 语言。
- en: 'If you open the `buildspec` file to examine it after completing the previous
    exercise, then you would notice that it contains three major sections:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在完成前面的练习后打开 `buildspec` 文件进行检查，你会注意到它包含了三个主要部分：
- en: '**Version**: This tells the CodeBuild service which version of the syntax you
    are using and is one of the few required sections.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Version**：此字段告诉 CodeBuild 服务你正在使用的语法版本，它是少数几个必需的部分之一。'
- en: '`Install`: This is only used for installing packages in the build environment.
    If you need to install a testing framework such as `pytest` or `Mocha`, this is
    the step where you would perform this task.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Install`：此步骤仅用于在构建环境中安装软件包。如果你需要安装测试框架，例如 `pytest` 或 `Mocha`，可以在此步骤执行此操作。'
- en: 'b. `pre-build`: These are commands that happen before the actual build command
    is run. Pre-build commands can include signing into an `Build`: At this part of
    the phase, these are the commands that are run during the build. These can be
    commands that build the software, create a container, or create commands that
    test the software.'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. `pre-build`：这是在实际构建命令运行之前执行的命令。预构建命令可以包括登录到 `Build`：在此阶段，会运行一些构建命令、创建容器，或者执行测试软件的命令。
- en: 'd. `post-build`: Once the build has been completed, these are any commands
    that are performed afterward, which can include packaging up the software in a
    `.jar` or `.war` file, or creating a Python egg file. It can even involve uploading
    a container to a repository such as ECR or DockerHub.'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. `post-build`：一旦构建完成，这些是随后的命令，可以包括将软件打包成 `.jar` 或 `.war` 文件，或创建 Python 的 egg
    文件。它甚至可能涉及将容器上传到 ECR 或 DockerHub 等仓库。
- en: '**Artifacts**: This is the build output. This can include the names of the
    files, the actual files themselves, or both. The artifacts phase also allows you
    to keep the directory structure where the files have been created or strip that
    away so that you just have the files themselves.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Artifacts**：这是构建输出。这可以包括文件的名称、文件本身，或两者兼有。工件阶段还允许你保留文件创建时的目录结构，或者将其去除，仅保留文件本身。'
- en: There are quite a few other options that are available in the `buildspec` file,
    depending on your use case. You can use environment variables, create reports,
    and even run as a specific user or a Linux operating system. For a complete list
    of options, please reference the AWS build spec documentation available at [https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html](https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的使用场景，`buildspec` 文件中还提供了许多其他选项。你可以使用环境变量、生成报告，甚至以特定用户或 Linux 操作系统身份运行。完整选项列表，请参考
    AWS 构建规范文档：[https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html](https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html)。
- en: We just took a deeper look at constructing `buildspec` files and what components
    they comprise. Next, we will concentrate on the artifacts that CodeBuild produces
    and how to export them and store them elsewhere.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚深入了解了如何构建 `buildspec` 文件以及它包含的组件。接下来，我们将重点讨论 CodeBuild 生成的工件，以及如何将它们导出并存储到其他地方。
- en: Storing CodeBuild artifacts
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储 CodeBuild 工件
- en: When you create a software package, you can have AWS CodeBuild automatically
    save this artifact into an S3 bucket for use during deployments.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个软件包时，可以让 AWS CodeBuild 自动将该工件保存到 S3 存储桶中，以便在部署过程中使用。
- en: Inside of your `buildspec` file, if you are looking to create artifacts, you
    can declare just one artifact, or you can declare multiple artifacts. In the *Creating
    a CodeBuild job* section, the `buildspec` file had one artifact declared at the
    end.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `buildspec` 文件中，如果你打算创建工件，你可以声明一个工件，也可以声明多个工件。在 *创建 CodeBuild 作业* 部分，`buildspec`
    文件在最后声明了一个工件。
- en: Note
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While the name CodeArtifact may lead you to believe that you can automatically
    store CodeBuild artifacts after a build, you can't. CodeArtifact can be used in
    conjunction with CodeBuild by supplying language packages just like a **NuGet**,
    **PyPi**, or **npm server** would do during the build process so that your team
    can have standardized packages and forgo download limits from public servers.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 CodeArtifact 的名称可能会让您认为可以在构建后自动存储 CodeBuild 构建产物，但实际上不能。CodeArtifact 可以与
    CodeBuild 配合使用，提供语言包，就像 **NuGet**、**PyPi** 或 **npm 服务器** 在构建过程中提供的那样，帮助您的团队使用标准化的包，并避免来自公共服务器的下载限制。
- en: Using CodeBuild to test
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 CodeBuild 进行测试
- en: While the first use of AWS CodeBuild that comes to mind may be creating packages
    for deployment and building Docker containers, this service also can serve a dual
    function in the SDLC process, and that is for testing. CodeBuild allows you to
    run the predefined unit tests and see reports of both a graphical and textual
    nature in the console regarding the results of those tests.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然人们首先想到使用 AWS CodeBuild 可能是为了创建用于部署的包和构建 Docker 容器，但这个服务还可以在软件开发生命周期（SDLC）过程中发挥双重功能，那就是进行测试。CodeBuild
    允许您运行预定义的单元测试，并在控制台中查看图形和文本形式的报告，了解测试结果。
- en: Reports expire after 30 days of creation and once they have expired, you nor
    anyone else with access to the report can view the report. If you need to keep
    the results of a report for more than 30 days, then you have the option to export
    the raw results of the report to an S3 bucket, where they will not expire and
    will only be phased out based on the bucket's life cycle policy.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 报告在创建后30天过期，一旦过期，您和任何有权限访问报告的人都无法查看报告。如果您需要将报告的结果保留超过30天，您可以选择将报告的原始结果导出到S3存储桶中，这样它们就不会过期，只会根据存储桶的生命周期策略逐步淘汰。
- en: 'CodeBuild supports the following test report file formats:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: CodeBuild 支持以下测试报告文件格式：
- en: Cucumber JSON
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cucumber JSON
- en: Junit XML
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Junit XML
- en: NUnit XML
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NUnit XML
- en: TestNG XML
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TestNG XML
- en: Visual Studio TRX
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio TRX
- en: Specifying a report group name in your `buildspec` file with information about
    your test cases allows CodeBuild to create a report group for you if one doesn't
    already exist.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 `buildspec` 文件中指定一个报告组名称，并提供关于测试用例的信息，如果尚未存在，CodeBuild 会为您创建一个报告组。
- en: Once tests have been created, AWS CodeBuild can show reports on the console,
    providing a quick summary of the status of all of our tests.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 测试创建后，AWS CodeBuild 可以在控制台上显示报告，快速总结所有测试的状态。
- en: Triggering CodeBuild jobs via CodeCommit
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 CodeCommit 触发 CodeBuild 作业
- en: AWS CodeCommit can be used as the input source for the build. CodeCommit by
    itself cannot natively signal to CodeBuild that it has received either a new commit
    or a merge into a branch. However, with the help of the Lambda service, you can
    add a trigger that will initiate the CodeBuild job.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CodeCommit 可以用作构建的输入源。CodeCommit 本身不能原生地向 CodeBuild 发出信号，告诉它已经收到新的提交或合并到分支中。然而，借助
    Lambda 服务，您可以添加触发器来启动 CodeBuild 作业。
- en: 'Having an automated process such as this without any manual intervention helps
    teams find bugs, along with deployed software, in a more expedient fashion. Creating
    a trigger that automatically signals the CodeBuild project to kick off the build
    is a great way to add continuous feedback to your **Software Development Life
    Cycle** (**SDLC**):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有像这样的自动化过程，无需手动干预，帮助团队更迅速地找到 bug 和已部署的软件。创建一个触发器，自动向 CodeBuild 项目发出信号启动构建，是为您的**软件开发生命周期**（**SDLC**）添加持续反馈的好方法：
- en: '![Figure 8.23 – Triggering a CodeBuild job from CodeCommit'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.23 – 从 CodeCommit 触发 CodeBuild 作业'
- en: '](img/Figure_8.23_B17405.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.23_B17405.jpg)'
- en: Figure 8.23 – Triggering a CodeBuild job from CodeCommit
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.23 – 从 CodeCommit 触发 CodeBuild 作业
- en: Now that we have looked at how to start a CodeBuild job using the CodeCommit
    service automatically, we know how to automatically start CodeBuild jobs as soon
    as new code has been successfully merged into the project.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使用 CodeCommit 服务自动启动 CodeBuild 作业，我们也知道如何在新代码成功合并到项目中时自动启动 CodeBuild
    作业。
- en: In the next chapter, [*Chapter 9*](B17405_09_Final_JM_ePub.xhtml#_idTextAnchor237),
    *Deploying Workloads with CodeDeploy and CodePipeline*, we will learn how the
    CodePipeline service can also be used to start a build process from CodeCommit.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[*第9章*](B17405_09_Final_JM_ePub.xhtml#_idTextAnchor237)，*使用 CodeDeploy
    和 CodePipeline 部署工作负载* 中，我们将学习如何使用 CodePipeline 服务启动来自 CodeCommit 的构建过程。
- en: Next, we will look at some of the advanced features of AWS CodeBuild.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将了解 AWS CodeBuild 的一些高级功能。
- en: Advanced features of AWS CodeBuild
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AWS CodeBuild 的高级功能
- en: Some of the features we will talk about in this section aren't mandatory for
    the DevOps professional exam. Since this book has *beyond* in its title, the following
    are some helpful features that can make using the service a bit easier. They are
    also good tips that you can share with teammates and clients.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中我们将讨论的一些功能对于 DevOps 专业考试不是强制要求的。由于本书标题中有 *beyond*，以下是一些有助于让服务使用更便捷的功能。它们也是一些可以与团队成员和客户分享的好技巧。
- en: Using AWS Session Manager to help troubleshoot builds
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 AWS Session Manager 帮助排查构建问题
- en: 'If you are trying to troubleshoot builds, then rather than looking up a way
    to `ssh` into the AWS-based docker images session manager, AWS Session Manager
    will allow you to jump into the build and try and troubleshoot what is happening.
    You can pause your build by adding `codebuild-breakpoint` to your `buildspec`
    file:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在排查构建问题时遇到困难，而不是寻找 `ssh` 进入基于 AWS 的 Docker 镜像会话管理器，AWS Session Manager 将允许你进入构建环境并尝试排查发生了什么。你可以通过在
    `buildspec` 文件中添加 `codebuild-breakpoint` 来暂停构建：
- en: '[PRE20]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once you have finished troubleshooting, you can pass `codebuild-resume` via
    the Command Prompt to pick up where you left off in your `buildspec` file.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 完成故障排除后，你可以通过命令提示符传递 `codebuild-resume`，以便从 `buildspec` 文件中中断的位置继续。
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at how we can get our teams to share code using the
    AWS native source code tool CodeCommit. We also looked at how to package, build,
    and test our software using the CodeBuild tool.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们讨论了如何使用 AWS 原生的源代码工具 CodeCommit 让团队共享代码。我们还探讨了如何使用 CodeBuild 工具对软件进行打包、构建和测试。
- en: In the next chapter, we will continue looking at **AWS Developer Tools**. This
    includes using CodeDeploy to deploy workloads and then tying everything together
    using AWS CodePipeline.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续讨论 **AWS Developer Tools**。这包括使用 CodeDeploy 部署工作负载，然后通过 AWS CodePipeline
    将一切串联起来。
- en: Review questions
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习题
- en: You have been asked to set up a CodeCommit repository for your organization
    for the development team. The developers need the ability to push commits to their
    branches but not merge commits to the main branch, nor push commits to the main
    branch. The project manager also needs to be notified whenever a merge or a commit
    to the main branch occurs. Which combination of steps will safeguard the master
    branch and send the notification in the shortest time possible?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你被要求为你的组织设置一个 CodeCommit 仓库，供开发团队使用。开发人员需要能够将提交推送到他们的分支，但不能将提交合并到主分支，也不能将提交推送到主分支。项目经理还需要在合并或提交到主分支时收到通知。哪个步骤组合能以最短时间保护主分支并发送通知？
- en: a. Attach a resource policy to the CodeCommit repository that denies members
    of the IAM developer group actions of pushing commits, merging requests, and adding
    files to the main branch.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为 CodeCommit 仓库附加一个资源策略，拒绝 IAM 开发者组成员对主分支执行推送提交、合并请求和添加文件的操作。
- en: b. Affix an IAM policy to the developer IAM developer group that denies the
    actions of pushing commits, merging requests, and adding files to the main branch.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 为开发者 IAM 开发者组附加一项 IAM 策略，拒绝其对主分支执行推送提交、合并请求和添加文件的操作。
- en: c. Configure AWS CloudTrail to send log events to send logs events to Amazon
    CloudWatch logs. Create a CloudWatch alarm based on a defined metric filter to
    identify CodeCommit Repository events. Use an SNS topic as a target that the project
    manager is subscribed to for the CloudWatch Alarm.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 配置 AWS CloudTrail 将日志事件发送到 Amazon CloudWatch 日志。创建一个基于定义的度量标准过滤器的 CloudWatch
    警报，以识别 CodeCommit 仓库事件。使用 SNS 主题作为目标，项目经理已订阅该主题以接收 CloudWatch 警报。
- en: d. Create an Amazon CloudWatch Events rule that's triggered by a CodeCommit
    Repository State Change event by the main branch. Use an SNS topic that the project
    manager is subscribed to for the target.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 创建一个 Amazon CloudWatch Events 规则，该规则会在主分支的 CodeCommit 仓库状态更改事件触发时运行。使用一个项目经理已订阅的
    SNS 主题作为目标。
- en: e. Create a Lambda function to check for repository changes that will be sent
    to an SNS topic that the project manager is subscribed to if changes are found.
    Have AWS CloudWatch Events run the Lambda every 15 minutes.
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: e. 创建一个 Lambda 函数，检查仓库的变更，如果发现变更，则将事件发送到项目经理已订阅的 SNS 主题。让 AWS CloudWatch Events
    每 15 分钟运行一次 Lambda。
- en: You have a CodeCommit repository in your account that your developers have a
    limited set of actions for. Two new developers from a different Organizational
    Unit need to access this CodeCommit repository, but their users are based in a
    different AWS account. What is the most effective way to grant these new developers
    access?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在账户中有一个 CodeCommit 代码库，开发者对该代码库有有限的操作权限。来自不同组织单元的两位新开发者需要访问这个 CodeCommit 代码库，但他们的用户位于不同的
    AWS 账户中。授予这两位新开发者访问权限的最有效方式是什么？
- en: a. Enable public access for the repository.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 为代码库启用公开访问权限。
- en: b. Create IAM users for each new developer and then grant them access to the
    repository.
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 为每个新开发者创建 IAM 用户，并授予他们对代码库的访问权限。
- en: c. Create an IAM group for the external developers, add the IAM users, and then
    provide access to the repository.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 为外部开发者创建一个 IAM 组，添加 IAM 用户，然后为其提供对代码库的访问权限。
- en: d. Create a cross-account role in your account, assign the necessary privileges
    to the role. and then provide the role ARN to the developers so that they can
    assume the role.
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 在你的账户中创建一个跨账户角色，为该角色分配必要的权限，然后将角色 ARN 提供给开发者，以便他们可以假设该角色。
- en: A client is looking for a new code versioning service and no longer wants the
    management hassle of running his servers. Currently, his team is small and not
    looking to grow exponentially over the next four quarters, but he is extremely
    concerned about the encryption abilities of any service he considers. What can
    you explain to him regarding AWS CodeCommit's ability to protect objects and code
    with encryption?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一位客户正在寻找一个新的代码版本控制服务，并且不再希望管理自己服务器的麻烦。目前，他的团队规模较小，预计在接下来的四个季度不会急剧增长，但他非常关注任何他考虑的服务是否具备加密功能。关于
    AWS CodeCommit 如何保护对象和代码的加密能力，你能向他解释什么？
- en: a. All transmissions are encrypted in transit and can only be done through the
    HTTPS or `SSH` protocols.
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 所有传输内容在传输过程中都是加密的，并且只能通过 HTTPS 或 `SSH` 协议进行。
- en: b. Transmissions are encrypted in transit when sent through the `SSH` protocol.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 通过 `SSH` 协议发送时，传输内容在传输过程中是加密的。
- en: c. CodeCommit repositories are automatically encrypted using KMS.
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. CodeCommit 代码库会自动使用 KMS 进行加密。
- en: d. CodeCommit repositories can be encrypted using KMS.
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. CodeCommit 代码库可以使用 KMS 进行加密。
- en: You are setting up a new build process that is using S3 as the source of the
    code. You want to have unit tests run against the code that you and other developers
    have previously created and placed in a directory called `test/`, which is located
    in the child directory in the main source code directory. You plan to work on
    this build process for 60 days and want to be able to view the historical test
    reports, even from the first build. How can you configure this with native AWS
    services?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你正在设置一个新的构建过程，使用 S3 作为代码源。你希望对你和其他开发者之前创建并放置在名为 `test/` 的目录中的代码进行单元测试，该目录位于主源代码目录的子目录中。你计划在这个构建过程中工作
    60 天，并希望能够查看历史的测试报告，甚至是第一次构建的报告。你如何通过原生 AWS 服务配置这一过程？
- en: a. The test reports will be available in the `buildspec` file.
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 测试报告将在 `buildspec` 文件中提供。
- en: b. Export the CodeBuild test data to S3 after every build and use AWS QuickSight
    to create the test reports.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 在每次构建后将 CodeBuild 测试数据导出到 S3，并使用 AWS QuickSight 创建测试报告。
- en: c. The test reports will be available in the Reports tab of the CodeBuild section
    of the console if you specify a report section in your `buildspec` file. Create
    a Lambda function that is triggered by CloudWatch events to export the raw data
    from the test reports that will be saved to an S3 bucket and available to be reviewed.
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 如果你在 `buildspec` 文件中指定了报告部分，则测试报告将可在控制台的 CodeBuild 部分的 Reports 选项卡中查看。创建一个
    Lambda 函数，该函数由 CloudWatch 事件触发，导出从测试报告中获取的原始数据，并将其保存到 S3 存储桶中，供后续查看。
- en: d. This is not possible with native AWS services.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 使用原生的 AWS 服务无法实现此操作。
- en: Review answers
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看答案
- en: b, d
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b, d
- en: d
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: a, c
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a, c
- en: c
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
