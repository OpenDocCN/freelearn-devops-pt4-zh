- en: 'Chapter 9: Deploying Workloads with CodeDeploy and CodePipeline'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章：使用 CodeDeploy 和 CodePipeline 部署工作负载
- en: Teams are looking for an easy-to-use tool that allows the automation of the
    release process and gives a consistent release process. We will look at incorporating
    **CodePipeline** and the third-party tool Jenkins to automate our deployments'
    release cycle, which can then integrate into **CodeDeploy** for the actual code
    deployments.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 团队们正在寻找一种易于使用的工具，能够自动化发布过程，并提供一致的发布流程。我们将介绍如何将**CodePipeline**与第三方工具 Jenkins
    结合，来自动化我们的部署发布周期，进而与**CodeDeploy**集成，实现实际的代码部署。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论以下主要内容：
- en: About AWS CodePipeline
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 AWS CodePipeline
- en: Setting up a code pipeline
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置代码管道
- en: Using Jenkins to build your workloads
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jenkins 构建工作负载
- en: About AWS CodeDeploy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 AWS CodeDeploy
- en: Use cases for AWS CodeDeploy
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CodeDeploy 使用案例
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: If you plan to follow along with the exercises in this chapter, there are some
    dependencies in the previous chapter, [*Chapter 8*](B17405_08_Final_JM_ePub.xhtml#_idTextAnchor212),
    *Creating Workloads with CodeCommit and CodeBuild*. Just as in the real world,
    we are building on what we have previously started in earlier chapters. Hence,
    if you have not created a developer user from the previous chapter, you will need
    to do so with the corresponding **Identity and Access Management** (**IAM**) permissions
    in their group.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算跟随本章中的练习进行操作，需要注意，前一章的内容 [*第 8 章*](B17405_08_Final_JM_ePub.xhtml#_idTextAnchor212)，《使用
    CodeCommit 和 CodeBuild 创建工作负载》是本章的前提。如同现实世界中一样，我们在前面章节中所做的工作基础上继续构建。因此，如果你没有在上一章创建开发者用户，你需要为该用户设置相应的**身份与访问管理**（**IAM**）权限。
- en: About AWS CodePipeline
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于 AWS CodePipeline
- en: AWS CodePipeline can be thought of as a conductor in an orchestra. Using either
    code or the AWS console, you can put together your software development life cycle
    process in a visual representation that is either fully automated or has manual
    checks along the way for certain stages to be passed. This whole process is then
    laid out visually for your team members (including developers, testers, and others)
    to see which deployments happened and which deployments failed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CodePipeline 可以被看作是一个管弦乐团中的指挥。通过代码或 AWS 控制台，你可以将软件开发生命周期过程以可视化方式组织起来，过程可以是完全自动化的，也可以在某些阶段设置手动检查，确保每个阶段顺利通过。整个过程会以图形化的方式呈现给你的团队成员（包括开发者、测试人员和其他人员），让他们了解哪些部署成功，哪些部署失败。
- en: 'AWS CodePipeline helps you automate the steps you require to release your software
    and infrastructure changes in a continuous manner, as illustrated in the following
    diagram:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CodePipeline 帮助你自动化发布软件和基础设施更改的步骤，实现持续交付，如下图所示：
- en: '![Figure 9.1 – CodePipeline and its integration with other AWS developer tools'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.1 – CodePipeline 及其与其他 AWS 开发工具的集成'
- en: '](img/Figure_9.1_B17405.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.1_B17405.jpg)'
- en: Figure 9.1 – CodePipeline and its integration with other AWS developer tools
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – CodePipeline 及其与其他 AWS 开发工具的集成
- en: The different AWS developer services, which CodePipeline is one of, are depicted
    in *Figure 9.1* and shown underneath their respected stages in the **Systems Development
    Life Cycle** (**SDLC**).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的 AWS 开发服务，其中 CodePipeline 是其中之一，如*图 9.1*所示，并展示在**系统开发生命周期**（**SDLC**）的各个阶段下。
- en: CodePipeline structure for actions
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CodePipeline 动作结构
- en: CodePipeline is structured into several different categories that allow either
    native AWS services to act or allow a supported third-party service to be integrated
    and perform the necessary action.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: CodePipeline 结构包括几个不同的类别，允许原生 AWS 服务进行操作，或允许支持的第三方服务集成并执行必要的操作。
- en: 'There are six valid action categories, as listed here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了六个有效的动作类别：
- en: Source
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源
- en: Build
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建
- en: Test
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Deploy
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署
- en: Approval
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审批
- en: Invoke
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用
- en: 'Each of the action categories has its own set of providers that can invoke
    actions or have actions invoked from that resource, as outlined in the following
    table:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每个动作类别都有一组可以调用动作或允许从该资源调用动作的提供者，如下表所示：
- en: '![Table 9.1 – CodePipeline source actions and action providers'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 9.1 – CodePipeline 源动作和动作提供者'
- en: '](img/014.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/014.jpg)'
- en: Table 9.1 – CodePipeline source actions and action providers
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.1 – CodePipeline 源动作和动作提供者
- en: 'In addition to the action integrations, a few other AWS services integrate
    without any specific action category, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了动作集成外，还有一些其他 AWS 服务无需特定的动作类别即可集成，具体如下：
- en: '**Amazon CloudWatch**: CloudWatch can monitor your resources that are built
    with the pipeline or are being tested and integrated into the pipeline.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon CloudWatch**：CloudWatch 可以监控使用管道构建的资源，或者监控正在测试并集成到管道中的资源。'
- en: '**Amazon CloudWatch Events**: CloudWatch Events can detect changes to your
    pipeline as a whole or even at certain stages of your pipeline. CloudWatch Events
    can even listen to other outside services and then trigger a CodePipeline run
    if specific scenarios happen, such as if someone updated a CloudFormation stack.
    This would then create a need for the software to be redeployed.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon CloudWatch Events**：CloudWatch Events 可以检测整个管道的变化，甚至可以检测管道某些阶段的变化。CloudWatch
    Events 甚至可以监听其他外部服务，并在特定情境发生时触发 CodePipeline 运行，例如当有人更新了 CloudFormation 堆栈时。这时可能需要重新部署软件。'
- en: '**AWS Cloud9**: Cloud9 is the cloud-based **integrated development environment**
    (**IDE**) that is accessible via a web browser.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS Cloud9**：Cloud9 是一种基于云的**集成开发环境**（**IDE**），可以通过网页浏览器访问。'
- en: '**AWS CloudTrail**: If the CloudTrail service is active for the particular
    region, any **application programming interface** (**API**) actions that happen
    via the AWS console, **software development kits** (**SDKs**), or **command-line
    interface** (**CLI**) are captured and recorded.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS CloudTrail**：如果 CloudTrail 服务在特定区域处于激活状态，任何通过 AWS 控制台、**软件开发工具包**（**SDK**）或**命令行接口**（**CLI**）进行的**应用程序编程接口**（**API**）操作都会被捕获并记录。'
- en: '**AWS KMS**: **Key Management Service** (**KMS**) can be integrated with AWS
    CodePipeline for source S3 buckets and artifacts, which either are encrypted or
    need to be encrypted. Suppose the artifacts are coming from an account other than
    the one where the CodePipeline is being executed. In that case, the key that is
    encrypting the bucket and objects will need to be a customer-managed key.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS KMS**：**密钥管理服务**（**KMS**）可以与 AWS CodePipeline 集成，用于源 S3 存储桶和工件，这些存储桶和工件要么是加密的，要么需要加密。假设工件来自与执行
    CodePipeline 的帐户不同的帐户，那么加密该存储桶和对象的密钥将需要是客户管理的密钥。'
- en: Looking at *Table 9.1*, you can see that there is a combination of both native
    AWS services and specialized third-party partner tools that you may already be
    using to integrate into your code pipeline stages.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从*表 9.1*中可以看到，既有原生的 AWS 服务，也有您可能已经在使用的第三方合作伙伴工具，这些工具可以集成到您的代码管道阶段中。
- en: We have just looked at the different actions along with their corresponding
    AWS services and third-party services that can help perform those actions. Next,
    we will look at some of the use cases for AWS CodePipeline, including real-world
    use cases.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚查看了不同的操作以及相应的 AWS 服务和第三方服务，这些服务可以帮助执行这些操作。接下来，我们将看看一些 AWS CodePipeline 的使用案例，包括真实世界的使用案例。
- en: Use cases for AWS CodePipeline
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AWS CodePipeline 的使用案例
- en: When thinking about what you can do with CodePipeline, there are specific scenarios
    that have already identified that CodePipeline is an optimal fit as a tool. Let's
    take a look at some of these next.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑使用 CodePipeline 能做什么时，有一些特定场景已经确定 CodePipeline 作为工具是最合适的选择。接下来我们将看看这些场景中的一些。
- en: Automation of your build and release process
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动化您的构建和发布过程
- en: CodePipeline allows your developers to concentrate on the code they are working
    on and then commit that code to either an Amazon-hosted repository or a third-party
    repository such as GitHub or Bitbucket Cloud. The push of a new code commit by
    a developer can then trigger the build process.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: CodePipeline 允许开发人员专注于他们正在编写的代码，然后将代码提交到 Amazon 托管的代码库或第三方代码库，如 GitHub 或 Bitbucket
    Cloud。开发人员推送的新代码提交将触发构建过程。
- en: Creating a consistent toolset for developers to use
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为开发人员创建一致的工具集
- en: One of the most challenging parts of getting a new developer up and productive
    quickly in an organization is the onboarding process. CodePipeline helps with
    this process by presenting a consistent toolset no matter which time zone a team
    member is in or the operating system that they are using.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在组织中让新开发人员快速上手并提高生产力的最具挑战性部分之一是入职过程。CodePipeline 通过提供一致的工具集来帮助这个过程，无论团队成员位于哪个时区，或使用什么操作系统。
- en: Using CodePipeline to integrate with third-party providers
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 CodePipeline 与第三方提供商集成
- en: Suppose your team currently uses third-party tools such as Jenkins for the code
    build or testing process, BlazeMeter for the load testing process, or StormRunner
    for the testing process. In that case, CodePipeline can help present a unified
    orchestration front for all of these tools.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的团队当前使用像Jenkins这样的第三方工具进行代码构建或测试，BlazeMeter进行负载测试，或StormRunner进行测试过程，那么CodePipeline可以帮助将所有这些工具统一协调展示。
- en: There can also be a cost-savings aspect in using only one service account called
    from the CodePipeline service rather than each individual or individual team requesting
    their own license.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个服务账户从CodePipeline服务中调用，而不是每个个人或团队请求自己的许可证，也可能会带来成本节约的好处。
- en: Continuously deploy your web applications with Elastic Beanstalk and CodePipeline
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Elastic Beanstalk和CodePipeline持续部署你的Web应用程序
- en: Although Elastic Beanstalk is many times looked upon as a service which helps
    developers who minimal exposure to AWS infrastructure items to get their code
    up and running quickly, those items of code can become successful items in an
    organization. The incorporation of CodePipeline allows to take the reliance away
    from the Elastic Beanstalk CLI or try to track down deployments in the AWS Management
    Console and allow for a more structured and trackable approach.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Elastic Beanstalk常被认为是一个帮助开发者快速启动代码、并且接触较少AWS基础设施的服务，但这些代码可以成为组织中的成功项目。集成CodePipeline使得不再依赖于Elastic
    Beanstalk CLI或在AWS管理控制台中追踪部署，而是采用一种更结构化、可追踪的方式。
- en: Now that we have examined a few of the various use cases where CodePipeline
    can be used successfully, we can now go on to our hands-on example. This is where
    we will go through the steps of setting up our own AWS CodePipeline that utilizes
    a CodeCommit repository.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检查了一些CodePipeline成功使用的不同场景，接下来我们可以进入实际操作示例。在这里，我们将按照步骤设置我们自己的AWS CodePipeline，并利用CodeCommit仓库。
- en: Setting up a code pipeline
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置代码管道
- en: One of the best ways to get a feel for AWS CodePipeline is to go through the
    exercise of setting up a code pipeline. Many times, it will be those designated
    tools' team members who will set up the pipelines. These **tools** team members
    have a unique set of permissions that differ from that of developers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 体验AWS CodePipeline的最佳方法之一是通过设置代码管道的练习。通常，这些管道的设置工作会由指定工具的团队成员完成。这些**工具**团队成员拥有与开发人员不同的独特权限集。
- en: We will need to set up our tools team group and assign them the correct permission
    set. After this, we can create a tools team member and associate them with the
    tools team IAM group. Then, we can log in as that tools team member and have them
    build out the pipeline.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设置工具团队组并为他们分配正确的权限集。之后，我们可以创建工具团队成员并将其关联到工具团队IAM组。然后，我们可以以该工具团队成员身份登录，并让他们构建管道。
- en: Creating our code base prior to setting up the pipeline
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在设置管道之前创建我们的代码库
- en: We are going to set up a brand new CodeCommit repository before setting up our
    code pipeline. Creating the repository beforehand will allow us to have a fresh
    set of code to use to run through the steps of our pipeline.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置我们的代码管道之前，我们将先创建一个全新的CodeCommit仓库。事先创建仓库将使我们能够拥有一套新的代码，用来执行管道中的各个步骤。
- en: 'In the `chapter9` section of our GitHub repository, there will be a folder
    named `code`. This folder will hold the source code that we will need to upload
    to the CodeCommit repository we are about to create using the following steps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们GitHub仓库的`chapter9`部分，会有一个名为`code`的文件夹。这个文件夹将包含我们需要上传到即将创建的CodeCommit仓库的源代码，具体步骤如下：
- en: Open your browser to the AWS CodeCommit home page, [https://console.aws.amazon.com/codesuite/codecommit/home](https://console.aws.amazon.com/codesuite/codecommit/home),
    and sign in if prompted.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器，访问AWS CodeCommit首页，[https://console.aws.amazon.com/codesuite/codecommit/home](https://console.aws.amazon.com/codesuite/codecommit/home)，如果出现提示，请登录。
- en: Click the orange **Create repository** button on the top right-hand side of
    the screen.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击屏幕右上方的橙色**创建仓库**按钮。
- en: On the `chapt9` for the name of the repository. We will add a description that
    this repository is for `CodePipeline` to distinguish it from the `chapt8` repository,
    which we created as a test in the previous chapter, [*Chapter 8*](B17405_08_Final_JM_ePub.xhtml#_idTextAnchor212),
    *Creating Workloads with CodeCommit and CodeBuild*, as illustrated in the following
    screenshot:![Figure 9.2 – CodeCommit repository settings for chapt9 repository
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chapt9`中设置仓库名称。我们将添加描述，说明这个仓库是用于`CodePipeline`的，以便与在上一章节中创建的`chapt8`仓库区分开来，后者是作为测试创建的，参见[*第8章*](B17405_08_Final_JM_ePub.xhtml#_idTextAnchor212)，*使用CodeCommit和CodeBuild创建工作负载*，如以下截图所示：![图9.2
    – chapt9仓库的CodeCommit仓库设置
- en: '](img/Figure_9.2_B17405.jpg)'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_9.2_B17405.jpg)'
- en: Figure 9.2 – CodeCommit repository settings for chapt9 repository
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.2 – chapt9仓库的CodeCommit仓库设置
- en: Click the orange **Create** button.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击橙色的**创建**按钮。
- en: Since we have already created a user that can upload files in [*Chapter 8*](B17405_08_Final_JM_ePub.xhtml#_idTextAnchor212),
    *Creating Workloads with CodeCommit and CodeBuild*, simply click on the **Repositories**
    menu item in the left-hand menu, as illustrated in the following screenshot. This
    will bring up the names of all the repositories that we have in CodeCommit and
    will allow us to copy the link we need to clone the repository locally to our
    workstation:![Figure 9.3 – The side menu on CodeCommit with Repositories highlighted
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经在[*第8章*](B17405_08_Final_JM_ePub.xhtml#_idTextAnchor212)中创建了一个可以上传文件的用户，*使用CodeCommit和CodeBuild创建工作负载*，现在只需点击左侧菜单中的**Repositories**（仓库）菜单项，如以下截图所示。这样就会显示我们在CodeCommit中的所有仓库名称，并允许我们复制需要的链接，以便将仓库克隆到本地工作站：![图9.3
    – CodeCommit的侧边菜单，仓库部分高亮显示
- en: '](img/Figure_9.3_B17405.jpg)'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_9.3_B17405.jpg)'
- en: Figure 9.3 – The side menu on CodeCommit with Repositories highlighted
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.3 – CodeCommit的侧边菜单，仓库部分高亮显示
- en: Now, click on the link labeled `SSH`, to the right of the `chapt9` repository,
    as illustrated in the following screenshot. This will pop up a small dialog box
    confirming that the link has been copied and you are ready to clone the repository
    to your local workstation:![Figure 9.4 – SSH cloning Uniform Resource Locator
    (URL) copied to clipboard
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击`chapt9`仓库右侧的`SSH`链接，如以下截图所示。此时会弹出一个小对话框，确认该链接已被复制，你可以准备将仓库克隆到本地工作站：![图9.4
    – 已复制到剪贴板的SSH克隆统一资源定位符（URL）
- en: '](img/Figure_9.4_B17405.jpg)'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_9.4_B17405.jpg)'
- en: Figure 9.4 – SSH cloning Uniform Resource Locator (URL) copied to clipboard
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.4 – 已复制到剪贴板的SSH克隆统一资源定位符（URL）
- en: At this point, we are done with the AWS console for the moment, and we will
    move on for the next set of commands to the terminal on your local workstation.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此时，我们暂时完成了AWS控制台的操作，接下来将切换到本地工作站的终端，进行下一组命令操作。
- en: 'Now, with your terminal open, go to the root of your home directory. In Linux,
    you can get there quickly with the `$cd ~` command. Next, perform the following
    command to clone the repository locally. Now, we can use the URL on our clipboard
    to clone into the repository:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开终端，进入到你的主目录根目录。在Linux系统中，你可以通过`$cd ~`命令快速进入该目录。接下来，执行以下命令将仓库克隆到本地。现在，我们可以使用剪贴板中的URL来克隆仓库：
- en: '[PRE0]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once you have successfully cloned into the repository, then you should get a
    confirmation message stating that you have cloned into an empty repository.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦你成功克隆了仓库，你应该会收到一条确认消息，表示你已经克隆到一个空的仓库。
- en: Even though we have an empty repository, we are going to take the example code
    from the GitHub repository in the `/code` directory and then copy (or move it
    if you don't want two copies of the code on your local machine) to this new local
    `CodeCommit` repository so that we can push it up to `CodeCommit`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管我们有一个空的代码库，我们将从GitHub仓库的`/code`目录中获取示例代码，然后将其复制（或者如果你不希望在本地机器上有两个代码副本，可以选择移动）到这个新的本地`CodeCommit`仓库，这样我们就可以将其推送到`CodeCommit`。
- en: 'Make sure that you are starting from the directory where you have cloned the
    example code from GitHub, as illustrated in the following code snippet:'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保你从已经克隆了GitHub示例代码的目录开始，如以下代码片段所示：
- en: '[PRE1]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you don't want to copy the files via the command line you could also use
    either File Explorer or Finder to make a copy of the files into your new git repository.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你不想通过命令行复制文件，也可以使用文件资源管理器（File Explorer）或Finder，将文件复制到新的git仓库中。
- en: 'Now that we have copied the files over to the `CodeCommit` local directory,
    we need to add all of them to the commit. After adding them and the `commit` message,
    we will push the files up to the repository. We can do all of this in just a few
    simple commands. First, we will need to change directories from where we cloned
    the example code to our local `CodeCommit` repository, as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将文件复制到`CodeCommit`本地目录中，接下来我们需要将所有文件添加到提交中。添加文件并编写`commit`消息后，我们将文件推送到代码库。我们可以通过几个简单的命令完成这一切。首先，我们需要从克隆的示例代码所在的目录切换到本地`CodeCommit`代码库，如下所示：
- en: '[PRE2]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Since we are in our local directory, we can now add all of the files and then
    push them up to the remote `CodeCommit` repository. We do this by using the `git
    add`, `git commit`, and `git push` commands, like this:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们当前在本地目录中，我们现在可以添加所有文件并将其推送到远程的`CodeCommit`代码库。我们通过使用`git add`、`git commit`和`git
    push`命令来完成，操作如下：
- en: '[PRE3]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, with our sample code ready, we are prepared to move on to the next step,
    which is creating our tools team member. Our tools team member is the person on
    our team who focuses on creating and managing the pipelines and processes more
    than the code itself.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，示例代码已经准备好，我们可以继续进行下一步，即创建工具团队成员。我们的工具团队成员是专注于创建和管理管道及流程的人，而不仅仅是编写代码的人。
- en: Creating our tools team member
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的工具团队成员
- en: Just as we had previously created our development group and member, we will
    need to do the same thing for our tools team member. It is important to separate
    the duties of our team members and give each person only the privileges they need
    to perform their job duties. After creating our tools member, we will then log
    in as that tools teams member and then run the CloudFormation template named `pipeline1.yml`
    as this tools team member to construct the pipeline.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前创建了开发组和成员一样，我们也需要为工具团队成员做同样的事情。重要的是要区分团队成员的职责，并只赋予每个人执行其工作职责所需的权限。在创建工具成员之后，我们将以该工具团队成员的身份登录，然后运行名为`pipeline1.yml`的CloudFormation模板来构建管道。
- en: 'Let''s go ahead and set up the group for our tools team member, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续设置工具团队成员的组，如下所示：
- en: 'Open up your terminal and type the following commands so that we can create
    our new group:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的终端并输入以下命令，以便我们创建新的组：
- en: '[PRE4]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After running the command, you should see a confirmation like the one shown
    next:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行命令后，你应该看到类似下面的确认信息：
- en: '[PRE5]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Take note of the ARN which is returned for the group name. You will either need
    to save this to a note pad or scroll up to copy and paste this when we attach
    the policy which we create next to this group
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意返回的组名称对应的ARN。你需要将其保存到记事本中，或者滚动到上方进行复制和粘贴，方便我们下一步将创建的策略附加到该组时使用。
- en: 'Next, we will need to create our policy using the pre-made policy document
    that you should have downloaded from the GitHub repository in the `Chapter9` folder
    named `IAM_Tools.json`, as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用预先制作的策略文档来创建策略，该文档应该已从GitHub仓库的`Chapter9`文件夹中下载，文件名为`IAM_Tools.json`，如下所示：
- en: '[PRE6]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '{'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '"Policy": {'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"Policy": {'
- en: '"PolicyName": "Tools_Members",'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"PolicyName": "Tools_Members",'
- en: '"PolicyId": "ANPAW24Q7QQF6FPOCHV5V",'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"PolicyId": "ANPAW24Q7QQF6FPOCHV5V",'
- en: '"Arn": "arn:aws:iam::470066103307:policy/Tools_Members",'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"Arn": "arn:aws:iam::470066103307:policy/Tools_Members",'
- en: '"Path": "/",'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"Path": "/",'
- en: '"DefaultVersionId": "v1",'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"DefaultVersionId": "v1",'
- en: '"AttachmentCount": 0,'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"AttachmentCount": 0,'
- en: '"PermissionsBoundaryUsageCount": 0,'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"PermissionsBoundaryUsageCount": 0,'
- en: '"IsAttachable": true,'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"IsAttachable": true,'
- en: '"CreateDate": "2021-05-16T19:32:41+00:00",'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"CreateDate": "2021-05-16T19:32:41+00:00",'
- en: '"UpdateDate": "2021-05-16T19:32:41+00:00"'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"UpdateDate": "2021-05-16T19:32:41+00:00"'
- en: '}'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE7]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After creating our policy, we will then attach our policy to our group, like
    this:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建策略后，我们将把策略附加到组中，操作如下：
- en: '[PRE8]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: --policy-arn arn:aws:iam::470066103307:policy/Tools_Members \
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --policy-arn arn:aws:iam::470066103307:policy/Tools_Members \
- en: --group-name tools
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --group-name tools
- en: '[PRE9]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that we have created our `tools` group, we can create a user to be part
    of the tools team. This tools team member will be the user that we will use to
    create the actual code pipeline. Let''s go ahead and make our new user, as follows:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了`tools`组，可以创建一个用户成为工具团队成员。这个工具团队成员将是我们用于创建实际代码管道的用户。让我们继续创建我们的新用户，如下所示：
- en: '[PRE10]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we can take our new user and add them to the `tools` group so that they
    have the group permissions, as follows:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将新用户添加到`tools`组中，使其拥有该组的权限，如下所示：
- en: '[PRE11]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And just like the developer user we created in [*Chapter 8*](B17405_08_Final_JM_ePub.xhtml#_idTextAnchor212),
    *Creating Workloads with CodeCommit and CodeBuild*, we will need to set an initial
    password that the tools user will need to reset on the first login, as follows:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们在[*第 8 章*](B17405_08_Final_JM_ePub.xhtml#_idTextAnchor212)中创建的开发者用户一样，*使用
    CodeCommit 和 CodeBuild 创建工作负载*，我们需要为工具用户设置一个初始密码，该密码将在第一次登录时由用户重置，具体如下：
- en: '[PRE12]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At this point, we have created our tools user and are ready to log in to the
    AWS console as the tools user and build out our AWS pipeline.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经创建了工具用户，并且准备好以工具用户身份登录 AWS 控制台，搭建 AWS 管道。
- en: Creating a pipeline
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建管道
- en: With our tools user (Peter, in our case) created, we will make a context switch
    from using the AWS CLI to the browser and the management console and act as if
    we were performing these acts as the tools user. Before we start, you need to
    be sure to download the `pipeline1.yml` file from the `Chapter9` folder in the
    GitHub repository for the book.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了我们的工具用户（在我们这个例子中是 Peter）后，我们将从使用 AWS CLI 切换到浏览器和管理控制台，并假装这些操作是由工具用户执行的。在开始之前，你需要确保从本书的
    GitHub 仓库中的`Chapter9`文件夹下载`pipeline1.yml`文件。
- en: 'Let''s open up a fresh web browser that doesn''t have cookies or a session
    attached so that we can log in to the AWS console as Peter. You may need to either
    open up an incognito window or a different browser than the one you have been
    using. For example, if you have been running the administrator in Chrome, then
    you would open up a new session in Firefox or Edge using the following steps:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的浏览器窗口，不带有任何 cookie 或会话，这样我们就可以作为 Peter 登录 AWS 控制台。你可能需要打开一个隐身窗口或使用一个不同的浏览器。例如，如果你一直在
    Chrome 中使用管理员权限，则可以在 Firefox 或 Edge 中打开一个新会话，按以下步骤操作：
- en: Sign in to the AWS console using your account number or account alias and the
    user's name, `peter`, and the `Dev0psPRO` password, as we created previously.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的账号号码或账号别名以及用户名称`peter`和我们之前创建的`Dev0psPRO`密码，登录 AWS 控制台。
- en: You will instantly be prompted to change the password for the user `peter`.
    Change this password to anything you like, but either write it down or keep it
    something you can remember as you may need to access this user later. The process
    is shown in the following screenshot:![Figure 9.5 – Password change for tools
    user peter
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统会立刻提示你更改用户`peter`的密码。将此密码更改为你喜欢的任何密码，但请记下或者设置一个你能记住的密码，因为你可能需要稍后访问此用户。以下截图显示了该过程：![图
    9.5 – 工具用户 peter 的密码更改](img/Figure_9.5_B17405.jpg)
- en: '](img/Figure_9.5_B17405.jpg)'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_9.5_B17405.jpg)'
- en: Figure 9.5 – Password change for tools user peter
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.5 – 工具用户 peter 的密码更改
- en: Once you have changed the password, the AWS console will bring you to the main
    console page. Use the top unified search box to search for the **CloudFormation**
    service. Once the CloudFormation service appears, click on the service icon to
    be taken to the main CloudFormation page, as illustrated in the following screenshot:![Figure
    9.6 – CloudFormation service icon
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改密码后，AWS 控制台将带你进入主控制台页面。使用顶部的统一搜索框搜索**CloudFormation**服务。服务出现后，点击服务图标，进入主 CloudFormation
    页面，如下图所示：![图 9.6 – CloudFormation 服务图标](img/Figure_9.6_B17405.jpg)
- en: '](img/Figure_9.6_B17405.jpg)'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_9.6_B17405.jpg)'
- en: Figure 9.6 – CloudFormation service icon
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.6 – CloudFormation 服务图标
- en: Once on the main **CloudFormation** service page, click the orange **Create
    stack** button.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主**CloudFormation**服务页面上，点击橙色的**创建堆栈**按钮。
- en: 'On the **Create stack** page, use the following options:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**创建堆栈**页面，使用以下选项：
- en: a. **Prepare stack**—Keep this selected on **Template is ready**
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. **准备堆栈**—确保选中**模板已准备好**
- en: b. **Specify template**—Choose the checkbox that is labeled **Upload a template
    file**
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. **指定模板**—选择标有**上传模板文件**的复选框
- en: Then, click the `pipeline1.yml` file and open this file. Once this file has
    been selected, click the orange **Next** button at the bottom of the screen, as
    illustrated in the following screenshot:![Figure 9.7 – Creating a CodePipeline
    stack
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击`pipeline1.yml`文件并打开它。选中文件后，点击屏幕底部的橙色**下一步**按钮，如下图所示：![图 9.7 – 创建 CodePipeline
    堆栈](img/Figure_9.7_B17405.jpg)
- en: '](img/Figure_9.7_B17405.jpg)'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_9.7_B17405.jpg)'
- en: Figure 9.7 – Creating a CodePipeline stack
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.7 – 创建 CodePipeline 堆栈
- en: Once you click the `C9-demo` and your email address where you would like to
    receive notifications about the stack. You can leave this blank for the email
    address, or you can put in your own email address. If the branch you created was
    named `main`, then you do not need to make any changes; however, if the branch
    you created was named `master` as in our example, then you will need to change
    the default value in the `master` before moving on or the pipeline will not execute
    right away. Once you have filled in these values, click the orange **Next** button
    at the bottom of the screen, as illustrated in the following screenshot:![Figure
    9.8 – Adding values to the Specify stack details screen
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦点击`C9-demo`并输入你希望接收堆栈通知的电子邮件地址。你可以将电子邮件地址留空，或者输入你自己的电子邮件地址。如果你创建的分支名为`main`，则无需做任何更改；但是，如果你创建的分支名为`master`（如我们的示例），则需要在`master`中更改默认值，然后再继续，否则管道将无法立即执行。填写完这些值后，点击屏幕底部的橙色**下一步**按钮，如下图所示：![图
    9.8 – 添加值到指定堆栈详细信息屏幕](img/Figure_9.8_B17405.jpg)
- en: '](img/Figure_9.8_B17405.jpg)'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_9.8_B17405.jpg)'
- en: Figure 9.8 – Adding values to the Specify stack details screen
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.8 – 添加值到指定堆栈详细信息屏幕
- en: On the **Configure stack options** screen, we will not be adding any tags. Simply
    go to the bottom of the page and click the orange **Next** button.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**配置堆栈选项**屏幕上，我们不会添加任何标签。只需滚动到页面底部，点击橙色的**下一步**按钮。
- en: Now, on the **Review C9-demo** page, scroll down to the bottom of the page and
    check the box in the blue area that acknowledges that this stack will create an
    IAM role under the heading of **Capabilities**. After you have checked the box,
    you can press the orange button that is labeled **Create stack**, as illustrated
    in the following screenshot:![Figure 9.9 – Checking the acknowledgment in the
    Capabilities section on the review
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**审查C9-demo**页面上，滚动到页面底部，并勾选蓝色区域中的框，确认该堆栈将创建一个IAM角色，在**功能**标题下显示。勾选框后，你可以点击橙色的**创建堆栈**按钮，如下图所示：![图
    9.9 – 在审核中的“功能”部分检查确认信息](img/Figure_9.9_B17405.jpg)
- en: '](img/Figure_9.9_B17405.jpg)'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_9.9_B17405.jpg)'
- en: Figure 9.9 – Checking the acknowledgment in the Capabilities section on the
    review
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.9 – 在审核中的“功能”部分检查确认信息
- en: Once pressed, you will be taken to the `CREATE_IN_PROGRESS` until it has finished
    creating our code pipeline. Once the status has been completed, then we can move
    on to the next step.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦点击，你将被带到`CREATE_IN_PROGRESS`状态，直到我们的代码管道创建完成。完成后，我们就可以继续进行下一步了。
- en: After the CloudFormation process completes, we will then be able to go back
    up to the unified search and search for the `CodePipeline` service. Once the icon
    for **CodePipeline** appears, as illustrated in the following screenshot, click
    on it to be taken to the current pipelines:![Figure 9.10 – CodePipeline from the
    unified search bar
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在CloudFormation过程完成后，我们将能够返回统一搜索栏，搜索`CodePipeline`服务。一旦**CodePipeline**的图标出现，如下图所示，点击它即可进入当前的管道：![图
    9.10 – 从统一搜索栏中的CodePipeline](img/Figure_9.10_B17405.jpg)
- en: '](img/Figure_9.10_B17405.jpg)'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_9.10_B17405.jpg)'
- en: Figure 9.10 – CodePipeline from the unified search bar
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.10 – 从统一搜索栏中的CodePipeline
- en: You should see the pipeline that you just created, named `C9-demo`. Click on
    this name to view the details of the pipeline.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该能够看到刚刚创建的管道，名称为`C9-demo`。点击此名称查看管道的详细信息。
- en: 'We can see from the pipeline we created that we now have a pipeline created
    with three stages: **Source**, **Build**, and **Deploy**. There are integrated
    processes including manual approval processes on the deploy stage along with the
    CloudFormation creation..'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从我们创建的管道中看到，现在已经创建了一个包含三个阶段的管道：**源**、**构建**和**部署**。在部署阶段包含了集成过程，包括手动审批流程，以及CloudFormation创建过程。
- en: Note
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you failed to complete the previous exercise of creating the CodeCommit repository
    named `chapt9`, you would run into problems with the pipeline. This `chapt9` repository
    is the code source for our AWS code pipeline. If you named your repository something
    different, you would need to either modify the CloudFormation template or go into
    the AWS console and modify your source stage.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有完成前面的练习，即创建名为`chapt9`的CodeCommit仓库，那么你将遇到管道问题。这个`chapt9`仓库是我们AWS代码管道的代码源。如果你将仓库命名为其他名称，你需要修改CloudFormation模板，或者进入AWS控制台修改源阶段。
- en: Now, with our AWS code pipeline built, we can move forward with our developer
    testing a commit and seeing the stages of the pipeline in action, just as it would
    work in real life. Before we do that, however, we need to give our developer users
    more IAM permissions since when they were initially created, they only had permissions
    for CodeCommit and to modify their own password.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着我们构建了 AWS 代码管道，我们可以继续让我们的开发者测试提交，并查看管道在实际操作中的各个阶段，就像它在现实生活中运行一样。然而，在此之前，我们需要为开发者用户提供更多的
    IAM 权限，因为他们在最初创建时，只拥有 CodeCommit 权限并且只能修改自己的密码。
- en: Updating our developer users
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新我们的开发者用户
- en: 'In the previous chapter, [*Chapter 8*](B17405_08_Final_JM_ePub.xhtml#_idTextAnchor212),
    *Creating Workloads with CodeCommit and CodeBuild*, we created a group for developers.
    We gave them a scoped set of permissions that was limited to AWS CodeCommit and
    CodeBuild. Since we are now adding CodePipeline and CodeBuild to the mix, we will
    now have to expand their permissions so that they can use these services as well.
    In the GitHub `Chapter9` repository, there is a file named `IAM_Developers.json`—be
    sure to download this file so that you can update the permissions for your developer.
    While updating the commands, you will need to use your administrative user. We''ll
    proceed as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章，[*第 8 章*](B17405_08_Final_JM_ePub.xhtml#_idTextAnchor212)，*使用 CodeCommit
    和 CodeBuild 创建工作负载*，我们为开发者创建了一个用户组。我们为他们提供了一组权限，限定在 AWS CodeCommit 和 CodeBuild
    服务内。由于现在我们要加入 CodePipeline 和 CodeBuild，因此我们需要扩展他们的权限，以便他们也能使用这些服务。在 GitHub 的 `Chapter9`
    仓库中，有一个名为 `IAM_Developers.json` 的文件——请务必下载该文件，以便更新开发者的权限。在更新命令时，您需要使用管理员用户。我们将按以下步骤进行：
- en: Note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before you start to perform these commands, make sure that you have downloaded
    the `IAM_Developers.json` file from the `Chapter9` folder in the GitHub repository
    and are in the same directory where you downloaded the file.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行这些命令之前，请确保您已经从 GitHub 仓库的 `Chapter9` 文件夹下载了 `IAM_Developers.json` 文件，并且位于下载该文件的同一目录下。
- en: 'The first thing that we need to do is find the ARN of the policy attached to
    our developers. We created this policy in the exercise in [*Chapter 8*](B17405_08_Final_JM_ePub.xhtml#_idTextAnchor212),
    *Creating Workloads with CodeCommit and CodeBuild*. Log in to your terminal and
    run the following command to extract the ARN for the developer group:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是找到附加到开发者的策略的 ARN。我们在 [*第 8 章*](B17405_08_Final_JM_ePub.xhtml#_idTextAnchor212)，*使用
    CodeCommit 和 CodeBuild 创建工作负载* 的练习中创建了该策略。登录到终端并运行以下命令，提取开发者组的 ARN：
- en: '[PRE13]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After we run this command, we should get a return of the current ARN being used
    for our Code Commit developers' group. This ARN is going to be needed in the following
    step so that we can update our policy.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行此命令后，我们应该会得到当前用于 Code Commit 开发者组的 ARN 返回结果。接下来，我们将在下一步中使用该 ARN 更新我们的策略。
- en: 'After we have the ARN, we can then create a new policy version and set that
    version as `default`, as follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在获得 ARN 后，我们可以创建一个新的策略版本，并将该版本设置为`默认`，如下所示：
- en: '[PRE14]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If this is successful, we will be returned a **JavaScript Object Notation**
    (**JSON**) message showing that we are now on the second version of our policy,
    as illustrated in the following code snippet:'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果成功，我们将返回一个**JavaScript 对象表示法**（**JSON**）消息，显示我们现在正在使用策略的第二个版本，如以下代码片段所示：
- en: '[PRE15]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Updating our developer user group to allow for CodePipeline access permits the
    developers to see the pipelines previously created when running, along with any
    errors that may have been encountered during individual steps of the pipeline.
    These permissions have been scoped in such a manner so as not to allow developers
    to create or modify any new or existing pipelines.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 更新我们的开发者用户组，以允许访问 CodePipeline，允许开发者查看之前创建的管道，并查看在管道各个步骤中可能遇到的错误。这些权限的范围被限制为不允许开发者创建或修改任何新的或现有的管道。
- en: CodePipeline concepts
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CodePipeline 概念
- en: 'There are several basic concepts and terms to understand when using AWS CodePipeline,
    as depicted in the following diagram:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AWS CodePipeline 时，需要了解几个基本概念和术语，如下图所示：
- en: '![Figure 9.11 – CodePipeline transition representation'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.11 – CodePipeline 转换表示'
- en: '](img/Figure_9.11_B17405.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.11_B17405.jpg)'
- en: Figure 9.11 – CodePipeline transition representation
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – CodePipeline 转换表示
- en: Understanding the CodePipeline and stage requirements
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 CodePipeline 和阶段需求
- en: 'As you start to build pipelines, there are some rules and requirements that
    should be known as this can help you avoid headaches in trying to debug errors.
    Look through the list stated next for best practices as you build your AWS code
    pipelines along with the knowledge to remember during exam time:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始构建管道时，有一些规则和要求是应该了解的，因为这有助于你避免在调试错误时遇到麻烦。请查阅接下来的清单，了解最佳实践，并记住考试时的知识点：
- en: All stage names in a pipeline must be unique.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道中的所有阶段名称必须是唯一的。
- en: Only the first stage in a pipeline can contain source actions.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有管道中的第一个阶段可以包含源操作。
- en: A pipeline must have at least two stages.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个管道必须至少包含两个阶段。
- en: All actions within a single stage must be unique.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个阶段中的所有操作必须是唯一的。
- en: The input action of a stage must match the output action of the preceding stage
    exactly.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阶段的输入操作必须与前一阶段的输出操作完全匹配。
- en: Output artifact names must be unique to a pipeline. If a stage has an output
    artifact named `TestPackage`, no other stage may have another output artifact
    named `TestPackage` in that pipeline.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出工件名称必须在管道中唯一。如果某个阶段的输出工件名为`TestPackage`，则该管道中的其他阶段不得有名为`TestPackage`的输出工件。
- en: For all supported action types, the only valid owner strings are `AWS`, `ThirdParty`,
    or `Custom`.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有支持的操作类型，唯一有效的所有者字符串是`AWS`、`ThirdParty`或`Custom`。
- en: There are other more complex requirements; however, if you understand these
    requirements, then you have a solid foundation for using the CodePipeline service
    along with an understanding of the nuances of stages for the DevOps professional
    exam.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他更复杂的要求；然而，如果你理解了这些要求，那么你就为使用 CodePipeline 服务打下了坚实的基础，并且对 DevOps 专业考试中的阶段细节有了深入理解。
- en: 'Now that we have looked at the stages as a whole in an AWS code pipeline, let''s
    look at one aspect that is not automated: approval actions.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经整体了解了 AWS CodePipeline 中的各个阶段，让我们来看看一个未被自动化的方面：审批操作。
- en: Approval actions in a code pipeline
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CodePipeline 中的审批操作
- en: In a code pipeline, there is an opportunity to pause between stages using approval
    actions. Approval actions allow for the manual review of an action before proceeding
    to the next stage of the pipeline.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CodePipeline 中，可以在阶段之间使用审批操作进行暂停。审批操作允许在继续进入管道的下一个阶段之前，手动审核操作。
- en: Actions that are approved by the reviewer move on to the next stage of the pipeline.
    If an approval is rejected, then the pipeline does not continue to the next stage.
    You also have 7 days to approve a pipeline action, or it will result in the pipeline
    failing.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 经审核人批准的操作将进入管道的下一个阶段。如果审批被拒绝，则管道不会继续到下一个阶段。你也有 7 天时间来批准管道操作，否则管道将失败。
- en: 'There are a few common reasons why you would use approval actions in an AWS
    code pipeline, outlined as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWS CodePipeline 中使用审批操作的常见原因如下：
- en: To perform manual **Quality Assurance** (**QA**) testing before moving on to
    the next stage
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进入下一阶段之前，进行手动**质量保证**（**QA**）测试
- en: To allow for a code review or change management review before proceeding
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在继续之前，允许进行代码审查或变更管理审查
- en: To allow for manual review of a web page before publishing to production
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许在发布到生产环境之前手动审核网页
- en: Using Jenkins to build your workloads
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jenkins 构建你的工作负载
- en: The developer tools provided by AWS can give you just about all the functionality
    that you need without any extra configuration or setup. There are instances where
    teams have already built parts of their **Continuous Integration/Continuous Deployment**
    (**CI/CD**) process around existing tooling and may want to retain some of the
    work that they have already poured time and effort into refining.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 提供的开发者工具几乎可以为你提供所有所需的功能，而无需额外的配置或设置。有些情况下，团队已经围绕现有工具构建了部分**持续集成/持续部署**（**CI/CD**）流程，并且可能希望保留已经投入时间和精力精细化的部分工作。
- en: Teams that use the Jenkins server can be one of those cases. Along with its
    vast ecosystem of plugins, Jenkins can provide an extreme amount of functionality
    in the CI/CD process.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Jenkins 服务器的团队可以属于这种情况之一。借助其庞大的插件生态系统，Jenkins 能够为 CI/CD 流程提供极大的功能支持。
- en: Many teams use Jenkins for the build stage of the CI process since, in Jenkins,
    it can feel easier to build the steps in shell scripts without a need to create
    additional `buildspec` files.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 许多团队在 CI 过程的构建阶段使用 Jenkins，因为在 Jenkins 中，构建步骤可以通过 Shell 脚本来实现，无需创建额外的`buildspec`文件。
- en: 'The following diagram depicts Jenkins being used in conjunction with CodePipeline:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了 Jenkins 与 CodePipeline 一起使用的情况：
- en: '![Figure 9.12 – Using Jenkins in conjunction with CodePipeline'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.12 – Jenkins 与 CodePipeline 一起使用'
- en: '](img/Figure_9.12_B17405.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.12_B17405.jpg)'
- en: Figure 9.12 – Using Jenkins in conjunction with CodePipeline
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – Jenkins 与 CodePipeline 一起使用
- en: Jenkins itself has plugins that will work with many of the AWS services, including
    the developers' suite of services.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 本身有插件，可以与许多 AWS 服务兼容，包括开发者服务套件。
- en: Now that we have looked at the CodePipeline service, including how to incorporate
    third-party tools such as the Jenkins build server, let's look at how we can use
    AWS CodeDeploy to deploy our workloads either by themselves or as part of a pipeline.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 CodePipeline 服务，包括如何将 Jenkins 构建服务器等第三方工具集成进来，接下来看看如何使用 AWS CodeDeploy
    部署我们的工作负载，不论是单独部署还是作为管道的一部分。
- en: About AWS CodeDeploy
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于 AWS CodeDeploy
- en: AWS CodeDeploy is a service that assists in automating deployments of application
    code and files to EC2 instances, on-premises servers, Lambda functions, and containers
    running on AWS ECS.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CodeDeploy 是一个帮助自动化将应用程序代码和文件部署到 EC2 实例、本地服务器、Lambda 函数和运行在 AWS ECS 上的容器的服务。
- en: 'CodeDeploy is a service that makes the following things easier:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: CodeDeploy 是一个服务，它使以下事项变得更加简便：
- en: Update Lambda functions and create new versions
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新 Lambda 函数并创建新版本。
- en: Avoid downtime during application deployments
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序部署期间避免停机
- en: Swiftly release new features
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速发布新功能
- en: Promptly roll back to a known good version in case of deployment failure
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在部署失败的情况下，及时回滚到已知的良好版本。
- en: 'AWS CodeDeploy is focused on the following three platforms for deployments:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CodeDeploy 专注于以下三个平台的部署：
- en: EC2/on-premises instances
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EC2/本地实例
- en: Lambda functions
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 函数
- en: ECS containerized applications
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECS 容器化应用程序
- en: Using these three platforms as a basis, you describe your deployments in a file
    named `appspec`. This file can be written in either JSON or **YAML Ain't Markup
    Language** (**YAML**) format.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这三个平台作为基础，你需要在名为 `appspec` 的文件中描述你的部署。这个文件可以使用 JSON 或 **YAML Ain't Markup
    Language**（**YAML**）格式编写。
- en: 'There are multiple types of files and components that CodeDeploy can distribute,
    including the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: CodeDeploy 可以分发多种类型的文件和组件，包括以下内容：
- en: Executables
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可执行文件
- en: Packages
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包
- en: Scripts
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本
- en: Multimedia files
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多媒体文件
- en: Now that we have a grasp of the basics of CodeDeploy, let's look at the basic
    concepts we need to understand when using the CodeDeploy service.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了 CodeDeploy 的基础知识，接下来看看在使用 CodeDeploy 服务时需要理解的基本概念。
- en: Basic CodeDeploy concepts to understand
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要理解的基本 CodeDeploy 概念
- en: As we start to employ the CodeDeploy service, there are some components that
    should be understood first and foremost.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始使用 CodeDeploy 服务时，有一些组件需要首先理解。
- en: Application
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序
- en: This is a name that is unique, and CodeDeploy uses it to identify the application
    which you want to deploy. It uses this unique name to make sure that the correct
    version of deployment, deployment group, revision, or rollback is referenced during
    a particular deployment.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个唯一的名称，CodeDeploy 使用它来标识你想要部署的应用程序。它使用这个唯一名称来确保在特定部署过程中引用的是正确版本的部署、部署组、修订版或回滚。
- en: Compute platform
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算平台
- en: This is the actual platform where CodeDeploy deploys an application. There are
    quite a few choices for CodeDeploy deployments. Deployments can happen to EC2
    instances or on-premises servers as long as they meet operating system requirements.
    These deployments can consist of configuration files, images, and executable files,
    along with other types of files.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 CodeDeploy 实际部署应用程序的平台。CodeDeploy 部署有很多选择。只要满足操作系统要求，部署可以发生在 EC2 实例或本地服务器上。这些部署可以包括配置文件、镜像、可执行文件及其他类型的文件。
- en: CodeDeploy can also be used to update Lambda functions. CodeDeploy also has
    the ability to shift traffic from one version of a Lambda function to a newer
    function in a multitude of deployment options, including **canary**, **linear**,
    and **all-at-once** deployments.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: CodeDeploy 还可以用于更新 Lambda 函数。CodeDeploy 还具备将流量从一个版本的 Lambda 函数转移到新版本的能力，支持多种部署选项，包括
    **金丝雀**、**线性** 和 **一次性全部部署**。
- en: If you are using containers on the ECS platform, then CodeDeploy can be used
    to update the tasks using a **blue/green deployment** strategy by first installing
    a new version of the task set and then shifting the traffic over to the latest
    version of the task set. As with Lambda deployments, these deployments can be
    done in a canary, linear, or all-at-once fashion.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 ECS 平台上使用容器，则可以使用 CodeDeploy 来更新任务，采用 **蓝绿部署** 策略，首先安装新版本的任务集，然后将流量切换到任务集的最新版本。与
    Lambda 部署一样，这些部署可以采用金丝雀、线性或一次性方式进行。
- en: Deployment configuration
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署配置
- en: 'Using a set of success or failure criteria along with deployment rules, CodeDeploy
    is guided by a deployment configuration for each deployment. Inside of the deployment
    configuration, especially in the case of EC2 or on-premises deployments, you can
    set the minimum number of healthy instances that need to succeed for the deployment
    to be a success. If you are targeting either a Lambda application or ECS tasks,
    then your deployment configuration can specify how the traffic is routed during
    the deployment. The following deployments are available:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一组成功或失败标准以及部署规则，CodeDeploy 会根据每次部署的部署配置来进行引导。在部署配置中，特别是在 EC2 或本地部署的情况下，你可以设置成功的最小健康实例数量，以确保部署成功。如果你部署的是
    Lambda 应用程序或 ECS 任务，则可以在部署配置中指定流量在部署过程中如何路由。以下是可用的部署方式：
- en: '**Canary**: Traffic is shifted in two separate increments, and you have the
    ability to specify the percentage of the traffic shifted initially before the
    rest of the traffic is shifted at a time specified in minutes.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**金丝雀**：流量分两次进行转移，并且你可以指定在第一次转移前初始转移的流量百分比，剩余流量会在指定的分钟数后进行转移。'
- en: '**Linear**: Traffic is shifted in equal increments. You have predefined options
    for percentages that can be shifted and for the intervals between shifts.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线性**：流量按相等的增量进行转移。你可以预定义可以转移的百分比和转移之间的时间间隔。'
- en: '**All-at-once**: All the traffic is shifted from the original Lambda function
    or ECS task at the same time.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一次性**：所有流量会同时从原始的 Lambda 函数或 ECS 任务转移。'
- en: Deployment groups
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署组
- en: Deployment groups pertain to EC2 instances, either individually or in **Auto
    Scaling Groups** (**ASGs**), and are explicitly tagged for targeting a deployment.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 部署组适用于 EC2 实例，无论是单独的还是在**自动扩展组**（**ASGs**）中，并且会明确标记用于指定部署目标。
- en: Deployment groups can be as straightforward as using a single tag to designate
    the deployment group, or you can become elaborate as using up to 10 different
    tags in a deployment group.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 部署组可以简单地通过一个标签来指定部署组，或者你可以通过在一个部署组中使用多达 10 个标签来进行更复杂的配置。
- en: Deployment type
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署类型
- en: 'The deployment type is the technique used by CodeDeploy to place the most up-to-date
    version of an application into a deployment group. There are two different types
    of deployment types: **in-place** and **blue/green**.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 部署类型是 CodeDeploy 用来将最新版本的应用程序部署到部署组中的技术。有两种不同类型的部署方式：**就地部署**和**蓝绿部署**。
- en: With in-place deployments, although possibly more cost-effective, the application
    on the current instances in the deployment group is stopped while the latest version
    of the application is installed. The new version of the application is restarted
    and then validated. In-place deployments are only available for EC2 instances
    or on-premises deployments.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在就地部署中，虽然可能更具成本效益，但部署组中当前实例上的应用程序会被停止，同时安装最新版本的应用程序。新版本的应用程序会重启并进行验证。就地部署仅适用于
    EC2 实例或本地部署。
- en: Blue/green deployments provision a new set of resources. This can consist of
    creating a new version of a Lambda function, a new task set in the case of ECS,
    or a whole new instance in the case of EC2\.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝绿部署会配置一组新的资源。这可以包括创建新的 Lambda 函数版本，ECS 中创建新的任务集，或者在 EC2 中创建新的实例。
- en: Blue/green deployments do not work with on-premises deployments.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝绿部署不适用于本地部署。
- en: Revision
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修订版
- en: A revision for an AWS Lambda deployment is either a file in YAML or JSON format
    that states information about the Lambda function to deploy. Revisions for Lambda
    are stored in an S3 bucket.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda 部署的修订版是一个 YAML 或 JSON 格式的文件，包含有关要部署的 Lambda 函数的信息。Lambda 的修订版存储在
    S3 存储桶中。
- en: In the case of an EC2 or on-premises deployment revision, this is not just one
    file but a collection of files that contain the components (such as web pages,
    executable files, source code, and deployment scripts) along with a specification
    for the application, which is then packaged up into archive format. Revisions
    for EC2 or on-premises instances can be stored in an S3 bucket or GitHub repositories.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 EC2 或本地部署修订版，这不仅仅是一个文件，而是一个包含组件（如网页、可执行文件、源代码和部署脚本）的文件集合，以及应用程序的规范，然后将其打包成归档格式。EC2
    或本地实例的修订版可以存储在 S3 存储桶或 GitHub 仓库中。
- en: Target revision
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标修订版
- en: This is the most recent version of an application that has been uploaded to
    the code repository, which is going to be targeted for deployment.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这是已经上传到代码仓库中的应用程序的最新版本，将被作为目标进行部署。
- en: Installing the CodeDeploy agent file
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 CodeDeploy 代理文件
- en: When using CodeDeploy with EC2 instances, an agent file is placed on those instances,
    making it viable for the instance to achieve deployments from the CodeDeploy service.
    A configuration file is also placed on the instance with an agent, and this file
    specifies how the agent will work. These instances not only have to be in the
    AWS cloud but can also be on a specific operating system of an on-premises data
    center.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 CodeDeploy 与 EC2 实例时，代理文件会被放置在这些实例上，使得实例能够从 CodeDeploy 服务进行部署。同时，配置文件也会被放置在实例上，并且该文件指定了代理如何工作。这些实例不仅必须在
    AWS 云中，还可以位于本地数据中心的特定操作系统上。
- en: 'Take a glance at the following lists to see which operating systems have been
    tested using the AWS CodeDeploy agent:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下列表，了解哪些操作系统已经使用 AWS CodeDeploy 代理进行过测试：
- en: '![Table 9.2 – Tested operating systems to use the AWS CodeDeploy agent'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 9.2 – 测试过的操作系统，用于使用 AWS CodeDeploy 代理'
- en: '](img/021.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/021.jpg)'
- en: Table 9.2 – Tested operating systems to use the AWS CodeDeploy agent
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.2 – 测试过的操作系统，用于使用 AWS CodeDeploy 代理
- en: Any EC2 instance that you wish to use with CodeDeploy will also need to have
    a service role attached that gives it enough permissions so that the CodeDeploy
    service can perform its duties.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 任何你希望与 CodeDeploy 一起使用的 EC2 实例，也需要附加一个服务角色，以授予它足够的权限，以便 CodeDeploy 服务能够执行其职责。
- en: Understanding the appspec file
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 appspec 文件
- en: The application specification file, or `appspec` file, as it is most commonly
    called, is a YAML file in the majority of cases (although it may be formatted
    in JSON format) that has a specific number of sections along with some optional
    sections depending on which type of deployment you are trying to perform.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序规范文件，或者通常所说的 `appspec` 文件，在大多数情况下是一个 YAML 文件（虽然它也可以格式化为 JSON 格式），它有特定的几个部分，以及一些可选的部分，具体取决于你要执行的部署类型。
- en: The `appspec` file details the deployment actions that you want to take during
    the deployment.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`appspec` 文件详细说明了在部署过程中你希望执行的部署操作。'
- en: There are different types of `appspec` files if you are doing an ECS deployment
    for containers, for EC2, or on-premises instances, and then if you are trying
    to deploy to Lambda instances.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在为容器做 ECS 部署、为 EC2 或本地实例部署，或者试图部署到 Lambda 实例，那么 `appspec` 文件有不同的类型。
- en: 'The following is an example `appspec` file:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 `appspec` 文件的示例：
- en: '[PRE16]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Important items to note in our example `appspec` file are the version, the resources,
    and the hooks.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们示例中的 `appspec` 文件中，重要的项目包括版本、资源和钩子。
- en: Deployment rollbacks and content redeployment
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署回滚和内容重新部署
- en: AWS CodeDeploy can roll back a deployment that has either been stopped manually
    or that has failed during the deployment process. Properly speaking, these rollbacks
    are new deployments and receive new deployment **identifiers** (**IDs**). The
    rollbacks do restore previous versions of a set of code. There are two different
    ways that rollbacks can happen, via automated rollbacks or via a manual process.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CodeDeploy 可以回滚一个已经被手动停止或在部署过程中失败的部署。严格来说，这些回滚是新的部署，并且会接收新的部署**标识符**（**ID**）。回滚确实会恢复一组代码的先前版本。回滚可以通过自动回滚或手动过程两种方式进行。
- en: Automated rollbacks
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动回滚
- en: Your deployment group can be configured to automatically roll back either on
    failure during a deployment or if certain monitoring thresholds are met during
    a deployment. If one of these limits has been set and then triggered during the
    deployment for a case of automated rollback, then the deployment will go back
    to the last known good configuration.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您的部署组可以配置为在部署失败时或在部署过程中达到某些监控阈值时自动回滚。如果设置了其中一个阈值并在部署过程中触发了自动回滚，那么部署将回到上一个已知的良好配置。
- en: You may also choose to override the automated rollback option if it has previously
    been put in place when starting a new deployment by configuring one of the advanced
    configuration options for the deployment group.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以选择在开始新的部署时，通过配置部署组的高级配置选项来覆盖先前设置的自动回滚选项。
- en: Manual rollbacks
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动回滚
- en: Even if you have not set up your deployment to roll back automatically, using
    AWS CodeDeploy, you can push out a previous version of a deployment. This would
    create a new deployment version. You could do this if your deployment failed or
    if your instances have got into an unknown state, and they might be fixed by pushing
    updates to the application and configuration.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您没有设置自动回滚部署，使用 AWS CodeDeploy，您仍然可以推出之前版本的部署。这将创建一个新的部署版本。如果您的部署失败，或者实例进入未知状态，您可以通过推送应用程序和配置更新来修复它们。
- en: Rollback and redeployment workflow
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回滚和重新部署工作流
- en: If a rollback has been induced either automatically or manually, then CodeDeploy
    will start to try to remove all of the files that were successfully installed
    during the deployment.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果回滚是自动或手动触发的，那么 CodeDeploy 将开始尝试删除在部署过程中成功安装的所有文件。
- en: The cleanup file, if it exists, is a type of log file that CodeDeploy keeps
    so that it knows which files have been installed and can remove these files before
    starting a new deployment.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 清理文件（如果存在）是一种日志文件，CodeDeploy 会保存它，以便知道哪些文件已被安装，并在开始新的部署之前删除这些文件。
- en: During deployment, the CodeDeploy agent will write out the filenames that are
    being deployed so that it has a record in case a rollback is necessary.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署过程中，CodeDeploy 代理会记录正在部署的文件名，以便在需要回滚时有记录。
- en: In the case of a rollback, CodeDeploy will refer to the cleanup file so that
    it knows which files to remove. It can then proceed with the previous version
    of the deployment in case of automatic rollback.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在回滚的情况下，CodeDeploy 会参考清理文件，以便知道需要删除哪些文件。然后，它可以在自动回滚的情况下继续执行之前的版本部署。
- en: Knowing now how deployments and rollbacks work, let's take a look at some of
    the use cases for AWS CodeDeploy.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在了解了部署和回滚的工作原理，让我们来看一下 AWS CodeDeploy 的一些使用案例。
- en: Use cases for AWS CodeDeploy
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS CodeDeploy 的使用案例
- en: As we have looked at the AWS CodeDeploy service, let's think about some of the
    situations where this service would serve us best.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解了 AWS CodeDeploy 服务之后，让我们思考一些在什么情况下该服务最适合我们使用。
- en: Deploying application updates to servers in an on-premises data center
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将应用更新部署到本地数据中心的服务器
- en: If you are running a compatible operating system on your on-premises hardware,
    then you use AWS CodeDeploy to coordinate the deployments as well as have a single
    pane of glass to see successes and failures. Installing the AWS CodeDeploy agent
    is a required prerequisite. These operating systems include Windows Server, Ubuntu
    Server, or RHEL.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的本地硬件上运行的是兼容的操作系统，则可以使用 AWS CodeDeploy 来协调部署，并通过单一界面查看成功和失败。安装 AWS CodeDeploy
    代理是必要的前提条件。这些操作系统包括 Windows Server、Ubuntu Server 或 RHEL。
- en: Deploying application updates to Windows or Linux servers in the AWS cloud
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将应用更新部署到 AWS 云中的 Windows 或 Linux 服务器
- en: If you are deploying to an NGINX or Apache server on a Linux EC2 instance or
    an **Internet Information Services** (**IIS**) instance on a Windows server, then
    you can use the CodeDeploy agent to choreograph the placement of files and restart
    any necessary services needed to update files on these instances.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在将应用程序部署到 Linux EC2 实例上的 NGINX 或 Apache 服务器，或 Windows 服务器上的 **Internet Information
    Services** (**IIS**) 实例，则可以使用 CodeDeploy 代理来协调文件的放置，并重新启动任何需要更新文件的服务。
- en: Deploying application updates to multiple regions with one deployment push
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用一次部署推送将应用更新部署到多个区域
- en: 'When you are looking for a way to build a solution that will create an automated
    **End-to-End** (**E2E**) release flow for deployments in multiple regions, then
    AWS CodeDeploy can help do this with help from AWS CodePipeline. This is especially
    true in the case of trying to keep Lambda deployments in sync for either **High-Availability**
    (**HA**) purposes or a **Disaster Recovery** (**DR**) strategy. In the following
    diagram, you can see CodeDeploy being used to deploy to multiple regions:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当您寻找一种方法来构建解决方案，以在多个区域中为部署创建自动化**端到端**（**E2E**）发布流程时，AWS CodeDeploy可以通过AWS CodePipeline的帮助来实现此目标。在尝试保持Lambda部署以实现**高可用性**（**HA**）或**灾难恢复**（**DR**）策略时尤为如此。在以下图表中，您可以看到CodeDeploy被用来在多个区域进行部署：
- en: '![Figure 9.13 – Using CodePipeline and CodeDeploy to deploy to multiple regions'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.13 – 使用CodePipeline和CodeDeploy进行多区域部署'
- en: '](img/Figure_9.13_B17405.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.13_B17405.jpg)'
- en: Figure 9.13 – Using CodePipeline and CodeDeploy to deploy to multiple regions
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 – 使用CodePipeline和CodeDeploy进行多区域部署
- en: Using S3 as the origin for the source code will kick off the deployment via
    the AWS code pipeline. If the pipeline is successful, then it will move on to
    an invoke stage where a Lambda function will copy the source code to an S3 bucket
    in the replicated region.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用S3作为源代码的起点将通过AWS代码流水线启动部署。如果流水线成功，则它将进入一个调用阶段，其中Lambda函数将源代码复制到复制区域的S3存储桶中。
- en: This replication of the source code to the S3 bucket in the **B** region will
    start the process again on another pipeline that has been set up in the second
    region.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 将源代码复制到**B**区域的S3存储桶将在第二个区域设置的另一个流水线上重新启动该过程。
- en: Deploying a new task to ECS in blue/green fashion
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以蓝/绿方式将新任务部署到ECS
- en: 'CodeDeploy can give you the ability to seamlessly switch between task sets
    that are behind a network or application load balancer. It does this by deploying
    the new version of the task set and then switching the listener to the new version
    at the load balancer level, as illustrated in the following diagram:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: CodeDeploy可以让您无缝切换网络或应用负载均衡器后面的任务集。它通过部署任务集的新版本，然后在负载均衡器级别切换监听器到新版本来实现这一点，如以下图表所示：
- en: '![Figure 9.14 – Blue/green deployment using CodeDeploy'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.14 – 使用CodeDeploy进行蓝/绿部署'
- en: '](img/Figure_9.14_B17405.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.14_B17405.jpg)'
- en: Figure 9.14 – Blue/green deployment using CodeDeploy
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 – 使用CodeDeploy进行蓝/绿部署
- en: Note
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will go more in-depth into blue/green deployments in [*Chapter 13*](B17405_13_Final_JM_ePub.xhtml#_idTextAnchor338),
    *Blue Green Deployments*.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更深入地探讨[*第13章*](B17405_13_Final_JM_ePub.xhtml#_idTextAnchor338)，*蓝绿部署*。
- en: Deploying a task to Amazon ECS and using Lambda to validate before switching
    traffic over
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在将任务部署到Amazon ECS并在切换流量之前使用Lambda进行验证
- en: With the use of CodeDeploy deployment groups, along with the assistance of a
    Lambda function, you can create a test to ensure that your new task is up and
    running successfully. This Lambda function can be specified in the deployment
    `appspec` file, and if the validation fails, then the deployment is stopped and
    rolled back. If the validation succeeds, then the deployment continues.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CodeDeploy部署组以及Lambda函数的帮助，您可以创建一个测试，以确保新任务成功运行。这个Lambda函数可以在部署`appspec`文件中指定，如果验证失败，则部署将停止并回滚。如果验证成功，则继续部署。
- en: Monitoring CodeDeploy jobs
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控CodeDeploy作业
- en: Whether your CodeDeploy jobs are running standalone with the CodeDeploy service
    or as part of a deployment pipeline, monitoring their status and being notified
    promptly when there is a failure can be critical for solving issues in a timely
    fashion.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您的CodeDeploy作业是作为CodeDeploy服务的独立运行还是作为部署流水线的一部分运行，监控它们的状态并在发生故障时及时通知，对于及时解决问题至关重要。
- en: Partnering CodeDeploy with the monitoring abilities of CloudWatch allows you
    to monitor specific metrics during deployments. Using these metrics, you can create
    CloudWatch alarms. Up to 10 CloudWatch alarms can be associated with a CodeDeploy
    deployment group. Triggering any one of the alarms will cause the deployment to
    stop and the status of the deployment to be reflected as `Stopped`. In order to
    monitor CodeDeploy with the CloudWatch service, you must grant your CodeDeploy
    service role permissions to use the CloudWatch service.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 将 CodeDeploy 与 CloudWatch 的监控功能结合使用，可以在部署过程中监控特定的指标。利用这些指标，您可以创建 CloudWatch
    警报。最多可以将 10 个 CloudWatch 警报与一个 CodeDeploy 部署组关联。触发任何一个警报将导致部署停止，并且部署状态将显示为 `Stopped`。为了使用
    CloudWatch 服务监控 CodeDeploy，您必须授予 CodeDeploy 服务角色权限以使用 CloudWatch 服务。
- en: 'CloudWatch events can be used to help not only detect but also react to failures
    of CodeDeploy jobs based on rules that you create. Once these rules are created,
    CloudWatch events will initiate actions on specific targets. The following targets
    will work from CloudWatch events with rules from CodeDeploy jobs:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: CloudWatch 事件可以帮助不仅检测，而且根据您创建的规则反应 CodeDeploy 作业的故障。一旦创建了这些规则，CloudWatch 事件将启动针对特定目标的动作。以下目标将与来自
    CodeDeploy 作业的规则的 CloudWatch 事件配合使用：
- en: AWS **Lambda** functions
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS **Lambda** 函数
- en: Kinesis streams
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kinesis 流
- en: Amazon **Simple Queue Service** (**SQS**) queues
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon **简单队列服务** (**SQS**) 队列
- en: '**CloudWatch** alarm actions'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CloudWatch** 警报动作'
- en: Amazon **Simple Notification Service** (**SNS**) topics (and notifications)
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon **简单通知服务** (**SNS**) 主题（和通知）
- en: CodeDeploy monitoring use cases
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CodeDeploy 监控用例
- en: If your team uses Slack as a communication channel, then you can integrate a
    Slack notification via a Lambda function whenever a CodeDeploy deployment fails.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的团队使用 Slack 作为通讯渠道，那么您可以通过 Lambda 函数集成 Slack 通知，每当 CodeDeploy 部署失败时。
- en: CloudWatch alarm actions can be used to programmatically reboot, stop, or terminate
    EC2 instances if a specific event occurs during deployment.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在部署过程中发生特定事件，可以使用 CloudWatch 警报动作以编程方式重启、停止或终止 EC2 实例。
- en: Now that we have looked at the abilities to monitor our CodeDeploy deployments,
    let's recap what we have learned in this chapter.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何监控我们的 CodeDeploy 部署，让我们回顾一下本章中学到的内容。
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at the other pieces of the AWS developer tools we
    are going to cover in depth in this book. We learned about deploying our software
    to different environments, both in the cloud and on-premises, using AWS CodeDeploy.
    We examined how CodeDeploy can be used to not only push out new versions of an
    application but also to control traffic during deployments. We also studied the
    AWS CodePipeline orchestration tool and how it as a service can incorporate not
    only all of the other three services we have been looking at from a development
    perspective but also other third-party partner tools as well.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了将要深入探讨的其他 AWS 开发者工具。我们了解了如何使用 AWS CodeDeploy 将软件部署到不同的环境，包括云端和本地环境。我们研究了如何使用
    CodeDeploy 不仅推送应用程序的新版本，还能在部署过程中控制流量。我们还学习了 AWS CodePipeline 编排工具，它作为一项服务，不仅能够整合我们从开发角度看到的其他三个服务，还能整合其他第三方合作伙伴工具。
- en: In the next chapter, we will look at the AWS OpsWorks service and how this can
    be helpful for managing infrastructure and application services using stacks,
    especially if your team members are well versed in Chef or Puppet.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍 AWS OpsWorks 服务，以及它如何帮助通过堆栈管理基础设施和应用服务，尤其是当您的团队成员熟悉 Chef 或 Puppet
    时。
- en: Review questions
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习问题
- en: One of the team of developers at a company has made multiple deployments. The
    last deployment with overwrite content failed. You have been tasked with rolling
    back to the previously working version with all the files necessary for the application.
    Which option would you choose to fulfill this requirement in the most expedient
    way possible?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一家公司的开发团队成员进行了多次部署。最后一次部署覆盖内容失败。您被要求回滚到之前的正常版本，并且包含应用程序所需的所有文件。您会选择哪种方式来尽可能迅速地完成此任务？
- en: a. Manually roll back to the last known application version, which will add
    files required for application revision.
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 手动回滚到最后一个已知的应用版本，并添加修订所需的文件。
- en: b. Manually roll back to the previous deployment and then manually add files
    for the application revision.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 手动回滚到上一个部署版本，然后手动添加应用程序修订所需的文件。
- en: c. Automatically roll back to the last known version, which will add files required
    for application revision.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 自动回滚到最后一个已知版本，并添加应用程序修订所需的文件。
- en: d. Automatically roll back to the last known application version and manually
    add files for application revision.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 自动回滚到最后一个已知的应用版本，并手动添加应用程序修订所需的文件。
- en: 'You have constructed an AWS code pipeline that carries out a code release process.
    There are two stages to this pipeline: a source stage and a deploy stage. The
    source stage is using the third-party provider GitHub to source the code for the
    deployments. AWS CodeDeploy is being used to deploy the new versions of the application
    to multiple EC2 instances in a target group. The last few deployments have not
    gone successfully, and failures appear during the CodeDeploy stage. You need the
    ability to increase monitoring and notifications for deployments in order to cut
    down your Mean Time to Resolution (MTTR). How can you create notifications as
    soon as an issue is detected?'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你已经构建了一个执行代码发布过程的 AWS 代码管道。这个管道有两个阶段：源阶段和部署阶段。源阶段使用第三方提供商 GitHub 来提供部署所需的代码。AWS
    CodeDeploy 被用来将新版本的应用程序部署到目标组中的多个 EC2 实例。最近的几次部署都没有成功，且在 CodeDeploy 阶段出现了失败。你需要增加监控和通知的能力，以缩短平均修复时间（MTTR）。如何在检测到问题时尽快创建通知？
- en: a. Set up CloudWatch events for both CodeDeploy and CodePipeline. Use Amazon
    Inspector to create an assessment target to assess code deployment issues and
    create an SNS topic so that you can be notified of deployment issues.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 为 CodeDeploy 和 CodePipeline 设置 CloudWatch 事件。使用 Amazon Inspector 创建评估目标来评估代码部署问题，并创建一个
    SNS 主题，以便在发生部署问题时能够收到通知。
- en: b. Set up CloudWatch events for both CodeDeploy and CodePipeline. Use an AWS
    Lambda function to help assess code deployment issues and create an SNS topic
    so that you can be notified of deployment issues.
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 为 CodeDeploy 和 CodePipeline 设置 CloudWatch 事件。使用 AWS Lambda 函数帮助评估代码部署问题，并创建一个
    SNS 主题，以便在发生部署问题时能够收到通知。
- en: c. Set up a new AWS CloudTrail trail for the region that the pipeline is running
    in. Use AWS Config to assess any code deployment issues and create an SNS topic
    so that you can be notified of any deployment issues.
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 为管道运行所在的区域设置一个新的 AWS CloudTrail 路径。使用 AWS Config 来评估任何代码部署问题，并创建一个 SNS 主题，以便在发生部署问题时能够收到通知。
- en: d. Set up a new AWS CloudTrail to capture API events from CodeDeploy and CodePipeline.
    Use an AWS Lambda function to help assess code deployment issues and create an
    SNS topic so that you can be notified of deployment issues.
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 设置一个新的 AWS CloudTrail 来捕获来自 CodeDeploy 和 CodePipeline 的 API 事件。使用 AWS Lambda
    函数帮助评估代码部署问题，并创建一个 SNS 主题，以便在发生部署问题时能够收到通知。
- en: Review answers
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查答案
- en: d
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: b
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
