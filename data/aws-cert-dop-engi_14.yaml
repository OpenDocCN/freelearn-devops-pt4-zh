- en: 'Chapter 12: Lambda Deployments and Versioning'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章：Lambda 部署和版本控制
- en: As more and more application architectures go serverless and more and more cloud
    budgets are scrutinized, AWS Lambda becomes more and more of a viable option in
    both the Developer and Operations professions' tool belts. Knowing how to harness
    the flexibility and power of Lambda and Step functions is key to success in today's
    AWS environments.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着越来越多的应用架构走向无服务器，越来越多的云预算受到审视，AWS Lambda 成为开发者和运维人员工具箱中越来越可行的选择。了解如何利用 Lambda
    和 Step Functions 的灵活性和强大功能是当今 AWS 环境成功的关键。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: AWS Lambda overview
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Lambda 概述
- en: Lambda functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 函数
- en: Lambda triggers and event source mappings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 触发器和事件源映射
- en: Deploying versions using Lambda
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Lambda 部署版本
- en: Working with Lambda layers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Lambda 层
- en: Monitoring Lambda functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控 Lambda 函数
- en: Optimal Lambda use cases and anti-patterns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 最佳使用案例和反模式
- en: Orchestrating Step Functions with Lambda
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Lambda 协调 Step Functions
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As in the previous chapters, we will be using the Python programming language
    to create our Lambda functions. Basic working knowledge of Python is suggested
    to follow the examples and debug and troubleshoot if necessary.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，我们将使用 Python 编程语言创建 Lambda 函数。建议具备基本的 Python 工作知识，以便跟随示例并在必要时进行调试和故障排除。
- en: AWS Lambda overview
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS Lambda 概述
- en: AWS Lambda is a service that allows you to run your code as a function, without
    the need to stand up any servers or provision or orchestrate containers. It automatically
    scales to the number of requests that it receives. One of the most attractive
    items about Lambda functions is that they are only charged for the time they run.
    This means that you can have your platform provisioned in one or multiple regions,
    waiting for requests, without worrying how much the bill will accumulate from
    idle resources.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda 是一种允许您将代码作为函数运行的服务，无需设置任何服务器或进行容器编排。它会自动根据接收到的请求数量进行扩展。Lambda 函数最吸引人的特点之一是它们仅按运行时间收费。这意味着您可以在一个或多个区域内配置平台，等待请求，而不必担心因空闲资源而产生的账单。
- en: 'Lambda lets you concentrate on the code instead of servers as it is a serverless
    Platform as a Service offering. Being a PaaS also means that you have no access
    to the underlying compute platform to make adjustments other than those that AWS
    exposes to you, such as the runtime (programming language) or your environment,
    the amount of memory that your function needs to use, and the amount of CPU allocated:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 让您专注于代码，而不是服务器，因为它是一个无服务器的 PaaS（平台即服务）产品。作为 PaaS 也意味着，除非 AWS 向您暴露，否则您无法访问底层计算平台进行调整，例如运行时（编程语言）、您的环境、函数需要使用的内存量以及分配的
    CPU 数量：
- en: '![Figure 12.1 – Lambda architecture with triggers'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.1 – 带触发器的 Lambda 架构](img/Figure_12.1_B17405.jpg)'
- en: '](img/Figure_12.1_B17405.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.1_B17405.jpg)'
- en: Figure 12.1 – Lambda architecture with triggers
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – 带触发器的 Lambda 架构
- en: Many Lambda functions are events that are triggered by other AWS services. This
    is another fact that makes the service so appealing. Lambda functions can be used
    to do backend processing based on S3 bucket events. Then, you can put them into
    a decoupled architecture using a message queue, such as **Simple Queue Service**
    or **Amazon MQ**, for processing by one or more concurrent Lambda functions to
    put the data into a backend data store.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Lambda 函数是由其他 AWS 服务触发的事件。这也是该服务如此有吸引力的原因之一。Lambda 函数可以用于基于 S3 存储桶事件进行后台处理。然后，您可以将它们放入一个解耦的架构中，使用消息队列，如**简单队列服务（Simple
    Queue Service）**或**Amazon MQ**，由一个或多个并发的 Lambda 函数进行处理，将数据存入后端数据存储中。
- en: The data can then be retrieved using either RESTful calls from a service such
    as **API Gateway** by utilizing GraphQL with **AppSync**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以使用诸如**API 网关**的服务通过 GraphQL 和**AppSync**来检索数据。
- en: Serverless instead of servers
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无服务器而非服务器
- en: 'The term **serverless** should instantly bring a few critical thoughts to mind.
    In the world of AWS, this boils down to four fundamental principles:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**无服务器**这一术语应立刻让人联想到一些关键概念。在 AWS 的世界中，这可以归结为四个基本原则：'
- en: '**There are no servers to provision**: There should be no actual servers or
    instances to configure or maintain. There should also be no container orchestration
    needed on your part.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无需配置服务器**：不需要实际配置或维护任何服务器或实例。您也不需要对容器进行编排。'
- en: '**The system and architecture scale with usage**: As requests, data, or events
    come in, the underlying platform and infrastructure should automatically scale
    out and scale in to meet the necessary demand.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统和架构随使用情况自动扩展**：随着请求、数据或事件的到来，底层平台和基础设施应自动进行扩展以满足所需的需求。'
- en: '**You pay for value**: Resources that are sitting idle, waiting to be used,
    should not incur charges. Charges should only occur when the resources are actively
    being utilized.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按价值付费**：那些处于空闲状态、等待被使用的资源不应产生费用。只有在资源被实际使用时才会产生费用。'
- en: '**The system is built for availability and fault tolerance**: Once you''re
    launching your platform, it should automatically span multiple availability zones,
    increasing your availability and fault tolerance.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统是为可用性和容错性而构建的**：一旦您启动平台，它应该自动跨多个可用区扩展，从而提高您的可用性和容错性。'
- en: As you talk to people who have used a serverless platform in the real world,
    they feel like they have derived numerous benefits from making the switch. One
    such benefit is **greater agility** and the ability to move faster since they
    are not spending as much time setting up and provisioning infrastructure. Separating
    themselves from dealing with instance and container configuration allows them
    to **better focus** on their business and the features that their customers want
    and find valuable. They also feel as though they have **increased scale** compared
    to the previous capacity that customers used to have in their data centers. This
    is because Lambda will scale up automatically based on the number of invocations
    to a particular function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与那些在实际应用中使用过无服务器平台的人交谈时，他们通常会感觉从转向无服务器架构中获得了诸多好处。一个这样的好处是**更高的灵活性**和更快的行动能力，因为他们不再花费大量时间来设置和配置基础设施。将自己从实例和容器配置中解脱出来，能够**更好地专注**于他们的业务以及客户想要且认为有价值的功能。他们还觉得与以前数据中心的客户使用的容量相比，他们的**规模增加了**。这是因为Lambda会根据某个特定函数的调用次数自动扩展。
- en: Synchronous versus asynchronous invocation
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步与异步调用
- en: 'When you invoke a Lambda function, it can be done in one of two ways: either
    synchronously or asynchronously.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用Lambda函数时，可以选择两种方式之一：同步或异步。
- en: Lambda will run the function on a synchronous invocation, wait for the response,
    and then return the response code with any data included in the function's return
    call. You can use the `invoke` command from the AWS CLI to invoke a function synchronously.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda将在同步调用中运行该函数，等待响应，然后返回响应代码以及函数返回调用中包含的任何数据。您可以使用AWS CLI中的`invoke`命令来同步调用函数。
- en: 'With asynchronous invocations, you are pushing the event to Lambda but not
    waiting for an immediate response. Lambda will queue up the events before sending
    them to the function:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异步调用时，您将事件推送到Lambda，但不会等待即时响应。Lambda会先将事件排队，然后再将其发送到函数：
- en: '![Figure 12.2 – Asynchronous invocation in Lambda'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.2 – Lambda中的异步调用'
- en: '](img/Figure_12.2_B17405.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.2_B17405.jpg)'
- en: Figure 12.2 – Asynchronous invocation in Lambda
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – Lambda中的异步调用
- en: Lambda manages the functions event queue and, upon receiving an error, will
    attempt to retry the event. If it fails, it will try twice more with a longer
    time in-between each additional attempt.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda管理着函数的事件队列，并在收到错误时，会尝试重试事件。如果重试失败，它会再尝试两次，每次重试的间隔时间会更长。
- en: Now that we have taken an initial look at how we can invoke a Lambda function,
    let's take a deeper look at Lambda functions themselves.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们初步了解了如何调用Lambda函数，让我们深入研究一下Lambda函数本身。
- en: Lambda functions
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda函数
- en: The code you write becomes the function that runs without the need for provisioning
    or managing any servers. The function itself is the resource and can take in events
    that have been passed to it, either by you or other AWS services.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您编写的代码就是运行的函数，无需配置或管理任何服务器。该函数本身就是资源，可以接收传递给它的事件，无论是您自己还是其他AWS服务传递的事件。
- en: You can use a few different languages that are supported to create your Lambda
    functions. These include Python, Node.js, Ruby, Java, Go, and .NET. You can even
    create custom runtimes by using containers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用几种支持的语言来创建Lambda函数，包括Python、Node.js、Ruby、Java、Go和.NET。您甚至可以通过使用容器来创建自定义运行时。
- en: The basic concepts of Lambda
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda的基本概念
- en: 'When you start a Lambda function, that process is called **invoking** the function.
    Lambda functions process events. Events are sent to your functions in a few different
    ways: you can manually invoke the function, such as with a test event, or you
    can configure an AWS resource or service to invoke it and start the process.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动 Lambda 函数时，这个过程称为 **调用** 函数。Lambda 函数处理事件。事件可以通过几种不同方式发送到你的函数：你可以手动调用函数，如使用测试事件，或者可以配置
    AWS 资源或服务来调用它并启动进程。
- en: Since we're talking about Lambda functions, there are a few key concepts that
    need to be understood.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在讨论 Lambda 函数，有几个关键概念需要理解。
- en: Function
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数
- en: A function is the code where you process your events. It is what is invoked
    when you call the Lambda process, either by an event, schedule, or manually.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是你处理事件的代码。当你通过事件、计划任务或手动调用 Lambda 进程时，函数会被调用。
- en: Qualifier
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标识符
- en: Lambda functions can have versions and aliases. Once a version has been created,
    it is a fixed version of the code and contains a numerical qualifier at the end.
    Although the `$LATEST` version of your Lambda code is the one that you can constantly
    be updating, if you wanted to call that version that you snapshotted in time,
    such as `test-function:1`, you would need to append the version number to the
    end.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数可以有版本和别名。一旦版本创建，它就是代码的固定版本，并且末尾带有一个数字标识符。虽然 `$LATEST` 版本是你可以不断更新的 Lambda
    代码版本，但如果你想调用某个快照版本，如 `test-function:1`，则需要在版本号后追加版本号。
- en: Runtime
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行时
- en: The runtime in Lambda allows you to choose the language, along with the language
    version, that your function will execute. This runtime is not contained within
    the function itself; instead, it sits between the Lambda service and the function
    code. Not only can you use the runtimes that the Lambda service provides, but
    you can also build your own if there is a language and version that you desire
    that the service itself does not support.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 中的运行时允许你选择语言以及语言版本，以便执行你的函数。这个运行时并不包含在函数内部；它位于 Lambda 服务和函数代码之间。你不仅可以使用
    Lambda 服务提供的运行时，还可以在服务本身不支持的语言和版本下构建自己的运行时。
- en: Event
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件
- en: 'An event in Lambda is a JSON document that consists of data for the function
    to process. Events can be simple and single-tiered, as shown in the following
    example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 中的事件是一个包含待处理数据的 JSON 文档。事件可以是简单的和单层的，如下例所示：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: They can be also complex, coming from AWS services with nested keys and values
    that require complex parsing. These complex events can hold valuable data that
    can automate processes and make your life, as a DevOps professional, easier if
    you learn how to harness their power.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可能是复杂的，来自 AWS 服务，并且包含需要复杂解析的嵌套键值对。这些复杂的事件可以包含有价值的数据，能够自动化流程并使你作为 DevOps 专业人员的工作变得更轻松，只要你学会如何利用它们的力量。
- en: The Lambda handler
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda 处理器
- en: 'A handler can be any name, but the default name, especially when creating a
    function in the AWS Console, is `Lambda_function.Lambda_handler`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器可以是任何名称，但默认名称，尤其是在 AWS 控制台中创建函数时，是 `Lambda_function.Lambda_handler`：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In our example Lambda code, we can see two arguments being passed to the Lambda
    handler: the event and the context.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们示例的 Lambda 代码中，我们可以看到有两个参数被传递给 Lambda 处理器：event 和 context。
- en: The `event` argument is a JSON formatted document that includes the data for
    the Lambda function to process. While it is often a dictionary object, it can
    also be a list, string, integer, or floating-point number.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`event` 参数是一个 JSON 格式的文档，其中包含 Lambda 函数需要处理的数据。虽然它通常是一个字典对象，但也可以是列表、字符串、整数或浮动点数。'
- en: Using a combination of the event handler and a parser, you can grab information
    about which specific resources invoked the Lambda function and then perform the
    necessary actions from there. By using `returns`, such as the greeting in the
    simple example shown previously, you can call other methods inside your function
    based on the information you find. You could even have the entire function return
    a value. This is especially useful in the case of **Step Functions**, which we
    will look at later in this chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过事件处理器和解析器的组合，你可以获取有关哪些特定资源调用了 Lambda 函数的信息，然后从那里执行必要的操作。通过使用 `returns`，例如之前简单示例中的问候语，你可以基于找到的信息调用函数内部的其他方法。你甚至可以让整个函数返回一个值。这在
    **Step Functions** 中尤其有用，我们将在本章后面讨论这个。
- en: The `context` argument is passed to the Lambda function at runtime. This argument
    contains information regarding the invocation, the runtime environment, and the
    function itself.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`context`参数在运行时传递给Lambda函数。此参数包含有关调用、运行时环境和函数本身的信息。'
- en: Limits of Lambda
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda的限制
- en: As you go about creating your Lambda functions, it's helpful to understand some
    of the constraints that the Lambda service has put into place. The minimum amount
    of memory for a function is 128 MB, while the maximum is 3,008 MB. The longest
    execution time allowed for a Lambda function is 15 minutes or 900 seconds. You
    can only have a maximum of 4 KB in environment variables. There is a concurrency
    limit of 1,000 concurrent executions per function. If you are extracting data
    or using the `/tmp` disk space, you have a limit of 512 MB.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建Lambda函数时，了解Lambda服务的一些限制是很有帮助的。一个函数的最小内存为128 MB，最大为3,008 MB。Lambda函数允许的最长执行时间为15分钟或900秒。环境变量最大只能有4
    KB。每个函数的并发执行限制为1,000次。如果你在提取数据或使用`/tmp`磁盘空间时，有512 MB的限制。
- en: Creating a Lambda function
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Lambda函数
- en: With an understanding of how Lambda functions work, we will now start creating
    our Lambda function. The function that we will create will take a URL that's been
    passed to it and then count the number of words on the web page. Since we will
    need external packages, we will need to create a ZIP package first and then upload
    that to the Lambda service.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Lambda函数的工作原理后，我们将开始创建我们的Lambda函数。我们将创建的函数会接收一个传入的URL，并计算该网页上的单词数。由于我们需要外部包，因此我们首先需要创建一个ZIP包，然后将其上传到Lambda服务中。
- en: There are times when you can just write a simple function in the AWS Management
    Console itself using the built-in editor in the Lambda service. This includes
    the Python language and the `boto` and `botocore` modules, which allow you to
    take advantage of the Python `random` to help you generate random numbers and
    values, `OS` to allow you to call operating system functionality, and `math`,
    `gzip`, and `logging`, along with quite a few others.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可以直接在AWS管理控制台中使用Lambda服务内置的编辑器编写一个简单的函数。这包括Python语言及其`boto`和`botocore`模块，它们允许你利用Python的`random`来帮助生成随机数和随机值，`OS`允许你调用操作系统功能，`math`、`gzip`和`logging`模块，以及其他许多模块。
- en: 'Follow these steps to build our Lambda package so that it can be uploaded:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建我们的Lambda包，以便上传：
- en: 'Let''s start by opening our terminal and creating a role for our Lambda function
    to use. With our terminal open, we will navigate to the beginning of our directory
    and then create a new directory for our Lambda. Once created, go into that directory:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先打开终端并为我们的Lambda函数创建一个角色。终端打开后，我们将导航到目录的起始位置，然后为我们的Lambda创建一个新目录。创建后，进入该目录：
- en: '[PRE2]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will use the following JSON saved to a file named `Lambda-role-policy.json`;
    you can also find this file in the `Chapter-12` folder of the GitHub repository
    for this book:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用以下JSON，保存为名为`Lambda-role-policy.json`的文件；你也可以在本书的GitHub仓库中的`Chapter-12`文件夹里找到这个文件：
- en: '[PRE3]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Use this file in the following command to create the role that our Lambda function
    will use:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此文件在以下命令中创建我们Lambda函数将使用的角色：
- en: '[PRE4]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This should come back with a JSON return showing the successful creation of
    the role, similar to the following output:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该命令应返回一个JSON格式的输出，显示角色创建成功，类似于以下输出：
- en: '[PRE5]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our role has now been created for our Lambda to use; however, it cannot do
    much since there is currently no policy attached. Instead of writing a custom
    policy, we will use a predefined AWS policy created for Lambdas:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的角色已经为Lambda创建好了；然而，由于目前没有附加任何策略，它不能做太多事情。我们不会编写自定义策略，而是使用AWS为Lambda创建的预定义策略：
- en: '[PRE6]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With our role created and ready to use, let''s remove the current file in the
    directory so that it doesn''t get deployed with our `zip` package later. We are
    going to use the `remove` command for the file. However, if you would like to
    save it, I would suggest using the `copy` or `move` command to your `/tmp` directory
    or `Downloads` so that you can access it later:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的角色创建并准备好使用后，让我们删除当前目录中的文件，以防它被随后的`zip`包一起部署。如果你希望保存它，我建议使用`copy`或`move`命令将其转移到`/tmp`目录或`Downloads`，以便稍后访问：
- en: '[PRE7]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we will create a new file called `Lambda_function.py`. In this function,
    we will cut and paste (or type, if you''re brave) the following code. Alternatively,
    once again, you can find the full file in the `Chapter-12` directory of this book''s
    GitHub repository:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个新的文件，名为`Lambda_function.py`。在这个函数中，我们将剪切并粘贴（或者如果你敢的话，直接输入）以下代码。或者，你也可以在本书的GitHub仓库中的`Chapter-12`目录找到完整的文件：
- en: '[PRE8]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, the directory structure of your `my-wc-function` directory should look
    like this:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你的`my-wc-function`目录结构应该是这样的：
- en: '[PRE9]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'At this point, we can start installing our dependent modules locally using
    the `–target`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，我们可以开始使用`–target`在本地安装我们的依赖模块：
- en: '[PRE10]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s make the deployment package. First, we will navigate into the `package`
    directory that we just created and then create the initial `zip` file. Take note
    of the two dots in the `zip` command; these are telling the `zip` file to be created
    in the directory and not in the `package` directory:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们来制作部署包。首先，我们将进入刚刚创建的`package`目录，然后创建初始的`zip`文件。注意`zip`命令中的两个点，它们是告诉`zip`文件要在当前目录中创建，而不是在`package`目录中：
- en: '[PRE11]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With our initial `zip` file created, we can add our Python file to the `zip`
    file:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建好我们的初始`zip`文件后，我们可以将Python文件添加到`zip`文件中：
- en: '[PRE12]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After running this command, you should see that the `Lambda_function.py` file
    has been added to the previously created `zip` package.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行此命令后，你应该看到`Lambda_function.py`文件已经被添加到之前创建的`zip`包中。
- en: We now have our deployment package created and are ready to move on to the AWS
    Management Console so that we can upload and test our function. This could all
    be continued from the CLI, but the console has some features that aren't available
    from the CLI.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了部署包，准备继续使用AWS管理控制台上传并测试我们的函数。所有这些也可以从CLI继续，但控制台有一些CLI中没有的功能。
- en: Open your web browser and navigate to the Lambda service after logging in using
    your administrative account. You can get to the service directly by going to the
    [https://console.aws.amazon.com/Lambda](https://console.aws.amazon.com/lambda).
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的浏览器，登录管理账户后访问Lambda服务。你可以通过直接访问[https://console.aws.amazon.com/Lambda](https://console.aws.amazon.com/lambda)来进入该服务。
- en: Find and click on the orange **Create function** button near the top right-hand
    side of the main screen.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到并点击主屏幕右上方的橙色**创建函数**按钮。
- en: Once you're on the `my-word-count_python`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你进入`my-word-count_python`。
- en: '`python 3.8`.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`python 3.8`。'
- en: '`Lambda-12` role that we created earlier:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们之前创建的`Lambda-12`角色：
- en: '![Figure 12.3 – Choosing the existing role we created on the Lambda Create
    Function screen'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.3 – 在Lambda创建函数屏幕上选择我们创建的现有角色](img/Figure_12.3_B17405.jpg)'
- en: '](img/Figure_12.3_B17405.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.3_B17405.jpg)'
- en: Figure 12.3 – Choosing the existing role we created on the Lambda Create Function
    screen
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – 在Lambda创建函数屏幕上选择我们创建的现有角色
- en: Once you have filled in all the values, click on the orange **Create Function**
    button.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写完所有值后，点击橙色的**创建函数**按钮。
- en: Once you have created your function, which should take you to the main screen
    for this Lambda function, we need to upload the ZIP file that we created. So,
    under the `my-wc-package.zip` on your local system. Press the **Save** button
    to send the ZIP file and its code to AWS Lambda:![Figure 12.4 – Uploading the
    .zip file we previously created to our Lambda function
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你创建了你的函数（这应该会将你带到该Lambda函数的主屏幕），我们需要上传我们创建的ZIP文件。因此，在你的本地系统中找到`my-wc-package.zip`。点击**保存**按钮将ZIP文件及其代码发送到AWS
    Lambda：![图 12.4 – 将我们之前创建的.zip文件上传到我们的Lambda函数](img/Figure_12.4_B17405.jpg)
- en: '](img/Figure_12.4_B17405.jpg)'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_12.4_B17405.jpg)'
- en: Figure 12.4 – Uploading the .zip file we previously created to our Lambda function
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.4 – 将我们之前创建的.zip文件上传到我们的Lambda函数
- en: Once you have uploaded the ZIP file, multiple folders should appear on the left-hand
    side of the `Lambda_function.py` file.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你上传了ZIP文件，多个文件夹应该出现在`Lambda_function.py`文件的左侧。
- en: To see our new function work, we will need to create a test event. Click on
    the orange `Test1` and then click on the orange **Create** button at the bottom
    of the dialog.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了查看我们新创建的函数的效果，我们需要创建一个测试事件。点击橙色的`Test1`，然后点击对话框底部的橙色**创建**按钮。
- en: With our test event created, we can run the test. Click on the arrow next to
    the **Test** button and choose the **Test1** option when it appears. With the
    correct test event selected, we can click on the orange **Test** button once more
    to start the test.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建好测试事件后，我们可以运行测试。点击**测试**按钮旁边的箭头，出现时选择**Test1**选项。选中正确的测试事件后，我们可以再次点击橙色的**测试**按钮开始测试。
- en: After running the test, you should see a count of all the words in our demo
    URL from the **Execution result** page.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试后，你应该能在**执行结果**页面看到我们演示URL中所有单词的计数。
- en: This exercise took us through creating and testing a Lambda function that had
    dependencies on third-party libraries from scratch. Next, we will look at triggers
    and source mappings for our functions so that they can run automatically when
    specific events occur.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本次练习带领我们从头创建和测试一个Lambda函数，该函数依赖于第三方库。接下来，我们将学习如何为我们的函数设置触发器和源映射，以便在特定事件发生时自动运行。
- en: Lambda triggers and event source mappings
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda触发器和事件源映射
- en: 'Lambda triggers are especially useful for kicking off numerous applications
    when a piece of data is uploaded to a specific S3 bucket. AWS provides examples
    of images being uploaded to buckets in many of its talks and presentations. This
    image then triggers a Lambda function, which will resize the image so that it''s
    more compressed and then place it in a folder for GIFs. Many times, this same
    function will place a pointer for the newly resized image in a DynamoDB table.
    These resized images are more accessible and quicker for end users to download,
    and this all happens automatically once a source image has been uploaded:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda触发器特别适用于当一段数据上传到特定的S3桶时启动多个应用程序。AWS在许多讲座和演示中提供了将图像上传到桶的示例。然后，这张图像会触发Lambda函数，该函数会调整图像大小，使其更加压缩，然后将其放入GIF文件夹中。很多时候，这个函数还会在DynamoDB表中为新调整大小的图像放置一个指针。这些调整大小的图像对最终用户来说更易于访问并且下载更快，这一切都在上传源图像后自动发生：
- en: '![Figure 12.5 – The flow of an image being uploaded to an S3 bucket that triggers
    a lambda function for image resizing](img/Figure_12.5_B17405.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5 – 上传图像到S3桶的流程，触发Lambda函数进行图像调整大小](img/Figure_12.5_B17405.jpg)'
- en: Figure 12.5 – The flow of an image being uploaded to an S3 bucket that triggers
    a Lambda function for image resizing
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – 上传图像到S3桶的流程，触发Lambda函数进行图像调整大小
- en: There are even more things we can do with bucket triggers than just image resizing,
    especially in an enterprise and DevOps context. Remember that S3 can be used as
    source code storage since it has versioning capabilities if they've been turned
    on. Suppose a new file has been uploaded to a particular folder with a specific
    file extension (for example, `*.py`). In that case, that upload could kick off
    our CodePipeline job to build a new container and push that container through
    as many steps as we have until any manual gates are encountered.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过桶触发器做的不仅仅是图像调整大小，尤其是在企业和DevOps环境中。记住，S3可以作为源代码存储，因为它具有版本控制功能（如果已启用）。假设一个新文件已上传到某个特定文件夹，并具有特定的文件扩展名（例如`*.py`）。在这种情况下，这次上传可以触发我们的CodePipeline作业来构建一个新的容器，并将该容器通过我们设定的所有步骤，直到遇到任何手动审批步骤。
- en: Now that we've looked at how triggers can invoke Lambda, let's look at how streaming
    data can be pushed to different queuing services so that Lambda can asynchronously
    process the data.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过触发器如何调用Lambda，让我们看看如何将流式数据推送到不同的队列服务，以便Lambda可以异步处理数据。
- en: Looking at event source mappings
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看事件源映射
- en: Since Lambda is an automatically scalable service, it can take the information
    from certain other services that are sending data to it and then process that
    information. This information may or may not go directly to the Lambda function.
    These are intermediary services such as message queues, which take the instream
    of data and then invoke the Lambda function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Lambda是一个自动可扩展的服务，它可以接收来自其他服务的某些信息并处理这些信息。这些信息可能会直接进入Lambda函数，也可能不会。这些中介服务，例如消息队列，接收数据流，然后触发Lambda函数。
- en: Services that Lambda can read from event sources
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda可以从事件源读取的服务
- en: 'The following services can provide event source mappings for the Lambda service:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下服务可以为Lambda服务提供事件源映射：
- en: DynamoDB
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DynamoDB
- en: Kinesis
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kinesis
- en: Amazon MQ
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊MQ
- en: Amazon Managed Streaming for Apache Kafka
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊托管的Apache Kafka流媒体服务
- en: Amazon SQS
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊SQS
- en: Now that we have seen how Lambda functions can be invoked by different AWS services
    and even sources, let's learn how to update our functions using versions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Lambda函数如何被不同的AWS服务甚至其他源调用，让我们学习如何通过版本来更新我们的函数。
- en: Deploying versions using Lambda
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Lambda部署版本
- en: If you have a known good state for your Lambda function, you can freeze it from
    future changes by publishing a version of the function. Once published, this version
    will be called and used by users and services independently of any changes or
    updates made to future versions, including iterations done on the `$Latest` function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个已知的 Lambda 函数的良好状态，你可以通过发布该函数的版本来冻结它，避免未来的更改。一旦发布，这个版本将被用户和服务独立调用并使用，不受未来版本更改或更新的影响，包括对
    `$Latest` 函数进行的迭代。
- en: 'When you publish a version of a Lambda function, it contains the following
    information:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发布一个 Lambda 函数的版本时，它包含以下信息：
- en: The function code, as well as all the dependencies that are associated with
    it.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数代码以及与之相关的所有依赖项。
- en: The Lambda runtime that invokes the function.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用函数的 Lambda 运行时。
- en: All of the function settings, such as memory, VPC association, and IAM role.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的函数设置，如内存、VPC 关联和 IAM 角色。
- en: Any environment variables that have been added to the function.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加到函数中的任何环境变量。
- en: 'A unique **Amazon Resource Name** (**ARN**), so that the distinct version of
    the function can be identified:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个唯一的 **Amazon 资源名称**（**ARN**），以便可以识别该函数的特定版本：
- en: '![Figure 12.6 – Lambda versions and how they map to aliases'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.6 – Lambda 版本及其如何映射到别名](img/Figure_12.6_B17405.jpg)'
- en: '](img/Figure_12.6_B17405.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.6_B17405.jpg)'
- en: Figure 12.6 – Lambda versions and how they map to aliases
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 – Lambda 版本及其如何映射到别名
- en: 'Versions can be referenced in one of two ways: either with a qualified ARN
    or with an unqualified ARN.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 版本可以通过两种方式之一来引用：通过限定 ARN 或通过未限定 ARN。
- en: 'A qualified ARN will have a version suffix at the end of the function ARN:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一个限定的 ARN 会在函数 ARN 末尾有版本后缀：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'An unqualified ARN will not have a suffix at the end of the function ARN:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一个未限定的 ARN 将不会在函数 ARN 末尾有后缀：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we have learned about versions for our Lambda functions, let's look
    at how we can use aliases in conjunction with our versions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Lambda 函数的版本，接下来我们来看一下如何将别名与版本一起使用。
- en: Using aliases in Lambda
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Lambda 中使用别名
- en: Aliases allow you to create named pointers to specific versions of your Lambda
    deployments. This is especially helpful if you have passed the ARN of your Lambda
    function to a user or other application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 别名允许你为 Lambda 部署的特定版本创建命名指针。如果你已经将 Lambda 函数的 ARN 传递给用户或其他应用程序，这尤其有用。
- en: Unless you were in a testing environment, you wouldn't want to pass along the
    base Lambda ARN since that would point to the `$Latest` version. This `$Latest`
    version can constantly be changing and be subject to errors and bugs while new
    features and fixes are being tested and deployed. Instead, by using an alias,
    you can point users to a specific, stable version of the function and seamlessly
    transition to a new version of the function once published, tested, and ready
    for release.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你处于测试环境中，否则你不会想要传递基础的 Lambda ARN，因为那会指向 `$Latest` 版本。这个 `$Latest` 版本会不断变化，并且在测试和部署新功能和修复时可能会出现错误和漏洞。相反，通过使用别名，你可以将用户指向一个特定的、稳定的函数版本，并且在发布、测试并准备好发布新版本时，可以无缝过渡到新版本。
- en: Working with Lambda layers
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Lambda 层
- en: 'A Lambda layer is a pre-published collection of code dependencies and libraries.
    If you find that you (or you, as a team) are using the same snippets of code in
    multiple functions, you can create a layer to get the benefits of Lambda layers.
    First, when there is a change to one of the dependencies, you no longer have to
    update each of the functions; instead, you only maintain a single layer that all
    the functions can take advantage of and only needs to be maintained one time:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 层是一个预先发布的代码依赖项和库的集合。如果你发现你（或你的团队）在多个函数中使用相同的代码片段，可以创建一个层，利用 Lambda 层的好处。首先，当其中一个依赖项发生变化时，你不再需要更新每个函数；而是只需要维护一个单一的层，所有函数都可以利用这个层，并且只需要维护一次：
- en: '![Figure 12.7 – Lambda functions with and without layers'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.7 – 带有和不带有层的 Lambda 函数](img/Figure_12.7_B17405.jpg)'
- en: '](img/Figure_12.7_B17405.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.7_B17405.jpg)'
- en: Figure 12.7 – Lambda functions with and without layers
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 – 带有和不带有层的 Lambda 函数
- en: Layers are a great way to speed up development between teams. Shared functionality
    such as logging, networking, or even database connectivity can be programmed and
    packaged into a layer once and then called from individual functions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 层是加速团队之间开发的好方法。共享功能，如日志记录、网络或甚至数据库连接，可以一次性编写并打包成层，然后从各个函数中调用。
- en: Adding a Lambda layer to our function
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Lambda 层添加到我们的函数中
- en: We already have a Lambda function from our previous exercise. Now, let's expand
    the functionality of our function by adding a layer that works not only for this
    particular function, but could also be used across numerous functions in our code
    base and organization.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了一个来自上次练习的 Lambda 函数。现在，让我们通过添加一个不仅适用于这个特定函数，而是可以在我们的代码库和组织中多个函数间共享的层来扩展函数的功能。
- en: We have gone through the process of adding a layer to our Lambda function. Next,
    we will learn how to use native AWS to monitor our functions, as well as what
    metrics are the most effective to monitor.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了为 Lambda 函数添加层的过程。接下来，我们将学习如何使用原生 AWS 服务来监控我们的函数，以及哪些指标最有效。
- en: Monitoring Lambda functions
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控 Lambda 函数
- en: Your job is not done once you have developed and deployed your Lambda function.
    To ensure that it is functioning correctly as it runs, specific metrics should
    be monitored. Fortunately, Lambda integrates with several other AWS services to
    help you not only monitor your functions but also troubleshoot them when the need
    arises.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你开发并部署了 Lambda 函数，你的工作并没有完成。为了确保其在运行时能够正确工作，应当监控特定的指标。幸运的是，Lambda 可以与多个其他
    AWS 服务集成，帮助你不仅监控你的函数，还能在需要时排查它们。
- en: 'If you go to the AWS Console in the region where your Lambda function has been
    deployed, you will find a menu item that you can click on in the vertical menu
    bar named **Monitor**:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你前往 AWS 控制台所在区域，并且你的 Lambda 函数已经部署，你会发现垂直菜单栏中有一个名为 **Monitor** 的菜单项，点击它可以进入监控功能：
- en: '![Figure 12.8 – The Monitor menu item from the Lambda function console'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.8 – 来自 Lambda 函数控制台的 Monitor 菜单项'
- en: '](img/Figure_12.8_B17405.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.8_B17405.jpg)'
- en: Figure 12.8 – The Monitor menu item from the Lambda function console
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8 – 来自 Lambda 函数控制台的 Monitor 菜单项
- en: 'Once you enter the **Monitor** section of the Lambda console, you are instantly
    presented with a pre-built dashboard that allows you to see basic but vital metrics
    graphically for your Lambda function at a glance. The following metrics are presented:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入 Lambda 控制台的 **Monitor** 部分，你会立即看到一个预先构建的仪表盘，它允许你一目了然地查看 Lambda 函数的基本但重要的图形化指标。以下是呈现的指标：
- en: '**Invocations**'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用次数**'
- en: '**Duration**'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续时间**'
- en: '**Error count and success rate**'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误计数和成功率**'
- en: '**Throttles**'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制**'
- en: '**Async delivery failure**'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步传输失败**'
- en: '**Iterator Age**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代器年龄**'
- en: '**Concurrent Executions**'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发执行**'
- en: The default timeframe for the dashboard is 3 hours; however, there are preset
    iterations from 1 hour to 1 week. You can also select a custom time range for
    the dashboard to show monitoring.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表盘的默认时间范围为 3 小时；然而，也有从 1 小时到 1 周的预设迭代。你还可以选择自定义时间范围，查看仪表盘上的监控数据。
- en: Another extremely handy feature regarding the **Monitoring** section in the
    AWS Management Console is that it has buttons that allow you to jump right to
    either CloudWatch Logs for the function, X-Ray traces for the function using ServiceLens,
    or look at Lambda Insights via CloudWatch if you have enabled this extra feature.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 AWS 管理控制台中 **Monitoring** 部分的另一个非常实用的功能是，它有一些按钮，可以让你直接跳转到函数的 CloudWatch 日志、使用
    ServiceLens 查看函数的 X-Ray 跟踪，或者如果你启用了该附加功能，还可以通过 CloudWatch 查看 Lambda Insights。
- en: Using X-Ray to help troubleshoot your functions
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 X-Ray 帮助排查你的函数
- en: When you try to troubleshoot an application, especially to find where bottlenecks
    are occurring during the execution of that application or the other services that
    it's calling, you may need more information than your current metrics and logs
    are providing you with. This is when the AWS service can become especially helpful.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试排查应用程序问题，尤其是找出在应用程序执行过程中或其调用的其他服务中出现瓶颈的地方时，你可能需要比当前的指标和日志提供的更多信息。这时，AWS
    服务可以变得特别有用。
- en: X-Ray collects data about your application's requests and then provides you
    with detailed information, including a step-by-step timing of each process. Lambda
    runs the X-Ray daemon any time a function is invoked. This X-Ray daemon listens
    for traffic on UDP port `2000` and gathers the segment data. That segmented data
    is then relayed to the X-Ray API for presentation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: X-Ray 会收集有关你应用程序请求的数据，然后提供详细信息，包括每个过程的逐步时间。每次调用函数时，Lambda 都会运行 X-Ray 守护进程。该
    X-Ray 守护进程监听 UDP 端口 `2000` 的流量并收集分段数据。然后，这些分段数据会被传递到 X-Ray API 进行展示。
- en: Note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will look at the X-Ray service and how it can be used to monitor and watch
    Lambda functions in more detail in [*Chapter 14*](B17405_14_Final_JM_ePub.xhtml#_idTextAnchor366),
    *CloudWatch and X-Ray's Role in DevOps*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入探讨X-Ray服务，以及它如何在[*第14章*](B17405_14_Final_JM_ePub.xhtml#_idTextAnchor366)《CloudWatch与X-Ray在DevOps中的角色》中更详细地用于监控和观察Lambda函数。
- en: Now that we have looked at how to monitor our Lambda functions, we will look
    at both the optimal use cases and the anti-patterns for AWS Lambda.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何监控我们的Lambda函数，接下来我们将讨论AWS Lambda的最佳使用场景和反模式。
- en: Optimal Lambda use cases and anti-patterns
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda的最佳使用场景和反模式
- en: Now that we've looked at the AWS Lambda function as code service in detail,
    let's look at when it is best used and where Lambda is not the best choice. This
    is essential information to understand both as an AWS professional and while pursuing
    your AWS DevOps professional certification.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经详细了解了AWS Lambda作为代码服务的功能，接下来让我们看看什么时候使用Lambda最为合适，以及Lambda在哪些情况下不是最佳选择。这些信息对AWS专业人士和追求AWS
    DevOps认证的人来说都至关重要。
- en: The Lambda service from AWS is very flexible, affordable, and interacts with
    a vast number of AWS services. It also allows you to write your code in many different
    languages that you feel comfortable with and use them as your runtime environment.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: AWS的Lambda服务非常灵活、经济实惠，并与大量AWS服务进行交互。它还允许你使用你熟悉的多种语言编写代码，并将其作为你的运行时环境。
- en: So, let's move on and look at some of the scenarios where Lambda would serve
    us best.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们继续前进，看看在什么场景下Lambda最能发挥作用。
- en: AWS Lambda optimal use cases
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AWS Lambda的最佳使用场景
- en: As more and more teams start to look at serverless solutions and patterns, let's
    look at where using the Lambda service makes sense.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 随着越来越多的团队开始关注无服务器解决方案和模式，我们来看看使用Lambda服务在哪些地方是合理的。
- en: You want to concentrate on the code and not the underlying infrastructure
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你希望专注于代码，而不是底层的基础设施
- en: If you or your team wants to concentrate on the features and code base instead
    of provisioning and patching servers, serverless Lambda functions are an excellent
    choice. You concentrate on the code and simply choose your runtime, amount of
    memory, how long the function is allowed to run, along with a few other options,
    and the Lambda service takes care of the rest. This includes scaling to meet demand
    and managing any underlying hardware.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你或你的团队希望专注于功能和代码库，而不是配置和修补服务器，无服务器Lambda函数是一个非常好的选择。你只需要专注于代码，选择运行时、内存大小、函数的最大运行时间以及一些其他选项，Lambda服务会处理其余的工作。这包括按需扩展和管理底层硬件。
- en: In return for just focusing on the code, you do give up a few things. You can
    no longer log into the underlying compute instances, which, in reality, are containers,
    to check processes or gather and watch logs as they are being generated. Instead,
    you need to add either logging statements or a logging library so that you can
    debug your code using CloudWatch Logs.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 作为专注于代码的回报，你确实会放弃一些功能。你将无法登录到底层的计算实例，实际上这些实例是容器，无法查看进程或在日志生成时进行监视。相反，你需要添加日志语句或日志库，以便通过CloudWatch日志调试代码。
- en: You need a cost-effective solution
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你需要一个具有成本效益的解决方案
- en: Cost optimization is one of the five original service pillars that we spoke
    about in [*Chapter 1*](B17405_01_Final_JM_ePub.xhtml#_idTextAnchor015), *Amazon
    Web Service Pillars*. Organizations are constantly looking at how to make their
    solutions more cost-effective, and using Lambda is usually a great way to do that.
    There are no idle charges for the Lambda service since the charges are calculated
    on a pay-per-use basis. The service also has a perpetual free tier of one million
    invocations per month.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 成本优化是我们在[*第1章*](B17405_01_Final_JM_ePub.xhtml#_idTextAnchor015)《Amazon Web Service基础》提到的五大服务支柱之一。组织总是寻找如何让他们的解决方案更加具有成本效益，而使用Lambda通常是一个不错的选择。Lambda服务没有空闲费用，因为费用是按使用量计算的。该服务还提供一个每月一百万次调用的永久免费层。
- en: One of the ways that this becomes especially useful is if you're crafting your
    DevOps pipeline to deploy to both your primary region and your secondary (or disaster
    recovery) region during each deployment without the worry of incurring extra costs.
    There would be no charge for the secondary deployment since it would not be invoked
    unless a regional or service failure occurred in the primary region. If there
    was an issue, however, you will be steps ahead of others since you would not need
    to stand up any infrastructure or resources. Instead, all you would need to do
    would be repoint to which region's Lambdas were being invoked.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个特别有用的场景是，如果你正在构建 DevOps 管道，在每次部署时将应用程序部署到主区域和次区域（或灾难恢复区域），而无需担心额外费用。在次区域进行的部署不会产生费用，因为除非主区域发生区域或服务故障，否则不会调用该区域。如果发生问题，你将比其他人领先一步，因为你无需搭建任何基础设施或资源。相反，你只需要重新指向正在调用哪个区域的
    Lambda 函数。
- en: Lambda anti-patterns
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda 反模式
- en: Since we just looked at where Lambda was the best choice for our platform, we
    will also look at where Lambda does not make the most sense.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们刚刚讨论了 Lambda 在平台中的最佳使用场景，接下来我们将看看 Lambda 不太适合的场景。
- en: You don't want to update the runtime once the application has been developed
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在应用程序开发完成后，你不想更新运行时环境
- en: With the AWS Lambda service, a specific number of runtimes are supported. The
    use of these languages and versions are not set in stone, however. As language
    versions are deprecated due to lack of support, AWS will no longer support these
    runtimes, nor will they allow any new Lambda functions to be deployed using these
    runtimes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AWS Lambda 服务时，支持特定数量的运行时。不过，这些语言和版本并不是一成不变的。由于某些语言版本因缺乏支持而被弃用，AWS 将不再支持这些运行时，也不允许部署使用这些运行时的新
    Lambda 函数。
- en: Many times, the fix can be as easy as switching the runtime version in the Lambda
    console from the previous version to the new supported version of the runtime.
    If there are dependent packages, libraries, or modules of the older version of
    the runtime, then updates and replacements might need to be found. This can be
    a problem if the original developers or contractors are no longer around.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，解决方法可能只是将 Lambda 控制台中的运行时版本从旧版本切换到新支持的版本。如果存在依赖于旧版本运行时的包、库或模块，那么可能需要更新或替换这些内容。如果原始开发人员或承包商不再在场，这可能会成为一个问题。
- en: You need to call an asynchronous call from your function
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你需要从你的函数中调用一个异步调用
- en: When you need to call an outside service such as an external API to perform
    your task, this is an asynchronous call. This can be done successfully with Lambda.
    However, the call it makes to the initial service may not always return an immediate
    response. Having the function wait for the response from the service is not an
    optimal pattern since the Lambda service is billed based on the number of resources
    consumed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要调用外部服务，比如外部 API 来执行任务时，这是一个异步调用。Lambda 可以成功地实现这一点。然而，调用到初始服务的请求可能并不会立即返回响应。让函数等待服务的响应并不是最佳模式，因为
    Lambda 服务的计费是基于资源消耗的。
- en: Now that we have looked at when to use and not to use Lambda functions, next,
    we will learn how to orchestrate multiple Lambda functions together using Step
    Functions.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了何时使用和不使用 Lambda 函数，接下来我们将学习如何使用 Step Functions 协调多个 Lambda 函数。
- en: Orchestrating Step Functions with Lambda
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Lambda 协调 Step Functions
- en: There may be times when you need to coordinate multiple Lambda functions together
    to perform a larger task. Step Functions can make decisions based on input received
    in the state machine, run steps in parallel, and even be connected to other services
    such as SNS to request human input for tasks.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要将多个 Lambda 函数协调在一起执行一个更大的任务。Step Functions 可以根据状态机接收到的输入做出决策，执行并行步骤，甚至与其他服务（如
    SNS）连接，以请求人工输入。
- en: Step Functions also create a visual workflow that allows you to see the individual
    steps in the process. As the Step Functions run, you can see the success or failure
    of your state machine.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Step Functions 还会创建一个可视化工作流，让你看到流程中的每个步骤。当 Step Functions 运行时，你可以看到状态机的成功或失败。
- en: Understanding state machines inside of Step Functions
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Step Functions 中的状态机
- en: The state machine is the orchestration feature of the Step Function. It defines
    the order in which the steps are run, along with any data that's been received
    from previous states and passed out to be used by other states.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机是 Step Function 的编排功能。它定义了步骤的执行顺序，以及从前一个状态接收到的任何数据，并将其传递给其他状态以供使用。
- en: State machine commands are always written in JSON format. Even if you have written
    your CloudFormation template in YAML format, you will still need to create your
    state machine and its various states in JSON format.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机命令始终以 JSON 格式编写。即使你已经使用 YAML 格式编写了 CloudFormation 模板，你仍然需要以 JSON 格式创建你的状态机及其各种状态。
- en: 'The following is an example of a state machine:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个状态机的示例：
- en: '[PRE15]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that we understand what state machines are and how they differ from Step
    Functions, let's look at how Step Functions work.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了什么是状态机以及它们如何与 Step Functions 区别开来，让我们看看 Step Functions 是如何工作的。
- en: How do Step Functions work?
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Step Functions 是如何工作的？
- en: 'Step Functions work by using a three-step process:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Step Functions 通过使用三步流程来工作：
- en: Define the steps in your application.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义你应用中的步骤。
- en: Verify any state changes.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证任何状态变化。
- en: Run your application and scale it if needed.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的应用并根据需要进行扩展。
- en: Note
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Did you know that, unlike a Lambda function, you cannot trigger a Step Function
    from an `S3` bucket event? Instead, you need to have the bucket event call a separate
    Lambda function that can then invoke the Step Function.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你知道吗，与 Lambda 函数不同，你不能从 `S3` 存储桶事件触发 Step Function？相反，你需要让存储桶事件调用一个单独的 Lambda
    函数，然后再调用 Step Function。
- en: Now that we know the basics of how Step Functions work, let's take a closer
    look at the different states available in Step Functions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Step Functions 的基本原理，接下来让我们更仔细地看看 Step Functions 中可用的不同状态。
- en: States available in Step Functions
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Step Functions 中可用的状态
- en: 'As you start to configure the states for your step functions, you begin to
    create a **state machine**. You do this by using the **Amazon States Language**,
    which is a JSON-based language for defining the different states in your state
    machine. There are states that can do things, transitional states, and then states
    that stop when the task fails or succeeds:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始配置你的 Step Functions 状态时，你开始创建一个 **状态机**。你通过使用 **Amazon 状态语言** 来实现这一点，Amazon
    状态语言是一种基于 JSON 的语言，用于定义状态机中的不同状态。有些状态可以执行操作，有些是过渡状态，还有一些在任务失败或成功时停止：
- en: '![Figure 12.9 – The different states that are available in Step Functions'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.9 – Step Functions 中可用的不同状态'
- en: '](img/Figure_12.9_B17405.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.9_B17405.jpg)'
- en: Figure 12.9 – The different states that are available in Step Functions
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9 – Step Functions 中可用的不同状态
- en: Let's take a closer look at each of these states and what functions they perform.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这些状态及其执行的功能。
- en: Task state
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任务状态
- en: When you create a single unit of work that is to be executed by a state machine,
    then you are creating a `task` state. The `task` state is where you can invoke
    Lambda functions.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个由状态机执行的单个工作单元时，你正在创建一个 `task` 状态。`task` 状态是你可以调用 Lambda 函数的地方。
- en: Choice state
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择状态
- en: The `choice` state allows the state machine to choose between different branches
    to follow based on logical evaluations. You provide a set of choice rules, which
    are rules that evaluate either input or output variables. Based on if the values
    render as true or not, the next step in the state machine is defined.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`choice` 状态允许状态机根据逻辑评估在不同的分支之间进行选择。你提供一组选择规则，这些规则评估输入或输出变量。根据这些值是否为真，状态机的下一步将被定义。'
- en: Although a default choice is not required, it is recommended just in case none
    of your choices match any of the logic. Otherwise, your state machine will stop
    and error out.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然默认选择不是必需的，但建议这样做，以防没有任何选择与逻辑匹配。否则，你的状态机会停止并报错。
- en: Parallel state
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并行状态
- en: As the name implies, a `parallel` state can be used to create multiple branches
    of a state machine that execute at the same time. This can significantly speed
    up the execution time for tasks that are not dependent on each other.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，`parallel` 状态可用于创建状态机的多个分支，这些分支同时执行。对于那些彼此独立的任务，这可以显著加快执行时间。
- en: Fail state
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 失败状态
- en: A `fail` state will stop the execution of your state machine but optionally
    give you the ability to enter either a `Cause` in a field, an `Error` in a field,
    or both. These fields can be especially useful when you're trying to debug larger
    and more complex state machines, and rather than hard-coding in an error code,
    it is better to pass on some of the information from the system.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`fail`状态会停止你的状态机的执行，但可以选择在字段中输入`Cause`（原因）、`Error`（错误）或两者。这些字段在调试较大和更复杂的状态机时尤其有用，与其在代码中硬编码错误代码，不如传递一些系统信息。
- en: Succeed state
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Succeed 状态
- en: The `Succeed` state is a termination state and has no next field.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`Succeed`状态是一个终止状态，没有下一个字段。'
- en: Wait state
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 等待状态
- en: If you need to put a pause in your Step Function, then you can add a `wait`
    state. The `wait` state can be defined by the number of seconds to pause or by
    a timestamp on when to resume.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在步进函数中添加暂停，可以添加一个`wait`状态。`wait`状态可以通过暂停的秒数或恢复的时间戳来定义。
- en: Creating a Step Function
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建步进函数
- en: 'One of the best ways to understand step functions is to create one and then
    watch it execute. We have created a `S3` bucket, which is used to store the Lambda
    functions that have been invoked by the Step Function. If you completed the initial
    Lambda function exercise, you will already have the Lambda in ZIP format, ready
    to upload to this new bucket. The template file can be found in this book''s GitHub
    repository, in the `Chapter-12` folder, called `step_function.yml`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 理解步进函数的最佳方式之一是创建一个，然后观察它的执行过程。我们已经创建了一个`S3`存储桶，用于存储已被步进函数调用的 Lambda 函数。如果你完成了初始的
    Lambda 函数练习，你应该已经拥有以 ZIP 格式保存的 Lambda 函数，准备上传到这个新的存储桶。模板文件可以在本书的 GitHub 仓库中找到，在`Chapter-12`文件夹中，名为`step_function.yml`：
- en: 'Before we run the template, we need to upload the `my-wc-package.zip` file.
    This can be the `S3` bucket that we have been using up to this point. We will
    do this on the command line using the S3 copy command. Make sure that you are
    in the same directory where you have the ZIP file, or that you have moved the
    ZIP file to your current working directory:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行模板之前，我们需要上传`my-wc-package.zip`文件。这可以是我们至今一直使用的`S3`存储桶。我们将通过命令行使用 S3 复制命令来完成此操作。确保你在包含
    ZIP 文件的相同目录中，或者已将 ZIP 文件移动到当前工作目录：
- en: '[PRE16]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Open your terminal and go to the directory where you have downloaded the CloudFormation
    template from the `Chapter-12` folder. Use the following CLI command to create
    the Step Function from the `step_function.yml` template. We will need to know
    the bucket that we uploaded the files to so that we can pass that in as a parameter.
    We will also name our stack `stepTest`:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并转到你从`Chapter-12`文件夹下载 CloudFormation 模板的目录。使用以下 CLI 命令从`step_function.yml`模板创建步进函数。我们需要知道我们上传文件的存储桶，以便将其作为参数传递。我们还将把我们的堆栈命名为`stepTest`：
- en: '[PRE17]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With the Step Function and Lambda function in place, we will log into the AWS
    Management Console using our administrative user. Once logged in, navigate to
    the **Step Function** service.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置好步进函数和 Lambda 函数后，我们将使用管理员用户登录到 AWS 管理控制台。登录后，导航到**步进函数**服务。
- en: Once on the **Step Functions service** page, you should see a state machine
    named **Chapter-Twelve**. Click on the name of the state machine to be taken to
    it:![Figure 12.10 – The Chapter-Twelve state machine created
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入**步进函数服务**页面，你应该能看到一个名为**第十二章**的状态机。点击该状态机的名称，进入它：![图 12.10 – 创建的第十二章状态机
- en: '](img/Figure_12.10_B17405.jpg)'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_12.10_B17405.jpg)'
- en: Figure 12.10 – The Chapter-Twelve state machine created
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.10 – 创建的第十二章状态机
- en: Now, on the **Chapter-Twelve** state machine, click on the **Start execution**
    button. This will open up a dialog box where you can name the execution. Just
    leave the default values as-is and click the orange **Start Execution** button
    at the bottom of the dialog window.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**第十二章**状态机中，点击**开始执行**按钮。这将打开一个对话框，你可以在其中命名执行。只需保持默认值不变，并点击对话框底部的橙色**开始执行**按钮。
- en: 'Once you start the execution, you should see the mapping of the state machine
    and the flow of the steps. You can click on any individual step to see both the
    input and output values:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你开始执行，你应该能够看到状态机的映射和步骤的流动。你可以点击任何单个步骤来查看输入和输出值：
- en: '![Figure 12.11 – The graphical view of the state machine, as generated by AWS'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.11 – 状态机的图形视图，由 AWS 生成'
- en: '](img/Figure_12.11_B17405.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.11_B17405.jpg)'
- en: Figure 12.11 – The graphical view of the state machine, as generated by AWS
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11 – 由AWS生成的状态机图形视图
- en: With that, you have gone through not only the process of creating a Step Function
    but also incorporating the Lambda function we created earlier into our state machine.
    Now, let's quickly recap what we learned in this chapter.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一章的学习，你不仅了解了创建Step Function的过程，还将之前创建的Lambda函数融入到了我们的状态机中。现在，让我们快速回顾一下这一章的内容。
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about the Lambda service and how it is used in serverless
    architectures. We looked at the different components of the Lambda function, from
    its events to its runtimes. We looked at the different ways that Lambda can be
    invoked and even used to build a function from scratch. After that, we learned
    how Step Functions can be used to orchestrate multiple Lambda functions.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们了解了Lambda服务及其在无服务器架构中的应用。我们考察了Lambda函数的不同组件，从事件到运行时环境。我们查看了Lambda可以被调用的不同方式，甚至可以从头开始构建一个函数。之后，我们了解了如何使用Step
    Functions来编排多个Lambda函数。
- en: In the next chapter, we will do a deep dive into Blue/Green deployments, along
    with their variations. We will also talk about how they play an important role
    in the DevOps process since this can be brought up in a variety of ways in different
    testing questions.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨蓝绿部署及其变体。我们还将讨论它们在DevOps过程中扮演的重要角色，因为这可以在不同的测试问题中以多种方式提出。
- en: Questions
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: A developer on your team has created a Lambda function that is triggered by
    an S3 bucket event. The function is supposed to be invoked when an object is placed
    in the bucket. However, the function is not working correctly. This issue needs
    to be debugged and fixed. How can this be accomplished simply and quickly by the
    developer?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你团队中的一位开发人员创建了一个由S3桶事件触发的Lambda函数。该函数应该在对象放入桶中时被调用。然而，函数并没有正常工作。这个问题需要进行调试和修复。开发人员如何简单快速地完成这一任务？
- en: a. Use the Lambda Monitoring Console to help debug the issue.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 使用Lambda监控控制台帮助调试问题。
- en: b. Use AWS CloudTrail Logs.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 使用AWS CloudTrail日志。
- en: c. Open an AWS support case, noting both the ARN of the Lambda function and
    the S3 bucket.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 打开AWS支持案例，注明Lambda函数的ARN和S3桶的名称。
- en: d. Use AWS CloudWatch Logs.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 使用AWS CloudWatch Logs。
- en: You have been asked to help construct a serverless application using AWS Lambda.
    The application needs to be monitored; however, the company does not want to bring
    in any third-party services for monitoring. Although logging and tracking functions
    that call other functions can be tricky, what services from AWS can help you perform
    this task? (Choose 3)
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你被要求帮助构建一个使用AWS Lambda的无服务器应用程序。这个应用程序需要进行监控，但公司不希望引入任何第三方服务进行监控。虽然记录和跟踪调用其他函数的功能可能会比较棘手，但AWS有哪些服务可以帮助你完成这项任务？（选择3项）
- en: a. AWS CloudTrail
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. AWS CloudTrail
- en: b. AWS CloudWatch
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. AWS CloudWatch
- en: c. AWS Inspector
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. AWS Inspector
- en: d. AWS X-Ray
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. AWS X-Ray
- en: You have been brought into a company to help with their serverless architecture.
    They currently have an architecture that has multiple Lambda functions. These
    functions are invoking other functions and are acting as a state machine. The
    company has used older obsolete coding patterns to coordinate the state machine
    and is finding that the code is difficult to repair when it breaks. What service
    could you suggest to them that will help refactor their application and manage
    the state machine?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你被引入一家公司，帮助他们处理无服务器架构。公司目前有一个架构，包含多个Lambda函数，这些函数互相调用，并充当状态机。公司使用了过时的编码模式来协调状态机，并发现当代码出错时修复起来很困难。你可以建议他们使用什么服务来帮助重构他们的应用并管理状态机？
- en: a. AWS Data Pipeline
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. AWS Data Pipeline
- en: b. AWS Step Functions
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. AWS Step Functions
- en: c. AWS Cognito
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. AWS Cognito
- en: d. AWS Beanstalk
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. AWS Beanstalk
- en: Answers
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: d
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: a, b, d
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a, b, d
- en: c
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
