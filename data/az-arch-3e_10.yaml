- en: 10\. Serverless in Azure – Working with Azure Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10\. Azure 中的无服务器——与 Azure Functions 一起工作
- en: In the previous chapter, you learned about various big data solutions available
    on Azure. In this chapter, you will learn how serverless technology can help you
    deal with a large amount of data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你了解了 Azure 上的各种大数据解决方案。在本章中，你将学习无服务器技术如何帮助你处理大量数据。
- en: 'Serverless is one of the hottest buzzwords in technology these days, and everyone
    wants to ride this bandwagon. Serverless brings a lot of advantages in overall
    computing, software development processes, infrastructure, and technical implementation.
    There is a lot going on in the industry: at one end of the spectrum is **Infrastructure
    as a Service (IaaS)**, and at the other is serverless. In between the two are
    **Platform as a Service (PaaS)** and containers. I have met many developers and
    it seems to me that there is some confusion among them about IaaS, PaaS, containers,
    and serverless computing. Also, there is much confusion about use cases, applicability,
    architecture, and implementation for the serverless paradigm. Serverless is a
    new paradigm that is changing not only technology but also the culture and processes
    within organizations.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器（Serverless）是当前技术领域最热门的流行词之一，大家都想赶上这股潮流。无服务器在整体计算、软件开发流程、基础设施和技术实现方面带来了许多优势。这个行业中有许多变化：一端是**基础设施即服务（IaaS）**，另一端则是无服务器。在两者之间的是**平台即服务（PaaS）**和容器。我遇到了许多开发人员，似乎他们对
    IaaS、PaaS、容器和无服务器计算之间存在一些困惑。此外，人们对于无服务器范式的使用场景、适用性、架构和实现也有很多混淆。无服务器是一个新的范式，正在改变不仅是技术，甚至是组织内部的文化和流程。
- en: 'We will begin this chapter by introducing serverless, and will cover the following
    topics as we progress:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将通过介绍无服务器开始，并将在接下来的内容中涵盖以下主题：
- en: Functions as a Service
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数即服务
- en: Azure Functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Functions
- en: Azure Durable Functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Durable Functions
- en: Azure Event Grid
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Event Grid
- en: Serverless
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无服务器
- en: Serverless refers to a deployment model in which users are responsible for only
    their application code and configuration. In serverless computing, customers do
    not have to bother about bringing their own underlying platform and infrastructure
    and, instead, can concentrate on solving their business problems.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器是指一种部署模型，用户只需要负责他们的应用程序代码和配置。在无服务器计算中，客户不需要为自己的底层平台和基础设施操心，而是可以专注于解决业务问题。
- en: Serverless does not mean that there are no servers. Code and configuration will
    always need compute, storage, and networks to run. However, from the customer's
    perspective, there is no visibility of such compute, storage, and networks. They
    do not care about the underlying platform and infrastructure. They do not need
    to manage or monitor infrastructure and the platform. Serverless provides an environment
    that can scale up and down, in and out, automatically, without the customer even
    knowing about it. All operations related to platforms and infrastructures happen
    behind the scenes and are executed by the cloud provider. Customers are provided
    with performance-related **service-level agreements (SLAs)** and Azure ensures
    that it meets those SLAs irrespective of the total demand.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器并不意味着没有服务器。代码和配置始终需要计算、存储和网络来运行。然而，从客户的角度来看，他们看不到这些计算、存储和网络。他们不关心底层的平台和基础设施，不需要管理或监控基础设施和平台。无服务器提供了一个可以自动按需扩展、收缩、进出环境，而客户甚至对此一无所知的环境。与平台和基础设施相关的所有操作都发生在幕后，并由云服务提供商执行。客户会获得与性能相关的**服务级别协议（SLA）**，Azure
    会确保在任何需求下都能满足这些 SLA。
- en: Customers are required to only bring in their code; it is the responsibility
    of the cloud provider to provide the infrastructure and platform needed to run
    the code. Let's go ahead and dive into the various advantages of Azure Functions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 客户只需要带入他们的代码；云服务提供商负责提供运行代码所需的基础设施和平台。让我们深入探讨 Azure Functions 的各种优势。
- en: The advantages of Azure Functions
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure Functions 的优势
- en: Serverless computing is a relatively new paradigm that helps organizations convert
    large functionalities into smaller, discrete, on-demand functions that can be
    invoked and executed through automated triggers and scheduled jobs. They are also
    known as **Functions as a Service (FaaS)**, in which organizations can focus on
    their domain challenges instead of the underlying infrastructure and platform.
    FaaS also helps in devolving solution architectures into smaller, reusable functions,
    thereby increasing return on investment.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器计算是一种相对较新的范式，帮助组织将大型功能转化为较小的、离散的按需功能，这些功能可以通过自动触发器和计划任务被调用和执行。这些功能也被称为 **功能即服务
    (FaaS)**，在这种模式下，组织可以专注于领域挑战，而非底层基础设施和平台。FaaS 还有助于将解决方案架构分解为更小、可重用的功能，从而提高投资回报率。
- en: 'There is a plethora of serverless compute platforms available. Some of the
    important ones are listed here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有大量的无服务器计算平台可供选择。以下是一些重要的平台：
- en: Azure Functions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Functions。
- en: AWS Lambda
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Lambda。
- en: IBM OpenWhisk
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IBM OpenWhisk。
- en: Iron.io
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Iron.io。
- en: Google Cloud Functions
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Cloud Functions。
- en: 'In fact, every few days it feels like there is a new platform/framework being
    introduced, and it is becoming increasingly difficult for enterprises to decide
    on the framework that works best for them. Azure provides a rich serverless environment
    known as Azure Functions, and what follows are some of the features that it supports:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，每隔几天就会有新的平台/框架被推出，企业越来越难以决定哪个框架最适合他们。Azure 提供了一个丰富的无服务器环境，称为 Azure Functions，以下是它支持的一些功能：
- en: Numerous ways to invoke a function—manually, on a schedule, or based on an event.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多种方式调用函数——手动调用、按计划调用或基于事件触发。
- en: Numerous types of binding support.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多种绑定类型。
- en: The ability to run functions synchronously as well as asynchronously.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以同步和异步运行函数。
- en: The ability to execute functions based on multiple types of triggers.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于多种触发器类型执行函数的能力。
- en: The ability to run both long- and short-duration functions. However, large and
    long-running functions are not recommended as they may lead to unexpected timeouts.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以运行长时间和短时间的函数。然而，不推荐运行大型和长时间的函数，因为它们可能导致意外超时。
- en: The ability to use proxy features for different function architectures.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够使用代理功能来支持不同的函数架构。
- en: Multiple usage models including consumption, as well as the App Service model.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多种使用模型，包括消费模型和应用服务模型。
- en: The ability to author functions using multiple languages, such as JavaScript,
    Python, and C#.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够使用多种编程语言（如 JavaScript、Python 和 C#）编写函数。
- en: Authorization based on OAuth.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 OAuth 的授权。
- en: The Durable Functions extension helps in writing stateful functions.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Durable Functions 扩展帮助编写有状态的函数。
- en: Multiple authentication options, including Azure AD, Facebook, Twitter, and
    other identity providers.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多种身份验证选项，包括 Azure AD、Facebook、Twitter 和其他身份提供商。
- en: The ability to easily configure inbound and outbound parameters.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以轻松配置输入和输出参数。
- en: Visual Studio integration for authoring Azure functions.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Visual Studio 集成来编写 Azure 函数。
- en: Massive parallelism.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大规模并行处理。
- en: Let's take a look at FaaS and what roles it plays in serverless architecture.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 FaaS 及其在无服务器架构中扮演的角色。
- en: FaaS
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FaaS。
- en: Azure provides FaaS. These are serverless implementations from Azure. With Azure
    Functions, code can be written in any language the user is comfortable with and
    Azure Functions will provide a runtime to execute it. Based on the language chosen,
    an appropriate platform is provided for users to bring their own code. Functions
    are a unit of deployment and can automatically be scaled out and in. When dealing
    with functions, users cannot view the underlying virtual machines and platform,
    but Azure Functions provides a small window to view them via the **Kudu Console**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 提供 FaaS。这些是 Azure 的无服务器实现。使用 Azure Functions，用户可以用任何熟悉的语言编写代码，Azure Functions
    会提供一个运行时来执行它。根据选择的语言，平台为用户提供适当的环境来运行自己的代码。函数是部署的基本单元，可以自动扩展和缩减。在处理函数时，用户无法查看底层的虚拟机和平台，但
    Azure Functions 提供了一个小窗口，通过 **Kudu Console** 查看它们。
- en: 'There are two main components of Azure Functions:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 有两个主要组件：
- en: The Azure Functions runtime
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Functions 运行时。
- en: Azure Functions binding and triggers
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Functions 的绑定和触发器。
- en: Let's learn about these components in detail.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解这些组件。
- en: The Azure Functions runtime
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Azure Functions 运行时。
- en: The core of Azure Functions is its runtime. The precursor to Azure Functions
    was Azure WebJobs. The code for Azure WebJobs also forms the core for Azure Functions.
    There are additional features and extensions added to Azure WebJobs to create
    Azure Functions. The Azure Functions runtime is the magic that makes functions
    work. Azure Functions is hosted within Azure App Service. Azure App Service loads
    the Azure runtime and either waits for an external event or a manual activity
    to occur. On arrival of a request or the occurrence of a trigger, App Service
    loads the incoming payload, reads the function's `function.json` file to find
    the function's bindings and trigger, maps the incoming data to incoming parameters,
    and invokes the function with parameter values. Once the function completes its
    execution, the value is again passed back to the Azure Functions runtime by way
    of an outgoing parameter defined as a binding in the `function.json` file. The
    function runtime returns the values to the caller. The Azure Functions runtime
    acts as the glue that enables the entire performance of functions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 的核心是其运行时。Azure Functions 的前身是 Azure WebJobs。Azure WebJobs 的代码也是
    Azure Functions 的核心。Azure WebJobs 增加了额外的功能和扩展，以创建 Azure Functions。Azure Functions
    运行时是使函数能够工作的魔法。Azure Functions 托管在 Azure App Service 中。Azure App Service 加载 Azure
    运行时，并等待外部事件或手动活动的发生。请求到达或触发器发生时，App Service 加载传入的负载，读取函数的 `function.json` 文件以查找函数的绑定和触发器，将传入数据映射到传入参数，并使用参数值调用函数。一旦函数完成执行，值通过
    `function.json` 文件中定义为绑定的输出参数再次传回 Azure Functions 运行时。函数运行时将值返回给调用者。Azure Functions
    运行时充当粘合剂，支持整个函数的执行。
- en: The current Azure runtime version is ~3\. It is based on the .NET Core 3.1 framework.
    Prior to this, version ~2 was based on the .NET Core 2.2 framework. The first
    version, ~1, was based on the .NET 4.7 framework.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的 Azure 运行时版本是 ~3。它基于 .NET Core 3.1 框架。在此之前，版本 ~2 基于 .NET Core 2.2 框架。第一个版本
    ~1 基于 .NET 4.7 框架。
- en: There were substantial changes from version 1 to 2 because of changes in the
    underlying framework itself. However, there are very few breaking changes from
    version 2 to 3 and most functions written in version 2 would continue to run on
    version 3 as well. However, it is recommended that adequate testing is done after
    migrating from version 2 to 3\. There were also breaking changes from version
    1 to 2 with regard to triggers and bindings. Triggers and bindings are now available
    as extensions, with each one in a different assembly in versions 2 and 3.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 1 到版本 2 由于底层框架本身的变化，发生了重大变化。然而，从版本 2 到版本 3 几乎没有破坏性变化，大多数在版本 2 中编写的函数仍然能够在版本
    3 上运行。然而，建议在从版本 2 升级到版本 3 后进行充分的测试。关于触发器和绑定，从版本 1 到版本 2 也存在破坏性变化。触发器和绑定现在作为扩展提供，在版本
    2 和 3 中，每个扩展都位于不同的程序集。
- en: Azure Functions bindings and triggers
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Azure Functions 绑定和触发器
- en: If the Azure Functions runtime is the brain of Azure Functions, then Azure Functions
    bindings and triggers are its heart. Azure Functions promote loose coupling and
    high cohesion between services using triggers and bindings. Applications written
    targeting non-serverless environments implement code using imperative syntax for
    incoming and outgoing parameters and return values. Azure Functions uses a declarative
    mechanism to invoke functions using triggers and configures the flow of data using
    bindings.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Azure Functions 运行时是 Azure Functions 的大脑，那么 Azure Functions 绑定和触发器就是它的心脏。Azure
    Functions 通过触发器和绑定促进服务之间的松耦合和高内聚。针对非无服务器环境编写的应用程序使用命令式语法实现传入和传出的参数以及返回值的代码。Azure
    Functions 使用声明式机制通过触发器调用函数，并使用绑定配置数据流。
- en: Binding refers to the process of creating a connection between the incoming
    data and the Azure function along with mapping the data types. The connection
    could be in a single direction from the runtime to Azure Functions and vice versa
    or could be multi-directional—the binding can transmit data between the Azure
    runtime and Azure Functions in both directions. Azure Functions defines bindings
    declaratively.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定是指创建传入数据与 Azure 函数之间连接的过程，并映射数据类型。该连接可以是从运行时到 Azure Functions 的单向连接，也可以是双向的——绑定可以在
    Azure 运行时和 Azure Functions 之间双向传输数据。Azure Functions 以声明的方式定义绑定。
- en: Triggers are a special type of binding through which functions can be invoked
    based on external events. Apart from invoking a function, triggers also pass the
    incoming data, payload, and metadata to the function.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器是一种特殊类型的绑定，函数可以通过它根据外部事件被调用。除了调用函数，触发器还会将传入的数据、有效负载和元数据传递给函数。
- en: 'Bindings are defined in the `function.json` file as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定在 `function.json` 文件中定义，如下所示：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, a trigger is declared that invokes the function whenever there
    is a new item in the storage queue. The type is `queueTrigger`, the direction
    is inbound, `queueName` is `checkout-items`, and details about the target storage
    account connection and table name are also shown. All these values are important
    for the functioning of this binding. The `checkOut` name can be used within the
    function's code as a variable.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，声明了一个触发器，当存储队列中有新项时，会调用该函数。类型为 `queueTrigger`，方向为输入，`queueName` 为 `checkout-items`，并且显示了目标存储帐户连接和表名称的详细信息。所有这些值对于此绑定的功能至关重要。`checkOut`
    名称可以在函数代码中作为变量使用。
- en: Similarly, a binding for the return value is declared. Here, the return value
    is named `Orders` and the data is the output from Azure Functions. The binding
    writes the return data into Azure Table Storage using the connection string provided.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，声明了返回值的绑定。这里，返回值命名为 `Orders`，数据是来自 Azure Functions 的输出。该绑定将返回数据写入 Azure
    表存储，使用提供的连接字符串。
- en: 'Both bindings and triggers can be modified and authored using the `function.json` file
    is updated. The `checkOut` trigger is declared as shown here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定和触发器都可以通过更新 `function.json` 文件进行修改和编写。`checkOut` 触发器声明如下：
- en: '![Modifying triggers through the Integrate tab of Azure Functions](img/B15432_10_01.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![通过 Azure Functions 的“集成”选项卡修改触发器](img/B15432_10_01.jpg)'
- en: 'Figure 10.1: The Triggers section of the Integrate tab'
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.1：集成选项卡的触发器部分
- en: 'The **Orders** output is shown next:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**Orders** 输出如下所示：'
- en: '![Adding output details for the storage account through the Integrate tab](img/B15432_10_02.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![通过“集成”选项卡为存储帐户添加输出详细信息](img/B15432_10_02.jpg)'
- en: 'Figure 10.2: Adding output details for the storage account'
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.2：为存储帐户添加输出详细信息
- en: 'The authors of Azure functions do not need to write any plumbing code to get
    data from multiple sources. They just decide the type of data expected from the
    Azure runtime. This is shown in the next code segment. Notice that the checkout
    is available as a string to the function. Multiple data types can be used as binding
    for functions. For example, a queue binding can provide the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 函数的作者无需编写任何管道代码来获取来自多个源的数据。他们只需决定预期的 Azure 运行时数据类型。下一段代码示例中显示了这一点。请注意，结账功能作为字符串提供给函数。可以使用多种数据类型作为函数的绑定。例如，队列绑定可以提供以下内容：
- en: A plain old CLR (Common Language Runtime) object (POCO)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个普通的 CLR（公共语言运行时）对象 (POCO)
- en: A string
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字符串
- en: A byte
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字节
- en: '`CloudQueueMessage`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CloudQueueMessage`'
- en: 'The author of the function can use any one of these data types, and the Azure
    Functions runtime will ensure that a proper object is sent to the function as
    a parameter. The following is a code snippet for accepting string data and the
    Functions runtime will encapsulate incoming data into a `string` data type before
    invoking the function. If the runtime is unable to cast the incoming data to a
    string, it will generate an exception:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的作者可以使用这些数据类型中的任何一种，Azure Functions 运行时会确保将正确的对象作为参数传递给函数。以下是一个接受字符串数据的代码片段，运行时会在调用函数之前将传入的数据封装为
    `string` 数据类型。如果运行时无法将传入的数据转换为字符串，则会生成异常：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is also important to know that, in *Figure 10.2*, the storage account names
    are `AzureWebJobsStorage` and `AzureWebJobsDashboard`. Both of these are keys
    defined in the `appSettings` section and contain storage account connection strings.
    These storage accounts are used internally by Azure Functions to maintain its
    state and the status of function execution.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 同样需要了解的是，在*图 10.2*中，存储帐户名称为 `AzureWebJobsStorage` 和 `AzureWebJobsDashboard`。这两个是定义在
    `appSettings` 部分的密钥，包含存储帐户连接字符串。Azure Functions 内部使用这些存储帐户来维护其状态和函数执行的状态。
- en: For more information on Azure bindings and triggers, refer to [https://docs.microsoft.com/azure/azure-functions/functions-bindings-storage-queue](https://docs.microsoft.com/azure/azure-functions/functions-bindings-storage-queue).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Azure 绑定和触发器的更多信息，请参阅 [https://docs.microsoft.com/azure/azure-functions/functions-bindings-storage-queue](https://docs.microsoft.com/azure/azure-functions/functions-bindings-storage-queue)。
- en: Now that we have a fair understanding of Azure bindings and triggers, let's
    check out the various configuration options offered by Azure Functions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对 Azure 绑定和触发器有了一个基本的理解，让我们来看看 Azure Functions 提供的各种配置选项。
- en: Azure Functions configuration
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Azure Functions 配置
- en: 'Azure Functions provides configuration options at multiple levels. It provides
    configuration for the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 提供了多级配置选项。它为以下内容提供配置：
- en: The platform itself
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台本身
- en: Functions App Services
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数应用服务
- en: These settings affect every function contained by them. More information about
    these settings are available at [https://docs.microsoft.com/azure/azure-functions/functions-how-to-use-azure-function-app-settings](https://docs.microsoft.com/azure/azure-functions/functions-how-to-use-azure-function-app-settings).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置会影响它们所包含的每个函数。关于这些设置的更多信息，请访问 [https://docs.microsoft.com/azure/azure-functions/functions-how-to-use-azure-function-app-settings](https://docs.microsoft.com/azure/azure-functions/functions-how-to-use-azure-function-app-settings)。
- en: '**Platform configuration**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**平台配置**'
- en: Azure functions are hosted within Azure App Service, so they get all of its
    features. Diagnostic and monitoring logs can be configured easily using platform
    features. Furthermore, App Service provides options for assigning SSL certificates,
    using a custom domain, authentication, and authorization as part of its networking
    features.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 函数托管在 Azure App Service 中，因此它们可以享受所有的 App Service 特性。可以使用平台功能轻松配置诊断和监控日志。此外，App
    Service 提供了分配 SSL 证书、使用自定义域名、身份验证和授权等网络功能的选项。
- en: Although customers are not concerned about the infrastructure, operating system,
    file system, or platform on which functions actually execute, Azure Functions
    provides the necessary tooling to peek within the underlying system and make changes.
    The in-portal console and the Kudu Console are the tools used for this purpose.
    They provide a rich editor to author Azure functions and edit their configuration.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管客户无需关心函数实际执行的基础设施、操作系统、文件系统或平台，但 Azure Functions 提供了必要的工具，可以深入了解底层系统并进行更改。门户内控制台和
    Kudu 控制台是用于此目的的工具。它们提供了丰富的编辑器，用于编写 Azure 函数并编辑其配置。
- en: 'Azure Functions, just like App Service, lets you store the configuration information
    within the `web.config` application settings section, which can be read on demand.
    Some of the platform features of function apps are shown in *Figure 10.3*:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与 App Service 一样，Azure Functions 允许你将配置信息存储在 `web.config` 应用程序设置部分，可以按需读取。一些函数应用的
    платформ功能如 *图 10.3* 所示：
- en: '![Platform features of the function app](img/B15432_10_03.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![函数应用的 платформ功能](img/B15432_10_03.jpg)'
- en: 'Figure 10.3: Platform features of a function app'
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.3：函数应用的 플랫폼功能
- en: These platform features can be used to configure authentication, custom domains,
    SSL, and so on. Also, the **Platform Features** tab provides an overview of the
    development tools that can be used with the function app. In the next section,
    we will take a look at the function app settings that are available in the platform
    features.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些平台功能可以用来配置身份验证、自定义域名、SSL 等等。此外，**平台功能**选项卡提供了可以与函数应用一起使用的开发工具概览。在接下来的章节中，我们将查看在平台功能中可用的函数应用设置。
- en: '**App Service function settings**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**App Service 函数设置**'
- en: 'These settings affect all functions. Application settings can be managed here.
    Proxies in Azure Functions can be enabled and disabled. We will discuss proxies
    later in this chapter. They also help in changing the edit mode of a function
    application and the deployment to slots:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置会影响所有函数。应用程序设置可以在此处管理。Azure Functions 中的代理可以启用和禁用。我们将在本章后面讨论代理。它们还帮助更改函数应用的编辑模式和部署到槽：
- en: '![Configuring the function app’s settings](img/B15432_10_04.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![配置函数应用设置](img/B15432_10_04.jpg)'
- en: 'Figure 10.4: Function app settings'
  id: totrans-85
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.4：函数应用设置
- en: Budget is a very important aspect of the success of any project. Let's explore
    the various plans offered for Azure Functions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 预算是任何项目成功的一个非常重要的方面。让我们来探索 Azure Functions 提供的各种计划。
- en: Azure Functions cost plans
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Azure Functions 费用计划
- en: Azure Functions is based on the Azure App Service and provides a pocket-friendly
    model for users. There are three cost models.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 基于 Azure App Service，为用户提供了一种经济实惠的模型。它有三种费用模型。
- en: '**A consumption plan**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**消费计划**'
- en: This is based on the per-second consumption and execution of functions. This
    plan calculates the cost based on the compute usage during the actual consumption
    and execution of the function. If a function is not executed, there is no cost
    associated with it. However, it does not mean that performance is compromised
    in this plan. Azure functions will automatically scale out and in based on demand,
    to ensure basic minimum performance levels are maintained. A function execution
    is allowed 10 minutes for completion.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是基于按秒计费的函数消费和执行费用。该计划根据函数的实际消费和执行的计算使用情况来计算费用。如果一个函数没有执行，则不会产生费用。然而，这并不意味着该计划会影响性能。Azure
    函数会根据需求自动扩展和缩减，以确保基本的最小性能水平得以保持。一个函数的执行允许 10 分钟完成。
- en: One of the major drawbacks of this plan is that if there is no consumption of
    functions for a few seconds, the function might get cold and the next request
    that comes up might face a short delay in getting a response as the function is
    idle. This phenomenon is called a cold start. However, there are workarounds that
    can keep functions warm even when there are no legitimate requests. This can be
    done by writing a scheduled function that keeps invoking the target function to
    keep it warm.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 该计划的一个主要缺点是，如果函数几秒钟内没有被消费，函数可能会变冷，接下来的请求可能会因函数处于空闲状态而出现短暂的响应延迟。这种现象称为冷启动。然而，有一些解决方法可以保持函数在没有合法请求时也保持“热”状态。可以通过编写一个计划任务函数，不断调用目标函数，保持其活跃。
- en: '**A premium plan**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级计划**'
- en: This is a relatively new plan and provides lots of benefits compared to both
    App Service and a consumption plan. In this plan, there are no cold starts for
    Azure functions. Functions can be associated with a private network and customers
    can choose their own virtual machine sizes for executing functions. It provides
    numerous out-of-the-box facilities that were not possible previously with the
    other two types of plans.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相对较新的计划，与应用服务计划和消费计划相比，提供了许多好处。在该计划中，Azure 函数没有冷启动。函数可以与私有网络关联，客户可以选择自己的虚拟机大小来执行函数。它提供了许多之前在其他两种计划中无法实现的现成功能。
- en: '**An App Service plan**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用服务计划**'
- en: This plan provides functions with completely dedicated virtual machines in the
    backend, and so the cost is directly proportional to the cost of the virtual machine
    and its size. There is a fixed cost associated with this plan, even if functions
    are not invoked. Function code can run for as long as necessary. Although there
    is no time restriction, the default limit is set to 30 minutes. This can be changed
    by changing the value in the `hosts.json` file. Within the App Service plan, the
    function runtime goes idle if not used for a few minutes and can be activated
    only using an HTTP trigger. There is an **Always On** setting that can be used
    to prevent the function runtime from going idle. Scaling is either manual or based
    on autoscale settings.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 该计划为函数提供了完全专用的虚拟机后端，因此其费用与虚拟机的成本及其大小直接相关。即使函数没有被调用，也会有固定的费用与此计划相关联。函数代码可以运行所需的时间。尽管没有时间限制，但默认限制设置为
    30 分钟。可以通过更改 `hosts.json` 文件中的值来更改此限制。在应用服务计划中，如果函数长时间未使用，函数运行时会进入空闲状态，只能通过 HTTP
    触发器激活。可以使用 **Always On** 设置来防止函数运行时进入空闲状态。扩展可以是手动的，也可以基于自动扩展设置。
- en: Along with the flexible pricing option, Azure also offers various hosting options
    for architecture deployment.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 除了灵活的定价选项外，Azure还提供了多种架构部署的托管选项。
- en: Azure Functions destination hosts
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Azure Functions 目标主机
- en: The Azure Functions runtime can be hosted on Windows as well as on Linux hosts.
    PowerShell Core, Node.js, Java, Python, and .NET Core-based functions can run
    on both Windows as well as Linux operating systems. It is important to know which
    type of underlying operating system is required for the functions because this
    configuration setting is tied to the function app and in turn to all functions
    that are contained in it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 运行时可以托管在 Windows 和 Linux 主机上。基于 PowerShell Core、Node.js、Java、Python
    和 .NET Core 的函数可以在 Windows 和 Linux 操作系统上运行。了解函数所需的底层操作系统类型非常重要，因为此配置设置与函数应用程序及其包含的所有函数相关联。
- en: Also, it is possible to run functions within Docker containers. This is because
    Azure provides Docker images that have a pre-built function runtime installed
    in them and functions can be hosted using such images. Now, Docker images can
    be used to create containers within Kubernetes Pods and hosted on Azure Kubernetes
    Service, Azure Container Instances, or on unmanaged Kubernetes clusters. These
    images can be stored within Docker Hub, Azure Container Registry, or any other
    global as well as private image repositories.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，函数还可以在 Docker 容器中运行。这是因为 Azure 提供了预先构建的函数运行时的 Docker 镜像，可以使用这些镜像来托管函数。现在，Docker
    镜像可以用于在 Kubernetes Pod 中创建容器，并托管在 Azure Kubernetes 服务、Azure 容器实例或非托管的 Kubernetes
    集群中。这些镜像可以存储在 Docker Hub、Azure 容器注册表或任何其他全球和私有镜像库中。
- en: To have a clearer understanding, let's look into some of the most prominent
    use cases for Azure Functions.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地理解，我们来看看 Azure Functions 中一些最突出使用案例。
- en: Azure Functions use cases
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Azure Functions 使用案例
- en: Azure Functions has many implementations. Let's have a look at some of these
    use cases.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 有多种实现方式。让我们来看一下这些使用案例。
- en: '**Implementing microservices**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现微服务**'
- en: Azure Functions helps in breaking down large applications into smaller, discrete
    functional code units. Each unit is treated independently of others and evolves
    in its own life cycle. Each such code unit has its own compute, hardware, and
    monitoring requirements. Each function can be connected to all other functions.
    These units are woven together by orchestrators to build complete functionality.
    For example, in an e-commerce application, there can be individual functions (code
    units), each responsible for listing catalogs, recommendations, categories, subcategories,
    shopping carts, checkouts, payment types, payment gateways, shipping addresses,
    billing addresses, taxes, shipping charges, cancellations, returns, emails, SMS,
    and so on. Some of these functions are brought together to create use cases for
    e-commerce applications, such as product browsing and checkout flow.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 帮助将大型应用程序拆分为更小的独立功能代码单元。每个单元都独立于其他单元发展，拥有自己的生命周期。每个代码单元都有其自己的计算、硬件和监控要求。每个函数可以与所有其他函数连接。这些单元由协调器交织在一起，以构建完整的功能。例如，在一个电子商务应用程序中，可以有多个独立的函数（代码单元），每个函数负责列出目录、推荐、分类、子分类、购物车、结账、支付类型、支付网关、收货地址、账单地址、税费、运费、取消、退货、电子邮件、短信等。其中一些函数被组合在一起，创建用于电子商务应用程序的使用案例，如产品浏览和结账流程。
- en: '**Integration between multiple endpoints**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**多个端点之间的集成**'
- en: Azure Functions can build overall application functionality by integrating multiple
    functions. The integration can be based on the triggering of events or it could
    be on a push basis. This helps in decomposing large monolithic applications into
    small components.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 可以通过集成多个函数来构建整体应用程序功能。这种集成可以基于事件触发，也可以是推送方式。这有助于将大型的单体应用程序拆分为小型组件。
- en: '**Data processing**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据处理**'
- en: Azure Functions can be used for processing incoming data in batches. It can
    help in processing data in multiple formats, such as XML, CSV, JSON, and TXT.
    It can also run conversion, enrichment, cleaning, and filtering algorithms. In
    fact, multiple functions can be used, each doing either conversion or enrichment,
    cleaning or filtering. Azure Functions can also be used to incorporate advanced
    cognitive services, such as **optical character recognition (OCR)**, computer
    vision, and image manipulation and conversion. This is ideal if you want to process
    API responses and convert them.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 可用于批量处理传入数据。它可以帮助处理多种格式的数据，如 XML、CSV、JSON 和 TXT。它还可以运行转换、增强、清理和过滤算法。事实上，可以使用多个函数，每个函数执行转换或增强、清理或过滤操作。Azure
    Functions 还可以用于结合先进的认知服务，如 **光学字符识别（OCR）**、计算机视觉、图像处理和转换。如果您想处理 API 响应并进行转换，这是理想的选择。
- en: '**Integrating legacy applications**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成遗留应用程序**'
- en: Azure Functions can help in integrating legacy applications with newer protocols
    and modern applications. Legacy applications might not be using industry-standard protocols
    and formats. Azure Functions can act as a proxy for these legacy applications,
    accepting requests from users or other applications, converting the data into
    a format understood by a legacy application, and talking to it on protocols it
    understands. This opens a world of opportunity for integrating and bringing old
    and legacy applications into the mainstream portfolio.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 可以帮助将遗留应用程序与更新的协议和现代应用程序集成。遗留应用程序可能未使用行业标准协议和格式。Azure Functions
    可以充当这些遗留应用程序的代理，接受用户或其他应用程序的请求，将数据转换为遗留应用程序可以理解的格式，并使用其理解的协议与其进行通信。这为集成和将旧有遗留应用程序引入主流应用组合提供了巨大的机会。
- en: '**Scheduled jobs**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**定时作业**'
- en: Azure Functions can be used to execute continuously or periodically for certain
    application functions. These application functions can perform tasks such as periodically
    taking backups, restoring, running batch jobs, exporting and importing data, and
    bulk emailing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 可用于执行持续或定期的某些应用程序功能。这些应用程序功能可以执行诸如定期备份、恢复、批处理作业、导入导出数据和批量发送电子邮件等任务。
- en: '**Communication gateways**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**通信网关**'
- en: Azure Functions can be used in communication gateways when using notification
    hubs, SMS, email, and so on. For example, you can use Azure Functions to send
    a push notification to Android and iOS devices using Azure Notification Hubs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 可以在使用通知中心、短信、电子邮件等时用作通信网关。例如，你可以使用 Azure Functions 通过 Azure
    通知中心向 Android 和 iOS 设备发送推送通知。
- en: Azure functions are available in different types, which must be selected based
    on their relationship to optimizing workloads. Let's have a closer look at them.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 函数有不同的类型，需要根据它们与工作负载优化的关系进行选择。让我们仔细了解它们。
- en: Types of Azure functions
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Azure 函数的类型
- en: 'Azure functions can be categorized into three different types:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 函数可以分为三种不同的类型：
- en: '**On-demand functions**: These are functions that are executed when they are explicitly called
    or invoked. Examples of such functions include HTTP-based functions and webhooks.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按需函数**：这些函数在被显式调用或触发时执行。例如，HTTP 基础的函数和 Webhook 就是这类函数。'
- en: '**Scheduled functions**: These functions are like timer jobs and execute functions on fixed
    intervals.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定时函数**：这些函数像定时任务一样，按固定时间间隔执行。'
- en: '**Event-based functions**: These functions are executed based on external events.
    For example, uploading a new file to Azure Blob storage generates an event that
    could start the execution of Azure functions.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于事件的函数**：这些函数基于外部事件执行。例如，向 Azure Blob 存储上传新文件会生成一个事件，从而启动 Azure 函数的执行。'
- en: In the following section, you will learn how to create an event-driven function
    that will be connected to an Azure Storage account.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，你将学习如何创建一个事件驱动的函数，该函数将连接到一个 Azure 存储帐户。
- en: Creating an event-driven function
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建事件驱动的函数
- en: 'In this example, an Azure function will be authored and connected to an Azure
    Storage account. The Storage account has a container for holding all Blob files.
    The name of the Storage account is **incomingfiles** and the container is **orders**,
    as shown in *Figure 10.5*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，将创建一个 Azure 函数并将其连接到 Azure 存储帐户。该存储帐户有一个容器来存放所有 Blob 文件。存储帐户的名称是 **incomingfiles**，容器的名称是
    **orders**，如 *图 10.5* 所示：
- en: '![The Storage account and container used for the Azure function](img/B15432_10_05.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![用于 Azure 函数的存储帐户和容器](img/B15432_10_05.jpg)'
- en: 'Figure 10.5: Storage account details'
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.5：存储帐户详情
- en: 'Perform the following steps to create a new Azure function from the Azure portal:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤从 Azure 门户创建一个新的 Azure 函数：
- en: Click on the **+** button beside the **Functions** menu on the left.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧 **Functions** 菜单旁边的 **+** 按钮。
- en: Select **In-Portal** from the resultant screen and click on the **Continue**
    button.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从结果页面选择 **In-Portal** 并点击 **继续** 按钮。
- en: Select **Azure Blob Storage trigger**, as shown in *Figure 10.6*:![Creating
    an Azure Blob Storage trigger function](img/B15432_10_06.jpg)
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Azure Blob 存储触发器**，如 *图 10.6* 所示：![创建 Azure Blob 存储触发器函数](img/B15432_10_06.jpg)
- en: 'Figure 10.6: Selecting Azure Blob Storage trigger'
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.6：选择 Azure Blob 存储触发器
- en: Right now, this Azure function does not have connectivity to the Storage account.
    Azure functions need connection information for the Storage account, and that
    is available from the **Access keys** tab in the Storage account. The same information
    can be obtained using the Azure Functions editor environment. In fact, that environment
    allows the creation of a new Storage account from the same editor environment.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个 Azure 函数与存储帐户没有连接。Azure 函数需要存储帐户的连接信息，而这些信息可以从存储帐户的**访问密钥**标签中获取。同样的信息也可以通过
    Azure Functions 编辑器环境获取。事实上，该环境允许从同一个编辑器环境中创建一个新的存储帐户。
- en: The Azure Blob Storage trigger can be added using the **New** button beside
    the **Storage account connection** input type. It allows the selection of an existing
    Storage account or the creation of a new Storage account. Since I already have
    a couple of Storage accounts, I am reusing them, but you should create a separate
    Azure Storage account. Selecting a Storage account will update the settings in
    the **appSettings** section with the connection string added to it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过点击**存储帐户连接**输入框旁的**新建**按钮来添加 Azure Blob 存储触发器。它允许选择现有的存储帐户或创建一个新的存储帐户。由于我已经有几个存储帐户，所以我在重复使用它们，但你应该创建一个单独的
    Azure 存储帐户。选择一个存储帐户后，将更新**appSettings**部分的设置，并将连接字符串添加到其中。
- en: 'Ensure that a container already exists within the Blob service of the target
    Azure Storage account. The path input refers to the path to the container. In
    this case, the **orders** container already exists within the Storage account.
    The **Create** button shown here will provision the new function monitoring the
    Storage account container:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 确保目标 Azure 存储帐户的 Blob 服务中已存在一个容器。路径输入指的是容器的路径。在这种情况下，**orders** 容器已经存在于存储帐户中。这里显示的**创建**按钮将为新的函数提供服务，监控存储帐户容器：
- en: '![Creating a function for monitoring a Storage account container](img/B15432_10_07.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![为监控存储帐户容器创建函数](img/B15432_10_07.jpg)'
- en: 'Figure 10.7: Creating a function that monitors the Storage account container'
  id: totrans-135
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.7：创建一个监控存储帐户容器的函数
- en: 'The code for the `storagerelatedfunctions` function is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`storagerelatedfunctions` 函数的代码如下：'
- en: '[PRE2]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The bindings are shown here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定如下所示：
- en: '[PRE3]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, uploading any blob file to the `orders` container should trigger the function:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将任何 blob 文件上传到 `orders` 容器应该会触发该函数：
- en: '![Initiating a trigger through a blob file](img/B15432_10_08.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![通过 blob 文件启动触发器](img/B15432_10_08.jpg)'
- en: 'Figure 10.8: C# Blob trigger function processed blob'
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.8：C# Blob 触发函数处理的 blob
- en: In the next section, we will dive into Azure Function Proxies, which will help
    you to efficiently handle the requests and responses of your APIs.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将深入探讨 Azure Function Proxies，它将帮助你高效处理 API 的请求和响应。
- en: Function Proxies
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数代理
- en: Azure Function Proxies is a relatively new addition to Azure Functions. Function
    Proxies helps in hiding the details of Azure functions and exposing completely
    different endpoints to customers. Function Proxies can receive requests on endpoints,
    modify the content, body, headers, and URL of the request by changing the values,
    and augment them with additional data and pass it internally to Azure functions.
    Once they get a response from these functions, they can again convert, override,
    and augment the response and send it back to the client.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Function Proxies 是 Azure Functions 的一个相对较新的功能。函数代理有助于隐藏 Azure 函数的细节，并向客户公开完全不同的端点。函数代理可以接收端点的请求，通过改变值来修改请求的内容、主体、头部和
    URL，增加额外数据，并将其传递给 Azure 函数。一旦它们从这些函数获得响应，它们可以再次转换、覆盖和增强响应，并将其发送回客户端。
- en: It also helps in invoking different functions for CRUD (create, read, delete,
    and update) operations using different headers, thereby breaking large functions
    into smaller ones. It provides a level of security by not exposing the original
    function endpoint and also helps in changing the internal function implementation
    and endpoints without impacting its caller. Function Proxies helps by providing
    clients with a single function URL and then invoking multiple Azure functions
    in the backend to complete workflows. More information about Azure Function Proxies
    can be found at [https://docs.microsoft.com/azure/azure-functions/functions-proxies](https://docs.microsoft.com/azure/azure-functions/functions-proxies).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 它还帮助通过使用不同的头部信息调用不同的函数进行 CRUD（创建、读取、删除和更新）操作，从而将大型函数拆分成更小的函数。它通过不暴露原始函数端点提供了一定的安全性，并且在不影响调用者的情况下，帮助更改内部函数实现和端点。函数代理通过为客户端提供单一的函数
    URL，然后在后台调用多个 Azure 函数来完成工作流。有关 Azure Function Proxies 的更多信息，请访问 [https://docs.microsoft.com/azure/azure-functions/functions-proxies](https://docs.microsoft.com/azure/azure-functions/functions-proxies)。
- en: In the next section, we will cover Durable Functions in detail.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将详细介绍 Durable Functions。
- en: Durable Functions
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Durable Functions
- en: 'Durable Functions is one of the latest additions to Azure Functions. It allows
    architects to write stateful workflows in an Orchestrator function, which is a
    new function type. As a developer, you can choose to code it or use any form of
    IDE. Some advantages of using Durable Functions are:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Durable Functions 是 Azure Functions 中最新的功能之一。它允许架构师在 Orchestrator 函数中编写有状态的工作流，这是一个新的函数类型。作为开发者，你可以选择编写代码或使用任何形式的
    IDE。使用 Durable Functions 的一些优势包括：
- en: Function output can be saved to local variables and you can call other functions
    synchronously and asynchronously.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数输出可以保存到本地变量中，你可以同步和异步调用其他函数。
- en: The state is preserved for you.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态会为你保留。
- en: 'The following is the basic mechanism for invoking Durable Functions:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是调用 Durable Functions 的基本机制：
- en: '![The basic mechanism for invoking Durable Functions](img/B15432_10_09.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![调用 Durable Functions 的基本机制](img/B15432_10_09.jpg)'
- en: 'Figure 10.9: Mechanism for invoking Durable Functions'
  id: totrans-154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.9：调用 Durable Functions 的机制
- en: Azure Durable Functions can be invoked by any trigger provided by Azure Functions.
    These triggers include HTTP, Blob storage, Table Storage, Service Bus queues,
    and more. They can be triggered manually by someone with access to them, or by
    an application. *Figure 10.9* shows a couple of triggers as an example. These
    are also known as starter Durable Functions. The starter durable functions invoke
    the **durable orchestrator trigger**, which contains the main logic for orchestration,
    and orchestrates the invocation of activity functions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Durable Functions 可以通过 Azure Functions 提供的任何触发器进行调用。这些触发器包括 HTTP、Blob
    存储、表存储、服务总线队列等。它们可以由具有访问权限的用户手动触发，也可以由应用程序触发。*图 10.9* 展示了几个触发器作为示例。这些也被称为启动型 Durable
    Functions。启动型 Durable Functions 调用 **durable orchestrator trigger**，该触发器包含编排的主要逻辑，并负责编排活动函数的调用。
- en: The code written within the durable orchestrator must be deterministic. This
    means that no matter the number of times the code is executed, the values returned
    by it should remain the same. The Orchestrator function is a long-running function
    by nature. This means it can be hydrated, state-serialized, and it goes to sleep
    after it calls a durable activity function. This is because it does not know when
    the durable activity function will complete and does not want to wait for it.
    When the durable activity function finishes its execution, the Orchestrator function
    is executed again. The function execution starts from the top and executes until
    it either calls another durable activity function or finishes the execution of
    the function. It has to re-execute the lines of code that it already executed
    earlier and should get the same results that it got earlier. Note that the code
    written within the durable orchestrator must be deterministic. This means that
    no matter the number of times the code is executed, the values returned by it
    should remain the same.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在持久编排器中编写的代码必须是确定性的。这意味着，无论代码执行多少次，返回的值应该保持不变。编排器函数本质上是一个长时间运行的函数。这意味着它可以被注水、状态序列化，并在调用持久活动函数后进入休眠状态。因为它不知道持久活动函数何时完成，所以它不想等待。当持久活动函数执行完成时，编排器函数将再次执行。函数执行从顶部开始，并一直执行，直到它调用另一个持久活动函数或完成函数执行。它必须重新执行之前已经执行过的代码行，并且应该得到之前的相同结果。请注意，在持久编排器中编写的代码必须是确定性的。这意味着，无论代码执行多少次，返回的值应该保持不变。
- en: Let me explain this with the help of an example. If we use a general .NET Core
    datetime class and return the current date time, it will result in a new value
    every time we execute the function. The Durable Functions context object provides
    `CurrentUtcDateTime`, which will return the same datetime value during re-execution
    that it returned the first time.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我通过一个例子来解释这一点。如果我们使用通用的.NET Core日期时间类并返回当前的日期时间，每次执行函数时，它都会返回一个新的值。持久函数上下文对象提供了`CurrentUtcDateTime`，它将在重新执行时返回与第一次执行时相同的日期时间值。
- en: These orchestration functions can also wait for external events and enable scenarios
    related to human hand-off. This concept will be explained later in this section.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些编排函数也可以等待外部事件，并支持与人工交接相关的场景。这个概念将在本节稍后解释。
- en: 'These activity functions can be called with or without a retry mechanism. Durable
    Functions can help to solve many challenges and provides features to write functions
    that can do the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些活动函数可以在有或没有重试机制的情况下被调用。持久函数可以帮助解决许多挑战，并提供以下功能来编写可以执行以下操作的函数：
- en: Execute long-running functions
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行长时间运行的函数
- en: Maintain state
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护状态
- en: Execute child functions in parallel or sequence
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行或按顺序执行子函数
- en: Recover from failure easily
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易从故障中恢复
- en: Orchestrate the execution of functions in a workflow
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工作流中编排函数的执行
- en: Now that you have a fair understanding of the inner workings of a durable function,
    let's explore how to create a durable function in Visual Studio.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对持久函数的内部工作机制有了基本了解，接下来让我们探索如何在Visual Studio中创建持久函数。
- en: Steps for creating a durable function using Visual Studio
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Visual Studio创建持久函数的步骤
- en: 'The following are the steps to create a durable function:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建持久函数的步骤：
- en: Navigate to the Azure portal and click on **Resource groups** in the left menu.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到Azure门户并点击左侧菜单中的**资源组**。
- en: Click on the **+Add** button in the top menu to create a new resource group.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部菜单中的**+添加**按钮来创建一个新的资源组。
- en: Provide the resource group information on the resultant form and click on the
    **Create** button, as shown here:![Creating a resource group for creating a Durable
    Function](img/B15432_10_10.jpg)
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生成的表单中提供资源组信息并点击**创建**按钮，如下所示：![创建资源组以创建持久函数](img/B15432_10_10.jpg)
- en: 'Figure 10.10: Creating a resource group'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.10：创建资源组
- en: Navigate to the newly created resource group and add a new function app by clicking
    on the `function app` in the resultant search box.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到新创建的资源组，并通过点击生成的搜索框中的`功能应用`来添加一个新的功能应用。
- en: Select **Function App** and click on the **Create** button. Fill in the resultant
    function app form and click on the **Create** button. You can also reuse the function
    app we created earlier.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**功能应用**并点击**创建**按钮。填写生成的功能应用表单并点击**创建**按钮。你也可以重新使用我们之前创建的功能应用。
- en: Once the function app is created, we will get into our local development environment
    with visual studio 2019 installed on it. We will get started with Visual Studio
    and create a new project of type `Azure functions`, provide it with a name, and
    select **Azure Functions v3** (**.NET core**) for **Function runtime**.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦函数应用创建完成，我们将进入本地开发环境，安装了 Visual Studio 2019 的环境中。我们将开始使用 Visual Studio 创建一个新的
    `Azure functions` 类型项目，提供名称，并为 **Function runtime** 选择 **Azure Functions v3**（**.NET
    core**）。
- en: After the project is created, we need to add the `DurableTask` NuGet package
    to the project for working with Durable Functions. The version used at the time
    of writing this chapter is 2.2.2:![Adding a DurableTask NuGet package for the
    project](img/B15432_10_11.jpg)
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建项目后，我们需要将 `DurableTask` NuGet 包添加到项目中，以便与 Durable Functions 一起使用。编写本章时使用的版本是
    2.2.2：![为项目添加 DurableTask NuGet 包](img/B15432_10_11.jpg)
- en: 'Figure 10.11: Adding a DurableTask NuGet package'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.11：添加 DurableTask NuGet 包
- en: Now, we can code our durable functions within Visual Studio. Add a new function,
    provide it with a name, and select the **Durable Functions Orchestration** trigger
    type:![Adding a Durable Functions Orchestration trigger](img/B15432_10_12.jpg)
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在 Visual Studio 中编写持久化函数。添加一个新函数，给它命名，并选择 **Durable Functions Orchestration**
    触发器类型：![添加 Durable Functions Orchestration 触发器](img/B15432_10_12.jpg)
- en: 'Figure 10.12: Selecting a Durable Functions Orchestration trigger'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.12：选择 Durable Functions Orchestration 触发器
- en: Visual Studio generates the boilerplate code for Durable Functions, and we are
    going to use it to learn about Durable Functions. Durable Functions activities
    are functions that are invoked by the main Orchestrator function. There is generally
    one main Orchestrator function and multiple Durable Functions activities. Once
    the extension is installed, provide a name for the function and write code that
    does something useful, such as sending an email or an SMS, connecting to external
    systems and executing logic, or executing services using their endpoints, such
    as cognitive services.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 会为 Durable Functions 生成样板代码，我们将利用这些代码来学习 Durable Functions。Durable
    Functions 活动是由主 Orchestrator 函数调用的函数。通常会有一个主 Orchestrator 函数和多个 Durable Functions
    活动。一旦扩展安装完成，提供一个函数名称并编写一些有用的代码，比如发送电子邮件或短信，连接外部系统并执行逻辑，或者使用其端点执行服务，如认知服务。
- en: 'Visual Studio generates three sets of functions in a single line of code:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Visual Studio 会在一行代码中生成三组函数：
- en: '`BlobTrigger`, a `ServiceBus` queue, or a trigger-based function.'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlobTrigger`，`ServiceBus` 队列或基于触发器的函数。'
- en: '**RunOrchestrator**: This is the main durable orchestration function. It is
    responsible for accepting parameters from the starter function and in turn, invokes
    multiple durable task functions. Each durable task function is responsible for
    a functionality and these durable tasks can be invoked either in parallel or in
    sequence depending on the need.'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RunOrchestrator**：这是主要的持久化协调函数。它负责从启动函数接收参数，并依次调用多个持久化任务函数。每个持久化任务函数负责一个特定功能，这些持久化任务可以根据需要并行或顺序调用。'
- en: '**SayHello**: This is the durable task function that is invoked from the durable
    function orchestrator to do a particular job.'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SayHello**：这是从持久化函数协调器调用的持久化任务函数，用于执行特定任务。'
- en: The code for the starter function (`HttpStart`) is shown next. This function
    has a trigger of type HTTP and it accepts an additional binding of type `DurableClient`.
    This `DurableClient` object helps in invoking the Orchestrator function:![Code
    for the HttpStart starter function](img/B15432_10_13.jpg)
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动函数（`HttpStart`）的代码如下所示。此函数的触发器类型为 HTTP，并接受一个类型为 `DurableClient` 的附加绑定。此 `DurableClient`
    对象有助于调用 Orchestrator 函数：![HttpStart 启动函数的代码](img/B15432_10_13.jpg)
- en: 'Figure 10.13: Code for the starter function'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.13：启动函数的代码
- en: The code for the Orchestrator function (`RunOrchestrator`) is shown next. This
    function has a trigger of type `OrchestrationTrigger` and accepts a parameter
    of type `IDurableOrchestrationContext`. This context object helps in invoking
    durable tasks:![Code for the orchestrator trigger function](img/B15432_10_14.jpg)
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Orchestrator 函数（`RunOrchestrator`）的代码如下所示。此函数的触发器类型为 `OrchestrationTrigger`，并接受类型为
    `IDurableOrchestrationContext` 的参数。此上下文对象有助于调用持久化任务：![Orchestrator 触发器函数的代码](img/B15432_10_14.jpg)
- en: 'Figure 10.14: Code for orchestrator trigger function'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.14：Orchestrator 触发器函数的代码
- en: The code for the durable task function (`HelloFunction`) is shown next. This
    function has a trigger of type `ActivityTrigger` and accepts a parameter that
    can be any type needed for it to execute its functionality. It has a return value
    of type `string` and the function is responsible for returning a string value
    to the orchestration function:![Code for the durable task function](img/B15432_10_15.jpg)
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 持久化任务函数的代码（`HelloFunction`）如下所示。该函数的触发器类型为`ActivityTrigger`，并接受一个参数，该参数可以是执行其功能所需的任何类型。它的返回值类型为`string`，并且该函数负责返回一个字符串值给协调函数：![持久化任务函数的代码](img/B15432_10_15.jpg)
- en: 'Figure 10.15: Code for the durable task function'
  id: totrans-189
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.15：持久化任务函数的代码
- en: 'Next, we can execute the function locally, which will start a storage emulator
    if one''s not already started, and will provide a URL for the HTTP trigger function:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在本地执行该函数，这将启动一个存储仿真器（如果尚未启动），并为 HTTP 触发器函数提供一个 URL：
- en: '![Executing a function to start the storage emulator and provide a URL for
    the HTTP trigger function](img/B15432_10_16.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![执行函数以启动存储仿真器并提供 HTTP 触发器函数的 URL](img/B15432_10_16.jpg)'
- en: 'Figure 10.16: Starting the storage emulator'
  id: totrans-192
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.16：启动存储仿真器
- en: 'We are going to invoke this URL using a tool known as **Postman** (this can
    be downloaded from [https://www.getpostman.com/](https://www.getpostman.com/)).
    We just need to copy the URL and execute it in Postman. This activity is shown
    in *Figure 10.17*:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个工具**Postman**来调用此 URL（该工具可以从[https://www.getpostman.com/](https://www.getpostman.com/)下载）。我们只需要复制该
    URL 并在 Postman 中执行。这个操作如*图 10.17*所示：
- en: '![Invoking URLs using Postman](img/B15432_10_17.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Postman 调用 URL](img/B15432_10_17.jpg)'
- en: 'Figure 10.17: Invoking URLs using Postman'
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.17：使用 Postman 调用 URL
- en: 'Notice that five URLs are generated when you start the orchestrator:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你启动协调器时，会生成五个 URL：
- en: The `statusQueryGetUri` URL is used to find the current status of the orchestrator.
    Clicking this URL on Postman opens a new tab, and if we execute this request,
    it shows the status of the workflow:![The current status of the orchestrator](img/B15432_10_18.jpg)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`statusQueryGetUri` URL 用于查找协调器的当前状态。在 Postman 中点击该 URL 会打开一个新标签页，如果执行此请求，它将显示工作流的状态：![协调器的当前状态](img/B15432_10_18.jpg)'
- en: 'Figure 10.18: Current status of the orchestrator'
  id: totrans-198
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.18：协调器的当前状态
- en: The `terminatePostUri` URL is used for stopping an already running Orchestrator
    function.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`terminatePostUri` URL 用于停止已经在运行的协调器函数。'
- en: The `sendEventPostUri` URL is used to post an event to a suspended durable function.
    Durable functions can be suspended if they are waiting for an external event.
    This URL is used in those cases.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sendEventPostUri` URL 用于向挂起的持久化函数发布事件。当持久化函数在等待外部事件时，它们可以被挂起。在这种情况下，将使用此 URL。'
- en: The `purgeHistoryDeleteUri` URL is used to delete the history maintained by
    Durable Functions for a particular invocation from its Table Storage account.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`purgeHistoryDeleteUri` URL 用于从持久化函数的表存储帐户中删除某个调用的历史记录。'
- en: 'Now that you know how to work with Durable Functions using Visual Studio, let''s
    cover another aspect of Azure functions: chaining them together.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何使用 Visual Studio 操作持久化函数，让我们讨论 Azure 函数的另一个方面：将它们链接在一起。
- en: Creating a connected architecture with functions
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建具有函数的连接架构
- en: A connected architecture with functions refers to creating multiple functions,
    whereby the output of one function triggers another function and provides data
    for the next function to execute its logic. In this section, we will continue
    with the previous scenario of the Storage account. In this case, the output of
    the function being triggered using Azure Storage Blob files will write the size
    of the file to Azure Cosmos DB.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 具有函数的连接架构指的是创建多个函数，其中一个函数的输出触发另一个函数，并为下一个函数提供数据以执行其逻辑。在本节中，我们将继续之前的存储帐户场景。在此情况下，使用
    Azure 存储 Blob 文件触发的函数输出将把文件的大小写入 Azure Cosmos DB。
- en: The configuration of Cosmos DB is shown next. By default, there are no collections
    created in Cosmos DB.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来展示的是 Cosmos DB 的配置。默认情况下，Cosmos DB 中没有创建任何集合。
- en: 'A collection will automatically be created when creating a function that will
    be triggered when Cosmos DB gets any data:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建一个函数时，Cosmos DB接收到任何数据时将自动创建一个集合，该函数将被触发：
- en: '![Creating an Azure Cosmos DB account](img/B15432_10_19.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![创建 Azure Cosmos DB 账户](img/B15432_10_19.jpg)'
- en: 'Figure 10.19: Creating an Azure Cosmos DB account'
  id: totrans-208
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.19：创建 Azure Cosmos DB 账户
- en: Let's follow the below steps to retrieve data for the next function from the
    output of one function.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤，从一个函数的输出中获取数据，供下一个函数使用。
- en: Create a new database, `testdb`, within Cosmos DB, and create a new collection
    named `testcollection` within it. You need both the database and the collection
    name when configuring Azure functions: ![Creating a new database within a container](img/B15432_10_20.jpg)
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Cosmos DB 中创建一个新的数据库 `testdb`，并在其中创建一个名为 `testcollection` 的新集合。在配置 Azure 函数时，您需要同时提供数据库和集合名称：![在容器中创建新数据库](img/B15432_10_20.jpg)
- en: 'Figure 10.20: Adding a container'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.20：添加容器
- en: Create a new function that will have a Blob Storage trigger and output CosmosDB
    binding. The value returned from the function will be the size of the data for
    the uploaded file. This returned value will be written to Cosmos DB. The output
    binding will write to the Cosmos DB collection. Navigate to the **Integrate**
    tab and click on the **New Output** button below the **Outputs** label and select
    **Azure Cosmos DB**:![Binding output to Azure Cosmos DB](img/B15432_10_21.jpg)
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的函数，该函数将具有 Blob 存储触发器和 Cosmos DB 输出绑定。该函数返回的值将是上传文件的数据大小。该返回值将写入 Cosmos
    DB。输出绑定将写入 Cosmos DB 集合。导航到**集成**标签页，点击**新建输出**按钮，位于**输出**标签下方，并选择**Azure Cosmos
    DB**：![将输出绑定到 Azure Cosmos DB](img/B15432_10_21.jpg)
- en: 'Figure 10.21: Binding output to Azure Cosmos DB'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.21：将输出绑定到 Azure Cosmos DB
- en: Provide the appropriate names for the database and collection (check the checkbox
    to create the collection if it does not exist), click on the **New** button to
    select your newly created Azure Cosmos DB, and leave the parameter name as **outputDocument**:![Selecting
    an Azure Cosmos DB account as output](img/B15432_10_22.jpg)
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供适当的数据库和集合名称（如果集合不存在，请勾选复选框以创建集合），点击**新建**按钮选择您新创建的 Azure Cosmos DB，并将参数名称保持为**outputDocument**：![选择
    Azure Cosmos DB 账户作为输出](img/B15432_10_22.jpg)
- en: 'Figure 10.22: Newly created Azure Cosmos DB'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.22：新创建的 Azure Cosmos DB
- en: Modify the function as shown in *Figure 10.23*:![Modifying the function](img/B15432_10_23.jpg)
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照*图 10.23*中的方式修改函数：![修改函数](img/B15432_10_23.jpg)
- en: 'Figure 10.23: Modifying the function'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.23：修改函数
- en: Now, uploading a new file to the orders collection in the Azure Storage account
    will execute a function that will write to the Azure Cosmos DB collection. Another
    function can be written with the newly created Azure Cosmos DB account as a trigger
    binding. It will provide the size of files and the function can act on it. This
    is shown here:![Creating a trigger binding function](img/B15432_10_24.jpg)
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将新文件上传到 Azure 存储账户中的 orders 集合，将会触发一个写入 Azure Cosmos DB 集合的函数。另一个函数可以使用新创建的
    Azure Cosmos DB 账户作为触发绑定。它将提供文件的大小，函数可以对其进行处理。如下所示：![创建触发器绑定函数](img/B15432_10_24.jpg)
- en: 'Figure 10.24: Writing a trigger binding function'
  id: totrans-219
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.24：编写触发器绑定函数
- en: This section covered how the output of one function can be used to retrieve
    data for the next function. In the next section, you will learn about how to enable
    serverless eventing by understanding about Azure Event Grid.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了如何使用一个函数的输出数据来为下一个函数获取数据。在下一节中，您将学习如何通过了解 Azure Event Grid 来启用无服务器事件处理。
- en: Azure Event Grid
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure 事件网格
- en: Azure Event Grid is a relatively new service. It has also been referred to as
    a serverless eventing platform. It helps with the creation of applications based
    on events (also known as **event-driven design**). It is important to understand
    what events are and how we dealt with them prior to Event Grid. An event is something
    that happened – that is, an activity that changed the state of a subject. When
    a subject undergoes a change in its state, it generally raises an event.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Event Grid 是一个相对较新的服务，也被称为无服务器事件平台。它帮助基于事件（也称为**事件驱动设计**）创建应用程序。了解事件是什么以及在
    Event Grid 出现之前我们如何处理事件是非常重要的。事件是指发生的事情——即改变某个主题状态的活动。当一个主题的状态发生变化时，通常会触发一个事件。
- en: Events typically follow the publish/subscribe pattern (also popularly known
    as the **pub/sub pattern**), in which a subject raises an event due to its state
    change, and that event can then be subscribed to by multiple interested parties,
    also known as **subscribers**. The job of the event is to notify the subscribers
    of such changes and also provide them with data as part of its context. The subscribers
    can take whatever action they deem necessary, which varies from subscriber to
    subscriber.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 事件通常遵循发布/订阅模式（也称为**pub/sub模式**），在该模式中，主题因其状态变化而触发事件，其他多个感兴趣的方（即**订阅者**）可以订阅该事件。事件的作用是通知订阅者这些变化，并将相关数据作为事件的一部分提供给他们。订阅者可以根据需要采取相应的行动，这些行动因订阅者而异。
- en: Prior to Event Grid, there was no service that could be described as a real-time
    event platform. There were separate services, and each provided its own mechanism
    for handling events.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件网格之前，并没有可以称作实时事件平台的服务。曾经有多个独立服务，每个服务都提供了各自的事件处理机制。
- en: For example, Log Analytics, also known as **Operations Management Suite** (**OMS**),
    provides an infrastructure for capturing environment logs and telemetry on which
    alerts can be generated. These alerts can be used to execute a runbook, a webhook,
    or a function. This is near to real time, but they are not completely real time.
    Moreover, it was quite cumbersome to trap individual logs and act on them. Similarly,
    there is Application Insights, which provides similar features to Log Analytics
    but for applications instead.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Log Analytics，也称为**操作管理套件**（**OMS**），提供了一个捕获环境日志和遥测数据的基础设施，基于这些数据可以生成警报。这些警报可以用于执行Runbook、Webhook或函数。这接近实时，但并不完全是实时的。而且，捕获单个日志并对其进行处理非常繁琐。同样，Application
    Insights也提供了类似于Log Analytics的功能，但它是为应用程序提供的。
- en: There are other logs, such as activity logs and diagnostic logs, but again,
    they rely on similar principles as other log-related features. Solutions are deployed
    on multiple resource groups in multiple regions, and events raised from any of
    these should be available to the resources that are deployed elsewhere.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他日志，例如活动日志和诊断日志，但它们同样依赖于与其他日志相关功能类似的原理。解决方案部署在多个资源组中，跨多个区域，从任何这些区域引发的事件应该能被部署在其他地方的资源访问。
- en: Event Grid removes all barriers, and as a result, events can be generated by
    most resources (they are increasingly becoming available), and even custom events
    can be generated. These events can then be subscribed to by any resource, in any
    region, and in any resource group within the subscription.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 事件网格去除了所有障碍，因此，几乎所有资源都可以生成事件（这些资源正变得越来越可用），甚至可以生成自定义事件。这些事件可以被任何资源、任何区域、任何资源组内的订阅者所订阅。
- en: Event Grid is already laid down as part of the Azure infrastructure, along with
    data centers and networks. Events raised in one region can easily be subscribed
    to by resources in other regions, and since these networks are connected, it is
    extremely efficient for the delivery of events to subscribers.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 事件网格已经作为Azure基础设施的一部分铺设好了，包括数据中心和网络。一个区域内触发的事件可以轻松地被其他区域的资源订阅，并且由于这些网络是互联的，因此事件传递给订阅者的效率极高。
- en: Event Grid
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件网格
- en: Event Grid lets you create applications with event-based architecture. There
    are publishers of events and there are consumers of events; however, there can
    be multiple subscribers for the same event.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 事件网格让你可以创建基于事件的架构应用程序。既有事件的发布者，也有事件的消费者；然而，针对同一事件，可能会有多个订阅者。
- en: The publisher of an event can be an Azure resource, such as Blob storage, **Internet
    of Things** (**IoT**) hubs, and many others. These publishers are also known as
    event sources. These publishers use out-of-the-box Azure topics to send their
    events to Event Grid. There is no need to configure either the resource or the
    topic. The events raised by Azure resources are already using topics internally
    to send their events to Event Grid. Once the event reaches the grid, it can be
    consumed by the subscribers.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的发布者可以是一个Azure资源，例如Blob存储、**物联网**（**IoT**）中心等。这些发布者也称为事件源。它们使用现成的Azure主题将事件发送到事件网格，无需配置资源或主题。Azure资源触发的事件已经通过内部使用主题的方式将事件发送到事件网格。一旦事件到达网格，订阅者就可以消费它。
- en: 'The subscribers, or consumers, are resources who are interested in events and
    want to execute an action based on these events. These subscribers provide an
    event handler when they subscribe to the topic. The event handlers can be Azure
    functions, custom webhooks, logic apps, or other resources. Both the event sources
    and subscribers that execute event handlers are shown in *Figure 10.25*:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者或消费者是对事件感兴趣并希望基于这些事件执行操作的资源。这些订阅者在订阅主题时提供事件处理程序。事件处理程序可以是 Azure 函数、自定义 Webhook、逻辑应用程序或其他资源。执行事件处理程序的事件源和订阅者如*图
    10.25*所示：
- en: '![The Event Grid architecture](img/B15432_10_25.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![事件网格架构](img/B15432_10_25.jpg)'
- en: 'Figure 10.25: The Event Grid architecture'
  id: totrans-234
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.25：事件网格架构
- en: When an event reaches a topic, multiple event handlers can be executed simultaneously,
    each taking its own action.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件到达主题时，可以同时执行多个事件处理程序，每个处理程序执行自己的操作。
- en: 'It is also possible to raise a custom event and send a custom topic to Event
    Grid. Event Grid provides features for creating custom topics, and these topics
    are automatically attached to Event Grid. These topics know the storage for Event
    Grid and automatically send their messages to it. Custom topics have two important
    properties, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以引发自定义事件并将自定义主题发送到事件网格。事件网格提供了创建自定义主题的功能，这些主题会自动附加到事件网格。这些主题知道事件网格的存储位置，并会自动将消息发送到该位置。自定义主题有两个重要属性，如下所示：
- en: '**An endpoint**: This is the endpoint of the topic. Publishers and event sources
    use this endpoint to send and publish their events to Event Grid. In other words,
    topics are recognized using their endpoints.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端点**：这是主题的端点。发布者和事件源通过此端点将事件发送并发布到事件网格。换句话说，主题是通过其端点来识别的。'
- en: '**Keys**: Custom topics provide a couple of keys. These keys enable security
    for the consumption of the endpoint. Only publishers with these keys can send
    and publish their messages to Event Grid.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥**：自定义主题提供了一些密钥。这些密钥为端点的使用提供安全保障。只有拥有这些密钥的发布者才能将消息发送并发布到事件网格。'
- en: Each event has an event type and it is recognized by it. For example, Blob storage
    provides event types, such as `blobAdded` and `blobDeleted`. Custom topics can
    be used to send a custom-defined event, such as a custom event of the `KeyVaultSecretExpired` type.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 每个事件都有一个事件类型，并通过它来识别。例如，Blob 存储提供了事件类型，如 `blobAdded` 和 `blobDeleted`。自定义主题可以用来发送自定义定义的事件，如
    `KeyVaultSecretExpired` 类型的自定义事件。
- en: On the other hand, subscribers have the ability to accept all messages or only
    get events based on filters. These filters can be based on the event type or other
    properties within the event payload.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，订阅者有能力接受所有消息，或者仅根据筛选器获取事件。这些筛选器可以基于事件类型或事件有效负载中的其他属性。
- en: 'Each event has at least the following five properties:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 每个事件至少具有以下五个属性：
- en: '`id`: This is the unique identifier for the event.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：这是事件的唯一标识符。'
- en: '`eventType`: This is the event type.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eventType`：这是事件类型。'
- en: '`eventTime`: This is the date and time when the event was raised.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eventTime`：这是事件引发的日期和时间。'
- en: '`subject`: This is a short description of the event.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subject`：这是事件的简短描述。'
- en: '`data`: This is a dictionary object and contains either resource-specific data
    or any custom data (for custom topics).'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：这是一个字典对象，包含特定资源的数据或任何自定义数据（用于自定义主题）。'
- en: Currently, Event Grid's functionalities are not available with all resources;
    however, Azure is continually adding more and more resources with Event Grid functionality.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，事件网格的功能并非所有资源都支持；然而，Azure 正在不断增加更多支持事件网格功能的资源。
- en: To find out more about the resources that can raise events related to Event
    Grid and handlers that can handle these events, please go to [https://docs.microsoft.com/azure/event-grid/overview](https://docs.microsoft.com/azure/event-grid/overview).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于能够引发与事件网格相关事件的资源以及能够处理这些事件的处理程序，请访问[https://docs.microsoft.com/azure/event-grid/overview](https://docs.microsoft.com/azure/event-grid/overview)。
- en: Resource events
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源事件
- en: 'In this section, the following steps are provided to create a solution in which
    events that are raised by Blob storage are published to Event Grid and ultimately
    routed to an Azure function:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了以下步骤，以创建一个解决方案，其中由 Blob 存储引发的事件发布到事件网格，并最终路由到 Azure 函数：
- en: Log in to the Azure portal using the appropriate credentials and create a new
    Storage account in an existing or a new resource group. The Storage account should
    be either **StorageV2** or **Blob storage**. As demonstrated in *Figure 10.26*,
    Event Grid will not work with **StorageV1**:![Creating a storage account of the
    StorageV2 type](img/B15432_10_26.jpg)
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用适当的凭据登录到 Azure 门户，并在现有或新的资源组中创建一个新的存储账户。存储账户应该是 **StorageV2** 或 **Blob 存储**。如
    *图 10.26* 所示，事件网格不支持 **StorageV1**：![创建 StorageV2 类型的存储账户](img/B15432_10_26.jpg)
- en: 'Figure 10.26: Creating a new storage account'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.26：创建新的存储账户
- en: Create a new function app or reuse an existing function app to create an Azure
    function. The Azure function will be hosted within the function app.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的函数应用程序，或者重用现有的函数应用程序来创建 Azure 函数。Azure 函数将托管在该函数应用程序中。
- en: Create a new function using the **Azure Event Grid trigger** template. Install
    the **Microsoft.Azure.WebJobs.Extensions.EventGrid** extension if it's not already
    installed, as shown in *Figure 10.27*:![Installing extensions for Azure Event
    Grid trigger](img/B15432_10_27.jpg)
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **Azure Event Grid 触发器** 模板创建一个新函数。如果尚未安装 **Microsoft.Azure.WebJobs.Extensions.EventGrid**
    扩展，请安装该扩展，如 *图 10.27* 所示：![为 Azure Event Grid 触发器安装扩展](img/B15432_10_27.jpg)
- en: 'Figure 10.27: Installing extensions for an Azure Event Grid trigger'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.27：为 Azure Event Grid 触发器安装扩展
- en: Name the `StorageEventHandler` function and create it. The following default
    generated code will be used as the event handler:![Code for the event handler](img/B15432_10_28.jpg)
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `StorageEventHandler` 函数命名并创建它。以下是将作为事件处理程序使用的默认生成代码：![事件处理程序代码](img/B15432_10_28.jpg)
- en: 'Figure 10.28: Event handler code'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.28：事件处理程序代码
- en: The subscription to Storage events can be configured either from the Azure Functions
    **user interface (UI)** by clicking on **Add Event Grid subscription**, or from
    the storage account itself.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存储事件的订阅可以通过 Azure Functions **用户界面 (UI)** 配置，方法是点击 **添加事件网格订阅**，或者通过存储账户本身进行配置。
- en: Click on the **Add Event Grid subscription** link in the Azure Functions UI
    to add a subscription to the events raised by the storage account created in the
    previous step. Provide a meaningful name for the subscription, and then choose
    **Event Schema** followed by **Event Grid Schema**. Set **Topic Types** as **Storage
    Accounts**, set an appropriate **Subscription**, and the resource group containing
    the storage account:![Creating an Event Grid subscription](img/B15432_10_29.jpg)
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Azure Functions UI 中点击 **添加事件网格订阅** 链接，为前一步创建的存储账户添加事件订阅。为订阅提供一个有意义的名称，然后选择
    **事件模式**，接着选择 **事件网格模式**。将 **主题类型** 设置为 **存储账户**，选择适当的 **订阅**，并选择包含存储账户的资源组：![创建事件网格订阅](img/B15432_10_29.jpg)
- en: 'Figure 10.29: Creating an Event Grid subscription'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.29：创建事件网格订阅
- en: Ensure that the **Subscribe to all event types** checkbox is checked and click
    on the **Create** button (it should be enabled as soon as a storage account is
    selected).
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保选中 **订阅所有事件类型** 复选框，然后点击 **创建** 按钮（选中存储账户后该按钮应自动启用）。
- en: If we now navigate to the storage account in the Azure portal and click on the **Events**
    link in the left-hand menu, the subscription for the storage account should be
    visible:![List of event subscriptions](img/B15432_10_30.jpg)
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在导航到 Azure 门户中的存储账户，并点击左侧菜单中的 **事件** 链接，则应能看到该存储账户的订阅：![事件订阅列表](img/B15432_10_30.jpg)
- en: 'Figure 10.30: Event subscription list'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.30：事件订阅列表
- en: Upload a file to the Blob storage after creating a container, and the Azure
    function should be executed. The upload action will trigger a new event of the `blobAdded` type
    and send it to the Event Grid topic for storage accounts. As shown in *Figure
    10.31*, the subscription is already set to get all the events from this topic,
    and the function gets executed as part of the event handler:![Using a blob file
    to trigger a new event](img/B15432_10_31.jpg)
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建容器后，将文件上传到 Blob 存储，Azure 函数应该会被执行。上传操作将触发一个 `blobAdded` 类型的新事件，并将其发送到存储账户的事件网格主题。如
    *图 10.31* 所示，订阅已经设置为接收来自该主题的所有事件，函数将作为事件处理程序的一部分执行：![使用 blob 文件触发新事件](img/B15432_10_31.jpg)
- en: 'Figure 10.31: Triggering a new event'
  id: totrans-265
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.31：触发新事件
- en: In this section, you learned how events raised by Blob storage can be routed
    to an Azure function. In the next section, you will learn how to leverage custom
    events.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何将 Blob 存储引发的事件路由到 Azure 函数。在下一节中，你将学习如何利用自定义事件。
- en: Custom events
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义事件
- en: 'In this example, instead of using out-of-box resources to generate events,
    custom events will be used. We will use PowerShell to create this solution and
    reuse the same Azure function that was created in the last exercise as the handler:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用自定义事件，而不是使用现成的资源来生成事件。我们将使用 PowerShell 创建这个解决方案，并重用在上一个练习中创建的相同
    Azure 函数作为处理器：
- en: Log in and connect to your Azure subscription of choice using `Login-AzAccount`
    and `Set-AzContext cmdlet`.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Login-AzAccount` 和 `Set-AzContext` cmdlet 登录并连接到你选择的 Azure 订阅。
- en: 'The next step is to create a new Event Grid topic in Azure in a resource group.
    The `New-AzEventGridTopic` cmdlet is used to create a new topic:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在 Azure 的一个资源组中创建一个新的事件网格主题。使用 `New-AzEventGridTopic` cmdlet 创建新的主题：
- en: '[PRE4]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once the topic is created, its endpoint URL and key should be retrieved as
    they are needed to send and publish the event to it. The `Get-AzEventGridTopic`
    and `Get-AzEventGridTopicKey` cmdlets are used to retrieve these values. Note
    that `Key1` is retrieved to connect to the endpoint:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦主题创建完成，需要获取其端点 URL 和密钥，因为它们是发送并发布事件到该主题所必需的。`Get-AzEventGridTopic` 和 `Get-AzEventGridTopicKey`
    cmdlet 被用来获取这些值。请注意，获取的是 `Key1`，用于连接到端点：
- en: '[PRE5]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A new hash table is created with all five important Event Grid event properties.
    A new `id` property is generated for the ID, the `subject` property is set to
    `Key vault` `Asset Expiry`, `eventType` is set to `Certificate Expiry`, `eventTime` is
    set to the current time, and `data` contains information regarding the certificate:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的哈希表，包含所有五个重要的事件网格事件属性。为 ID 生成一个新的 `id` 属性，将 `subject` 属性设置为 `Key vault`
    `Asset Expiry`，将 `eventType` 设置为 `Certificate Expiry`，将 `eventTime` 设置为当前时间，并将
    `data` 填充证书相关信息：
- en: '[PRE6]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Since Event Grid data should be published in the form of a JSON array, the
    payload is converted in the JSON array. The `"["`,`"]"` square brackets represent
    a JSON array:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于事件网格数据应以 JSON 数组的形式发布，因此有效负载会被转换为 JSON 数组。`"["` 和 `"]"` 方括号代表 JSON 数组：
- en: '[PRE7]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The event will be published using the HTTP protocol, and the appropriate header
    information has to be added to the request. The request is sent using the application/JSON
    content type and the key belonging to the topic is assigned to the `aeg-sas-key`
    header. It is mandatory to name the header and key set to `aeg-sas-key`:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件将通过 HTTP 协议发布，必须向请求中添加适当的头信息。请求使用应用程序/JSON 内容类型发送，属于主题的密钥被分配给 `aeg-sas-key`
    头部。必须命名头部并将密钥设置为 `aeg-sas-key`：
- en: '[PRE8]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A new subscription is created to the custom topic with a name, the resource
    group containing the topic, the topic name, the webhook endpoint, and the actual
    endpoint that acts as the event handler. The event handler in this case is the
    Azure function:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的订阅，订阅自定义主题，包含名称、包含主题的资源组、主题名称、WebHook 端点和实际作为事件处理器的端点。在此情况下，事件处理器是 Azure
    函数：
- en: '[PRE9]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The URL of the Azure function is available from the **Integrate** tab, as shown
    in *Figure 10.31*:'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Azure 函数的 URL 可以从**集成**选项卡获取，如*图 10.31*所示：
- en: '![Event Grid Subscription URL in the Integrate tab](img/B15432_10_32.jpg)'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![集成选项卡中的事件网格订阅URL](img/B15432_10_32.jpg)'
- en: 'Figure 10.32: Event Grid Subscription URL in the Integrate tab'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.32：集成选项卡中的事件网格订阅 URL
- en: 'By now, both the subscriber (event handler) and the publisher have been configured.
    The next step is to send and publish an event to the custom topic. The event data
    was already created in the previous step and, by using the `Invoke-WebRequest`
    cmdlet, the request is sent to the endpoint along with the body and the header:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，订阅者（事件处理器）和发布者都已配置完成。下一步是向自定义主题发送并发布事件。事件数据已经在上一步创建，使用`Invoke-WebRequest`
    cmdlet，带着请求体和头部将请求发送到端点：
- en: '[PRE10]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The API call will trigger the event and the Event Grid will message the endpoint
    we configured, which is the function app. With this activity, we are winding up
    this chapter.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: API 调用将触发事件，事件网格会向我们配置的端点发送消息，该端点是功能应用。通过这项操作，我们将结束本章内容。
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The evolution of functions from traditional methods has led to the design of
    the loosely coupled, independently evolving, self-reliant serverless architecture
    that was only a concept in earlier days. Functions are a unit of deployment and
    provide an environment that does not need to be managed by the user at all. All
    they have to care about is the code written for the functionality. Azure provides
    a mature platform for hosting functions and integrating them seamlessly, based
    on events or on demand. Nearly every resource in Azure can participate in an architecture
    composed of Azure functions. The future is functions, as more and more organizations
    want to stay away from managing infrastructures and platforms. They want to offload
    this to cloud providers. Azure Functions is an essential feature to master for
    every architect dealing with Azure.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 从传统方法到函数的演变，催生了松耦合、独立演化、自给自足的无服务器架构，这在早期只是一个概念。函数是部署单元，提供一个完全无需用户管理的环境。用户只需要关注为功能编写的代码。Azure
    提供了一个成熟的平台，用于托管函数并根据事件或按需无缝集成它们。Azure 中几乎所有资源都可以参与由 Azure 函数组成的架构。未来是函数，因为越来越多的组织希望摆脱管理基础设施和平台的任务，想将这些工作交给云服务提供商。对于每个处理
    Azure 的架构师来说，掌握 Azure Functions 是一项基本技能。
- en: This chapter went into the details of Azure Functions, Functions as a Service,
    Durable Functions, and Event Grid. The next chapter will focus on Azure Logic
    Apps, and we will build a complete end-to-end solution combining multiple serverless
    services along with other Azure services, such as Azure Key Vault and Azure Automation.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细介绍了 Azure Functions、函数即服务（Functions as a Service）、持久化函数（Durable Functions）和事件网格（Event
    Grid）。下一章将重点讲解 Azure Logic Apps，并且我们将构建一个完整的端到端解决方案，结合多个无服务器服务以及其他 Azure 服务，如
    Azure Key Vault 和 Azure Automation。
