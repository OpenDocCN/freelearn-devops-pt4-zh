- en: Approaches, Tools, and Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法、工具和技术
- en: The last chapter focused on getting a goal, vision, and dedicated team together
    (or not, as the case may be) to help with the implementation and adoption of CD
    and DevOps within your business. Over the next couple of chapters, we will go
    through the steps of executing the plan to ultimately deliver the goal you have
    defined.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章专注于为 CD 和 DevOps 的实施和推广组建目标、愿景和专门的团队（或根据实际情况不组建）。在接下来的几章中，我们将通过执行计划的步骤，最终实现你所定义的目标。
- en: Throughout [Chapter 3](17779905-1394-4db1-995e-04c6af9a5125.xhtml), *Culture
    and Behaviors are the Cornerstones to Success*, we focused on the human side of
    what needs to be in place for CD and DevOps adoption. [Chapter 4](a19ac942-68bd-48a6-b59e-cd67ced91b65.xhtml),
    *Planning for Success*, then looked at how to build the plan and some of the building
    blocks that need to be put into place to make the adoption successful. We will
    now apply focus on the technical side of the execution—the tools, techniques,
    approaches, and processes you and the team should be looking to implement and/or
    refine as part of the plan.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](17779905-1394-4db1-995e-04c6af9a5125.xhtml)中，*文化和行为是成功的基石*，我们专注于 CD 和
    DevOps 采用中需要落实的人文方面。[第4章](a19ac942-68bd-48a6-b59e-cd67ced91b65.xhtml)，*成功的规划*，则探讨了如何制定计划以及为确保采纳成功需要构建的一些基本要素。接下来，我们将重点关注执行中的技术层面——你和团队应该在计划中实施和/或完善的工具、技术、方法和流程。
- en: There will be quite a lot of things to cover and take in, some of which you
    will need, some of which you may already have in place, and some of which you
    may want to consider implementing later down the line. I would recommend you read
    through everything, just in case there are some small chunks of wisdom or information
    that you can adapt or adopt to better fit your requirements.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖很多内容，其中一些是你需要的，一些你可能已经具备，另一些则可能是你以后想要考虑实施的。我建议你阅读全部内容，以防其中有些小的智慧或信息，你能够调整或采用，以更好地满足你的需求。
- en: Quite a bit of this chapter is focused on software engineering (that is, the
    Dev side of the DevOps partnership), and more CD than DevOps, but bear with me
    as some of the points covered are as relevant to system operations as they are
    to software engineering—this is, after all, what DevOps is really all about.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有相当一部分内容集中在软件工程（即 DevOps 合作中的 Dev 端），更偏向 CD 而非 DevOps，但请耐心阅读，因为其中的一些要点对系统运维和软件工程同样相关——毕竟，这正是
    DevOps 的核心所在。
- en: It is worth pointing out that the tools and processes mentioned are not mutually
    exclusive—it is not a case of all or nothing; you just need to pick what works
    for you. That said, there is a logical order and dependency to some of the things
    covered over the next chapter or two, but it's down to you to decide what is viable.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，所提到的工具和流程并不是相互排斥的——并非“全有或全无”；你只需选择适合你的方法。话虽如此，接下来一两章中所涉及的一些内容确实有一定的逻辑顺序和依赖关系，但最终决定什么是可行的，还是取决于你。
- en: One other very important thing to take into account is that there are a plethora
    of other books, websites, blogs, and such that go into far more detail than I
    will. I will endeavor to provide a flavor and overview of what you'll need to
    drive the CD and DevOps adoption forward. It's down to you and the team to dig
    a little deeper.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常重要的考虑因素是，除了我将要提到的内容外，还有大量的书籍、网站、博客等，它们提供了比我更为详细的信息。我会努力提供一个概览，帮助你理解推动 CD
    和 DevOps 采用的关键内容。深入了解的部分就交给你和团队去探索吧。
- en: Throughout this chapter, I'll be referring to tools and/or software solutions
    that you should consider to reduce the burden and ease the CD and DevOps adoption.
    As with any investment, I would recommend that you don't just chose the first
    one that appears in your favorite search engine or the one that an existing vendor
    is pushing. The CD and DevOps tooling market is very competitive; therefore, you
    should have more than one or two options. Understand what problem you need to
    solve based upon your specific needs and apply due diligence to the selection.
    If you need to trial a few different tools, you should do so. The effectiveness
    of your CD and DevOps adoption may rely upon these tools, so choose carefully.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将提到一些工具和/或软件解决方案，您应考虑使用它们来减轻负担并促进CD和DevOps的采用。像任何投资一样，我建议您不要仅仅选择出现在您最喜欢的搜索引擎中的第一个工具，或选择一个现有供应商强推的工具。CD和DevOps工具市场竞争激烈；因此，您应该有多个选择。根据您的具体需求，了解您需要解决的问题，并在选择时进行充分的尽职调查。如果需要尝试几种不同的工具，您应该这样做。CD和DevOps的采纳效果可能依赖于这些工具，因此请选择谨慎。
- en: Now that's out of the way, let's start with some engineering best practices.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 既然这些问题已经解决了，让我们开始一些工程最佳实践吧。
- en: Engineering best practices
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工程最佳实践
- en: For those of you who are not software engineers, nor from a software engineering
    background, your knowledge and/or interest in how software is developed may be
    extremely minimal. Why, I hear you ask, do I need to know how a developer does
    their job? Surely, developers know this stuff better than I do? I doubt I even
    understand 10 percent of it anyway!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不是软件工程师，或者没有软件工程背景的人来说，您对软件如何开发的知识和/或兴趣可能非常有限。你可能会问，为什么我需要了解开发人员是如何工作的？难道开发人员比我更懂这些吗？反正我都不理解其中10%！
- en: To some extent, this is very true; developers do (and should) know their stuff,
    and having you stick your nose in might not be welcome. However, it does help
    if you at least have an understanding or appreciation of how software is created,
    as it can help to identify where potential issues could reside.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，这是非常真实的；开发人员确实（并且应该）懂得自己的业务，把你放进来可能并不受欢迎。然而，如果你至少对软件是如何创建的有所了解或理解，会有帮助，因为这有助于识别潜在的问题所在。
- en: 'Let''s put it another way: I have an understanding and appreciation of how
    an internal combustion engine is put together and how it works, but I am no mechanic—far
    from it, in fact. However, I do know enough to be able to question why a mechanic
    has replaced my entire exhaust system and rear axle when I took my car in for
    a fuel-injector problem—in fact, I think I would vigorously question why.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 换个方式说：我理解并且欣赏内燃机是如何组装的以及它是如何运作的，但我不是机械师——事实上，远非如此。然而，我知道足够的知识，能够质疑当我带车去修理时，为什么一个机械师会把我的整个排气系统和后轴都换了，尽管我只是带车来解决一个燃油喷射器的问题——事实上，我肯定会激烈地质疑为什么。
- en: It is the same with software development and the process that surrounds it.
    If you're not technical in the slightest and haven't done your homework to understand
    how software should be written, you leave yourself open to decisions being made
    by (or at the very least, noise emitting from) individuals who prefer to deflect
    by using technobabble rather than be open, honest, and willing and able to work
    with you. You will no doubt have come across such individuals during the elephant
    exposure, and I would wager that they have avoided getting involved with this
    pipe dream of shipping software quickly without everything going to pot—at least
    that's what they think. You and the team will need try to and work on the same
    level as them, so having some idea of what you're talking about will help with
    those discussions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发和它周围的过程也是如此。如果你一点技术背景都没有，且没有做过功课来理解软件应该如何编写，你就会让自己暴露在那些喜欢用技术术语来转移话题而不是开诚布公、愿意并能够与你合作的人做决定的风险中。在“象的曝光”过程中，你无疑会遇到过这样的人，我敢打赌，他们肯定避免参与到这个快速交付软件而不让一切乱套的空想之中——至少他们是这么认为的。你和团队将需要与他们在同一水平上合作，所以如果你对你所说的内容有一些了解，将有助于这些讨论。
- en: 'Let''s start with the basics: CD is based upon a premise that quality software
    can be developed, built, tested, and shipped many times in quick succession (that''s
    the continuous bit)—ideally, we''re talking hours or days at the most. When you
    consider this list and apply it to a traditional waterfall-style development project,
    you''ll no doubt have found that every step takes time and effort, and contains
    waste. You would also no doubt have found that it''s the shipping part that is
    the most painful, costly, and risky. When applied to a modern agile development
    project, you''ll normally find that the first three items on the list are more
    honed, efficient, and effective (although not without some waste and time lag—depending
    on the maturity of the team), whereas the shipping part is still painful and takes
    a vast amount of time and effort. We will focus on the shipping (or to be more
    accurate, the delivery) section later.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基础开始：CD（持续交付）基于一个前提，即优质软件可以在短时间内多次开发、构建、测试和发布（这就是“持续”的部分）——理想情况下，我们说的是几小时或几天最多。当你把这个列表应用到传统的瀑布式开发项目时，你无疑会发现每个步骤都需要时间和精力，并且充满浪费。你也无疑会发现，最痛苦、最昂贵、最有风险的部分就是发布（或交付）。而当应用到现代敏捷开发项目时，你通常会发现列表中的前三项更为精炼、高效和有效（尽管仍然存在一些浪费和时间滞后——这取决于团队的成熟度），但发布部分仍然是痛苦的，且需要大量的时间和精力。稍后我们将重点讨论发布（更准确地说，是交付）部分。
- en: From this point forward, I'm going to assume you know what the differences between
    waterfall and agile development are (if not, I suggest you stop here and do some
    homework) and move swiftly on.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，我假设你已经知道瀑布式开发和敏捷开发之间的区别（如果不知道，我建议你停下来做点功课），然后迅速进入下一部分。
- en: 'Let''s go back to basics and cover some fundamentals in terms of modern agile
    software engineering:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回归基础，讲解一些现代敏捷软件工程的基本概念：
- en: All code, config, and related metadata are stored in a modern source/version-control
    solution
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有代码、配置和相关元数据都存储在现代的源代码/版本控制解决方案中
- en: Small and complete code changes are committed to the source-control repository
    frequently
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小的且完整的代码更改应频繁提交到源代码管理仓库
- en: Unit tests are included by default and sit with the source-code repository
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试默认包含并与源代码仓库一起存放
- en: Refactoring code happens on a regular basis
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码重构会定期进行
- en: Code should not be overly complex and documented
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码不应过于复杂，并且应该有文档化说明
- en: Branches are short-lived, and merges are frequent
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支生命周期短，合并频繁
- en: Automated tests sit alongside the code within the source-control repository
    and are run very frequently
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试与代码一起存放在源代码仓库中，并且会非常频繁地运行
- en: Pair programming, code reviews, or pull requests are used consistently
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一直使用结对编程、代码审查或拉取请求
- en: Build and automated tests are orchestrated and controlled by a **Continuous
    Integration** (**CI**) solution
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和自动化测试由**持续集成**（**CI**）解决方案进行协调和控制
- en: Failing tests are not the end of the world; nor is having others find fault
    in your code
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试失败并不意味着世界末日；让别人指出你代码中的缺陷也不是终结
- en: I may have lost some of you, but before you skip this chapter, please read on
    a little more as I'll be going through some of these concepts soon.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有些人已经失去兴趣，但在跳过本章之前，请再稍微阅读下去，因为我很快会深入讲解其中的一些概念。
- en: The preceding list is pretty simplistic and, as stated previously, most software
    engineers who work on modern agile software development projects will see this
    as common sense and common practice.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表相当简单，正如之前所说，大多数从事现代敏捷软件开发项目的工程师会把这些视为常识和常规做法。
- en: The reference to modern agile software development is purposeful as there are
    still some (in some industries, that should read *many*) old-school code cutters
    who believe that they are exempt from this due to the fact that they have been
    delivering code without of all of this newfangled hipster stuff for many years
    without any issues. That may be true; however, there's next to no chance of successfully
    adopting CD and DevOps without changing the way that software is written and delivered.
    No doubt these individuals would have been in the disengaged contributors group
    during the elephant exposure.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 提到现代敏捷软件开发是有目的的，因为仍然有一些（在某些行业中，应该说是*很多*）老派的程序员认为，他们由于多年来在没有这些新潮的“hipster”技术的情况下成功交付代码，因此可以免除这一切。也许这是事实；然而，如果不改变软件的编写和交付方式，几乎不可能成功地采用CD和DevOps。这些人无疑会在“参与度低”的贡献者组中。
- en: What is more worrying is when these individuals are actively discouraging the
    software engineers who do wish to follow modern agile software engineering best
    practice from doing so. Whatever the situation, these old dogs will have to learn
    new tricks.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 更令人担忧的是，当这些人积极阻止那些希望遵循现代敏捷软件工程最佳实践的软件工程师时。无论情况如何，这些“老狗”都得学会新把戏。
- en: Ultimately, modern agile software engineering is based on the simple premise
    of finding software problems as early as possible. Without this approach, these
    software problems **will** be found later down the line, they **will** slow everything
    down, and they **will** negatively impact the adoption and the perception of how
    successful the adoption is.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，现代敏捷软件工程的基础是尽早发现软件问题。没有这种方法，这些软件问题**必定**会在后期被发现，它们**必定**会拖慢进度，并且**必定**会对最佳实践的采用和其成功的认知产生负面影响。
- en: To put it another way, if you are continuously developing small incremental
    changes, which are being built, integrated, and tested, the ease of continuous
    delivery will be vastly increased.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果你持续开发小的增量变化，并且这些变化正在构建、集成和测试，那么持续交付的便利性将大大提高。
- en: 'Let''s see what our personas can do to help:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的角色可以做些什么来帮助：
- en: '| **Good approach** | **Not-so-good approach** |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **良好方法** | **不太好的方法** |'
- en: '| Victoria (the Veep) should not ignore this as simply "what developers do"
    and ensure she is aware of the effort needed to successfully embed best practice
    within the engineering teams and be willing to supply budget and executive sponsorship.
    | Victoria (the Veep) sees this as more expense which may well slow things down
    and / or a low priority skunkworks project off of the side of the main product
    delivery process |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| Victoria（副总裁）不应仅仅将此视为“开发人员的工作”，应确保她意识到在工程团队中成功实施最佳实践所需的努力，并愿意提供预算和高层支持。 |
    Victoria（副总裁）将其视为更多的开支，这可能会拖慢进程和/或成为偏离主要产品交付流程的低优先级秘密项目 |'
- en: '| Stan (the manager) should ensure that relative importance is front and center
    with leadership, peer group and team(s) alike. He should also ensure the correct
    resources are assigned and aligned across the organization | Stan (the manager)
    ignores the benefits that engineering best practice will bring and sees adoption
    as additional workload that will distract the team(s) |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| Stan（经理）应确保相对重要性在领导层、同伴群体和团队之间得到充分重视，并确保正确的资源在组织中分配和对齐。 | Stan（经理）忽视工程最佳实践带来的好处，认为其采用会增加额外的工作量，从而分散团队的注意力。
    |'
- en: '| Devina (the developer) and Oscar (the Ops guy) should spend time understanding
    and fully embrace engineering best practice and lead by example throughout their
    peer groups. | Devina (the developer) and Oscar (the Ops guy) keep their heads
    down and leave the leadership to argue about the merits of engineering best practice
    which they continue to struggle to deliver |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| Devina（开发人员）和Oscar（运维人员）应该花时间理解并完全接受工程最佳实践，并在同伴中以身作则。 | Devina（开发人员）和Oscar（运维人员）低调行事，把领导角色交给他人，继续在执行工程最佳实践时遇到困难。
    |'
- en: For those of you whose eyes may have glazed over, or those of you who need a
    refresher, let's break these down a little further, starting with source-control.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些眼神开始涣散的朋友，或者那些需要复习的朋友，让我们从源代码管理开始，进一步解释这些概念。
- en: Source-control
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码管理
- en: There are many different flavors, versions, and solutions available for source-control
    (sometimes referred to as SCM or version-control systems), both commercial (not
    free) and open source (free). Most of these tools can be self-hosted (if that's
    something you need to do), or offered as a **PaaS** model (which isn't free but
    still relatively cheap). Taking this into account, there are no excuses not to
    use source-control. None!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多不同版本、种类和解决方案可供选择用于源代码管理（有时称为SCM或版本控制系统），包括商业（收费）和开源（免费的）。这些工具大多可以自托管（如果需要的话），或者作为**PaaS**模式提供（虽然不是免费的，但仍然相对便宜）。考虑到这一点，不使用源代码管理没有任何借口。绝对没有！
- en: If **all** of your code is in source-control, it is versioned (that is, there
    is a history of every change that has been made from the year dot), it is available
    to anyone and everyone who has access to the source-control system, it is secure,
    and it is (should be) backed up so you won't lose any of it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**所有**代码都存储在源代码管理中，并且进行了版本控制（即，每一个变更都有历史记录，从最早的版本开始），它对任何拥有源代码管理访问权限的人都是可用的，是安全的，并且应该有备份，以防丢失任何代码。
- en: Some of the more modern solutions can actually help you control the full life
    cycle of software delivery via inbuilt tools, workflows, and triggers. This can
    save you a lot of time, complexity, and cost. However, you should not be swayed
    by this too much. What you need is a solution that best suits your organization
    and the ways of working (now and in the future), and helps you to deliver quality
    software continuously.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一些更现代的解决方案实际上可以帮助你通过内置的工具、工作流程和触发器来控制软件交付的整个生命周期。这可以为你节省大量的时间、复杂度和成本。然而，你不应过分被此类功能所左右。你需要的是一个最适合你组织和工作方式（现在以及未来）的解决方案，帮助你持续交付高质量的软件。
- en: 'Some of you may have heard the urban myth that a source-control solution is
    only useful for software source code. Just like all urban myths, this had some
    truth way back in the mists of time, but is now bunk. Source-control should not
    be restricted to software source code. Anything that can, could, and will be changed
    should be versioned and stored in source-control. I''ve already mentioned a few
    examples, so let''s expand on this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你们中的一些人可能听说过一个城市传说，认为源代码管理解决方案仅对软件源代码有用。像所有的城市传说一样，这种说法在很久以前是有一定道理的，但现在已经不成立了。源代码管理不应该仅限于软件源代码。任何可以、能够并且将会被更改的东西都应该进行版本管理，并存储在源代码管理系统中。我已经提到了一些例子，下面我们来详细扩展一下：
- en: Unit tests
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Test cases
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试用例
- en: Automated test scripts
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试脚本
- en: Software configuration/metadata
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件配置/元数据
- en: SQL scripts/SPROCS
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL脚本/SPROCS
- en: Documentation
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档
- en: Environmental configurations
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境配置
- en: Server configuration
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器配置
- en: Anything and everything than can be changed, edited, or saved
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何可以被更改、编辑或保存的东西
- en: 'The normal bone of contention is environmental/server configurations and other
    collections of artifacts such as start-up scripts and network routing config,
    which some may see as exempt from source-control as this is in the land of Ops
    rather than Dev. However, as you''re moving to DevOps, this no longer makes any
    sense and is not applicable. The rule of thumb should be: if it can be changed,
    it should be in source-control and versioned.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，争议的焦点是环境/服务器配置以及其他一些工件集合，比如启动脚本和网络路由配置，有些人可能认为这些应该排除在源代码管理之外，因为它们属于运维领域，而不是开发领域。然而，随着你们逐步过渡到DevOps，这种说法就不再有任何意义，且不再适用。经验法则应该是：如果它可以被更改，它就应该在源代码管理中进行版本控制。
- en: The DevOps community refers to the approach of representing a given environment
    via configuration files that can (should) be stored in source-control as configuration
    as code. It should be pointed out that this approach has grown from the open source
    community, and therefore some areas of this approach may not be wholly applicable
    initially—for example, administering Windows servers is more point-and-click than
    a set of configuration files that would be used to administer a Linux cluster.
    However, you can also administer Windows via PowerShell scripts, so there is an
    option. The bottom line is that you should strive toward having every element
    of a given environment/server/switch/router/firewall represented as configuration
    files that can (and should) be stored and versioned within your source-control
    system. That way, you can create an exact clone of a given environment at a given
    point in time with relative ease (something we'll come to soon).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps社区提到的一种方法是通过配置文件来表示给定的环境，并且这些配置文件可以（也应该）存储在源代码管理中，作为“配置即代码”。需要指出的是，这种方法源自开源社区，因此这种方法的一些方面最初可能并不完全适用——例如，管理Windows服务器更多是通过点击操作，而不是使用一组配置文件来管理Linux集群。然而，你也可以通过PowerShell脚本来管理Windows服务器，所以这也是一种选择。总的来说，你应该努力让给定环境/服务器/交换机/路由器/防火墙的每个元素都以配置文件的形式表示，并可以（并且应该）存储和版本控制在你的源代码管理系统中。这样，你就可以相对轻松地在某一时刻创建给定环境的精确克隆（稍后我们会讲到这个问题）。
- en: One thing that may become a blocker is security and access to the contents of
    the source within the source-control solution. For example, if you're storing
    environmental configuration as code, you ideally don't want the development team
    having access to the production database connection strings or API tokens. There
    are proven and well-documented ways and means to do this (masking, encryption,
    restricting access to certain repositories, and so on), so it shouldn't be a blocker
    if you plan for it upfront.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能成为阻碍的因素是安全性以及对源代码管理系统中文件内容的访问权限。例如，如果你将环境配置作为代码存储，理想情况下你不希望开发团队访问生产数据库连接字符串或API令牌。已经有了经过验证且文档化的方式来做到这一点（如掩码、加密、限制访问某些仓库等），所以如果你提前做好规划，这不应该成为障碍。
- en: There are books and reference materials aplenty regarding source-control that
    cover this subject in much more depth and detail, so I will not dwell on it here.
    Suffice it to say, if you do not have a source-control solution, implement one.
    Now!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 关于源代码管理的书籍和参考资料很多，它们在这个主题上有更深入的讨论，因此我在这里就不多赘述。只需说，如果你没有源代码管理解决方案，请立即实施一个。
- en: As you'll no doubt gather, a source-control solution is a very valuable tool
    for CD and DevOps adoption. Along with having a central place to securely store
    your source code, it's also important to apply the same approach to your binary
    objects and artifacts.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，源代码管理解决方案对于持续交付（CD）和DevOps的采用是非常有价值的工具。除了拥有一个中央位置来安全存储源代码之外，将同样的方法应用于你的二进制对象和工件也是非常重要的。
- en: The binary repository
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制仓库
- en: As the name implies, a binary repository is somewhere to store your binary objects
    and artifacts. Binary objects/artifacts are, in software engineering terms, the
    runnable software that is created when the source code is successfully compiled.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，二进制仓库就是用来存储二进制对象和工件的地方。在软件工程术语中，二进制对象/工件是指源代码成功编译后生成的可执行软件。
- en: Binary repositories function in much the same way as a source-control solution,
    but, as you would expect, are better suited to storing binary objects. Some solutions
    also provide mechanisms to version, and even package up the binaries for later
    installation on a target environment.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制仓库的功能与源代码管理解决方案非常相似，但正如你所预期的那样，它们更适合存储二进制文件。一些解决方案还提供版本管理机制，甚至将二进制文件打包以便以后在目标环境中安装。
- en: We'll cover the importance of binary repositories later in the chapter. For
    now, let's move on to the valuable practice of keeping changes small and frequent.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章稍后讨论二进制仓库的重要性。现在，让我们继续讨论保持小而频繁变更的有价值实践。
- en: Small, frequent, and simple changes
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小而频繁、简单的变更
- en: Keeping changes small means the impact of the change—sometimes referred to as
    the blast radius—should also be small, the risks reduced, and the opportunities
    for change increased. It sounds overly simplistic, but it is also very true. If
    you consider how many changes to software a typical software engineering team
    makes in a day and then extrapolate that out to the number of teams you have making
    said changes, you'll soon find that this adds up. If you then take this number
    and multiply it by the number of days between releases, you'll find the volume
    of changes is not insignificant— and nor is the risk of those changes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 保持小的变更意味着变更的影响——有时称为爆炸半径——也应该很小，风险减少，变更的机会增加。听起来过于简单，但这也是非常正确的。如果你考虑一个典型的软件工程团队每天做的变更次数，然后将其推广到你有的所有团队的变更次数，你很快就会发现这些变更会积累起来。如果你再将这个数字乘以版本发布之间的天数，你会发现变更量并不微不足道——这些变更的风险也同样不可忽视。
- en: In terms of risk, let's assume we have a team of five software engineers who,
    on average, make 10 code changes each per day—that's 50 changes. Let's assume
    we have 10 teams all doing the same—that's 500 code changes per day. Let's now
    assume we're releasing every 12 weeks (or 60 working days); we're now talking
    30,000 changes that need to go live. Even if we have industry-leading test coverage—let's
    say 99.9% coverage—there's still a chance something nasty could slip through.
    In this case, that's 30 changes not covered. In simple terms, there's a risk that
    30 defects may be created every 12 weeks. OK, this is a very simplistic approach,
    but hopefully it illustrates the point that clumping together a large number of
    code changes is far from ideal.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 就风险而言，假设我们有一个由五个软件工程师组成的团队，每个工程师每天平均做10次代码变更——这就是50次变更。假设我们有10个团队都在做同样的事情——这就是每天500次代码变更。现在假设我们每12周发布一次版本（或60个工作日）；我们现在谈论的是30,000次需要上线的变更。即使我们有行业领先的测试覆盖率——假设是99.9%的覆盖率——仍然有可能会漏掉一些问题。在这种情况下，就是30个未被覆盖的变更。简单来说，每12周可能会产生30个缺陷的风险。好吧，这是一种非常简化的方式，但希望它能说明一个问题——将大量代码变更聚集在一起远不是理想的做法。
- en: One thing that may not be obvious is what happens if a simple defect is spotted
    the day after a release that can be fixed by a single-line code change. If we
    follow the preceding example, that defect will stay in production for another
    11 weeks and 6 days (assuming we don't have emergency patch releases available
    to us). The same is true of any change made on day one of the 12-week release
    cycle—including customer feature requests.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一件可能不太显而易见的事情是，如果在发布后的第二天发现了一个可以通过单行代码修改来修复的简单缺陷会发生什么。如果我们按照前面的例子，那这个缺陷将在生产环境中再停留11周6天（假设我们无法进行紧急补丁发布）。发布周期的第一天所做的任何变更——包括客户功能请求——也会发生同样的情况。
- en: 'If we were to break this down into smaller more frequent releases—say, every
    two weeks—and apply the same numbers, we would be looking at something like the
    following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将其拆解成更小且更频繁的发布——例如，每两周一次——并应用相同的数据，我们可能会看到类似以下的情况：
- en: '*500 changes * 10 days = 5,000 changes released with a risk of five defects
    slipping through.*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*500次变更 * 10天 = 5,000次变更发布，可能存在五个缺陷未被发现。*'
- en: Now, let's again assume that if one escaped defect is spotted and fixed the
    day after the release, then that change will be live in nine days. Again, if a
    customer feature request change was made on day one of the release cycle, it could
    be live in 10 days. I think you'll agree that sounds slightly better than the
    first example.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设如果在发布后的第二天发现并修复了一个缺陷，那么这个变更将在九天内上线。再次假设，如果在发布周期的第一天做了一个客户功能请求变更，它将在10天内上线。我想你会同意，这听起来比第一个例子要好一些。
- en: 'The following diagram goes some way to illustrate what this could look like:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示可以某种程度上说明这可能会是什么样子：
- en: '![](img/c28ef67f-8ae6-4d09-953c-72232aac5b62.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c28ef67f-8ae6-4d09-953c-72232aac5b62.png)'
- en: Large changes versus small incremental changes
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 大变更与小的增量变更
- en: Now, I will admit that the preceding example is very simplistic and may not
    reflect reality, and you might not currently have the luxury of shipping your
    code very frequently due to external factors (maybe your customers don't want—or
    can't accept—frequent releases, or your existing ops processes need time to allow
    for this); however, that is no excuse for not adopting the concepts now. If your
    software engineering teams become used to releasing in small and potentially shippable
    chunks, they form the habit of delivering continuously.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我必须承认前面的例子非常简化，可能与现实不符，且由于外部因素，你可能目前没有频繁发布代码的奢侈（也许你的客户不希望——或者不能接受——频繁的发布，或者你现有的运维流程需要时间来支持这一点）；然而，这并不能成为你现在不采用这些理念的借口。如果你的软件工程团队习惯于以小且可发布的模块进行发布，他们就会养成持续交付的习惯。
- en: Another way of putting this is that once you have fully adopted CD and DevOps,
    they will have to work in this mode, so why not start getting used to it?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种表达方式是，一旦你完全采用了持续交付（CD）和DevOps，它们将必须在这种模式下工作，那么为什么不从现在开始适应它呢？
- en: Continuously delivering small and frequent changes can also help in other areas;
    namely, reducing complexity, increasing code maintainability, and increasing quality.
    If an engineer only has to change a small amount of code then they have a far
    greater chance of refactoring the surrounding code to reduce complexity and overall
    maintainability of the codebase, including adding in additional unit tests. Another
    less obvious benefit of small and frequent changes is reducing the overhead of
    code reviews, pull requests, and merging, which can happen more frequently and
    become more of an everyday thing than a chore.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 持续地进行小范围且频繁的变更也有助于其他方面；即减少复杂性、提高代码的可维护性并提升质量。如果工程师只需要更改少量代码，那么他们就有更大的机会重构周围的代码，减少复杂性并提高代码库的整体可维护性，包括增加额外的单元测试。另一个不太明显的好处是减少代码审查、拉取请求和合并的开销，这些过程可以更加频繁地发生，成为一种日常的事情，而不是繁琐的任务。
- en: This practice should not be restricted to software engineering; it is just as
    relevant to changes in the system operations area. For example, making a small,
    isolated tweak to the server configuration (such as memory allocation to a virtual
    server) is much safer and easier to control and monitor than making sweeping changes
    all at once. If you make small changes, you have a much better chance of seeing
    whether the change had an impact (positive or negative) on the overall operation
    of the platform.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法不仅限于软件工程，它同样适用于系统运维领域的变更。例如，对服务器配置进行小范围、孤立的调整（如虚拟服务器的内存分配）比一次性进行大范围变更要安全得多，且更容易控制和监控。如果你进行小规模的更改，你将有更大的机会看到这些变更是否对平台的整体运行产生了影响（无论是正面的还是负面的）。
- en: Working with small, incremental changes is a very beneficial practice to follow.
    However, this is going to be pretty difficult to manage unless you have some tools
    to help automate the building of your software.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 进行小规模、渐进性的变更是一个非常有益的实践。然而，除非你有一些工具来帮助自动化构建软件，否则这将非常难以管理。
- en: Automated builds
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化构建
- en: One of the common themes with CD and DevOps adoption is how automation is used.
    As mentioned previously, without some sort of automated tooling or solution, it
    will be very difficult to deliver on a frequent basis. You may be reading this
    and thinking, "Well, that's pretty obvious." However, even in this modern technological
    age there are software engineering teams who do everything manually using manual
    steps and/or handcrafted scripts—some of which may be older than the engineer
    running them. Luckily, this is very much a minority nowadays, although I'll cover
    some aspects of what automation is and why it's key to CD and DevOps adoption,
    just in case you're in the minority.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: CD（持续交付）和DevOps采用的一个常见主题是如何使用自动化。如前所述，如果没有某种自动化工具或解决方案，将非常难以频繁地交付。你可能会读到这里并想，“嗯，这显然是显而易见的。”然而，即使在这个现代科技时代，仍然有一些软件工程团队在手动完成所有工作，使用手动步骤和/或手工编写的脚本——其中一些脚本的历史甚至比正在运行它们的工程师还要久远。幸运的是，这种情况如今已经非常少见，尽管我还是会介绍一些自动化的相关内容以及它为何对于CD和DevOps的采用至关重要，以防你正处于少数派。
- en: Every engineer that makes a change—be they a software or ops engineer—needs
    feedback as to whether a change they have made works (or not, as the case may
    be). The sooner they get this feedback, the sooner they can rectify any issues
    or move on to the next change. From a software engineering perspective, it is
    also very helpful to know whether the code they have written actually builds and/or
    compiles cleanly and consistently so that it can be tested.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进行更改的工程师——无论是软件工程师还是运维工程师——都需要反馈，以了解他们所做的更改是否有效（或者是否失败）。他们越早收到反馈，就能越早解决问题或继续进行下一个更改。从软件工程的角度来看，了解自己编写的代码是否能够顺利构建和/或编译，并且保持一致性，也是非常有帮助的，以便可以进行测试。
- en: This validation could be done via a manual process (or processes or scripts),
    but this can be cumbersome, inconsistent, prone to error, slow, and not always
    fully repeatable. Without consistency and repeatability, there's additional risk.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种验证可以通过手动过程（或过程或脚本）来完成，但这可能会繁琐、不一致、容易出错、缓慢，且并不总是能够完全重复。缺乏一致性和可重复性，会增加额外的风险。
- en: Implementing automation will help speed things up and keep things consistent,
    reliable, and repeatable, and, above, all provide confidence. If you are running
    the same steps over and over again and getting the same results, it's a strong
    bet that the process works and that you can trust it. It is therefore plausible
    that if you change one thing within your software, configuration, or environment,
    and the previously working process fails, there is a very good chance that the
    change has broken something.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 实施自动化将有助于加快进程，保持一致性、可靠性和可重复性，并且最重要的是提供信心。如果你反复执行相同的步骤并获得相同的结果，那么可以合理地推测该过程是有效的，且可以信任它。因此，如果你在软件、配置或环境中更改了某个部分，并且之前正常工作的过程失败了，那么很有可能是这个变更破坏了某些东西。
- en: 'There are plenty of tools available for building/compiling code—depending on
    the development language you are using—and all of them do pretty much the same
    thing: ensure the code is written correctly, the language syntax is as expected,
    ensure all external references are available, and—if all is as it should be—create
    a binary that can be run. This is overly simplistic, but hopefully conveys the
    point. There are a number of different ways to trigger this process: manually
    from the command line, manually via a script, or from within the developer''s
    IDE itself. Whichever process you use, you should seriously consider automating
    the process so that you gain consistency and repeatability.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多工具可供用来构建/编译代码——这取决于你使用的开发语言——它们的功能基本相同：确保代码书写正确、语言语法符合预期、确保所有外部引用可用，并且——如果一切正常——创建可以运行的二进制文件。这是一个过于简单的描述，但希望能传达出要点。触发这个过程的方法有多种：可以通过命令行手动触发、通过脚本手动触发，或通过开发者的IDE来触发。无论使用哪种方式，你都应该认真考虑自动化该过程，以确保一致性和可重复性。
- en: Another tool to consider including within the automation scripts/process is
    linting. Linting tools are there to help scan and check your source code for syntax
    issues. This can be a very useful addition as, if used before you build/compile
    code, it can vastly reduce the time taken to find issues—especially when you have
    quite a convoluted codebase, which means the build time is minutes rather than
    seconds. Again, there are plenty of options to consider, depending on the code
    language you're using.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑加入自动化脚本/流程的工具是代码检查（linting）。代码检查工具帮助扫描并检查源代码中的语法问题。这是一个非常有用的补充，因为如果在构建/编译代码之前使用它，能大大减少查找问题的时间——尤其是在代码库非常复杂时，这意味着构建时间可能是几分钟而不是几秒钟。同样，依据你使用的编程语言，有许多选项可供选择。
- en: Hopefully, you now have some insight into why automating the building of your
    software components is important. Let's now focus on test-automation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你现在已经对为什么自动化构建软件组件很重要有所了解。现在让我们集中讨论测试自动化。
- en: Test-automation
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试自动化
- en: A traditional software-delivery process will normally include an element of
    testing. However, depending on the organization and age of the software, running
    the test cases themselves is normally a manual process. That being said, test-automation
    has been around for a while—for as long as agile software development. However,
    it's not as prevalent as one would hope. I should point out that testing approaches
    and the automation of such is a massive subject, and I will not be covering everything
    here. If you need more information, I suggest you do some research and pick up
    some good books on the subject. What we'll cover here is pretty basic, but should
    give you enough information to understand how test-automation fits into CD and
    DevOps adoption.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的软件交付过程通常会包含一定的测试环节。然而，根据组织的不同以及软件的使用年限，测试用例的执行通常是一个手动过程。尽管如此，测试自动化已经存在了一段时间——与敏捷软件开发同时发展。然而，测试自动化并不像人们希望的那样普遍。我要指出的是，测试方法及其自动化是一个庞大的话题，我不会在这里涵盖所有内容。如果你需要更多的信息，我建议你做一些研究并阅读一些关于这个主题的好书。我们在这里讨论的内容相当基础，但应该足够让你理解测试自动化如何融入CD和DevOps的应用中。
- en: 'There are principally three types of tests:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 测试主要有三种类型：
- en: Unit tests are normally written in the coding language of the software and are
    used to exercise *code* and *logic paths* within the code base itself. They do
    not normally align to any particular use case or area of functionality.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试通常用软件的编程语言编写，用来测试代码库中的*代码*和*逻辑路径*。它们通常不会与任何特定的用例或功能区域对齐。
- en: Integration tests traditionally exercise the way in which one part of the software
    system/platform interacts with another (for example, to ensure the login page
    calls the authentication service correctly).
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试通常测试软件系统/平台中一个部分与另一个部分之间的交互方式（例如，确保登录页面正确调用身份验证服务）。
- en: End-to-end tests are normally focused on the real-world use cases that an end
    user would initiate (for example, when logged in successfully, the welcome page
    is presented and the text displayed is in the correct language).
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端测试通常集中于最终用户会启动的实际用例（例如，当成功登录后，欢迎页面会显示，且显示的文本语言正确）。
- en: This is an overly simplistic view, but hopefully elucidates the different types
    of tests.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种过于简化的视角，但希望能阐明不同类型的测试。
- en: 'In terms of tooling and technologies you can use to create, maintain, and run
    automated tests, there are a vast number of different flavors and solutions available,
    and the selection that best fits your needs can be hard to make. At a basic level,
    these tools pretty much do the same thing: they orchestrate the running of test
    scripts and capture the results. The choice of test-automation tooling is something
    you should not rush into, and my recommendation would be to give this as much
    thought as you did selecting the development language you use.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 就工具和技术而言，用于创建、维护和运行自动化测试的选择有很多，不同的解决方案各有特点，选择最适合你需求的工具可能会很困难。从基本层面来看，这些工具基本上做的事情相同：它们协调测试脚本的运行并捕获结果。选择测试自动化工具是一个不应仓促做出的决定，我的建议是，像选择开发语言一样，给予这方面足够的思考。
- en: You will at times hear the word framework being used—especially when researching
    how to include unit tests. These are basically predefined approaches that are
    (mostly) industry standards. This means that the tools themselves may be different,
    but the standards they adhere to are similar.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你有时会听到“框架”这个词，特别是在研究如何加入单元测试时。它们基本上是预定义的（大多数是）行业标准方法。这意味着工具本身可能不同，但它们所遵循的标准是相似的。
- en: When choosing a tool, try to consider future-proofing in terms of the testing
    language used for creating and maintaining the tests themselves. Standardizing
    on something such as Cucumber would be a good start, and this is something quite
    a few tools all use. It helps should you wish to adopt a **TDD** and/or **BDD**
    approach for your integration and end-to-end testing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择工具时，尽量考虑未来可持续性，特别是用于创建和维护测试的测试语言。像Cucumber这样的标准化工具是一个不错的起点，而且这是许多工具都采用的方式。如果你希望采用**TDD**和/或**BDD**方法进行集成和端到端测试，这会非常有帮助。
- en: 'Ultimately, what you need is to work toward what is widely referred to as "inverting
    the testing triangle." In essence, traditional testing approaches mostly rely
    on manually-executed tests, with automated and unit tests being less prevalent.
    For your CD and DevOps adoption to be successful, you need to change the ratio
    and vastly reduce the reliance on manual testing and increase automation. There
    are many documented reasons for this, but in relation to CD and DevOps, the main
    advantages are speed, reliability, repeatability, and consistency:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你需要朝着广泛被称为“倒置测试三角形”的方向努力。本质上，传统的测试方法大多依赖于手动执行的测试，自动化和单元测试则较为少见。为了使CD和DevOps的采用成功，你需要改变这种比例，显著减少对手动测试的依赖，并增加自动化。关于这一点有很多文献支持，特别是在CD和DevOps方面，主要的优势是速度、可靠性、可重复性和一致性：
- en: '![](img/6822106b-3ec5-4820-801f-895bb104f62f.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6822106b-3ec5-4820-801f-895bb104f62f.png)'
- en: Inverted testing triangle
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 倒置的测试三角形
- en: One thing you may notice in relation to the **Agile** triangle compared to the
    **Traditional** triangle is the relative size of the **Unit Tests** layer. This
    is the ideal situation to be in, as the more unit tests you have checking the
    code and logic flows within the code, the greater confidence you will have in
    the underlying code. This in turn should build greater confidence in higher-level
    tests. One less obvious advantage is cost—it's far cheaper to write unit tests
    than it is to write integration and/or full end-to-end tests.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，与**传统**三角形相比，**敏捷**三角形中**单元测试**层的相对大小。这是理想的情况，因为你拥有的单元测试越多，能够检查代码和代码中的逻辑流程，你对底层代码的信心就会越大。反过来，这也应当能增强你对更高级别测试的信心。一个不那么显而易见的优势是成本——编写单元测试比编写集成和/或完整的端到端测试便宜得多。
- en: Agile software engineering approaches, such as TDD and **eXtreme Programming**
    (**XP**), follow the premise that unit tests are always written and must pass
    before you progress to the next level of testing.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 像TDD和**极限编程**（**XP**）这样的敏捷软件工程方法，遵循的前提是单元测试必须始终编写并通过，才能进入下一个测试阶段。
- en: 'Staying with automated testing, there is one thing that does add confusion
    and can put people off: the fact that adopting test-automation can be very daunting—
    and that''s putting it lightly. There are quite a few things to consider when
    you go down this route: How much of the codebase do you cover with tests? How
    do you replicate actual users and usage in the real world? Where do you start?'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 继续讨论自动化测试，有一件事确实会增加困惑，并且让人望而却步：采用测试自动化可能会让人感到非常令人畏惧——这还算轻描淡写。走这条路时有很多事情需要考虑：你需要覆盖多少代码库？如何在现实世界中模拟实际用户及其使用情况？你从哪里开始？
- en: Unfortunately, there are no straightforward or generic answers. This becomes
    more challenging when you start to look at the reams of online materials, books,
    and information regarding this very subject. To make matters worse, some of it
    will be contradictory to others. The only advice I can give is to follow the keep-it-simple
    (KISS) approach. For example, you may want to start by mapping out some of the
    primary and most-executed use cases (for example, login/authentication, users
    navigating from a list to an item detail in a shopping cart, or users making a
    purchase), and trial a couple of tools by creating automated tests to cover those.
    As long as you gain the ability to run the tests and the results are consistent,
    reliable, and repeatable, you should be on the right path.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有简单或通用的答案。当你开始查看关于这个话题的大量在线资料、书籍和信息时，这变得更加具有挑战性。更糟糕的是，其中的一些信息可能与其他的内容相互矛盾。我唯一能给出的建议是遵循简单至上的（KISS）方法。例如，你可以从绘制出一些主要且最常执行的用例开始（例如，登录/身份验证、用户从列表导航到购物车中的商品详情，或用户进行购买），并通过创建自动化测试来尝试一些工具以覆盖这些用例。只要你能够运行这些测试，并且结果是稳定、可靠和可重复的，那么你就应该走在正确的道路上。
- en: To use the KISS approach, even one automated test that validates some small
    part of the code base is better than nothing.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 KISS 方法，即使只有一个自动化测试验证了代码库的一小部分，也总比什么都没有要好。
- en: Once you have gained some confidence and trust in the overarching automated
    testing process, you can move onto the next use cases—or try another tool until
    you're happy.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对整体的自动化测试过程建立了一定的信心和信任，就可以进入下一个用例——或者尝试另一种工具，直到你感到满意为止。
- en: I would also recommend the KISS approach for coverage—if you can cover 100%
    of the code base and use cases, then that's the figure you should chose. If you
    can't, then find the figure that is viable and increase it as you go along. What
    I mean by this is do not let the % decrease as new code and features are added.
    It may help to set a milestone date and realistic percentage goal so that a sense
    of urgency/focus isn't lost along the way.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我还建议在覆盖率方面使用 KISS 方法——如果你可以覆盖 100% 的代码库和用例，那就选择这个数字。如果不能，那么找到一个可行的数字，并随着时间的推移增加它。我的意思是，当新增代码和功能时，不要让覆盖率百分比下降。设定一个里程碑日期和现实的百分比目标可能有助于保持紧迫感和专注力，避免在过程中丧失动力。
- en: There is another set of tools that can help with ascertaining your test coverage
    by inspecting/analyzing your codebase and source repository (which will, of course,
    include all of your automated tests) and providing useful information and dashboards
    for you to review. These can also give you a historical view so that you can measure
    increases (or decreases) in your coverage.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一组工具可以通过检查/分析你的代码库和源代码仓库（当然，这也包括你所有的自动化测试）来帮助你确定测试覆盖率，并提供有用的信息和仪表板供你查看。这些工具还可以为你提供历史视图，帮助你衡量覆盖率的增加（或减少）。
- en: 'Another place to apply the KISS approach in is something that normally trips
    people up when adopting test-automation: the gnarly subject of test data. Test
    data can be a massive issue, and it can cause more problems than it solves—and
    quite a few arguments to boot. A good rule of thumb here would be to have the
    test data you need to run your test(s) created as part of the automated process
    and—more importantly—removed as a final step. I''ve seen far too many examples
    of this KISS approach not being followed, which means you will end up with stale
    data that may well become out of date quite quickly. This stale data can cause
    tests that previously ran without issue to start failing or, worse still, other
    people come along and base their tests on this very same data (which means you
    can''t get rid of it even if you wanted to). It also compromises your ability
    to ensure your tests are consistent and repeatable.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以应用 KISS 方法的地方是自动化测试中通常会让人头痛的测试数据问题。测试数据可能是一个巨大的问题，且可能带来更多问题而不是解决问题——并且还可能引发相当多的争论。一个好的经验法则是，将运行测试所需的测试数据作为自动化流程的一部分来创建——更重要的是——在最后一步将其移除。我见过太多没有遵循这一
    KISS 方法的例子，这意味着你最终可能会得到过时的数据，这些数据很可能会很快变得不再适用。这些过时的数据可能导致以前运行正常的测试开始失败，或者更糟的是，其他人拿这些数据作为基础来编写他们的测试（这意味着即使你想清除它，也做不到）。它还会影响你确保测试一致性和可重复性的能力。
- en: 'Let''s see what our personas can do to help:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的角色可以做些什么来提供帮助：
- en: '| **Good approach** | **Not-so-good approach** |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **好方法** | **不太好的方法** |'
- en: '| Victoria (the Veep) should take an active interest in how test automation
    can vastly reduce overall cost and effectiveness of quality assurance and be willing
    to supply budget and executive sponsorship. | Victoria (the Veep) sees this as
    a head count / cost reduction solution and skimps on the budget to get the best
    deal rather than the best solutions which the team(s) need |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| Victoria（副总裁）应该积极关注测试自动化如何大大降低整体成本并提高质量保证的效果，并愿意提供预算和高层支持。 | Victoria（副总裁）将此视为一种裁员/降低成本的解决方案，并削减预算以获得最优惠的交易，而非团队所需的最佳解决方案。
    |'
- en: '| Stan (the manager) should ensure that relative importance is front and center
    with leadership, peer group and team(s) alike. He should also ensure the most
    relevant resources are assigned and aligned across the organization. | Stan (the
    manager) doesn''t bother to understand the advantages test automation brings -
    he sees this as post-development QA stuff and has no interest in it |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| Stan（经理）应该确保在领导层、同级团队及团队内部清楚地传达相对重要性。他还应该确保最相关的资源在组织内得到分配和协调。 | Stan（经理）不愿了解测试自动化带来的好处——他把这看作是开发后的质量保证工作，对此不感兴趣。
    |'
- en: '| Devina (the developer) and Oscar (the Ops guy) should spend time understanding,
    investigating and embracing test automation as a day to day activity that sits
    side by side with software development. | Devina (the developer) and Oscar (the
    Ops guy) ignore test automation as there''s already a team testing software once
    it''s built so what''s the point? |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| Devina（开发人员）和Oscar（运维人员）应该花时间理解、调查并接纳测试自动化，作为与软件开发并行的日常活动。 | Devina（开发人员）和Oscar（运维人员）忽视测试自动化，因为已经有团队在软件构建完成后进行测试，那这样做有什么意义呢？
    |'
- en: One thing we have not covered thus far is the tooling that can run, manage,
    and control this automation. That is where continuous integration solutions come
    into play.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们尚未讨论的是可以运行、管理和控制这些自动化的工具。这正是持续集成解决方案发挥作用的地方。
- en: Continuous integration
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: Continuous integration, or CI as it's more commonly known, is a tried-and-tested
    method of ensuring the software asset that is being developed builds correctly
    and plays nicely with the rest of the codebase. The keyword here is *continuous*,
    which, as the name implies, is as frequent as possible (ideally on each commit
    and/or merge to the source-control system). The simplest way to look at a CI solution
    is to think of it as a tool to orchestrate your build and test-automation tools—the
    two things we've just covered.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成，或更常见的CI，是一种经过验证的方法，用来确保正在开发的软件资产能够正确构建并与代码库中的其他部分良好协作。这里的关键词是*持续*，顾名思义，它是尽可能频繁的（理想情况下是在每次提交和/或合并到源代码控制系统时）。最简单的理解CI解决方案的方法是将其视为一个工具，用于协调构建和测试自动化工具——我们刚刚讨论的这两项内容。
- en: Yet again there are, as you may have guessed, a vast number of mature CI solutions
    available, both commercial and open source, so there are no excuses for not selecting
    one and using CI.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜测的那样，市面上有大量成熟的CI解决方案，既有商业版也有开源版，因此没有理由不选择一个并使用CI。
- en: As mentioned, CI solutions are a very basic-level, software solution that orchestrates
    the execution of your build and test-automation. The execution is controlled by
    what many refer to as *CI jobs*, which are invoked when certain events occur;
    for example, when code is committed to and/or merged to the source-control repository,
    or on a timed schedule, or when another automation tool triggers the CI, and so
    on. These jobs contain a list of activities (commonly referred to as *steps*)
    that need to be run in quick succession; for example, get the latest version of
    source from source-control, compile to an executable, deploy the binary to a test
    environment, get the automated tests from source-control, and run them.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，CI解决方案是一个非常基础的、协调构建和测试自动化执行的软件解决方案。执行是由许多人所称的*CI任务*控制的，当某些事件发生时，这些任务会被调用；例如，当代码提交并/或合并到源代码控制库时，或按定时计划执行，或当另一个自动化工具触发CI时，等等。这些任务包含一个活动列表（通常被称为*步骤*），需要快速连续地执行；例如，从源代码控制中获取最新的源代码，编译为可执行文件，将二进制文件部署到测试环境，获取源代码中的自动化测试，并运行它们。
- en: 'If all is well, the CI job completes and reports a success. If it fails, it
    reports this fact and provides detailed feedback as to why it failed. Most tools
    also let you drill down into the failing step and see what went wrong. Each time
    you run a given CI job, a complete audit trail is written for you to go back and
    compare results and/or trends over time, as shown:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，CI任务会完成并报告成功。如果失败，它会报告失败并提供详细的反馈，解释失败的原因。大多数工具还允许你深入查看失败的步骤，了解哪里出了问题。每次运行给定的CI任务时，都会为你写入完整的审计日志，你可以回顾并比较结果和/或随时间变化的趋势，如下所示：
- en: '![](img/e785ddf0-c97f-4ad9-b7a5-01331153ac00.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e785ddf0-c97f-4ad9-b7a5-01331153ac00.png)'
- en: A typical CI process
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的CI流程
- en: CI tools can be quite powerful, and you can build in simple logic to control
    the process. For example, if all of the automated tests pass, you can then automatically
    move the executable (which could have the build version number baked in) to your
    binary repository, or if something fails, you could email the results to the engineering
    team. You can even build dashboards or information radiators so provide an instant
    and easy-to-understand visual representation of what's happening, and the results.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: CI工具非常强大，你可以构建简单的逻辑来控制流程。例如，如果所有自动化测试都通过，你可以自动将可执行文件（可能已嵌入构建版本号）移至二进制仓库，或者如果某个环节失败，你可以将结果通过邮件发送给工程团队。你甚至可以构建仪表板或信息显示器，以便提供即时、易于理解的可视化表示，展示当前的情况和结果。
- en: CI solutions are a must for CD. If you are building and testing your software
    changes on a frequent basis, you can ship frequently.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: CI解决方案是CD的必备工具。如果你频繁地构建和测试软件变更，你就能频繁发布。
- en: The advantages of CI for traditional systems-operations changes are not as obvious,
    but they can help a great deal in terms of trying out changes without impacting
    the production platform. For example, let's presume that you have a CI solution
    that is running many overnight automated tests against an isolated test environment.
    The tests have been successfully passing (more commonly referred to as green)
    for a few days, so you are confident that everything is as it should be. You then
    make a server configuration change and re-run the CI suite, which then fails.
    The only change has been the server configuration; therefore, it must have had
    an adverse impact. This is a good example of the DevOps approach being applied.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: CI对传统系统操作变更的优势并不那么显而易见，但它们在尝试更改而不影响生产平台方面可以提供很大帮助。例如，假设你有一个CI解决方案，正在对一个隔离的测试环境运行多个自动化夜间测试。这些测试已经成功通过（通常称为绿色）好几天了，所以你有信心一切正常。然后，你对服务器配置进行了更改并重新运行CI套件，结果失败了。唯一的变化是服务器配置，因此它一定产生了不利影响。这是DevOps方法应用的一个很好的例子。
- en: Implementing CI is no small feat—especially if you have nothing in terms of
    automation to start with. However, CI is a very powerful tool and vastly reduces
    that overhead and risk of using manual methods for building and testing system
    changes. For all intents and purposes, trying to implement CD without CI is going
    to be a very hard slog, and therefore my recommendation would be to bite the bullet
    and implement CI.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 实施CI并非易事——尤其是当你没有任何自动化工具可用时。然而，CI是一个非常强大的工具，能大大减少使用手动方法进行系统更改构建和测试的开销与风险。就实际情况而言，如果没有CI，尝试实现CD将是一个非常艰难的过程，因此我的建议是咬紧牙关，实施CI。
- en: Throughout this section, we have been talking about how to automate builds and
    tests to ensure the software can be validated and delivered. We also refer to
    results that, overall, should be positive—the automated build has to have completed
    and the automated tests need to have passed before they can progress to the next
    stage. In other words, if tests fail, that's a bad thing. On the whole, that is
    correct. However, failure can be a good thing, as long as the failures are found
    early in the process.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们一直在讨论如何自动化构建和测试，以确保软件可以被验证和交付。我们还提到了一些结果，整体来说应该是积极的——自动化构建必须完成，自动化测试需要通过，才能进入下一阶段。换句话说，如果测试失败，那就不好了。总体上，这是正确的。然而，失败也可以是好事，只要这些失败是在流程的早期发现的。
- en: Fail fast and often
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速失败并频繁失败
- en: Failing fast and often may seem counter-intuitive, but it's a very good ethos
    to work to. If a defect is created but it is not spotted until it has gone live,
    the cost of rectifying said defect is high (it could be a completely new release),
    not to mention the impact it could have on your customers, reputation, and possibly
    your revenue. Finding defects early on is a must.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 快速且频繁地失败可能看起来反直觉，但这是一个非常好的工作理念。如果一个缺陷被引入，但直到它已经上线后才被发现，修复这个缺陷的成本是很高的（可能需要完全新的发布版本），更不用说它可能对您的客户、声誉和可能的收入产生的影响了。尽早发现缺陷是必须的。
- en: Agile engineering approaches such as **TDD** or **BDD** are based upon the principle
    of finding and catering for faults within software very early on in the process,
    the simple premise being that before code-development begins, tests are written
    to cover some/all of the use cases the software has to cater to—the proportion
    is normally referred to as coverage. As the code is being written, these tests
    can be run again and again as part of the CI process to spot gaps. If the test
    cases fail at this point, this is a good thing, as the only person impacted is
    the software engineer writing the code, rather than your customers.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷工程方法如**TDD**或**BDD**基于在软件开发过程的早期阶段找到和解决软件中的故障的原则，其简单前提是在编码开始之前编写测试来覆盖软件需要满足的某些/所有用例——这个比例通常称为覆盖率。随着代码的编写，这些测试可以作为持续集成过程的一部分反复运行，以发现漏洞。如果在此时测试用例失败，这是件好事，因为唯一受到影响的是编写代码的软件工程师，而不是您的客户。
- en: This may sound strange—especially for the managers out there—but if defects
    are found early on, you should not make a big thing of it and you should not chastise
    people. Think back to what we learned about blame versus learning behaviors. What
    you want is to find the problem, figure out why it happened, fix it, learn from
    it, and move on.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能有些奇怪，特别是对于管理者来说，但如果早期发现缺陷，您不应大惊小怪，也不应责备人员。回想一下我们对责备与学习行为的理解。您想要的是找到问题，弄清原因，修复它，从中学习，然后继续前进。
- en: One of the things that can sometimes scupper implementing engineering practices
    such as TDD is the size and complexity of the software platform itself. It may
    be a very daunting task to retrospectively implement a test suite for a software
    system that was not built around these principles. If this is the case, it may
    be wise to start small and build up.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会妨碍实施TDD等工程实践的事情之一是软件平台本身的规模和复杂性。为不围绕这些原则构建的软件系统回顾性地实施测试套件可能是一项非常艰巨的任务。如果是这种情况，从小处着手逐步构建可能是明智的选择。
- en: We'll now move away from software building and test-automation and onto the
    challenges you will face when adopting CD and DevOps in relation to how your software
    system/platform is designed and architected.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将远离软件构建和测试自动化，转向在采用持续交付（CD）和DevOps时可能遇到的挑战，特别是与软件系统/平台的设计和架构相关的挑战。
- en: Architectural approaches
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构方法
- en: The majority of businesses—despite what the tech press and jeans-and-t-shirt
    conference speakers would have you believe—are not running modern software architecture.
    The reality is that a vast number of software platforms and systems in the world
    on which we are reliant have evolved over many years, and some (most) are rather
    complex and cumbersome to maintain or advance. Even the young and hipster tech
    sector companies are running and maintaining what would be classed as *legacy*
    solutions and platforms that comprise a small number of large executables all
    built and tested together before getting delivered. That isn't to say CD and DevOps
    principles aren't being used or can't be adopted; it just means that it takes
    a little more work.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管科技界媒体和穿着牛仔裤T恤的会议演讲者让您相信大多数企业都在运行现代软件架构，但事实并非如此。实际情况是，世界上大量的软件平台和系统经过多年发展，其中一些（多数）相当复杂和笨重，难以维护或推进。即使是年轻和时尚的科技公司也在运行和维护被视为*遗留*解决方案和平台的少量大型可执行文件，这些文件都是在构建和测试后一起交付的。这并不意味着不能使用或采用CD和DevOps原则，只是意味着需要更多的工作。
- en: The immediate reaction may well be to spend vast amounts of time, effort, and
    money transforming your entire software platform to a new reference architecture
    model that will allow for seamless adoption of CD and DevOps. If you're lucky
    enough to have senior leadership who have fully bought into this and have deep
    pockets, then good luck. Most of us are not that lucky, and therefore need to
    be creative in our approach.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 立即反应可能是花费大量时间、精力和金钱将整个软件平台转型为一个新的参考架构模型，以实现CD和DevOps的无缝接入。如果你足够幸运，拥有深谙此道的高层领导并且他们有充足的资金，那么祝你好运。大多数人并不这么幸运，因此我们需要在方法上更加富有创造性。
- en: Something that is also a little daunting, if you were to research the best breed
    of reference architecture, is that you will find that there are many views (often
    differing) on what's the best approach. Not to mention the many and varied ways
    one would go about adopting and implementing said architecture. If you're lucky
    enough to have a high-flying visionary who knows instinctively what to do, you
    are off to a great start. In reality, what you will end up with is a target architecture
    and a plan to get there through what's referred to as legacy strangulation—that
    being an approach to systematically replace parts of the legacy platform with
    software components designed and built using a more modern approach and focused
    on particular functional (and non-functional) areas.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要研究最佳的参考架构种类，这可能会让人感到有些望而生畏，因为你会发现关于什么是最佳方法存在许多不同的看法（往往各不相同）。更不用说，采用和实施该架构的方式有很多且各异。如果你足够幸运，拥有一位高瞻远瞩的愿景者，他能凭直觉知道该怎么做，那么你就已经有了一个好的开端。实际上，最终你得到的将是一个目标架构，以及通过所谓的遗留系统“勒索”来实现这一目标的计划——这是一种系统性地用更现代的方法设计和构建的软件组件替换遗留平台部分的方式，重点是特定的功能（以及非功能）领域。
- en: Although legacy solutions are a pain, they are not the end of the world when
    it comes to CD and DevOps adoption. Take into account the limitations that come
    from having to build, test, and ship the entire platform each time changes are
    made, and also the overall duration for this to complete, which can be many minutes
    (sometime hours) depending on the size and complexity of the platform itself.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管遗留解决方案是个痛点，但在CD和DevOps的采用过程中，它们并不是世界末日。需要考虑的限制因素包括每次进行更改时，必须构建、测试和部署整个平台的需求，以及完成这一过程的整体时间，这可能需要几分钟（有时是几个小时），具体取决于平台本身的规模和复杂性。
- en: This is where creativity comes into play. Let's assume that your *legacy* platform
    takes 30 minutes to build and another 90 mins for the automated test suite to
    complete. That's two hours to wait for *each* change you make and want to test.
    Scale that out to the number of engineers making changes. And that's what can
    only be described as unworkable. Most will overcome this by only triggering the
    CI job at certain times—for example, at the end of the working day—so that the
    time taken doesn't leach into the working day. This does help in some ways, but
    also adds the risk that an entire build could fail due to one simple mistake,
    defect, or typo, and then hold up all the other changes and engineers who want
    to move onto their next task.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这时创造力就派上用场了。假设你的*遗留*平台构建需要30分钟，而自动化测试套件的完成需要90分钟。每进行一次更改并希望测试，就需要等待两小时。将这一时间扩展到所有做更改的工程师身上，这简直无法承受。大多数人会通过只在特定时间触发CI作业来克服这个问题——例如在工作日结束时——这样时间就不会延续到工作日中。这确实在某些方面有所帮助，但也增加了一个风险，那就是整个构建可能由于一个简单的错误、缺陷或拼写错误而失败，从而阻碍其他所有更改和工程师继续下一个任务。
- en: 'You could overcome this by looking at some small tweaks to the process to make
    things (a little more) workable. For example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过对流程进行一些小的调整来克服这一问题，使其变得（稍微更）可行。例如：
- en: Split the testing suite into smaller, discrete test packs; for example, use
    a subset of the tests to run when the build completes (sometimes referred to as
    a smoke test) and a full set overnight
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将测试套件拆分成更小、更独立的测试包；例如，在构建完成时使用一部分测试（有时称为烟雾测试），并且在晚上进行完整的测试。
- en: Add more horsepower to your build and/or automated test servers
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的构建和/或自动化测试服务器增加更多的计算能力。
- en: Implement a clustered CI solution
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个集群化的CI解决方案。
- en: Parallelize the CI jobs (you'll need the additional horsepower/clustering)
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将CI作业并行化（你需要更多的计算能力/集群化）。
- en: Alter the way the software is built so that only changes that have changed since
    the last build are built again (that is, only build deltas rather the entire platform
    every time)
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变软件构建方式，使得只有自上次构建以来有变化的部分才会重新构建（也就是说，每次只构建增量，而不是整个平台）
- en: Ultimately, you want to reduce the time taken to build, test, and ship your
    legacy software. The more you can achieve in this area, the more time you can
    buy yourself while you look at breaking down the legacy platform into smaller
    independent software components that can be independently built, tested, and shipped.
    Even the most integrated and closely-coupled software platform is made up of many
    small components all talking to each other.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你希望减少构建、测试和发布遗留软件所花费的时间。你在这方面取得的进展越多，就能为自己争取更多时间，去将遗留平台拆解成更小的、可以独立构建、测试和发布的软件组件。即使是最集成、最紧密耦合的软件平台，也由许多小组件组成，它们之间相互通信。
- en: If you take a step back and look at your legacy platform, you'll probably find
    you could actually split it (or at least most of it) into small, manageable chunks
    (shared libraries, different layers of technology, packaging solutions, and so
    on) that can be built and tested independently and quickly, and, more importantly,
    can be delivered frequently.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你退后一步，回顾一下你的遗留平台，你可能会发现实际上你可以将它（或至少大部分部分）拆分成小而易于管理的模块（共享库、不同技术层、打包解决方案等），这些模块可以独立并快速地构建和测试，更重要的是，它们可以频繁地发布。
- en: Component-based architecture
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于组件的架构
- en: As previously mentioned, if you are lucky enough to have the opportunity to
    re-engineer your *legacy* platform—as did ACME systems—then you should take time
    to consider the best approach for your needs. Ideally, you should look at a technology
    or an architectural approach that allows the platform to be broken down into small,
    discrete modules or components that are loosely coupled. By this I mean that each
    component can be developed, built, tested, and shipped independently of all other
    components.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果你有幸能够重新设计你的*遗留*平台——就像ACME系统那样——那么你应该花时间考虑最适合你需求的方法。理想情况下，你应该选择一种技术或架构方法，允许将平台拆解成小而独立的模块或组件，并且这些组件之间是松耦合的。我的意思是，每个组件都可以独立开发、构建、测试和发布，而不依赖其他组件。
- en: 'This approach has had many names over the years—web services architecture,
    **Service Orientated Architecture** (**SOA**), or micro services architecture—but
    at a basic level they are pretty much the same thing: an architectural approach
    that allows loosely-coupled software components that are self-contained and coexist
    to provide functionality that would normally have been delivered as a complete
    monolithic platform shown as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法多年来有许多名称——如Web服务架构、**面向服务架构**（**SOA**）或微服务架构——但从基本层面来看，它们几乎是相同的：一种架构方法，允许松耦合的、自包含的软件组件共同工作，提供通常会作为完整单体平台交付的功能，示例如下：
- en: '![](img/bad8ee9d-8636-4d4c-965b-18075b0bd0c7.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bad8ee9d-8636-4d4c-965b-18075b0bd0c7.png)'
- en: A typical architectural comparison
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的架构比较
- en: By going down this route, you have the advantage of small, discreet software
    components that can be developed and tested, and, more importantly, released independently.
    This goes a long way to realizing the benefits of CD.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，你将拥有小而独立的软件组件，它们可以被开发、测试，且更重要的是，可以独立发布。这大大有助于实现持续交付（CD）的好处。
- en: Another advantage of this approach not directly attributable to CD or DevOps
    is cost saving. Not only does a component-based architecture allow for small and
    frequent changes to be released, it can also remove the need for large and costly
    IT infrastructure. For example, if you currently have one or two huge bits of
    code, you will have to have one or two hulking servers to run them. You then have
    one or two hulking DB servers and—to allow for Disaster Recovery—you'll have another
    set sitting and waiting. Just think how much that costs to acquire and keep running.
    With many small components, you can consider more cost-effective hosting approaches—something
    we'll look at later on.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的另一个优势是节省成本，这与持续交付（CD）或DevOps并没有直接关系。基于组件的架构不仅允许频繁的小规模变更发布，还可以减少对大型昂贵IT基础设施的需求。例如，如果你现在有一两块庞大的代码，你就需要一两台巨大的服务器来运行它们。然后你还需要一两台庞大的数据库服务器——为了实现灾难恢复，你还得有另一套服务器在等待。想一下，要获得并维持这些服务器运行的成本有多高。使用许多小组件，你可以考虑更具成本效益的托管方式——我们稍后将讨论这个问题。
- en: There is a mountain of options and information available to determine the best
    approach for your current and future needs. Suffice to say, if you can move toward
    a component-based architecture, the pain and overhead of releasing will be a thing
    of the past.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有大量的选项和信息可以帮助确定最适合您当前和未来需求的方法。可以这么说，如果您能够朝着基于组件的架构迈进，发布时的痛苦和开销将成为过去。
- en: One important thing to note here, should you adopt a component-based architecture
    (which you should do, by the way, just in case it wasn't clear), is how you release
    the components. There may be a temptation to use the same *clump it all into one
    big release* approach as used for the legacy platform, but that will simply lead
    to a world of pain and give you no advantage whatsoever. We'll be looking at CD
    tooling later, so please keep reading.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要注意的一点是，如果您采用基于组件的架构（顺便说一下，您应该这么做，万一不够清楚的话），如何发布这些组件。可能会有诱惑使用与遗留平台相同的*将所有内容合并为一个大版本*的方法，但这将只会导致一堆痛苦，并且根本不会给您带来任何优势。稍后我们会讨论持续交付工具，因此请继续阅读。
- en: Let's have a look at another possible solution that may help with legacy strangulation
    and ease you toward the component-based architecture utopia.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下另一个可能的解决方案，它可以帮助解决遗留系统的限制问题，并使您更容易向基于组件的架构理想迈进。
- en: Layers of abstraction
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象层
- en: If you have quite complex dependencies throughout your platform, it may help
    to try and separate your software assets by using some form of abstraction. This
    technique should assist in removing, or at least reducing, hard dependencies within
    your platform, and will help move you toward a component-based architecture which,
    in turn, will give you the opportunity to adopt CD.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的平台中有复杂的依赖关系，尝试通过使用某种形式的抽象来分离软件资产可能会有所帮助。这个技术应该有助于去除，或者至少减少平台内的硬依赖，并帮助您朝着基于组件的架构迈进，进而为您提供采用持续交付（CD）的机会。
- en: Let's say, for example, you have two software components that have to be deployed
    together, as they have been hardwired in such a way that deploying one without
    the other would cause a platform outage. Then you're going to struggle to follow
    the *small incremental changes* method—not to mention the fact that you will be
    hard-pressed to release without downtime.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设您有两个必须一起部署的软件组件，因为它们被硬性耦合在一起，无法单独部署，否则会导致平台停机。那么您将很难遵循*小幅增量变更*的方法，更不用说您将很难做到在不出现停机的情况下发布了。
- en: There are plenty of mature and proven design patterns available that can give
    some good ways of achieving this, but at the very least, it is a good practice
    to remove close dependencies wherever possible so that you don't end up with clumps
    of assets that need to be deployed together.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多成熟且经过验证的设计模式可以为实现这一目标提供一些不错的方法，但至少，移除尽可能多的紧密依赖是一个好的实践，这样您就不会最终拥有一堆需要一起部署的资产。
- en: 'One common area for close coupling is between software and databases. This
    means that a change to one may mean both need to be tested and shipped. Adding
    abstraction here could be as complex as adding a data-access layer proxy between
    the two, or as simple as using SQL views. Another problem area is UI and business
    logic code being bundled together, which again can be separated out by following
    a standard design pattern. Whatever the approach, the goal is the same: to be
    able to build, test, and ship software components independently.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的紧耦合领域是软件和数据库之间。这意味着对其中一个的更改可能意味着两者都需要进行测试和发布。在这里添加抽象可能和在两者之间添加数据访问层代理一样复杂，或者像使用
    SQL 视图一样简单。另一个问题区域是 UI 和业务逻辑代码捆绑在一起，这同样可以通过遵循标准设计模式来分离。无论采用何种方法，目标都是一样的：能够独立构建、测试和发布软件组件。
- en: Just to add to your homework, you should spend some time looking at and analyzing
    areas of the existing platform to find components that are closely coupled, and
    then see how you can add an abstraction layer to allow each to be worked on without
    impacting the other. You could also look at fast-moving versus slow-moving areas
    (for example, which software components are updated on a regular basis and which
    very rarely), as this may help you to pinpoint which components to separate first.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的作业，您应该花些时间查看并分析现有平台中的区域，找出那些紧密耦合的组件，然后看看如何添加抽象层，使得每个组件都可以独立工作而不影响其他组件。您还可以查看快速变化和缓慢变化的区域（例如，哪些软件组件是定期更新的，哪些非常少更新），因为这可能帮助您找出哪些组件需要首先分离。
- en: Never break your consumer
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 永远不要破坏您的消费者
- en: Your software platform will probably be complex and have quite a few dependencies—this
    is nothing to be ashamed of, and is quite normal. These dependencies can be classified
    as relationships between consumers and providers. The providers can be anything
    from shared libraries or core code modules to a database. The consumers will call/execute/send
    requests to the providers in a specific way as per some predefined interface spec
    (sometimes called a service contract).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你的软件平台可能会很复杂，并且有相当多的依赖关系——这并不丢人，实际上这是非常正常的。这些依赖关系可以被分类为消费者和提供者之间的关系。提供者可以是任何东西，从共享库或核心代码模块到数据库。消费者将根据某些预定义的接口规范（有时称为服务合同）以特定方式调用/执行/发送请求给提供者。
- en: A simple example would be a web page that utilizes a shared library to return
    content to render and display a user's address details. In this scenario, the
    web page is the consumer and the shared library is the provider. If the shared
    library originally returned four pieces of data but was changed to provide three,
    the consumer may not know how to handle this and may throw an error or, worse
    still, simply crash. You could, of course, add some defensive code, but in reality,
    this is just adding more complexity due to lazy change-management.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子是，网页利用共享库返回内容来渲染和显示用户的地址信息。在这种情况下，网页是消费者，共享库是提供者。如果共享库最初返回了四个数据项，但被更改为只提供三个，消费者可能不知道如何处理这种情况，可能会抛出错误，甚至更糟糕的是，直接崩溃。当然，你可以添加一些防御性代码，但实际上，这只是由于懒惰的变更管理而增加了更多复杂性。
- en: Most software platforms have many dependencies, which means it is sometimes
    very difficult to spot which *provider* has changed and is causing one of the
    many consumers to fail—especially when you consider that a consumer may also be
    a provider to another consumer higher up the stack (that is, a shared library,
    which consumes from a database and then *provides* said data to a web page, which
    then consumes it and provides that data to a JavaScript client, and so on).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数软件平台都有许多依赖关系，这意味着有时很难发现是哪个*提供者*发生了变化，导致众多消费者中的一个失败——特别是当你考虑到一个消费者也可能是另一个位于堆栈上游的消费者的提供者时（也就是说，一个共享库，它从数据库中获取数据，然后*提供*这些数据给网页，网页再消费这些数据，并将其提供给JavaScript客户端，等等）。
- en: To understand how prevalent this situation is, you'll need to do some impact
    analysis that will help you map this out. Be forewarned that unless you can map
    out your entire platform into one easy-to-understand format that is consistently
    up to date, it's going to be a difficult task. Luckily, there are many mature
    and established patterns that cover these sorts of problems, as well as tools
    that will help with the analysis.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这种情况有多普遍，你需要进行一些影响分析，帮助你将其映射出来。提前提醒，除非你能够将整个平台映射成一个易于理解且始终保持最新的格式，否则这将是一项艰巨的任务。幸运的是，有许多成熟且已建立的模式可以解决这些问题，还有一些工具可以帮助进行分析。
- en: What can also help is to establish some rules around how changes are approached
    going forward. In simple terms, if you are making a change to software, config,
    or a database which will be consumed by another part of the platform, it's the
    responsibility of the person making the change to validate that the change has
    not broken anything up/downstream. If you have CI and test-automation in place,
    then that can help spot issues early. However, simply adding some diligence to
    the code-review/pull-request process is cheap and easy, and can help cement good
    behaviors.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，有助于做的是建立一些规则，来规范如何处理未来的更改。简单来说，如果你正在更改软件、配置或数据库，而这些更改将被平台的其他部分消费，那么做出更改的人有责任验证该更改没有破坏任何上游或下游的内容。如果你已经建立了CI和自动化测试，那有助于尽早发现问题。然而，简单地在代码审查/拉取请求过程中增加一些谨慎态度既便宜又容易，而且有助于巩固良好的行为。
- en: Within the system operations area, the "never break your consumer" rule should
    also apply. For example, the software platform could be classed as a consumer
    of the server operating system (the provider); therefore, if you change or upgrade
    the operating system, you must ensure that there are no breaking changes that
    will cause the consumer to fail.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统操作领域，“永远不要破坏你的消费者”规则也应该适用。例如，软件平台可以被视为服务器操作系统（提供者）的消费者；因此，如果你更改或升级操作系统，必须确保没有任何破坏性更改会导致消费者失败。
- en: Sometimes breaking changes cannot be avoided (for example, the service contract
    between components has to change to accommodate new functionality). However, this
    should be the exception rather than the rule, and you should have a strategy planned
    to cater for this. An example strategy would be to accommodate side-by-side versioning,
    which will allow you to run more than one version of a software asset at the same
    time—something we'll cover later.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，破坏性更改是无法避免的（例如，组件之间的服务契约必须发生变化，以容纳新的功能）。然而，这应该是例外而非常规，并且你应该提前规划好应对这种情况的策略。一个示例策略是支持并行版本管理，这将允许你同时运行多个版本的软件资产——这一点我们稍后会讲到。
- en: There may be times when the consumer/provider relationship fails as the person
    or team working on the provider is unaware of the relationship. This can be very
    true of providers within the system operations area. To overcome this, or at least
    minimize the risk, use open and honest peer-working practices.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者/提供者关系可能会失败，原因是负责提供者的一方人员或团队没有意识到这种关系。对于系统运维领域中的提供者来说，这一点尤为真实。为了克服这个问题，或者至少尽量减少风险，使用开放和诚实的同行合作实践。
- en: Open and honest peer-working practices
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开放和诚实的同行合作实践
- en: There are many different agile software-delivery methodologies in use today,
    but all of them revolve around some form of highly-collaborative ways of working
    and free-flowing communication. Agile approaches such as **XP**, pairing, or a
    simple code-review process, all depend on engineers working closely together.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 今天有许多不同的敏捷软件交付方法论，但它们都围绕着某种形式的高度协作的工作方式和自由流动的沟通展开。像**XP**、配对编程或简单的代码审查过程等敏捷方法，都依赖于工程师们紧密合作。
- en: I cannot stress enough the importance of sharing your work with others. Even
    the best software engineers (or system admins) on the planet are human and they
    **will** make mistakes. If you think your code is precious and don't want to share
    it with anyone else, you **will** create defects and it **will** take longer to
    overcome small mistakes, which can cause hours of head-scratching, or worse, have
    an adverse impact on your customers.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我不能过分强调与他人分享你工作的必要性。即使是地球上最优秀的软件工程师（或系统管理员）也是人，他们**会**犯错。如果你认为自己的代码是珍贵的，不想与其他人分享，那么你**会**制造缺陷，并且**会**花费更长的时间来解决小错误，这可能会导致几个小时的困惑，或者更糟糕的是，对你的客户产生不利影响。
- en: If you are confident that your code is of the highest quality and can stand
    up to scrutiny, then do not hide it away—put your money where your mouth is and
    share your work. If you are not that confident, sharing with your peer group will
    help to build that confidence. One thing to point out here—in terms of software
    engineers—is that the peer group should not be exclusively made up of other software
    engineers; the operations team can (and should) also be included in this process.
    It may seem strange, as they may not be able to actually read your code (although
    you may be surprised how many system admins can read code), but they know how
    the live platform operates and may be able to provide some valuable input and/or
    ask some pertinent questions (for example, what the code will do if there's a
    network blip, how long-lived threads will be, or why connection-polling isn't
    being used). This also encourages the DevOps mindset and approach. The same rule
    should apply to changes made by the Ops team.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对自己的代码质量非常自信，并且能经得起推敲，那么就不要把它藏起来——说到做到，分享你的工作。如果你没有那么有信心，与同行分享将帮助你建立这种信心。有一点需要指出——就软件工程师而言——同行小组不应该仅仅由其他软件工程师组成；运维团队也可以（并且应该）参与到这个过程中来。看起来可能有些奇怪，因为他们可能无法真正阅读你的代码（虽然你可能会惊讶于有多少系统管理员能够读懂代码），但是他们了解在线平台是如何运行的，可能会提供一些有价值的意见和/或提出一些相关问题（例如，代码在网络中断时会做什么，长期运行的线程会如何，或者为什么不使用连接轮询）。这也有助于推动DevOps的思维模式和方法。对于运维团队所做的更改，同样的规则也应该适用。
- en: 'All things considered, the majority of the world''s highest-quality software
    is built in a highly-collaborative way, so there are no excuses for you not to
    be doing the same. Some purists may scoff at this approach, but consider this:
    most of these types will most probably sing the praises of Linux-based operating
    systems, which, if they actually thought about it, is, like most open source software,
    written using highly-collaborative approaches that have been part of the development
    process from day one.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 综合考虑，世界上大多数高质量的软件都是通过高度协作的方式构建的，因此你没有理由不采取相同的方法。尽管一些极端主义者可能会嘲笑这种做法，但请考虑这一点：这些人很可能会称赞基于Linux的操作系统，而如果他们仔细想一想，实际上，像大多数开源软件一样，它们也是通过高度协作的方式开发的，从一开始，协作就已是开发过程的一部分。
- en: Having an open, honest, and transparent peer-review process is as important
    within an Operations team as it is within a Development team. Changes made to
    any part of the platform run a risk, and having more than one pair of eyes to
    review will help reduce this risk. As with software code, there is no reason not
    to share system configuration changes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在运营团队中，与开发团队一样，拥有一个开放、诚实、透明的同行评审过程同样重要。对平台的任何部分进行更改都伴随着风险，而让不止一双眼睛来进行审查有助于降低这种风险。就像软件代码一样，系统配置更改也没有理由不进行共享。
- en: One normally unforeseen advantage of working in this way is the fact that if
    your code (or configuration change) fails to get through peer review, the impact
    on the production system is negated. It's all about failing fast rather than waiting
    to put out something live to find it fails.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一种通常被忽视的好处是，如果你的代码（或配置更改）未能通过同行评审，对生产系统的影响就会被消除。关键在于快速失败，而不是等到发布到生产环境才发现它失败。
- en: Let's assume you have seen the light and have decided to move to a loosely-coupled
    component-based architecture that has been written using best practices and you're
    ready to move to the next stage in your software engineering evolution.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经意识到这一点，并决定转向一个松耦合的基于组件的架构，该架构是采用最佳实践编写的，现在你准备迈向软件工程演进的下一阶段。
- en: 'Now you have everyone working together and playing nicely, we''ll move on to
    the next challenge: how the expectations of the wider business need to be realigned
    in terms of release and feature delivery.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在大家都在一起合作愉快，我们将进入下一个挑战：如何重新调整更广泛业务方面的期望，特别是在发布和功能交付方面。
- en: Incremental delivery of features
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能的增量交付
- en: Earlier, we looked at breaking work down into small incremental chunks so that
    you can deliver and release quickly. You also need to consider how you deal with
    features. What I'm referring to here is the business-driven deliverables that
    turn into revenue. Typically, you'll have a year-long business plan that is represented
    by a number of key initiatives that need to be delivered within that year, and
    these are further broken down into a selection of features, which is what will
    be marketed and sold to customers. This is pretty normal in terms of business
    process.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们讨论了将工作分解成小的增量块，以便能够快速交付和发布。你还需要考虑如何处理功能。这里我指的是那些以商业驱动的交付物，它们最终转化为收入。通常，你会有一个为期一年的商业计划，这个计划由若干个关键举措组成，需要在这一年内完成，而这些举措又进一步细化为一些功能，这些功能最终将被营销并卖给客户。从业务流程的角度来看，这是非常正常的。
- en: Please note that terms used within your business may differ and you may use
    terms such as epics, or themes, or goals, or MVP. In essence, we'll focus on the
    relationship between delivering a thing your business can make money from and
    the point in time when that thing becomes available to customers. To keep things
    simple, I'll refer to the thing as a feature and the point in time as a release.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你们公司内部使用的术语可能会有所不同，可能会使用如史诗（epics）、主题（themes）、目标（goals）或最小可行产品（MVP）等术语。实质上，我们将重点讨论的是：将一个能够为企业带来收益的东西交付给客户的时机。为了简化起见，我将这个东西称作“功能”，而交付给客户的时机称作“发布”。
- en: 'How the adoption of CD and DevOps can impact this does depend on the current
    release cadence, but I would hazard a guess that you''ll be looking at a cadence
    in months or quarters. Once CD and DevOps are embedded, you''ll be looking at
    weeks, days, or hours between each release. This can only be a good thing, but
    let''s take a moment to consider the wider impact:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付（CD）和DevOps的采用如何影响这一点，确实取决于当前的发布节奏，但我敢猜测，你会看到一个以月或季度为单位的节奏。一旦CD和DevOps嵌入到流程中，你将会看到每次发布之间的间隔从几周、几天甚至几小时。这无疑是好事，但我们还是花点时间考虑一下更广泛的影响：
- en: The wider business would currently be expecting a feature to be delivered in
    its entirety within a release cycle
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更广泛的业务部门目前可能期望在每个发布周期内完整交付一个功能
- en: Business functions, such as sales, marketing, legal, and support, will have
    processes in place to cater for this
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销售、营销、法律和支持等业务职能将会有相应的流程来应对这一情况
- en: You will be vastly reducing the release cycle and incrementally delivering changes
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将大幅度缩短发布周期，并逐步交付变更
- en: How should the wider business cater for this? When will the feature be ready?
    When should they start the wheels turning? What should they say to customers?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 更广泛的业务部门该如何应对这一变化？功能什么时候可以准备好？他们应该何时开始行动？他们该如何告诉客户？
- en: 'What you need to do is work with these business areas and come to an agreement
    in terms of how features can be incrementally delivered over a number of releases.
    There are a few approaches you should consider and discuss:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要与这些业务领域合作，并就如何在多个发布周期中逐步交付功能达成一致。你应该考虑并讨论以下几种方法：
- en: Deliver the end-to-end experience in slices and build up the richness of the
    functionality over a number of releases until the feature is complete
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分阶段交付端到端体验，并在多个发布周期中逐步丰富功能，直到功能完成
- en: Focus on an area of functionality through to completion, then move onto to the
    next, then the next, until the feature is complete
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于某一功能领域直到完成，然后再转向下一个，依此类推，直到功能完成
- en: Incrementally build the feature over a number of releases but keep it hidden
    until it's completed
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个发布周期中逐步构建功能，但在完成之前保持其隐藏
- en: Something to consider is approaches such as the first and second could open
    up avenues such as alpha/beta releases, which means that you start to get customer
    feedback early on, whereas approaches such as the last one mean you don't get
    early feedback but the go-live is relatively painless (you've already shipped
    the code so go-live is really switch-it-on). Whatever approach you choose—and
    you will need to choose one—you need to ensure that those expecting "release equals
    feature delivery" are educated and their expectations are realigned.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 值得考虑的是，像第一种和第二种方法可能会开启像alpha/beta版本发布这样的途径，这意味着你可以提前获得客户反馈；而像最后一种方法则意味着你无法提前获取反馈，但上线过程相对简单（因为你已经发布了代码，上线实际上就是“打开”）。无论你选择哪种方法——你必须选择一种——你都需要确保那些期望“发布等于功能交付”的人得到教育，并调整他们的期望。
- en: 'We''ll now move back into a more technical area: ensuring you are deploying
    the same software throughout your environments.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将回到一个更技术性的领域：确保在所有环境中部署相同的软件
- en: Using the same binary across all environments
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在所有环境中使用相同的二进制文件
- en: Before a software asset can be used in a given environment, it has to have been
    built/compiled into an executable or a binary. This binary is important, as it
    is the version of the software that will be executed at runtime within your environments.
    Think of it as a snapshot in time. Some would say that the source code is more
    important than the binary object itself as the binary is simply a byproduct and
    can be recreated time and time again, although that's not strictly true.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件资产可以在给定环境中使用之前，它必须已经被构建/编译成可执行文件或二进制文件。这个二进制文件很重要，因为它是将在你的环境中运行时执行的软件版本。可以将其看作是一个时间快照。有些人会说源代码比二进制文件本身更重要，因为二进制文件只是副产品，可以一次次重建，尽管这并不完全准确。
- en: You will not be running functional, regression, performance, or load tests against
    the source code. You will be doing so against the binary. It's therefore important
    that the resulting binary is treated with as much reverence as the source code
    from which it was created. This becomes more important if you're looking at side-by-side
    versioning and/or baking in versions during the CI process. For example, if your
    CI solution creates version 1.2.0.1 of the binary, then it's version 1.2.0.1 you
    should be using and testing.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会对源代码进行功能性、回归、性能或负载测试，而是对二进制文件进行测试。因此，重要的是要像对待源代码一样对待生成的二进制文件。如果你采用并行版本控制和/或在CI过程中嵌入版本信息，这一点就显得尤为重要。例如，如果你的CI解决方案生成了版本1.2.0.1的二进制文件，那么你应该使用并测试的是版本1.2.0.1。
- en: The ideal, and recommended, approach is that the binary is only built once for
    a given release/deployment and that the self-same unchanged binary is used in
    **all** environments, including production. This may sound like common sense,
    but sometimes this is overlooked or simply cannot be done due to software design
    and/or tooling, or, more worryingly, it's not seen as important.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的、推荐的做法是，二进制文件仅在某个特定版本/部署时构建一次，并且**在所有**环境中使用完全相同、未经修改的二进制文件，包括生产环境。这听起来像是常识，但有时由于软件设计和/或工具的原因，这一点会被忽视，或者干脆做不到，或者更让人担心的是，它没有被视为重要。
- en: One example of tooling/software design limitations would come in the form of
    software tokens or config related to the environment (sometimes referred to as
    secrets). Let's take the credentials for a database server, for instance. Some
    would say that because this data is very sensitive—especially in higher environments
    such as production—it should be hidden away from all but a select few. One way
    around this is to *bake* this information into the binary itself at compile-time,
    which makes it secure. This is all well and good, but we only want to build it
    once, and therefore you would have to have the same credentials set up in all
    environments, including the completely open development environment—far from secure,
    I think you'll agree. Another drawback to this approach is the fact that someone
    could reverse-engineer the binary and get hold of the credentials without you
    knowing. Also, how would you change said credentials should they get leaked and
    need changing?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 工具/软件设计的一个限制例子可能出现在与环境相关的软件令牌或配置（有时称为机密）上。以数据库服务器的凭据为例。有些人会说，因为这些数据非常敏感——特别是在像生产环境这样的高权限环境中——它应该只对少数几个人可见。一种解决方法是在编译时将这些信息**嵌入**到二进制文件中，这样就可以确保它的安全。这种方式确实不错，但我们只想构建一次，因此你必须在所有环境中设置相同的凭据，包括完全开放的开发环境——你肯定会同意，这远不是安全的。这个方法的另一个缺点是，有人可能通过逆向工程获得二进制文件，并获取凭据，而你却毫不知情。而且，如果这些凭据泄露并需要更改，你该怎么做呢？
- en: You could always build multiple copies of the binary (one for each environment);
    however, you're back to testing different versions of the software.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你始终可以为每个环境构建多个二进制副本（每个环境一个）；然而，这样你又得测试不同版本的软件。
- en: There are many industry-standard approaches to this problem, but the simple
    approach (which seems to work well for a vast amount of businesses) is to have
    this kind of data held in a startup script or system configuration file (which,
    of course, is under version-control) and have the software load it up at runtime.
    If you restrict access to these configs files/scripts, you have a good chance
    of keeping them *secret.* Whatever approach you choose, you should ensure that
    it allows you to use the same binary.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的行业标准方法有很多，但简单的方法（似乎对大多数企业来说都很有效）是将这些数据保存在启动脚本或系统配置文件中（当然，这些文件是版本控制下的），并在运行时由软件加载它。如果你限制对这些配置文件/脚本的访问，就有很大的机会保持它们的*机密性*。无论你选择哪种方法，都应该确保它允许你使用相同的二进制文件。
- en: As previously mentioned, use of a binary repository will also allow you to store
    multiple versions of a given binary, which means a rollback to the previous version
    is pretty painless.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用二进制仓库也能让你存储某个二进制文件的多个版本，这意味着回滚到先前版本会变得相对简单。
- en: Now that we've looked at how to deliver the software to each environment, let's
    see how many environments you need.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何将软件交付到每个环境，接下来看看你需要多少个环境。
- en: How many environments is enough?
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多少个环境才算足够？
- en: This question has been around since software development became a thing. Unfortunately,
    there is no simple answer, although there are some common-sense and tried-tested-and-trusted
    approaches that have worked over the years. When I talk about environments, I'm
    not just referring to servers here; I'm referring to the servers, infrastructure,
    network, firewalls, first- and third-party integration, and so on. In essence,
    everything you need to run one copy of your software platform.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题从软件开发诞生以来就存在。不幸的是，无法给出一个简单的答案，尽管有一些常识性的、经过实践检验并得到信任的方法多年来一直有效。当我谈论环境时，我不仅仅指服务器；我指的是服务器、基础设施、网络、防火墙、第一方和第三方集成等。实际上，就是你运行软件平台所需的一切。
- en: 'Going back to the question at hand, the (rather underwhelming) answer is: the
    number of environments you **need** depends on your ways of working, your engineering
    setup, and, of course, the architecture of your platform. There''s also another
    factor to consider: the overhead to manage and look after multiple environments
    along with the cost of keeping them running and healthy. Suffice it to say that
    you should not go overboard; try to work to a *less-is-more* approach where you
    can.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们讨论的问题，（相当平淡的）答案是：你**需要**的环境数量取决于你的工作方式、工程设置以及平台架构。当然，还有一个因素需要考虑：管理和维护多个环境的开销，以及保持它们运行和健康的成本。可以肯定地说，你不应该做得过头；尽量采用*少即是多*的方法。
- en: 'There may also be a temptation to have environments set up for different scenarios:
    development, functional testing, regression testing, user acceptance testing,
    performance testing, and load testing. If you are able to ensure all the environments
    can be kept up to date (including the all-important test data), can easily deploy
    to them, and, more importantly, **need** all of them, then this may be viable.
    The reality is that having too many environments can actually be counterproductive
    and can cause far too much noise and overhead.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能会有一种诱惑，想要为不同的场景设置不同的环境：开发、功能测试、回归测试、用户验收测试、性能测试和负载测试。如果你能确保所有环境都能够保持最新（包括至关重要的测试数据），并且能够轻松部署到这些环境中，更重要的是，**需要**所有这些环境，那么这种做法是可行的。现实情况是，环境过多实际上可能适得其反，造成太多的噪声和负担。
- en: 'The ideal number of environments is two:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的环境数量是两个：
- en: One for development
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于开发
- en: One for production
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于生产
- en: This may sound like an accident waiting to happen, but if you think about it,
    many small businesses and start-ups manage fine with such a setup. What you'll
    find is that as a business grows, so does the need to be risk-averse, and hence
    the potential for multiple environments.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来这可能像是一个意外即将发生，但如果你仔细想想，很多小型企业和初创公司在这样的设置下都能顺利运作。你会发现，随着企业的成长，对风险规避的需求也随之增加，因此可能会需要多个环境。
- en: 'When ACME systems started out, two environments were sufficient. As they grew,
    so did the need for more environments, and they ended up with multiple development
    environments (one for each engineering team), an integration environment, a performance-testing
    environment, a load-testing environment, a pre-live deployment staging environment,
    and, of course, production environments. They also ended up with an entire team
    of people whose job was to keep these all running—actually, they ended up with
    two: one to look after the engineering and testing environments, and one to look
    after the production environments. Far from ideal or effective.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当ACME系统刚开始时，两个环境就足够了。随着公司的发展，环境的需求也在增加，最终他们有了多个开发环境（每个工程团队一个），一个集成环境，一个性能测试环境，一个负载测试环境，一个预上线部署环境，当然还有生产环境。最终，他们还成立了一个专门的团队，负责维持这些环境的运行——实际上，他们成立了两个团队：一个负责工程和测试环境，另一个负责生产环境。远非理想或高效。
- en: You may think that with virtualization technologies (including cloud-based)
    now in a highly-mature state and used by anyone and everyone, setting up and running
    hundreds of servers, is not as much as an overhead as it once was. There is truth
    in that thinking, but it's the challenge of keeping everything in line that is
    massive—versions of software, O/S patch levels, network configuration, firewall
    configurations, and so on. Therefore, virtualization can help in some ways, but
    the *how many environments* question still remains.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为，现在虚拟化技术（包括基于云的虚拟化）已经高度成熟，并且被广泛应用，设置和运行数百台服务器不再像以前那样是一个巨大的负担。这个想法是有道理的，但真正的挑战在于如何保持一切井然有序——软件版本、操作系统补丁级别、网络配置、防火墙配置等等。因此，虚拟化在某些方面确实有帮助，但“需要多少个环境”这个问题仍然存在。
- en: 'Whatever you decide, there may be a fly in the ointment: what if your production
    environments are locked away in a highly-secure datacenter to which you have little
    or no access, or, worse still, fully managed by a third party? This can have a
    massive impact on your *less-is-more* approach. If this is the case, then you
    really need to get those managing said environments closely looped into what you''re
    trying to do—if you don''t, it can derail your DevOps adoption.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你做出什么决定，可能都会有一个麻烦：如果你的生产环境被锁定在一个高度安全的数据中心，你几乎无法访问，或者更糟糕的是，由第三方完全管理，这可能会对你的*少即是多*方法产生巨大影响。如果是这种情况，那么你真的需要让那些管理这些环境的人紧密配合你正在做的事情——如果不这样做，可能会破坏你的DevOps采纳。
- en: 'Let''s move on to a real-world example and see how ACME systems approached
    this. When they reviewed the environments **needed** for CD and DevOps, they settled
    on the following as being sufficient for their needs:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看一个现实世界的例子，看看ACME系统是如何处理这个问题的。当他们回顾为持续交付（CD）和DevOps所**需要**的环境时，他们认为以下环境足以满足他们的需求：
- en: '**Development environments**: Cut-down versions of the platform with only a
    few other platform components that were needed for local testing'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发环境**：平台的精简版本，只包含本地测试所需的少数平台组件'
- en: '**CI environment**: The place where the software is built and all automated
    tests are run on a regular basis'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CI环境**：软件构建和所有自动化测试定期运行的地方'
- en: '**Pre-production environment**: Used for the occasional spot check/UAT (occasional
    being the operative word)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预生产环境**：用于偶尔的抽查/用户验收测试（偶尔是关键字）'
- en: '**Production environment**: This is where all the action takes place'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产环境**：这是所有操作发生的地方'
- en: 'The following diagram depicts the environments used:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了所使用的环境：
- en: '![](img/94632199-b701-4c63-bfb6-2a128075a02c.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94632199-b701-4c63-bfb6-2a128075a02c.png)'
- en: ACME systems 3.0 environment setup
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ACME系统 3.0 环境设置
- en: As you can see, this follows the less-is-more approach and allows for enough
    quality gates to ensure a given change was sufficient. When combined with all
    of the aforementioned engineering best practices (high levels of test coverage,
    build automation, CI tooling, and so on), the speed at which a given change could
    be delivered was minutes.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这遵循了少即是多的方法，并允许足够的质量门控，以确保给定的更改是充分的。当与所有前述的工程最佳实践（高水平的测试覆盖率、构建自动化、CI工具等）结合使用时，给定更改的交付速度可能只需几分钟。
- en: OK, so this is a bit of a utopia and you may be quite some distance from this
    now, but hopefully you can see how simple it can be, and hopefully you're slightly
    closer to answering the *how many environments* question.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这有点理想化，现在你可能离这个目标还有一段距离，但希望你能看到它有多简单，并且希望你能稍微接近回答*需要多少环境*的问题。
- en: Let's now have a look at another possible environment-related solution that
    can help speed up your delivery capabilities.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看另一种可能的环境相关解决方案，它可以帮助加速您的交付能力。
- en: Developing against a like-live environment
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在类似生产环境中进行开发
- en: There are many ways to ensure one version of a software binary works, or integrates,
    with other parts of your platform, but by far the easiest is to actually develop
    against an environment that contains live versions of your platform.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以确保一个版本的软件二进制文件能够正常工作或与平台的其他部分进行集成，但迄今为止，最简单的方法是实际上在一个包含平台实时版本的环境中进行开发。
- en: On paper, this may look like a strange statement, but if you think about it,
    you're making a change to one part of your overall platform and—as is the CD way—you
    want to validate and ship that change as soon as possible. What this also gives
    you is the ability to ensure that the dependencies you expect to be available
    within the production environment are actually there and function as you expect,
    along with the configuration and infrastructure.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，这可能看起来像是一个奇怪的说法，但如果你仔细想想，你正在更改整体平台的一部分——就像持续交付（CD）的方法那样——你希望尽快验证并交付这个更改。这样做的好处是，您可以确保您期望在生产环境中可用的依赖项确实存在并按预期运行，同时还包括配置和基础设施。
- en: This approach will give the most value when used in conjunction with component-based
    architecture, but some aspects will apply to legacy platforms as well.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当与基于组件的架构结合使用时，这种方法将产生最大价值，但一些方面也适用于传统平台。
- en: The simplest approach would be to develop against the production environment,
    but this is very risky and the possibility that you could cause outage—albeit
    inadvertently—is quite high. There's also the security/access issues. The next
    best thing is, therefore, to have another like-live environment set up, which
    contains the versions of code that are running in the production environment.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是直接在生产环境中进行开发，但这种做法风险极高，你可能会无意中导致服务中断。还有安全/访问问题。因此，最好的做法是设置一个类似于生产环境的环境，包含在生产环境中运行的代码版本。
- en: 'You may be thinking that developing against a *like-live* environment is somewhat
    overkill, and you may be wondering why not simply develop against the versions
    of software that reside in the CI environment. There is a simple answer: you have
    no firm idea which of the changed binaries in the CI environment will be live
    before you. For example, if you are developing and testing against version 1.2.0.3
    of the authentication component (to pick a name out of the air), and when your
    binary hits production and starts to talk to version 1.2.0.1, you may experience
    issues that you didn''t see during the development/testing phase.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得在类似生产环境中进行开发有些过度，或许你会疑惑为什么不直接在CI环境中的软件版本上进行开发。答案很简单：你无法确定CI环境中哪些更改后的二进制文件会在你之前被推向生产环境。例如，如果你正在开发和测试身份验证组件的版本1.2.0.3（随便挑选一个版本），而当你的二进制文件进入生产并开始与版本1.2.0.1进行交互时，你可能会遇到开发/测试阶段没有发现的问题。
- en: This is especially true if someone is testing out a breaking change where you
    need to ensure that you have covered all scenarios **before** you release it to
    production.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人正在测试一个重大变更，需要确保在将其发布到生产环境之前，已经涵盖了所有场景，这一点尤其重要，**在**发布到生产之前。
- en: This like-live environment only needs to be *like-live* in terms of software
    (and infrastructure) versions. If you can populate it with live data, that would
    be good, but the reality is that you would need something as big as production
    in terms of storage and so on, which is costly. Saying nothing of the risk of
    exposing confidential data and breaching data protection rules and regulation,
    such as GDPR—unless you have a way to redact confidential data (which is a whole
    different challenge).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类似生产环境的设置仅需要在软件（和基础设施）版本上与生产环境相似。如果你能用实际数据填充它，那将更好，但实际上，你需要一个和生产环境一样大的存储空间，这会很昂贵。更不用说暴露机密数据并违反数据保护法规（如GDPR）的风险——除非你有办法对机密数据进行脱敏处理（这又是一个完全不同的挑战）。
- en: 'To give you a flavor of how this could work, the following diagram gives an
    overview of how ACME systems implemented such a setup:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你了解这一过程如何运作，以下图表概述了ACME系统如何实现这种设置：
- en: '![](img/f4958468-5227-4273-9e42-4c0fa496f940.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4958468-5227-4273-9e42-4c0fa496f940.png)'
- en: The like-live environment used by ACME systems 3.0
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ACME系统3.0使用的类似生产环境
- en: 'As you can see, the like-live environment is tagged onto the end of the deployment
    pipeline. It is on the end for a reason: you only want to deploy to this environment
    once the deployment to production is successful.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，类似生产环境被添加到部署流水线的末端。它之所以放在末端，是因为你只想在成功部署到生产环境后才进行部署到这个环境。
- en: It should be noted that when we talk about a like-live environment, this need
    not be a physical set of servers. You could look at virtualization (cloud or desktop-based),
    whereby you can pretty much spin up a copy of your production environment on a
    developer's workstation (on the presumption that there's enough horse power and
    storage available).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，当我们谈论类似生产环境时，这不一定是一个物理服务器集群。你可以考虑虚拟化（云端或桌面虚拟化），通过这种方式，你几乎可以在开发者的工作站上创建一个生产环境的副本（前提是有足够的计算能力和存储空间）。
- en: Now that you are starting to get all of the building blocks in place to realize
    your goal of adopting CD and DevOps, we have a few additional blocks you'll need,
    those being how you actually take the fully-built and tested software component
    through the environments in a controlled, reliable, and repeatable way. This is
    where CD tooling comes into play.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经开始搭建实现采用持续交付（CD）和DevOps目标的所有基础组件，我们还有一些额外的组件你需要了解，那就是如何将完全构建和测试通过的软件组件以一种受控、可靠且可重复的方式穿越各个环境。这正是CD工具发挥作用的地方。
- en: CD and DevOps tooling
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CD和DevOps工具
- en: There is another collection of tools that may not be as readily available to
    you as the aforementioned tools (automated build and testing, CI, and so on).
    These are the tools that you will use to control and orchestrate the entire software-delivery
    life cycle from building the binaries (via CI), deploying said binaries to the
    various test environments, and if all goes well, pushing the same binary to production.
    At a very simple level, these tools act as workflow engines wherein each step
    is defined to do a specific action, and then the flow moves on to the next tasks.
    They also have basic logic built in to catch exceptions during the flow (for example,
    if tests fail, then don't go any further and send a notification). This workflow
    analogy is normally referred to as the CD pipeline, delivery pipeline, or just
    pipeline.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一组工具，可能不像上述工具（自动构建和测试、CI等）那样随处可得。这些是您将用来控制和编排整个软件交付生命周期的工具，从构建二进制文件（通过CI）、将这些二进制文件部署到各种测试环境，以及如果一切顺利，推送相同的二进制文件到生产环境。在非常简单的层面上，这些工具充当工作流引擎，其中每个步骤被定义为执行特定操作，然后流程继续移动到下一个任务。它们还内置了基本逻辑来捕获流程中的异常（例如，如果测试失败，则不要继续并发送通知）。这种工作流程类比通常称为CD管道、交付管道或仅管道。
- en: Over the past few years, the CD and DevOps tooling market has grown from almost
    nothing to a full-blown multi-million-dollar global business. There are now a
    plethora of tools and vendors wanting to sell tools to you, and it's become quite
    difficult to choose the one (or two) that will fit your needs. Just like any tool
    or technology you use within your software development life cycle, you need CD
    and DevOps tools that will be reliable, help more than hinder, and will grow with
    you as your adoption matures. I would also hazard a guess that you will already
    have some tooling that manages your software delivery/deployment, so you may need
    to look at something that will either integrate with the existing tooling or replace
    it completely.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，持续交付和DevOps工具市场从几乎无到成为一个价值数百万美元的全球行业。现在有大量工具和供应商想要向您销售工具，选择一个或两个符合您需求的工具已变得非常困难。就像您软件开发生命周期内使用的任何工具或技术一样，您需要可靠的持续交付和DevOps工具，它们能帮助而不是阻碍，并且随着您的采用成熟而成长。我还敢猜测，您可能已经有一些管理软件交付/部署的工具，因此您可能需要考虑一些能够与现有工具集成或完全替换它的东西。
- en: The tooling you choose will be used day in and day out and will be heavily relied
    upon, so you had better make sure it fits your needs and will be there when it's
    needed. To assist in this, you could use something similar to the following, which
    could assist during your tool/vendor selection and due diligence.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 选择的工具将被日复一日地使用，并且将被严重依赖，因此最好确保它符合您的需求，并且在需要时可靠。为了帮助您，您可以使用类似以下的内容，这将在选择工具/供应商以及尽职调查期间提供帮助。
- en: 'The following are some example questions you should ask of your CD and DevOps
    tooling/vendor:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您应该询问CD和DevOps工具/供应商的一些示例问题：
- en: Can it deploy the same binary to multiple environments?
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它能够将相同的二进制部署到多个环境中吗？
- en: Can it access the binary and source repositories we're using?
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它能够访问我们正在使用的二进制和源代码仓库吗？
- en: Can it remotely invoke and control the installation process on the server it's
    been deployed to?
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它能够远程调用和控制安装过程在其部署到的服务器上吗？
- en: Is there functionality to allow it to orchestrate my current tooling?
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有功能来允许它编排我的当前工具集吗？
- en: Is it capable of deploying database changes?
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它能够部署数据库变更吗？
- en: Does it have functionality to allow for the queuing up of releases?
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有功能允许排队发布吗？
- en: Can it run parallel pipelines?
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它能够并行运行管道吗？
- en: Does it contain an audit of what has been deployed, when, and by whom?
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含已部署内容的审计，包括何时部署和由谁部署的吗？
- en: Is it secure?
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否安全？
- en: How is it hosted (SaaS, PaaS, on-premise, and so on)?
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是如何托管的（SaaS、PaaS、本地等等）？
- en: Can it interact with the infrastructure to allow for no-downtime deployments?
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否能与基础架构互动，以允许无停机部署？
- en: Can it/could it orchestrate automated infrastructure-provisioning?
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它能够/可以编排自动化基础设施提供吗？
- en: Can it interact with other systems and solutions, such as email, collaboration
    tools, change-management, issue-management, and project-management solutions?
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它能够与其他系统和解决方案进行交互，例如电子邮件、协作工具、变更管理、问题管理和项目管理解决方案吗？
- en: Does it have simple and easy-to-understand dashboards that can be displayed
    on big screens around the office?
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否有简单易懂的仪表板，可以在办公室周围的大屏幕上显示？
- en: Can it interact with and/or orchestrate CI solutions (our current solution and
    other industry leaders)?
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它能与 CI 解决方案互动并/或协调工作吗（我们的当前解决方案和其他行业领导者）？
- en: Will it grow with our needs?
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会随着我们的需求增长而扩展吗？
- en: What skills/experience do we need to run this?
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要什么技能/经验来运行它？
- en: Is it simple enough for anyone and everyone to use?
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否足够简单，人人都能使用？
- en: What support/SLA do we get?
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们获得什么支持/SLA？
- en: What set up/implementation support do we get included in the price?
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在价格中包括了哪些设置/实施支持？
- en: What about HA/failover?
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那么高可用性/故障转移呢？
- en: What is the process for upgrading the tooling itself?
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级工具本身的过程是怎样的？
- en: 'At this point, it would be very helpful if I just listed most of the market-leading
    tools and gave you an idea of their pros and cons. However, depending on when
    you read this, that information could be very out of date. This is really something
    you need to be doing yourself anyway—you know your needs, problems to solve, and
    budget better than I. It should go without saying, but I''ll mention it just in
    case: the tooling choice should be done in true DevOps style, with both Dev and
    Ops heavily and equally involved.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，如果我列出大部分市场领先工具并告诉你它们的优缺点，那将非常有帮助。然而，根据你阅读本文的时间，这些信息可能已经过时了。无论如何，这本该是你自己做的事——你比我更了解自己的需求、要解决的问题和预算。当然，这不言而喻，但我还是要提一提：工具的选择应该按照真正的
    DevOps 风格进行，开发和运维都应该深度且平等地参与其中。
- en: 'There are a few things you should take into account when selecting CD and DevOps
    tooling: don''t skimp on budget as the tooling will become the backbone of your
    delivery pipeline; don''t just stick with the big boys in the marketplace, as
    they may be too constraining in the long run; and if there are gaps you can fill
    with bespoke solutions, you should seriously consider that without creating another
    legacy to look after.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择 CD 和 DevOps 工具时，有几件事需要考虑：不要在预算上吝啬，因为工具将成为你交付流水线的核心；不要仅仅依赖市场上的大牌工具，因为它们从长远来看可能会过于局限；如果有可以通过定制解决方案填补的空白，你应该认真考虑，而不是创造出另一个需要维护的遗留问题。
- en: You may have noticed that one of the considerations noted here is automated
    provisioning. Let's now look into what this means.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，自动化配置是这里提到的一个考虑因素。现在，让我们深入了解一下这意味着什么。
- en: Automated provisioning
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化配置
- en: 'The norm over the past few years has been to move from traditional tin-and-string
    physical servers and infrastructure to virtualized equivalents, be that on-premise,
    datacenter-hosted, or cloud-based. I won''t dwell too much on the advantages of
    one over the other—again, there''s plenty of rich information available should
    you wish to read up—but I will focus on one element that is not always front and
    center when planning to move to a virtualized environment solution: the ability
    to use automated provisioning as part of your CD and DevOps pipeline.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 过去几年中的常态是从传统的金属和电缆物理服务器以及基础设施转向虚拟化的等效解决方案，无论是在本地、数据中心托管，还是基于云的。我不会过多讨论某一类比另一类更具优势——再说一次，如果你有兴趣深入了解，这里有很多丰富的信息——但是我会重点关注一个在规划迁移到虚拟化环境解决方案时并不总是显而易见的因素：将自动化配置作为
    CD 和 DevOps 流水线的一部分。
- en: Provisioning is nothing new; as long as cloud providers have been a thing, they
    have been providing their customers with cloud-based virtualized servers that
    can be provisioned pretty much as and when needed. One also has the freedom in
    defining the configuration and setup of the servers in terms of horsepower, storage,
    networking, operating system, and location/region. In addition to this, when the
    servers are no longer needed, they can then be deleted (sometimes referred to
    as teared down).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 配置并不是什么新鲜事；只要云服务商存在，他们就一直在为客户提供可以按需配置的云基础虚拟化服务器。你还可以自由定义服务器的配置和设置，包括计算能力、存储、网络、操作系统以及位置/区域。除此之外，当这些服务器不再需要时，它们可以被删除（有时称为销毁）。
- en: Now consider how useful it would be to have automated provisioning as a step
    within your CD pipeline. You would then have the ability to not only control and
    orchestrate the software-delivery life cycle, but you can also create environments
    on the fly, install your software, run your tests, and then tear it all down.
    The massive advantages this gives you are predictability and repeatability. If
    you can guarantee that **every time** you initiate the CD pipeline you will have
    exactly the same vanilla environment created from scratch, then you can pretty
    much eliminate what some like to call environmental issues—something we'll be
    looking at later—which continually cause noise and false negatives (or positives)
    within the testing step.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑一下如果将自动化供应作为CD管道中的一个步骤会有多有用。你不仅能够控制和协调软件交付生命周期，还可以即时创建环境，安装软件，运行测试，然后销毁它们。这带来的巨大优势是可预测性和可重复性。如果你能保证**每次**启动CD管道时，都会从零开始创建完全相同的标准环境，那么你几乎可以消除某些人喜欢称之为环境问题的情况——这也是我们稍后会讨论的内容——这些问题不断地在测试步骤中产生噪声和虚假阴性（或阳性）。
- en: As you would expect, there are many industry buzzwords floating around to complicate
    this sort of activity—the most common ones being **Infrastructure-as-a-Service**
    (**IaaS**) and PaaS—but what it boils down to is being able to programmatically
    interface with a provisioning system, tell it what you want in terms of spec,
    configuration, and so on, and get it to spit one out the other end. When you're
    done, you programmatically interface again and get the environment removed.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所预料的那样，围绕这种活动存在许多行业术语，它们往往使事情变得复杂——最常见的术语是**基础设施即服务**（**IaaS**）和PaaS——但归根结底，这就是能够通过编程与供应系统接口，告诉它你想要的规格、配置等，最终让它输出相应的结果。当你完成时，再通过编程接口来删除环境。
- en: The list of requirements fed into a provisioning system that defines the server
    spec, CPUs, GPUs, RAM, storage, and so on is normally referred to as the recipe—there
    are some variations depending on the tools, but they are all pretty much the same
    thing.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给供应系统的需求清单，定义了服务器的规格、CPU、GPU、RAM、存储等，通常被称为配方——根据工具的不同，可能有一些变体，但它们基本上是相同的。
- en: Something to consider with automated provisioning is the time lag you may encounter
    within the CD pipeline. For example, if you were to take a binary and deploy it
    to a prebuilt server, then the time taken is simply the act of deploying. Add
    automated provisioning into the mix and the CD pipeline will have to wait for
    the new virtual server(s) to be provisioned before you can deploy your binaries.
    What you need to weigh up is the importance of quality, repeatability, and predictability
    over speed and convenience. Just because something is faster doesn't make it better.
    What you can do to overcome this is to pre-bake some vanilla virtual server images
    that can be added to the environment via the automated provisioning tooling as
    part of the CD pipeline. That way, you have a fresh virtual server in a fraction
    of the time. In fact, this is how many leading cloud providers operate. There
    is an overhead with this approach; someone needs to keep these vanilla virtual
    server images fresh and updated, with operating-system patch levels being the
    pain they are. Again, you need to weigh up the pros and cons.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动化供应过程中需要考虑的一个问题是你可能在CD管道中遇到的时间延迟。例如，如果你将一个二进制文件部署到一个预建的服务器上，那么所花的时间就是部署的时间。将自动化供应加入其中，CD管道必须等到新的虚拟服务器被供应出来，才能部署你的二进制文件。你需要权衡的是质量、可重复性和可预测性与速度和便利性之间的重要性。仅仅因为某件事更快并不意味着它更好。为了解决这个问题，你可以提前制作一些标准的虚拟服务器镜像，这些镜像可以通过自动化供应工具作为CD管道的一部分加入到环境中。这样，你就可以在更短的时间内获得一个全新的虚拟服务器。事实上，这正是许多领先的云服务提供商的操作方式。这种方法有一定的开销；需要有人保持这些标准虚拟服务器镜像的更新和新鲜，操作系统的补丁问题尤其麻烦。同样，你需要权衡利弊。
- en: One massive advantage of automated provisioning is blue/green deployments. Strictly
    speaking, this approach was around before automated provisioning became mainstream,
    but automated provisioning has made it far easier to realize. I won't go into
    too much detail—again that's homework for you. However, in simple terms, blue/green
    deployments allow you to provision a new server with the latest version of software
    or configuration changes or database updates offline within the environment, then
    switch old for new via a small network/routing change. Essentially, you do the
    hard work and prep upfront, and the release simply becomes the switchover. It's
    very effective and quick, and allows for near-instant rollback if problems are
    found (for example, switching back from new to old). I would highly recommend
    adding this to your reading list.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化配置的一个巨大优势是蓝绿部署。严格来说，这种方法在自动化配置成为主流之前就已经存在，但自动化配置使得实现这一方法变得更容易。我不会过多详细介绍——这留给你自己去学习。不过，简单来说，蓝绿部署允许你在环境中离线配置一台新服务器，安装最新版本的软件或配置更改或数据库更新，然后通过小的网络/路由调整来切换旧服务器与新服务器。实质上，你提前完成了所有的艰苦工作和准备，发布过程只是一个切换操作。这种方法非常有效且快速，并且在发现问题时（例如，切换回旧版本）可以几乎即时回滚。我强烈建议你将这项内容加入你的阅读清单。
- en: You may be thinking that the automated provisioning approach will only work
    for environments that are used for development and testing, but this self-same
    approach can (and should) be considered for your production environment. After
    all, if you have set up a CD pipeline, what's the point (or value) of stopping
    short of the goal. I wouldn't recommend doing this on day one; you need to build
    up your confidence in the tooling and iron out any kinks before taking the plunge.
    Based upon experience, I can guarantee that once you have automated provisioning
    in place, you will not look back.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为自动化配置方法只适用于开发和测试环境，但这种方法实际上也可以（而且应该）应用于生产环境。毕竟，如果你已经建立了CD流水线，那为什么还要止步不前呢？我不建议你在第一天就尝试这样做；你需要建立对工具的信心，并在跳入实际操作前解决任何问题。根据经验，我可以保证，一旦你将自动化配置落实到位，你将不再回头。
- en: 'Another massive but little-mentioned benefit of automated provisioning is the
    ability to overcome the bane of most IT departments and software houses around
    the globe: having to take your production system offline to upgrade it.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化配置的另一个巨大的但鲜少被提及的好处是能够克服全球大多数IT部门和软件公司面临的头疼问题：必须将生产系统下线进行升级。
- en: No-downtime deployments
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无停机部署
- en: 'One of the things that comes with large releases of software (legacy or otherwise)
    is the unforgivable need to take the production platform offline to upgrade it.
    Yes, I did say unforgivable, because that''s exactly what it is. It is also wholly
    avoidable. It''s the IT equivalent to having an out-of-order sign on the elevator:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 大规模发布软件（无论是遗留系统还是其他）时，一件不可饶恕的事情就是必须将生产平台下线进行升级。是的，我确实说了“不可饶恕”，因为这正是它的真实情况。而且完全可以避免。这就像是电梯上挂着“故障”标志的IT等价物：
- en: '![](img/ff4dd7d1-569e-4098-b05e-3ed44eb0607e.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff4dd7d1-569e-4098-b05e-3ed44eb0607e.png)'
- en: 'There are two simple reasons for taking a production system offline to upgrade
    it: there are far too many unreleased changes that have been bundled up together,
    or you don''t trust the quality of the software being delivered. Both of these
    can be overcome through CD and DevOps adoption.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 将生产系统下线进行升级有两个简单的原因：有太多尚未发布的更改被捆绑在一起，或者你不信任交付的软件质量。这两种情况都可以通过采用CD和DevOps来克服。
- en: Let's consider you are operating a real-time online service and you inform your
    customers that you have to take the system offline for an upgrade. You can bet
    a pretty penny that your customers will not take kindly to not being able to access
    your system (or more importantly, their data) for a few hours so that you can
    upgrade some parts of it. To minimize the impact, you will no doubt schedule the
    upgrade out-of-hours, which means you'll need to have people on-call to support
    the upgrade—but being out-of-hours, I doubt you'll have all of the engineers that
    made the changes available on the night, so you already have a risk.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在运营一个实时在线服务，并且你通知你的客户你需要将系统下线进行升级。你可以打赌，客户一定不会高兴，因为为了升级系统中的某些部分，你将让他们无法访问系统（更重要的是，无法访问他们的数据）几个小时。为了将影响降到最低，你无疑会安排在非工作时间进行升级，这意味着你需要有人员待命以支持升级——但是因为是在非工作时间，我怀疑你无法联系到所有参与过更改的工程师，所以你已经面临一定的风险。
- en: 'One important thing in relation to out-of-hours is this: unless you are running
    a B2B solution and have customers in the same time zone, you may struggle to find
    a suitable out-of-hours time window. For example, if your solution and business
    is B2C, you''re pretty much offering a 24/7 solution, so unless you know for sure
    when your consumers sleep, finding the time window is going to be tough. If your
    customers are global, you will find it even harder to find a suitable window.
    You will no doubt have included something in your terms of service and/or contracts
    to cater for taking the live platform offline, but this amounts to admitting to
    your customers that your business processes are inadequate.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 关于非工作时间的一个重要事项是：除非你运营的是B2B解决方案并且客户都在同一时区，否则你可能会很难找到合适的非工作时间窗口。例如，如果你的解决方案和业务是B2C的，你几乎是在提供一个全天候的服务，因此除非你确切知道你的消费者何时睡觉，否则找到合适的时间窗口会非常困难。如果你的客户是全球性的，那么找到合适的窗口会更加困难。你无疑已经在你的服务条款和/或合同中包含了为了将在线平台下线而做出的相关规定，但这实际上是在向客户承认你的业务流程存在不足。
- en: If you also consider how many news stories are reported on a regular basis regarding
    major issues following a massive down-time IT upgrade, there is also a very strong
    possibility that your customers will look upon this big-bang approach with distrust
    as they'll be pretty sure something will go wrong once the service is up and running
    again. This distrust will be amplified if you go beyond the time window. From
    experience, I can say with confidence that something will go wrong, and depending
    on the severity, you will have to quickly move into damage-limitation mode to
    keep customers happy, T&Cs and contracts aside. It might even get to the stage
    where your customers may shop around to find a competitor who does not need planned
    downtime.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还考虑到每当进行大规模停机IT升级时，关于重大问题的新闻报道通常会频繁出现，那么也有很大的可能性，客户会对这种“大爆炸”式的做法产生不信任感，因为他们很清楚一旦服务重新上线，就很可能会出问题。如果超出了预定的时间窗口，这种不信任感会加剧。根据经验，我可以自信地说，总会出问题，根据问题的严重性，你可能需要迅速进入限损模式来让客户满意，撇开服务条款和合同不谈。甚至可能会发展到客户开始寻找不需要计划停机的竞争对手。
- en: OK, so this is a bit doom and gloom, but that is the stark reality. Customers
    and consumers don't care about your process problems or complexities in your SDLC;
    they have become accustomed to having the IT services they use on a daily basis
    being available when they need them. Try to remember when one of the major search
    engines or social media platforms was offline. When release issues happen, it's
    now extremely difficult to contain the bad news, especially with the prevalence
    of social media, 24-hour news, and the like. You have to remember that bad news
    travels faster than anything else known to man, so the last thing you need is
    bad news generated because of a release.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这听起来有点悲观，但这就是残酷的现实。客户和消费者并不关心你的流程问题或软件开发生命周期（SDLC）中的复杂性；他们已经习惯了每天使用的IT服务在需要时都能随时使用。试着回想一下，什么时候某个主要搜索引擎或社交媒体平台曾经出现过离线问题。当发布问题发生时，现在很难控制坏消息的传播，尤其是在社交媒体、24小时新闻等的普及下。你必须记住，坏消息的传播速度比其他任何事情都快，因此你最不需要的就是因为发布问题而产生的坏消息。
- en: The ultimate goal for CD and DevOps adoption is to repeatedly deliver value
    as quickly, consistently, and reliably as possible. Removing the need for down-time
    deployments completely is a massive bonus for you.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: CD和DevOps的最终目标是尽可能快速、一致和可靠地反复交付价值。完全消除停机部署的需求对你来说是一个巨大的好处。
- en: One thing to point out which may not be obvious is that it's not just the production
    environment that should have maximum uptime. Any environment that you are reliant
    on for your development, testing, and CD should be treated the same. If the like-live
    environment is down, how are you going to develop? If your CI environment is down,
    how are you going to integrate and test? The same rules should apply across the
    board—without exception.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指出的一点，可能并不显而易见，那就是不仅仅是生产环境应该最大限度地保证正常运行。任何你依赖的开发、测试和CD环境也应该同样对待。如果类似生产环境的环境发生故障，你怎么进行开发？如果你的CI环境出现故障，你怎么进行集成和测试？这些规则应该在所有环境中通用——没有例外。
- en: Previously, we covered open and honest ways of working as part of engineering
    best practices. Openness and honesty are just as important when it comes to CD.
    A good way of providing this level of transparency is to monitor everything and
    have it available to all.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的讨论中，我们涵盖了工程最佳实践中的开放和诚实工作方式。开放和诚实在 CD 方面同样至关重要。提供这种透明度的一个好方法就是对一切进行监控，并让所有人都能访问这些数据。
- en: Monitor, monitor, monitor
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控，监控，再监控
- en: 'One of the most important ways to ensure whether CD and DevOps is working is
    to monitor, monitor, and then monitor some more. If all of the environments used
    within the CD process are constantly being observed, then the impact of any change
    (big or small) is easy to see—in other words, there should be no hidden surprises.
    A simple rule of thumb here: if it moves, monitor it.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 确保 CD 和 DevOps 是否有效的最重要方式之一就是监控、监控，再监控。如果在 CD 过程中使用的所有环境都在持续被观察，那么任何变化的影响（无论大小）都容易看到——换句话说，应该没有意外的情况。这里有一个简单的经验法则：如果它在动，就监控它。
- en: If you have good coverage in terms of monitoring, you have much more transparency
    across the board. There is no reason why monitoring should be restricted to the
    operations teams; everyone in the business should be able to see and understand
    how any environment—especially the production platform—is performing and what
    it is doing.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的监控覆盖范围足够广泛，你就能在各个方面获得更多的透明度。没有理由将监控仅限于运维团队；业务中的每个人都应该能够查看并理解任何环境——特别是生产平台——的表现以及它在做什么。
- en: There are plenty of mature and industry-standard monitoring tools available,
    but it can be quite difficult to get a single view that is consistent and meaningful.
    For example, some tools are geared up for monitoring infrastructure and servers,
    whereas others are geared up for collecting application metrics, and still others
    for measuring application and/or database performance. Unless you can tie this
    data together into a coherent view, things will look disjointed. Ideally, you
    should try to aggregate the data from these tools—or at least try to integrate
    them—and present a unified view of how any given environment and the software/services
    running within are coping and functioning.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 市面上有很多成熟且符合行业标准的监控工具，但要获得一个一致且有意义的统一视图可能会非常困难。例如，一些工具专注于监控基础设施和服务器，而另一些则专注于收集应用程序的指标，还有一些则专门用于测量应用程序和/或数据库的性能。除非你能将这些数据整合成一个连贯的视图，否则它们看起来会支离破碎。理想情况下，你应该尝试将这些工具的数据汇总在一起——或者至少尽量将它们集成——并呈现一个统一的视图，展示任何特定环境以及其中运行的软件/服务的运行状态和表现。
- en: You will be surprised how much very valuable data you can get and how it can
    direct your engineering work, as the engineers can see exactly how their software
    or infrastructure is behaving in real time with real users.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你会惊讶于你能获得的非常有价值的数据，以及它如何引导你的工程工作，因为工程师可以实时看到他们的软件或基础设施在真实用户环境中的表现。
- en: '![](img/37e01040-01d1-459e-87ad-cc0c13f29f0b.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37e01040-01d1-459e-87ad-cc0c13f29f0b.png)'
- en: If it moves, monitor it. If it doesn't, monitor it just in case
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它在动，就监控它。如果它不动，还是监控一下以防万一
- en: Monitoring is a must for CD and DevOps to work correctly, as things will be
    continually changing (software, services, infrastructure, and so on), and both
    halves of the Dev and Ops relationship will need to see what is going on and assist
    when/if problems occur.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 监控是 CD 和 DevOps 正常运行的必要条件，因为事物（软件、服务、基础设施等）会不断变化，而 Dev 和 Ops 的双方都需要查看正在发生的情况，并在问题出现时提供帮助。
- en: Another, less obvious, positive that monitoring can bring you is proof that
    CD is not having an adverse impact on the production platform. If you're using
    some *graph-over-time* solution, you can get your CD tools to add a *spike* or
    a marker to the graph when a deployment takes place. You can then visually see
    the impact (or not) of the change.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 监控能带来的另一个不太显眼的好处是证明 CD 对生产平台没有产生不利影响。如果你使用的是某种*图表随时间变化*的解决方案，你可以让你的 CD 工具在部署时向图表添加一个*尖峰*或标记。这样你就可以直观地看到变化的影响（或者没有影响）。
- en: So far, we have mainly focused on technical solutions and tools for the adoption
    of CD and DevOps. These solutions and tools may help to provide you with much
    of what you need in your toolbox. However, there is still room for simple manual
    processes.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要关注的是技术解决方案和工具，这些解决方案和工具有助于实现 CD 和 DevOps 的采用。这些解决方案和工具可能会为你提供许多你工具箱所需的内容。然而，简单的手动过程依然有它的空间。
- en: When a simple manual process is also an effective tool
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当一个简单的手动过程也是一个有效的工具时
- en: Even if you have enough tooling to shake a stick at, you will no doubt have
    some small and niggling challenges that cannot be overcome with tooling and automation
    alone. To be honest, tooling and automation can be overkill in some respects,
    and can actually create barriers between certain parts of the organization you
    are trying so hard to bring together—here, I am talking about the Dev and Ops
    partnership that forms DevOps.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你拥有足够的工具，也无疑会遇到一些无法仅通过工具和自动化解决的小问题。说实话，工具和自动化在某些方面可能是过度的，甚至可能在你努力将组织的不同部分整合时制造障碍——这里指的是形成DevOps的开发与运维之间的合作关系。
- en: If tooling and automation completely negate the need for human interaction and
    discussion, you may well end up back where you started. You may also find that
    it is almost impossible to automate your way out of a simple problem.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果工具和自动化完全消除了对人类互动和讨论的需求，你可能会发现最终又回到了最初的状态。你可能还会发现，几乎不可能通过自动化来解决一个简单的问题。
- en: Let's take, for example, the thorny issue of dependency-management. As a software
    platform matures, many interdependencies will form. If you are deploying your
    code using a CD process, these many interdependencies become ever-moving targets
    wherein components are being developed and deployed at different rates. You can
    try to capture this within your CI process, but something somewhere might be missed
    and you could end up inadvertently bringing down the entire platform because component
    B was deployed before component A.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 以依赖管理这个棘手问题为例。随着软件平台的发展，许多相互依赖关系会逐渐形成。如果你使用持续交付（CD）流程进行代码部署，这些众多的相互依赖关系就变成了不断变化的目标，其中各个组件的开发和部署速度各不相同。你可以尝试在持续集成（CI）流程中捕捉这些变化，但某些地方可能会被遗漏，最终可能会因为组件B在组件A之前部署而不经意地导致整个平台崩溃。
- en: You can try to map this out and build into the tooling rules to restrict, or
    at least minimize, these moving targets, but the rules may end up being more complex
    than the original dependencies. Or you could simply agree on a process whereby
    only one change happens at any given point in time. To feed into this, you can
    implement a simple queuing mechanism written on a whiteboard and reviewed regularly
    by all of the engineering and Operations teams.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试绘制出这个过程，并将其构建到工具规则中，以限制或至少最小化这些不断变化的目标，但这些规则可能会比最初的依赖关系更复杂。或者你可以简单地约定一个过程，即在任何给定的时间只能进行一次更改。为了支持这一点，你可以实现一个简单的队列机制，写在白板上，并由所有工程和运维团队定期审查。
- en: 'This approach worked extremely well for ACME systems. The following is what
    they did:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对ACME系统非常有效。以下是他们所做的事情：
- en: They obtained a blanket agreement from everyone that only one change would go
    through to production at any given point in time. They called this a deployment
    transaction.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们获得了每个人的统一同意，即在任何时候，只有一个变更可以进入生产环境。他们将此称为部署事务。
- en: To highlight the fact that someone was making a change to production (either
    a deployment or operational change), that person held the production environment
    token, which was in the form of a plush toy animal and was given the name the
    build badger. If you had the build badger, you were changing production.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了突出某人正在对生产环境进行更改（无论是部署还是操作更改），这个人持有生产环境令牌，令牌的形式是一个毛绒玩具动物，并被命名为“构建獾”。如果你持有构建獾，意味着你正在更改生产环境。
- en: They implemented a simple prioritized queue system using a whiteboard and a
    pen. Each morning, whoever wanted to make a deployment would come along to the
    deployment stand-up and agree with everyone there the order in which deployments
    (or changes) would be made that day.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们使用白板和笔实现了一个简单的优先级队列系统。每天早上，任何想要进行部署的人都会来到部署站会，并与在场的每个人商定当天部署（或更改）顺序。
- en: Screens were installed throughout the office (not just the Dev and Ops areas),
    showing a real-time dashboard of what was going on.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕被安装在整个办公室（不仅仅是开发和运维区域），显示实时仪表板，展示当前正在进行的工作。
- en: All very simple, but what this gave ACME systems was a way to overcome dependency
    hell (for example, if they could only change one thing at a time, there was an
    implied logical order of which change went before another) and built a sense of
    collaboration throughout all of the teams involved.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都非常简单，但这给ACME系统带来了克服依赖地狱的方法（例如，如果他们一次只能更改一项内容，那么就隐含了一个逻辑顺序，表示某个更改应该在另一个更改之前进行），并且在所有参与的团队中建立了协作的意识。
- en: 'The following diagram should give you some idea of what the deployment transaction
    covered, in terms of a deployment:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示应能帮助你理解部署事务在部署过程中的作用：
- en: '![](img/1f685d47-931c-4d08-a318-601aed762973.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f685d47-931c-4d08-a318-601aed762973.png)'
- en: The deployment transaction
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 部署事务
- en: Eventually, ACME managed to engineer out the dependencies that plagued them
    in the early days so this manual process could be decommissioned, although it
    helped them keep moving with their CD and DevOps adoption.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，ACME成功地解决了早期困扰他们的依赖问题，从而使得这个手动过程可以被停用，尽管这个过程曾帮助他们推进CD和DevOps的采纳。
- en: 'Other very simple manual solutions you can use could include the following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 其他你可以使用的非常简单的手动解决方案包括以下几种：
- en: Use collaborative tools for real-time communication between everyone and integrate
    this into your CD tooling so that deployments are announced and can be followed
    by all.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用协作工具进行团队间的实时沟通，并将其集成到你的CD工具中，这样部署时可以宣布并供所有人跟踪。
- en: If your management is uneasy about having developers deploy to production without
    involving the Operations team, make sure you have a DevOps team doing the release.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的管理层对于开发人员在不涉及运维团队的情况下直接部署到生产环境感到不安，确保有一个DevOps团队负责发布。
- en: If instant rollback is needed should a deployment fail, look into simple ways
    of rolling back, such as simply deploying the previous version of the component
    using the CD tooling.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果部署失败需要即时回滚，可以考虑一些简单的回滚方式，例如使用CD工具将先前版本的组件重新部署。
- en: Consistently inspect and adapt through regular retrospectives to see what is
    working and what is not.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过定期回顾持续检查和适应，以了解哪些有效，哪些无效。
- en: As you can tell, it's not all about technical solutions. If simple manual processes
    or tweaks to the ways of working are sufficient, then why bother trying to automate
    them?
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这不仅仅是技术解决方案的问题。如果简单的手动流程或工作方式的调整足够，那为什么要费力去自动化它们呢？
- en: And so ends the lesson—for now. Let's recap what we have covered.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是今天的课程——暂时结束了。让我们回顾一下我们所涵盖的内容。
- en: Summary
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As stated at the beginning of this chapter was a lot to cover and a lot to take
    in. Some of it is relevant to you now and some of it will be relevant for the
    future.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章开头所说，内容非常丰富，需要消化的东西很多。其中一些内容对你现在有帮助，有些则是在未来才会相关。
- en: At this point you should have a greater understanding and appreciation for how
    agile engineering best practices (including use of source control, CI, incremental
    delivery, test automation, failing fast) along with modern architectural approaches,
    delivery methods and in-depth monitoring will ease your CD and DevOps adoption.
    Above all you should have learned that it's not all about technical tools and
    techniques, sometimes simple processes can solve problems.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个时候，你应该更清楚并且更能欣赏敏捷工程最佳实践（包括使用源代码控制、CI、增量交付、测试自动化、快速失败）以及现代架构方法、交付方式和深入的监控如何简化你的CD和DevOps采纳过程。最重要的是，你应该已经明白，问题不仅仅关乎技术工具和技巧，有时简单的流程也能解决问题。
- en: We'll now move on from ways to advance your CD and DevOps adoption to the kinds
    of issues which will trip you up along the way, how to spot them and how to get
    passed them.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从如何推进CD和DevOps采纳的方式，转向你在此过程中可能遇到的难题，如何识别这些问题以及如何克服它们。
