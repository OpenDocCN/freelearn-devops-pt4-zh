- en: 6\. Open Technical Practices – Beginnings, Starting Right
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 开放技术实践——开始，正确起步
- en: So far, we have talked about the foundational culture and collaboration practices
    that support our discovery, options, and delivery Mobius loop. The next two chapters
    establish the technical practices that teams should implement to make the foundation
    even stronger.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了支持我们发现、选项和交付莫比乌斯环的基础文化和协作实践。接下来的两章将建立团队应实施的技术实践，以使基础更加牢固。
- en: Think of the Mobius loop as an engine turning from discovery through options
    generation and into delivery. This cycle continues by doing more delivery until
    we need to revisit the outcomes we've targeted. Delivery is where we take the
    concept and make it real. As we deliver, we will learn a lot and garner feedback
    from our stakeholders and our team. At some point in time, we will need to revisit
    the discovery side of the loop, either to adjust what we know or to realign what
    we deliver next.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 把莫比乌斯环想象成一个从发现到选项生成再到交付的引擎。这个循环通过更多的交付不断进行，直到我们需要重新审视我们所设定的结果。交付是我们将概念变为现实的过程。在交付的过程中，我们会学到很多，并从利益相关者和团队中获得反馈。某个时刻，我们将需要重新审视循环中的发现环节，调整我们所知道的内容或重新对齐我们接下来要交付的内容。
- en: '![](img/B16297_06_01.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_01.jpg)'
- en: 'Figure 6.1: The Mobius loop'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：莫比乌斯环
- en: Imagine we've done one iteration and built some new features for our product,
    such as a leaderboard for our PetBattle app – it's very likely we'd be OK to demo
    and release that functionality without investing time or effort in building out
    a solid technical foundation. But as our iterations continue and the application's
    complexity grows, we may find ourselves beginning to drown in manual testing or
    technical debt. As we hit iteration five or six, things that were working will
    most likely start to break and our ability to predict how much we can do will
    start to fall apart. This could demotivate the team and have people lose confidence
    in our product or ability to execute. Breaking trust at this stage is a difficult
    thing to come back from.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经完成了一次迭代并为我们的产品构建了一些新功能，比如我们为PetBattle应用程序增加了一个排行榜——很可能我们会觉得可以展示并发布这个功能，而不需要投入时间和精力来建立一个扎实的技术基础。但是随着迭代的继续，应用的复杂性增加，我们可能会发现自己开始淹没在手动测试或技术债务中。当我们进行到第五或第六次迭代时，以前有效的做法很可能会开始崩溃，我们预测能做多少事的能力也会开始瓦解。这可能会让团队失去动力，并让人们对我们的产品或执行能力失去信心。在这个阶段失去信任是很难恢复的。
- en: To successfully build software incrementally, we need to ensure we can operate
    smoothly and sustainably. Constant rewrites and fixes will hinder this.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功地逐步构建软件，我们需要确保能够顺利且可持续地运作。不断的重写和修复将阻碍这一过程。
- en: For these reasons, it's important we support our delivery capability with a
    set of foundational technical practices, much like we did with the collaboration
    and culture. Practices such as **configuration-as-code**, **infrastructure-as-code**,
    and even **everything-as-code** can help ensure a team's work is repeatable. Identifying
    how a team will do testing and automating that testing can lead to higher-quality
    output and simplify defect management. Picking the right development workflow
    and tools will accelerate the team's ability to deliver the software and not spend
    all their time managing their tools instead.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这些原因，我们必须通过一套基础技术实践来支持我们的交付能力，就像我们在协作和文化方面所做的那样。**配置即代码**、**基础设施即代码**，甚至**一切皆代码**等实践可以帮助确保团队的工作具有可重复性。确定团队如何进行测试并自动化测试，可以提高输出质量并简化缺陷管理。选择合适的开发工作流和工具将加快团队交付软件的能力，而不是把所有时间都花在管理工具上。
- en: Adding practices to the foundation is not a one-time activity. As the applications
    grow in number and complexity, it's important to bolster the foundation with new
    and more comprehensive use of practices.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 向基础中添加实践并不是一次性的活动。随着应用程序数量和复杂性的增加，重要的是通过新方法和更全面的实践来加强基础。
- en: In the next two chapters, we will share the technical practices implemented
    on the foundational level that have enabled us to achieve the best success. They
    are part of the foundation because they are not time-boxed practices; rather,
    they are continually carried out as part of our daily work. Later in the book,
    we'll explore how bolstering these practices with great use of the platform can
    enable sustainability and scalability of continuous delivery.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，我们将分享在基础层面实施的技术实践，这些实践帮助我们取得了最佳的成功。它们构成了基础的一部分，因为它们不是时间限制的实践；相反，它们是我们日常工作的一部分，不断进行。书中的后续部分，我们将探讨如何通过充分利用平台来加强这些实践，从而实现持续交付的可持续性和可扩展性。
- en: 'In this chapter, we want to start off right by covering the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们希望通过涵盖以下内容来正确开始：
- en: Green from go!
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Green from Go!**'
- en: Pairing and mobbing
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配对编程与集体编程
- en: The container-native approach
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器原生方法
- en: 'Pipelines: CI-CD²'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道：CI-CD²
- en: Everything as code
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一切皆代码
- en: Developer workflows
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者工作流
- en: Green from Go!
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**Green from Go!**'
- en: '**Green from go!** really just means setting yourself up the correct way when
    kicking off a new piece of work. For us, that means having all our foundational
    pieces of software up and running before writing any application software. It
    is another mantra of ours. Much like **show, not tell**, this one is all about
    getting things working with a light touch into a usable state.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**Green from Go!** 实际上意味着在开始新的工作时，以正确的方式为自己铺路。对我们来说，这意味着在编写任何应用程序软件之前，先确保所有基础软件组件都已启动并运行。这是我们另一个座右铭。就像**展示，而非讲述**一样，这个理念的核心是通过轻松的方式使事物达到可用状态并开始运作。'
- en: For example, take choosing the tool we want to use to automate the building
    of our code, such as Jenkins or Tekton, or choosing how we manage secrets or access
    to private information. The ambition with **green from go!** should be obvious
    – clear the pathway to empower developers to get on and do what they do best –
    writing amazing, high-quality software that delights end users.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，选择我们想要用来自动化构建代码的工具，如 Jenkins 或 Tekton，或者选择如何管理机密或访问私密信息。**Green from Go!**
    的目标应该很明确——清除障碍，赋能开发人员，让他们专注于做他们最擅长的事情——编写出令人惊叹的高质量软件，给最终用户带来愉悦的体验。
- en: When we engage in any new piece of software delivery, we always ensure the tools
    we need to do our jobs are in place. We will have picked a few that will help
    us automate taking our code, compiling it, and delivering it to an environment
    where it can be tested. This means all the tools need to be re-creatable from
    scripts or another mechanism so we can easily kick-start any engagement to the
    same level with consistency and the learning from each run can be brought to the
    next one.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始任何新的软件交付任务时，我们总是确保完成工作的工具已经到位。我们会选择一些工具，帮助我们自动化代码的提取、编译，并将其交付到可以进行测试的环境中。这意味着所有工具都需要能够通过脚本或其他机制重新创建，这样我们可以轻松启动每次工作，并保持一致性，同时将每次运行的学习成果带入下一个任务。
- en: Green from go! will also include any reference apps or pipelines using the tools.
    This could be a simple AngularJS application scaffold with an end-to-end build
    process running against it, proving that we can take code and deliver it to users.
    The level of complexity of this process should be low enough to allow the teams
    to evolve it to their specific needs. For example, a team might want to do more
    non-functional testing in their pipeline, or perhaps another team wants to try
    out a new cool testing framework. The priority here is to have enough of a foundation
    to not slow the team down in doing these repeatable tasks when kicking off new
    work but to get them focused on writing new functionality.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**Green from Go!** 还将包括使用这些工具的任何参考应用程序或管道。这可能是一个简单的 AngularJS 应用程序框架，配有完整的构建过程，确保我们能够将代码交付给用户。这个过程的复杂性应足够低，以便团队根据特定需求进行演化。例如，一个团队可能希望在其管道中进行更多的非功能性测试，或者另一个团队可能想尝试一个新的酷炫测试框架。这里的优先级是，确保有足够的基础，以便在启动新工作时不会拖慢团队执行这些可重复任务的速度，而是让他们专注于编写新功能。'
- en: It's also important to not have too much in the kit bag – it is our experience
    that when bringing new teams on board using an accelerator, the technical burden
    it can have can cause some team members to not engage with it. In order for teams
    to take ownership and maintain something that accelerates their delivery, they
    often need to feel like they helped to build it. If something is too complex to
    engage with, it becomes "that thing that Brian knows all about, so I don't need
    to know it." This kind of behavior is dangerous in a team as it can lead to silos
    and gaps in the team's collective ownership and responsibility. Often, when the
    build system then fails or breaks in some way, that person becomes the single
    point of failure when trying to recover it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是不要让工具包过于复杂——我们的经验是，当引入新团队使用加速器时，它可能带来的技术负担会导致一些团队成员不愿参与其中。为了让团队真正拥有并维护一个加速他们交付的工具，他们通常需要感觉到自己参与了构建过程。如果某样东西过于复杂，无法投入使用，它就变成了“布莱恩非常了解的东西，所以我不需要了解”。这种行为在团队中是危险的，因为它可能导致孤岛效应，破坏团队的集体所有权和责任。当构建系统出现故障或破裂时，那个了解这一切的人就会成为单点故障，恢复过程中的瓶颈。
- en: In the next section, let's look at two practices that help build collective
    ownership and understanding.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨两种有助于建立集体所有权和理解的实践。
- en: Pair Programming and Mob Programming
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配对编程与集体编程
- en: Pair programming and mob programming help us deal with a phenomenon that people
    term **Unicorn Developers**. It has various names across different regions and
    companies, such as **the Hero Developer** or **the Rockstar Developer**. But we
    all can identify who they are when we see them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 配对编程和集体编程帮助我们应对人们所称的**独角兽开发者**现象。这个现象在不同地区和公司有不同的名字，例如**英雄开发者**或**明星开发者**。但当我们看到他们时，我们都能认出他们。
- en: For those who don't know; the Unicorn Developer is the one who has all the knowledge
    and keeps it to themselves. They're the person who writes the most magnificent
    code, and the code that is usually the least understood. They have all the keys
    and secrets in their head, including all the ideas and knowledge. They are often
    the one producing so much new work that they don't have time to document it, meaning
    no one else can continue on the work in their absence. At this point, you can
    probably identify if your team has a Unicorn; it may even be you!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不太了解的人来说；独角兽开发者是那种掌握所有知识却将其保留给自己的人。他们是写出最华丽代码的人，而这些代码通常是最难理解的。他们的脑袋里充满了所有的钥匙和秘密，包括所有的想法和知识。他们往往是产出大量新工作的那个人，以至于没有时间进行文档记录，这意味着当他们不在时，其他人无法继续工作。此时，你可能已经能够识别出你的团队是否有一个独角兽开发者；甚至这可能是你自己！
- en: '![](img/B16297_06_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_02.jpg)'
- en: 'Figure 6.2: The Unicorn'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：独角兽
- en: So why do we have a problem with the Unicorn?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们会有独角兽的问题呢？
- en: The Unicorn is a bottleneck and an icon of failed projects. They are the single
    point of failure in the system. When the Unicorn goes on holiday, projects grind
    to a halt. When things go wrong, the Unicorn has to step in to fix things, meaning
    new work cannot be completed while they are preoccupied.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 独角兽开发者是瓶颈，是失败项目的象征。他们是系统中的单点故障。当独角兽休假时，项目就会停滞不前。当出现问题时，独角兽必须介入解决问题，这意味着在他们忙于解决问题时，新的工作无法完成。
- en: 'Organizations want to create high-performing teams around their products –
    they want entire teams of **Rockstars**. A great philosophy in achieving this
    is to "mob to learn, pair to build":'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 组织希望围绕其产品创建高效能的团队——他们希望拥有一整支**明星团队**。实现这一目标的一个重要理念是“集体学习，配对构建”：
- en: Pair programming involves two engineers working together with one computer on
    one problem at a time.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配对编程是指两名工程师共同使用一台计算机来解决一个问题。
- en: Mob programming[1](#footnote-023) involves an entire team working together with
    one machine to solve one problem.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集体编程[1](#footnote-023)是指整个团队共同使用一台机器来解决一个问题。
- en: Pairs and mobs of engineers allow for more knowledge transfer and create a shared
    understanding of the problem and the journey to get to the solution.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 成对编程和集体编程能够促进更多的知识传递，并且帮助大家共同理解问题和解决方案的过程。
- en: Mob to Learn, Pair to Build
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集体学习，配对构建
- en: To understand why pairing is different, let's use an analogy. Imagine you're
    a carpenter and you look at a magnificent rocking chair. What do you learn from
    seeing the completed piece? Probably not a lot; you might see how one or two pieces
    connect, but not all of them. Now imagine you worked with the carpenter assembling
    and crafting the pieces. You'd get to experience the hidden parts, the joinery
    that was used, how it was created, and how it's all connected. You'd identify
    the problems faced while fitting the parts together and understand why they're
    assembled in a given order. You could take a step back and review the furniture
    as it's being built, giving you a better perspective on the creation process.
    The same applies when writing and engineering software. Pairing makes better programmers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解配对编程的不同，我们可以用一个类比。假设你是一个木匠，你看到了一把精美的摇椅。你从看到这件完成的作品中学到了什么？可能不多；你也许会看到一两个部件如何连接，但不会了解所有的连接方式。现在想象你和木匠一起组装和制作这些部件。你会体验到隐藏的部分、使用的榫接技术、是如何制作的以及它们如何连接的。你会发现拼接部件时遇到的问题，并理解它们为什么按照特定的顺序组装。当你在建造的过程中能退一步审视这件家具时，你能更好地理解整个创作过程。同样的道理适用于软件的编写和工程设计。配对编程能培养更好的程序员。
- en: 'I can hear the skeptics out there thinking to themselves, hmmm sounds like
    two developers doing one person''s job. Doesn''t sound very cost effective to
    me…. Well, there are a number of interesting advantages to pair programming and
    mobbing:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以听到那些怀疑论者在心里想，嗯，这听起来像是两个开发者做一个人的工作。对我来说，这并不具有成本效益……嗯，配对编程和集体编程有很多有趣的优势：
- en: '**Mentoring of team members**: New team members can be brought up to speed
    quickly when they work alongside others, tackling the same problem as someone
    who knows the code better. Sharing tips and tricks or shortcuts can widen both
    pairs'' skill depth. This sharing can also bring junior associates up to speed
    very rapidly.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队成员的指导**：当新成员与其他人一起工作，解决与熟悉代码的人共同面对的问题时，可以很快跟上进度。分享技巧、窍门或快捷方式可以增加配对成员的技能深度。这种分享也能帮助初级开发者迅速提升。'
- en: '**Half the code**: When you ask an organization to spend two developers on
    one problem, the usual math kicks in of "won''t that mean half the code gets written?
    In truth, hopefully even less code gets written! Two minds working on the same
    problem makes for more efficiently written code, so less spaghetti.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码量减半**：当你要求一个组织让两个开发者共同解决一个问题时，通常的思维方式是“那是不是意味着只有一半的代码能写出来？”实际上，理想情况下，写出的代码甚至会更少！两个大脑共同解决同一个问题能写出更高效的代码，因此避免了过度复杂的代码。'
- en: '**No pull requests**: Pairing means you have to share your thought process
    with your pair. This synchronization means code is being reviewed as it''s written.
    Often, people reviewing pull requests are too busy writing their own code and
    they can only give very superficial reviews. When you pair, you review as you
    go and therefore write leaner, better-understood code. You won''t cut corners
    when pairing as someone is watching.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有拉取请求**：配对编程意味着你必须与配对者分享你的思考过程。这种同步意味着代码在编写时就会被审查。通常，审查拉取请求的人太忙于编写自己的代码，他们只能给出非常表面的审查。当你进行配对编程时，你会在过程中进行审查，因此写出的代码更简洁、理解更深刻。配对编程时，你不会偷工减料，因为有人在看着你。'
- en: '**Team bonding**: Humans are social creatures; we share and interact all the
    time. Pairing and mobbing facilitates this interaction. Instead of sitting in
    a room with headphones in, ignoring the world around you, developers in pairs
    look happier. A room with mobbing and pairing going on is louder. Happy coders
    lead to better code.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队凝聚力**：人类是社会性动物，我们总是进行交流和互动。配对编程和集体编程促进了这种互动。与其一个人戴着耳机坐在房间里忽视周围的世界，配对编程的开发者看起来更开心。进行配对和集体编程的房间会更热闹。快乐的程序员能写出更好的代码。'
- en: '**The knowledge stays in the team**: With more than one mind solving the same
    problem, the understanding and logic stays with them. As pairs naturally shuffle
    from task to task, the depth of knowledge stays with the team and not with an
    individual. This means when holidays or even flu season take over, the team can
    still continue to work at pace knowing the Unicorn is not leaving with key information.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**知识留在团队中**：通过多个人共同解决同一个问题，理解和逻辑将会留在团队中。当配对成员自然地从任务到任务转换时，知识的深度将留在团队，而不是某个个体身上。这意味着，当假期或流感季节来临时，团队仍然可以保持工作进度，因为团队不会因为某个“独角兽”离开而失去关键信息。'
- en: '[1](#footnote-023-backlink) A relatively new practice championed by Woody Zuill
    – [https://woodyzuill.com/](https://woodyzuill.com/)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](#footnote-023-backlink) 由Woody Zuill倡导的一种相对较新的实践 – [https://woodyzuill.com/](https://woodyzuill.com/)'
- en: '![](img/B16297_06_03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_03.jpg)'
- en: 'Figure 6.3: Mob programming in action'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3：集体编程实践
- en: When tackling new problems (whether that's a new framework, a new language,
    or even a particularly hard problem), we will all group together. Huddled around
    one computer with a very large screen, we can explore the problem we're trying
    to solve. We mob around the problem until the cross-functional team is satisfied
    that they have enough knowledge or a rough scaffold of how to complete their tasks.
    The team then breaks away into groups of two to pull items from the backlog and
    begin implementation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决新问题时（无论是新的框架、新的语言，还是特别难的问题），我们都会聚集在一起。大家围坐在一台大屏幕电脑前，探索我们要解决的问题。我们围绕问题进行集体协作，直到跨职能团队确认他们已经掌握了足够的知识或拥有了解决问题的大致框架。然后，团队会拆分成小组，每组两人，从待办事项中提取任务并开始实施。
- en: '![](img/B16297_06_04.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_04.jpg)'
- en: 'Figure 6.4: Pair programming in action'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4：配对编程实践
- en: Mobbing and pairing allows teams to cross-skill. Sharing experience and expertise
    leads to better teams. Well-oiled teams working like this can continue to build
    their product sustainably and at pace, driving toward outcomes, not outputs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 集体编程和配对编程使团队能够跨领域学习。经验和专业知识的共享能促进更好的团队合作。像这样高效运作的团队可以持续并迅速地推动产品建设，专注于成果而非单纯的输出。
- en: You can learn more and collaborate about these practices by going to the Open
    Practice Library site at [https://openpracticelibrary.com/practice/pair-programming/](https://openpracticelibrary.com/practice/pair-programming/)
    and [https://openpracticelibrary.com/practice/mob-programming/](https://openpracticelibrary.com/practice/mob-programming/).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问 Open Practice Library 网站上的[https://openpracticelibrary.com/practice/pair-programming/](https://openpracticelibrary.com/practice/pair-programming/)
    和[https://openpracticelibrary.com/practice/mob-programming/](https://openpracticelibrary.com/practice/mob-programming/)来了解更多并合作交流这些实践。
- en: Containers and Being Container-Native
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器与容器原生
- en: 'Before we can define exactly what containers are (hint: they are Linux processes!)
    and what container-native means, we need to look back in time to see what led
    to containers.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能准确地定义什么是容器（提示：它们是 Linux 进程！）以及什么是容器原生之前，我们需要回顾一下历史，看看是什么推动了容器的出现。
- en: Container History
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器的历史
- en: 'If you are over a certain age (over 30!), it is very likely your first computer
    program involved compiling source code and statically linking it with libraries
    from the operating system. Computer scientists then invented dynamic linking –
    which is great: you could patch one library and all of the programs you had written
    would pick up that change once restarted. This of course created a different problem
    – managing all of the dependencies. Packaging technologies such as RPM and YUM
    were created to help solve the dependency problem when distributing and managing
    Linux operating systems. Operating system distributions are one mechanism for
    collaboratively sharing and managing lots of different software packages at scale,
    and ultimately it is the software communities that evolve around these different
    software packages that solve real-world problems.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经超过了某个年龄（超过30岁！），很可能你写的第一段程序涉及编译源代码，并将其与操作系统中的库静态链接。之后，计算机科学家发明了动态链接技术——这很好：你只需修补一个库，所有你写的程序在重新启动后都会自动采用该变更。当然，这也带来了新的问题——如何管理所有依赖。像
    RPM 和 YUM 这样的打包技术被创建出来，以帮助解决在分发和管理 Linux 操作系统时的依赖问题。操作系统的发行版是一个协作共享和管理大量不同软件包的机制，最终围绕这些软件包形成的软件社区解决了实际问题。
- en: Of course, running your application on one physical machine is fine, but running
    lots of applications across lots of machines becomes a standard requirement as
    you scale. Virtualization solved how to run many operating systems on one machine
    in an isolated fashion. Indeed, the prominent form of cloud computing has been
    running virtual machines on someone else's hardware.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，运行一个应用程序在一台物理机上没问题，但当你需要在多台机器上运行大量应用程序时，随着规模的扩大，这就成为了标准需求。虚拟化技术解决了如何在一台机器上以隔离方式运行多个操作系统的问题。实际上，云计算的主流形式就是在他人的硬件上运行虚拟机。
- en: Virtualized infrastructure solved many problems of running applications at scale.
    However, configuring all of the pieces required to manage a fleet of **virtual
    machines** (**VMs**) leading to an explosion of tooling and technology related
    to configuration management. There was also the problem of "VM sprawl" – lots
    of VMs everywhere using too many resources that were difficult to patch and manage
    as a whole. Every application was managed independently, possibly by different
    teams. It was seen as desirable to reduce the interdependency between each application
    and so each application was also deployed in its own VM. To help control this
    spread of VMs, they were managed centrally by an infrastructure and operations
    team. Silos between teams were built! Many tools were created to help configure
    VMs. Each VM has overhead for running system processes and daemons, and so a lot
    of effort has been spent building tools that help avoid over-allocating machine
    resources to help save money.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化基础设施解决了大规模运行应用程序的许多问题。然而，管理一大批**虚拟机**（**VMs**）所需配置的所有组件，导致了与配置管理相关的工具和技术的爆炸性增长。还有“虚拟机泛滥”的问题——大量虚拟机到处都是，占用了太多资源，且很难整体修补和管理。每个应用程序都是独立管理的，可能由不同的团队负责。为了减少每个应用程序之间的相互依赖，每个应用程序也被部署在自己的虚拟机中。为了控制虚拟机的扩展，这些虚拟机由基础设施和运维团队集中管理。团队之间的隔阂也因此形成！许多工具被创建出来帮助配置虚拟机。每个虚拟机都有运行系统进程和守护进程的开销，因此，许多精力被投入到构建工具上，帮助避免过度分配机器资源，从而节省成本。
- en: For developers, the user interface in a VM deployed within an organization was
    not particularly self-service. Requesting a VM to be provisioned takes time. Workflow,
    ticketing, and provisioning systems were automated to try and help speed up this
    service request process. This was made radically better by public cloud services
    with an API-driven infrastructure, where provisioning a VM takes minutes and there
    is real self-service for developers. The control and VM sprawl issues still exist,
    though.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发人员来说，部署在组织内部的虚拟机（VM）用户界面并不特别具备自助服务功能。请求提供虚拟机的过程需要时间。工作流、票务和供应系统已自动化，以帮助加速此服务请求过程。然而，通过公共云服务，API驱动的基础设施使得虚拟机的提供只需要几分钟，而且开发人员可以真正实现自助服务。不过，控制和虚拟机泛滥的问题仍然存在。
- en: The application stack that developers used is still dependent on the operating
    system and libraries packaged into the VM that came with the kernel (for example,
    libc, libssl). And developers were usually not allowed to change the VM configuration,
    either because of perceived security or stability concerns. This was an infrastructure
    or operations team responsibility. Often, VMs were not easy to update, patch,
    and manage. It was not clear to the infrastructure or operations team what the
    effect of updating and rebooting a machine would have on the applications they
    supported.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员使用的应用堆栈仍然依赖于包含在虚拟机中的操作系统和库，这些虚拟机是与内核一起提供的（例如libc、libssl）。并且开发人员通常不允许更改虚拟机配置，可能是出于安全性或稳定性考虑。这通常是基础设施或运维团队的责任。通常，虚拟机更新、修补和管理起来并不容易。基础设施或运维团队不清楚更新和重启一台机器会对他们支持的应用程序产生什么影响。
- en: How Containers Work
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器工作原理
- en: It is often said that the journey of containers is one of **process isolation**.
    The containers concept likely started with chroot in 1979, then graduated to BSD
    Linux jails in the early 2000s where Solaris Containers picked them up in 2004.[2](#footnote-022)
    Solaris zones were a form of technology that isolated and combined system resource
    controls and boundary separation. From the outside, they looked like VMs, but
    they were not.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 人们常说，容器的发展历程是**进程隔离**的历程。容器的概念可能始于1979年的chroot，随后在2000年代初期发展成了BSD Linux监狱，2004年Solaris容器也采用了这一技术。[2](#footnote-022)
    Solaris区域是一种技术形式，结合了系统资源控制和边界隔离。从外部来看，它们像虚拟机，但实际上并不是虚拟机。
- en: '[2](#footnote-022-backlink) [https://www.section.io/engineering-education/history-of-container-technology/](https://www.section.io/engineering-education/history-of-container-technology/)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[2](#footnote-022-backlink) [https://www.section.io/engineering-education/history-of-container-technology/](https://www.section.io/engineering-education/history-of-container-technology/)'
- en: Technology companies that run a large number of workloads are always looking
    at ways to save resources and ultimately be more efficient. Roll forward to 2006
    and a number of technology enhancements were made within the core Linux kernel
    that was related to the isolation of Linux processes. Google introduced the technology
    initially called process containers that was later renamed cgroups. It was designed
    for limiting, accounting, and isolating resource usage (CPU, memory, disk I/O,
    and network) of a collection of processes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 运行大量工作负载的科技公司总是寻找节省资源和最终提高效率的方法。回到2006年，核心 Linux 内核中进行了多项与 Linux 进程隔离相关的技术增强。谷歌最初引入了一项名为“进程容器”的技术，后来更名为
    cgroups。它旨在限制、计量和隔离一组进程的资源使用（CPU、内存、磁盘 I/O 和网络）。
- en: A novel solution to the dependency problem for containers was introduced by
    Docker in 2013\. Packaging applications and their dependencies into container
    images lead to an explosion in popularity for containers. Container images were
    made freely available and distributed online via container registries such as
    [dockerhub.io](http://dockerhub.io) and [quay.io](http://quay.io).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 2013年，Docker 提出了一个解决容器依赖问题的新方案。将应用程序及其依赖项打包成容器镜像，导致容器的普及爆炸式增长。容器镜像被免费提供并通过容器注册中心在线分发，如[dockerhub.io](http://dockerhub.io)和[quay.io](http://quay.io)。
- en: A running container is really just Linux processes with extra protections and
    data structures supporting the process in the kernel. Running containers on a
    single machine was easy; running thousands of containers across a compute farm
    was a much harder problem to solve. Enter into the scene container orchestration
    engines of which the Kubernetes project is by far the most widely used today.
    The OpenShift Container Platform is a product that brings together Linux, Kubernetes,
    and container technologies to allow enterprises to run containers safely and securely
    at scale in the enterprise.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 运行中的容器实际上只是具有额外保护和数据结构支持的 Linux 进程，这些数据结构支持内核中的进程。在单台机器上运行容器很容易；在计算农场中跨越成千上万个容器则是一个更加棘手的问题。于是，容器编排引擎登场，其中
    Kubernetes 项目无疑是目前使用最广泛的。OpenShift 容器平台是一个结合了 Linux、Kubernetes 和容器技术的产品，允许企业在规模化环境中安全、可靠地运行容器。
- en: Of course, to get to real business value, it is not enough to package your applications
    as containers and deploy a Kubernetes platform such as OpenShift. Just because
    you build it does not mean that all users will immediately flock to the platform!
    Modern application delivery using trusted supply chains forces new tools and ways
    of working onto your teams. New behaviors are required.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，要获得真正的商业价值，仅仅将应用程序打包为容器并部署一个像 OpenShift 这样的 Kubernetes 平台是不够的。仅仅因为你构建了它，并不意味着所有用户会立即涌向该平台！使用受信任供应链的现代应用交付迫使你的团队采用新的工具和工作方式。新的行为方式是必须的。
- en: With containers, the developer's user experience has been radically changed.
    Developers can now self-service their applications without having to go through
    the provisioning of a VM. Of course, someone still had to provision the platform!
    Provisioning and starting of containers took seconds and minutes, and today with
    serverless-focused technology stacks, milliseconds.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器后，开发者的用户体验发生了彻底变化。开发者现在可以自助服务他们的应用程序，而无需经过虚拟机的配置。当然，仍然有人需要配置平台！容器的配置和启动只需几秒钟到几分钟，而今天，借助专注于无服务器技术栈的支持，甚至可以在毫秒级别完成。
- en: Developers can control the packaging, running, and upgrading of their applications
    easily using container images. The application is no longer tied to the version
    of libraries packaged in the kernel. It is possible to pull out all of an application's
    code and dependencies into a container image. You can run multiple versions of
    the same application together without being dependent on the same version of libraries
    in the kernel.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以轻松控制应用程序的打包、运行和升级，使用容器镜像即可实现。应用程序不再依赖于内核中打包的库版本。你可以将一个应用程序的所有代码和依赖项提取到一个容器镜像中。你可以同时运行同一个应用程序的多个版本，而不必依赖于内核中相同版本的库。
- en: The immutable nature of a container image also improved the overall service
    quality of applications. Teams could ensure that exactly the same container image
    would be run in different environments, such as development and production. To
    be able to run this immutable container image in different environments, developers
    started to learn that by externalizing their application configuration they could
    easily run the same container anywhere. The application configuration management
    was now built in as part of the container deployment process and the platform.
    This led to clearer boundaries between what the **developers** controlled (their
    applications and configuration) and what **ITOps** controlled (the platform itself).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像的不变性还提高了应用程序的整体服务质量。团队可以确保在不同的环境中运行完全相同的容器镜像，比如开发环境和生产环境。为了能够在不同环境中运行这种不变的容器镜像，开发人员开始学习通过外部化应用程序配置，他们可以轻松地在任何地方运行相同的容器。应用程序配置管理现在作为容器部署过程和平台的一部分构建在其中。这使得**开发人员**控制的部分（他们的应用程序和配置）与**ITOps**
    控制的部分（平台本身）之间的边界更加明确。
- en: '![](img/B16297_06_05.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_05.jpg)'
- en: 'Figure 6.5: Containerization providing clear boundaries'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5：容器化提供清晰的边界
- en: In a multi-tenant environment, different groups of users can isolate via projects
    so as to increase utilization of the underlying infrastructure. In OpenShift there
    are built-in mechanisms for controlling network ingress and egress, role-based
    access control, and security, as well as out-of-the-box metrics, monitoring, and
    alerting capabilities. The platform supports the idea of mounting persistent data
    storage into your containers. The platform supports these stateful applications
    so that when a container is stopped/restarted or moved to another compute node,
    so too is the persistent volume.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在多租户环境中，不同的用户组可以通过项目进行隔离，从而提高底层基础设施的利用率。在 OpenShift 中，内置了控制网络流入和流出、基于角色的访问控制和安全性等机制，以及开箱即用的指标、监控和警报功能。该平台支持将持久数据存储挂载到容器中。平台支持这些有状态的应用程序，以便当容器停止/重启或迁移到另一个计算节点时，持久卷也会随之移动。
- en: The demarcation of team roles within a container ecosystem is different compared
    to virtualized infrastructure. **InfraOps** teams can manage the OpenShift platform
    and supporting infrastructure, while development teams can self-service provision
    and run application services on the platform. It is a "set up and get out of the
    way" mentality. Of course, there are still complexities that need to be discussed
    and agreed upon before you can reach this goal. When to run cluster-wide services
    and operators, how to perform rolling platform upgrades while managing business
    application service levels under change, security, storage, high availability,
    and load balancing/networking concerns usually require everyone's involvement.
    It is the coming together of these teams and the DevOps conversations between
    them that form the backbone of modern DevOps practices today.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器生态系统中，团队角色的划分与虚拟化基础设施不同。**InfraOps** 团队可以管理 OpenShift 平台及其支持的基础设施，而开发团队则可以自助服务来部署和运行平台上的应用服务。这是一种“设置好后就不干涉”的心态。当然，在达到这一目标之前，仍然存在需要讨论和达成一致的复杂问题。何时运行集群级别的服务和操作员，如何在管理业务应用服务级别变化的同时执行滚动平台升级，安全性、存储、高可用性以及负载均衡/网络问题通常需要每个人的参与。正是这些团队的汇聚和他们之间的
    DevOps 对话，构成了当今现代 DevOps 实践的骨架。
- en: You can learn more and collaborate about the containers practice by going to
    the Open Practice Library page at [openpracticelibrary.com/practice/containers](http://openpracticelibrary.com/practice/containers).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问 [openpracticelibrary.com/practice/containers](http://openpracticelibrary.com/practice/containers)
    页面来了解更多并与他人合作容器实践。
- en: Pipelines — CI or CD or CD²?
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流水线 — CI、CD 还是 CD²？
- en: '*"The job of a pipeline is to prove your code is not releasable."* – Jez Humble'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*“流水线的工作是证明你的代码不可发布。”* – Jez Humble'
- en: OK – let's set the scene and get some basics out of the way. How do we take
    our code from individual lines of text on a laptop to being an application running
    in a container in production? Well, there are lots of ways with lots of kooky-sounding
    names! Teams call the journey our software goes through a pipeline, but there
    are numerous ways to implement one.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 好的——让我们设置场景，并先解决一些基本问题。我们如何将代码从笔记本上的单行文本转化为在生产环境中运行的容器中的应用程序？嗯，有很多方式，名字也各不相同！团队将软件的旅程称为流水线，但实现方式有很多种。
- en: Let's pause for a minute and think about what a software pipeline really is
    with the help of our friend Derek, the DevOps Dinosaur!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂停片刻，借助我们的朋友 Derek，DevOps 恐龙，来思考一下什么才是软件管道！
- en: Derek the DevOps Dinosaur
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DevOps 恐龙 Derek
- en: '![](img/Donal.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Donal.jpg)'
- en: Before I joined the Red Hat Open Innovation Labs team, I was a developer working
    for a large system integrator. While there, someone asked me to explain what a
    pipeline is – referring to some build automation I had created. The person asking
    me was an executive partner and had very limited technical knowledge. He wanted
    to know what a pipeline is in simple language that he could understand and relate
    to when talking to his customers. His questions were fundamental, such as what
    does one look like and what should it do?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在加入 Red Hat Open Innovation Labs 团队之前，我是一名在大型系统集成商工作的开发人员。那时，有人问我解释什么是管道——指的是我创建的某个构建自动化工具。问我的那位是位执行合伙人，他的技术知识非常有限。他想了解什么是管道，用简单的语言解释，让他能理解并在与客户沟通时使用。他的问题很基础，比如管道长什么样，应该做些什么？
- en: While thinking of ways to describe a pipeline in a simplified, relatable way,
    I kept thinking about whether I could explain it in a way that a three-year-old
    would understand – I could probably explain it to him. And so, Derek the DevOps
    Dinosaur was born.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑如何以简化、易于理解的方式描述管道时，我一直在想，是否能用三岁孩子能理解的方式来解释——我应该可以解释给他听。因此，DevOps 恐龙 Derek
    就这样诞生了。
- en: Let's Forget about Software for a Minute…
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 先暂时忘记软件吧…
- en: Imagine for a moment that we're not building software. We're not configuring
    Jenkins, dealing with shells, Ansible, or any other automation tool. Let's imagine
    we're building dinosaurs! Big, scary, tough, monstrous, and ferocious ones with
    lots of teeth! Close your eyes and imagine the scary dinosaur for yourself. Maybe
    you're imagining some kind of hybrid Jurassic Park dinosaur. Think about the parts
    of the dinosaur you'd want to build – how many teeth does it have? How many arms
    and legs? When I think of my scary dinosaur, I think of Derek.️
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，暂时我们不是在构建软件。我们不是在配置 Jenkins、处理 Shell、Ansible 或任何其他自动化工具。让我们想象一下，我们在构建恐龙！大而可怕、坚韧、怪异、凶猛的恐龙，拥有很多锋利的牙齿！闭上眼睛，想象一下那个可怕的恐龙。也许你正在想象某种混合型侏罗纪公园恐龙。想想你想要构建的恐龙的部件——它有多少颗牙齿？多少只手臂和腿？当我想到我的可怕恐龙时，我会想到
    Derek。️
- en: '![](img/B16297_06_06.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_06.jpg)'
- en: 'Figure 6.6: Introducing Derek'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6：介绍 Derek
- en: So, how do we know Derek is as big and scary as I need him to be? Let's start
    with his parts. First, we might analyze each of the individual parts of our dinosaur.
    Give them a quick check-over and ensure they meet the standard we set. For example,
    do I have two arms and two legs for my dinosaur? Has he got enough teeth? If it
    all looks good, we can then pop the parts in the ️Dino-Constructor 5000™.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们怎么知道 Derek 够大、够可怕呢？让我们从他的部件开始。首先，我们可能需要分析恐龙的每一个部件，快速检查一下，确保它们符合我们设定的标准。例如，我的恐龙有两只手臂和两只腿吗？它有足够的牙齿吗？如果一切看起来没问题，我们就可以把这些部件放进
    Dino-Constructor 5000™ 里。
- en: With the Dino-Constructor 5000™ complete, we should hopefully produce our dinosaur,
    Derek.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成 Dino-Constructor 5000™ 后，我们应该能够制造出我们的恐龙，Derek。
- en: '![](img/B16297_06_07.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_07.jpg)'
- en: 'Figure 6.7: Introducing the Dino-Constructor 5000™'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7：介绍 Dino-Constructor 5000™
- en: How Do I Know My Dinosaur Is Fierce Enough?
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我怎么知道我的恐龙够凶猛？
- en: So, we've got a Dinosaur. But remember, we're here to build ferocious scary
    dinosaurs that are tough and fit. How do we know Derek is tough enough? Well,
    we could put him through a series of obstacles. Let's build an obstacle course
    for Derek.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们有了一只恐龙。但记住，我们的目标是打造强壮、可怕的恐龙，既坚韧又健康。我们怎么知道 Derek 够强壮呢？嗯，我们可以让他通过一系列的障碍。让我们为
    Derek 建造一个障碍课程吧。
- en: '![](img/B16297_06_08.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_08.jpg)'
- en: 'Figure 6.8: The dinosaur obstacle course'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8：恐龙障碍课程
- en: We'll start him on a climbing wall, much like the one you'd see recruits on
    in an army movie. Then if he's lucky enough to get over that hurdle, he's on to
    the next obstacle where he must jump over some spikes, Indiana Jones style! Next,
    we check how fit our dinosaur is; if he's able to run fast on the treadmill, he
    gets to pass on to the next step. Here he must try swimming past some fish that
    are trying to nibble on him. Once through that, perhaps he has to jump through
    a ring of fire. If Derek is capable and makes it through the obstacles, he can
    then run toward his pen – however, if Derek is not careful, he may be stopped
    by the swinging blade that was menacingly looming over him the whole time, like
    something from a Mario level. At any time, the blade could drop and stop Derek
    dead in his tracks. Let's for a moment assume Derek was careful and has made it
    into the pen where the other dinosaurs are.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让他从一个攀岩墙开始，类似于你在军队电影中看到的新兵们所用的那种。如果他足够幸运地跨过了这个障碍，他将进入下一个障碍，在那里他必须像印第安纳·琼斯一样跳过一些尖刺！接下来，我们检查一下我们的恐龙有多健康；如果它能够在跑步机上快速奔跑，他就可以进入下一步。在这一阶段，它必须尽力游过去，躲避那些试图咬它的鱼。一旦通过这一关，也许它还得跳过一圈火焰。如果德里克足够能干，并顺利通过这些障碍，他就可以跑向他的围栏——然而，如果德里克不小心，他可能会被一直悬在他上方、威胁重重的摆动刀片挡住，就像马里奥关卡中的场景一样。任何时候，刀片都可能掉下来，直接把德里克挡住。假设德里克小心翼翼，最终进入了围栏，那里有其他的恐龙。
- en: '![](img/B16297_06_09.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_09.jpg)'
- en: 'Figure 6.9: The dinosaur pen'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：恐龙围栏
- en: Derek can now live out his days with the other dinosaurs in the Dino Petting
    Zoo, Danny and Debbie. However, unfortunately for Derek, Debbie the dinosaur is
    quite mean to him. She keeps stealing all of the precious grass and water that
    Derek likes to eat (Derek is vegetarian in this metaphor!). So, in order to give
    Derek the isolation and correct amount of things he needs to be strong and healthy,
    the zookeeper comes along and moves him to a new pen.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 德里克现在可以和其他恐龙一起在恐龙宠物园里度过余生，和丹尼、黛比一起生活。然而，不幸的是，黛比这只恐龙对德里克相当刻薄。她总是抢走德里克喜欢吃的宝贵草和水（在这个比喻中，德里克是素食者！）。因此，为了给德里克提供必要的隔离和足够的资源，使他保持强壮和健康，饲养员过来，把他移到了一个新围栏里。
- en: Derek, as it turns out, is quite a popular dinosaur at the zoo, so the zookeeper
    decides to make clones of him and puts them all in a pen with Derek. He is happy
    here and has enough of all the things he needs to survive.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，德里克是动物园里相当受欢迎的恐龙，所以饲养员决定为他克隆出几个，并把它们都放进和德里克同一个围栏里。他在这里过得很开心，拥有生存所需的一切。
- en: '![](img/B16297_06_10.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_10.jpg)'
- en: 'Figure 6.10: The zookeeper moves Derek to a new pen'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10：饲养员把德里克移到一个新围栏
- en: But Wait – We're Building Software, Not Dinosaurs!
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 但等等——我们在构建软件，而不是恐龙！
- en: Sorry to shatter the illusion, but yes, we're (sadly) not in the business of
    making dinosaurs. We are here to build software applications. What we have just
    done to our dinosaur is the same thing we do to our code base on every commit.
    We build our code, run it through a series of obstacles, and then deploy it for
    our users to consume it. This is a pipeline; it's quite simple really!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对不起打破这个幻想，但实际上，我们（遗憾的是）并不从事恐龙制造业。我们在这里是为了构建软件应用程序。我们刚刚对我们的恐龙所做的，就是我们在每次提交代码时对代码库所做的事情。我们构建代码，将其通过一系列的障碍，然后部署给我们的用户使用。这就是一个流水线，其实非常简单！
- en: Let's look at our dinosaur pipeline in more detail. In the first step, we assess
    the individual pieces that make up our dinosaur – its arms, legs, teeth, and so
    on. We ask questions such as are there enough parts? Does each hand have three
    fingers? I often think of this step as the static code analysis part of a pipeline.
    In the JavaScript world, this could be as simple as linting the code base or perhaps
    even running something more complex such as SonarQube to inspect the code quality.
    The Dino-Constructor 5000™ represents the compile step of any language.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看一下我们的恐龙流水线。在第一步，我们评估组成恐龙的各个部件——它的手臂、腿、牙齿等。我们会问一些问题，比如部件是否足够？每只手是否有三根手指？我常把这一步看作是流水线中的静态代码分析部分。在JavaScript世界里，这可能就像是对代码库进行简单的lint检查，甚至可能运行一些更复杂的工具，比如SonarQube来检查代码质量。Dino-Constructor
    5000™代表了任何编程语言中的编译步骤。
- en: The obstacle course we built for Derek represents the steps we should carry
    out to further assess our code quality. The initial hurdle Derek must get over
    could represent some unit testing. It is important that these obstacles are tough
    enough of a challenge while also not being so easy that they provide no value.
    For example, if Derek can make it over the climbing wall with ease, then it's
    probably not testing all the parts of him. Imagine for a moment that we decided
    to add another arm to Derek. We now have a terrifying three-armed dinosaur! If
    we were to ask him to climb the wall again, he would find it much simpler than
    before. In this regard it is important to increase the difficulty of the climb,
    perhaps widening the gaps or making it steeper so it presents more of a challenge.
    Thinking back to code, the logic still holds. When we introduce new features to
    our applications, we need to improve the testing coverage to include this. Writing
    tests is not a one-time thing; it must continue to evolve alongside our application
    development.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 Derek 构建的障碍赛道代表了我们应当采取的步骤，以进一步评估我们的代码质量。Derek 必须跨越的初始障碍可能代表一些单元测试。重要的是，这些障碍应该具有足够的挑战性，同时又不能太简单，否则就没有价值。例如，如果
    Derek 能轻松越过攀岩墙，那么这可能并没有全面测试他的各个方面。假设我们决定给 Derek 添加一只额外的手臂。现在我们有了一个可怕的三臂恐龙！如果我们让他再爬一次墙，他会发现比以前简单得多。在这个方面，增加难度是很重要的，可能需要加大缝隙的宽度或让墙更陡峭，这样才能提出更多的挑战。回想代码，逻辑也是一样的。当我们向应用程序中引入新功能时，我们需要提升测试覆盖率，以包括这些新功能。编写测试并非一次性工作，它必须随着应用程序的开发不断演变。
- en: The other obstacles represent additional testing types. The small piranha pool
    Derek must swim through in order to get to safety could represent some early integration
    tests. The treadmill he must run on may be a kind of performance testing. The
    final obstacle Derek must pass unscathed is the giant blade hanging above him.
    Constantly looming, this testing type is, in my eyes, often the one that gets
    forgotten about. Derek may think he is free and run toward the pen only for the
    blade to drop on him and mean he can go no further – this is an example of security
    testing. Often forgotten about until the last minute, it can be a showstopper
    for final deployment in a lot of cases.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 其他障碍代表了额外的测试类型。Derek 必须游过的小食人鱼池可能代表一些早期的集成测试。他必须跑的跑步机可能是一种性能测试。Derek 必须通过的最后一个障碍是悬挂在他头上的巨大刀片。这个障碍一直悬而不决，在我看来，往往是最容易被忽视的测试类型。Derek
    可能会以为自己已经自由，朝着围栏跑去，结果刀片突然落下，意味着他无法继续前进——这就是安全测试的一个例子。通常在最后一刻才被想到，但在许多情况下，它可能成为最终部署的“拦路虎”。
- en: '![](img/B16297_06_11.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_11.jpg)'
- en: 'Figure 6.11: Failing to make the cut when moving to a new pen'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11：移动到新围栏时未能通过测试
- en: Once Derek arrives at the dinosaur pen, he has to share the space with some
    other dinosaurs. Perhaps, at this point, the code has been deployed to a public
    cloud or a VM with competition for shared resources. Hopefully, by now, the operations
    team has noticed the application is running out of memory or there is a lack of
    compute. To combat this problem, the team might automate the containerization
    of the application. Once the code is in a container, it becomes shippable. We
    can move the container between cloud providers or even just between environments.
    At this stage, the code is packaged up with all of the dependencies it requires
    to run. This ability to move code without the need to rebuild and test can be
    safely achieved by building immutable container images. Versioning the application
    configuration separately from the built software means we can also horizontally
    scale our software easily by running more instances based on user demand.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Derek 到达恐龙围栏，他必须与其他恐龙共享空间。也许此时，代码已经部署到公共云或虚拟机中，并且资源在竞争中共享。希望到此时，运维团队已经注意到应用程序内存不足或计算资源不足。为了解决这个问题，团队可能会自动化应用程序的容器化。一旦代码进入容器，它就变得可以发布。我们可以在云服务提供商之间甚至仅在环境之间移动容器。在这一阶段，代码已经与其运行所需的所有依赖项一起打包。这种无需重新构建和测试即可移动代码的能力，通过构建不可变容器镜像可以安全地实现。将应用程序配置与已构建的软件版本分开，使我们能够轻松水平扩展软件，基于用户需求运行更多的实例。
- en: A Final Thought on Building Dinosaurs
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于构建恐龙的最终思考
- en: All of these testing types can, and should, be automated as part of a software
    pipeline. On each automated process that should execute building, testing, and
    deploying, the code should check if each proceeding step is successful. Through
    this process, teams can deliver new features faster. Teams can introduce new code
    without fear of regression. Container platforms such as Red Hat OpenShift and
    Kubernetes can ensure an application always exists in the desired state. These
    platforms can also be used to run our software pipelines, using build tools such
    as Jenkins to run the stages. Dynamic provisioning of test tools such as Zalenium
    to execute our browser tests as well as using Jenkins to build makes creating
    pipelines repeatable and reusable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些测试类型都可以并且应该作为软件管道的一部分进行自动化。在每个应执行构建、测试和部署的自动化过程中，代码应该检查每个后续步骤是否成功。通过这个过程，团队可以更快地交付新功能。团队可以在不担心回归问题的情况下引入新代码。像Red
    Hat OpenShift和Kubernetes这样的容器平台可以确保应用始终处于期望的状态。这些平台还可以用来运行我们的软件管道，使用构建工具如Jenkins来运行各个阶段。通过动态提供测试工具，如Zalenium执行浏览器测试，以及使用Jenkins构建，使得创建管道变得可重复和可重用。
- en: By automating all steps in a pipeline like this, we can ultimately get the dev
    and ops teams' awesome output into the hands of users quicker.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过自动化管道中的所有步骤，我们最终能够更快地将开发和运维团队的出色成果交到用户手中。
- en: Thanks to Derek, we now know that a pipeline is a series of steps we use to
    build, package, test, and deploy our software. Now, let's look at some of the
    terminology people use to describe a software delivery pipeline.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Derek，我们现在知道管道是我们用来构建、打包、测试和部署软件的一系列步骤。现在，让我们来看一些描述软件交付管道时人们使用的术语。
- en: Continuous Integration
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持续集成
- en: '**Continuous Integration** (**CI**) is a software development practice that
    was popularized by the authors of Extreme Programming. There have been countless
    books written about it but the shortest definitions are sometimes the simplest!
    The three-word definition of CI is to "integrate code continuously." That is to
    say, developers and teams should regularly commit and push their code into the
    repository and have some automated process to compile, package, and test that
    code. This process should happen frequently – many times throughout the day for
    maximum effect.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）是一种软件开发实践，最初由极限编程的作者推广。虽然关于它已经有无数的书籍问世，但最简短的定义有时恰恰是最简单的！CI的三词定义就是“持续集成代码”。也就是说，开发人员和团队应该定期将他们的代码提交并推送到仓库，并有一些自动化过程来编译、打包和测试这些代码。这个过程应该频繁发生——为了达到最大效果，每天进行多次。'
- en: '![](img/B16297_06_12.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_12.jpg)'
- en: 'Figure 6.12: Continuous Integration'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12：持续集成
- en: More teams fall down on this CI hurdle than you may think. Often, teams think
    they are practicing CI when in fact they are not.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 更多团队在这个CI难关上失败的情况比你想象的要多。通常，团队认为他们正在实践CI，但实际上并没有。
- en: Integrate Continuously
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续集成
- en: '![](img/Noel.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Noel.jpg)'
- en: I worked on a Labs residency for a security company a few years ago. The team
    was fairly junior with several team members who'd just graduated. The team decided
    to create feature branches when writing their code so as to not break the workflows
    of others. Unfortunately, this led us to having these branches that lived for
    the duration of the sprint. We had lots of automation that was triggered when
    code was merged but we weren't merging frequently enough.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，我在一个安全公司做了一个Labs驻场。这个团队相当年轻，几个团队成员刚刚毕业。团队决定在编写代码时创建功能分支，以免破坏其他人的工作流程。不幸的是，这导致我们创建了这些在冲刺期间存在的分支。我们有很多自动化流程，当代码合并时会被触发，但我们合并的频率不够。
- en: For two sprints, we had the same mad dash to merge all our features at the end
    of the sprint just before the weekly demo – and it was chaotic, to say the least!
    This resulted in bi-weekly "mini-integrations." We had lots of automation set
    up to validate our code but we were not using it frequently enough. As you can
    imagine, there is nothing continuous about this process – we were not integrating
    continuously!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个冲刺周期中，我们每次都在冲刺结束前，紧急地将所有功能合并，以便进行每周演示——可以说是非常混乱！这导致了每两周一次的“迷你集成”。我们已经设立了大量的自动化来验证我们的代码，但我们并没有足够频繁地使用它。可以想象，这个过程根本不算是持续的——我们并没有进行持续集成！
- en: 'To remedy this, we talked about it over our retrospective. If the tool you''re
    using, in our case Jenkins, can give you data about the frequency of builds or
    its usage stats, these can be great things to print out or bring to a sprint retrospective.
    A brilliant Scrum Master I once worked with always did this and it helped the
    team focus during the retro on actionable things that we could do to make things
    faster. In our case on this residency, we were operating in one-week iterations.
    This meant only four days of actual development time! Through the retrospective,
    we identified a few actions from looking at the data being supplied to the team:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们在回顾会上进行了讨论。如果你使用的工具（在我们的案例中是Jenkins）能够提供构建频率或使用统计数据，那么这些数据可以是很有价值的信息，可以打印出来或带到回顾会议上。我曾与一位非常出色的Scrum
    Master合作，他总是这么做，这帮助团队在回顾会上专注于我们可以采取的实际行动，从而加快进度。在我们这个周期里，我们实行了每周一次的迭代。这意味着实际的开发时间只有四天！通过回顾会，我们根据提供给团队的数据识别出了一些可行的改进措施：
- en: '**Integrate continuously** – This was a big change for us, to try as often
    as possible to merge features together and get that validation we needed to avoid
    the merge hell we were encountering during demos.'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**持续集成** – 这是我们的一次重大变化，尽可能频繁地将特性合并，并获得我们所需的验证，以避免在演示过程中遇到的合并地狱。'
- en: '**Smaller features** – The team realized that work was being broken down into
    too-large chunks. Each chunk was taking most of the sprint to complete. A smaller
    task size for each feature meant we could validate faster in smaller chunks whether
    things would work or not.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**更小的特性** – 团队意识到工作被拆解成了过大的任务块，每个任务块需要花费大部分迭代周期才能完成。将每个特性的任务拆分得更小意味着我们可以更快地验证每个小任务是否可行。'
- en: You can learn more and collaborate about the CI practice by going to the Open
    Practice Library page at [openpracticelibrary.com/practice/continuous-integration](http://openpracticelibrary.com/practice/continuous-integration).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问[openpracticelibrary.com/practice/continuous-integration](http://openpracticelibrary.com/practice/continuous-integration)页面来了解更多并参与持续集成的实践。
- en: Continuous Delivery
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持续交付
- en: '**Continuous Delivery** (**CD**) is a development process where on every code
    change, teams build, test, and package their code such that it can go all the
    way to production. It is delivered to the doorway of production in an automated
    way but not let in. Lots of teams get to this state, and it is a great place to
    get to, but are held back from releasing all the way to production usually due
    to organizational release cadences or additional approvals being required. The
    important thing here is that they could release to production if needs be.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续交付**（**CD**）是一种开发流程，在每次代码更改时，团队会构建、测试并打包代码，使其能够一直部署到生产环境。它以自动化的方式将代码交付到生产环境的门口，但并未真正部署到生产环境。许多团队能够达到这种状态，这本身是一个很好的目标，但通常由于组织发布节奏或需要额外批准，导致它们无法完全发布到生产环境。这里需要注意的是，如果有需要，它们是可以发布到生产环境的。'
- en: '![](img/B16297_06_13.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_13.jpg)'
- en: 'Figure 6.13: Continuous Delivery'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13：持续交付
- en: Building Confidence in the Quality of the Software Delivery Pipeline
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立对软件交付管道质量的信心
- en: '![](img/Donal.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Donal.jpg)'
- en: Early in my career when the concepts of automated testing and CD were new to
    me but still at the bleeding edge for some industries, I was working for a large
    retailer in the UK. They operated a very traditional approach to software deployments
    with a maximum of one release per quarter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我职业生涯的早期，当自动化测试和持续交付的概念对我来说还很陌生，而在一些行业里仍然处于前沿时，我曾为一家英国的大型零售商工作。他们采取了非常传统的软件部署方法，每季度最多发布一次版本。
- en: Deployments were a scary thing to them – they would involve a team of specialists
    who would come in during the dark hours of a Sunday morning to begin their manual
    task. They would take down the website, put up a holding page, and begin working
    through the script they were asked to run. Mostly this was a success, but on some
    occasions when things went wrong, they may have been left with outages for days!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 部署对他们来说是一件令人害怕的事情——这通常需要一组专家团队在周日凌晨的黑暗时刻进场，开始他们的手动任务。他们会先停掉网站，放上一个临时页面，然后开始执行他们被要求运行的脚本。大多数情况下，这个过程是成功的，但有时在事情出错时，他们可能会遇到几天的停机时间！
- en: This engagement was to build a mobile channel for the retailer to reach their
    customers. My role was to write some of the integration services between the mobile
    app and the commerce platform as well as to write a suite of automated integration
    tests. The retailer I was working for was very traditional and so they had in
    their project plan a three-week block prior to going live in which all the testing
    would occur. The retailer thought we were wasting our time writing automated tests
    and radiating the scores on a wall for all to see – they were confident the three-week
    window would be enough!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的目标是为零售商建立一个移动渠道，以便他们与客户互动。我的角色是编写移动应用与电商平台之间的一些集成服务，并编写一套自动化集成测试。我们合作的零售商非常传统，因此他们的项目计划中包含了一个为期三周的时间块，在此期间将进行所有测试。零售商认为我们浪费时间编写自动化测试，并将分数展示在墙上供大家查看——他们确信三周的时间足够了！
- en: Our team was not willing to wait until the end to find out all the issues; they
    wanted feedback as they proceeded. We created a series of automated jobs in Jenkins
    to build the apps and APIs and deploy them to the user acceptance test environment.
    This meant that for months before the testing team was even engaged, we were delivering
    application revisions for them to test. Our automated tests emulated user behavior
    from the mobile app and tested for the happy path and all known error or sad paths
    through calling APIs with different input parameters. We also got hold of the
    user acceptance testing team's regression test scripts that would be manually
    executed and codified them as a set of tests for doing the same API calls. This
    excited the business as they began to see the app evolve. Features were getting
    added and issues were being fixed as they showed it off internally. It was a new
    experience for them, as they were only used to seeing the whole thing at the end.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的团队不愿等到最后才发现所有问题；他们希望在整个过程中得到反馈。我们在 Jenkins 中创建了一系列自动化任务，用于构建应用程序和 API，并将其部署到用户验收测试环境。这意味着，在测试团队参与之前的几个月，我们已经开始交付应用程序的修订版供他们测试。我们的自动化测试模拟了来自移动应用的用户行为，测试了正常路径以及所有已知的错误路径或悲观路径，通过不同输入参数调用
    API。我们还获取了用户验收测试团队的回归测试脚本，这些脚本将被手动执行，并将其编码为一组测试，以执行相同的 API 调用。这让业务方感到兴奋，因为他们开始看到应用程序的不断演变。功能被逐步添加，问题也在内部展示时被修复。这对他们来说是一次全新的体验，因为他们习惯于只在最后才看到完整的结果。
- en: Fast forward to the end of the project and the business had started to see the
    value of the tests we'd written. On every change, we had automated the building
    of the mobile app, deploying it to the app store, and we ran a huge suite of integration
    tests. They continued to do their manual testing phase at the end, which did throw
    up a few bugs (which we then wrote automated tests for and fixed). However, when
    they compared the number of issues found during this phase against other similar
    projects, there were far fewer.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 项目结束时，业务方已经开始意识到我们编写的测试的价值。每次更改时，我们都自动化了移动应用的构建、部署到应用商店，并运行了一大套集成测试。他们继续在最后进行手动测试阶段，确实发现了一些错误（然后我们为其编写了自动化测试并修复了）。然而，当他们将此阶段发现的问题数量与其他类似项目进行对比时，发现问题明显更少。
- en: On the day of go live, the team was all set to push the app to the app stores
    and do the final deployment of the APIs. The retailer had marketing campaigns
    and other events aligned with this go live date, so the pressure was on! The teams
    were making minor app fixes right up to this point. Every change required the
    business to sign off the release, which meant involving the manual test team.
    Due to the pressure of the release window, the business decided to only do a quick
    smoke test of the app to see if the issue being fixed was resolved on a specific
    release candidate. This smoke test passed, so they were ready to roll – however,
    our automated tests threw up two failures in a service delivering product reviews
    within the application. There had been a minor change to the data format in the
    system of record further down the architecture that meant some data transformation
    functions were not working. This was not caught by the manual test team as they
    were not smoke testing this functionality. We flagged it up that our tests had
    spotted a regression, and the release was paused while this issue was resolved.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在上线当天，团队已经准备好将应用程序推送到应用商店并完成API的最终部署。零售商将营销活动和其他事件与上线日期对接，所以压力非常大！团队一直在做小范围的应用修复，直到这一时刻。每次更改都需要业务部门批准发布，这意味着必须涉及到手动测试团队。由于发布窗口的压力，业务部门决定仅对应用程序进行快速的冒烟测试，以确认特定发布候选版本上的问题是否已解决。冒烟测试通过了，因此他们准备好进行发布——然而，我们的自动化测试在一个服务中发现了两个失败，该服务负责应用程序中的产品评论。这是由于在架构中更下层的记录系统中对数据格式进行了轻微更改，导致一些数据转换功能无法正常工作。手动测试团队没有捕捉到这一问题，因为他们并未测试此功能。我们标记出我们的测试发现了回归问题，发布因此暂停，直到解决该问题。
- en: It may seem like a trivial example, but this marked a big turning point for
    the retailer. They'd witnessed first-hand the speed, reliability, and effectiveness
    of our automated test suite as well as the speed at which we could build, validate,
    and deliver a production-ready application. The act of writing and running automated
    tests built huge trust within the wider organization, prompting them to change
    their ways radically in favor of more automation and more test automation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能是一个微不足道的例子，但对零售商来说，这标志着一个重大转折点。他们亲眼见证了我们自动化测试套件的速度、可靠性和有效性，以及我们构建、验证并交付生产就绪应用程序的速度。编写和运行自动化测试的过程在更广泛的组织内建立了巨大的信任，促使他们彻底改变做法，转向更多的自动化和更多的测试自动化。
- en: You can learn more and collaborate about the CD practice by going to the Open
    Practice Library page at [openpracticelibrary.com/practice/continuous-delivery](http://openpracticelibrary.com/practice/continuous-delivery).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问[openpracticelibrary.com/practice/continuous-delivery](http://openpracticelibrary.com/practice/continuous-delivery)了解更多关于持续交付（CD）实践的内容并进行协作。
- en: Continuous Deployment (CD²)
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持续部署（CD²）
- en: '**Continuous Deployment** (**CD²**) takes the process of CD but goes one step
    further and delivers applications into production and therefore into the hands
    of our end users. I think of CD as a big train – one that operates on a very reliable
    timetable. It bundles up all the changes, taking everything in our repositories
    and compiling, packaging, testing, and promoting the application through all environments,
    verifying it at each stage.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续部署**（**CD²**）是在持续交付（CD）过程中更进一步的做法，它将应用程序交付到生产环境，并最终交到最终用户手中。我将持续部署（CD）比作一列大火车——这列火车按照非常可靠的时间表运行。它将所有更改打包起来，将我们的代码库中的所有内容进行编译、打包、测试，并通过各个环境进行推广，确保在每个阶段都经过验证。'
- en: '![](img/B16297_06_14.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_14.jpg)'
- en: 'Figure 6.14: CI, CD, and CD²'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '图 6.14: CI、CD 和 CD²'
- en: By continuously delivering to production, you speed up the delivery of features
    and fixes to end users compared to holding back for big bang releases. Delivering
    faster leads to business agility – the ability to react to changing customer and
    market demands and generate feedback from features sooner. Developers will not
    have to wait weeks or months from when their code is written for an end user to
    try it. A quick feedback loop is vital and time and money should be spent considering
    the best tooling to enable this speedy delivery.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过持续交付到生产环境，你可以加速将功能和修复交付给最终用户，相比于等待大型发布的“爆炸性发布”方式。更快速的交付促成了业务敏捷性——即响应客户和市场需求变化的能力，并更早从功能中获取反馈。开发者不再需要等待数周或数月，才能让最终用户尝试他们编写的代码。快速的反馈循环至关重要，应该投入时间和金钱考虑最好的工具，以支持这种快速交付。
- en: When the Work Is Done, Ship It!
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成工作后，就发布吧！
- en: '![](img/Tim.jpg)![](img/Noel.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Tim.jpg)![](img/Noel.jpg)'
- en: Thinking about the ability to deliver at speed, where every change could be
    deployed to production, it's important to set the technology up to allow changes
    to flow freely with confidence. This requires strong buy-in from the people around
    the team, such as leadership and product owners, who can often block such efforts
    because too much change is considered harmful to quality or end user experience.
    These conceptions are often formed from previous bad experiences around failed
    deliveries. So, it is a two-way street – trust is built in that the team can execute
    with excellence.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 想到快速交付的能力，每个变更都能部署到生产环境中，我们必须设置好技术架构，让变更能够自由流动并充满信心。这需要团队周围的人，特别是领导层和产品负责人的强力支持，因为他们往往会阻止这种努力，认为过多的变更会对质量或最终用户体验造成伤害。这些观念通常来自于过去在交付失败时的糟糕经历。所以，这是一条双向街道——信任建立在团队能够出色执行的基础上。
- en: One of the best product owners we've worked with was at a European car manufacturer.
    They were replacing a knowledge base application used by dealers and mechanics
    to diagnose problems and order parts. Historically, changes to this application
    were farmed out to suppliers with each one patching on their changes. They would
    hire a systems integrator to add some new functionality and in doing so would
    often introduce new bugs or issues. This outsourcing of development meant that
    architectural design decisions were made outside of the customers' product team,
    which led to technical debt and an unsustainable solution in the long run. The
    team decided to wipe the slate clean and rebuild the application by bringing the
    development in-house. We were engaged to help kick start this team the right way,
    using a residency, and help them build a product team connected to their end users.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们合作过的最优秀的产品负责人之一是在一家欧洲汽车制造商那里。他们正在替换一款供经销商和维修工使用的知识库应用，用来诊断问题并订购零件。历史上，这款应用的更改工作外包给供应商，每个供应商都在自己的基础上进行修改。他们会聘请系统集成商添加新功能，但这样做往往会引入新的BUG或问题。这种外包开发意味着架构设计决策是由客户的产品团队之外的人做出的，最终导致技术债务，并且从长远来看是不可持续的。团队决定重新开始，重新构建应用，并将开发工作带回公司内部。我们受邀帮助这个团队以正确的方式启动，采用驻场方式，并帮助他们建立一个与最终用户紧密联系的产品团队。
- en: A number of sprints into the engagement but still early in the development,
    the team was creating the authentication flow for users. I was pair programming
    with one of the engineers and we'd written the logout functionality. We had test-written
    and demonstrated the feature to the product owner running in our test environment.
    The Definition of Done the team agreed meant we had to show the feature to someone
    from the product team so they could accept it. So, as far as the engineering effort
    was concerned, we were done. The product owner did a quick test and it looked
    good in the test environment, so at the end of the sprint when we promoted all
    our changes up to production, our feature was released.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在参与项目的多个冲刺后，尽管开发工作还处于初期阶段，团队正在为用户创建身份验证流程。我和一名工程师进行配对编程，我们编写了注销功能。我们编写了测试，并在我们的测试环境中向产品负责人展示了这个功能。团队一致同意的完成定义是：我们必须向产品团队的某个成员展示这个功能，以便他们接受。因此，就工程工作的进展来说，我们已经完成了。产品负责人进行了快速测试，测试环境中一切正常，于是，在冲刺结束时，我们将所有更改推送到生产环境，我们的功能也发布了。
- en: The UX folks were doing some usability testing with the latest increment of
    the application when they noticed some buggy behavior with logout not working
    from one of the screens. This was reported to the engineer and me, who worked
    on it initially, and we could spot the issue immediately. This was a small fix,
    so we wrote another test and made the change.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户体验团队在对应用的最新增量版本进行可用性测试时，他们注意到注销功能在某个页面上出现了故障。这一问题被报告给了我和最初处理此事的工程师，我们立即发现了问题所在。这个问题很小，所以我们编写了另一个测试并进行了修改。
- en: We demonstrated the process to the product owner – writing a test that failed,
    writing code that would make the test pass, iterating, and then delivering that
    fixed logout code all the way to production. The ability to deliver small incremental
    improvements into the hands of our end users when they were ready to be shipped
    paved the way to deliver continuously.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向产品负责人展示了这个过程——先编写一个失败的测试，再编写能让测试通过的代码，进行迭代，然后将修复后的注销代码交付到生产环境。能够在最终用户准备好接收时，将小的增量改进交付给他们，为持续交付铺平了道路。
- en: The lesson here is that Scrum may start to impede a team's ability to continuously
    deliver small incremental changes safely to production because Scrum delivers
    at the end of a sprint. "When the work is done, just ship it to production."
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的教训是，Scrum可能会妨碍团队不断向生产环境交付小规模增量更改的能力，因为Scrum是在冲刺结束时交付的。“当工作完成时，直接将其发布到生产环境。”
- en: We have learned about the role of software pipelines, which codify the steps
    required to build, package, test, and deploy our application code into various
    environments up to but not necessarily including production – the practice of
    CD. We then looked at an approach to continuously deploying small incremental
    changes all the way to production.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了软件管道的作用，它将构建、打包、测试和部署我们的应用程序代码到不同环境（但不一定包括生产环境）所需的步骤进行了编码——即CD的实践。然后我们又看到了一个将小规模增量更改持续部署到生产环境的做法。
- en: You can learn more about CD² by going to the Open Practice Library page at [openpracticelibrary.com/practice/continuous-deployment](http://openpracticelibrary.com/practice/continuous-deployment).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问[openpracticelibrary.com/practice/continuous-deployment](http://openpracticelibrary.com/practice/continuous-deployment)页面，了解更多关于CD²的信息。
- en: Everything-as-Code
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一切皆代码
- en: 'You may have heard about this one before: [insert software term here]-as-code.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能之前听说过这个： [插入软件术语]-即代码。
- en: Examples include infrastructure-as-code, config-as-code, tests-as-code, and
    now everything-as-code. This practice has been around for a long time but some
    organizations have been slow to adopt it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 示例包括基础设施即代码、配置即代码、测试即代码，现在还有一切皆代码。这种做法已经存在很长时间了，但一些组织还没有迅速采纳。
- en: Here's the problem – historically, organizations have had to get expensive specialists
    to deploy complex environments. They would spend hours going through pages of
    instructions, line by line, eventually getting the deployment to work. A number
    of weeks would pass and the organization would like to create another environment,
    exactly like this one, for further testing. What do they do now? Call the specialist
    and ask them to come back at a great cost! This is fine, if you like hiring expensive
    specialists a lot.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 问题来了——历史上，组织必须聘请昂贵的专家来部署复杂的环境。他们会花几个小时逐行阅读操作手册，最终才能让部署成功。几个星期过去了，组织想要创建另一个环境，完全像这个一样进行进一步的测试。现在该怎么办？打电话给专家，请他们回来，但这代价不小！如果你喜欢经常雇佣昂贵的专家，那倒没问题。
- en: 'So, what''s the solution? The everything-as-code practice is simple: you treat
    every part of a system as you would any other line of code. You write it down
    and store it in a version control system, such as Git. Do we really mean to automate
    every part of the system? Yes.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，解决方案是什么？一切皆代码的做法很简单：你将系统的每个部分都像对待其他代码行一样对待。你将其写下并存储在版本控制系统中，比如Git。我们真的是要自动化系统的每个部分吗？是的。
- en: We start by automating the infrastructure layer, the lowest level, from the
    bare metal servers to the operating systems, networks, application configuration,
    and on up through to application deployments.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从自动化基础设施层开始，这是最低层次的，从裸金属服务器到操作系统、网络、应用程序配置，直到应用程序部署。
- en: 'This automation effort sounds like an awful lot of work, and could be expensive
    in terms of people''s time – why should you invest in doing it? Here''s why:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这项自动化工作听起来像是非常繁重的工作，而且在人的时间成本上可能非常昂贵——为什么要投入其中呢？原因如下：
- en: '**Traceability**: Having your environment descriptions and structure stored
    in a version control system allows us to audit changes made to the system, tracked
    to the individual who made them.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可追溯性**：将环境描述和结构存储在版本控制系统中，使我们能够审核对系统所做的更改，并追踪到具体的执行人。'
- en: '**Repeatable**: Moving from one cloud provider to another should be a simple
    task. Picking a deployment target should be like shopping around for the best
    price that week. By storing all things as code, systems can be re-created in moments
    in various providers.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重复性**：从一个云提供商迁移到另一个云提供商应该是一个简单的任务。选择部署目标应该像是每周为最优惠的价格进行购物一样。通过将所有内容存储为代码，系统可以在不同的提供商中迅速重新创建。'
- en: '**GitOps**: A single source of the truth means no more tribal knowledge or
    experts needed to set up cables or attach hard drives.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitOps**：单一的事实来源意味着不再需要部落知识或专家来设置电缆或连接硬盘。'
- en: '**Phoenix server**: No more fears of configuration drift. If a server needs
    to be patched or randomly dies, that''s OK. Just create it again from scratch
    using the stored configuration.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**凤凰服务器**：不再担心配置漂移。如果服务器需要打补丁或突然宕机，也没关系。只需使用存储的配置从头开始重新创建它。'
- en: '**Cross-functional teams**: Writing all things as code improves collaboration
    between silos in an organization. The development team is able to contribute to
    the environment creation or can recreate their own like-for-like environments
    in a sandbox.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨职能团队**：将一切写成代码有助于改善组织内各个部门之间的协作。开发团队能够为环境创建做出贡献，或者在沙盒中重建相同的环境。'
- en: '**De-risking**: Changes can be applied to environments or application deployments
    and reverted to previous states quickly, thus de-risking big upgrades of any kind.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**降低风险**：可以将更改应用到环境或应用程序部署中，并迅速恢复到先前的状态，从而降低任何类型的大规模升级风险。'
- en: 'There are plenty of approaches to implementing everything-as-code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以实现万物即代码：
- en: '**Networks and infrastructure**: Ansible can be used to declaratively define
    the system you''re implementing, and Istio can help with managing network traffic
    between apps and services.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络与基础设施**：Ansible 可以用来声明式地定义你正在实施的系统，Istio 则能帮助管理应用程序和服务之间的网络流量。'
- en: '**Application environments**: Containerization provides a proven, repeatable
    way to package applications and their dependencies in a way that both developers
    and operators love.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用环境**：容器化提供了一种经过验证的、可重复的方法，将应用程序及其依赖项打包，既满足开发人员的需求，也符合运维人员的喜好。'
- en: '**Developer workflows/build automation**: Use Jenkins'' Pipeline as Code or
    Tekton to describe how your application is taken from source, compiled, tested,
    and turned into something runnable.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发者工作流/构建自动化**：使用 Jenkins 的 Pipeline as Code 或 Tekton 来描述你的应用程序是如何从源代码编译、测试并转化为可运行的程序的。'
- en: '**Configuration drift**: ArgoCD is a tool that implements the GitOps pattern
    for your application and support tooling.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置漂移**：ArgoCD 是一个实现 GitOps 模式的工具，适用于你的应用程序及其支持工具。'
- en: '**Testing as code**: Selenium tests written as acceptance criteria in the behavior-driven
    development form can bring business analysts and developers one step closer together.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为代码的测试**：以行为驱动开发形式编写的 Selenium 测试作为验收标准，可以让业务分析师和开发人员更紧密地合作。'
- en: '**Security and compliance**: Open Policy Agent and Advanced Cluster Manager
    are tools that enforce policies across the whole stack.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全与合规**：Open Policy Agent 和 Advanced Cluster Manager 是在整个堆栈上强制执行策略的工具。'
- en: Teams who treat the whole system as code are stronger, faster, and better for
    it. We should no longer think about just infrastructure-as-code but automating
    the whole system – everything from application properties to networks and security
    policies. Then we codify it!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 视整个系统为代码的团队更强大、更高效，也更优秀。我们不应该再仅仅考虑基础设施即代码，而是要自动化整个系统——从应用程序属性到网络和安全策略的所有内容。然后，我们将其编码化！
- en: Can You Build a Second One of Those for Me, Please?
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你能为我再建一个那样的服务器吗？
- en: '![](img/Author_4.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Author_4.jpg)'
- en: Spending time on automating the creation of test environments? "Sounds costly
    and a waste of my time" – I can hear some people reading this saying to themselves.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 花时间自动化创建测试环境？“听起来成本高，浪费时间”——我能听到一些人心里在这么想。
- en: While working for a customer in the UK, I was building mobile apps and a bunch
    of JavaScript services to supply data to the apps in a consumable way optimized
    for the mobile. The services layer of adapters was deployed on IBM's MobileFirst
    (then Worklight), a big Java app that required a specialist to configure and install.
    We had several environments, from dev to system integration test environments
    to user acceptance test environments and production. All the common environments
    you'd imagine in a very traditional ecosystem.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在为英国的一位客户工作时，我在构建移动应用程序以及一堆 JavaScript 服务，用以提供优化过的、便于移动设备消费的数据。适配器的服务层部署在 IBM
    的 MobileFirst（当时是 Worklight）上，这是一个庞大的 Java 应用，需要专家来配置和安装。我们有多个环境，从开发环境到系统集成测试环境，再到用户验收测试环境和生产环境。你能想象的所有常见环境，都在这个非常传统的生态系统中。
- en: The specialist spent two weeks configuring and installing the user acceptance
    test servers. Two of them were made available to allow us to have more than one
    thing under test at any given time. You wanted a third? Well, that meant bringing
    back that expensive specialist to build the third one and another week of their
    time. In production we had eight servers, each manually configured and deployed!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 专家花了两周时间来配置和安装用户验收测试服务器。其中两个服务器被设置好，允许我们在任何给定时间同时进行多个测试。你想要第三个服务器吗？嗯，那就意味着要请回那位昂贵的专家来建立第三台服务器，并且再花上一周的时间。生产环境中我们有八台服务器，每一台都需要手动配置和部署！
- en: When I look back on this engagement and think about the pressure we faced to
    get the servers configured and deployed along with the time taken for each one,
    it seems like madness. The consultant would rock up, spend the day messing around
    on the terminal making manual changes here and there and manually testing the
    results. None of the config files back then were stored in Git or even turned
    into scripts that she could execute to make spinning up the next one faster. Every
    piece of information was tribal and in her head. We wanted a third server? We
    had to hire her to come back and do it all again!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当我回顾这次合作，思考我们面临的压力，要求在配置和部署服务器时所花费的时间，每个服务器所花费的时间，看起来真是疯狂。顾问会出现，花整天在终端上胡乱修改，并手动测试结果。当时的配置文件都没有存储在Git中，甚至没有转化为可以执行的脚本来加快下一个服务器的创建。所有信息都是口口相传的，保存在她的脑海中。如果我们想要第三台服务器？我们得雇她回来再做一遍！
- en: Some years later on another engagement for a public sector client, I saw similar
    behavior. I thought maybe creating servers in this way was a localized instance
    but on the government contract, there were teams spinning up servers for the developers
    to use that were not using any scripting or automation. If you wanted a server,
    you raised a ticket and waited a week. If you wanted an exact copy of that one,
    you raised another ticket and sometimes received one that was identical. In this
    case, the team was manually executing shell commands inside each VM and more often
    than not forgot to run a command or two!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 几年后，在为一个公共部门客户服务时，我看到了类似的行为。我原以为这种创建服务器的方式只是一个局部现象，但在政府合同中，有些团队为开发人员创建了服务器，而这些团队没有使用任何脚本或自动化工具。如果你想要一台服务器，你需要提交工单并等待一周。如果你想要与那台服务器完全相同的服务器，你需要再提交一张工单，有时得到的复制品是完全相同的。在这种情况下，团队在每台虚拟机内手动执行Shell命令，并且常常忘记执行一两个命令！
- en: These examples may feel a bit old now – but the reality is that I still see
    organizations with a traditional approach to infrastructure, automation, and repeatability.
    Not being able to test changes on representative hardware can be a challenge for
    teams trying to go fast. Teams need to have the power to spin up and spin down
    application stacks on demand. Modern approaches to how we package applications,
    such as containers, can really help to bring down this wall. No longer does a
    developer need to stub out test cases with database calls, because they can just
    spin up a real database in a container and test against it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子现在可能感觉有些陈旧了——但现实是，我仍然看到一些组织采用传统的基础设施、自动化和可重复性的方法。无法在代表性硬件上测试变更，对那些想要快速发展的团队来说是一个挑战。团队需要能够按需启动和关闭应用堆栈。我们打包应用程序的现代方法，如容器，确实有助于打破这一壁垒。开发人员不再需要通过数据库调用来模拟测试案例，因为他们可以在容器中启动一个真实的数据库并进行测试。
- en: You can learn more and collaborate about the everything-as-code practice by
    going to the Open Practice Library page at [openpracticelibrary.com/practice/everything-as-code](http://openpracticelibrary.com/practice/everything-as-code).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问[openpracticelibrary.com/practice/everything-as-code](http://openpracticelibrary.com/practice/everything-as-code)页面，了解更多并与大家合作，关于“万物皆代码”实践。
- en: So, what approach did the PetBattle team take while practicing everything-as-code?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，PetBattle团队在实践“万物皆代码”时采取了什么样的方法？
- en: Establishing the Technical Foundation for PetBattle
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为PetBattle建立技术基础
- en: This section will cover the beginning of our journey of PetBattle as the development
    team tries to set up a technical foundation with tools we will cover in later
    chapters. Any section in a box such as this one is going to lean in a bit more
    on the technical side.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍PetBattle的起步阶段，开发团队在尝试使用我们将在后续章节中讨论的工具来建立技术基础。像这样放在框中的部分将更侧重于技术方面。
- en: PetBattle began life as a hobby for some engineers – a pet project, if you will.
    This project provides the team with a real-world application where they can try
    out new frameworks and technology. In order to wrap some modern software practices
    around PetBattle, they enhance the application with some build and test automation.
    As the demand for PetBattle increases, we will look at autoscaling and how we
    can apply practices from the Open Practice Library to identify how we should build
    things.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: PetBattle最初是一些工程师的业余爱好——如果你愿意的话，它是一个宠物项目。这个项目为团队提供了一个真实的应用场景，让他们可以尝试新的框架和技术。为了将一些现代软件实践应用到PetBattle中，他们增强了应用的构建和测试自动化。随着PetBattle需求的增加，我们将考虑自动扩展以及如何借鉴开放实践库的做法，来确定我们应该如何构建这些东西。
- en: For PetBattle, we embrace modern software development paradigms – we monitor
    and respond to configuration drift so the team can implement GitOps to monitor
    this drift. Our environments should be like a phoenix, able to rise from the ashes!
    In other words, we can destroy them with confidence as we can recreate them from
    code.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 PetBattle，我们拥抱现代软件开发范式——我们监控并响应配置漂移，以便团队可以实施 GitOps 来监控这种漂移。我们的环境应该像凤凰一样，能够从灰烬中重生！换句话说，我们可以自信地摧毁它们，因为我们可以通过代码重新创建它们。
- en: Let's look at PetBattle's first piece of software they want to deploy, Jenkins.
    This section will explore how to deploy and manage Jenkins on OpenShift using
    Jenkins.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 PetBattle 想要部署的第一款软件——Jenkins。本节将探讨如何使用 Jenkins 在 OpenShift 上部署和管理 Jenkins。
- en: The PetBattle team is using OpenShift to deploy their applications. They have
    chosen to use Jenkins to get started with automating some of their tasks for building
    and deploying their software automatically. Jenkins is an open source automation
    server that can run many tasks and is supported on OpenShift. Jenkins also has
    a strong helpful community surrounding it and there is a large plugin ecosystem
    too, making automating almost any task you can think of a cinch!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: PetBattle 团队正在使用 OpenShift 来部署他们的应用程序。他们选择使用 Jenkins 来自动化一些构建和部署软件的任务。Jenkins
    是一个开源自动化服务器，可以运行许多任务，并且支持在 OpenShift 上运行。Jenkins 还有一个强大的社区支持，并且拥有一个庞大的插件生态系统，使得自动化几乎所有你能想到的任务都变得轻而易举！
- en: Now that we have established PetBattle's technical foundation, let's explore
    Jenkins a little more and the role it can play in strengthening foundations.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了 PetBattle 的技术基础，接下来让我们更深入地探讨 Jenkins 及其在强化基础中的作用。
- en: Jenkins – Our Best Friend!
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jenkins——我们最好的朋友！
- en: '![](img/Donal.jpg)![](img/Noel.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Donal.jpg)![](img/Noel.jpg)'
- en: We like to think of Jenkins as our friend. We remember the days when teams would
    have someone build the app on their local machine and send it to the ops team
    via email. To do deployments, it would be a specialized team that came in, usually
    overnight, and did the deployment so as to minimize interruptions.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们喜欢把 Jenkins 当作我们的朋友。我们还记得曾经的日子，当时团队里会有人在本地机器上构建应用程序，然后通过电子邮件发送给运维团队。为了进行部署，通常会有一个专门的团队，在晚上进入并完成部署，以减少对日常工作的干扰。
- en: Deployments were seen as a risky, scary thing. One time, a team we worked with
    went out the night before a big deployment. When they stumbled into work in the
    wee hours of the morning they were not quite in the sharpest of mindsets. As you'd
    imagine when running an upgrade, they skipped a step and broke things. The reason
    we think of Jenkins as our friend is that he doesn't do things like that. He does
    not go out the night before and arrive at work tired (unless, of course, you forget
    to feed him lots of RAM and CPU). Jenkins also won't forget a line to execute
    in a script; he's pretty good in that way. But he's also pretty dumb in other
    ways; Jenkins is only as clever as the instructions you feed him. Jenkins in his
    vanilla form is fairly basic, so we give him additional superpowers to be able
    to run builds for specific technology using agents and to report test scores in
    a machine-readable way using plugins. But once he's got it once, he will do it
    over and over again without failing – especially if you configure him as code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 部署曾被视为一项风险大、让人害怕的事情。有一次，我们合作的一个团队在一次大型部署前夕出去庆祝。当他们在清晨迷迷糊糊地来到公司时，他们的思维状态并不是最清晰的。正如你能想象的那样，在进行升级时，他们跳过了一步，导致了故障。我们之所以认为
    Jenkins 是我们的朋友，是因为它不会做这种事。它不会在前一天晚上出去玩，第二天疲惫不堪地到达公司（当然，除非你忘记给它提供足够的内存和 CPU）。Jenkins
    也不会忘记在脚本中执行某一行代码；它在这一点上做得很好。但它在其他方面也相当笨拙；Jenkins 只有你给它的指令有多聪明。Jenkins 的原始版本相对基础，因此我们为它赋予了额外的超级能力，能够使用代理来运行特定技术的构建，并通过插件以机器可读的方式报告测试结果。但一旦它完成了某个任务，它会一次又一次地重复执行，几乎不会失败——尤其是当你将它配置为代码时。
- en: Helm Overview
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Helm 概述
- en: This next section is going to get a bit more detailed on the technical side
    of things. Prepare for some code snippets and whatnot! If this is not your thing,
    feel free to skip over it to the next section all about Git and developer workflows.
    We'll mark any section that's going to have code snippets and be a bit lower level
    with this handy sign!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将更详细地介绍技术方面的内容。准备好一些代码片段和相关内容吧！如果这不是你的兴趣，随时跳过这部分，直接进入下一节，关于 Git 和开发者工作流的内容。我们会用这个方便的标志标记任何涉及代码片段和较低层次内容的部分！
- en: '![](img/Techie.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Techie.jpg)'
- en: Jenkins comes with OpenShift, and there are several ways for the team to install
    and configure it. Any member of the cross-functional team could go to the OpenShift
    console and install it from the catalog. It's as simple as clicking a few buttons
    in the UI and choosing to add a persistent hard disk or not. This is a great way
    for the team to get moving fast but also would not honor our technical foundation
    practice of everything-as-code!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 已经与 OpenShift 一起提供，团队有多种方法来安装和配置它。跨职能团队的任何成员都可以去 OpenShift 控制台，从目录中安装它。只需在
    UI 中点击几个按钮并选择是否添加持久硬盘即可。这是一个帮助团队快速启动的好方法，但也不符合我们一切皆代码的技术基础实践！
- en: PetBattle now has two choices for how they could create an instance of Jenkins
    while honoring our everything-as-code practice. They could use OpenShift or Helm
    templates containing all of the Kubernetes and OpenShift objects that would be
    required to deploy a working Jenkins. For the purposes of this book, we will focus
    exclusively on Helm as our Kubernetes package manager.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: PetBattle 现在有两种选择，可以在遵循一切皆代码的实践下创建 Jenkins 实例。它们可以使用包含所有 Kubernetes 和 OpenShift
    对象的 OpenShift 或 Helm 模板，这些对象是部署一个工作 Jenkins 所必需的。在本书中，我们将专注于使用 Helm 作为我们的 Kubernetes
    包管理器。
- en: Helm is an application package manager for Kubernetes that allows both developers
    and operators to easily package the resources and configuration that make up an
    application into a release. Helm is used for application life cycle management
    for installing, upgrading, and rolling back application deployments, thus simplifying
    the installation of an application on an OpenShift cluster. In Helm, applications
    are packaged up and distributed as Helm charts. A Helm chart is made up of several
    YAML files and templates. These Helm templates should output Kubernetes YAML once
    processed. Let's take a look at an example Helm chart.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 是一个 Kubernetes 应用程序包管理器，使开发人员和运维人员可以轻松地将构成应用程序的资源和配置打包成发布版本。Helm 用于应用程序生命周期管理，包括安装、升级和回滚应用程序部署，从而简化了在
    OpenShift 集群上安装应用程序的过程。在 Helm 中，应用程序被打包并作为 Helm 图表分发。一个 Helm 图表由多个 YAML 文件和模板组成。这些
    Helm 模板在处理后应输出 Kubernetes YAML。让我们来看一个 Helm 图表的示例。
- en: 'From our experience using Jenkins on OpenShift with customers, we have written
    a chart to deploy the Red Hat instance of Jenkins and give it a few superpowers.
    We''ll look at those afterward. Let''s first explore the anatomy of a chart:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们与客户在 OpenShift 上使用 Jenkins 的经验，我们编写了一个图表来部署 Red Hat 版本的 Jenkins，并赋予它一些超级功能。稍后我们将介绍这些功能。首先，让我们探索图表的结构：
- en: '[PRE0]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The Jenkins chart, like all Helm charts, is made up of a number YAML files:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 图表与所有 Helm 图表一样，由多个 YAML 文件组成：
- en: '`Chart.yaml`: This is the manifest of our Jenkins chart. It contains metadata
    such as the name, description, and maintainer information. The manifest also contains
    the application version and the version of the chart. If the chart has any dependencies
    on another chart or charts, they would also be listed here.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chart.yaml`：这是我们的 Jenkins 图表的清单。它包含元数据，如名称、描述和维护者信息。清单还包括应用程序版本和图表版本。如果图表依赖于其他图表或图表，它们也会在这里列出。'
- en: '`README.md`: Instructions for the chart, how to install it, and how to customize
    it.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README.md`：图表的说明，包括如何安装它以及如何自定义它。'
- en: '`templates/*`: This folder contains all the resources that need to be deployed
    to install and configure a running Jenkins instance, such as deployments, services,
    routes, and pvc.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templates/*`：此文件夹包含所有需要部署的资源，以安装和配置一个正在运行的 Jenkins 实例，如部署、服务、路由和 PVC。'
- en: '`values.yaml`: These are the sensible (default) values that the chart can be
    run with so a user can just install the chart and get up and running quickly.
    Customizations to these values can be supplied on the command line or by supplying
    your own values.yaml file when installing a chart.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values.yaml`：这些是图表可以使用的合理（默认）值，用户可以直接安装图表并快速启动。可以通过命令行提供自定义值，或在安装图表时提供自己的
    values.yaml 文件。'
- en: Red Hat **Communities of Practice** (**CoP**) is an organization that creates
    reusable software based on experiences and learnings from working with customers.
    This software is then open sourced and shared. We can add the CoP Helm Charts
    repository, which contains a Jenkins Helm chart for us to use.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 红帽**实践社区**（**CoP**）是一个基于与客户合作的经验和教训创建可重用软件的组织。然后，这些软件被开源并共享。我们可以添加 CoP Helm
    Charts 仓库，其中包含一个 Jenkins Helm 图表供我们使用。
- en: 'To start, we need the helm command-line tool. From your laptop, follow the
    instructions on the `helm.sh` ([https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/))
    website to install the helm tool. Then add the Red Hat CoP helm repository as
    follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要 helm 命令行工具。从你的笔记本电脑上，按照 `helm.sh`（[https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/)）网站上的说明来安装
    helm 工具。然后按如下方式添加 Red Hat CoP helm 仓库：
- en: '[PRE14]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can search this helm repository for Jenkins chart versions we can use:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这个 helm 仓库中搜索可以使用的 Jenkins chart 版本：
- en: '![](img/B16297_06_15.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_15.jpg)'
- en: 'Figure 6.15: Searching the helm repository for the Jenkins chart'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.15：在 helm 仓库中搜索 Jenkins chart
- en: Installing Jenkins Using Helm
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Helm 安装 Jenkins
- en: 'The quickest way to get access to your very own OpenShift cluster is to install
    CodeReady Containers on your laptop. Linux, Windows, and macOS are supported.
    You will need to log in and follow the instructions located here: [https://developers.redhat.com/products/codeready-containers/overview](https://developers.redhat.com/products/codeready-containers/overview),
    and you should see a two-step process similar to *Figure 6.16*:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 获取你自己 OpenShift 集群的最快方式是安装 CodeReady Containers 到你的笔记本电脑上。支持 Linux、Windows 和
    macOS。你需要登录并按照此处的说明操作：[https://developers.redhat.com/products/codeready-containers/overview](https://developers.redhat.com/products/codeready-containers/overview)，你应该能看到类似
    *图 6.16* 的两步安装过程：
- en: '![](img/B16297_06_16.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_16.jpg)'
- en: 'Figure 6.16: Installing CodeReady Containers'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16：安装 CodeReady Containers
- en: 'Other OpenShift clusters you have access to may also work, as long as you have
    sufficient resources and privileges. The CodeReady Containers install gives you
    cluster administrator privilege (the highest level of privilege) and is limited
    by how much RAM, CPU, and disk space your laptop has. We recommend 8 G RAM, 4
    vCPUs, and 31 GB of disk space as a minimum, which would correspond to starting
    CRC on linux with:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以访问的其他 OpenShift 集群也可以使用，只要你有足够的资源和权限。CodeReady Containers 安装为你提供集群管理员权限（最高权限），并且受限于你的笔记本电脑的
    RAM、CPU 和磁盘空间。我们推荐至少 8GB RAM、4 个 vCPU 和 31 GB 的磁盘空间，这样的配置适用于在 Linux 上启动 CRC：
- en: '[PRE16]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There are more detailed OpenShift sizing instructions in the Appendix.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 附录中有更详细的 OpenShift 配置说明。
- en: To install the Jenkins chart, we will log in to OpenShift, create a new project,
    and install the Helm chart. If you're missing any of the tools needed to run these
    commands, have no fear, as they can be downloaded and installed to match your
    OpenShift cluster version directly from the OpenShift console. Click on the ?
    icon and then Command Line Tools to find the latest instructions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装 Jenkins chart，我们将登录到 OpenShift，创建一个新项目，并安装 Helm chart。如果你缺少运行这些命令所需的工具，不用担心，它们可以从
    OpenShift 控制台直接下载并安装，以匹配你的 OpenShift 集群版本。点击 ? 图标，然后选择命令行工具，找到最新的安装说明。
- en: '![](img/B16297_06_17.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_17.jpg)'
- en: 'Figure 6.17: Downloading Command Line Tools from OpenShift'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.17：从 OpenShift 下载命令行工具
- en: 'The string after installation, my-jenkins, is the release name that is used
    by the Helm template engine:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后字符串 my-jenkins 是 Helm 模板引擎使用的发布名称：
- en: '[PRE17]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It allows us to create multiple releases in the one namespace, which is useful
    for testing purposes:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许我们在一个命名空间中创建多个发布，这对测试非常有用：
- en: '![](img/B16297_06_18.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_18.jpg)'
- en: 'Figure 6.18: Creating multiple releases in a single namespace'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.18：在一个命名空间中创建多个发布
- en: 'Helm charts can be installed in a number of ways. You can also run helm template
    against a local copy of the chart. If you are interested in doing this, fetch
    the chart and run this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Helm charts 可以通过多种方式安装。你还可以针对 chart 的本地副本运行 helm template。如果你有兴趣这样做，可以获取 chart
    并运行以下命令：
- en: '[PRE20]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This can be useful if you want to play around and see what the output is before
    applying it to an OpenShift cluster or if you want to validate things while debugging
    or testing a chart's configuration. You can also supply `--dry-run` to the helm
    install command to verify the chart before installing it.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在将其应用到 OpenShift 集群之前查看输出，或者在调试或测试 chart 配置时验证内容，这会非常有用。你还可以在 helm install
    命令中添加`--dry-run`参数来验证 chart，而不进行实际安装。
- en: Let me just pause a minute and say that this is not a book about Helm! There
    are great books out there written specifically for it, such as Learn Helm ([https://www.packtpub.com/product/learn-helm/9781839214295](https://www.packtpub.com/product/learn-helm/9781839214295))
    by *Andy Block* and *Austin Dewey*. Our aim is just to scratch the surface to
    show how easy it is to get going in a reusable and repeatable way with Helm and
    OpenShift.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我暂停一下，说明这本书并不是关于 Helm 的！市面上有很多专门介绍 Helm 的好书，比如 *Andy Block* 和 *Austin Dewey*
    所著的《Learn Helm》([https://www.packtpub.com/product/learn-helm/9781839214295](https://www.packtpub.com/product/learn-helm/9781839214295))。我们的目的是仅仅触及表面，展示如何以可重用和可重复的方式轻松开始使用
    Helm 和 OpenShift。
- en: 'Using helm install as demonstrated previously is great as it will create a
    life cycle managed by the Helm CLI to run upgrades and roll back releases if needed.
    These revisions are integrated into OpenShift and can be viewed in the UI or on
    the command line. Every time a new revision is deployed to the cluster, a new
    secret will be created, making rollback very simple:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，使用 `helm install` 非常好，因为它将创建一个由 Helm CLI 管理的生命周期，能够在需要时进行升级和回滚。这些版本已集成到
    OpenShift 中，可以通过 UI 或命令行查看。每次将新版本部署到集群时，都会创建一个新的 secret，使回滚变得非常简单：
- en: '[PRE22]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To see all the pods being spun up by the Jenkins chart, you can run this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Jenkins chart 启动的所有 Pods，可以运行以下命令：
- en: '[PRE23]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should see a large volume of pods being created – this is because this
    Helm chart contains lots of additional configuration-as-code for Jenkins. Write
    once and deploy many times:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到大量的 Pods 被创建——这是因为这个 Helm chart 包含了许多用于 Jenkins 的附加配置代码。一次编写，多次部署：
- en: '![](img/B16297_06_19.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_19.jpg)'
- en: 'Figure 6.19: Pods being created'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.19：正在创建的 Pods
- en: You may notice a bunch of agent build pods in the output. Jenkins by itself
    is a bit useless. One of Jenkins' superpowers is his ability to be extended using
    what are called plugins – small bits of code that provide new functions and features.
    To install these plugins, we could wait until Jenkins is deployed and configure
    the plugins manually through the UI – but this is the everything-as-code world,
    so we don't want to do that!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到输出中有一堆代理构建 pod。Jenkins 本身有些无用。Jenkins 的一项超级能力是它可以通过所谓的插件进行扩展——这些插件是提供新功能和特性的代码小块。为了安装这些插件，我们本可以等到
    Jenkins 部署完成后，通过 UI 手动配置插件——但这是一个“一切皆代码”的世界，所以我们不想那样做！
- en: 'The Jenkins Helm chart is configured to pre-install a bunch of useful Jenkins
    agent plugins. These agents know how to build container images using various language-specific
    stacks. The configuration for the agent plugins is defined in the Helm chart''s
    `values.yaml` file, which you can see by using this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins Helm chart 配置了预安装一堆有用的 Jenkins 代理插件。这些代理知道如何使用各种特定语言栈来构建容器镜像。代理插件的配置定义在
    Helm chart 的 `values.yaml` 文件中，你可以通过以下命令查看：
- en: '[PRE24]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The Helm chart is defining a list of build configurations to build each agent
    image. The Jenkins agent images use an OpenShift project called **Source-to-Image**
    (**S2I**) to do their language-specific build of your applications. S2I is a toolkit
    and workflow for building reproducible container images from source code; you
    can read about it here: [https://github.com/openshift/source-to-image](https://github.com/openshift/source-to-image).
    You basically feed S2I your source code via a Git repository URL and it takes
    care of the rest.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Helm chart 定义了一系列构建配置，用于构建每个代理镜像。Jenkins 代理镜像使用一个叫做 **Source-to-Image**（**S2I**）的
    OpenShift 项目来完成针对特定语言的应用构建。S2I 是一个工具包和工作流，用于从源代码构建可重现的容器镜像；你可以在这里了解更多：[https://github.com/openshift/source-to-image](https://github.com/openshift/source-to-image)。你基本上是通过
    Git 仓库 URL 将源代码输入给 S2I，之后它会处理剩下的事情。
- en: Using language-specific agents makes Jenkins easier to extend. We do not have
    to install tools into the base Jenkins image; rather, we define an agent and add
    it to the Helm chart agent plugins values list. OpenShift makes it very easy to
    create agents for Jenkins. We can extend the base image with any binary we want
    to use in our pipelines and apply the label `role=jenkins-slave` to make it discoverable
    in Jenkins. This gives us a near "serverless" ability for Jenkins to dynamically
    provision an agent when it's required. In this case, a pod gets launched and Jenkins
    will connect to it, execute its tasks, and destroy it when it's done. This means
    no agents lying idle waiting to be executed and a clean slate every time we run
    a build.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特定语言的代理使得 Jenkins 更容易扩展。我们不需要将工具安装到基础 Jenkins 镜像中，而是定义一个代理并将其添加到 Helm 图表代理插件值列表中。OpenShift
    让为 Jenkins 创建代理变得非常容易。我们可以使用任何我们想要在流水线中使用的二进制文件扩展基础镜像，并将标签 `role=jenkins-slave`
    应用于使其在 Jenkins 中可被发现。这使得 Jenkins 能够在需要时动态提供代理，例如，一个 Pod 被启动并且 Jenkins 将连接到它，执行其任务，并在完成后销毁它。这意味着没有代理处于空闲状态等待执行，每次运行构建时都是一个干净的状态。
- en: 'There are a bunch of Jenkins agents available in the CoP; you can use them
    or create your own: [https://github.com/redhat-cop/containers-quickstarts/tree/master/jenkins-agents](https://github.com/redhat-cop/containers-quickstarts/tree/master/jenkins-agents).'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CoP 中有大量的 Jenkins 代理可用；您可以使用它们或者自己创建：[https://github.com/redhat-cop/containers-quickstarts/tree/master/jenkins-agents](https://github.com/redhat-cop/containers-quickstarts/tree/master/jenkins-agents)。
- en: 'Apart from the agent plugins, the Jenkins image is extensible from the base
    image in a number of different ways. You can specify a list of plugins to install
    when you build the Jenkins image. We use S2I to build our Jenkins image and add
    our list of `plugins.txt` from this Git repository: [https://github.com/rht-labs/s2i-config-jenkins](https://github.com/rht-labs/s2i-config-jenkins).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 除了代理插件外，Jenkins 镜像还可以通过多种不同的方式从基础镜像进行扩展。您可以在构建 Jenkins 镜像时指定要安装的插件列表。我们使用 S2I
    构建我们的 Jenkins 镜像，并从此 Git 仓库添加我们的 `plugins.txt` 列表：[https://github.com/rht-labs/s2i-config-jenkins](https://github.com/rht-labs/s2i-config-jenkins)。
- en: Once the Jenkins build has completed, a Jenkins deployment and running container
    instance will be available.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Jenkins 构建完成，Jenkins 部署和运行的容器实例将可用。
- en: '![](img/B16297_06_20.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_20.jpg)'
- en: 'Figure 6.20: Available Jenkins deployment and a running container instance'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.20：可用的 Jenkins 部署和运行的容器实例
- en: 'All of the S2I plugins and agents are configured. You can log in to Jenkins
    using its route, which is available in the OpenShift web console, or by running
    this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 S2I 插件和代理都已配置好。您可以使用其路由登录到 Jenkins，在 OpenShift Web 控制台中可用，或者通过运行以下命令：
- en: '[PRE32]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By running this single `helm install` command, we get a sensible starting point
    to be able to do lots of things with our build server, Jenkins. By codifying the
    Jenkins configuration, we can repeatedly deploy Jenkins into many environments
    without ever having to touch the Jenkins UI.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行这个单一的 `helm install` 命令，我们可以得到一个合理的起点，可以在我们的构建服务器 Jenkins 中执行很多操作。通过将 Jenkins
    配置进行编码化，我们可以在许多环境中重复部署 Jenkins，而无需触摸 Jenkins UI。
- en: Now that we have our build server, before starting development we should familiarize
    ourselves with the types of code workflows developers use. If you are an experienced
    developer, you will already be pretty familiar with the next section's content.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的构建服务器，在开始开发之前，我们应该熟悉开发者使用的代码工作流类型。如果您是一位经验丰富的开发者，您可能已经对下一节的内容非常熟悉。
- en: Developer Workflows
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发者工作流
- en: Git is a **version control system** (**VCS**) created by Linus Torvalds (author
    of the Linux kernel) to track changes in source code and easily manage these changes
    across many file types and developers. Git differs from other VCS in that it is
    decentralized. This means that unlike, for example, **Subversion** (**svn**),
    each developer retains a complete copy of the source code locally when they check
    it out. Locally, each developer has a copy of all the history and can rewind or
    fast forward to different versions as they need to. An engineer makes their changes
    and applies those changes as a delta on top of another's work. This is known as
    a commit. Git can be conceptualized as a tree, with a trunk of these changes or
    commits on top of each other. Branches can spring out from the trunk as independent
    pieces of functionality, or work that is not ready can be merged back to the trunk.
    Once something is committed to Git, it is forever in the history and can always
    be found – so be careful not to add something secret, such as a password, by mistake!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Git 是由 Linus Torvalds（Linux 内核的作者）创建的**版本控制系统**（**VCS**），用于跟踪源代码的变化，并轻松地在多个文件类型和开发人员之间管理这些变化。Git
    与其他版本控制系统的不同之处在于它是去中心化的。这意味着，与例如 **Subversion**（**svn**）不同，每个开发者在检出代码时都会保留一份源代码的完整副本。在本地，每个开发者都有所有历史的副本，并可以根据需要回滚或快进到不同的版本。工程师会进行更改，并将这些更改作为增量应用到他人的工作上，这就是所谓的提交。Git
    可以被概念化为一棵树，树干是这些更改或提交依次叠加在一起。分支可以从树干中分出，作为独立的功能，或者尚未准备好的工作可以被合并回树干。一旦某个东西被提交到
    Git，它将永远存在于历史记录中，随时可以找到——因此，请小心不要错误地添加一些机密信息，如密码！
- en: Git is the underlying technology behind some big companies such as GitHub and
    GitLab. They have taken the Git product and added some social features and issue-tracking
    capabilities to help manage a code base.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Git 是一些大型公司背后的基础技术，如 GitHub 和 GitLab。它们在 Git 产品的基础上添加了一些社交功能和问题追踪能力，帮助管理代码库。
- en: There are many workflows for Git that development teams can use when writing
    code, and choosing the correct one can seem like a daunting task. Some are designed
    to give teams a sense of safety and security, especially in large complex projects,
    while others promote speed and trust within the teams. The most popular source
    code management workflows for Git are Trunk, GitFlow, and GitHub Flow. Let's explore
    each in detail and see how we could use them to help us promote CD.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 开发团队在编写代码时可以使用许多 Git 工作流，选择正确的工作流可能看起来是一项艰巨的任务。有些工作流旨在为团队提供安全感，特别是在大型复杂项目中，而有些则促进团队内部的速度和信任。最流行的
    Git 源代码管理工作流包括 Trunk、GitFlow 和 GitHub Flow。让我们详细探索每个工作流，并看看我们如何使用它们来促进 CD。
- en: GitFlow
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GitFlow
- en: GitFlow was first published about 10 years ago by Vincent Driessen. The workflow
    was built from his experience using Git, a relatively new tool at the time. As
    teams moved to Git from a non-branching-based code repository, some new concepts
    and core practices had to be defined. GitFlow tried to answer this by adding a
    well-thought-out structure to branch names and their conventions.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: GitFlow 最早由 Vincent Driessen 在大约 10 年前发布。这个工作流是基于他使用 Git 的经验构建的，而 Git 当时是一个相对较新的工具。当团队从非分支式的代码仓库迁移到
    Git 时，一些新的概念和核心实践需要被定义。GitFlow 尝试通过为分支名称和约定增加一个深思熟虑的结构来解决这个问题。
- en: 'A well-defined branching strategy is at the heart of GitFlow. Changes are committed
    to different named branches depending on the type of change. New features are
    developed on branches that are called `feature-*` branches. `hotfixes-*` branches
    are created for patching changes to bugs in production and a release branch. GitFlow
    describes two reserved and long-living branches:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 明确的分支策略是 GitFlow 的核心。根据变更的类型，代码会被提交到不同命名的分支。新功能在被称为 `feature-*` 的分支上开发。`hotfixes-*`
    分支用于修复生产环境中的漏洞和发布分支。GitFlow 描述了两个预留的、长期存在的分支：
- en: '**Master**: This is the branch that contains our releases or our production-ready
    code. Sometimes this branch is referred to as the main branch.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Master**：这是包含我们发布版本或生产就绪代码的分支。有时这个分支也被称为主分支。'
- en: '**Develop**: This branch is our integration branch. It is usually the most
    turbulent and very likely to contain bugs or other issues as it is the place where
    teams first bring their code together.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Develop**：这个分支是我们的集成分支。它通常是最混乱的，很可能包含 bugs 或其他问题，因为它是团队首次将代码汇集到一起的地方。'
- en: The naming and usage conventions defined in GitFlow make it easier for a new
    developer to discover what each branch is doing. The developer can bring additional
    changes made by other team members into their feature branch, when they choose
    to, by merging in any new changes. Branching in this way avoids breaking things
    for other engineers by ensuring that the feature functionality is complete before
    asking to merge their code from the feature into the develop branch. When a set
    of features is ready to be promoted to the mainline master branch, the developers
    merge their code to the master via the release branch.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: GitFlow中定义的命名和使用规范使得新开发人员能够轻松发现每个分支的作用。开发人员可以在需要时通过合并新更改，将其他团队成员的更改带入他们的功能分支。以这种方式分支可以避免破坏其他工程师的工作，因为它确保功能实现完整，才会请求将代码从功能分支合并到开发分支中。当一组功能准备好推送到主线主分支时，开发人员会通过发布分支将代码合并到主分支。
- en: You may be reading this and thinking, this sounds complex! And in some ways,
    it is. But in a large project with a single code base, this can be exactly what
    is required to ensure developers are free to work on their code without having
    to manage their code.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在读到这里时会觉得，这听起来很复杂！在某些方面，确实如此。但是在一个拥有单一代码库的大型项目中，这可能正是确保开发人员能够自由编写代码而不必管理代码所需的方式。
- en: GitHub Flow
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GitHub Flow
- en: GitHub Flow is similar to GitFlow in that it shares some of the same words in
    its name. Branching is a core pillar of Git, and GitHub Flow uses this by keeping
    one long-lived branch, that is, the main or master branch. Developers then work
    in branches off main, where they can commit changes and experiment without affecting
    the main branch.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Flow与GitFlow类似，因为它们的名字中有些相同的词。分支是Git的核心支柱，GitHub Flow利用这一点，保持一个长久存在的主分支（main
    或 master）。然后，开发人员在主分支上创建自己的分支，在这些分支中可以提交更改并进行实验，而不会影响主分支。
- en: These could be feature branches like in GitFlow, but there is no naming convention
    to be followed. It is important to name the branch sensibly using a descriptive
    name, such as sign-up-form or refactor-auth-service. No branches called another-new-feature-branch,
    please!
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分支可以像GitFlow中的功能分支一样，但没有必须遵循的命名规范。重要的是要使用描述性名称为分支命名，例如 sign-up-form 或 refactor-auth-service。请不要命名为
    another-new-feature-branch 之类的分支！
- en: At any point in time, the developer can raise a pull request, where other engineers
    can discuss the code and its approach, and design by providing feedback for the
    changes that are still in progress. The original author can then incorporate this
    discussion into the software. When the team is happy and the code is reviewed,
    the changes can be approved and merged to the main branch.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时刻，开发人员都可以提出拉取请求，其他工程师可以讨论代码及其方法，并通过提供反馈来对仍在进行中的更改进行设计。原作者可以将这些讨论整合到软件中。当团队满意并且代码已被审查后，可以批准更改并合并到主分支。
- en: GitHub Flow is great at promoting the peer review of work and promoting transparency
    in how a decision was made. Git by its nature is searchable, and the discussion
    on a merge request provides valuable insight and traceability into how architectural
    and coding decisions were made.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Flow非常有助于促进工作成果的同行评审，并提高决策过程的透明度。Git本身就是可搜索的，而合并请求中的讨论提供了有关如何做出架构和编码决策的宝贵见解和可追溯性。
- en: Trunk-Based Development
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于主干的开发
- en: Both GitHub Flow and GitFlow use branching strategies and merging patterns to
    bring independent development activities together. Branching in Git is made extremely
    easy. However, when merging all of the branches together, conflicts can still
    occur that require human intervention.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Flow和GitFlow都使用分支策略和合并模式来将独立的开发活动结合在一起。Git中的分支操作非常简单。然而，在合并所有分支时，仍然可能发生冲突，需要人工干预。
- en: Depending on the frequency of this branching, some teams end up in merge hell,
    where everyone tries to bring their changes in at once, leading to the complex
    and often frustrating event of trying to unpick all the changes that were made
    while maintaining a working code base!
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 根据分支的使用频率，一些团队最终会陷入合并地狱，在这种情况下，所有人都会试图同时将他们的更改合并，这就导致了一个复杂且通常令人沮丧的事件——试图解开所有更改，并在保持可工作的代码库的同时解决冲突！
- en: Trunk-based development ([https://trunkbaseddevelopment.com/](https://trunkbaseddevelopment.com/))
    takes a somewhat different approach to this particular problem by saying **no**
    to branches!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 基于主干的开发（[https://trunkbaseddevelopment.com/](https://trunkbaseddevelopment.com/)）通过拒绝使用分支，采用了与众不同的方式来解决这个问题！
- en: '![](img/B16297_06_21.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_21.jpg)'
- en: 'Figure 6.21: Merge hell'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.21：合并地狱
- en: In trunk-based development, developers collaborate on one single main branch
    referred to as the trunk. Devs work on their changes and apply them directly to
    the trunk. In a perfect world, the commits are small in nature and frequent throughout
    the development process. The golden rules here are never break the build and always
    be release-ready. In this regard, a developer must always ensure this is the case.
    Development could be automated using some CI process, but the key is that the
    trust within the team must be there.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在主干开发中，开发者们在一个单一的主分支上协作，这个分支被称为主干。开发者在其中进行更改，并直接将更改应用到主干中。在理想的情况下，提交内容是小规模且频繁的。在这一过程中，黄金法则是绝不破坏构建，并始终保持可发布状态。在这方面，开发者必须始终确保这一点。开发可以通过一些持续集成（CI）流程自动化，但关键是团队内部必须建立信任。
- en: In a large-scale enterprise, this constant merging to master sounds like it
    could create headaches. How, for example, do you do a peer review of the code?
    For large-scale application development with many engineers and many teams, it
    is suggested that very short-lived feature branches can be a great help. They
    provide decision logs during the review process, but the key here is short. Short-lived
    feature branches should only be alive for a day or two at most (definitely no
    longer than a sprint) and are deleted once the code is merged to prevent them
    from becoming feature release branches.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型企业中，这种不断合并到主分支的方式听起来可能会带来麻烦。例如，如何进行代码同行评审？对于有许多工程师和团队的大型应用开发，建议使用非常短生命周期的功能分支，这能够在评审过程中提供决策日志，但关键是分支的生命周期要短。短生命周期的功能分支应该最多只存在一两天（绝对不超过一个迭代周期），并在代码合并后删除，以防它们变成功能发布分支。
- en: Too Many Choices — Tell Me What to Do
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择过多——告诉我该做什么
- en: Each of these Git workflows has been tried and tested with teams for years.
    Some teams choose one as a standard, whereas others adopt one or more depending
    on their own context.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 每种Git工作流都经过多年的团队实践和验证。一些团队选择其中一个作为标准，而其他团队则根据自身的上下文采用一种或多种工作流。
- en: The original author of GitFlow recently revised his views to suggest GitFlow
    does not work well for "applications that are delivered continuously" such as
    web apps. Branches can create distance between production code and work in progress
    and GitFlow sees code moving between several branches before it's released. If
    we think of a developer working on their feature, they get it merged into the
    develop branch and then they move on to a new feature branch.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: GitFlow的原始作者最近修订了他的观点，建议GitFlow并不适用于“持续交付的应用程序”，例如Web应用。分支可能会在生产代码和正在进行的工作之间产生距离，而GitFlow要求代码在发布之前需要在多个分支间流动。如果我们想象开发者在工作他们的功能，他们将其合并到开发分支中，然后继续创建新的功能分支。
- en: The new feature sits waiting (potentially along with some other features that
    have been completed) until the end of the development cycle. At this point, it's
    bundled up and moved across to master via the release branch, possibly two weeks
    after the work was completed. All of these extra steps mean a developer is not
    getting the feedback they need from users in the field for a long time after the
    development is complete. In terms of a feedback loop, if the rework is required
    on the item or a bug arises, it could take weeks before it is rectified. Add to
    that the context switch for the developer, who has to go back over what they previously
    did, which could end up having an impact on the team's velocity.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 新功能会等待（可能还包括一些其他已完成的功能），直到开发周期结束。此时，它们会通过发布分支打包并移到主分支，可能是在工作完成后两周。这些额外的步骤意味着开发者在开发完成后很长一段时间内无法从用户那里获得所需的反馈。在反馈循环方面，如果需要对项目进行返工或出现bug，可能需要几周才能解决。再加上开发者的上下文切换，他们需要重新回顾之前所做的工作，这可能会影响团队的开发速度。
- en: In CI, does having feature branches slow us down? It's very easy for a developer
    to effectively hide out on their branch while development is happening. We have
    worked with teams in the past who have claimed to be doing CI, but their build
    system remains idle until the day of review. At this point, all the developers
    rush to integrate their features in a last-minute mini-integration session that
    often reveals misunderstanding in the designs or broken software. Long-lived feature
    branches do not easily marry up with CI.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在持续集成（CI）中，功能分支会拖慢我们速度吗？开发者很容易在他们的分支上独立工作，直到开发完成。我们过去与一些声称在做持续集成的团队合作过，但他们的构建系统在审查日之前一直处于空闲状态。到那时，所有开发者会赶在最后一刻进行集成，常常会暴露出设计上的误解或软件故障。长期存在的功能分支很难与持续集成兼容。
- en: Short-lived feature branches are a great way to help with some of these concerns.
    Developers can work away on small chunks in an isolated way and still merge frequently.
    Short feedback loops are the king of improving software delivery metrics. If branches
    add time to this loop, how can we tighten it further? Peer reviews can often be
    a burden to teams by creating a dependency on one individual or breaking the focus
    of another engineer in order to complete a feature. By pairing engineers, you
    gain implicit peer review. Pushing changes as a pair straight to the trunk is
    a great way to achieve speed. In a container ecosystem, you only want to build
    once and verify your application is working before deploying it to many places.
    Trunk-based development underpins this by encouraging frequent small changes pushed
    straight to the head, where CI and CD can then take over.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 短期存在的功能分支是解决这些问题的好方法。开发者可以在独立的环境中处理小块功能，并且仍然频繁地进行合并。短反馈周期是改善软件交付度量的关键。如果分支增加了这个周期的时间，我们怎么能进一步缩短它呢？同行评审有时会成为团队的负担，因为它依赖某个个体，或打断其他工程师的专注力来完成功能。通过配对工程师，你能实现隐性的同行评审。作为一对配对工程师，直接将更改推送到主干是提高速度的好方法。在容器生态系统中，你只希望构建一次并验证应用程序是否工作，然后再将其部署到多个地方。基于主干的开发通过鼓励频繁的小变更直接推送到主干，支持了这一点，此时持续集成（CI）和持续交付（CD）可以接管流程。
- en: From our experience in kickstarting product teams with varying skill sets, choosing
    the right one should be seen as more of a pathway, a sliding scale from immature
    to mature teams. Teams that are new to Git may find the use of feature branches
    a comforting way to not step on the toes of other developers. The book *Accelerate*[3](#footnote-021)
    measured the software delivery performance of many teams and concluded that high-performing
    teams use trunk-based development.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在启动具有不同技能组合的产品团队的经验，选择合适的团队应该视为一种路径，是从不成熟到成熟团队的一个滑动尺度。对于初次接触 Git 的团队，使用功能分支可能是一个令人放心的方式，可以避免踩到其他开发者的脚。书籍*《加速》*[3](#footnote-021)衡量了多个团队的软件交付表现，得出的结论是高效能团队使用基于主干的开发。
- en: No matter what you choose as your approach to managing code, the key here is
    the frequency of delivery. How long will it take you to get software into the
    hands of your end users? Does having feature branches slow you down? Or do those
    branches provide you with a safe place for your team to start? As the team matures
    and becomes more familiar with each other and the tools, your software output
    can increase.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种管理代码的方法，关键在于交付的频率。你需要多长时间才能将软件交付给最终用户？使用功能分支会拖慢速度吗？还是这些分支为你的团队提供了一个安全的起步点？随着团队的成熟以及彼此和工具的熟悉，软件输出可以增加。
- en: The big call to action here is to let the teams choose the way that works best
    for them and build the automation around the workflow and tools. This allows the
    developers to focus on the hard stuff – writing code not managing the code. Initially,
    this will just be a guess. Teams should use retrospectives to assess whether things
    are working or not and evolve accordingly. It's important to not set out one dogma
    to fit all development activities across all teams because every team is going
    to be different. One shoe size is not going to fit everyone!
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键行动是让团队选择最适合他们的方式，并围绕工作流和工具构建自动化。这使得开发者能够专注于难题——编写代码，而不是管理代码。最初，这只是一种猜测。团队应该通过回顾来评估是否有效，并根据需要调整。重要的是不要为所有团队的所有开发活动制定统一的教条，因为每个团队都不同。一种鞋码并不适合每个人！
- en: '[3](#footnote-021-backlink) [https://itrevolution.com/book/accelerate/](https://itrevolution.com/book/accelerate/)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[3](#footnote-021-backlink) [https://itrevolution.com/book/accelerate/](https://itrevolution.com/book/accelerate/)'
- en: Conclusion
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, we learned that we could get off to a great start by being
    green from go! By automating the deployment of our application build and packaging
    tools, Jenkins and Helm can establish a technical foundation that will allow our
    teams to integrate continuously (CI) and continuously deploy (CD) our code to
    production.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到通过从一开始就采取绿色开发的方式，我们能够有一个良好的开端！通过自动化我们的应用构建和打包工具的部署，Jenkins 和 Helm 可以建立一个技术基础，使我们的团队能够持续集成（CI）并持续部署（CD）我们的代码到生产环境中。
- en: We learned that we can align our developer code workflow across our team and
    begin to iterate on our CI/CD pipelines to help us deliver applications faster.
    We can increase code quality and understanding by pairing developers together
    to help shorten the code review feedback loop.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到，团队间可以对齐开发者的代码工作流，并开始迭代我们的 CI/CD 流水线，帮助我们更快地交付应用程序。我们可以通过让开发者结对编程，帮助缩短代码评审反馈周期，从而提升代码质量和理解度。
- en: As a team, we learned all of these new skills and techniques together by trying
    mob programming and, in the process, said goodbye to our love for Unicorn developers.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个团队，我们通过尝试集体编程（mob programming）一起学习了所有这些新的技能和技术，并在此过程中告别了我们对独角兽开发者的热爱。
- en: '![](img/B16297_06_22.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_22.jpg)'
- en: 'Figure 6.22: Adding technical practices to the foundation'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.22：将技术实践添加到基础中
- en: In the second half of *Open Technology Practices*, we will learn about the bigger
    picture, discover what GitOps is all about, vastly improve our code quality through
    testing, and finish off with some lessons about our emerging architecture.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *开放技术实践* 的后半部分，我们将学习更广泛的视角，了解 GitOps 的本质，通过测试大幅提升我们的代码质量，并最终通过一些关于新兴架构的课程做总结。
