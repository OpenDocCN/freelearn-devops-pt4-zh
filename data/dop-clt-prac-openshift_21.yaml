- en: 14\. Build It
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14. 构建它
- en: '"*It works on my machine*"—a phrase heard time and time again by developers,
    testers, and operators as they write, test, and verify their code. *It works on
    my machine* is a phrase rooted in siloed teams where ownership of the problem
    moves around like a tennis ball on a court at Wimbledon. The metaphorical wall
    that exists between teams that have operated in silos, passing work over the wall
    and not taking full responsibility for the end-to-end journey is a problem that
    has been around for decades. We need to break away from this behavior! From now
    on, it''s not, "*It''s working on my machine*" but rather, "*How has your code
    progressed in the build system*?" The build and deployment pipeline our code runs
    through is a shared responsibility. In order for this to be the case, all team
    members must contribute to the pipeline and be ready to fix it when it breaks.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '"*在我的机器上运行正常*"——这是开发者、测试人员和运维人员在编写、测试和验证代码时经常听到的一句话。*在我的机器上运行正常*是源自孤岛式团队的一种说法，在这种团队中，问题的责任像温布尔登网球场上的网球一样来回传递。存在于这些孤岛式团队之间的隐形墙，导致工作在团队之间传递，但没有承担从头到尾的完整责任，这个问题已经存在了几十年。我们需要打破这种行为！从现在起，不再是“*在我的机器上运行正常*”，而是，“*你的代码在构建系统中的进展如何*？”我们代码所经过的构建和部署管道是共同的责任。为了实现这一点，所有团队成员都必须为管道做出贡献，并准备在管道出现故障时修复它。'
- en: '![](img/B16297_14_01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_01.jpg)'
- en: 'Figure 14.1: It works on my machine'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1：在我的机器上运行正常
- en: If your code has failed the build because you forgot to check in a dependency,
    or if your tests are not passing, then it is your responsibility to fix it! The
    purpose of the deployment pipeline is to create a repeatable process that our
    code will pass through and accelerate releases while also de-risking them. If
    we know that on every commit to a repository all of our tests are executed, we're
    going to have a large amount of confidence that the resulting application will
    work well. If we're continuously increasing the test volume as the application's
    complexity increases, that too should grow our confidence. It's critical for teams
    to want to own their software pipelines.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码构建失败，因为你忘记检查某个依赖项，或者如果你的测试没有通过，那么修复它是你的责任！部署管道的目的是创建一个可重复的流程，使我们的代码能够通过它，并加速发布的同时降低风险。如果我们知道每次提交到代码库时，所有测试都会执行，我们就会对最终的应用程序有很大的信心。如果我们随着应用程序复杂性的增加，不断增加测试量，这也应该提高我们的信心。团队要想拥有自己的软件管道是至关重要的。
- en: Having a platform such as OpenShift is a bit like the Beatles singing on the
    rooftop of the Apple Corps building on Saville Row about people *coming together*.
    Developers, operations, testers, architects, designers, database administrators,
    and analysts, everyone coming together and using a platform like OpenShift provides
    a shared space to collaborate upon. Building applications and business services
    on the platform where developers can self-service all of their requirements in
    a safe, access-controlled manner, bringing down the walls between teams, and removing
    bottlenecks such as having to wait for permissions to deploy an application—this
    gets everyone speaking the same language to deliver business outcomes through
    modern application delivery and technological solutions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有像 OpenShift 这样的平台，有点像披头士在萨维尔街的苹果公司大楼屋顶上唱歌，唱的是人们*团结起来*。开发者、运维、测试人员、架构师、设计师、数据库管理员和分析师，大家共同使用像
    OpenShift 这样的平台，提供了一个共享的协作空间。在这个平台上构建应用程序和业务服务，开发人员可以以安全、受控的方式自服务满足他们的所有需求，打破团队之间的壁垒，消除等待权限才能部署应用程序等瓶颈——这使得每个人都能用相同的语言，通过现代应用交付和技术解决方案推动业务成果的实现。
- en: Cluster Resources
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集群资源
- en: 'This section of the book will be one of the most technical. As described in
    the *Appendix*, the minimum requirements for running the code examples using **CodeReady
    Containers** (**CRCs**) in this chapter are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的这一部分将是最具技术性的之一。如*附录*中所述，本章中使用**CodeReady Containers**（**CRCs**）运行代码示例的最低要求如下：
- en: '![](img/B16297_Table_14.1.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_Table_14.1.png)'
- en: 'Table 14.1: Minimum requirements for running code examples using CRCs'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14.1：使用 CRCs 运行代码示例的最低要求
- en: With the amount of memory required to follow, and the technical content out
    of the way, let's dive into things in more detail. We'll start by looking over
    the components of the existing PetBattle applications as they move from a hobby
    weekend project into a highly available, production-based setup that is built
    and maintained by a strong, cross-functional team.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 随着所需内存的增加，技术内容也已经讲解完毕，让我们更详细地深入探讨。我们将从现有PetBattle应用程序的组件开始，随着它从一个业余周末项目转变为一个高可用的、以生产为基础的设置，这一设置是由一个强大的跨职能团队构建和维护的。
- en: Existing PetBattle Architecture
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现有的PetBattle架构
- en: 'The initial PetBattle architecture was pretty basic and revolved around deploying
    application components running in a single **virtual machine** (**VM**). The initial
    architecture had three major components: a JavaScript frontend; a Java-based backend,
    providing an API and a database; and a single instance of MongoDB. Nothing here
    was too exciting or complex but hidden inside was a minefield of technical debt
    and poor implementation that caused all sorts of problems when the site usage
    took off.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的PetBattle架构相当基础，围绕在单个**虚拟机**（**VM**）中运行的应用组件进行部署。初始架构有三个主要组件：一个JavaScript前端；一个基于Java的后端，提供API和数据库；以及一个单实例的MongoDB。这里的内容并不令人兴奋或复杂，但其中隐藏着技术债务和糟糕实现的雷区，这导致了网站流量增长时出现各种问题。
- en: 'The issues with this architecture seemed to include:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构的问题似乎包括：
- en: A monolith—Everything had to be deployed and scaled as one unit, there were
    no independent moving parts.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体架构——一切都必须作为一个整体进行部署和扩展，没有独立的可移动部分。
- en: Authentication and access control were non-existent.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证和访问控制不存在。
- en: Tests? Unit tests? But seriously, there weren't many.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试？单元测试？但说真的，没多少。
- en: It required a lot of data maintenance as everything was stored in the database.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要大量的数据维护，因为所有数据都存储在数据库中。
- en: Bad actors adding inappropriate images to our family-friendly cat application.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不良行为者向我们友好的猫咪应用添加不当图片。
- en: Fragile application—If something went wrong, the application would crash and
    everything had to be restarted.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脆弱的应用——如果出现问题，应用程序会崩溃，且一切都需要重启。
- en: 'Back in *Chapter 9*, *Discovering the How*, we went through an Event Storming
    exercise that helped drive a newly proposed architecture. It consisted of a UI
    component and a backing service that provided different REST-based APIs to the
    UI, as shown in *Figure 14.2*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第9章*，*发现方式*中，我们进行了一个事件风暴练习，帮助推动了一个新提议的架构。它由一个UI组件和一个支持服务组成，后者向UI提供不同的REST
    API，如*图14.2*所示：
- en: '![](img/B16297_14_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_02.jpg)'
- en: 'Figure 14.2: PetBattle''s initial hobbyist architecture'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2：PetBattle的初始业余架构
- en: Let's now take a look at the individual PetBattle components.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看PetBattle的各个组件。
- en: PetBattle Components
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PetBattle 组件
- en: In the coming chapters, we will explore automation, testing, and the extension
    of PetBattle to include aspects such as monitoring and alerting, Knative Serving,
    and Service Mesh. But first, let's imagine that the PetBattle team has completed
    a few sprints of development. They have been building assets from the Event Storms
    and now have the components and architecture as seen in *Figure 14.3*. Through
    the Event Storm, we also identified a need for authentication to manage users.
    The tool of choice for that aspect was Keycloak.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探索自动化、测试，以及将PetBattle扩展到包括监控、警报、Knative Serving和Service Mesh等方面。但首先，让我们设想PetBattle团队已经完成了几个开发冲刺。他们从事件风暴中构建了资源，现在拥有了如*图14.3*所示的组件和架构。通过事件风暴，我们还发现需要身份验证来管理用户。为此，我们选择了Keycloak作为工具。
- en: '![](img/B16297_14_03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_03.jpg)'
- en: 'Figure 14.3: PetBattle''s evolving architecture'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3：PetBattle的演进架构
- en: PetBattle's architecture is now increasing in complexity. It has a UI that connects
    to two services to provide it with data. **Single Sign-On** (**SSO**) and user
    management are provided by Keycloak. Let's take a look at each component of the
    architecture in more detail.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，PetBattle的架构正变得越来越复杂。它有一个连接到两个服务的UI，以提供数据。**单点登录**（**SSO**）和用户管理由Keycloak提供。让我们更详细地看看架构的每个组件。
- en: User Interface
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户界面
- en: The UI is written in Angular[1](#footnote-093) v12, a complete JavaScript framework
    from Google for building web and mobile applications. The application is transpiled
    and the static site code is then served from a container running Nginx (a webserver)
    instance provided by Red Hat. The application is set up to pull its configuration
    on startup, which sets up endpoints for all of the dependent services, such as
    Keycloak and the APIs. This configuration is managed as a ConfigMap in OpenShift.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面使用Angular[1](#footnote-093) v12编写，这是Google提供的一个完整的JavaScript框架，用于构建Web和移动应用程序。该应用程序会进行转译，静态站点代码随后从运行Nginx（一个Web服务器）实例的容器中提供，由Red
    Hat提供。应用程序在启动时会拉取其配置，配置中设置了所有依赖服务的端点，例如Keycloak和API。此配置作为ConfigMap在OpenShift中进行管理。
- en: Pet Service
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 宠物服务
- en: The Pet service is a straightforward service that uses Java Quarkus[2](#footnote-092)
    as the framework, backed by a MongoDB database to retrieve and store details of
    the pets uploaded to partake in a tournament.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 宠物服务是一个简单的服务，使用Java Quarkus[2](#footnote-092)作为框架，并通过MongoDB数据库来检索和存储上传到平台参加比赛的宠物详情。
- en: Tournament Service
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比赛服务
- en: The Tournament service also uses the Quarkus framework and stores the state
    in both MongoDB and an Infinispan distributed cache. MongoDB is used to store
    the details of the tournament such as which pet won the tournament—but why did
    we use a cache?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 比赛服务也使用Quarkus框架，并将状态存储在MongoDB和Infinispan分布式缓存中。MongoDB用于存储比赛的详细信息，例如哪个宠物赢得了比赛——但为什么我们使用缓存呢？
- en: Well, the answer is that a tournament only exists for a finite period of time
    and using a database to store temporal data is not a great fit for our use case.
    Also, Infinispan stores the cache data in memory, which is much faster to access
    than data on disk. The drawback of this is that if the Infinispan pod dies/crashes,
    then the data is lost. However, we plan to circumvent this in production by having
    at least two replicas, with the data being replicated between the pods.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，答案是比赛只存在有限的时间，使用数据库存储时间数据并不适合我们的用例。而且，Infinispan将缓存数据存储在内存中，访问速度比磁盘上的数据要快得多。其缺点是，如果Infinispan的pod死掉或崩溃，数据就会丢失。然而，我们计划在生产环境中通过至少保留两个副本来规避这一问题，数据将在这些pod之间进行复制。
- en: User Management
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户管理
- en: User management, authentication, and access control are a few other critical
    parts of the architecture that need to be addressed. We're using Keycloak,[3](#footnote-091)
    an open source identity and access management tool, to provide this functionality.
    We could have written some code ourselves for this functionality, but security
    is an area that requires a lot of expertise to get it right, and Keycloak does
    a great job of using open standards to do this job correctly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 用户管理、身份验证和访问控制是架构中需要解决的其他几个关键部分。我们使用的是Keycloak，[3](#footnote-091) 一个开源身份和访问管理工具，用于提供这些功能。我们本可以自己编写一些代码来实现这些功能，但安全性是一个需要大量专业知识才能做到正确的领域，而Keycloak在使用开放标准来正确完成这项工作方面做得非常出色。
- en: '[1](#footnote-093-backlink) [https://angular.io/](https://angular.io/)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](#footnote-093-backlink) [https://angular.io/](https://angular.io/)'
- en: '[2](#footnote-092-backlink) [https://quarkus.io/](https://quarkus.io/)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[2](#footnote-092-backlink) [https://quarkus.io/](https://quarkus.io/)'
- en: '[3](#footnote-091-backlink) [https://www.keycloak.org/](https://www.keycloak.org/)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[3](#footnote-091-backlink) [https://www.keycloak.org/](https://www.keycloak.org/)'
- en: Plan of Attack
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 攻击计划
- en: Initially, we are going to get the core PetBattle application components and
    services up and running on OpenShift in a fairly manual way. We want to be able
    to develop locally, adding new functionality to show how easy it is to combine
    Helm and OpenShift to repeatedly deploy our code. Once that is completed, we are
    going to automate the setup and deployment process using various tools, including
    Tekton/Jenkins, Argo CD, and GitOps. We will explore how to add new components
    to our architecture using Knative and experiment with some of the more advanced
    deployment capabilities that we can utilize. Finally, in *Chapter 16*, *Own It*,
    we will look at application monitoring and alerting along with Service Mesh for
    traceability. *Figure 14.4* shows the additional components added to the architecture,
    including the Knative Cat Detector Service being proxied via the Service Mesh.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们将以相对手动的方式将核心PetBattle应用组件和服务部署到OpenShift上。我们希望能够在本地开发，增加新功能，展示Helm和OpenShift结合使用的简便性，使我们能够反复部署代码。一旦完成，我们将通过各种工具（包括Tekton/Jenkins、Argo
    CD和GitOps）来自动化设置和部署过程。我们还将探讨如何使用Knative添加新组件到架构中，并尝试一些更高级的部署能力。最后，在*第十六章*，*掌控它*中，我们将关注应用监控与告警，以及使用服务网格进行可追溯性的相关内容。*图14.4*展示了架构中添加的额外组件，包括通过服务网格代理的Knative猫侦测服务。
- en: '![](img/B16297_14_04.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_04.jpg)'
- en: 'Figure 14.4: PetBattle''s target architecture, including final OpenShift deployment'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4：PetBattle的目标架构，包括最终的OpenShift部署
- en: We will be using the command line as much as possible to show and explain the
    commands involved. Each step can also be performed via the OpenShift web console.
    If you're new to OpenShift, the web console is a great place to get started as
    it's full of tips and tutorials!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尽可能使用命令行来展示和解释相关命令。每个步骤也可以通过OpenShift网页控制台来执行。如果你是OpenShift新手，网页控制台是一个很好的起点，里面有许多提示和教程！
- en: Running PetBattle
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行PetBattle
- en: 'In *Chapter 6*, *Open Technical Practices* – *Beginnings*, *Starting Right,*
    we talked about Helm and its use as an application lifecycle manager for installing,
    upgrading, and rolling back application deployments. We are going to start with
    the command line, but you can skip to the end of this section if you would like
    to follow the web console method. If you need help installing the Helm command-line
    tool, take a look at *Chapter 6* as a refresher. Now let''s see how we can easily
    deploy the PetBattle suite of applications as Helm charts into a single project
    on OpenShift. On your terminal, add the PetBattle Helm repositories:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第六章*，*开放技术实践* - *起步*，*正确开始*中，我们讨论了Helm及其作为应用生命周期管理工具的使用，用于安装、升级和回滚应用部署。我们将从命令行开始，但如果你更喜欢使用网页控制台的方法，可以跳到本节的末尾。如果你需要帮助安装Helm命令行工具，可以回顾一下*第六章*内容。现在，让我们来看一下如何轻松地将PetBattle应用套件作为Helm图表部署到OpenShift中的单个项目中。在你的终端中，添加PetBattle
    Helm仓库：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are three main applications that make up PetBattle and are searchable
    in the Helm repository:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个主要应用组成了PetBattle，可以在Helm仓库中搜索到：
- en: '![](img/B16297_Table_14.2.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_Table_14.2.png)'
- en: 'Table 14.2: The three main applications making up PetBattle'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 表格14.2：组成PetBattle的三个主要应用
- en: The infrastructure Helm chart is normally deployed as a dependency of the Tournament
    Helm chart but can optionally be deployed alone. This can be useful for debugging
    purposes. The **Not Safe For Families** (**NSFF**) component is an optional chart,
    adding a feature whereby the API checks uploaded images for safe content for our
    family-friendly application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施Helm图表通常作为锦标赛Helm图表的依赖项进行部署，但也可以选择单独部署。这在调试过程中非常有用。**不适合家庭观看**（**NSFF**）组件是一个可选图表，提供了一项功能，可以通过API检查上传的图像是否符合我们面向家庭友好应用的安全内容标准。
- en: '![](img/B16297_Table_14.3.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_Table_14.3.png)'
- en: 'Table 14.3: The infrastructure and NSFF Helm charts'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 表格14.3：基础设施和NSFF Helm图表
- en: 'We can search for the latest versions of these charts using the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令搜索这些图表的最新版本：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s now deploy the main PetBattle application into our OpenShift cluster.
    We need to update a local copy of the PetBattle frontend''s Helm `values.yaml`
    file to match our cluster URLs. This is needed to connect the frontend when deployed
    to the correct collection of backend services. We can provide these values to
    our Helm charts when deploying the suite of PetBattle applications. Let''s download
    an example of the `values.yaml` file for us to edit:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将主 PetBattle 应用部署到 OpenShift 集群中。我们需要更新 PetBattle 前端的 `values.yaml` 文件本地副本，以匹配我们的集群
    URL。这是为了在部署时连接到正确的后端服务集群。我们可以在部署 PetBattle 应用套件时，将这些值提供给我们的 Helm 图表。让我们下载一个 `values.yaml`
    文件示例进行编辑：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Open the `values.yaml` file and replace the five URLs listed in the `config_map`
    to match your OpenShift cluster (change the `apps.cluster.com` domain to `apps-crc.testing`,
    for example, if you are using a CRC). For example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `values.yaml` 文件，并将 `config_map` 中列出的五个 URL 替换为你 OpenShift 集群的 URL（例如，如果你使用
    CRC，则将 `apps.cluster.com` 域名改为 `apps-crc.testing`）。例如：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Gather the `pet-battle`, `pet-battle-api`, and `pet-battle-tournament` into
    your cluster. To do this, you will need to be logged in to your OpenShift cluster.
    For example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `pet-battle`、`pet-battle-api` 和 `pet-battle-tournament` 集成到你的集群中。为此，你需要登录到
    OpenShift 集群。例如：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If the `pet-battle-tournament` install times out, just run it again.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `pet-battle-tournament` 安装超时，只需重新运行它。
- en: 'Each Helm install chart command should return a message similar to the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Helm 安装图表命令应返回类似以下的信息：
- en: '[PRE30]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Using `helm list` should give you a list of the installed charts. You should
    see the following pods running in your `petbattle` project. An example is shown
    in *Figure 14.5*:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `helm list` 命令可以列出已安装的 Helm 图表。你应该能在你的 `petbattle` 项目中看到以下的 Pod。示例如 *图 14.5*
    所示：
- en: '![](img/B16297_14_05.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_05.jpg)'
- en: 'Figure 14.5: PetBattle pods'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5：宠物战斗 Pod
- en: The Tournament service will take several minutes to deploy and stabilize. This
    is because its dependent infrastructure chart is deploying operator subscriptions
    for Keycloak, Infinispan, and Grafana. Navigate to the OpenShift web console and
    you should now be able to explore the PetBattle application suite as shown in
    *Figure 14.6*. Browse to the PetBattle frontend to play with the applications.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 比赛服务将需要几分钟才能部署并稳定下来。这是因为其依赖的基础设施图表正在为 Keycloak、Infinispan 和 Grafana 部署运维订阅。进入
    OpenShift Web 控制台，你现在应该能够看到如 *图 14.6* 所示的 PetBattle 应用套件。访问 PetBattle 前端，开始使用应用。
- en: '![](img/B16297_14_06.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_06.jpg)'
- en: 'Figure 14.6: PetBattle Helm charts deployed in the OpenShift Developer view'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6：在 OpenShift 开发者视图中部署的 PetBattle Helm 图表
- en: 'You have now been shown how to install PetBattle Helm charts using the command
    line—some may say the hard way! We are now going to demonstrate some of the integrated
    features of Helm in OpenShift—some may say the easier way! We can create a `HelmChartRepository`
    Custom Resource object that points to our PetBattle Helm chart repository; think
    of it as `helm repo add` for OpenShift. Run this command to install the chart
    repository:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何通过命令行安装 PetBattle Helm 图表——有人可能会说这是比较困难的方式！接下来，我们将演示 OpenShift 中 Helm
    的一些集成功能——有人可能会说这是一种更简便的方式！我们可以创建一个 `HelmChartRepository` 自定义资源对象，它指向我们的 PetBattle
    Helm 图表仓库；可以把它看作是 OpenShift 中的 `helm repo add`。运行以下命令来安装图表仓库：
- en: '[PRE36]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With this in place, we can browse to the Developer view in OpenShift and select
    Add Helm Charts, and see a menu and a form-driven approach to installing our Helm
    charts—just select a chart and install it:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，我们可以进入 OpenShift 的开发者视图，选择添加 Helm 图表，并通过菜单和表单驱动的方式安装我们的 Helm 图表——只需选择一个图表并进行安装：
- en: '![](img/B16297_14_07.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_07.jpg)'
- en: 'Figure 14.7: Adding PetBattle via the HelmChartRepository view in OpenShift'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.7：通过 OpenShift 中的 HelmChartRepository 视图添加 PetBattle
- en: This can provide a great developer experience for teams sharing services with
    each other. A backend team can produce a new app to the repository and a downstream
    team can deploy it to their developer environment in a single click. In fact,
    if you add a Helm values schema file, OpenShift will build a **What You See Is
    What You Get** (**WYSIWYG**) form for easy configuration of the values file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以为团队之间共享服务提供极好的开发者体验。后端团队可以将新应用发布到仓库，而下游团队可以通过单击操作将其部署到开发环境中。事实上，如果你添加了一个
    Helm 值模式文件，OpenShift 将构建一个 **所见即所得**（**WYSIWYG**）表单，便于配置值文件。
- en: Argo CD
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Argo CD
- en: When we established our foundations in *Section 2*, *Establishing the Foundation*,
    we bootstrapped all of our builds, deployment, and tooling using Helm and Argo
    CD. We made some opinionated choices when running that bootstrap automation and
    it's worth discussing some of the trade-offs we made in a bit more detail. We
    followed our call to action when establishing our technical foundation and planned
    out what worked for us as the PetBattle product team and reviewed and discussed
    what was working and not working so well.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在*第 2 节*中建立我们的基础时，*建立基础*，我们使用 Helm 和 Argo CD 启动了所有的构建、部署和工具。我们在运行启动自动化时做出了一些有主见的选择，值得详细讨论我们做出的一些权衡。我们在建立技术基础时遵循了我们的行动号召，并规划了适合我们作为
    PetBattle 产品团队的工作方案，同时回顾并讨论了哪些有效，哪些效果不太好。
- en: It turned out that for our development team, bootstrapping all of the CI/CD
    tools became an extremely important task. We had been given an arbitrary (but
    necessary) constraint that our development OpenShift cluster needed to be rebuilt
    from scratch every two weeks. So we needed to be confident that our CI and CD
    could stand up quickly and repeatedly. By following our everything-as-code practice,
    all of our OpenShift infrastructure definitions, CI/CD tooling, and pipeline definitions
    are stored in Git. The declared CI/CD tooling state is continuously synced to
    our development cluster by Argo CD, so updating the SonarQube Helm chart version,
    for example, is as easy as changing one line and pushing it to Git. The change
    is synchronized and rolled out to our cluster a minute later.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，对于我们的开发团队来说，启动所有的 CI/CD 工具变成了一项极为重要的任务。我们被赋予了一个任意的（但必要的）约束条件，即我们的开发 OpenShift
    集群每两周必须从头开始重建。因此，我们需要确保我们的 CI 和 CD 能够快速且反复地启动。例如，更新 SonarQube Helm 图表版本变得非常简单，只需更改一行并推送到
    Git。通过遵循我们的 "一切皆代码" 实践，所有 OpenShift 基础设施定义、CI/CD 工具以及流水线定义都存储在 Git 中。声明的 CI/CD
    工具状态由 Argo CD 持续同步到我们的开发集群，因此这种更改会在一分钟内同步并部署到我们的集群。
- en: Being able to effectively lifecycle-manage all of the supporting tools involved
    with building your applications takes effort and attention to detail, but it is
    worth it in the long run, as you will have built a system that can handle change
    easily and repeatedly. We have optimized our application lifecycle around the
    cost of change, making the cost (in man hours) as small as possible. Human time
    is our biggest resource cost after all!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 能够有效地生命周期管理所有与构建应用程序相关的支持工具需要付出努力并关注细节，但从长远来看，这是值得的，因为你将建立一个能够轻松且反复应对变化的系统。我们围绕变更的成本优化了应用生命周期，使得变更的成本（即人力成本）尽可能小。毕竟，人力时间是我们最大的资源成本！
- en: The versions of all our tooling are checked into Git using `MAJOR.MINOR` versions
    are tags that move with small bug fixes and security patches. `MAJOR.MINOR.PATCH`
    versions are not tags and yet they specify a fixed version (ideally!). Choose
    a strategy that does not incur too much technical debt that strands the team on
    old and unsupported versions forever. This is balanced with not having to constantly
    update version numbers all the time. Of course, if you have optimized for a small
    cost of change through automation, this problem of changing versions becomes much
    less of an issue!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有工具的版本都已检查并存入 Git，使用 `MAJOR.MINOR` 版本标签来标记小的 bug 修复和安全补丁。`MAJOR.MINOR.PATCH`
    版本不是标签，但它们指定了一个固定的版本（理想情况下！）。选择一个策略，不会让团队被困在旧的且不再支持的版本中。当然，如果你通过自动化优化了较小的变更成本，那么更改版本的问题就会变得不那么突出！
- en: '[4](#footnote-090-backlink) [https://semver.org/](https://semver.org/)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[4](#footnote-090-backlink) [https://semver.org/](https://semver.org/)'
- en: We have chosen a *push* (CI) and *pull* (CD) model for our software delivery
    lifecycle. The job of building images and artifacts (Helm charts and configuration),
    as well as unit and integration testing, is part of a *push* CI model. On every
    code commit, a build pipeline trigger (Tekton or Jenkins) fires. It is the job
    of the Argo CD controller to keep what we have deployed in our OpenShift cluster
    in sync with the declared application state in our Git repositories. This is a
    GitOps pull model for CI. The key thing here is that Git is the single source
    of truth and everything can be recreated from this source.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为软件交付生命周期选择了*推送*（CI）和*拉取*（CD）模型。构建镜像和工件（Helm 图表和配置）以及单元和集成测试的任务是*推送* CI 模型的一部分。在每次代码提交时，构建管道触发器（Tekton
    或 Jenkins）会被激活。Argo CD 控制器的任务是将我们在 OpenShift 集群中部署的内容与 Git 仓库中声明的应用状态保持同步。这是一个
    GitOps 拉取模型用于 CI。关键点是，Git 是唯一的可信来源，所有内容都可以从这个来源重新创建。
- en: '![](img/B16297_14_08.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_08.jpg)'
- en: 'Figure 14.8: A GitOps push and pull model for continuous delivery'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.8：持续交付的 GitOps 推送和拉取模型
- en: The main benefit we see with this approach is that it is developer-centric.
    Any change in the code base triggers a pipeline build and deployment. This gives
    the team fast feedback for any breakages, since automated tests are always run
    against the new code. The pull CD model decouples the synchronous nature of a
    build and testing pipeline. Built artifacts (container images and configuration)
    can be built once, then tagged and promoted through a lifecycle, all of which
    is controlled from Git. This is great for auditability and discovering who changed
    what and when. We can easily trace code committed and pushed with builds, tests,
    and deployments. It is also a flexible approach in that not all artifacts need
    to be built per se. Configuration can be changed and deployed using the same model.
    The model is also very flexible in its ability to support different development
    workflow models. For example, Gitflow and Trunk-based development can easily be
    catered for, depending on how the team chooses to work.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到这种方法的主要好处是它以开发者为中心。代码库中的任何变化都会触发管道构建和部署。这为团队提供了快速反馈，能迅速发现任何故障，因为自动化测试总是会针对新代码运行。拉取
    CD 模型将构建和测试管道的同步性解耦。构建的工件（容器镜像和配置）可以一次构建，然后通过整个生命周期进行标签化和推广，所有这些都由 Git 控制。这对审计非常有帮助，可以清楚地追踪是谁、在何时更改了什么。我们可以轻松地追溯提交和推送的代码，以及与构建、测试和部署相关的内容。这也是一种灵活的方法，因为并非所有工件都需要被构建。配置可以通过相同的模型进行更改和部署。该模型也非常灵活，能够支持不同的开发工作流模型。例如，Gitflow
    和基于主干的开发可以根据团队的工作方式轻松支持。
- en: Trunk-Based Development and Environments
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于主干的开发和环境
- en: When designing our initial pipelines, we mapped out the basic build, bake, deploy,
    integration testing, tag, and promotion stages. In *Figure 14.9*, we can see the
    MultiBranchPipeline Plugin, branches, and namespaces.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计初始管道时，我们绘制了基本的构建、打包、部署、集成测试、标签和发布阶段。在*图 14.9*中，我们可以看到 MultiBranchPipeline
    插件、分支和命名空间。
- en: '![](img/B16297_14_09.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_09.jpg)'
- en: 'Figure 14.9: Branches and namespaces'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.9：分支和命名空间
- en: This helped us to clarify where the responsibilities lie between our Git branches,
    our continuous integration tasks, continuous delivery tasks, and which OpenShift
    projects these would occur in.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这帮助我们明确了 Git 分支、持续集成任务、持续交付任务之间的职责划分，以及这些任务将在哪些 OpenShift 项目中执行。
- en: '![](img/B16297_14_10.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_10.jpg)'
- en: 'Figure 14.10: Branches and activities modeling'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.10：分支和活动建模
- en: Because we are following trunk-based development,[5](#footnote-089) our main/master
    branch is built, tagged, and promoted through the full lifecycle, that is, images
    are built, unit and functionally tested, and deployed into `labs-test` with end-to-end
    testing prior to deployment within the `labs-staging` project. For any short-lived
    feature branches or pull requests, we decided to only unit test, build, and deploy
    these sources into our `labs-dev` OpenShift project. That way we can customize
    which pipeline tasks happen on specific code branches. There is a trade-off between
    the time and resources used for every code commit in our pipelines, and this must
    be adjusted according to what goes into our pipelines to help improve the overall
    product quality.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们遵循基于主干的开发，[5](#footnote-089)，我们的主分支（main/master）会经历完整的生命周期，包括构建、标记和推广。也就是说，镜像会被构建、单元测试和功能测试，然后在部署到`labs-staging`项目之前，首先在`labs-test`进行端到端测试。对于任何短期存在的功能分支或拉取请求，我们决定仅进行单元测试、构建，并将这些源代码部署到我们的`labs-dev`
    OpenShift项目中。通过这种方式，我们可以定制不同代码分支上发生的管道任务。每次代码提交都会消耗一定的时间和资源，这在我们的管道中是一个权衡，必须根据管道中包含的内容进行调整，以帮助提升整体产品质量。
- en: '[5](#footnote-089-backlink) [https://trunkbaseddevelopment.com](https://trunkbaseddevelopment.com)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[5](#footnote-089-backlink) [https://trunkbaseddevelopment.com](https://trunkbaseddevelopment.com)'
- en: The Anatomy of the App-of-Apps Pattern
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用间模式的结构
- en: We choose to use Helm; remember, at its most basic, Helm is just templating
    language for packaging our Kubernetes-based application resources. Each PetBattle
    application has its own Git repository and Helm chart, making it easier to code
    independently of other apps. This inner *Helm chart per application* box is depicted
    in *Figure 14.11*. A developer can get the same experience and end result installing
    an application chart using a `helm install` as our fully automated pipeline. This
    is important from a useability perspective. Argo CD has great support for all
    sorts of packaging formats that suit Kubernetes deployments, Kustomize, Helm,
    as well as just raw YAML files. Because Helm is a templating language, we can
    mutate the Helm chart templates and their generated Kubernetes objects with various
    values.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择使用 Helm；记住，最基本的 Helm 只是一个用于打包我们基于 Kubernetes 的应用程序资源的模板语言。每个 PetBattle 应用程序都有自己的
    Git 仓库和 Helm 图表，使得独立于其他应用进行开发变得更容易。这个每个应用程序都有自己 *Helm 图表* 的框框如 *图 14.11* 所示。开发者可以通过运行
    `helm install` 安装应用图表，获得与我们的完全自动化管道相同的体验和最终结果。这在可用性角度非常重要。Argo CD 对所有适合 Kubernetes
    部署的打包格式（如 Kustomize、Helm，以及原始 YAML 文件）提供了极好的支持。因为 Helm 是一种模板语言，我们可以通过不同的值来改变 Helm
    图表模板及其生成的 Kubernetes 对象。
- en: '![](img/B16297_14_11.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_11.jpg)'
- en: 'Figure 14.11: Application packaging, Helm, and Argo CD with the app-of-apps
    pattern'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.11：应用打包、Helm 和 Argo CD 结合应用间模式
- en: One strict view of GitOps is that mutating a state is not as *pure* as just
    checking in the filled-in templates with the values themselves. Kustomize, for
    example, has no templating and follows this approach. We use Kustomize for deploying
    our CI/CD automation with Argo CD because we think it fits that use case better.
    This means that we are less likely to have a large number of CI/CD environments
    for our PetBattle product—at the moment there is just one.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps的一个严格观点是，改变状态并不像仅仅提交填写过的模板和其中的值那样*纯粹*。例如，Kustomize 没有模板化，采用了这种方法。我们使用
    Kustomize 来部署我们的 CI/CD 自动化与 Argo CD，因为我们认为它更适合这个用例。这意味着我们不太可能为我们的 PetBattle 产品拥有大量的
    CI/CD 环境——目前只有一个。
- en: 'The trade-off here is that while we use GitOps to synchronize the Helm chart
    itself, the supply of application values may come from multiple places, so you
    have to be careful to understand where overriding values and precedence occurs,
    as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的权衡是，虽然我们使用 GitOps 来同步 Helm 图表本身，但应用程序值的供应可能来自多个地方，因此你必须小心理解在哪里发生值的覆盖和优先级问题，如下所示：
- en: '`values.yaml` provided with the chart (or its sub chart dependencies)—these
    are kept in sync by the Argo CD controller.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供的`values.yaml`文件（或其子图表依赖项）——这些文件由 Argo CD 控制器保持同步。
- en: '`helm template --set` on the command line. These can be specified in a template
    or a trigger, depending on how the pipeline is run.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令行上使用 `helm template --set`。这些可以在模板或触发器中指定，具体取决于管道的运行方式。
- en: We deploy each of our applications using an Argo CD application definition.
    We use one Argo CD application definition for every environment in which we wish
    to deploy the application. This is the red box depicted in *Figure 14.11*. We
    make use of Argo CD with the app-of-apps pattern[6](#footnote-088) to bundle these
    all up; some might call this an application suite! In PetBattle we generate the
    app-of-apps definitions using a Helm chart. This is the third, outer green box
    in *Figure 14.11*. The configuration for this outer box is kept in a separate
    Git repository to our application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Argo CD 应用定义来部署每一个应用。我们为每一个希望部署的环境使用一个 Argo CD 应用定义。这是 *图 14.11* 中显示的红色框。我们使用
    Argo CD 采用应用套件模式[6](#footnote-088)将这些全部打包；有些人可能称之为应用套件！在 PetBattle 中，我们通过 Helm
    chart 生成应用套件定义。这是 *图 14.11* 中的第三个外部绿色框。该外部框的配置保存在与我们的应用不同的 Git 仓库中。
- en: 'The app-of-apps pattern is where we declaratively specify one Argo CD app that
    consists only of other apps. In our case, this is the `pet-battle-suite` application.
    We have chosen to put all of our applications that are built from the main/master
    under this `pet-battle-suite` umbrella. We have a PetBattle suite for *testing*
    and *stage* environments. *Figure 14.12* shows the app-of-apps for the stage environment:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 应用套件模式是我们声明性地指定一个仅包含其他应用的 Argo CD 应用。在我们的例子中，这就是 `pet-battle-suite` 应用。我们选择将所有从主分支/master
    构建的应用放在这个 `pet-battle-suite` 伞形下。我们有一个用于 *测试* 和 *阶段* 环境的 PetBattle 套件。*图 14.12*
    显示了阶段环境的应用套件：
- en: '![](img/B16297_14_12.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_12.jpg)'
- en: 'Figure 14.12: Argo CD, a deployed application suite'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.12：Argo CD，已部署的应用套件
- en: '[6](#footnote-088-backlink) [https://argoproj.github.io/argo-cd/operator-manual/cluster-bootstrapping/#app-of-apps-pattern](https://argoproj.github.io/argo-cd/operator-manual/cluster-bootstrapping/#app-of-apps-pattern)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[6](#footnote-088-backlink) [https://argoproj.github.io/argo-cd/operator-manual/cluster-bootstrapping/#app-of-apps-pattern](https://argoproj.github.io/argo-cd/operator-manual/cluster-bootstrapping/#app-of-apps-pattern)'
- en: 'In Git, we model different branches using the following patterns:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Git 中，我们使用以下模式建模不同的分支：
- en: '`labs-test`, `labs-staging`)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`labs-test`, `labs-staging`)'
- en: '`labs-dev` namespace only'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅限 `labs-dev` 命名空间
- en: The Argo CD sync policy for our applications is set to *automated* + *prune*,
    so that child apps are automatically created, synced, and deleted when the manifest
    is changed. You can change or disable this if you need to. We also configure a
    webhook against the CI/CD Git repository so that any changes trigger Argo CD to
    sync all applications; this avoids having to wait for the three-minute sync cycle
    when CI/CD code changes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用的 Argo CD 同步策略设置为 *自动化* + *修剪*，这样子应用会在清单更改时自动创建、同步和删除。如果需要，你可以更改或禁用此设置。我们还会配置一个针对
    CI/CD Git 仓库的 webhook，以便任何更改都会触发 Argo CD 同步所有应用；这避免了当 CI/CD 代码更改时需要等待三分钟的同步周期。
- en: The Git revision can be set to a specific Git commit **Secure Hash Algorithm**
    (**SHA**) for each child application. A Git SHA is a unique 40-character code
    computed for every commit to the repository, and is therefore not movable, unlike
    a tag. This ensures that even if the child app's repository changes, the app will
    only change when the parent app changes that revision. Alternatively, you can
    set it to HEAD/master/main or a branch name to keep in sync with that particular
    branch. It's a good idea to use Git commit SHAs to manage your application versions
    the closer you are to production environments. Pinning to an exact version for
    production ensures easier traceability when things go wrong. The structure here
    is flexible to suit your product team's needs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Git 修订版可以为每个子应用设置为特定的 Git 提交 **安全哈希算法** (**SHA**) 值。Git SHA 是为每次提交到仓库时计算出的独特的
    40 字符代码，因此是不可移动的，不像标签。这样可以确保即使子应用的仓库发生变化，只有当父应用更改该修订版时，应用才会发生变化。或者，你可以将其设置为 HEAD/master/main
    或分支名称，以保持与特定分支同步。越接近生产环境，使用 Git 提交 SHA 来管理应用版本是一个好主意。将生产环境固定为确切版本可以确保在出现问题时更容易追踪。此结构是灵活的，可以根据你的产品团队的需求进行调整。
- en: Build It – CI/CD for PetBattle
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建它 – PetBattle 的 CI/CD
- en: Let's get our hands dirty now by getting down into the weeds with some more
    techie stuff. How do we go from code to running in production in a repeatable
    and safe way? If you remember all the way back in *Section 2*, *Establishing the
    Foundation*, we learned about Derek the DevOps dinosaur and the obstacles we put
    him through to test his fearsomeness. We will now do the same thing with our PetBattle
    apps, beginning with the frontend.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们动手深入了解一些更技术性的话题。我们如何以可重复和安全的方式将代码从开发阶段推向生产环境？如果你还记得在*第 2 节*、*建立基础*中，我们了解了
    DevOps 恐龙 Derek，以及我们为测试他威慑力所经历的种种困难。现在，我们将以相同的方式开始处理我们的 PetBattle 应用，首先从前端开始。
- en: The Big Picture
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大致架构
- en: Before we touch a line of code, we always like to keep an eye on the Big Picture.
    This helps us frame what the tool is and why we are using it, and to scaffold
    out our pipeline from a very high level. Let's build the details of how we manage
    the PetBattle source code in this same way. As a subtle reminder, the PetBattle
    frontend is an Angular application. It was built using Node.js v12 and is deployed
    to a Red Hat Nginx image.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们接触任何一行代码之前，我们总是喜欢关注大致架构。这有助于我们框定工具的作用和使用原因，并从高层次构建出我们的流水线。让我们以相同的方式构建我们管理
    PetBattle 源代码的细节。顺便提醒一下，PetBattle 前端是一个 Angular 应用程序。它使用 Node.js v12 构建，并部署到 Red
    Hat Nginx 镜像上。
- en: Continuing our Big Picture from the foundation, let's add the steps we will
    consider implementing for the PetBattle frontend so we can get it ready for a
    high frequency of change being pushed through it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在从基础开始的大致架构基础上，让我们添加一些我们考虑在 PetBattle 前端实现的步骤，以便为频繁的变更推送做好准备。
- en: '![](img/B16297_14_13.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_13.jpg)'
- en: 'Figure 14.13: The Big Picture including the tools the team thinks they will
    use'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.13：大致架构，包括团队认为将使用的工具
- en: 'As a quick reminder, our Big Picture from *Section 2*, *Establishing the Foundation*,
    identified all the tools we might use as depicted in *Figure 14.13*, which include:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 快速提醒一下，我们在*第 2 节*、*建立基础*中定义的大致架构，识别了我们可能使用的所有工具，如*图 14.13*所示，包括：
- en: 'Jenkins: To automate the building and testing of our software'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins：用于自动化构建和测试我们的软件
- en: 'Nexus: To host our binaries and Helm charts'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nexus：用于托管我们的二进制文件和 Helm 图表
- en: 'Argo CD: To manage our deployments'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Argo CD：用于管理我们的部署
- en: 'SonarQube: To assess our code quality'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SonarQube：用于评估我们的代码质量
- en: 'Zalenium: For automated browser testing'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zalenium：用于自动化浏览器测试
- en: Now that the tools are in place, let's think about the stages our code should
    move through for being deployed. A team should start small—what is the minimum
    amount of automation we need to get code compiling and deployed? It's very important
    for teams to start small with a basic end-to-end flow of their code; otherwise,
    things become messy quite quickly, leading to unnecessary complexity and potentially
    not delivering anything. It's also important because the feedback loop we are
    creating needs to be fast. We don't want a brilliant, complex process that thinks
    of everything but takes hours to run! It's not the kind of feedback loop we're
    trying to create.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在工具已到位，让我们思考一下代码在部署过程中应经过哪些阶段。团队应从小处开始——我们需要多少自动化才能使代码编译并部署？团队开始时非常重要，要有一个简单的端到端流程，否则，事情会很快变得混乱，导致不必要的复杂性，甚至可能什么都不交付。它还很重要，因为我们正在创建的反馈回路需要是快速的。我们不想要一个很复杂、考虑周全的过程，但需要几个小时才能运行！这不是我们想要创建的反馈回路。
- en: 'We always use three simple stages: Build > Bake > Deploy. A good pattern for
    engineers to take is to keep to an abstract definition of their pipeline so they
    can get greater reuse of the pattern across any of their apps, irrespective of
    the technology they use. Each stage should have a well-defined interface with
    input and output. Reusing a pipeline definition in this way can lower the context
    switch when moving between backend and frontend. With this in mind, we can define
    the stages of our build in the following manner.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是使用三个简单的阶段：构建 > 烘焙 > 部署。对于工程师来说，一个好的模式是保持对他们流水线的抽象定义，这样他们可以在任何应用程序中更好地复用这个模式，无论使用何种技术。每个阶段应该有一个明确的接口，包含输入和输出。以这种方式复用流水线定义可以减少在后端和前端之间切换的上下文切换。考虑到这一点，我们可以以以下方式定义我们构建的各个阶段。
- en: The Build
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建
- en: '*Input*: *The code base*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*输入*：*代码库*'
- en: '*Output*: *A "compiled" and unit-tested software artifact*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*输出*：*一个“已编译”并且经过单元测试的软件工件*'
- en: '![](img/figure-14-14.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure-14-14.jpg)'
- en: 'Figure 14.14: The BUILD component from the Big Picture'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.14：大致架构中的 BUILD 组件
- en: The build should always take our source code, compile it, and run some unit
    tests before producing some kind of artifact that will be stored in Nexus. By
    defining the interface of the build process as lightly as this, it means we can
    substitute the implementation of what that looks like in each technology or application
    type. So, for example, when building the PetBattle frontend Angular app, we will
    use the **Node Package Manager** (**npm**) to complete these steps within the
    Build stage, but a Java application would likely use Gradle or Maven to achieve
    the same effect. The hardest work will happen in this stage and it is usually
    what has the highest dependency on the framework or language that's being used.
    We will see this in later stages; the technology originally being used becomes
    less important, so higher reuse of code can occur.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程应该始终采用我们的源代码，编译它，并在生成某种制品之前运行一些单元测试，这些制品将存储在 Nexus 中。通过将构建过程的接口定义得如此简单，我们可以在每种技术或应用程序类型中替换实现。例如，当构建
    PetBattle 前端 Angular 应用程序时，我们将使用 **Node 包管理器** (**npm**) 在构建阶段完成这些步骤，但 Java 应用程序可能会使用
    Gradle 或 Maven 来实现相同的效果。最困难的工作将在这一阶段完成，通常它对所使用的框架或语言的依赖性最大。我们将在后续阶段看到，最初使用的技术变得不那么重要，因此代码的重用性可以更高。
- en: The Bake
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 烘焙阶段
- en: '*Input*: *A "compiled" software artifact*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*输入*: *一个“已编译”软件制品*'
- en: '*Output*: *A tagged* *container image*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*输出*: *一个已标记的* *容器镜像*'
- en: '![](img/figure-14-15.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure-14-15.jpg)'
- en: 'Figure 14.15: The BAKE component from the Big Picture'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.15：大图中的 BAKE 组件
- en: This is the act of taking our software artifact that was created as an output
    in the previous step and packaging it into a box, that is, a Linux Container Image.
    This image is then tagged and stored in a container registry, either one built
    into OpenShift or an external one. In OpenShift there are many different ways
    we can achieve this, such as using source-2-image, binary build, or providing
    a Containerfile/Dockerfile.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将我们在前一步作为输出创建的软件制品打包成一个盒子，即 Linux 容器镜像的过程。然后，这个镜像会被标记并存储在容器注册中心中，可以是 OpenShift
    内置的，也可以是外部的。在 OpenShift 中，我们有多种方式可以实现这一点，例如使用 source-2-image、二进制构建或提供 Containerfile/Dockerfile。
- en: The Deploy
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署阶段
- en: '*Input*: *A tagged image*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*输入*: *一个已标记的镜像*'
- en: '*Output*: *A running app in a given environment*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*输出*: *在特定环境中运行的应用程序*'
- en: '![](img/figure-14-16.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure-14-16.jpg)'
- en: 'Figure 14.16: The DEPLOY component from the Big Picture'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.16：大图中的 DEPLOY 组件
- en: Take the image that has just been pushed to the registry and deploy it along
    with any other services or configuration required for it to run. Our applications
    will be packaged as Helm charts, so the deployment will likely have to patch the
    image referenced in our app's chart. We want our pipeline to support multiple
    workflows. For feature development, we can just `helm install` into the development
    namespace. But for release candidates, we should be committing new release information
    to Git for it to trigger the rollout of changes. The implementation of this workflow
    is the responsibility of the steps, the lower level of what is being executed.
    The abstract view of a Deploy should result in a *verified* app deployed on our
    cluster (and ultimately promoted all the way to production).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将刚刚推送到注册中心的镜像以及任何其他运行所需的服务或配置一起部署。我们的应用程序将打包为 Helm 图表，因此部署可能需要修补我们应用程序图表中引用的镜像。我们希望我们的流水线支持多种工作流。对于功能开发，我们可以直接
    `helm install` 到开发命名空间。但对于发布候选版本，我们应该将新的发布信息提交到 Git，以触发变更的发布。这一工作流的实现是步骤的责任，即正在执行的低级内容。部署的抽象视图应该导致一个*已验证*的应用程序被部署到我们的集群上（并最终推广到生产环境）。
- en: The team captures these stages for the applications they're building by adding
    some nice doodles to their Big Picture. Next, they begin thinking about promoting
    the application across the environment from test to production. When building
    applications in containers, we want to ensure the app can run in any environment,
    so controlling application configuration separately is vital. The team will not
    want to rebuild the application to target different environments either, so once
    an image is baked and deployed it needs to be verified before promotion. Let's
    explore these stages further.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 团队通过在他们的大图中添加一些漂亮的涂鸦来捕捉他们构建的应用程序的这些阶段。接下来，他们开始考虑如何将应用程序从测试环境推广到生产环境。在容器中构建应用程序时，我们希望确保该应用程序可以在任何环境中运行，因此单独控制应用程序配置至关重要。团队也不希望为了不同的环境而重新构建应用程序，因此一旦镜像构建并部署，它在推广之前需要进行验证。让我们进一步探讨这些阶段。
- en: System Test
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统测试
- en: '*Input*: *The app name and version under test*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*输入*: *正在测试的应用程序名称和版本*'
- en: '*Output*: *A successful test* *report and verified app*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*输出*: *成功的测试* *报告和经过验证的应用程序*'
- en: '![](img/figure-14-17.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure-14-17.jpg)'
- en: 'Figure 14.17: The SYSTEM TEST component from the Big Picture'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.17：来自大图的系统测试组件
- en: Drive the user behavior within the application via the frontend by verifying
    whether the app is behaving as expected. If all the connected parts that make
    up the application are behaving as expected (the microservices, authentication,
    and frontend) then the app can be signed off and will not need to be rebuilt.
    Our system test cases for PetBattle will be the acceptance criteria the team has
    agreed upon. Because of this, we can sign off the application as ready for real-world
    users. Any component that has changed in the stack should trigger this stage;
    it is not just the responsibility of the frontend.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前端驱动应用程序中的用户行为，验证应用程序是否按预期行为运行。如果构成应用程序的所有连接部分（微服务、身份验证和前端）都按预期工作，那么应用程序可以通过审核，并且不需要重新构建。我们为PetBattle编写的系统测试用例将是团队已经同意的验收标准。因此，我们可以将应用程序签署为准备好交给真实用户使用。任何在栈中发生变化的组件都应该触发此阶段；这不仅仅是前端的责任。
- en: Promote
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推广
- en: '*Input*: *A verified image name and version*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*输入*: *经过验证的镜像名称和版本*'
- en: '*Output*: *Running app in production environment*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*输出*: *在生产环境中运行应用程序*'
- en: '![](img/figure-14-18.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure-14-18.jpg)'
- en: 'Figure 14.18: The PROMOTE component from the Big Picture'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.18：来自大图的推广组件
- en: With the application working as expected (based on our passing system test cases),
    we can now promote the images that make up our app to the new environment, along
    with their configuration. Of course, in the world of GitOps, this is not a manual
    rollout of a new deployment but committing the new version and any custom configuration
    to our configuration repositories, where they will be picked up by Argo CD and
    deployed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序按预期工作（基于我们通过的系统测试用例）后，我们现在可以将构成我们应用程序的镜像及其配置推广到新环境中。当然，在GitOps的世界中，这并不是手动推出新的部署，而是将新版本和任何自定义配置提交到我们的配置仓库，在那里它们将被Argo
    CD接收并部署。
- en: '![](img/figure-14-19.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure-14-19.jpg)'
- en: 'Figure 14.19: The Big Picture including all the stages of the pipeline in place'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.19：包含所有管道阶段的大图
- en: In *Figure 14.19*, we can see the Big Picture with the stages of the pipeline
    drawn in. Now that the team knows the stages that their software will pass through
    on the way across the cluster, they can fill in the lower-level details, the steps.
    At this stage, the team is looking to see how they can build common pipeline steps,
    irrespective of the technology they're using. This will provide greater reuse
    across their software stack but, more importantly, reduce the cognitive load for
    engineers writing software in multiple technologies. For this, it's a good idea
    to put on the Big Picture the technology being used. In PetBattle's case, it is
    Angular and Quarkus (Node.js and Maven for the build tools). They use a new color
    sticky to write the steps that each service will go through in order to fulfill
    the interface defined at each stage.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 14.19*中，我们可以看到包含管道各个阶段的大图。现在，团队已经知道他们的软件将在跨越集群时会经历哪些阶段，他们可以填充更低层次的细节，即每个步骤。在这个阶段，团队正试图找到如何构建通用的管道步骤，而不考虑他们使用的技术。这将使他们的软件栈可以更好地复用，但更重要的是，减少为多种技术编写软件的工程师的认知负担。为此，把使用的技术标注在大图上是一个好主意。在PetBattle的案例中，使用的是Angular和Quarkus（构建工具是Node.js和Maven）。他们使用新的颜色便签写下每个服务为了完成每个阶段定义的接口将经过的步骤。
- en: In *Figure 14.20*, we detail what these steps could look like for the Build
    stage of our pipeline. First, we install the application dependencies. Following
    this, we test, lint, and compile the code. Finally, we store the successful artifacts
    in the Nexus repository to use in the next stage, the Bake.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 14.20*中，我们详细描述了管道构建阶段可能的步骤。首先，我们安装应用程序依赖项。接着，我们测试、校验并编译代码。最后，我们将成功的构建工件存储到Nexus仓库中，以便在下一个阶段——烘焙阶段中使用。
- en: '![](img/B16297_14_20.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_20.jpg)'
- en: 'Figure 14.20: The Build stage and the breakdown of its steps'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.20：构建阶段及其步骤的细分
- en: 'The team continues to flesh out the steps across all the stages. Finally, they
    add some example containers deployed to each namespace at each stage to give a
    view of all the components deployed for the PetBattle system to work. This is
    detailed in *Figure 14.21*:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 团队继续完善各个阶段的步骤。最终，他们为每个阶段添加了一些示例容器，部署到每个命名空间，以展示为使PetBattle系统正常运行而部署的所有组件的视图。具体内容请参见*图14.21*：
- en: '![](img/figure-14-21.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure-14-21.jpg)'
- en: 'Figure 14.21: The complete Big Picture for our software delivery process'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.21：我们软件交付过程的完整大局观
- en: The Big Picture is a helpful practice for getting team alignment on what's in
    our toolchain and how we use it. It can be a great thing to play back to non-technical
    team members too, giving them an idea of the complexity and usefulness of being
    able to repeatedly build and test code. As with all our practices, it's also never
    done; when a new tool enters our toolchain or we add a new stage in our pipeline,
    we add it to the Big Picture first. It is the living and breathing documentation
    of our software delivery process. With the Big Picture complete for now, let's
    move on to implementing the components it describes.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 大局观是一种有助于团队统一工具链内容及其使用方式的实践。这也是一个很好的工具，可以向非技术团队成员展示，帮助他们理解能够反复构建和测试代码的复杂性和实用性。和我们所有的实践一样，它也永远不会完成；当有新的工具进入我们的工具链，或者我们在管道中添加了新阶段时，我们首先将其添加到大局观中。它是我们软件交付过程的活文档。现在大局观已完成，我们继续实现它所描述的组件。
- en: Choose Your Own Adventure
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择你自己的冒险
- en: We understand that there are many ways to do anything and in software development,
    there are usually hundreds or even more. With this in mind, we hope to meet you,
    dear reader, where you are now. By this, we mean that the next section will identify
    two ways of doing the same thing, so take the approach that better fits your own
    context.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理解，做任何事都有很多方法，软件开发中通常有成百上千种甚至更多的方法。考虑到这一点，我们希望在此与亲爱的读者相遇。我们的意思是，接下来的章节将介绍两种实现同一目标的方法，请根据自己所在的上下文选择更适合的方式。
- en: Jenkins is the build tool of choice for lots of companies and developers alike.
    It has been around for some time and it has its set of quirks for sure. It was
    never intended to be deployed as a container when it was first conceived. In order
    to keep things current and have an eye on the future, we've decided to write the
    code for the Big Picture using both Tekton and Jenkins. Both can easily be tweaked
    for both frontend and backend development, but for the purposes of this book we
    will use Jenkins to automate the parts of the Big Picture for our Angular application.
    For the API, written in Java (Quarkus), we will use Tekton, and go through setting
    up the same things in a more Kubernetes native way. Both paths are available for
    the avid reader to play with and get working, but we'll split the narrative this
    way for illustrative purposes.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins是许多公司和开发者首选的构建工具。它已经存在一段时间了，当然它也有一些特点。当它最初构思时，Jenkins并没有考虑以容器的形式部署。为了保持与时俱进并展望未来，我们决定使用Tekton和Jenkins编写大局观的代码。两者都可以轻松调整用于前端和后端开发，但为了本书的目的，我们将使用Jenkins来自动化Angular应用程序的大局观部分。对于用Java（Quarkus）编写的API，我们将使用Tekton，并以更符合Kubernetes的方式来设置相同的内容。这两条路径都可以供热衷的读者进行尝试并运行，但我们将以这种方式拆分叙述，以便更好地说明。
- en: So, like you would in a *choose your own adventure* book, you can now pick the
    path that you would like to follow next. If you're not interested in Jenkins automation,
    then skip ahead to the Tekton section directly. The code for both options is available
    in the Git repositories for the book.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，就像你在*选择你自己的冒险*书籍中一样，现在你可以选择接下来想要跟随的路径。如果你对Jenkins自动化不感兴趣，可以直接跳到Tekton部分。本书中两个选项的代码都可以在Git仓库中找到。
- en: Before attempting the pieces in this chapter, make sure to have completed the
    bootstrap steps in *Chapter 7,* *Open Technical Practices –* *The Midpoint*, under
    the *Implementing GitOps – Let's Build the Big Picture With Some Real Working
    Code!* section. These steps deploy the CI/CD tooling into your cluster using GitOps.
    The main tools we are going to use in the next sections include Jenkins, Argo
    CD, and Tekton.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试本章中的内容之前，请确保已完成*第7章*中的引导步骤，*开放技术实践——* *中点*部分，位于*实施GitOps——让我们用一些真实的工作代码来构建大局观！*章节下。这些步骤使用GitOps将CI/CD工具部署到您的集群中。接下来的章节我们将使用的主要工具包括Jenkins、Argo
    CD和Tekton。
- en: Jenkins–The Frontend
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jenkins–前端
- en: Jenkins is our trusty friend who will do the hard crunching of code—compiling,
    testing, and so on—on our behalf. In order to get the best out of all the tools
    in our kit bag, there are a few items we need to configure first. This includes,
    among other things, managing secrets and adding webhooks to trigger our Jenkins
    automation as soon as a developer commits their code.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins是我们值得信赖的伙伴，它将为我们处理繁重的代码工作——编译、测试等。为了充分利用工具包中的所有工具，我们首先需要配置一些项目。这包括但不限于管理机密信息并添加webhook，以便开发人员提交代码时，能够触发我们的Jenkins自动化。
- en: Connect Argo CD to Git
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将Argo CD连接到Git
- en: Let's talk about GitOps. We want our Git repositories to be the single source
    of truth and the Argo CD controller to analyze the differences between what is
    currently deployed to our cluster and what is stored in our Git repositories.
    Argo CD can do things based on the difference it sees between the desired state
    (in Git) and the actual state (in the cluster) such as automatically synchronizing
    them or sending a notification to say that these two states are not as expected.
    For example, in Git we may have set version 123 of our application but the cluster
    currently has version 122 deployed.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来谈谈GitOps。我们希望我们的Git仓库成为唯一的真理源，并且Argo CD控制器分析当前部署到我们集群中的内容与存储在Git仓库中的内容之间的差异。Argo
    CD可以根据它看到的所需状态（在Git中）与实际状态（在集群中）之间的差异，执行一些操作，比如自动同步它们，或发送通知表明这两种状态不符合预期。例如，在Git中我们可能设置了版本123的应用程序，但集群中当前部署的是版本122。
- en: To create this connectivity between our configuration repository and Argo CD,
    we need to create an Argo CD app-of-apps to point to the repository. The app-of-apps
    pattern is a neat way to describe all elements of a system. Imagine we have an
    app, named `App-1`, which is our full system. This `App-1` is made up of independently
    deployable services such as `App-1a`, `App-1b`, `App-1c`, and so on. For PetBattle,
    we have the whole system that is all of our frontend, APIs, and other services.
    We also have one of these for our staging and test environments; this allows us
    to think of our app-of-apps as a suite of applications.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的配置仓库和Argo CD之间建立这种连接，我们需要创建一个指向仓库的Argo CD应用程序-应用程序的集合。应用程序-应用程序的集合模式是一种描述系统所有元素的简洁方式。假设我们有一个名为`App-1`的应用程序，它代表我们的完整系统。这个`App-1`由可独立部署的服务组成，例如`App-1a`、`App-1b`、`App-1c`等。对于PetBattle，我们有整个系统，包含前端、API和其他服务。我们也为我们的暂存和测试环境创建了类似的应用集合；这使得我们可以将应用程序-应用程序的集合视为一套应用程序。
- en: If we clone the `ubiquitous-journey`[7](#footnote-087) project that we set up
    in *Chapter 7*, *Open Technical Practices* – *The Midpoint,* to bootstrap our
    cluster, there is another set of charts in here for our application stacks located
    in *applications*/*deployments*. When applied, these definitions will create our
    Argo CD application Custom Resource pointing to our Helm charts that will be created
    by the running builds on either Tekton or Jenkins.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们克隆我们在*第七章*中建立的`ubiquitous-journey`[7](#footnote-087)项目，以启动我们的集群，那么这里会有另一组用于我们的应用栈的图表，这些应用栈位于*applications*/*deployments*中。应用这些定义将创建一个指向我们的Helm图表的Argo
    CD应用程序自定义资源，这些图表将在Tekton或Jenkins的构建过程中创建。
- en: The values files (`values-applications-stage.yaml`) contain the Helm chart version
    and application version that will be updated by Jenkins on successful builds.
    We want Argo CD to monitor these values when applying changes to the cluster.
    These values files also contain our overrides to the base Helm chart for specific
    environments, for example, the config map that the frontend is configured with
    to communicate with the services it requires to work properly (`tournament-svc`,
    `cats-svc`, and so on). The following snippet shows the definition of this. These
    values will differ between development, testing, and staging, so this pattern
    gives us the ability to version control the configuration we want the application
    to use on startup.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件(`values-applications-stage.yaml`)包含Helm图表版本和应用程序版本，这些将在Jenkins成功构建后更新。我们希望Argo
    CD在应用更改到集群时监控这些值。这些值文件还包含我们对基本Helm图表在特定环境中的覆盖内容，例如，前端配置的配置地图，用于与它所需的服务进行通信（`tournament-svc`、`cats-svc`等）。以下代码片段展示了这一点。这些值在开发、测试和暂存环境之间有所不同，因此这种模式使我们能够对应用程序启动时使用的配置进行版本控制。
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[7](#footnote-087-backlink) [https://github.com/petbattle/ubiquitous-journey](https://github.com/petbattle/ubiquitous-journey)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[7](#footnote-087-backlink) [https://github.com/petbattle/ubiquitous-journey](https://github.com/petbattle/ubiquitous-journey)'
- en: So, when we deploy an Argo CD application pointing to this Git repository, it
    will find additional apps and so create our app-of-apps pattern. The structure
    of the repository is trimmed, but you can see that the chart is very basic, having
    just two templates for creating a project in Argo CD and the application definitions
    to put inside the project.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们部署一个指向这个 Git 仓库的 Argo CD 应用时，它会找到额外的应用并创建我们的应用的应用模式。仓库的结构被简化了，但你可以看到这个图表非常基础，只有两个模板：一个用来在
    Argo CD 中创建项目，另一个用来在项目中定义应用。
- en: '[PRE64]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We could go to the Argo CD UI and connect it to this repository manually, or
    use the Argo CD CLI to create the Argo CD application Custom Resource, but let''s
    just run this handy one-liner to connect things up for both our staging and test
    app-of-apps:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以去 Argo CD UI 手动将它连接到这个仓库，或者使用 Argo CD CLI 创建 Argo CD 应用的自定义资源，但我们不如直接运行这个便捷的一行命令，连接我们预生产和测试的应用模式：
- en: '[PRE80]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: With these in place, we should see Argo CD create the app-of-apps definitions
    in the UI, but it will be unable to sync with the child applications. This is
    because we have not built them yet! Once they are available, Argo CD will kick
    in and sync them up for us.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好这些后，我们应该能在 UI 中看到 Argo CD 创建了应用的应用定义，但它无法与子应用同步。这是因为我们还没有构建它们！一旦它们可用，Argo
    CD 会启动并为我们同步它们。
- en: '![](img/B16297_14_22.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_22.jpg)'
- en: 'Figure 14.22: Argo CD sync of the pet-battle application suite for the staging
    environment'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.22：Argo CD 同步 PetBattle 应用套件到预生产环境
- en: 'To extend this app-of-apps pattern now is very simple. We only need to connect
    Git to Argo CD this one time. If, after the next few Sprints, the PetBattle team
    realizes they need to add a new component or service, they can simply extend the
    values YAML, that is, `values-applications-stage.yaml` or `values-applications-test.yaml`
    for their staging or test environment, with a reference to the new component chart
    location and version. For example, for `cool-new-svc`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在扩展这个应用的应用模式非常简单。我们只需连接一次 Git 和 Argo CD。如果在接下来的几个 Sprint 后，PetBattle 团队意识到他们需要添加新的组件或服务，他们只需扩展
    `values.yaml` 文件，即 `values-applications-stage.yaml` 或 `values-applications-test.yaml`，为其预生产或测试环境添加对新组件图表位置和版本的引用。例如，对于
    `cool-new-svc`：
- en: '[PRE87]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Secrets in Our Pipeline
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们流水线中的密钥
- en: Jenkins is going to be responsible for compiling our code, pushing the image
    to a registry, and writing values to Git. This means Jenkins is going to need
    some secrets! In our case, we're using Quay.io for hosting our images so Jenkins
    will need the access to be able to push our packaged Container Images to this
    repository, which requires authentication. If you're following along with forks
    of the PetBattle repositories and want to create your own running `pet-battle`
    instance, go ahead and sign up for a free account on [https://quay.io/](https://quay.io/).
    You can log in with GitHub, Google, or your Red Hat account.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 将负责编译我们的代码，将镜像推送到注册中心，并将值写入 Git。这意味着 Jenkins 需要一些密钥！在我们的案例中，我们使用 Quay.io
    来托管镜像，因此 Jenkins 需要访问权限，以便能够将我们的打包容器镜像推送到该仓库，这需要身份验证。如果你正在跟随 PetBattle 仓库的分支并希望创建你自己的
    `pet-battle` 实例，可以去 [https://quay.io/](https://quay.io/) 注册一个免费的账户。你可以通过 GitHub、Google
    或你的 Red Hat 账户登录。
- en: Quay.io
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Quay.io
- en: When on Quay, create three new repositories, one for each of the application
    components that we will be building. You can mark them as public, as private repositories
    cost money.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Quay 上创建三个新仓库，每个仓库对应我们将要构建的一个应用组件。你可以将它们标记为公开仓库，因为私有仓库需要付费。
- en: '![](img/B16297_14_23.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_23.jpg)'
- en: 'Figure 14.23: PetBattle images in Quay.io'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.23：Quay.io 中的 PetBattle 镜像
- en: These repositories serve as empty image stores for us to push our images to
    from within the pipeline. But we need to provide Jenkins with the correct access
    to be able to push them, so go ahead and hit the robot icon on the UI to create
    a new service account that Jenkins can use. Give it a sensible name and description
    for readability.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这些仓库作为我们推送镜像的空镜像存储，但我们需要提供正确的 Jenkins 访问权限来推送它们，因此点击 UI 上的机器人图标创建一个新的服务账户，供
    Jenkins 使用。给它起个合适的名字和描述以提高可读性。
- en: '![](img/B16297_14_24.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_24.jpg)'
- en: 'Figure 14.24: Robots in Quay.io'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.24：Quay.io 中的机器人
- en: 'We are going to mark all the repositories we created previously as Write by
    this robot. Hit Add permissions:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把之前创建的所有仓库标记为由这个机器人写入。点击添加权限：
- en: '![](img/B16297_14_25.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_25.jpg)'
- en: 'Figure 14.25: Robot RBAC in Quay.io'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.25：Quay.io 中的机器人 RBAC
- en: Now that the repositories and robot account have been created, we can download
    the secret to be used in our pipelines! Hit the cog on the side of the secret
    name and select View Credentials.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在仓库和机器人账户已经创建，我们可以下载将用于管道的密钥！点击密钥名称旁边的齿轮图标，选择查看凭证。
- en: '![](img/B16297_14_26.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_26.jpg)'
- en: 'Figure 14.26: How to view the robot credentials in Quay.io'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.26：如何在 Quay.io 查看机器人凭证
- en: On the page that pops up, download the Kubernetes YAML and store it in your
    fork of `pet-battle`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在弹出的页面中，下载 Kubernetes YAML 文件并将其存储在你自己的 `pet-battle` 分支中。
- en: '![](img/B16297_14_27.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_27.jpg)'
- en: 'Figure 14.27: Downloading the Kubernetes secret'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.27：下载 Kubernetes 密钥
- en: 'We can apply it to our cluster (ensure you are logged in first):'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其应用于我们的集群（首先确保你已经登录）：
- en: '[PRE104]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: GitHub
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GitHub
- en: A secret is also required for Jenkins to be able to push updates to our Helm
    values files stored in Git. The values files for our applications will contain
    the properties we want to pass to our templates, such as ConfigMap variables,
    or locations of images, such as Quay.io. Our values files for the deployment of
    our applications will also hold a reference to the image version (that is, the
    SemVer of our app, such as 1.0.1) to be deployed by patching our DeploymentConfigs.
    We don't want to manually update this but have a robot (Jenkins) update this when
    there has been a successful build. Therefore, this secret will be needed to write
    these changes in versions to our configured repositories, which are being pointed
    out by Argo CD. We track version changes across all our environments in this way
    because, after all, if it's not in Git, it's not real.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 还需要一个密钥，以便能够推送更新到我们存储在 Git 中的 Helm 值文件。我们应用程序的值文件将包含我们希望传递给模板的属性，例如
    ConfigMap 变量，或者图像的位置，例如 Quay.io。我们应用程序部署的值文件还将包含一个指向要通过补丁更新我们的 DeploymentConfigs
    进行部署的图像版本的引用（即我们应用程序的 SemVer，例如 1.0.1）。我们不希望手动更新这个，而是希望由机器人（Jenkins）在构建成功后更新它。因此，这个密钥将用于将这些版本更改写入我们的配置仓库，这些仓库由
    Argo CD 指定。我们以这种方式跟踪所有环境中的版本变化，因为毕竟，如果不在 Git 中，它就不是真实的。
- en: To create a secret for GitHub, simply go to the Developer Settings view. While
    logged into GitHub, that's **Settings > Developer Settings > Personal access tokens**
    or [https://github.com/settings/tokens](https://github.com/settings/tokens) for
    the lazy. Create a new **Personal Access Token** (**PAT**); this can be used to
    authenticate and push code to the repository. Give it a sensible name and allow
    it to have repository access.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 GitHub 创建密钥，只需进入开发者设置视图。在登录 GitHub 的情况下，路径为 **设置 > 开发者设置 > 个人访问令牌**，或者直接访问
    [https://github.com/settings/tokens](https://github.com/settings/tokens) 以便快捷操作。创建一个新的
    **个人访问令牌**（**PAT**）；这个令牌可以用来进行身份验证并将代码推送到仓库。为它取个合适的名字，并允许它访问仓库。
- en: '![](img/B16297_14_28.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_28.jpg)'
- en: 'Figure 14.28: GitHub personal access token permissions'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.28：GitHub 个人访问令牌权限
- en: 'Save the token''s value, as you won''t be able to access it again without generating
    a new one. With the token in place, we can create a secret in Jenkins by adding
    it to a `basic-auth` secret. In order for Jenkins, which is running in the same
    namespace as where this secret will be created, to be able to consume the value
    of the secret, we can apply a special annotation, `credential.sync.jenkins.openshift.io:
    "true"`. This little piece of magic will allow any credentials to be updated in
    Jenkins by only updating the secret!'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '保存令牌的值，因为没有生成新令牌之前，你将无法再次访问它。获取令牌后，我们可以通过将其添加到 `basic-auth` 密钥中来在 Jenkins 中创建一个密钥。为了使与该密钥将在同一命名空间中运行的
    Jenkins 能够使用该密钥的值，我们可以应用一个特殊的注解，`credential.sync.jenkins.openshift.io: "true"`。这一小段魔法将允许通过仅更新密钥来在
    Jenkins 中更新任何凭证！'
- en: 'Update the secret with your values for `GITHUB_TOKEN` and `GITHUB_USERNAME`
    if you''re following along in your own fork and apply them to the cluster:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在自己的分支中操作并跟随本教程，请更新密钥中的 `GITHUB_TOKEN` 和 `GITHUB_USERNAME` 值，并将其应用到集群中：
- en: '[PRE105]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: SealedSecrets
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SealedSecrets
- en: You might be thinking that these secrets should probably be stored somewhere
    safe—and you're right! If you want to explore the idea of storing the secrets
    in Git so they too are *GitOpsy* (yes, I did just invent a word there), then we
    could use SealedSecrets by Bitnami. It provides a controller for encrypting secrets,
    allowing us to store them as plain text. This means we can commit them to Git!
    Through the magic of the SealedSecret Custom Resource, it decrypts the SealedSecret,
    and creates a regular Kubernetes secret on your behalf. We've written our Jenkins
    Helm chart to accept SealedSecrets for this very reason!
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这些机密应该保存在某个安全的地方——你是对的！如果你想探索将机密存储在 Git 中的想法，以便它们也能变得*GitOpsy*（是的，我刚才确实又发明了一个词），那么我们可以使用
    Bitnami 的 SealedSecrets。它提供了一个加密机密的控制器，允许我们以明文形式存储它们。这意味着我们可以将它们提交到 Git！通过 SealedSecret
    自定义资源的魔力，它会解密 SealedSecret，并代表你创建一个常规的 Kubernetes 秘密。我们已经编写了 Jenkins Helm 图表来接受
    SealedSecrets，正是为了这个原因！
- en: You can deploy SealedSecrets to the cluster by enabling it in the Ubiquitous
    Journey Git project. Open up `bootstrap/values-bootstrap.yaml`. It's as simple
    as changing the `enabled` flag to `true` and, of course, Git committing the changes.
    This will resync with Argo CD and create an instance of Bitnami SealedSecrets
    in your cluster, by default in the `labs-ci-cd` namespace. Because this is a new
    component we're adding to our tooling, we should of course also update our Big
    Picture with the tool and a sentence to describe how we use it.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 Ubiquitous Journey Git 项目中启用它，将 SealedSecrets 部署到集群中。打开 `bootstrap/values-bootstrap.yaml`。只需将
    `enabled` 标志更改为 `true`，然后当然是 Git 提交这些更改。这样将会与 Argo CD 同步，并在你的集群中创建一个 Bitnami SealedSecrets
    实例，默认情况下在 `labs-ci-cd` 命名空间中。由于这是我们正在向工具中添加的新组件，当然我们也应该更新我们的 Big Picture，并添加描述我们如何使用它的句子。
- en: '[PRE118]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Once the controller has been created, we can seal our secrets by following
    these few steps:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦控制器创建完成，我们可以通过以下几个步骤来加密我们的机密：
- en: 'Install `kubeseal` using the instructions found on their GitHub releases page:
    [https://github.com/bitnami-labs/sealed-secrets/releases](https://github.com/bitnami-labs/sealed-secrets/releases).'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用他们的 GitHub 发布页面上的说明安装 `kubeseal`：[https://github.com/bitnami-labs/sealed-secrets/releases](https://github.com/bitnami-labs/sealed-secrets/releases)。
- en: Log in to the cluster where SealedSecrets is deployed and take note of the namespace
    (in our case this defaults to `labs-ci-cd`).
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到部署了 SealedSecrets 的集群并注意命名空间（在我们的例子中，默认为 `labs-ci-cd`）。
- en: 'Process your existing secret using the `kubeseal` command-line utility. It
    is important to set the correct namespace otherwise the secret will not be unsealed.
    In this case, we''re going to seal it as `super-dooper-secret`. It should look
    something like this:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `kubeseal` 命令行工具处理你现有的机密。设置正确的命名空间非常重要，否则机密将无法解密。在这种情况下，我们将其加密为 `super-dooper-secret`。它应该看起来像这样：
- en: '[PRE122]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'You can now apply that secret straight to the cluster for validation, but you
    *should* add it to the cluster using Argo CD by committing it to Git. If it''s
    not in Git, it''s not real. Here, we can see what the SealedSecret looks like
    before it''s applied to the cluster. As you can see, it''s a very large, encrypted
    string for each variable we sealed:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以直接将该机密应用到集群中进行验证，但你*应该*通过将其提交到 Git 来使用 Argo CD 将其添加到集群中。如果它不在 Git 中，那就不算真正的机密。在这里，我们可以看到
    SealedSecret 在应用到集群之前的样子。如你所见，对于我们加密的每个变量，它是一个非常大的加密字符串：
- en: '[PRE123]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'To *GitOpsify* (yes, again I did just make that up), open up your Jenkins configuration
    in `ubiquitous-journey/values-tooling.yaml`. Set your values on Jenkins `sealed_secrets`
    as follows using the output of the secret generation step to add the encrypted
    information to each key. The example here is trimmed for readability:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要*GitOpsify*（是的，我刚才确实发明了这个词），打开 `ubiquitous-journey/values-tooling.yaml` 中的
    Jenkins 配置。使用机密生成步骤的输出将加密信息添加到每个密钥，按照如下所示设置 Jenkins `sealed_secrets` 的值。此处示例已为提高可读性而进行了裁剪：
- en: '[PRE124]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: If you've already manually applied the secret in *Step 4*, delete it by running
    `cat /tmp/sealed-super-dooper.yaml | oc delete -f- -n labs-ci-cd`. Then `Git commit`
    these changes so they are available to Jenkins and, more importantly, stored in
    Git. In Argo CD, we should see that the SealedSecret generated a regular secret.![](img/B16297_14_29.jpg)
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经在*步骤 4*中手动应用了机密，请通过运行 `cat /tmp/sealed-super-dooper.yaml | oc delete -f-
    -n labs-ci-cd` 删除它。然后 `Git commit` 这些更改，这样它们就可以供 Jenkins 使用，更重要的是，保存在 Git 中。在
    Argo CD 中，我们应该看到 SealedSecret 生成了一个常规的机密。![](img/B16297_14_29.jpg)
- en: 'Figure 14.29: SealedSecrets from Argo CD'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.29：来自 Argo CD 的 SealedSecrets
- en: 'In Jenkins, we should see all that the synchronized secrets using the `magic`
    annotation (`credential.sync.jenkins.openshift.io: "true"`) have become available.![](img/B16297_14_30.jpg)'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在 Jenkins 中，我们应该看到所有通过 `magic` 注释（`credential.sync.jenkins.openshift.io: "true"`）同步的机密已经可用。![](img/B16297_14_30.jpg)'
- en: 'Figure 14.30: Jenkins secrets automatically loaded from Kubernetes'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.30：从 Kubernetes 自动加载的 Jenkins 密钥
- en: For simplicity here, we will continue without having sealed the secrets; the
    topic of secrets and GitOps has been included only for illustrative purposes.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，我们将继续进行，而不去封闭机密；机密和 GitOps 的话题仅用于说明目的。
- en: The Anatomy of a Jenkinsfile
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jenkinsfile 的结构
- en: Some of you may be familiar with a `Jenkinsfile`, but for those who are not,
    let's take a look at the anatomy of one. A `Jenkinsfile` is just a simple `Jenkinsfile`.
    It is an *everything-as-code* practice that defines the sequence of things we
    want our pipeline to execute in order.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能熟悉 `Jenkinsfile`，但对于那些不熟悉的人，让我们来看一下它的结构。`Jenkinsfile` 只是一个简单的 `Jenkinsfile`。它是一种
    *一切皆代码* 的实践，定义了我们希望管道按顺序执行的操作。
- en: 'The `Jenkinsfile` is made up of a pipeline definition with a collection of
    blocks, as the following is from our PetBattle frontend. If you''re curious as
    to where this file is, you will find it at the root of the project in Git. *Figure
    14.31* is trimmed a little for simplicity:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`Jenkinsfile` 由管道定义和一组块组成，以下是来自我们 PetBattle 前端的内容。如果你对这个文件的具体位置感到好奇，可以在 Git
    中找到它，位于项目根目录。*图 14.31* 已简化了一些：'
- en: '![](img/B16297_14_31.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_31.jpg)'
- en: 'Figure 14.31: Anatomy of a Jenkinsfile'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.31：Jenkinsfile 的结构
- en: 'The key aspects of a `Jenkinsfile` DSL are:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`Jenkinsfile` DSL 的关键要素包括：'
- en: '`pipeline {}` is how all declarative Jenkins pipelines begin.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pipeline {}` 是所有声明式 Jenkins 管道的开始。'
- en: '`environment {}` defines the environment variables to be used across all Build
    stages. Global variables can be defined here.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environment {}` 定义将在所有构建阶段使用的环境变量。可以在这里定义全局变量。'
- en: '`options {}` contains specific job specs you want to run globally across jobs;
    for example, setting the terminal color or the default timeout.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`options {}` 包含您希望在作业中全局运行的特定作业规格；例如，设置终端颜色或默认超时时间。'
- en: '`stages {}` encapsulates the collection of blocks our pipeline will go through,
    that is, the `stage`.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stages {}` 封装了管道将经过的多个阶段块，即 `stage`。'
- en: '`stage {}`: All jobs must have at least one stage. This is the logical part
    of the build that will be executed, such as `bake-image`, and contains the steps,
    agents, and other stage-specific configurations.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stage {}`：所有作业必须至少有一个阶段。这是构建的逻辑部分，将被执行，例如 `bake-image`，并包含步骤、代理和其他阶段特定的配置。'
- en: '`agent {}` specifies the node that the build should be run on, for example,
    `jenkins-agent-npm`.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`agent {}` 指定构建应该在哪个节点上运行，例如 `jenkins-agent-npm`。'
- en: '`steps {}`: Each stage has one or more steps involved. These could be executing
    shell commands, scripts, Git checkout, and so on.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`steps {}`：每个阶段都有一个或多个步骤。这些步骤可能包括执行 shell 命令、脚本、Git 检出等。'
- en: '`post {}` is used to specify the post-build actions. Jenkins'' declarative
    pipeline syntax provides very useful callbacks for `success`, `failure`, and `always`,
    which are useful for controlling the job flow or processing reports after a command
    is executed.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post {}` 用于指定构建后的操作。Jenkins 的声明式管道语法提供了非常有用的回调 `success`、`failure` 和 `always`，这些回调对于控制作业流程或在命令执行后处理报告非常有用。'
- en: '`when {}` is used for flow control. It can be used at the stage level, as well
    as to stop the pipeline from entering that stage; for example, when branch is
    master, deploy to test environment.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`when {}` 用于流程控制。它可以在阶段级别使用，也可以防止管道进入该阶段；例如，当分支是 master 时，部署到测试环境。'
- en: '`parallel {}` is used to execute some blocks simultaneously. By default, Jenkins
    executes each stage sequentially. If things can be done in parallel, then they
    should, as it will accelerate the feedback loop for the development team.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parallel {}` 用于同时执行一些块。默认情况下，Jenkins 按顺序执行每个阶段。如果某些任务可以并行完成，那么应该并行执行，因为这样可以加速开发团队的反馈循环。'
- en: For us, we are creating the components in the Big Picture, which are Build >
    Bake > Deploy.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们而言，我们正在创建大局中的组件，分别是构建（Build）> 烘焙（Bake）> 部署（Deploy）。
- en: The Build should always take the source code, compile it, run some linting (static
    code checking) and testing before producing a package, and store it in Nexus.
    We should produce test reports and have them interpreted by Jenkins when deciding
    to fail the build or not. We are building an Angular application, but Jenkins
    does not know how to execute `npm` or other JavaScript-based commands, so we need
    to tell it to use the agent that contains the `npm` binary. This is where the
    agents that we bootstrapped to the Jenkins deployment will come in handy. Each
    agent that is built extends the base agent image with the binary we need (that
    is, `npm`) and is pushed to the cluster. This ImageStream is then labeled `role=jenkins-slave`
    to make it automatically discoverable by Jenkins if they are running in the same
    namespace. This means that for us to use this, we just need to configure our Jenkins
    stage to use `agent { label "jenkins-agent-npm" }`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 构建阶段应始终获取源代码，进行编译，执行一些静态代码检查（lint）和测试，然后生成软件包，并将其存储到 Nexus。我们应生成测试报告，并在决定是否失败构建时由
    Jenkins 进行解读。我们正在构建一个 Angular 应用程序，但 Jenkins 不知道如何执行 `npm` 或其他基于 JavaScript 的命令，因此我们需要告诉它使用包含
    `npm` 二进制文件的代理。这时，我们在 Jenkins 部署中启动的代理将派上用场。每个构建的代理都会将所需的二进制文件（即 `npm`）扩展到基础代理镜像中，并推送到集群中。这个
    ImageStream 将被标记为 `role=jenkins-slave`，这样如果它们在同一命名空间中运行，Jenkins 就能自动发现它。为了使用这个，我们只需要配置
    Jenkins 阶段使用 `agent { label "jenkins-agent-npm" }`。
- en: '![](img/B16297_14_32.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_32.jpg)'
- en: 'Figure 14.32: Jenkins agent discovery magic'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.32：Jenkins 代理发现魔法
- en: The Build stage will use this agent and execute some steps. The first thing
    is to capture the app's version to be used throughout the pipeline by reading
    the app's manifest (`pom.xml` for Java or `package.json` for Node). This version
    is then used on all generated artifacts, including our image and Helm chart version,
    and should follow SemVer (for example, `<major>.<minor>.<patch> = 1.0.1`). We
    will then pull our dependencies, run our tests, lint, and build our code before
    publishing the results to Jenkins and the package to Nexus.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 构建阶段将使用此代理并执行一些步骤。首先需要捕获应用程序的版本，以便在整个管道中使用，通过读取应用程序的清单文件（Java 使用 `pom.xml`，Node
    使用 `package.json`）。此版本随后将用于所有生成的工件，包括我们的镜像和 Helm 图表版本，并应遵循语义化版本控制（SemVer）（例如，`<major>.<minor>.<patch>
    = 1.0.1`）。接下来，我们将拉取依赖项，运行测试，进行代码静态检查，构建代码，并将结果发布到 Jenkins，将软件包发布到 Nexus。
- en: 'This will display in the Jenkins declarative pipeline like so:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 Jenkins 声明式流水线中显示如下：
- en: '[PRE125]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Our Bake will always take the output of the previous step, in this case, the
    package stored in Nexus, and pop it into a container. In our case, we will be
    running an OpenShift build. This will result in the package being added to the
    base container and pushed to a repository. If we are executing a sandbox build,
    say some new feature on a branch, then we are not concerned with pushing the image
    externally—so we can use the internal registry for OpenShift. If this build is
    a release candidate then we''ll push into Quay.io (our external registry for storing
    images). The breakdown of the steps for a Bake is found in the Git repository
    that accompanies this book: [https://github.com/petbattle/pet-battle/blob/master/Jenkinsfile](https://github.com/petbattle/pet-battle/blob/master/Jenkinsfile).'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Bake 阶段将始终获取上一步的输出，在这种情况下是存储在 Nexus 中的软件包，并将其放入容器中。在我们的案例中，我们将执行一个 OpenShift
    构建。这将导致软件包被添加到基础容器中并推送到仓库。如果我们正在执行沙箱构建，比如在某个分支上开发新特性，那么我们不关心将镜像推送到外部——因此可以使用 OpenShift
    的内部注册表。如果这个构建是发布候选版本，那么我们将推送到 Quay.io（我们用于存储镜像的外部注册表）。Bake 阶段的步骤细节可以在本书配套的 Git
    仓库中找到：[https://github.com/petbattle/pet-battle/blob/master/Jenkinsfile](https://github.com/petbattle/pet-battle/blob/master/Jenkinsfile)。
- en: From a bird's-eye view, the idea is to get the package from Nexus and then create
    an OpenShift `BuildConfig` with a binary build and pass the package to it. You
    should then see the build execute in the OpenShift cluster.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 从鸟瞰图来看，整个过程的思路是从 Nexus 获取软件包，然后创建一个 OpenShift `BuildConfig`，进行二进制构建，并将软件包传递给它。然后你应该能看到构建在
    OpenShift 集群中执行。
- en: '![](img/B16297_14_33.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_33.jpg)'
- en: 'Figure 14.33: Jenkins stages outline for Bake and Deploy'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.33：Jenkins 阶段概述：Bake 和 Deploy
- en: The deployment will take the application that has just been packaged up with
    its dependencies and deploy it to our cluster. Initially, we will push the application
    to our `labs-test` environment. We want to package the application and its Kubernetes
    resources as a Helm chart, so for the deployment we will patch the version of
    the application referenced in the values file with the latest release. For this
    reason, our Deploy stage is broken down into two parts.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 部署将把刚刚打包好的应用及其依赖项部署到我们的集群中。最初，我们会将应用推送到 `labs-test` 环境。我们希望将应用及其 Kubernetes
    资源打包为 Helm 图表，因此在部署过程中，我们将使用最新的发布版本来更新 values 文件中引用的应用版本。因此，我们的部署阶段被分为两个部分。
- en: The first one patches the Helm chart with the new image information, as well
    as any repository configuration, such as where to find the image we just Baked!
    This is then stored in Nexus, which can be used as a Helm chart repository.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个步骤是将新的镜像信息和任何仓库配置（例如，我们刚刚构建的镜像所在位置）补丁到 Helm 图表中！然后将其存储在 Nexus 中，可以用作 Helm
    图表仓库。
- en: Secondly, it will install this Helm chart. Depending on what branch we're on,
    this behavior of how the application will be deployed differs. If we're building
    on `master` or `main`, it is a release candidate, so there is no more `oc` applying
    some configuration—this is GitOps land! Instead, we can commit the latest changes
    to our Argo CD config repository (Ubiquitous Journey). The commits on this repository
    should be mostly automated if we're doing this the right way. Managing our apps
    this way makes rollback easy—all we have to do is Git revert!
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，它将安装这个 Helm 图表。根据我们所在的分支，应用部署的行为有所不同。如果我们在 `master` 或 `main` 上构建，它是发布候选版本，因此不再使用
    `oc` 应用配置——这是 GitOps 环境！相反，我们可以将最新的更改提交到我们的 Argo CD 配置仓库（Ubiquitous Journey）。如果我们按正确的方式操作，这个仓库中的提交应该是大部分自动化的。通过这种方式管理我们的应用使得回滚变得容易——我们所需要做的只是
    Git revert！
- en: '![](img/B16297_14_34.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_34.jpg)'
- en: 'Figure 14.34: Jenkins automated commit of the new version from a pipeline run'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.34：Jenkins 从管道运行自动提交新版本
- en: Branching
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分支
- en: Our pipeline is designed to work on *multibranch*, creating new pipeline instances
    for every branch that is committed to in Git. It is intended to have slightly
    different behavior on each branch. In our world, anything that gets merged to
    `master` or `main` is deemed to be a release candidate. This means that when a
    developer is ready to merge their code, they would amend the `package.json` version
    (or `pom.xml` version for Java projects) with the new release they want to try
    and get all the way through the pipeline to production. We could automate the
    version management, but because our workflow has always been easier, a developer
    will do this management, as they are best placed to decide whether it's a patch,
    a minor, or a major release.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的管道设计用于在 *多分支* 环境中工作，为 Git 中提交的每个分支创建新的管道实例。每个分支的行为稍有不同。在我们的世界中，任何合并到 `master`
    或 `main` 的内容都被视为发布候选版本。这意味着，当开发人员准备合并代码时，他们会修改 `package.json` 版本（或 Java 项目的 `pom.xml`
    版本），以便尝试通过管道并最终部署到生产环境。我们可以自动化版本管理，但因为我们的工作流程一直很简单，所以由开发人员来管理版本，他们最了解是否是补丁、次要版本或主要版本。
- en: 'This means that anything not on the `main` or `master` branch is deemed to
    be a sandbox execution of the pipeline. If something is a sandbox build, it is
    there to provide fast feedback to the developers of the current state of development
    in that feature. It can also act as a warning to other engineers that something
    is not ready to be merged if it''s failing. The sandbox builds should be thought
    of as ephemeral—we''re not interested in keeping them hanging around—hence we
    make some key changes to the pipeline to accommodate this:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，任何不在 `main` 或 `master` 分支上的内容都被视为管道的沙箱执行。如果某个构建是沙箱构建，它的作用是为开发人员提供该功能当前开发状态的快速反馈。如果它失败了，它还可以作为其他工程师的警告，表明该内容还不准备合并。沙箱构建应该被看作是临时的——我们不希望它们一直存在——因此我们对管道做了一些关键修改以适应这一点：
- en: '**Internal registry**: If our built image is pushed to our external repository,
    it will become clogged up and messy with unnecessary images. Every time a developer
    commits to any branch it would create new images, so it can introduce a cleanup
    headache; hence we use the internal registry, which automatically prunes old images
    for us. We only use the external registry when we know a release could go all
    the way to production.'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**内部注册表**：如果我们将构建的镜像推送到外部仓库，它会变得拥挤且凌乱，充满了不必要的镜像。每次开发者提交到任何分支时都会创建新的镜像，这可能会引发清理的麻烦；因此我们使用内部注册表，它会自动为我们修剪旧镜像。只有在我们知道某个发布可能会进入生产环境时，才会使用外部注册表。'
- en: '**Helm install**: For our deployments, we''re not interested in bringing in
    a heavyweight tool like Argo CD to manage the development/sandbox deployments.
    It''s unnecessary, so we just use Jenkins to execute a Helm install instead. This
    will verify that our app can deploy as we expect. We use Argo CD and GitOps to
    manage the deployments in test and staging environments, but any lower environments
    we should also treat as ephemeral (as we should test and staging too).'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Helm 安装**：对于我们的部署，我们并不希望引入像 Argo CD 这样的重量级工具来管理开发/沙盒环境的部署。它并不是必须的，所以我们只是使用
    Jenkins 来执行 Helm 安装。这样可以验证我们的应用程序能按预期进行部署。我们使用 Argo CD 和 GitOps 来管理测试和预发布环境中的部署，但对于任何低环境，我们也应该把它们视作临时环境（就像测试和预发布环境一样）。'
- en: This approach allows us to support many different types of Git workflow. We
    can support GitHub Flow, Gitflow, and Trunk, all via the same consistent approach
    to the pipelines.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许我们支持多种不同类型的 Git 工作流。我们可以通过相同的流水线方法支持 GitHub Flow、Gitflow 和 Trunk。
- en: Webhooks
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Webhooks
- en: Before we actually trigger Jenkins to build things for us, it's important to
    add a few webhooks to make our development faster. We need two, one for the Argo
    CD config repo and one for Jenkins in our source code repository.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际触发 Jenkins 为我们构建之前，添加一些 webhook 来加速我们的开发是非常重要的。我们需要两个，一个用于 Argo CD 配置仓库，一个用于
    Jenkins，放在我们的源代码仓库中。
- en: When we commit a new change to the Git repositories that Argo CD is watching
    for, it polls. The poll time is configurable, but who can be bothered to wait
    at all? Argo CD allows you to configure a webhook to tell it to initiate a sync
    when a change has been made.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向 Argo CD 监视的 Git 仓库提交新更改时，它会进行轮询。轮询时间是可以配置的，但谁愿意浪费时间等待呢？Argo CD 允许你配置 webhook
    来通知它，在更改发生时启动同步操作。
- en: This is particularly important if we want things to happen after Argo CD has
    worked its magic, such as in a system test. Our pipeline in Jenkins runs synchronously,
    but Argo CD is asynchronous and therefore anything we can do to reduce the wait
    between these behaviors is critical.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望在 Argo CD 完成操作后进行某些操作（例如系统测试），这尤其重要。我们在 Jenkins 中的流水线是同步运行的，而 Argo CD
    是异步的，因此任何能减少这些行为之间等待时间的做法都是至关重要的。
- en: On GitHub, we can configure the webhook for Ubiquitous Journey to trigger Argo
    CD whenever the repository updates. On GitHub, add the webhook with the address
    of our Argo CD server followed by `/api/webhook`.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 上，我们可以配置 Ubiquitous Journey 的 webhook，当仓库更新时触发 Argo CD。在 GitHub 上，添加一个
    webhook，地址为我们的 Argo CD 服务器地址后面加上 `/api/webhook`。
- en: '![](img/B16297_14_35.jpg)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_35.jpg)'
- en: 'Figure 14.35: Webhook to trigger Argo CD on Git commit'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.35：在 Git 提交时触发 Argo CD 的 Webhook
- en: Jenkins
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jenkins
- en: Every time we commit to our source code repository, we want Jenkins to run a
    build. We're using the multibranch plugin for Jenkins, so this means that when
    we commit to the repository, the webhook will trigger a branch scan, which should
    bring back any new feature branches to build pipelines or create builds for any
    new code commits on any branch.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们向源代码仓库提交时，都希望 Jenkins 执行构建。我们使用的是 Jenkins 的多分支插件，这意味着当我们向仓库提交时，webhook 会触发一个分支扫描，这应该会拉取任何新的功能分支来构建流水线或为任何新代码提交创建构建。
- en: Configuring the Jenkins webhook for the `pet-battle` frontend is simple. On
    GitHub's *Hooks* page, add the URL to our Jenkins instance in the following form,
    where the trigger token is the name of our GitHub project. As a convention, I
    tend to use the name of the Git project as the token, so the same would apply
    for the backend if you were building it using Jenkins too:`JENKINS_URL/multibranch-webhook-trigger/invoke?token=[Trigger
    token]`
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 `pet-battle` 前端的 Jenkins webhook 非常简单。在 GitHub 的 *Hooks* 页面上，添加我们的 Jenkins
    实例的 URL，格式如下，其中触发令牌是我们 GitHub 项目的名称。作为一种约定，我倾向于使用 Git 项目的名称作为令牌，因此如果你使用 Jenkins
    构建后端，后端也会采用相同的方法：`JENKINS_URL/multibranch-webhook-trigger/invoke?token=[Trigger
    token]`
- en: 'For example, the frontend application''s webhook URL would look something like
    this:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，前端应用的 webhook URL 可能是这样的：
- en: '[https://jenkins-labs-ci-cd.apps.petbattle.com/multibranch-webhook-trigger/invoke?token=pet-battle](https://jenkins-labs-ci-cd.apps.petbattle.com/multibranch-webhook-trigger/invoke?token=pet-battle
    )'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://jenkins-labs-ci-cd.apps.petbattle.com/multibranch-webhook-trigger/invoke?token=pet-battle](https://jenkins-labs-ci-cd.apps.petbattle.com/multibranch-webhook-trigger/invoke?token=pet-battle)'
- en: Bringing It All Together
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将一切结合起来
- en: We have now gone through what a Jenkins file is and what it does for us. We've
    spoken about branching and what we mean for a build to be a release candidate
    (that is, a version bump and on master/main). We've touched on deploying using
    Helm and GitOps to commit our change and have Argo CD roll out the change for
    us…but how do we connect Jenkins up to all this magic?
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经了解了 Jenkins 文件是什么以及它为我们做了什么。我们讨论了分支和我们所说的构建成为发布候选版本的含义（即，版本提升并且在 master/main
    上）。我们也简单介绍了如何使用 Helm 和 GitOps 部署，提交更改并让 Argo CD 为我们推出更改……但是我们如何将 Jenkins 与所有这些魔法连接起来呢？
- en: 'As with all these things, there are several ways. We *could* open up Jenkins
    and hit `seed-multibranch-pipelines` job! Some of you may have noticed that Jenkins
    was configured to point to our organization''s GitHub for PetBattle when we deployed
    the Helm chart from Ubiquitous Journey. We set some environment variables on the
    image (in `ubiquitous-journey/values-tooling.yaml`) to point to our GitHub organization
    as follows:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有这些事情一样，有几种方法。我们*可以*打开 Jenkins 并点击 `seed-multibranch-pipelines` 作业！你们中的一些人可能已经注意到，当我们从
    Ubiquitous Journey 部署 Helm chart 时，Jenkins 被配置为指向我们组织的 PetBattle GitHub。我们在镜像中设置了一些环境变量（在
    `ubiquitous-journey/values-tooling.yaml` 中）以指向我们的 GitHub 组织，如下所示：
- en: '[PRE164]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: If you’re following along with a fork of the Ubiquitous Journey and want to
    see the pipeline run end to end, update both ARGOCD_CONFIG_REPO to point to your
    fork and QUAY_ACCOUNT to resolve to your user on Quay.io.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在跟随 Ubiquitous Journey 的 fork，并且希望查看整个管道的运行过程，更新 ARGOCD_CONFIG_REPO 为指向你的
    fork，且 QUAY_ACCOUNT 为指向你在 Quay.io 上的用户。
- en: These are used by the `seed-multibranch-pipelines` job that is baked into the
    Jenkins image to scan the organization for repositories that contain a `Jenkinsfile`
    and are not archived. If it finds any, it will automatically scaffold out multibranch
    Jenkins jobs for us. In our case, we have a `Jenkinsfile` for both the Cats API
    and the PetBattle frontend, so jobs are created for us without having to configure
    anything! If you're following along and not using GitHub but GitLab, you can set
    `GITLAB_*` environment variables to achieve the same effect.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是由内置于 Jenkins 镜像中的 `seed-multibranch-pipelines` 作业使用的，用于扫描组织中的仓库，查找包含 `Jenkinsfile`
    并且没有归档的仓库。如果找到，它会自动为我们创建多分支 Jenkins 作业。在我们的案例中，Cats API 和 PetBattle 前端都有一个 `Jenkinsfile`，所以作业会为我们自动创建，无需配置任何东西！如果你跟随这个过程，但不是使用
    GitHub 而是 GitLab，你可以设置 `GITLAB_*` 环境变量来实现相同的效果。
- en: '![](img/B16297_14_36.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_36.jpg)'
- en: 'Figure 14.36: Jenkins seed to scaffold out our Jenkins jobs'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.36：Jenkins seed 用于创建我们的 Jenkins 作业
- en: If you open Jenkins and drill down into the `pet-battle` folder for the frontend
    code base, you should see builds; for example, a Git branch called `cool-new-cat`
    and the `master` with pipeline executions for each of them. Opening the Blue Ocean
    view, we get a much better understanding of the flow control we built, as previously
    discussed.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开 Jenkins，并深入查看 `pet-battle` 文件夹中的前端代码库，你应该会看到构建任务；例如，一个名为 `cool-new-cat`
    的 Git 分支和 `master` 分支，每个分支都有管道执行。打开 Blue Ocean 视图，我们可以更清楚地理解我们构建的流程控制，正如之前讨论过的那样。
- en: '![](img/B16297_14_37.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_37.jpg)'
- en: 'Figure 14.37: Jenkins release candidate pipeline'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.37：Jenkins 发布候选管道
- en: For the master branch, which we deem to be a release candidate, the artifacts
    that are built could go all the way. If we are updating our application, we bump
    the manifest version along with any changes we're bringing in and Git commit,
    which should trigger the build. From this point, our build environment is configured,
    and the pipeline should execute. We target an external repository and the image
    that's built will be pushed to Quay.io for portability across multiple clusters.
    Our Helm chart's values are patched and pushed to Nexus for storage. If we need
    to update our Helm chart itself, for example, to add some new configuration to
    the chart or add a new Kubernetes resource, we should of course bump the chart
    version too. For our deployment, we patch the Argo CD config repository (Ubiquitous
    Journey) with the new release information, and it should sync automatically for
    us, deploying our application to the `labs-test` namespace! We then run a verify
    step to check that the version being rolled out matches the new version (based
    on the labels) and has been successful.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们认为是发布候选版本的主分支，构建的工件可能会一直沿着流水线走。如果我们正在更新应用程序，我们会更新清单版本，并且提交Git，这应该会触发构建。从这个点开始，我们的构建环境已经配置好，流水线应该开始执行。我们将目标指向外部仓库，构建的镜像将推送到Quay.io，以便在多个集群之间进行移植。我们的Helm
    chart的值会被修补并推送到Nexus进行存储。如果我们需要更新Helm chart本身，例如添加一些新的配置到chart中或添加一个新的Kubernetes资源，我们当然也应该更新chart的版本。对于我们的部署，我们会修补Argo
    CD配置仓库（Ubiquitous Journey）并提供新的发布信息，它应该会自动同步并将我们的应用程序部署到`labs-test`命名空间！然后，我们会运行验证步骤，检查正在发布的版本是否与新版本匹配（基于标签），并且已经成功。
- en: '![](img/B16297_14_38.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_38.jpg)'
- en: 'Figure 14.38: Jenkins feature development pipeline'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.38：Jenkins特性开发流水线
- en: For our feature branches, the idea is much the same, but without the need for
    an external repository. Our charts are also manipulated to override the name to
    include the branch. This means that on each commit to a feature branch, we get
    a new application deployed containing the branch name in the route. So, for our
    `cool-new-cat` branch, the application is deployed as `cool-new-cat-pet-battle`
    and is available in the developmental environment.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的功能分支，思路大致相同，但不需要外部仓库。我们的charts也会被修改，以覆盖名称并包括分支。这意味着，每次向功能分支提交时，我们都会部署一个新的应用程序，路由中包含分支名称。因此，对于我们的`cool-new-cat`分支，应用程序将作为`cool-new-cat-pet-battle`部署，并在开发环境中可用。
- en: The remaining stages that were added to the Big Picture, System Test and Promote,
    will be covered in the next chapter, when we look in more detail at the testing
    for PetBattle.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: Big Picture中新增的其余阶段，系统测试和推广，将在下一章中详细讨论，我们将更详细地了解PetBattle的测试。
- en: What's Next for Jenkinsfile
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jenkinsfile的下一步
- en: Jenkins has been around for quite some time. It is not the most container-native
    approach to building software but there is a rich ecosystem surrounding it. It's
    lasted a long time because people like it! Hopefully, this gives you a taste of
    what can be done with Jenkins for our PetBattle applications, but it's by no means
    the end. There are a few plot holes in the story, as some of you may have noticed.
    For example, once a build has been successfully deployed to the test environment,
    how do I promote it onward? Should I do more testing? Well, the answer will come
    in the next chapter when we explore system tests and extend our pipeline further
    to include promoting images. At the end of a successful pipeline execution, the
    values file in our repository is not updated; we should be thinking about writing
    the successful build artifact details back to the repository, so it's always got
    a sensible default set to what is currently deployed.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins已经存在一段时间了。它不是构建软件的最容器化方法，但周围有一个丰富的生态系统。它能够持续这么长时间，因为大家喜欢它！希望这能让你对我们PetBattle应用程序中Jenkins的应用有所了解，但这远不是终点。故事中还是有一些漏洞的，正如你们中的一些人可能已经注意到了。例如，一旦构建成功部署到测试环境，我该如何将其进一步推广？我是否需要做更多的测试？好吧，答案将在下一章给出，我们将探讨系统测试，并进一步扩展我们的流水线以包含推广镜像的步骤。在成功的流水线执行结束时，我们仓库中的值文件并未更新；我们应该考虑将成功构建的工件细节写回到仓库中，这样它总是能够设置一个合理的默认值，指向当前已部署的内容。
- en: The stages we have written here are fairly massive and do have some `bash` and
    other logic inside of them. If you were to build a non-frontend application, for
    example, you would want to build something in Golang. For the most part, the only
    thing that needs to change is the Build stage, as the act of putting something
    in a box, and how we package our Helm chart and deploy the app, remains the same.
    Once the app, in any language or framework, is in a container, then how we ship
    it remains the same. This means there is a high potential for reusing the code
    in the Bake and Deploy stages again and again, thus lowering the bar for adopting
    new technologies on a platform such as OpenShift. But be careful – copying and
    pasting the same steps across many jobs in a large estate of apps can lead to
    one mistake being copied around. Changes to the pipeline can become costly too,
    as you have to update each `Jenkinsfile` in each repository.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里写的阶段非常庞大，确实包含一些`bash`和其他逻辑。例如，如果你要构建一个非前端应用程序，你可能会想用Golang来构建。大部分情况下，唯一需要改变的是构建阶段，因为将某个东西放入容器以及我们如何打包我们的Helm图表并部署应用程序的方式保持不变。一旦应用程序（无论是使用什么语言或框架）被放入容器中，那么我们如何运输它也保持不变。这意味着在Bake和Deploy阶段重用代码的潜力很高，从而降低了在OpenShift等平台上采用新技术的门槛。但是要小心——在大量应用程序的多个任务中复制粘贴相同的步骤可能会导致某个错误被复制到各处。对管道的修改也可能变得很昂贵，因为你需要更新每个仓库中的每个`Jenkinsfile`。
- en: '![](img/B16297_14_39.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_39.jpg)'
- en: 'Figure 14.39: A lurking dragon, watch out!'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.39：潜伏的龙，小心！
- en: Jenkins does tackle these problems with the use of shared libraries, and more
    recently the **Jenkins Templating Engine** (**JTE**). The JTE tackles the problem
    by enforcing pipeline approaches from a governance point of view. While this might
    seem like a great way to standardize across an enterprise—here be dragons!
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins通过使用共享库来解决这些问题，最近还引入了**Jenkins模板引擎**（**JTE**）。JTE通过从治理的角度强制执行管道方法来解决这个问题。虽然这看起来像是一种很好的方式来在企业范围内实现标准化，但这里有潜在的风险！
- en: Applying a standard pipeline without justification or the ability for teams
    to pull requests and make changes for their own specific use case is the same
    as having Dev and Ops in separate rooms. We've worked with plenty of customers
    who have tried approaches like this and ultimately it makes them go slower, rather
    than faster. The teams putting the pipelines in place think they're helping and
    providing a great service, but when things go wrong, they are the bottleneck to
    fixing it. For some teams, the hammer approach might not be applicable for their
    use case and so the pipeline becomes something in the way for them to go faster.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 应用一个标准管道而没有正当理由，或者不给团队提供拉取请求并针对其特定用例做出更改的能力，就相当于将开发和运维分隔开来。我们与许多客户合作过，他们曾尝试过类似的方法，最终发现这让他们的速度变慢，而不是加快。那些实施管道的团队认为自己在提供帮助和优质服务，但当事情出错时，他们却成了修复的瓶颈。对于一些团队来说，采用强硬方法可能不适合他们的用例，因此管道就成了他们加速发展的障碍。
- en: Tekton is another way for us to get greater pipeline reusability and also honor
    more of our GitOps landscape. Let's explore it now for our Java microservices.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: Tekton是另一种让我们实现更高管道重用性的方式，同时也更好地支持我们的GitOps架构。现在让我们来探讨它在Java微服务中的应用。
- en: Tekton–The Backend
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tekton—后端
- en: Tekton[8](#footnote-086) is an open source cloud-native CI/CD tool that forms
    the basis for OpenShift Pipelines.[9](#footnote-085)
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: Tekton[8](#footnote-086)是一个开源的云原生CI/CD工具，构成了OpenShift管道的基础。[9](#footnote-085)
- en: Tekton Basics
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tekton基础知识
- en: There are many similarities between what Jenkins does and what Tekton does.
    For example, both can be used to store pipeline definitions as code in a Git repository.
    Tekton is deployed as an operator in our cluster and allows users to define in
    YAML `Pipeline` and `Task` definitions. Tekton Hub[10](#footnote-084) is a repository
    for sharing these YAML resources among the community, giving great reusability
    to standard workflows.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins和Tekton之间有很多相似之处。例如，两者都可以用来将管道定义作为代码存储在Git仓库中。Tekton作为一个运算符部署在我们的集群中，允许用户在YAML文件中定义`Pipeline`和`Task`。Tekton
    Hub[10](#footnote-084)是一个用于共享这些YAML资源的仓库，能够为标准工作流提供极高的重用性。
- en: '[8](#footnote-086-backlink) [https://tekton.dev](https://tekton.dev)'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '[8](#footnote-086-backlink) [https://tekton.dev](https://tekton.dev)'
- en: '[9](#footnote-085-backlink) [https://docs.openshift.com/container-platform/4.7/cicd/pipelines/understanding-openshift-pipelines.html](https://docs.openshift.com/container-platform/4.7/cicd/pipelines/understanding-openshift-pipelines.html)'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '[9](#footnote-085-backlink) [https://docs.openshift.com/container-platform/4.7/cicd/pipelines/understanding-openshift-pipelines.html](https://docs.openshift.com/container-platform/4.7/cicd/pipelines/understanding-openshift-pipelines.html)'
- en: '[10](#footnote-084-backlink) [https://hub.tekton.dev](https://hub.tekton.dev)'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '[10](#footnote-084-backlink) [https://hub.tekton.dev](https://hub.tekton.dev)'
- en: '![](img/B16297_14_40.jpg)'
  id: totrans-470
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_40.jpg)'
- en: 'Figure 14.40: Tekton Hub and OpenShift Cluster tasks'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '图 14.40: Tekton Hub 和 OpenShift 集群任务'
- en: OpenShift also makes these available globally as `ClusterTasks`. To write a
    pipeline you can wire together these task definitions. OpenShift provides a guided
    `Pipeline` builder UI for just this task. You link various tasks together and
    define parameters and outputs as specified in each task definition.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 还将这些任务作为 `ClusterTasks` 在全局范围内提供。要编写一个流水线，你可以将这些任务定义串联在一起。OpenShift
    提供了一个引导式的 `Pipeline` 构建器 UI 来完成这项任务。你将不同的任务连接在一起，并根据每个任务定义中的要求，定义参数和输出。
- en: '![](img/B16297_14_41.jpg)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_41.jpg)'
- en: 'Figure 14.41: OpenShift Pipeline builder UI'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '图 14.41: OpenShift 流水线构建器 UI'
- en: 'There are numerous task activities in our pipeline definitions that require
    persistent storage. When building our backend PetBattle API and Tournament applications
    using Maven, we pull our Java dependencies via our Nexus repository manager. To
    speed up this process, we can perform the same caching we might do on our laptops
    and store these locally between builds in a `.m2/repository` folder and share
    this between builds. We also use persistent storage for built artifacts so they
    can be shared between different steps in our pipeline. Another use case is to
    mount Kubernetes secrets into our pipelines:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的流水线定义中有许多任务活动需要持久化存储。在使用 Maven 构建我们的后端 PetBattle API 和 Tournament 应用程序时，我们通过
    Nexus 仓库管理器拉取 Java 依赖项。为了加速这个过程，我们可以在本地执行与笔记本电脑上相同的缓存操作，并将这些依赖项存储在 `.m2/repository`
    文件夹中，跨构建共享它们。我们还使用持久化存储来存储构建后的工件，以便它们可以在流水线的不同步骤之间共享。另一个用例是将 Kubernetes 秘密挂载到我们的流水线中：
- en: '[PRE168]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: In Tekton, we link these Kubernetes objects with the named `workspaces` when
    we create what is called the `PipelineRun`, a piece of code that represents one
    run of a pipeline. Similarly, the execution of a single task is a `TaskRun`. Each
    `workspace` is then made available for the tasks in that `PipelineRun` as shown.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Tekton 中，我们通过命名的 `workspaces` 将这些 Kubernetes 对象链接起来，当我们创建所谓的 `PipelineRun`
    时，后者代表一次流水线运行的代码。同样，单个任务的执行是 `TaskRun`。每个 `workspace` 随后会作为该 `PipelineRun` 中任务的资源，如下所示。
- en: Reusable Pipelines
  id: totrans-512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可重用流水线
- en: There are some choices to be made before you start writing and designing your
    Tekton pipeline. The first is to choose whether you write a pipeline for each
    application, or whether you write reusable pipelines that can be used for applications
    that are similar.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写和设计 Tekton 流水线之前，有一些选择需要做出。第一个选择是决定是为每个应用编写一个流水线，还是编写可重用的流水线，这些流水线可以用于相似的应用程序。
- en: In PetBattle, we started with one pipeline per application; this is similar
    to having a `Jenkinsfile` in each application Git repository. Both the API and
    Tournament PetBattle applications are built using Java, Quarkus, and Maven, so
    it makes sense to consolidate the pipeline code and write a reusable parameterized
    pipeline for these two applications because they will always have similar tasks.
    We use our `maven-pipeline` in PetBattle to do this.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PetBattle 中，我们开始时为每个应用程序编写一个流水线；这类似于在每个应用程序的 Git 仓库中都有一个 `Jenkinsfile`。API
    和 Tournament PetBattle 应用程序都使用 Java、Quarkus 和 Maven 构建，因此将流水线代码整合并为这两个应用程序编写一个可重用的参数化流水线是有意义的，因为它们始终有相似的任务。我们在
    PetBattle 中使用 `maven-pipeline` 来实现这一点。
- en: '![](img/B16297_14_42.jpg)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_42.jpg)'
- en: 'Figure 14.42: PetBattle''s Tekton pipelines'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '图 14.42: PetBattle 的 Tekton 流水线'
- en: Of course, you could keep the reuse to the `Task` level only but we share common
    tasks across the PetBattle UI, API, and Tournament applications. Ultimately, the
    development team has to balance the benefits of maintaining one pipeline over
    application pipeline autonomy. There is no one-size-fits-all answer.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以将重用限制在 `Task` 级别，但我们在 PetBattle 的 UI、API 和 Tournament 应用程序之间共享公共任务。最终，开发团队必须权衡维护一个流水线和每个应用程序流水线自治之间的利弊。没有放之四海而皆准的答案。
- en: Build, Bake, Deploy with Tekton
  id: totrans-518
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Tekton 进行构建、打包和部署
- en: The next step is to start designing what we put into our pipeline. This is a
    very iterative process! In our Big Picture, we talked about the Build, Bake, and
    Deploy process, so it makes sense to add pipeline task steps that follow this
    methodology.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是开始设计我们在流水线中使用的内容。这是一个非常迭代的过程！在我们的宏观图中，我们讨论了构建、打包和部署过程，因此增加遵循此方法论的流水线任务步骤是有意义的。
- en: '![](img/B16297_14_43.jpg)'
  id: totrans-520
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_43.jpg)'
- en: 'Figure 14.43: The list of task definitions used by PetBattle''s Tekton Pipelines'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.43：PetBattle 的 Tekton 流水线使用的任务定义列表
- en: The `maven-pipeline` starts by cloning the application and CI/CD (Ubiquitous
    Journey) repositories into the shared `workspace`. We check the code quality by
    invoking Maven to build and test the application, with quality reports being uploaded
    to our SonarQube image.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '`maven-pipeline` 开始通过将应用程序和 CI/CD（普遍旅程）代码库克隆到共享的 `workspace` 中。我们通过调用 Maven
    来构建和测试应用程序，从而检查代码质量，质量报告会被上传到我们的 SonarQube 镜像中。'
- en: We check that the quality gate in SonarQube has passed and then invoke Maven
    to package our application. Tekton offers us useful constructs to retry a task
    step if it fails by specifying the number of `retries` as well as the ordering
    of task steps using the `runAfter` task name list.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查 SonarQube 中的质量门是否通过，然后调用 Maven 来打包我们的应用程序。Tekton 提供了有用的构造，允许我们在任务步骤失败时通过指定
    `retries` 数量以及使用 `runAfter` 任务名称列表来重新尝试任务步骤。
- en: '[PRE203]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: In Java Quarkus, the packaging format could be a fat JAR, an exploded fast JAR,
    or a native GraalVM-based image. There are various trade-offs with each of these
    formats.[11](#footnote-083) However, we are using the exploded fast JAR in PetBattle,
    which allows us to trade off between faster build times or faster startup times.
    This is the end of the Build stage. We have moved the unit testing left in our
    pipeline, so we get fast feedback on any code quality issues before we move on
    to the Bake and Deploy pipeline phases.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java Quarkus 中，打包格式可以是 fat JAR、爆炸式快速 JAR 或基于 GraalVM 的本地镜像。这些格式各有利弊。[11](#footnote-083)
    然而，在 PetBattle 中，我们使用的是爆炸式快速 JAR，这让我们在更快的构建时间和更快的启动时间之间做出权衡。这是构建阶段的结束。我们将单元测试向左移动到流水线中，这样在进入打包和部署阶段之前，我们可以快速反馈任何代码质量问题。
- en: '![](img/B16297_14_44.jpg)'
  id: totrans-537
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_44.jpg)'
- en: 'Figure 14.44: The view of a PipelineRun in OpenShift showing the tasks being
    executed'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.44：在 OpenShift 中查看 PipelineRun，显示正在执行的任务
- en: '[11](#footnote-083-backlink) [https://quarkus.io/guides/maven-tooling](https://quarkus.io/guides/maven-tooling)'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '[11](#footnote-083-backlink) [https://quarkus.io/guides/maven-tooling](https://quarkus.io/guides/maven-tooling)'
- en: The Bake stage is next. We use a standard OpenShift BuildConfig object, which
    is loaded using Kustomize, as we do not package that with our Helm chart. We perform
    a binary build using the `oc start build` command on the packaged application.
    We decided not to upload the built application package to Nexus because we want
    to work with container images as our unit of deployment. If we were building libraries
    that needed to support our services, then they should be captured in Nexus at
    this stage. It is worth pointing out that we could also push the image to an external
    registry at this point in time so it can be easily shared between OpenShift clusters.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是打包阶段。我们使用一个标准的 OpenShift BuildConfig 对象，并通过 Kustomize 加载它，因为我们没有将其与 Helm
    图表一起打包。我们使用 `oc start build` 命令在打包的应用程序上执行二进制构建。我们决定不将构建好的应用程序包上传到 Nexus，因为我们希望使用容器镜像作为部署单元。如果我们正在构建需要支持我们服务的库，那么这些库应该在这个阶段被捕获到
    Nexus 中。值得指出的是，我们也可以在此时将镜像推送到外部注册中心，这样它可以在 OpenShift 集群之间轻松共享。
- en: '![](img/B16297_14_45.jpg)'
  id: totrans-541
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_45.jpg)'
- en: 'Figure 14.45: Bake part of the pipeline'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.45：流水线的打包部分
- en: 'The next step is to lint and package the application Helm chart. The versioned
    chart is then uploaded to Nexus. If we were on an application branch, the next
    pipeline step would be a `helm install` into the `labs-dev` project. We can make
    use of `when` statements in our Tekton pipeline to configure such behavior:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是进行代码检查并打包应用程序的 Helm 图表。然后，将版本化的图表上传到 Nexus。如果我们在应用程序分支上，下一步流水线操作将是将 `helm
    install` 安装到 `labs-dev` 项目中。我们可以在 Tekton 流水线中利用 `when` 语句来配置这种行为：
- en: '[PRE215]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: When on trunk/HEAD, the ImageStream is versioned and tagged into the namespaces
    we are going to deploy our application to (`labs-test`, `labs-staging`). Because
    we are practicing GitOps, the applications are deployed using Argo CD and Git.
    The Argo CD app-of-apps values files are updated with the new chart and image
    versions. This is checked into source code by the pipeline and `git commit` is
    executed. Argo CD is configured to automatically sync our applications in `labs-test`
    and `labs-staging`, and the last step of the pipeline is to make sure the sync
    task was successful.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 trunk/HEAD 上时，ImageStream 会被版本化并打标签到我们将要部署应用程序的命名空间（`labs-test`、`labs-staging`）。由于我们在实践
    GitOps，应用程序是通过 Argo CD 和 Git 部署的。Argo CD 的应用程序的值文件会更新为新的图表和镜像版本。这些文件会通过管道检查并执行
    `git commit`。Argo CD 配置为自动同步我们在 `labs-test` 和 `labs-staging` 中的应用程序，管道的最后一步是确保同步任务成功。
- en: '![](img/B16297_14_46.jpg)'
  id: totrans-552
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_46.jpg)'
- en: 'Figure 14.46: Deploy part of the pipeline'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.46：管道的部署部分
- en: There is a lot of pipeline information available to the developer in the OpenShift
    web console and all of the pipeline task logs can be easily seen.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenShift web 控制台中，开发人员可以访问到大量的管道信息，所有管道任务的日志也可以轻松查看。
- en: '![](img/B16297_14_47.jpg)'
  id: totrans-555
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_47.jpg)'
- en: 'Figure 14.47: Tekton pipeline progress and status hover'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.47：Tekton 管道进度和状态悬浮
- en: Tekton also has a great command-line tool called `tkn`, which can be used to
    perform all of the pipeline actions available in the OpenShift console, such as
    viewing logs, starting pipeline runs, and defining Tekton objects.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: Tekton 还提供了一个非常好的命令行工具，叫做 `tkn`，它可以用于执行 OpenShift 控制台中所有可用的管道操作，例如查看日志、启动管道运行和定义
    Tekton 对象。
- en: '[PRE222]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: NAME STARTED DURATION STATUS
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 名称 启动时间 持续时间 状态
- en: '[PRE223]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: Let's now take a look at how we can trigger a build.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看如何触发构建。
- en: Triggers and Webhooks
  id: totrans-567
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 触发器和 Webhooks
- en: On every developer push to Git, we wish to trigger a build. This ensures we
    get the fastest feedback for all of our code changes. In Tekton this is achieved
    by using an `EventListener` pod object. When created, a pod is deployed, exposing
    our defined trigger actions.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 每次开发人员将代码推送到 Git 时，我们希望触发一个构建。这确保了我们可以最快地获得所有代码变更的反馈。在 Tekton 中，这是通过使用一个 `EventListener`
    pod 对象来实现的。创建时，会部署一个 pod，暴露我们定义的触发器操作。
- en: '![](img/B16297_14_48.jpg)'
  id: totrans-569
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_48.jpg)'
- en: 'Figure 14.48: Tekton Triggers flow'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.48：Tekton 触发器流
- en: 'Tekton Triggers work by having `EventListener` objects receive incoming webhook
    notifications, processing them using an interceptor, and creating Kubernetes resources
    from templates if the interceptor allows it, with the extraction of fields from
    the body of the webhook (there''s an assumption that the body is a JSON file):'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: Tekton 触发器通过让 `EventListener` 对象接收传入的 webhook 通知来工作，使用拦截器处理这些通知，并根据拦截器的允许从模板中创建
    Kubernetes 资源，同时从 webhook 的正文中提取字段（假设正文是一个 JSON 文件）：
- en: '[PRE229]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: In OpenShift, we expose the `EventListener` webhook endpoint as a route so that
    it can be wired into Git. Different types of `TriggerBinding` and pass to our
    `TriggerTemplate`. The `TriggerTemplate` then defines the Tekton resources to
    create. In our case, this is a `PipelineRun` or `TaskRun` definition.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenShift 中，我们将 `EventListener` 的 webhook 端点作为路由暴露，以便可以将其连接到 Git。不同类型的 `TriggerBinding`
    被传递到我们的 `TriggerTemplate`。然后，`TriggerTemplate` 定义了要创建的 Tekton 资源。在我们的案例中，这是一个
    `PipelineRun` 或 `TaskRun` 定义。
- en: '[PRE244]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: Tekton uses an expression language, known as the **Common Expression Language**
    (**CEL**),[13](#footnote-081) to parse and filter requests based on JSON bodies
    and request headers. This is necessary because of the differing webhook payloads
    and potentially different Git workflows. For example, we are using GitHub and
    treat a pull request differently from changes to our main/HEAD. One customization
    we make that you can see above is to define the Argo CD app-of-apps key in the
    trigger binding based on the Git repository name. This allows us to check the
    synchronization of just the one application that changed and not the whole application
    suite during the Deploy phase of our pipeline. While triggering seems complex,
    the flexibility is required when dealing with all the various Git SCMs and workflows
    that are available to development teams.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: Tekton使用一种表达式语言，称为**通用表达式语言**（**CEL**），[13](#footnote-081)用来根据JSON主体和请求头解析和过滤请求。这是必要的，因为Webhook的有效载荷和Git工作流可能会有所不同。例如，我们使用GitHub，并且将拉取请求与对我们的main/HEAD分支的更改视为不同。我们在上述示例中所做的一项自定义是，根据Git仓库名称在触发绑定中定义Argo
    CD的app-of-apps键。这使我们可以在管道的部署阶段检查只更改了的那个应用的同步状态，而不是整个应用套件。虽然触发过程看起来复杂，但在处理各种Git
    SCM和开发团队可用的工作流时，这种灵活性是必需的。
- en: '[12](#footnote-082-backlink) [https://docs.github.com/en/developers/webhooks-and-events/webhook-events-and-payloads](https://docs.github.com/en/developers/webhooks-and-events/webhook-events-and-payloads)'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '[12](#footnote-082-backlink) [https://docs.github.com/en/developers/webhooks-and-events/webhook-events-and-payloads](https://docs.github.com/en/developers/webhooks-and-events/webhook-events-and-payloads)'
- en: '[13](#footnote-081-backlink) [https://github.com/google/cel-go](https://github.com/google/cel-go)'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '[13](#footnote-081-backlink) [https://github.com/google/cel-go](https://github.com/google/cel-go)'
- en: There are some convenience templates loaded into the `labs-ci-cd` project by
    Ubiquitous Journey that can be used to manually trigger a `PipelineRun`—this is
    handy if you have not configured the GitHub webhook yet.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些便捷的模板已经被Ubiquitous Journey加载到`labs-ci-cd`项目中，可以用于手动触发`PipelineRun`——如果你还没有配置GitHub
    webhook，这个功能非常有用。
- en: '[PRE264]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: You can manually add webhooks to your GitHub projects[14](#footnote-080) that
    point to the `EventListener` route exposed in the `labs-ci-cd` project.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以手动将webhook添加到你的GitHub项目中[14](#footnote-080)，指向在`labs-ci-cd`项目中暴露的`EventListener`路由。
- en: '[PRE267]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: Otherwise, check out the PetBattle Ubiquitous Journey documentation for Tekton
    tasks that can be run to automatically add these webhooks to your Git repositories.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，查看PetBattle Ubiquitous Journey文档，了解可以运行的Tekton任务，这些任务能够自动将这些webhook添加到你的Git仓库中。
- en: GitOps our Pipelines
  id: totrans-618
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GitOps我们的管道
- en: Our pipeline, task, trigger, workspace, and volume definitions are themselves
    applied to our `labs-ci-cd` project using GitOps. The idea here is to minimize
    how hard it is to adapt our pipelines. We may want to add some more security checks
    into our pipeline steps, for example. If there are testing failures, or even service
    failures in production, then we need to adapt our pipelines to cater for further
    quality controls or testing steps. Adding new tools or modifying task steps becomes
    nothing more than pushing the pipeline as code definitions to Git.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的管道、任务、触发器、工作空间和卷定义本身通过GitOps应用到`labs-ci-cd`项目中。这里的想法是最小化我们对管道进行适应的难度。例如，我们可能想要在管道步骤中增加一些安全检查。如果测试失败，或者生产环境中的服务失败，我们就需要调整管道，以适应更多的质量控制或测试步骤。添加新工具或修改任务步骤仅仅是将管道代码定义推送到Git中而已。
- en: '[PRE268]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: Within our Tekton source folder, we use Kustomize to apply all of the YAML files
    that define our Tekton objects. These pipeline objects are kept in sync by Argo
    CD.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Tekton源文件夹中，我们使用Kustomize来应用所有定义Tekton对象的YAML文件。这些管道对象通过Argo CD保持同步。
- en: '[14](#footnote-080-backlink) [https://docs.github.com/en/developers/webhooks-and-events/creating-webhooks](https://docs.github.com/en/developers/webhooks-and-events/creating-webhooks)'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '[14](#footnote-080-backlink) [https://docs.github.com/en/developers/webhooks-and-events/creating-webhooks](https://docs.github.com/en/developers/webhooks-and-events/creating-webhooks)'
- en: Which One Should I Use?
  id: totrans-631
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我应该使用哪个？
- en: 'The CI/CD tooling landscape is massive[15](#footnote-079) and also extremely
    vibrant and healthy. The CNCF landscape for tools in this category has no less
    than 36 products and projects today. In trying to answer the question of which
    one you should use; it is best to consider multiple factors:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD工具的生态系统庞大[15](#footnote-079)，并且充满活力和健康。CNCF在这个类别中的工具生态系统今天有不少于36个产品和项目。在试图回答“我应该使用哪一个？”这个问题时，最好考虑多个因素：
- en: Does your team have previous skills in a certain tooling or language? For example,
    pipelines as code in Jenkins use the Groovy language, so if your team has Groovy
    or JavaScript skills, this could be a good choice.
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的团队是否拥有某些工具或语言的相关经验？例如，Jenkins 中的代码流水线使用 Groovy 语言，因此如果你的团队具有 Groovy 或 JavaScript
    技能，这可能是一个不错的选择。
- en: Does the tool integrate with the platform easily? Most of the tools in CNCF
    have good integration with Kubernetes already and have a cloud-native pedigree.
    That does not mean that all tools are the same in terms of deployment, platform
    integration, or lifecycle management—some may be **Software as a Service** (**SaaS**)-only
    offerings with agents, whereas some can be deployed per team using namespace isolation
    on your cluster. Others, such as Argo CD and Tekton, can be deployed at cluster
    scope using the operator pattern, and have their lifecycle managed via the **Operator
    Lifecycle Manager** (**OLM**). Tekton has great web console integration with OpenShift
    because of the OpenShift Pipelines operator.
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该工具是否能与平台轻松集成？CNCF 中的大多数工具已与 Kubernetes 良好集成，并且具有云原生的血统。但这并不意味着所有工具在部署、平台集成或生命周期管理方面都是相同的——有些可能只是**软件即服务**（**SaaS**）形式的工具，使用代理进行部署，而另一些则可以通过在集群中使用命名空间隔离为每个团队进行部署。还有一些工具，如
    Argo CD 和 Tekton，可以使用操作器模式在集群范围内部署，并通过**操作器生命周期管理器**（**OLM**）来管理它们的生命周期。由于 OpenShift
    Pipelines 操作器的存在，Tekton 与 OpenShift 的 Web 控制台集成非常出色。
- en: 'Tool deployment model: Jenkins and Argo CD both have a client-server model
    for deployment. This can be problematic at larger scales, such as when looking
    after thousands of pipelines or hundreds of applications. It may be necessary
    to use multiple deployments to scale across teams and clusters. Argo CD and Tekton
    extend Kubernetes using CRDs and operator patterns, so deployment is more Kubernetes-native
    in its scaling model.'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具部署模型：Jenkins 和 Argo CD 都采用客户端-服务器模型进行部署。在大规模应用时可能会遇到问题，例如需要管理成千上万的流水线或数百个应用程序。可能需要使用多个部署来扩展到不同团队和集群。Argo
    CD 和 Tekton 使用 CRD 和操作器模式扩展 Kubernetes，因此它们的部署在扩展模型上更符合 Kubernetes 本地化。
- en: 'Enterprise support: Most, but not all, the tools have vendor support. This
    is important for enterprise organizations that need a relationship with a vendor
    to cover certification, training, security fixes, and product lifecycles.'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业支持：大多数工具都提供供应商支持，但并非所有工具都有。这对于需要与供应商建立关系的企业组织至关重要，以涵盖认证、培训、安全修复和产品生命周期等问题。
- en: '[15](#footnote-079-backlink) [https://landscape.cncf.io/card-mode?category=continuous-integration-delivery&grouping=category](https://landscape.cncf.io/card-mode?category=continuous-integration-delivery&grouping=category)'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '[15](#footnote-079-backlink) [https://landscape.cncf.io/card-mode?category=continuous-integration-delivery&grouping=category](https://landscape.cncf.io/card-mode?category=continuous-integration-delivery&grouping=category)'
- en: '![](img/B16297_14_49.jpg)'
  id: totrans-638
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_14_49.jpg)'
- en: 'Figure 14.49: CNCF CI/CD tooling landscape'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.49：CNCF CI/CD 工具生态图
- en: 'Active open-source communities: A vibrant upstream community is important as
    a place to collaborate and share code and knowledge. Rapid development of features
    and plugins often occurs in a community based on real user problems and requests.'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活跃的开源社区：一个充满活力的上游社区非常重要，它是合作、共享代码和知识的场所。功能和插件的快速开发通常源自一个基于实际用户问题和需求的社区。
- en: One tool for both CI and CD or use different tools? As we have shown with PetBattle,
    sometimes it makes sense for CI to be a push-type model, and CD to be a pull-type
    model using different tools.
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用同一工具进行 CI 和 CD，还是使用不同的工具？正如我们在 PetBattle 中所展示的那样，有时 CI 使用推式模型，CD 使用拉式模型并使用不同的工具是有意义的。
- en: 'Extensibility model: This is important for the ecosystem around the tooling.
    Jenkins has a great plugin model that allows lots of different extensions to the
    core. Tekton has a similar model, but it is different in that users have the ability
    to use any container in a task. It is important to weigh up these extensions as
    they offer a lot of value on top of the core tool itself. A good example is that
    Tekton does not manage test dashboards and results as well as Jenkins and its
    plugins do, so we might lean on Allure to do this. Reporting and dashboarding
    extensions are important to make the feedback loop as short as possible during
    CI/CD.'
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性模型：这对于工具周围的生态系统非常重要。Jenkins 拥有一个出色的插件模型，允许许多不同的扩展到核心。Tekton 有类似的模型，但它与 Jenkins
    的不同之处在于，用户可以在任务中使用任何容器。评估这些扩展很重要，因为它们在核心工具之上提供了很多价值。一个好的例子是，Tekton 在管理测试仪表盘和结果方面不如
    Jenkins 及其插件那样好，因此我们可能会依赖 Allure 来完成这项工作。报告和仪表盘扩展对于在 CI/CD 过程中尽量缩短反馈循环至关重要。
- en: Once you have considered a few of these ideals, hopefully you will agree on
    the right set of tools for your product and team. A measure of design and planning
    is required to answer the question of where the various steps in your continuous
    deployment happen and what application packaging approach should be used (templated
    or not templated, for example). By now, we have instilled an experiment-driven
    approach to answering these types of questions, where it is not one or the other
    tool, but about choosing the right tool for the job at hand!
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你考虑了这些理想， hopefully 你会对适合你的产品和团队的工具组合达成共识。设计和规划是回答各个连续部署步骤如何进行以及应使用什么应用打包方法（例如，是否使用模板）的必要手段。到目前为止，我们已经培养了一种以实验为驱动的方法来回答这些问题，这里并不是非此即彼的工具选择，而是选择最适合当前任务的工具！
- en: Conclusion
  id: totrans-644
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter we introduced how we use Git as the single source of truth.
    We covered taking our source code and packaging it using either
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何将 Git 作为唯一的可信来源。我们涵盖了如何使用它来打包源代码，选择使用模板或不使用模板的方式。
- en: Tekton or Jenkins. In the next chapter, we will focus on testing, introducing
    a new component to our app using Knative, running A/B tests, and capturing user
    metrics using some of the advanced deployment capabilities within OpenShift.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: Tekton 或 Jenkins。在下一章中，我们将重点介绍测试，使用 Knative 向我们的应用程序添加新组件，进行 A/B 测试，并利用 OpenShift
    中一些高级部署功能捕获用户指标。
