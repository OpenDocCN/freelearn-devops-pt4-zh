- en: Introducing Serverless
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入无服务器架构
- en: This book will introduce us to the world of the serverless approach to information
    technology, looking at multiple different cloud service providers, such as AWS,
    Azure, Google, OpenWhisk, and a few others. We will look in detail at each cloud
    service, as well as the different methods that are used to apply DevOps to them.
    We will look at the different use cases and learn the best practices for each
    of them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将带我们进入无服务器信息技术的世界，了解多个不同的云服务提供商，如 AWS、Azure、Google、OpenWhisk 和其他一些服务。我们将详细介绍每个云服务，并探讨将
    DevOps 应用于这些服务的不同方法。我们将研究不同的使用案例，并学习每个案例的最佳实践。
- en: 'The following topics will be covered in this introductory chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本介绍章节将涵盖以下主题：
- en: Introduction to serverless
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器简介
- en: Core concept
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心概念
- en: '**Backend as a service** (**BaaS**)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后端即服务** (**BaaS**)'
- en: '**Function as a service **(**FaaS**)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能即服务** (**FaaS**)'
- en: AWS Lambda
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Lambda
- en: Azure functions
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Functions
- en: Google functions
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Functions
- en: OpenWhisk
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenWhisk
- en: Pros and cons of serverless
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器的优缺点
- en: DevOps with serverless
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DevOps 与无服务器架构
- en: Introduction to serverless
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器简介
- en: 'When we hear the word **serverless**, the first thing that comes to mind is,
    *oh, my code will magically run without any server!*. In a way, this is right:
    the serverless approach is a process where we deploy the code into a cloud and
    it is executed automatically, without worrying about the underlying infrastructure,
    renting or buying servers, scaling, monitoring, or capacity planning. The service
    provider will take care of all these things. Also, you won''t believe how cheap
    it is and how much easier it is to manage. Now, you are probably thinking, *how
    is that possible?*. To look at its workings in more detail, let''s compare the
    serverless approach with something we do in our daily lives.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们听到“**无服务器**”这个词时，第一个想到的可能是，*哦，我的代码将在没有任何服务器的情况下自动运行！* 从某种程度上来说，这个想法是正确的：无服务器架构是一种将代码部署到云端并自动执行的过程，用户无需担心底层基础设施、租赁或购买服务器、扩展、监控或容量规划。服务提供商会负责所有这些事情。而且，你不会相信它是多么便宜，管理起来又是多么轻松。现在，你可能在想，*这怎么可能呢？*
    为了更详细地了解它的工作原理，让我们将无服务器架构与我们日常生活中的一件事进行对比。
- en: The serverless approach is a bit like dealing with our laundry. We all need
    to wash our clothes, and for this, we need to buy a washing machine. But the usage
    of this washing machine will be about 10 to 15 hours per week, and the rest of
    the time the washing machine will be idle. Interestingly, we buy servers to host
    our application, and most of the time, our servers are idle when waiting for requests
    and sit unused. We have piles of servers that are hardly managed or decommissioned.
    As they are not properly used or managed, resources, such as the power supply,
    capacity, storage, and memory, are wasted.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器架构有点像处理我们的洗衣服。我们都需要洗衣服，为此，我们需要购买一台洗衣机。但是，这台洗衣机每周的使用时间大约只有10到15个小时，其余时间它将处于空闲状态。有趣的是，我们购买服务器来托管我们的应用程序，而大部分时间，服务器在等待请求时处于空闲状态，未被使用。我们拥有大量的服务器，但它们很少被管理或淘汰。由于这些服务器没有得到正确的使用或管理，导致电力供应、容量、存储和内存等资源被浪费。
- en: 'Also, while doing the laundry, the washing machine will allow only a certain
    load and volume. The same applies to servers: They too allow only a certain volume
    and load. The more the load or traffic, the slower the processing will be, or
    it may stop completely. Now, to take care of our extra load, we might decide to
    buy a bigger washing machine, which will allow a bigger volume of laundry and
    support a larger load. But again, this high-end machine will take the same resources
    if we have to wash a huge pile of clothes or just one piece of clothing, which
    is wasteful. The same is the case in our server analogy. When catering for higher
    traffic or requests, we could buy a high-end server. But we will end up using
    the same resources for 10 requests a day as we would for 10,000 requests, even
    with a high-end server.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在洗衣服时，洗衣机只能承受一定的负载和容量。同样，服务器也有类似的限制：它们也只能承载一定的负载和流量。负载或流量越大，处理速度可能会变慢，甚至可能完全停止。现在，为了应对额外的负载，我们可能会决定购买一台更大的洗衣机，这样可以处理更多的衣物，支持更大的负载。但同样，这台高端机器在我们洗大量衣物或只洗一件衣物时，都将消耗相同的资源，这是浪费。同样，在服务器的类比中，当我们需要应对更高流量或请求时，我们可能会购买一台高端服务器。但是，即使是高端服务器，我们每天处理10个请求与处理10,000个请求时，所消耗的资源是一样的。
- en: Also, to use the washing machine, we have to separate our clothes before washing,
    select the program, and add the detergent and softener, and if these elements
    are not handled properly, we might ruin our clothes. Similarly, when using a server,
    we have to make sure we install the right software—as well as the right version
    of the software—make sure that it is secure enough, and always monitor whether
    the services are running.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，要使用洗衣机，我们需要在洗衣前分开衣物，选择程序，添加洗衣液和柔顺剂，如果这些操作不当，可能会弄坏衣物。同样，在使用服务器时，我们也必须确保安装正确的软件——以及正确的软件版本——确保其足够安全，并且始终监控服务是否正常运行。
- en: Also, if you are renting an apartment, then you might not have a washing machine,
    or perhaps you might find launderettes to be cheaper when you wash you laundry
    in bulk, and also less worrisome. So launderettes or coin-operated laundry machines
    can be rented whenever you need to wash your clothes. Likewise, many companies,
    such as AWS, Azure, or Google, started by renting their servers. So we too can
    rent a server, and the provider will take care of the storage, memory, power,
    and basic setup.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你租的是公寓，可能没有洗衣机，或者你可能会发现当你批量洗衣时，自助洗衣店会更便宜，也更省心。所以你可以根据需要租用自助洗衣店或投币式洗衣机。同样，许多公司，如AWS、Azure或Google，最初也是通过租用服务器起步的。所以我们也可以租用服务器，提供商会负责存储、内存、电力和基本设置。
- en: Say that we've decided that a coin-operated washing machine at the local launderette
    is our best option. Now we just put the coin in and wash our clothes, but we still
    need to make sure we add detergent and fabric softener, and set the right program,
    otherwise we will end up ruining our clothes. Likewise, when we rent a server
    on the cloud, we might not bother dealing with the power, storage, and memory.
    But we still need to install the required software, monitor the application service,
    and upgrade the software version from time to time, as well as monitor the performance
    of the application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们决定使用本地自助洗衣店的投币式洗衣机作为最佳选择。现在我们只需要投币洗衣，但我们仍然需要确保添加洗衣液和柔顺剂，并设置正确的程序，否则我们会弄坏衣物。同样，当我们在云上租用服务器时，可能不需要处理电力、存储和内存问题，但我们仍然需要安装所需的软件，监控应用服务，定期升级软件版本，并监控应用性能。
- en: Say that I found a new launderette, one that has a delivery service and that
    would charge me per item of clothing, so I can send clothes in bulk or one piece
    at a time. They will wash and iron my clothes too. Now, I don't need to worry
    about which detergent or comforter to use, or what cleaning program to use, and
    I also don't need to own an iron. But in the case of the world of information
    technology, companies are still using the rental coin laundry system. They still
    lease servers and manage them through **P****latform as a Service** (**PaaS**),
    still manage application downtime, upgrade the software version, and monitor services.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我找到了一家新的自助洗衣店，这家店提供送货服务，并按每件衣物收费，所以我可以一次送一批衣物或单件衣物。它们还会为我洗衣并熨烫衣物。现在，我不需要担心使用哪种洗衣液或柔顺剂，也不需要担心选择什么清洗程序，甚至不需要拥有熨斗。但在信息技术的世界中，许多公司仍然在使用租赁的投币式洗衣机系统。它们仍然租用服务器并通过**平台即服务**（**PaaS**）进行管理，仍然需要管理应用程序的停机时间，升级软件版本，并监控服务。
- en: But this can all be changed by adopting a serverless approach. Serverless computing
    will automatically provision and configure the server and then execute the code.
    As the traffic rises, it will scale automatically, apply the required resources,
    and scale down once the traffic eases down.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但通过采用无服务器的方法，这一切都可以改变。无服务器计算将自动配置服务器并执行代码。随着流量的增加，它将自动扩展，提供所需的资源，一旦流量减少，它也会缩减规模。
- en: Core concept
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心概念
- en: In earlier days, the term *serverless* referred to an application that was dependent
    on third-party applications or services to manage server-side logic. Such applications
    were cloud-based databases, such as Google Firebase, or authentication services,
    such as Auth0 or AWS Cognito. They were referred to as **Backend as a Service**
    (**BaaS**) services. But serverless also means code that is developed to be event-triggered,
    and which is executed in stateless compute containers. This architecture is popularly
    known as **F****unction as a Service** (**FaaS**). Let's look at each type of
    service in a bit more detail.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期，“*无服务器*”一词指的是依赖第三方应用或服务来管理服务器端逻辑的应用。这些应用通常是基于云的数据库，如Google Firebase，或者是身份验证服务，如Auth0或AWS
    Cognito。它们被称为**Backend as a Service**（**BaaS**）服务。但“无服务器”也意味着代码是为事件触发而开发的，并且在无状态的计算容器中执行。这种架构通常被称为**Function
    as a Service**（**FaaS**）。让我们更详细地了解一下每种类型的服务。
- en: Backend as a Service
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Backend as a Service
- en: The BaaS was conceptualized by Auth0 and Google Firebase. Auth0 started as authentication
    as a service, but moved to FaaS.  So basically, BaaS is third-party service through
    which we can implement our required functionality, and it will provide server-side
    logic for the implementation of the application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: BaaS的概念是由Auth0和Google Firebase提出的。Auth0最初作为身份验证即服务（authentication as a service）起步，但后来转向了FaaS。因此，BaaS本质上是通过第三方服务来实现我们所需的功能，它为应用的实现提供了服务器端逻辑。
- en: The common approach is that most web and mobile application developers code
    their own authentication functionality, such as login, registration, and password
    management, and each of these services has its own API, which has to be incorporated
    into the application. But this was complicated and time consuming for developers,
    and BaaS providers made it easy by having a unified API and SDK and bridging them
    with the frontend of the application so that developers did not have to worry
    about developing their own backend services for each service. In this way, time
    and money was saved.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的做法是，大多数Web和移动应用开发者会自己编写身份验证功能，如登录、注册和密码管理，并且每个服务都有自己的API，需要将其集成到应用中。但这对开发者来说既复杂又耗时，而BaaS提供商通过提供统一的API和SDK，帮助开发者将它们与应用前端连接，从而省去了开发自己的后端服务的麻烦。这样就节省了时间和金钱。
- en: Say, for example, that we want to build a portal that would require authentication
    to consume our services. We would need login, signup, and authentication systems
    in place, and we would also need to make it easy for the consumer to sign in with
    just a click of a button using their existing Google or Facebook or Twitter account.
    Developing these functionalities individually requires lots of time and effort.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要构建一个门户网站，该网站需要进行身份验证才能使用我们的服务。我们需要设置登录、注册和身份验证系统，并且我们还需要让消费者能够通过简单的一键操作，使用他们现有的Google、Facebook或Twitter账户进行登录。单独开发这些功能需要大量的时间和精力。
- en: But by using BaaS, we can easily integrate our portal to sign up and authenticate
    using a Google, Facebook, or Twitter account. Another BaaS service is Firebase,
    provided by Google. Firebase is a database service that is used by mobile apps,
    where database administration overhead is mitigated, and it provides authorization
    for different types of users. In a nutshell, this is how BaaS works. Let's look
    at the FaaS side of the serverless approach.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但是通过使用BaaS，我们可以轻松地将我们的门户网站与Google、Facebook或Twitter账户进行集成，实现注册和身份验证。另一个BaaS服务是由Google提供的Firebase。Firebase是一个数据库服务，广泛应用于移动应用，它减少了数据库管理的开销，并且为不同类型的用户提供授权。简而言之，这就是BaaS的工作原理。接下来，让我们来看一下无服务器架构中的FaaS部分。
- en: Function as a Service
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Function as a Service
- en: As mentioned at the start of chapter, FaaS is essentially a small program or
    function that performs small tasks that are triggered by an event, unlike a monolithic
    app, which does lots of things. So, in FaaS architecture, we break our app into
    small, self-contained programs or functions instead of the monolithic app that
    runs on PaaS and performs multiple functions. For instance, each endpoint in the
    API could be a separate function, and we can run these functions on demand rather
    than running the app full time.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头所提到的，FaaS本质上是一个执行小任务的程序或功能，这些任务由事件触发，与一个执行多种功能的单体应用不同。因此，在FaaS架构中，我们将应用拆分成小的、独立的程序或功能，而不是运行在PaaS上的、执行多个功能的单体应用。例如，API中的每个端点都可以是一个单独的函数，我们可以根据需求运行这些函数，而不是一直运行整个应用。
- en: 'The common approach would be to have an API coded in a multi-layer architecture,
    something like a three-tier architecture where code is broken down into a presentation,
    business, and data layer. All the routes would trigger the same handler functions
    in the business layer, and data would be processed and sent to the data layer,
    which would be a database or file. The following diagram shows this three-tier
    architecture:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的做法是将API编码为多层架构，类似三层架构，将代码分解为表示层、业务层和数据层。所有路由都会触发业务层中的相同处理函数，数据将被处理并发送到数据层，该数据层通常是数据库或文件。下图显示了这种三层架构：
- en: '![](img/2b9b12a1-0592-4891-9ccb-19850cf55cd0.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b9b12a1-0592-4891-9ccb-19850cf55cd0.jpg)'
- en: That might work fine for small numbers of simultaneous users, but how would
    we manage this when traffic grows exponentially? The application will suddenly
    become a  computing nightmare. So, to resolve this problem, ideally, we would
    separate the data layer, which contains the database, into the separate server.
    But the problem is still not solved, because the API routes and business logic
    is within one application, so the scaling would still be a problem.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于少量同时用户，这种方式可能工作正常，但当流量呈指数级增长时，我们该如何管理呢？此时，应用将突然成为计算噩梦。因此，理想情况下，我们可以将包含数据库的数据层分离到独立的服务器中来解决这个问题。但是问题依然没有解决，因为API路由和业务逻辑仍然在同一个应用中，因此扩展仍然是一个问题。
- en: 'A serverless approach to the same problem is painless. Instead of having one
    server for application API endpoints and business logic, each part of the application
    is broken down into independent, auto-scalable functions. The developer writes
    a function, and the serverless provider wraps the function into a container that
    can be monitored, cloned, and distributed on any number of servers, as shown in
    the following diagram:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于相同的问题，采用无服务器的方法则更加轻松。与其为应用API端点和业务逻辑设置一个服务器，不如将应用程序的每个部分拆解成独立的、自动扩展的函数。开发人员编写一个函数，随后无服务器提供商将该函数封装到一个容器中，容器可以在任意数量的服务器上进行监控、克隆和分发，如下图所示：
- en: '![](img/73925aef-65c8-4751-9c20-24826a1a98d7.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73925aef-65c8-4751-9c20-24826a1a98d7.jpg)'
- en: The benefit to breaking down an application into functions is that we can scale
    and deploy each function separately. For instance, if one endpoint in our API
    is where 90 percent of our traffic goes, or our image-processing code is eating
    up most of the computing time, that one function or bit code can be distributed
    and scaled more easily than scaling out the entire application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序拆分成函数的好处在于，我们可以分别扩展和部署每个函数。例如，如果我们的API中某个端点接收到90%的流量，或者我们的图像处理代码占用了大部分计算时间，那么这个函数或代码片段比扩展整个应用程序更容易进行分发和扩展。
- en: In a FaaS system, the functions are expected to start within milliseconds in
    order to allow the handling of individual requests. In PaaS systems, by contrast,
    there is typically an application thread that keeps running for long periods of
    time, and handles multiple requests. FaaS services are charged per execution time
    of the function, whilst PaaS services charge per running time of the thread in
    which the server application is running.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在FaaS系统中，函数预计能够在毫秒级别内启动，以便处理单个请求。相比之下，在PaaS系统中，通常有一个应用线程，它会长时间运行，并处理多个请求。FaaS服务按函数的执行时间收费，而PaaS服务则按运行服务器应用程序的线程时间收费。
- en: In the microservices architecture, the applications are loosely coupled, fine
    grained, and light weighted. The reason for the birth of microservices is to break
    down the monolithic application into small services so that it can be developed,
    managed, and scaled independently. But FaaS takes that a step further by breaking
    things down into even smaller units called functions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，应用程序是松散耦合的、精细化的、轻量级的。微服务诞生的原因是将单体应用拆分为小型服务，以便可以独立开发、管理和扩展。但是FaaS进一步将这一概念推向了更小的单元，称为函数。
- en: 'The trend is pretty clear: The unit of work is getting smaller and smaller.
    We''are moving from monoliths to microservices, and now to functions, as shown
    in the following diagram:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 趋势非常明显：工作单元变得越来越小。我们正从单体应用转向微服务，再到现在的函数，如下图所示：
- en: '![](img/267d8a00-37a5-4f6b-8327-3068780d5433.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/267d8a00-37a5-4f6b-8327-3068780d5433.png)'
- en: With the rise of containers, many cloud vendors saw that serverless functions
    architecture will provide better flexibility for developers to build their applications
    without worrying about the ops (operations). AWS was first to launch this service
    with the name Lambda, then other cloud providers followed the trend, such as Microsoft
    Azure with Azure Functions and Google Cloud with Google Functions. But this popularity
    also gave an opportunity for some vendors to build open source versions. Some
    popular versions are IBM's OpenWhisk, which is Apache licensed, Kubeless, which
    is built over the top of Kubernetes, and OpenFaaS, which is built over the Docker
    container. Even Oracle jumped into the foray with Oracle Fn. Let's briefly look
    at each vendor in this chapter, learning about how they work. We will then travel
    with them over the rest of the book, looking at their approach to DevOps.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 随着容器的兴起，许多云服务商意识到无服务器函数架构将为开发者提供更好的灵活性，让他们构建应用程序时无需担心运维（操作）。AWS 是第一个推出这一服务的公司，命名为
    Lambda，之后其他云服务提供商也跟随这一趋势，比如微软 Azure 推出了 Azure Functions，谷歌云推出了 Google Functions。但这一流行趋势也为一些供应商提供了机会，他们开始构建开源版本。一些流行的版本包括
    IBM 的 OpenWhisk（基于 Apache 许可），Kubeless（基于 Kubernetes 构建）以及 OpenFaaS（基于 Docker
    容器构建）。甚至 Oracle 也加入了这一行列，推出了 Oracle Fn。本章我们将简要介绍每个供应商，了解他们的工作原理。接着，在接下来的书籍中，我们将与这些供应商一起探索他们的
    DevOps 方法。
- en: AWS Lambda
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS Lambda
- en: '**Amazon Web Services** (**AWS**) were the first to launch a FaaS, or serverless, service
    in 2014, called Lambda. They are currently the leaders in this kind of serverless
    provision. AWS Lambda follow the event-driven approach. At the trigger of an event,
    Lambda executes the code and performs the required functionality, and it can automatically
    scale as the traffic rises, as well as automatically descale. Lambda functions
    run in response to events, such as changes to the data  in an Amazon S3 bucket,
    an Amazon DynamoDB table change, or in response to an HTTP request through the
    AWS API Gateway. That''s how Lambda helps to build the triggers for multiple services,
    such as S3 DynamoDB, and the stream data store in Kinesis.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊网络服务** (**AWS**) 是首个在 2014 年推出 FaaS 或无服务器服务的公司，命名为 Lambda。如今，他们是这一类无服务器服务的领导者。AWS
    Lambda 采用事件驱动的方法。当事件触发时，Lambda 执行代码并完成所需功能，并且能够在流量增加时自动扩展，流量减少时自动缩减。Lambda 函数根据事件触发运行，例如对
    Amazon S3 存储桶中数据的更改、对 Amazon DynamoDB 表的更改，或响应通过 AWS API Gateway 发出的 HTTP 请求。正是通过这种方式，Lambda
    帮助构建多个服务的触发器，如 S3、DynamoDB 和 Kinesis 中的流数据存储。'
- en: So, Lambda helps developers only worry about the coding—the computing part,
    such as the memory, CPU, network, and space, is taken care of by Lambda automatically.
    It also automatically manages the patching, logging, and monitoring of functions.
    Architecturally, a Lambda function is invoked in a container, which is launched
    based on the configuration provided. These containers might be reused for subsequent
    invocations for functions. As the demand dies, the container is decommissioned,
    but this is all managed internally by Lambda, so users do not have to worry about
    it as they do not have any control over these containers. The languages supported
    by AWS Lambda functions are Node.js, Java, C#, and Python.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，Lambda 帮助开发者只需关注编码——计算部分，如内存、CPU、网络和空间，由 Lambda 自动处理。它还会自动管理函数的修补、日志记录和监控。从架构上讲，Lambda
    函数在一个容器中被调用，该容器是基于提供的配置启动的。这些容器可能会被复用来处理后续的函数调用。当需求减少时，容器会被停用，但这一切都由 Lambda 内部管理，因此用户无需担心，因为他们无法控制这些容器。AWS
    Lambda 函数支持的语言有 Node.js、Java、C# 和 Python。
- en: While building serverless applications, the core components are functions and
    the event source. The event source is the AWS service or custom application, and
    the Lambda function processes the events. The execution time for each Lambda function
    is 300 seconds.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建无服务器应用时，核心组件是函数和事件源。事件源是 AWS 服务或自定义应用程序，而 Lambda 函数处理这些事件。每个 Lambda 函数的执行时间为
    300 秒。
- en: Let's look at an example of how AWS Lambda actually works. In a photo-sharing
    application, people upload their photos, and these photos need to have thumbnails
    so that they can be displayed on the user's profile page. In this scenario, we
    can use the Lambda function to create the thumbnails, so that the moment the photo
    gets uploaded in the AWS S3 bucket, S3, which supports the events source, can
    publish the object-created events and invoke the Lambda function. The Lambda function
    code reads the latest photo object from the S3 bucket, creates a thumbnail version,
    and saves it in another S3 bucket.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个 AWS Lambda 实际运作的示例。在一个照片分享应用中，用户上传照片，这些照片需要生成缩略图，以便在用户的个人主页上展示。在这种情况下，我们可以使用
    Lambda 函数来创建缩略图，这样一旦照片被上传到 AWS S3 存储桶中，支持事件源的 S3 就可以发布对象创建事件并调用 Lambda 函数。Lambda
    函数的代码从 S3 存储桶中读取最新的照片对象，创建一个缩略图版本，并将其保存到另一个 S3 存储桶中。
- en: In [Chapter 3](e7282c95-dfff-4ed6-91e2-92224fa414bf.xhtml), *Applying DevOps
    on AWS Lambda Applications*, we will look at how we can create, run, and deploy
    Lambda functions in an automated way, and we will also monitor and perform root-cause
    analysis through logging.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](e7282c95-dfff-4ed6-91e2-92224fa414bf.xhtml)，*将 DevOps 应用到 AWS Lambda
    应用程序*，我们将探讨如何以自动化的方式创建、运行和部署 Lambda 函数，同时通过日志监控和进行根本原因分析。
- en: Azure Functions
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure Functions
- en: '**Azure Functions** is Microsoft''s venture into serverless architecture. It
    came onto the market in March 2016\. Azure Functions allows functions to be coded
    in C#, F#, PHP, Node.js, Python, and Java. Azure Functions also supports bash,
    batch, and PowerShell files.  Azure Functions has seamless integration with **Visual
    Studio Team System** (**VSTS**), Bitbucket, and GitHub, which will make continuous
    integration and continuous deployment easier. Azure Functions supports various
    types of event triggers, timer-based events for tasks, OneDrive, and SharePoint,
    which can be configured to trigger operations in functions. Real-time processing
    of data and files adds the ability to operate a serverless bot that uses Cortana
    as the information provider. Microsoft has introduced **Logic Apps**, a tool with
    a workflow-orchestration engine, which will allow less technical users to build
    serverless applications. Azure Functions allows triggers to be created in other
    Azure cloud services and HTTP requests. The maximum execution time is five minutes
    per function. Azure Functions provides two types of app service plan: **Dynamic**
    and **Classic**. **App Service** is a container or environment for a set of Azure
    functions to run in. The Dynamic option is similar to Lambda, where we pay for
    the time and memory our function uses to run. The Classic option is about allocating
    your own existing or provisioned app resources for the functions at no extra cost.
    The memory allotted is as per App Service, whereas in AWS Lambda, the memory allocation
    is per function. Azure Functions allows just 10 concurrent executions per function'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**Azure Functions** 是微软进入无服务器架构的一个尝试。它于 2016 年 3 月上线。Azure Functions 允许使用 C#、F#、PHP、Node.js、Python
    和 Java 编写函数。Azure Functions 还支持 bash、batch 和 PowerShell 文件。Azure Functions 与 **Visual
    Studio Team System** (**VSTS**)、Bitbucket 和 GitHub 无缝集成，这将使得持续集成和持续部署变得更加容易。Azure
    Functions 支持多种类型的事件触发器、基于时间的任务事件、OneDrive 和 SharePoint，可以配置为触发函数中的操作。实时处理数据和文件增加了操作无服务器机器人的能力，该机器人使用
    Cortana 提供信息。微软还推出了 **Logic Apps**，这是一种带有工作流编排引擎的工具，可以让技术不太熟练的用户构建无服务器应用。Azure
    Functions 允许在其他 Azure 云服务和 HTTP 请求中创建触发器。每个函数的最大执行时间为五分钟。Azure Functions 提供两种类型的应用服务计划：**动态**
    和 **经典**。**应用服务** 是一个容器或环境，用于运行一组 Azure 函数。动态选项类似于 Lambda，我们为函数运行时使用的时间和内存付费。经典选项是为函数分配您现有或预配置的应用资源，而无需额外费用。分配的内存按照应用服务进行，而在
    AWS Lambda 中，内存分配是按每个函数来计算的。Azure Functions 允许每个函数最多 10 个并发执行。'
- en: Azure Functions follows a similar pricing model to AWS Lambda. The total cost
    is based on number to triggers executed and time. So the first one million requests
    are free, and beyond that, it will cost $0.02 for every 100,000 executions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 的定价模型与 AWS Lambda 类似。总费用是基于触发器执行的次数和时间来计算的。因此，前一百万次请求是免费的，超过这一数量后，每执行
    100,000 次将收费 0.02 美元。
- en: We will be looking at automating the deployment of Azure Functions in [Chapter
    4](0428c3ad-f4cb-4096-bb47-f4c14dec3b1f.xhtml), *DevOps with Azure Functions,*
    and also at how different DevOps processes will fit in to give Azure Functions
    a faster time to market.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第 4 章](0428c3ad-f4cb-4096-bb47-f4c14dec3b1f.xhtml)中讨论自动化部署 Azure Functions，*DevOps
    与 Azure Functions*，并探讨不同的 DevOps 过程如何适应，以加速 Azure Functions 的市场发布速度。
- en: Google Functions
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Functions
- en: Google joined the party a little late compared to AWS Lambda and Azure Functions.
    They came onto the market with a beta version of Cloud Functions in March 2017\.
    Currently, we can write Google Functions through Node.js; they will be supporting
    other languages soon. They support internal event bus triggers and also HTTP triggers,
    which respond to events such as GitHub WebHooks, slack, or any HTTPS requests,
    and also mobile backend for events from Firebase analytics, a real-time database.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与 AWS Lambda 和 Azure Functions 相比，Google 进入这一领域稍晚一些。它们在 2017 年 3 月发布了 Cloud
    Functions 的 beta 版本。目前，我们可以通过 Node.js 编写 Google Functions；它们很快将支持其他语言。Google Functions
    支持内部事件总线触发器和 HTTP 触发器，响应诸如 GitHub WebHooks、Slack 或任何 HTTPS 请求等事件，还支持 Firebase
    分析、实时数据库等来自移动端的事件。
- en: In terms of scalability, there is in-built provision for autoscaling. Google
    Functions supports 1,000 functions per project and allows 400 executions per function,
    which is claimed to be a soft limit. Google Functions allows an execution time
    of 540 seconds (9 minutes). Deployment is supported through ZIP upload, cloud
    storage, and cloud store repositories. The event source is through cloud pub/sub
    or cloud storage objects. The logging of function executions is managed through
    Stackdriver logging, which is Google Cloud's logging tool.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在可扩展性方面，Google Functions 内置了自动扩展功能。Google Functions 支持每个项目最多 1,000 个函数，并允许每个函数执行
    400 次，据称这是一个软性限制。Google Functions 允许执行时间为 540 秒（9 分钟）。支持通过 ZIP 上传、云存储和云存储库进行部署。事件源通过云
    Pub/Sub 或云存储对象进行。函数执行的日志管理通过 Stackdriver logging 来实现，这是 Google Cloud 的日志工具。
- en: We will sail through Google Functions's DevOps approach in Chapter 5, *Integrating
    DevOps with IBM – OpenWhisk*, and will also look at the best practices around
    DevOps using Google Functions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第 5 章](0428c3ad-f4cb-4096-bb47-f4c14dec3b1f.xhtml)中深入探讨 Google Functions
    的 DevOps 方法，*将 DevOps 与 IBM – OpenWhisk 集成*，并讨论使用 Google Functions 的 DevOps 最佳实践。
- en: OpenWhisk
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenWhisk
- en: '**OpenWhisk** is an open source FaaS platform that can be deployed to the cloud
    or on an on-premise data center. It is driven by IBM, and they have open sourced
    using the Apache licence. We can sign up for OpenWhisk through **Bluemix** (Bluemix
    is IBM''s cloud platform) or we can set  it up locally through a vagrant. It works
    in a similar way to any FaaS technology, such as AWS Lambda , Azure Functions,
    or Google Functions. But OpenWhisk supports open events providers. So if we have
    a custom event provider, then we can incorporate it with OpenWhiz, because, unlike
    other cloud platforms, OpenWhiz allows events within its service.  One example
    would be that a function can be triggered through OpenWhiz upon the arrival of
    a new item appearance in an RSS feed. OpenWhiz will allow an organisation to set
    up their own FaaS platform within their premises if they are not happy to allow
    their data to go out of their organisation. The language support in OpenWhiz is
    Swift, along with JavaScript or Node.js. OpenWhiz has integrated Docker support
    for binary code execution within functions.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenWhisk** 是一个开源的 FaaS 平台，可以部署到云端或本地数据中心。它由 IBM 推动，并且通过 Apache 许可证进行了开源。我们可以通过
    **Bluemix**（Bluemix 是 IBM 的云平台）注册 OpenWhisk，或者通过 vagrant 在本地设置。它的工作方式与任何 FaaS
    技术类似，比如 AWS Lambda、Azure Functions 或 Google Functions。但 OpenWhisk 支持开放事件提供者。如果我们有自定义事件提供者，可以将其与
    OpenWhisk 集成，因为与其他云平台不同，OpenWhisk 允许其服务内的事件。例如，可以通过 OpenWhisk 在 RSS feed 中出现新条目时触发函数。OpenWhisk
    还允许组织在其内部设置自己的 FaaS 平台，如果他们不愿意让数据离开组织。OpenWhisk 支持的语言有 Swift、JavaScript 和 Node.js。OpenWhisk
    集成了 Docker 支持，用于函数内部二进制代码的执行。'
- en: Other serverless architectures
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他无服务器架构
- en: There are many other serverless options, such as OpenFaaS, Fission, and Iron.io.
    I won't cover them in this book, but let's scheme through the features. **OpenFaaS**
    is an open source alternative for serverless architecture. It is built over Docker
    containers, Swarm, and Kubernetes. It has its own UI portal and also has CLI support
    to deploy functions. OpenFaaS supports Node.js, Python, GO, and C# on Windows
    and Linux. We can set it up over a cloud, a local laptop, or an on-premise server.
    We can write functions for almost everything—that is what is claimed by OpenFaas.
    OpenFaaS is written in Golang. It allows events through HTTP/HTTPS requests.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他无服务器选项，如OpenFaaS、Fission和Iron.io。我在本书中不会详细讨论它们，但我们可以浏览它们的功能。**OpenFaaS**是无服务器架构的一个开源替代方案。它建立在Docker容器、Swarm和Kubernetes之上。它有自己的UI门户，还支持CLI来部署函数。OpenFaaS支持Node.js、Python、Go和C#，并且可以在Windows和Linux上运行。我们可以将它部署在云端、本地笔记本电脑或本地服务器上。我们几乎可以为所有事情编写函数——这是OpenFaaS的承诺。OpenFaaS是用Golang编写的。它允许通过HTTP/HTTPS请求来触发事件。
- en: '**Fission** is yet another open source version of serverless architecture—the
    underlying technology is Kubernetes and Docker containers, which can be deployed
    on both cloud and on-premise infrastructures. It is designed as a set of microservices,
    and its components are the controller, router, and pool manager. The router manages
    HTTP requests, the controller manages functions, event triggers, and environment
    images, and the pool manager manages the pool of containers and loads the functions
    into these containers. The functions are written with Python.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fission**是另一种开源的无服务器架构——其底层技术是Kubernetes和Docker容器，可以在云端和本地基础设施上部署。它被设计为一组微服务，其组件包括控制器、路由器和池管理器。路由器管理HTTP请求，控制器管理函数、事件触发器和环境镜像，池管理器管理容器池并将函数加载到这些容器中。函数是用Python编写的。'
- en: Serverless benefits
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器架构的好处
- en: There are a number of pros and cons of using serverless architecture. Let's
    look at the bright side first. Why would anyone build their application using
    a serverless architecture such as AWS Lambda or OpenWhiz? The main reason is how
    efficiently the application performs, how fast it will scale, and, most importantly,
    its cost. Let's look at a few important pros and then move on to the cons.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无服务器架构有很多优缺点。我们先来看看其中的亮点。为什么有人会选择使用AWS Lambda或OpenWhiz等无服务器架构来构建他们的应用？主要原因是应用的高效性、快速扩展的能力，以及最重要的，它的成本。让我们先来看几个重要的优点，然后再讨论缺点。
- en: Faster time to market
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更快的市场推出时间
- en: We can push the application to market much faster, as OPS becomes much simpler,
    and will help the developer to concentrate only on their development. The OPS
    team does not have to bother about writing code that could handle scaling or worry
    about the underlying infrastructure.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更快地将应用推向市场，因为OPS变得更加简化，这将帮助开发者专注于他们的开发工作。OPS团队无需再为编写可以处理扩展的代码或担心底层基础设施而烦恼。
- en: Also, teams can build the application much faster with the help of third-party
    integration, such as API services such as OAuth, Twitter, and Maps.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，团队可以借助第三方集成（如OAuth、Twitter和地图等API服务）更快地构建应用。
- en: Highly scalable
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高度可扩展
- en: Every company wants their application to perform better, have zero downtime,
    and scale quickly and easily with rising traffic, but with monolithic application
    development, it can become very difficult. The Ops team has to be vigilant in
    scaling the underlying infrastructure as the load on the application rises. A
    huge amount of time and money is wasted over downtime due to rises in traffic.
    But serverless computing is highly scalable, and the applications can be scaled
    and descaled within seconds.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 每个公司都希望他们的应用表现更好、实现零停机时间，并能够随着流量的增加快速而轻松地扩展，但对于单体应用开发来说，这可能变得非常困难。随着应用负载的增加，Ops团队必须时刻关注底层基础设施的扩展。由于流量激增而导致的停机时间浪费了大量的时间和资金。而无服务器计算具有高度可扩展性，应用可以在几秒钟内进行扩展和缩减。
- en: Low cost
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 低成本
- en: In serverless computing, developers are billed only for the time that the function
    is running, unlike IaaS and PaaS, which are billed 24/7 for each server. This
    is good for companies with a huge setup of apps, APIs, or microservices that are
    currently running 24/7 and using resources 100 percent of the time, whether they
    are required or not. But with serverless, instead of running the application 24/7,
    we can execute functions on demand and share the resources, so we can reduce the
    idle time substantially and still make the application run faster.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在无服务器计算中，开发人员仅为函数运行时计费，不像IaaS和PaaS那样对每个服务器进行24/7计费。这对那些拥有大量应用、API或微服务的公司来说非常有利，这些公司目前24小时全天候运行，并且始终使用资源，无论是否需要。但通过无服务器，我们可以根据需要执行函数并共享资源，从而减少空闲时间，并且仍然使应用运行得更快，而不是让应用全天候运行。
- en: Latency and geolocation improvement
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟和地理位置改善
- en: 'The scalability of the application depends on three factors: the number of
    users, the location of the users, and the latency of the network. In today''s
    world, applications have a global audience, which can add to latency. But the
    danger of latency can be highly mitigated with the serverless platform. With serverless, a
    container is instantiated to run a function at every event call, and this container
    can be created close to the user''s geographical region, which will automatically
    improve the performance of the app.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 应用的可扩展性取决于三个因素：用户数量、用户位置和网络延迟。在今天的世界里，应用拥有全球用户，这可能会增加延迟。但通过无服务器平台，这种延迟的风险可以得到有效缓解。使用无服务器时，每次事件调用时会实例化一个容器来运行一个函数，这个容器可以创建在离用户地理位置较近的地方，从而自动提高应用的性能。
- en: Serverless drawbacks
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器的缺点
- en: Although there are upsides to using serverless, there are also downsides. Let's
    look at the other side of the coin of the serverless function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用无服务器有好处，但也有缺点。让我们来看一下无服务器功能的另一面。
- en: Increased complexity
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂性增加
- en: The more granular we go with the application, the more complex it becomes. The
    code for each function might get simpler, but the application as a whole will
    get more complex. Say, for example, that we break the application into 10 different
    microservices. We would have to manage 10 different apps, whereas in a monolithic
    application, it is just one app that has to be managed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用中越细化，复杂性就越高。每个函数的代码可能会更简洁，但整个应用会变得更复杂。例如，假设我们将应用拆分成10个不同的微服务。我们需要管理10个不同的应用，而在单体应用中，只需管理一个应用。
- en: Lack of tooling
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具缺乏
- en: Let's say that we break our monolithic application into 50 different functions.
    There are still a variety of processes and tools to manage, log, monitor, and
    deploy the monolithic application. As serverless is pretty new in the market,
    monitoring or logging an application that runs for a few seconds is limited and
    challenging as of now, but over time, there will be many efficient ways to do
    this.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将单体应用拆分成50个不同的函数。我们仍然需要管理、记录、监控和部署这些单体应用，并且有多种过程和工具需要处理。由于无服务器技术在市场上还比较新，当前监控或记录一个只运行几秒钟的应用是有限且具有挑战性的，但随着时间的推移，会有许多高效的方式来解决这个问题。
- en: Complexity with architecture
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构的复杂性
- en: It is hard to make a decision as to how granular a function should be, and it
    is time consuming to assess, implement, and test to check our preferences. It
    would be cumbersome to manage too many functions, and at the same time, ignoring
    granularity would result in us setting up mini monoliths.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 很难决定函数应该有多细化，而且评估、实施和测试以检查我们的偏好是非常耗时的。管理过多的函数会变得繁琐，而忽视细化则会导致我们建立迷你单体应用。
- en: Drawback in implementation
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现中的缺点
- en: The biggest challenge with serverless is integration tests. We will write many
    functions for an application, but how would we integrate them to work as an application?
    Of course, before that, how do we test how efficiently they work together? As
    serverless is new and still maturing, the options that are added through testing
    are still limited. But we will be covering a few aspects of deployment and testing
    in future chapters.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无服务器的最大挑战是集成测试。我们将为一个应用编写许多函数，但如何将它们集成在一起作为一个应用运行呢？当然，在此之前，如何测试它们协同工作的效率呢？由于无服务器是新的且仍在成熟过程中，测试过程中添加的选项仍然有限。但在未来的章节中，我们将涵盖部署和测试的几个方面。
- en: DevOps with serverless
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器与DevOps
- en: '**DevOps** is another buzzword that has been around for quite a long time.
    Like serverless, DevOps is also a confusing term. Lots of people have lots of
    different perspectives on DevOps. Some say that DevOps is just tools, some feel
    that DevOps consists of a few processes—even IaaS and PaaS falls under the umbrella
    of DevOps. As per my understanding, DevOps is a collaboration of tools, processes,
    and feedback. They all go hand in hand for the successful implementation of DevOps.
    But why are we talking about DevOps here? In short, because we would need DevOps
    for a smooth transition to production, to log or monitor the serverless functions,
    and to test them before they reach users.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**DevOps**是另一个流行了很长时间的术语。像无服务器一样，DevOps也是一个令人困惑的术语。许多人对DevOps有不同的看法。有些人认为DevOps只是工具，有些人认为DevOps由几个过程组成——甚至IaaS和PaaS也属于DevOps的范畴。根据我的理解，DevOps是工具、过程和反馈的协作，它们共同推动DevOps的成功实施。但是，为什么我们要在这里谈论DevOps呢？简而言之，因为我们需要DevOps来顺利过渡到生产环境，记录或监控无服务器函数，并在它们到达用户之前进行测试。'
- en: With DevOps functional prospective, I will be covering version control, continuous
    integration, continuous deployment, monitoring, and logging for AWS Lambda functions,
    Azure Functions, Google Functions, and OpenWhiz. Version control is a process
    where we version the code so that we can branch it, package it, deploy it, and
    also roll back to a previous version. Continuous integration is the practice where
    code is integrated together by developers with automated builds to detect and
    mitigate problems early on. Continuous deployment is basically a bus or pipeline
    where code is continuously refined using automated testing, and is then deployed
    to the environment. This pipeline moves smoothly towards production, with minimal
    manual intervention.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从DevOps的功能角度来看，我将涵盖版本控制、持续集成、持续部署、监控和日志记录，适用于AWS Lambda函数、Azure Functions、Google
    Functions和OpenWhiz。版本控制是一个管理代码版本的过程，使我们能够进行分支、打包、部署，同时也能回滚到先前的版本。持续集成是开发人员通过自动化构建将代码集成在一起，以便及早发现和解决问题的做法。持续部署本质上是一个管道，代码通过自动化测试不断精炼，然后被部署到环境中。这个管道平稳地向生产环境推进，手动干预最小化。
- en: Summary
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We will evaluate a few serverless frameworks in the next chapter, and then use
    one of them through the book with various DevOps implementation tutorials. In
    most of these DevOps implementations, we will be using the more popular DevOps
    tools, such as Jenkins, which is used for orchestrating, and GitHub, which is
    used for versioning. We will also cover automated units, integration, and system
    testing. We will also look at the adoption of monitoring and logging best practices,
    as well as many more DevOps processes and features.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章评估几种无服务器框架，并在本书中通过各种DevOps实施教程使用其中一个。在这些DevOps实施中，我们将使用一些更流行的DevOps工具，比如用于协调的Jenkins和用于版本管理的GitHub。我们还将涉及自动化单元测试、集成测试和系统测试。我们还将关注监控和日志记录的最佳实践，以及更多DevOps过程和特性。
