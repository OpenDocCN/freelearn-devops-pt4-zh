- en: Understanding Serverless Frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解无服务器框架
- en: In the previous chapter, we looked into the world of serverless computing, how
    it works, what the purpose of it is, the benefits of adopting it, the different
    service providers, and how they fare in terms of the services they offer. We also
    learned about the pros and cons of adopting a serverless architecture. The goal
    of this chapter is to teach us different serverless deployment frameworks, and
    how they will eventually help us to achieve continuous integration and continuous
    delivery. Furthermore, we will also look at the various features provided by the
    frameworks and talk in more detail about the serverless framework, learning what
    it does under the hood.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了无服务器计算的世界，它是如何工作的，目的是什么，采用它的好处，各种服务提供商以及它们在提供服务方面的表现。我们还了解了采用无服务器架构的优缺点。本章的目标是教会我们不同的无服务器部署框架，以及它们最终如何帮助我们实现持续集成和持续交付。此外，我们还将了解框架提供的各种功能，并更详细地讨论无服务器框架，了解它在幕后做了什么。
- en: In the world of application development, the process of developing an application
    is usually the same. The developer develops the code on their local machine, and
    compiles and pushes the changes to the source code management repository. The
    tester then tests and publishes reports, and the ops team plays the role of deploying
    the code into various different environments and manages the infrastructure.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用开发的世界里，开发应用的过程通常是相同的。开发者在本地机器上开发代码，然后将更改编译并推送到源代码管理仓库。测试人员随后测试并发布报告，而运维团队则负责将代码部署到不同的环境中并管理基础设施。
- en: 'But there is a chance that the same code will fail on production. Now, to get
    this code working again, the developer, tester, and operations teams have to work
    overtime to get the production live again. During root-cause analysis, the developer
    will say that his code works fine on his PC, the tester will claim that she has
    tested everything and will provide reports supporting this fact, and the operations
    guy will say that his job is just to deploy the code. So the challenges we have
    here are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但有可能相同的代码在生产环境中会失败。为了让这段代码重新工作，开发者、测试人员和运维团队必须加班才能使生产环境恢复正常。在根本原因分析中，开发者会说他的代码在个人电脑上运行正常，测试人员会声称她已经测试了所有内容并提供支持这一事实的报告，而运维人员则会说他的工作只是部署代码。因此，我们面临的挑战如下：
- en: Make the code run perfectly on production every time it is deployed
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保每次部署时代码都能在生产环境中完美运行
- en: Speed up the deployment cycle
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速部署周期
- en: Make the team work together and own their responsibility
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让团队一起合作，承担各自的责任
- en: Have tensionless production deployment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现无摩擦的生产部署
- en: The solution to all these problems is adopting DevOps, automating both the process
    and team collaboration.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些问题的方法是采用DevOps，自动化流程和团队协作。
- en: '"DevOps is a set of practices that automate the processes between the software
    development and IT teams, so that they can build, test, and release software faster
    and more reliably."'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '"DevOps是一套自动化软件开发和IT团队之间流程的实践，以便他们能够更快、更可靠地构建、测试和发布软件。"'
- en: -Definition of DevOps on Atlassian
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '- 在Atlassian上的DevOps定义'
- en: DevOps rides on the wheels of tools, people, processes, and feedback loops.
    But tools and processes are the front wheel of DevOps, and play a very important
    role in driving faster release cycles on non-production and production environments,
    and in continuous integration, continuous testing, and continuous deployment.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps依赖于工具、人员、流程和反馈循环的结合。但工具和流程是DevOps的前轮，在非生产和生产环境中推动更快的发布周期、持续集成、持续测试和持续部署方面发挥着至关重要的作用。
- en: Using serverless architecture to implement DevOps is much easier, as we do not
    have to worry about the underlying infrastructure. However, we still need continuous
    integration, monitoring, logging, and continuous deployment for smoother-sailing
    code to production. As serverless is still in its infancy,  there are quite a
    few newly developed tools and frameworks that are available, but these numbers
    will eventually grow. We will be looking at the more popular tools or frameworks,
    and finally focus on one framework, looking at it in detail and learning about
    the features that it offers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无服务器架构来实现DevOps要容易得多，因为我们不必担心底层基础设施。然而，我们仍然需要持续集成、监控、日志记录以及持续部署，以便代码顺利推向生产环境。由于无服务器架构仍处于初期阶段，现有的一些新开发工具和框架数量有限，但这些数量最终会增长。我们将关注更流行的工具或框架，最后集中讨论一个框架，深入了解其功能。
- en: All the tools that we will be looking at in this book are open source frameworks.
    They each serve a particular function on an as-per-need basis. We will consider
    four popular serverless frameworks and look at what they have to offer.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们将要探讨的所有工具都是开源框架。它们各自根据需求提供特定功能。我们将考虑四个流行的无服务器框架，并了解它们的特点。
- en: ClaudiaJS
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ClaudiaJS
- en: '**ClaudiaJS** is one of the earliest of the deployment frameworks and tools.
    It is licensed under open source, and, at the time writing, it only supports AWS
    Lambda. ClaudiaJS is a Node.js library that helps to deploy Node.js projects on
    to AWS Lambda and API Gateway. It currently supports just the Node.js language.
    ClaudiaJS claims that it is not a framework, but a deployment tool, so the developer
    just calls it ClaudiaJS within their code and does not have to change their code
    structure. ClaudiaJS is built on top of AWS SDK and AWS CLI. It flags three types
    of JavaScript libraries:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**ClaudiaJS**是最早的部署框架和工具之一。它是开源许可证下的，且在撰写本文时，仅支持AWS Lambda。ClaudiaJS是一个Node.js库，帮助将Node.js项目部署到AWS
    Lambda和API Gateway。它目前仅支持Node.js语言。ClaudiaJS声明它不是一个框架，而是一个部署工具，因此开发者只需在代码中调用ClaudiaJS，而无需改变代码结构。ClaudiaJS建立在AWS
    SDK和AWS CLI之上。它标识了三种类型的JavaScript库：'
- en: Command-line library
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行库
- en: API builder library
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API构建库
- en: Bot builder library
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bot 构建库
- en: Command-line library
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行库
- en: 'The first JavaScript library is a command-line tool or library. The command-line
    tool helps to deploy, update, roll back, package, invoke or test, and destroy
    Lambda functions, and it also works seamlessly with AWS API Gateway. It uses the
    standard npm packaging conventions, which just means that you can call it without
    making changes to your actual code structure. So the really interesting features
    with ClaudiaJs''s command-line library are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个JavaScript库是一个命令行工具或库。该命令行工具帮助部署、更新、回滚、打包、调用或测试以及销毁Lambda函数，它还与AWS API Gateway无缝集成。它使用标准的npm打包惯例，这意味着你可以在不修改代码结构的情况下直接调用它。所以，ClaudiaJS的命令行库提供的有趣功能如下：
- en: '`claudia create `: This command will create a function and a related security
    role on the AWS portal'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`claudia create `: 这个命令将在AWS门户上创建一个函数和相关的安全角色。'
- en: '`claudia update `: This command will update the function by deploying a new
    version of the function and update the associated API'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`claudia update `: 这个命令将通过部署新版本的函数来更新功能，并更新相关的API。'
- en: '`claudia test-lambda`: This command will execute the Lambda function'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`claudia test-lambda`: 这个命令将执行Lambda函数。'
- en: '`claudia set-version`: This command will point the Lambda API stage to the
    latest deployment version'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`claudia set-version`: 这个命令将把Lambda API阶段指向最新的部署版本。'
- en: '`claudia add-scheduled-event`: This command can add the scheduled recurring
    events for the Lambda function to run, so through this, we can keep the Lambda
    function warm'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`claudia add-scheduled-event`: 这个命令可以为Lambda函数添加定期执行的计划事件，通过这个命令，我们可以保持Lambda函数处于“热”状态。'
- en: '`claudia destroy`: This command will destroy the function and associated API
    and security roles'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`claudia destroy`: 这个命令将销毁函数及其相关的API和安全角色。'
- en: API builder library
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API构建库
- en: The second type of library is the API builder library. It is the extension of
    the ClaudiaJS library, and it helps in setting up the AWS API Gateway endpoint.
    It also helps to route multiple API gateways to a single Lambda function. It automatically
    enables the CORS for the endpoints.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种类型的库是API构建库。它是ClaudiaJS库的扩展，帮助设置AWS API Gateway端点。它还帮助将多个API网关路由到单一的Lambda函数，并自动为这些端点启用CORS。
- en: Bot builder library
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bot 构建库
- en: This library is one of the most interesting libraries provided by ClaudiaJS.
    This library helps to create different types of bots within minutes. It has out-of-the-box
    features to integrate with Facebook Messenger, Telegram, and Skype. It is pretty
    easy to set up a bot using ClaudiaJS bot libraries.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库是ClaudiaJS提供的最有趣的库之一。这个库可以帮助在几分钟内创建不同类型的机器人。它提供开箱即用的功能，能够与Facebook Messenger、Telegram和Skype集成。使用ClaudiaJS的机器人库，设置一个机器人相当简单。
- en: To summarize, ClaudiaJS is great tool when using the AWS Cloud provider. It
    also supports Node.js. The documentation link provided in the following information
    box is up to date; the documentation explains each and every CLI command very
    well. There are lots of tutorials available, ranging from simple development to
    advanced tasks. The bot libraries are one of the best things that ClaudiaJS can
    provide. However, there is no support for multiple serverless providers, nor for
    multiple languages.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，ClaudiaJS在使用AWS云服务提供商时非常好用。它也支持Node.js。以下信息框中提供的文档链接是最新的，文档详细解释了每一个CLI命令。提供了很多教程，涵盖从简单开发到高级任务。机器人库是ClaudiaJS提供的最棒的功能之一。然而，它不支持多个无服务器提供商，也不支持多语言。
- en: 'More information on Claudia.JS can found at the following link:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于Claudia.JS的信息可以在以下链接找到：
- en: '[https://claudiajs.com](https://claudiajs.com)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://claudiajs.com](https://claudiajs.com)'
- en: Apex
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apex
- en: '**Apex** is yet another serverless framework that is built on the Go to manage
    AWS Lambda functions. It is an open source framework and uses Terraform for bootstrapping
    the resources, which makes it faster to execute. The features provided by the
    frameworks are the ability to deploy, test functions, roll back deployment, view
    metrics, and tail logs.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**Apex**是另一个基于Go构建的无服务器框架，用于管理AWS Lambda函数。它是一个开源框架，使用Terraform来启动资源，使得执行速度更快。该框架提供的功能包括部署、测试函数、回滚部署、查看指标和跟踪日志。'
- en: Although it does not support invoking the function locally, it does support
    multiple languages, such as Node.js, Python, Java, Rust, and Go. We can create
    various environments through Apex. It has good documentation and helps you to
    quickly get started with using the frameworks. However, Apex currently only supports
    AWS Lambda.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它不支持本地调用函数，但它支持多种语言，如Node.js、Python、Java、Rust和Go。我们可以通过Apex创建各种环境。它有很好的文档，帮助你快速上手使用该框架。然而，Apex目前只支持AWS
    Lambda。
- en: 'More information on Apex can be found at the following link:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于Apex的信息可以在以下链接找到：
- en: '[http://apex.run/#function-hooks](http://apex.run/#function-hooks)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://apex.run/#function-hooks](http://apex.run/#function-hooks)'
- en: Zappa
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zappa
- en: If you decide to write your functions in Python, then you can use Zappa to deploy
    them. **Zappa** is a CLI/command-line framework, and it is open source. Zappa
    currently supports Python WSGI applications, which are basically Flask and Django
    applications. It can deploy macro and micro applications. Zappa has a wide variety
    of features, such as the ability to deploy functions like API to AWS lambda and
    AWS API Gateway respectively. It can also configure AWS events sources.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定用Python编写函数，那么你可以使用Zappa来部署它们。**Zappa**是一个CLI/命令行框架，并且是开源的。Zappa目前支持Python
    WSGI应用，基本上是Flask和Django应用。它可以部署宏应用和微应用。Zappa拥有各种功能，如能够将API等函数部署到AWS Lambda和AWS
    API Gateway。它还可以配置AWS事件源。
- en: Once deployed, we can also invoke the function through Zappa. It can fetch or
    tail the logs from the AWS. It also allows rollback to the previous version. We
    can set up multistage deployment (by **stage**, it means multiple environment
    deployments, such as `dev`, `qa`, `uat`, and `prod`).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦部署，我们还可以通过Zappa调用函数。它可以从AWS获取或跟踪日志。它还支持回滚到之前的版本。我们可以设置多阶段部署（通过**stage**，指的是多个环境部署，如`dev`、`qa`、`uat`和`prod`）。
- en: 'Zappa also has the cool feature of being able to keep the Lambda function warm.
    This makes for better performance and decreases latency, to an extent. It allows
    us to schedule deployment, which means that we can set up deployment earlier on
    in the day so that it does not interfere with regular traffic. It has the ability
    to undeploy the purging of logs from the CloudWatch. We can also use it to package
    the Lambda functions for future deployment. Post deployment status can also be
    checked through Zappa. Zappa allows us to deploy the Lambda function to any region
    in AWS. Let''s look at a few of Zappa''s features:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Zappa 还具有一个很酷的功能，可以保持 Lambda 函数常驻。这可以提高性能并在一定程度上减少延迟。它允许我们安排部署，这意味着我们可以在一天的早些时候设置部署，以免干扰常规流量。它还具备撤销部署和从
    CloudWatch 清除日志的能力。我们还可以使用它打包 Lambda 函数以供未来部署。部署后的状态也可以通过 Zappa 进行检查。Zappa 允许我们将
    Lambda 函数部署到 AWS 的任何区域。我们来看看 Zappa 的一些功能：
- en: '**Installation of Zappa:** To install Zappa, you need to make sure that you
    have Python 2.7 or older, and that you have PIP installed and configured on your
    local machine or laptop. You also need to make sure that your AWS credentials
    are set up ([https://aws.amazon.com/blogs/security/a-new-and-standardized-way-to-manage-credentials-in-the-aws-sdks/](https://aws.amazon.com/blogs/security/a-new-and-standardized-way-to-manage-credentials-in-the-aws-sdks/)). We
    need Python and pip to install Zappa on the local environment:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装 Zappa：** 要安装 Zappa，你需要确保你本地的 Python 版本为 2.7 或更低，并且已经安装和配置了 PIP。你还需要确保你的
    AWS 凭证已设置好（[https://aws.amazon.com/blogs/security/a-new-and-standardized-way-to-manage-credentials-in-the-aws-sdks/](https://aws.amazon.com/blogs/security/a-new-and-standardized-way-to-manage-credentials-in-the-aws-sdks/)）。我们需要
    Python 和 pip 来在本地环境中安装 Zappa：'
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Zappa init:** The `init` code phrase will set up deployment settings. It
    should automatically detect the Flask/Django application and it will create a
    JSON file named `zappa_settings.json` within the project directory:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Zappa init：** `init` 命令将设置部署配置。它应该会自动检测到 Flask/Django 应用，并在项目目录中创建一个名为 `zappa_settings.json`
    的 JSON 文件：'
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Packaging and deployment:** Once the settings are configured, we can package
    and deploy the application using the following command. By default, it uses the
    production stage, but we can create multiple different stages:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打包和部署：** 一旦设置好配置，我们可以使用以下命令打包和部署应用程序。默认情况下，它使用生产环境，但我们可以创建多个不同的环境：'
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Zappa is an awesome framework, but there are a few cons about it, such as the
    fact that it does not support other cloud providers, such as Azure, Google, and
    OpenWhisk. It only supports Python-WSGI-based applications and no other languages,
    such as Node.js.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Zappa 是一个很棒的框架，但它也有一些缺点，比如不支持其他云服务提供商，如 Azure、Google 和 OpenWhisk。它仅支持基于 Python-WSGI
    的应用程序，不支持其他语言，如 Node.js。
- en: 'You can find more information about the Zappa framework at the following link:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接找到更多关于 Zappa 框架的信息：
- en: '[https://www.zappa.io/](https://www.zappa.io/)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.zappa.io/](https://www.zappa.io/)'
- en: Serverless Framework
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Serverless Framework
- en: '**Serverless Framework** is one of the most popular frameworks for building
    serverless architectures. It is an open source CLI, with about 23,000 stars on
    GitHub. There is also an enterprise edition that helps in setting up templates
    and providing support. This framework has been used by many companies, such as
    EA, Coca Cola, Expedia, and Reuters. It is a framework that supports lots of cloud
    service providers, such as AWS, Azure, Google, OpenWhisk, Kubeless, Oracle Fn,
    and many others. It has a very well-documented user guide containing quite a large
    number of examples to help you start using it. It supports lots of languages,
    such as Node.js, Python, Java, Scala, C#, Go, F#, Groovy, Kotlin, PHP, and Swift.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**Serverless Framework** 是构建无服务器架构最受欢迎的框架之一。它是一个开源命令行工具，在 GitHub 上大约有 23,000
    个 stars。它还有一个企业版，帮助设置模板并提供支持。许多公司，如 EA、可口可乐、Expedia 和路透社，都在使用这个框架。它支持很多云服务提供商，如
    AWS、Azure、Google、OpenWhisk、Kubeless、Oracle Fn 等。它有一个文档非常完善的用户指南，包含大量示例，帮助你快速上手。它支持多种语言，如
    Node.js、Python、Java、Scala、C#、Go、F#、Groovy、Kotlin、PHP 和 Swift。'
- en: It supports the life cycle of serverless architecture, which can build, deploy,
    update, and delete. It supports function grouping for easy management of code,
    processes, and resources across large projects, and also provides fairly good
    support for CD/CI. It has far better community support compared to other frameworks.
    It provides lots of plugins to support framework functionality. There are a lot
    of blogs to help us build the best practices in using the framework. It has a
    support forum and slack rooms for resolving issues and problems. It supports lots
    of features, such as deploying functions and events, invoking functions, tailing
    logs, integration testing, and packaging for future deployment. Let's take a closer
    look at the features of Serverless Framework.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 它支持无服务器架构的生命周期，可以进行构建、部署、更新和删除。它支持功能分组，便于在大型项目中管理代码、流程和资源，并且对CD/CI提供了相当好的支持。与其他框架相比，它拥有更强大的社区支持。它提供了大量插件来支持框架功能，并且有很多博客可以帮助我们建立使用框架的最佳实践。它还提供了支持论坛和Slack聊天室来解决问题。它支持很多功能，如部署函数和事件、调用函数、跟踪日志、集成测试以及为将来部署进行打包。让我们更详细地了解一下Serverless
    Framework的功能。
- en: Framework features
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架功能
- en: There are many features available in Serverless Framework, although they vary
    with the cloud provider. I will list and describe a few of the more important
    and more common ones.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Serverless Framework中有许多功能，尽管它们会因云提供商而异。我将列出并描述一些更重要和更常见的功能。
- en: Services and deployment
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务和部署
- en: 'A service is a project where we define the functions, the events that trigger
    them, and any infrastructure resources that are required for the function to perform.
    They are collected together into one file, which is called `serverless.yml`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是我们定义函数、触发这些函数的事件，以及为函数执行所需的任何基础设施资源的项目。它们被收集到一个文件中，这个文件叫做`serverless.yml`：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When we start using Serverless Framework for deployment, we will be using one
    single service. But as the application grows, it is recommended that you have
    multiple services as shown in the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始使用Serverless Framework进行部署时，我们将使用一个单一的服务。但随着应用的增长，建议您使用多个服务，如以下代码所示：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Having multiple services can isolate the infrastructure resources that are to
    be used. But it also has a drawback, as currently each service creates a separate
    REST API on API Gateway. This is a limitation with API Gateway. But there is a
    workaround to resolve this, which we will look into in future chapters.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有多个服务可以隔离要使用的基础设施资源。但它也有一个缺点，即目前每个服务都会在API Gateway上创建一个独立的REST API。这是API Gateway的一个限制。但有一个解决方法，我们将在未来的章节中讨论。
- en: 'To create the service, we have to use the `create` command, and we must pass
    the runtime language in which you would like to write the service. We can also
    provide the path, as shown in the following example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建服务，我们必须使用`create`命令，并且必须传递您希望编写服务的运行时语言。我们还可以提供路径，如下例所示：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The main purpose of Serverless Framework is to deploy functions, events, and
    infrastructure resources into the remote cloud without much hassle, and that is
    done through the `deploy` plugin. There are various features that this `deploy`
    plugin provides. Let us look at a few of them:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Serverless Framework的主要目的是将函数、事件和基础设施资源部署到远程云端，且无需太多麻烦，这是通过`deploy`插件完成的。这个`deploy`插件提供了各种功能。让我们来看其中的一些：
- en: '**Deploy to different stages and regions:**'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署到不同的阶段和区域：**'
- en: '`$ serverless deploy --stage production --region us-east-1`'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$ serverless deploy --stage production --region us-east-1`'
- en: '**Deploying single function from the service:**'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从服务中部署单个函数：**'
- en: '`$ serverless deploy function <function_name> `'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$ serverless deploy function <function_name>`'
- en: '**Deploying package to cloud:**'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署包到云端：**'
- en: '`$ serverless deploy --package <path to package>`'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$ serverless deploy --package <path to package>`'
- en: 'This `deploy` plugin works in the following ways:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`deploy`插件的工作方式如下：
- en: The framework packages up the targeted AWS Lambda function into a `.zip` file
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架将目标AWS Lambda函数打包成`.zip`文件
- en: The framework fetches the hash of the already uploaded function `.zip` file
    and compares it to the local `.zip` file hash
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架获取已上传的函数`.zip`文件的哈希值，并将其与本地`.zip`文件的哈希值进行比较
- en: The framework terminates if both hashes are the same
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个哈希值相同，框架将终止
- en: That .zip file is uploaded to your S3 bucket using the same name as the previous
    function, which is the CloudFormation stack it is pointing to
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该`.zip`文件使用与之前函数相同的名称上传到您的S3存储桶，这就是它指向的CloudFormation堆栈
- en: Functions and events
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数和事件
- en: 'Functions are the properties that are defined within the service, and they
    are defined within the `serverless.yml`, so we name the function and provide the
    handler property to the function, and this property points to the function file,
    which could be Node.js or Python. We can add multiple functions within the property.
    The functions can inherit the properties from the provider or we can define the
    properties at function level. These function properties vary as per the cloud
    provider, as shown in the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是定义在服务中的属性，它们在 `serverless.yml` 文件中定义，因此我们为函数命名并提供 handler 属性，指向函数文件，该文件可以是
    Node.js 或 Python。我们可以在该属性中添加多个函数。函数可以继承提供者的属性，也可以在函数级别定义属性。这些函数属性会根据云提供商的不同而有所变化，如以下代码所示：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The functions can be listed as arrays if we create a separate file for each
    function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为每个函数创建一个单独的文件，可以将函数列为数组：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'An environment object property can also be added to the function within the
    service, and it should be a key–pair value. Also, the function-specific environment
    variable overrides the provider-specific environment variable:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在服务中的函数内添加环境对象属性，且它应该是键值对。同时，函数特定的环境变量会覆盖提供者特定的环境变量：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Events are things that trigger the function, such as the S3 bucket upload.
    There are multiple events supported by Serverless Framework, but they vary as
    per the cloud provider. We can define multiple events for a single function, as
    shown in the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是触发函数的操作，例如 S3 存储桶上传。Serverless 框架支持多种事件，但它们根据云提供商不同而有所变化。我们可以为单个函数定义多个事件，如以下代码所示：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The types of events provided for AWS Lambda by Serverless Framework are shown
    at the following link:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Serverless 框架为 AWS Lambda 提供的事件类型如下链接所示：
- en: '[https://serverless.com/framework/docs/providers/aws/events/](https://serverless.com/framework/docs/providers/aws/events/)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://serverless.com/framework/docs/providers/aws/events/](https://serverless.com/framework/docs/providers/aws/events/)'
- en: Variables and plugins
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量与插件
- en: '**Variables** are the values that can be passed to the configuration values
    within the `serverless.yml` while running the Serverless Framework command. They
    need to pass reference values enclosed in `${}` brackets, but you can use variables
    in property values rather than in the property keys. The following code shows
    how this is added in the `serverless.yml` file:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量**是在运行 Serverless 框架命令时，可以传递给 `serverless.yml` 配置值的值。它们需要通过 `${}` 括号传递引用值，但你可以在属性值中使用变量，而不是在属性键中。以下代码展示了如何在
    `serverless.yml` 文件中添加这些变量：'
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the following statement, we pass the parameter to the CLI and the `stage`
    value is populated in the `serverless.yml` file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下语句中，我们将参数传递给 CLI，`stage` 值将被填充到 `serverless.yml` 文件中：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The variables can be used recursively as reference properties—that is, we can
    combine multiple values and variable sources, as shown in the following environment
    variable:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以作为引用属性递归使用——也就是说，我们可以将多个值和变量来源结合起来，如以下环境变量所示：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can reference environment variables as well (as shown in the following code),
    but it is insecure to add sensitive data to environment variables, because they
    can be accessed through build logs or in the serverless CloudFormation templates:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以引用环境变量（如以下代码所示），但是将敏感数据添加到环境变量中是不安全的，因为它们可能会通过构建日志或 Serverless CloudFormation
    模板被访问：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s look at a few tutorials for doing this. Make sure that you have the
    latest Serverless Framework installed and working:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看看几个实现这一点的教程。确保你已安装并正常运行最新版本的 Serverless 框架：
- en: 'Create a simple `hello` project with the Serverless AWS template, then open
    this project in your favorite editor:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Serverless AWS 模板创建一个简单的 `hello` 项目，然后在你喜欢的编辑器中打开该项目：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Replace the `serverless.yml` file and handler, as shown in the following code.
    Here, we are adding an environment variable by the name of `MY_VAR`, and in the
    handler, we display the environment variable in the message output:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换 `serverless.yml` 文件和 handler，如以下代码所示。在这里，我们通过 `MY_VAR` 的环境变量名添加一个环境变量，并在
    handler 中显示该环境变量的值：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s invoke locally and look at the result. If you look in the message section,
    you can see the value of the environment variable that we defined, as shown in
    the following code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在本地调用并查看结果。如果你查看消息部分，你可以看到我们定义的环境变量的值，如以下代码所示：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we discussed earlier for nonsensitive data, adding a variable into the `serverless.yml`
    file should be fine, but how do we add sensitive data into an environment variable,
    like a database connection. Let''s look into the steps needed to do this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，对于非敏感数据，将变量添加到`serverless.yml`文件应该没问题，但我们如何将敏感数据（如数据库连接）添加到环境变量中呢？让我们看看实现这一目标所需的步骤：
- en: 'Create a new file in the `env-variable-service` folder and name it **`serverless.env.yml`**.
    Then add the following details into it, as shown in the following code. Here,
    we are creating a secret variable as per the environment:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`env-variable-service`文件夹中创建一个新文件，命名为**`serverless.env.yml`**。然后按照以下代码的示例添加相应的内容。在这里，我们根据环境创建一个密钥变量：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s add one more environment variable in the `serverless.yml` file, but
    this time the value will be pulled from the file, so you need to add the highlighted
    line as the environment variable. This way, Serverless Framework will read through
    the file and refer it to the specific environment:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`serverless.yml`文件中再添加一个环境变量，但这次它的值将从文件中获取，因此你需要添加高亮显示的那一行作为环境变量。这样，Serverless
    Framework将读取文件并将其引用到特定的环境中：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s change the response of the handler to display the secret through the
    message. Ideally, we should be displaying the secret over the screen, but for
    this tutorial, I am doing it manually.  So let''s replace the message body with
    the one displayed in the following code:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更改处理程序的响应，通过消息显示密钥。理想情况下，我们应该在屏幕上显示密钥，但为了本教程，我将手动进行。所以让我们将消息体替换为以下代码中显示的内容：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Invoke the function locally and look at the output:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地调用函数并查看输出：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, like I said, we can have multiple environment variables for each deployment
    stage, such as `dev`, `sit`,`uat`, and `prod`. The following steps show us how
    we can add them:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如我之前所说，我们可以为每个部署阶段设置多个环境变量，如`dev`、`sit`、`uat`和`prod`。以下步骤展示了如何添加这些环境变量：
- en: 'Let''s add one more environment variable for `prod` to the `serverless.env.yml` file.
    Then, we can use them dynamically within the `serverless.yml` file, as shown in
    the following code:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为`prod`添加一个环境变量到`serverless.env.yml`文件中。然后，我们可以在`serverless.yml`文件中动态使用它们，如下所示：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we need to makes changes to the `serverless.yml` file to dynamically pick
    up the environment variable on the basis of the stage that we set at the time
    of the invocation or deployment of the function, which is the replacement of the
    `MYSECRET_VAR` line with the following line:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要对`serverless.yml`文件进行修改，动态地根据调用或部署函数时设置的阶段来获取环境变量，这就是将`MYSECRET_VAR`行替换为以下行：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will now invoke the function locally and look at the output for a different
    stage:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将本地调用该函数，并查看不同阶段的输出：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'I have uploaded the preceding tutorials into the following GitHub repository
    as well, so you can use them at your leisure:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将前面的教程上传到以下 GitHub 仓库，你可以随时使用：
- en: '[https://github.com/shzshi/env-variable-service.git](https://github.com/shzshi/env-variable-service.git)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/shzshi/env-variable-service.git](https://github.com/shzshi/env-variable-service.git)'
- en: 'The plugins are custom JavaScript code that provide extension to existing CLI
    commands within Serverless Framework. The framework itself is a group of plugins
    that is provided in the core. We can build our own custom plugin; Serverless Framework
    provides documentation for this plugin as well. The plugin can be installed using
    the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 插件是提供扩展现有 Serverless Framework CLI 命令的自定义 JavaScript 代码。框架本身就是一组核心提供的插件。我们可以构建自己的自定义插件，Serverless
    Framework 也提供了该插件的文档。可以使用以下代码安装插件：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We also need to call them within the `serverless` service, using the following
    code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`serverless`服务中调用它们，使用以下代码：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A list of existing Serverless plugins can be found at the following link:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下链接查看现有的 Serverless 插件列表：
- en: '[https://github.com/serverless/plugins](https://github.com/serverless/plugins)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/serverless/plugins](https://github.com/serverless/plugins)'
- en: Resources
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源
- en: 'When we create Lambda functions, they might be dependent on many different
    types of infrastructure resources, such as AWS, DynamoDB or AWS S3, so we can
    define these resources within the `serverless.yml` file and deploy them. When
    we add these resources, they get added to the `serverless.yml` file, and when
    they are deployed, they get added to the CloudFormation stack and are executed
    at serverless deploy.We can look at the following example to see how these resources
    are defined:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 Lambda 函数时，它们可能依赖于多种不同类型的基础设施资源，如 AWS、DynamoDB 或 AWS S3，因此我们可以在 `serverless.yml`
    文件中定义这些资源并进行部署。当我们添加这些资源时，它们将被添加到 `serverless.yml` 文件中，并且在部署时，它们会被添加到 CloudFormation
    堆栈中并在 `serverless deploy` 时执行。我们可以通过以下示例查看这些资源是如何定义的：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can refer to the following link for more details on resources and to see
    which resources are available using only AWS Lambda: [https://serverless.com/framework/docs/providers/aws/guide/resources/](https://serverless.com/framework/docs/providers/aws/guide/resources/)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下链接，了解更多资源详情，并查看仅使用 AWS Lambda 时可用的资源：[https://serverless.com/framework/docs/providers/aws/guide/resources/](https://serverless.com/framework/docs/providers/aws/guide/resources/)
- en: Let's look at a simple example of Serverless Framework using AWS Lambda.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用 AWS Lambda 的 Serverless Framework 简单示例。
- en: 'You will need the following prerequisites for this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要以下先决条件：
- en: A free AWS account needs to be created
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要创建一个免费的 AWS 账户。
- en: Nodejs 4.0 and higher must be installed on the local machine
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地机器上必须安装 Node.js 4.0 或更高版本。
- en: AWS CLI can also be installed, but this is optional
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CLI 也可以安装，但这是可选的。
- en: Setting up AWS access keys
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 AWS 访问密钥。
- en: 'Go through the following steps:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照以下步骤操作：
- en: Log in to the AWS account and go to the IAM (Identity & Access Management) page.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到 AWS 账户并进入 IAM（身份与访问管理）页面。
- en: Click on Users on the left-hand side bar, then click on the Add User button and
    add the username `adm-serverless`. Then enable programmatic accessby clicking
    the checkbox. Then click on the Next:Premissionsbutton.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧栏的用户（Users），然后点击“添加用户”按钮并添加用户名 `adm-serverless`。接着启用编程访问（programmatic access），勾选复选框。然后点击下一步：权限按钮（Next:Permissions）。
- en: On this page, select Attach existing policies directly, search for and select
    the AdministratorAccess checkbox, then click on Next:Review.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此页面上，选择直接附加现有策略，搜索并选择 AdministratorAccess 复选框，然后点击下一步：审核。
- en: Now check whether everything is good, then click Create User. This will create
    a user and show us the access key IDand secret access key. Copy and store these
    keys somewhere, temporarily.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在检查一切是否正常，然后点击“创建用户”。这将创建一个用户并显示我们的访问密钥 ID 和秘密访问密钥。暂时复制并存储这些密钥。
- en: 'Now that we have the keys, we export them as an environment variable so that
    they will be accessed by the framework to perform their required function:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经获得了密钥，我们将其作为环境变量导出，以便框架能够访问并执行其所需的功能：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Installation of Serverless Framework
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Serverless Framework。
- en: 'Go through the following steps:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照以下步骤操作：
- en: 'Install Node.js 4.0 or higher from [https://nodejs.org/en/download/](https://nodejs.org/en/download/) .
    Once installed, we can verify installation through the following command:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://nodejs.org/en/download/](https://nodejs.org/en/download/) 安装 Node.js
    4.0 或更高版本。安装完成后，我们可以通过以下命令验证安装：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we need to install Serverless Framework globally through the following
    command:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要通过以下命令全局安装 Serverless Framework：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once installed successfully, we can verify the installation by using the following
    command. It will show all the framework commands and documentation:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装成功后，我们可以通过以下命令验证安装。它将显示所有框架命令和文档：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can also see the version of Serverless Framework installed by using the
    following command:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以通过以下命令查看已安装的 Serverless Framework 版本：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Lambda service and function deployment
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda 服务和函数部署。
- en: 'In the following step, we will be create a simple Node.js service and Lambda
    function, and then deploy and invoke them:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将创建一个简单的 Node.js 服务和 Lambda 函数，然后部署和调用它们：
- en: 'Create a new service using the Node.js template by Serverless Framework. We
    need to make sure that the name is unique and add the path to the service, which
    is optional. This command will create two files—`handler.js` and `serverless.yml`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Serverless Framework 创建一个新的服务，选择 Node.js 模板。我们需要确保名称唯一，并可以选择性地添加服务路径。此命令将创建两个文件—`handler.js`
    和 `serverless.yml`：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: A service is the framework's unit of organization. It can be considered as a
    project file. It's where we can define functions, the events that trigger them,
    and the resources of the function that we will use. All of these are placed into
    one file `serverless.yml`. In this `.yaml` file, we define the service called `my-serverless-service`. Then
    we define the provider; as I mentioned earlier, Serverless Framework supports
    a lot of other cloud service providers. We can list the provider details in this
    tag and also mention the runtime, which in our case is Node.js. The runtime will
    change depending on the language we use to write the function. We can define the
    environment or stage we are deploying to—which in our case is `dev`—as well as
    the respective region. Then, in the `functions` section, we define the function
    name—which in our case is `hello`—which has an attribute called `handler`, and
    this handler will call the `handler.js` file. We can also define the memory size.
    Next, I have added an HTTP event, which, in addition to the Lambda function, provisions
    the AWS API Gateway. It will create and provide an endpoint for the handler. So,
    using one script, we can provision a Lambda function and an API endpoint. We can
    define various other attributes and parameters; we will look into these in more
    detail in the next chapter.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是框架的组织单元。它可以被视为一个项目文件。在这里，我们可以定义函数、触发这些函数的事件以及我们将使用的函数资源。这些内容都被放入一个文件`serverless.yml`中。在这个`.yaml`文件中，我们定义了名为`my-serverless-service`的服务。然后我们定义了提供者；正如我之前提到的，Serverless
    Framework支持许多其他云服务提供商。我们可以在这个标签中列出提供者的详细信息，并且还可以提到运行时环境，在我们的案例中是Node.js。运行时环境会根据我们编写函数所使用的语言而变化。我们可以定义部署环境或阶段—在我们的案例中是`dev`—以及相应的区域。接着，在`functions`部分，我们定义了函数名称—在我们的案例中是`hello`—它有一个名为`handler`的属性，这个处理程序将调用`handler.js`文件。我们还可以定义内存大小。接下来，我添加了一个HTTP事件，它除了配置Lambda函数外，还配置了AWS
    API Gateway。它将为处理程序创建并提供一个端点。所以，使用一个脚本，我们可以配置Lambda函数和API端点。我们可以定义其他各种属性和参数；我们将在下一章中详细研究这些内容。
- en: 'Please make sure the `.yaml` files are properly indented, otherwise they will
    fail. You can also use the one that I have put on the following GitHub link:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保`.yaml`文件正确缩进，否则它们将无法运行。你也可以使用我在以下GitHub链接中提供的文件：
- en: '[https://github.com/shzshi/my-serverless-service.git](https://github.com/shzshi/my-serverless-service.git)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/shzshi/my-serverless-service.git](https://github.com/shzshi/my-serverless-service.git)'
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `handler.js` code phrase is the Node.js Lambda function for `Hello, World!`,
    which is referenced in the `serverless.yml` file. It is a pretty simple function
    that will just display the message `My Serverless World` on execution, as shown
    in the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`handler.js`代码段是`Hello, World!`的Node.js Lambda函数，在`serverless.yml`文件中引用。它是一个相当简单的函数，执行时将显示消息`My
    Serverless World`，如下所示：'
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Invoking locally
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地调用
- en: 'Pushing the code to AWS Lambda and testing every time would be expensive and
    time consuming. So with Serverless Framework, we can invoke or test functions
    locally and then deploy them to the cloud. We can have this as part of the continuous
    deployment pipeline, where we can set the local invocation for `dev` stage deployment,
    set up automated testing, and then move them further down the pipeline to deploy
    and test remotely. The following command is used to invoke the function locally:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 每次将代码推送到AWS Lambda并进行测试既昂贵又耗时。所以，通过Serverless Framework，我们可以在本地调用或测试函数，然后将其部署到云端。我们可以将此作为持续部署管道的一部分，在这里我们可以为`dev`阶段部署设置本地调用，设置自动化测试，然后将它们进一步推进管道，进行远程部署和测试。以下命令用于本地调用函数：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Deploying and invoking locally
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地部署和调用
- en: 'As we are now able to successfully invoke and test the function locally, we
    should be fine to deploy and test it remotely. First, we need to make sure that
    we have retrieved and exported the access and secret access keys as environment
    variables, as shown in the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们现在能够成功地在本地调用和测试函数，接下来我们应该可以将其部署并进行远程测试。首先，我们需要确保已将访问密钥和秘密访问密钥作为环境变量获取并导出，代码如下所示：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now I am deploying the function and API to the AWS Cloud through a simple `deploy`
    command. Behind the scenes, the deployment process will create a `.serverless`
    folder with `CloudFormation` JSON templates. The serverless code is packaged into
    a `.zip` file and a serverless state JSON file. If we look into the `create-stack`
    JSON template, Serverless Framework will create an S3 bucket on the AWS Cloud
    and deploy the function and API package on to the bucket with the `CloudFormation`
    template JSON file. It will also keep the state of the deployment in the form
    of a JSON file. The successful deployment will provision an API endpoint that
    is tied to an AWS Lambda function and creates a service as mentioned in the provider:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我通过一个简单的 `deploy` 命令将功能和 API 部署到 AWS 云中。在后台，部署过程将创建一个 `.serverless` 文件夹，包含
    `CloudFormation` JSON 模板。无服务器代码被打包成 `.zip` 文件以及一个无服务器状态 JSON 文件。如果我们查看 `create-stack`
    JSON 模板，Serverless Framework 将在 AWS 云上创建一个 S3 存储桶，并将功能和 API 包部署到该存储桶中，使用 `CloudFormation`
    模板 JSON 文件。它还会以 JSON 文件的形式保持部署状态。成功部署后，将提供一个 API 端点，该端点与 AWS Lambda 功能绑定，并创建一个如提供商中提到的服务：
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Postdeployment, we will go to the AWS portal and see whether the function is
    deployed. Then we will invoke it through the portal and then again invoke the
    remote function through the serverless CLI, using the following steps:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 部署后，我们将进入 AWS 门户，查看该功能是否已部署。然后我们将通过门户调用它，并再次通过无服务器 CLI 调用远程功能，使用以下步骤：
- en: Log in to the AWS portal, then select the correct region where the function
    and API was deployed.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到 AWS 门户，然后选择已部署功能和 API 的正确区域。
- en: Select the service as Lambda. The Lambda portal page will show the function
    name deployed. Select the function that you test using the radio button, then
    go to the drop-down marked Actions and select the option marked Test. The window
    will pop up to configure the event. You can add your own event or keep the default,
    and then click on Save. The event will be saved and the page will be redirected
    to the Function page. Now click on the Test button. The function will be executed,
    and the execution status and results will be displayed.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择服务为 Lambda。Lambda 门户页面将显示已部署的功能名称。使用单选按钮选择你要测试的功能，然后转到标记为“操作”的下拉菜单并选择“测试”选项。窗口将弹出配置事件。你可以添加自己的事件或保持默认设置，然后点击“保存”。事件将被保存，页面将重定向到功能页面。现在点击“测试”按钮。功能将被执行，执行状态和结果将显示出来。
- en: 'As I mentioned earlier, we can invoke the remote function locally as well.
    We will now look at the various commands for the remote Lambda function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们也可以在本地调用远程功能。现在我们将查看远程 Lambda 功能的各种命令：
- en: 'To invoke the function and get the logs, use the following command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用该功能并获取日志，请使用以下命令：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To just get the logs for the previous invocation, enter the following code.
    We can do this in a separate console to test the working:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 若只需获取上次调用的日志，请输入以下代码。我们可以在一个单独的控制台中测试其功能：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The command will undeploy the function from the Lambda and also remove the
    package details from the S3 bucket. Once `serverless remove` runs successfully
    (as shown in the following code), you can log in to the AWS portal and check the
    S3 bucket and the Lambda function for the specific region—it should be removed:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将从 Lambda 中撤销功能的部署，并移除 S3 存储桶中的包详情。一旦`serverless remove`成功运行（如以下代码所示），你可以登录
    AWS 门户，检查 S3 存储桶和 Lambda 功能的具体区域——它应该已经被移除：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about different frameworks, such as ClaudiaJS, Zappa,
    and Apex. We also looked into a few examples of using them, but we mostly covered
    Serverless Framework extensively. We will be using Serverless Framework extensively
    in most of our tutorials while going through the book, because Serverless Framework
    fairs far better than other frameworks because it has better community support
    and support for multiple cloud providers. This means that you don't have vendor
    locking, as you do with some other frameworks. It also has a huge list of plugins
    for different types of cloud service, good blog support, and finally, some really
    good features for easy deployment into various different cloud providers.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了不同的框架，例如 ClaudiaJS、Zappa 和 Apex。我们还查看了一些使用它们的示例，但我们主要深入探讨了 Serverless
    Framework。在本书中的大部分教程中，我们将广泛使用 Serverless Framework，因为它比其他框架表现得更好，因为它具有更好的社区支持和对多个云提供商的支持。这意味着你不会像使用某些其他框架时那样被绑定到特定供应商。它还拥有大量的插件，支持不同类型的云服务，良好的博客支持，最后，还有一些非常适合轻松部署到不同云提供商的优良功能。
