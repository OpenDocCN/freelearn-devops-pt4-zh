- en: Prometheus Metrics Fundamentals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Prometheus 指标基础
- en: Metrics are the core resources that the Prometheus stack ingests to provide
    you with useful information. Understanding them correctly is essential to fully
    utilize, manage, or even extend the realm of possibilities this stack has to offer.
    From data to information, and finally to knowledge, metrics are here to help you.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 指标是 Prometheus 堆栈获取并提供有用信息的核心资源。正确理解它们对于充分利用、管理甚至扩展该堆栈的可能性领域至关重要。从数据到信息，最终到知识，指标在这里帮助你。
- en: 'In brief, the following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，本章将涵盖以下主题：
- en: Understanding the Prometheus data model
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Prometheus 数据模型
- en: A tour of the four core metric types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四种核心指标类型的介绍
- en: Longitudinal and cross-sectional aggregations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 横向和纵向聚合
- en: Understanding the Prometheus data model
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Prometheus 数据模型
- en: To understand the Prometheus data model, we need to go through what makes a
    time series and the storage of such data. These concepts will be invaluable throughout
    this book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 Prometheus 数据模型，我们需要了解什么构成了时间序列以及如何存储这种数据。这些概念在本书的学习过程中将非常宝贵。
- en: Time series data
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列数据
- en: Time series data can usually be defined as a sequence of numerical data points
    that are indexed chronologically from the same source. In the scope of Prometheus,
    these data points are collected at a fixed time interval. As such, this kind of
    data, when represented in graphical form, will most commonly plot the evolution
    of the data through time, with the *x* axis being time and the *y* axis being
    the data value.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列数据通常可以定义为从相同来源按时间顺序索引的数值数据点。在 Prometheus 的范围内，这些数据点是按照固定时间间隔收集的。因此，当以图形形式呈现这种数据时，最常见的做法是绘制数据随时间的变化，*x*
    轴表示时间，*y* 轴表示数据值。
- en: Time series databases
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列数据库
- en: It all starts with the need to collect, store, and query measurements over time.
    When dealing with massive amounts of data from collectors and sensors (such as
    those that make up the Internet of Things), querying the resulting datasets is
    extremely slow if the database isn't designed with that use case in mind. Nothing
    prevents you from using standard relational or NoSQL databases to store time series
    data, but the performance penalty and scalability concerns should make you ponder
    on that decision. Prometheus chose to implement a time series database that was
    tailored to its unique problem space.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都始于需要收集、存储并查询随时间变化的度量。当处理来自收集器和传感器的大量数据（例如物联网组成部分）时，如果数据库没有为该用例设计，查询结果数据集将非常慢。虽然你可以使用标准的关系型或
    NoSQL 数据库来存储时间序列数据，但性能损失和可扩展性问题应该让你在做出决定时深思。Prometheus 选择实现一个专门为其独特问题空间量身定制的时间序列数据库。
- en: Besides the write-heavy aspect of these types of databases, which in turn implies
    the storage of a massive volume of measurements, it is also important to understand
    that a simple query can span over several hours, days, or even months, returning
    a tremendous amount of data points, but is still expected to return data reasonably
    fast.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些类型的数据库具有写入负载重的特点，这也意味着存储了大量的测量数据外，还需要理解的是，简单的查询可能跨越数小时、数天甚至数月，返回大量的数据点，但仍然期望能够合理快速地返回数据。
- en: 'As such, modern time series databases store the following components:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现代时间序列数据库存储以下组件：
- en: A timestamp
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间戳
- en: A value
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个值
- en: Some context about the value, encoded in a metric name or in associated key/value
    pairs
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于值的一些背景，编码在指标名称或关联的键/值对中
- en: 'An abstract example of data that fits this time series database specification
    is as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个符合此时间序列数据库规范的抽象数据示例如下：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, this kind of data can be easily stored into a single table
    in a database:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这种数据可以很容易地存储在数据库中的单一表格里：
- en: '| `timestamp` | `company` | `location` | `beverage` | `value` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `timestamp` | `company` | `location` | `beverage` | `value` |'
- en: '| `1544978108` | `ACME` | `headquarters` | `coffee` | `40172` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `1544978108` | `ACME` | `headquarters` | `coffee` | `40172` |'
- en: In this simple example, we can check the cups of coffee being served by a vending
    machine located at the headquarters of the ACME company. This example has all
    the required components of a time series if it's continually measured through
    time.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，我们可以查看位于 ACME 公司总部的自动售货机提供的咖啡杯数。如果通过时间持续测量，这个例子就拥有时间序列所需的所有组成部分。
- en: This example does not map directly to the Prometheus data model, as it also
    requires a metric name, but illustrates the logic we're aiming to address.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子并没有直接映射到 Prometheus 数据模型，因为它还需要一个度量名称，但它展示了我们希望解决的逻辑。
- en: Prometheus local storage
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Prometheus 本地存储
- en: Local storage is the standard approach for storing data in Prometheus and, as
    such, we must understand its basics. At a very high level, Prometheus storage
    design is a combination of an index implementation using posting lists for all
    currently stored labels with their values, and its own time series data format.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本地存储是 Prometheus 存储数据的标准方法，因此，我们必须理解它的基础知识。总体来看，Prometheus 存储设计结合了使用发布列表（posting
    lists）为当前存储的所有标签及其值实现索引的方式，以及它自己的时间序列数据格式。
- en: Data flow
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据流
- en: The way Prometheus stores collected data locally can be seen as a three-part
    process. The following topics depict the stages that data goes through until it's
    successfully persisted.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 存储收集数据的方式可以看作是一个三部分的过程。以下主题描述了数据在成功持久化之前所经历的各个阶段。
- en: Memory
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存
- en: The freshest batch of data is kept in memory for up to two hours. This includes
    one or more chunks of data that are gathered during the two-hour time window.
    This approach dramatically reduces disk I/O two fold; the most recent data is
    available in memory, making it blazingly fast to query; and the chunks of data
    are created in memory, avoiding constant disk writes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最新一批数据会保存在内存中，最长可达两小时。这包括在两小时时间窗口内收集到的一个或多个数据块。这种方法大大减少了磁盘 I/O，最多可以减少两倍；最近的数据保存在内存中，查询非常快速；并且数据块是在内存中创建的，避免了持续的磁盘写入。
- en: Write ahead log
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提前写日志
- en: While in memory, data is not persisted and could be lost if the process terminates
    abnormally. To prevent this scenario, a **write-ahead log** (**WAL**) in disk
    keeps the state of the in-memory data so that it can be replayed if Prometheus,
    for any reason, crashes or restarts.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中时，数据并未持久化，如果进程异常终止，数据可能会丢失。为了防止这种情况发生，磁盘上的 **写前日志** (**WAL**) 会保存内存中数据的状态，以便在
    Prometheus 因任何原因崩溃或重启时能够重放这些数据。
- en: Disk
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 磁盘
- en: After the two-hour time window, the chunks get written to disk. These chunks
    are immutable and, even though data can be deleted, it's not an atomic operation.
    Instead, tombstone files are created with the information of the data that's no
    longer required.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在两小时的时间窗口结束后，这些数据块将被写入磁盘。这些数据块是不可变的，尽管数据可以被删除，但这不是一个原子操作。相反，墓碑文件（tombstone）会被创建，记录不再需要的数据。
- en: Layout
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局
- en: The way data gets stored in Prometheus, as we can see in the following example,
    is organized into a series of directories (blocks) containing the data chunks,
    the LevelDB index for that data, a `meta.json` file with human-readable information
    about the block, and tombstones for data that's no longer required. Each one of
    these blocks represents a database.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在下面的示例中所看到的，数据在 Prometheus 中的存储方式被组织成一系列包含数据块、该数据的 LevelDB 索引、一个带有人类可读信息的
    `meta.json` 文件以及记录不再需要数据的墓碑文件的目录（块）。每一个这样的块代表一个数据库。
- en: 'At the top level, you can also see the WAL for the data that''s not been flushed
    into its own chunk yet:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在最顶层，你还可以看到那些尚未刷新到自己数据块中的数据的 WAL（写前日志）：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Prometheus data model
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Prometheus 数据模型
- en: As we have seen so far, Prometheus stores data as time series, which includes
    key/value pairs known as labels, a timestamp, and finally a value. The following
    topics will expand on these components and provide the basics for each one, which
    we will be utilizing in depth in [Chapter 7](205ddb34-6ee8-4e22-b80f-39d5b2198c29.xhtml),
    *Prometheus Query Language - PromQL*, dedicated to PromQL.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们目前所看到的，Prometheus 将数据存储为时间序列，这包括被称为标签的键值对、时间戳和最终的值。接下来的主题将扩展这些组件，并提供每个组件的基础知识，我们将在[第
    7 章](205ddb34-6ee8-4e22-b80f-39d5b2198c29.xhtml)，*Prometheus 查询语言 - PromQL*中深入使用这些知识。
- en: Notation
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标注
- en: 'A time series in Prometheus is represented as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 中的时间序列表示如下：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, it's represented as a metric name, optionally followed by one
    or more set of label names/values inside curly brackets, and then the value of
    the metric. Additionally, a sample will also have a timestamp with millisecond
    precision.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，数据表示为一个度量名称，后面可选地跟着一个或多个带有标签名称/值的集合，并且标签值放在大括号中，最后是度量的值。此外，一个样本也会带有精确到毫秒的时间戳。
- en: Metric names
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 度量名称
- en: Even though this is an implementation detail, a metric name is nothing more
    than the value of a special label called `"__name__"`. So, if you have a metric
    named `"beverages_total"`, internally, it's represented as `"__name__=beverages_total"`.
    Keep in mind that labels surrounded by `"__"` are internal to Prometheus, and
    any label prefixed with `"__"` is only available in some phases of the metrics
    collection cycle.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个实现细节，但指标名称实际上就是一个特殊标签的值，叫做`"__name__"`。因此，如果你有一个名为 `"beverages_total"`
    的指标，内部表示为 `"__name__=beverages_total"`。请记住，被 `"__"` 包围的标签是 Prometheus 的内部标签，任何以
    `"__"` 为前缀的标签仅在某些阶段的指标收集周期中可用。
- en: The combination of labels (key/values) and the metric name defines the identity
    of a time series.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 标签（键/值）和指标名称的组合定义了时间序列的身份。
- en: 'Every metric name in Prometheus must match the following regular expression:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 中的每个指标名称必须匹配以下正则表达式：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This, in layman's terms, means that metric names only allow lowercase and uppercase
    letters of the English alphabet (`a-z`), underscores (`_`), colons (`:`), and
    Arabic numerals (`0-9`), except on the first character, where numbers are not
    allowed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通俗来说，这意味着指标名称只允许使用英文字母的大小写（`a-z`）、下划线（`_`）、冒号（`:`）和阿拉伯数字（`0-9`），但首字符不能是数字。
- en: Colons are reserved for a special kind of metric-designated recording rule.
    We will expand on this subject in another chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号是保留给一种特殊类型的指标指定的记录规则的。我们将在另一章中详细展开这个话题。
- en: Metric labels
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指标标签
- en: Labels, or the key/value pairs associated with a certain metric, add dimensionality
    to the metrics. This is an essential part of what makes Prometheus so good at
    slicing and dicing time series, as we'll see in [Chapter 7](205ddb34-6ee8-4e22-b80f-39d5b2198c29.xhtml),* Prometheus
    Query Language – PromQL.*
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 标签，或者与特定指标相关的键/值对，为指标添加了维度。这是 Prometheus 在切片和处理时间序列数据时如此出色的一个关键部分，正如我们在[第七章](205ddb34-6ee8-4e22-b80f-39d5b2198c29.xhtml)中所见的，*Prometheus
    查询语言 – PromQL*。
- en: While label values can be full UTF-8, label names have to match a regular expression
    to be considered valid; for example, `"[a-zA-Z0-9_]*"`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然标签值可以是完整的 UTF-8 字符串，但标签名称必须符合正则表达式才能被认为是有效的；例如，`"[a-zA-Z0-9_]*"`。
- en: Their main difference in regard to metric names is that label names don't allow
    the colon (`:`).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与指标名称相比，它们的主要区别在于标签名称不允许使用冒号（`:`）。
- en: Samples
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样本
- en: Samples are the collected data points, and they represent the numerical value
    of time series data. The components that are required to define a sample are a
    float64 value, and a timestamp with millisecond precision. Something to keep in
    mind is that samples collected out of order will be discarded by Prometheus. The
    same happens to samples with the same metric identity and different sample values.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 样本是收集到的数据点，它们表示时间序列数据的数值。定义一个样本所需的组件是一个 float64 值和一个具有毫秒精度的时间戳。需要记住的是，顺序错乱的样本会被
    Prometheus 丢弃。同样，具有相同指标身份和不同样本值的样本也会被丢弃。
- en: Cardinality
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基数
- en: 'Depending on the computing resources being assigned to a Prometheus instance
    (that is, CPU, memory, disk space, and IOPS), it will gracefully handle a number
    of time series. This number can be thought of as the primary indicator of capacity
    for that instance, and it will inform your scraping decisions: will you have thousands
    of targets with relatively few metrics, fewer targets with a thousand metrics
    each, or something in between? In the end, Prometheus will only be able to handle
    that amount of time series without performance degradation.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 根据分配给 Prometheus 实例的计算资源（即 CPU、内存、磁盘空间和 IOPS），它将优雅地处理一定数量的时间序列。这个数字可以被视为该实例容量的主要指标，它将影响你的抓取决策：你会有成千上万个目标，每个目标的指标较少，还是较少的目标，每个目标有成千上万个指标，或者介于两者之间？最终，Prometheus
    将仅能处理一定数量的时间序列，而不会导致性能下降。
- en: It is in this context that the concept of cardinality appears. This term is
    often used to mean the number of unique time series that are produced by a combination
    of metric names and their associated label names/values. As an example, a single
    metric with no additional dimensions (such as labels) from an application that
    has one hundred instances will naturally mean that Prometheus will store 100 time
    series, one for each instance (the instance, here, is a dimension that's added
    outside of the application); another metric from that application that had a label
    with ten possible values will translate into 1,000 time series (10 time series
    per instance, times 100 instances). This shows that cardinality is multiplicative—each
    additional dimension will increase the number of produced time series by repeating
    the existing dimensions for each value of the new one. Having multiple dimensions
    with a large number of possible values in a metric will cause what is called a
    cardinality explosion in Prometheus, which is the creation of a very large number
    of time series.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，基数的概念出现了。这个术语通常用来表示由指标名称和其关联的标签名称/值的组合所产生的独特时间序列的数量。举个例子，一个没有额外维度（如标签）的指标，如果来自一个拥有一百个实例的应用程序，自然意味着
    Prometheus 将存储 100 个时间序列，每个实例一个（这里的实例是应用程序外部添加的维度）；另一个来自该应用程序的指标，如果有一个标签有十个可能的值，则会转化为
    1,000 个时间序列（每个实例 10 个时间序列，乘以 100 个实例）。这表明基数是乘法性的——每增加一个维度，现有维度的每个值都会与新维度的每个值重复，从而增加产生的时间序列数。拥有多个维度且每个维度具有大量可能值的指标将导致
    Prometheus 中所称的基数爆炸，即创建大量时间序列。
- en: When you have label values that don't have a clear limit, which can increase
    indefinitely or above hundreds of possible values, you will also have a cardinality
    problem. These metrics might be better suited to be handled in logs-based systems.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当标签值没有明确的限制，且可能会无限增加或有数百个可能值时，你也会遇到基数问题。这些指标可能更适合在基于日志的系统中处理。
- en: 'The following are some examples of data with high or unbound cardinality that
    should not be used as label values (or in metric names, for that matter):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些具有高或无限基数的数据示例，这些数据不应作为标签值（或在指标名称中使用）：
- en: Email addresses
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件地址
- en: Usernames
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名
- en: Request/process/order/transaction ID
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求/进程/订单/交易 ID
- en: A tour of the four core metric types
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 四种核心指标类型的概述
- en: 'Prometheus metrics are divided into four main types: counters, gauges, histograms,
    and summaries. It is essential to understand them in depth, as most functions
    provided by Prometheus only work correctly with a given data type. So, to that
    end, here is an overview of each.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 指标分为四种主要类型：计数器、计量器、直方图和摘要。深入理解它们非常重要，因为 Prometheus 提供的大多数功能只有在特定数据类型下才能正常工作。因此，以下是对每种类型的概述。
- en: Counter
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计数器
- en: This is a strictly cumulative metric whose value can only increase. The only
    exception for this rule is when the metric is reset, which brings it back to zero.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个严格的累积性指标，其值只能增加。唯一的例外是当指标被重置时，它会恢复为零。
- en: This is one of the most useful metric types because even if a scrape fails,
    you won't lose the cumulative increase in the data, which will be available on
    the next scrape. To be clear, in the case of a failed scrape, granularity would
    be lost as fewer points will be saved.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最有用的指标类型之一，因为即使抓取失败，数据的累积增加也不会丢失，下次抓取时仍然可以获取到。需要明确的是，在抓取失败的情况下，由于保存的点较少，粒度会丢失。
- en: 'To help visualize this type of metric, here are some examples of counters and
    their graphical representation based on the test environment we created in the
    previous chapter:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助可视化这种类型的指标，以下是一些计数器及其基于我们在上一章创建的测试环境的图形表示示例：
- en: 'The total number of packets received by the Prometheus instance:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prometheus 实例接收到的总数据包数量：
- en: '![](img/b19429b8-0dd4-4af4-85f4-d204334d9258.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b19429b8-0dd4-4af4-85f4-d204334d9258.png)'
- en: 'The total number of bytes written to disk by the Grafana instance – notice
    the middle gap caused by an instance restart, forcing the counter to reset:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grafana 实例写入磁盘的总字节数——注意由于实例重启而导致的中间空隙，迫使计数器重置：
- en: '![](img/e68511cd-17b3-4aa4-a35f-e4699f038e06.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e68511cd-17b3-4aa4-a35f-e4699f038e06.png)'
- en: Gauge
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计量器
- en: A gauge is a metric that snapshots a given measurement at the time of collection,
    which can increase or decrease (such as temperature, disk space, and memory usage).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 计量器是一种在收集时对给定测量值进行快照的指标，其值可以增加或减少（例如温度、磁盘空间和内存使用情况）。
- en: If a scrape fails, you will lose that sample, as the next scrape might encounter
    the metric on a different value (higher/lower).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果抓取失败，你将丢失该样本，因为下次抓取可能会遇到不同值的度量（更高或更低）。
- en: 'To help visualize this type of metric, here are some examples of gauges and
    their graphical representation based on the test environment we created in the
    previous chapter:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助可视化这种类型的度量，以下是基于我们在上一章创建的测试环境的一些仪表和其图形表示示例：
- en: 'The number of established TCP connections on the Alertmanager instance:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alertmanager 实例上建立的 TCP 连接数：
- en: '![](img/8fd23da9-b580-4619-84a2-e553d41e6f04.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8fd23da9-b580-4619-84a2-e553d41e6f04.png)'
- en: 'The amount of free memory on the Grafana instance – notice the middle gap caused
    by an instance restart, preventing any assumption about the possible value during
    that period:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grafana 实例上的空闲内存量——注意由于实例重启导致的中间间隙，这使得在该期间无法对可能的值做出任何假设：
- en: '![](img/2bc8cac1-9a40-4ae6-9662-0f7793b061b5.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2bc8cac1-9a40-4ae6-9662-0f7793b061b5.png)'
- en: Histogram
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直方图
- en: Recording numerical data that's inherent to each event in a system can be expensive,
    so some sort of pre-aggregation is usually needed to conserve at least partial
    information about what happened. However, by pre-calculating aggregations on each
    instance (such as average since process start, rolling window, exponentially weighted,
    and so on), a lot of granularity is lost and some calculations can be computationally
    costly. Adding to this, a lot of pre-aggregations can't generally be re-aggregated
    without losing meaning—the average of a thousand pre-calculated 95th percentiles
    has no statistical meaning. Similarly, having the 99th percentile of request latency
    collected from each instance of a given cluster (for example) gives you no indication
    of the overall cluster's 99th percentile and no way to accurately calculate it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 记录系统中每个事件固有的数值数据可能会很昂贵，因此通常需要某种形式的预聚合，以至少保留有关发生了什么的部分信息。然而，通过在每个实例上预计算聚合（例如，自进程启动以来的平均值、滚动窗口、指数加权等），会丢失大量的粒度，而且某些计算可能在计算上很昂贵。更糟糕的是，许多预聚合通常不能重新聚合，否则会失去其意义——例如，计算一千个预先计算的第95百分位数的平均值是没有统计意义的。类似地，从给定集群的每个实例收集的请求延迟的第99百分位数（例如）并不能指示整个集群的第99百分位数，也无法准确计算它。
- en: Histograms allow you to retain some granularity by counting events into buckets
    that are configurable on the client side, and also by providing a sum of all observed
    values. Prometheus histograms produce one time series per configured bucket, plus
    an additional two that track the sum and the count of observed events. Furthermore,
    histograms in Prometheus are cumulative, which means each bucket will have the
    value of the previous bucket, plus the number of its own events. This is done
    so that some buckets can be dropped for performance or storage reasons without
    losing the overall ability to use the histogram.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图允许你通过将事件计入客户端可配置的桶中来保持一定的粒度，同时还提供所有观察值的总和。Prometheus 直方图为每个配置的桶生成一个时间序列，并额外生成两个时间序列，分别跟踪观察到的事件的总和和计数。此外，Prometheus
    中的直方图是累积的，这意味着每个桶将包含前一个桶的值，加上其自身事件的数量。这样做是为了在不丢失使用直方图的整体能力的情况下，可以出于性能或存储的原因丢弃一些桶。
- en: 'The downside of using histograms is that the selected buckets need to fit the
    range and distribution of values that are expected to be collected. The error
    margin for quantile calculation will be directly related with this fit: too few
    or poorly selected buckets will increase the error margins for quantile calculations.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用直方图的缺点是所选的桶需要适应预期收集的值的范围和分布。分位数计算的误差范围将与此适配直接相关：选择太少或不当的桶将增加分位数计算的误差范围。
- en: This type of metric is especially useful to track bucketed latencies and sizes
    (for example, request durations or response sizes) as it can be freely aggregated
    across different dimensions. Another great use is to generate heatmaps (the evolution
    of histograms over time).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的度量特别适用于跟踪分桶延迟和大小（例如，请求持续时间或响应大小），因为它可以在不同维度之间自由聚合。另一个很好的应用是生成热图（直方图随时间的演变）。
- en: 'To help visualize this type of metric, here is an example of a histogram and
    its graphical representation based on the test environment we created in the previous
    chapter:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助可视化这种类型的度量，以下是基于我们在上一章创建的测试环境的直方图及其图形表示示例：
- en: 'A Prometheus HTTP request duration in seconds, divided into buckets. This is
    shown in a Grafana heatmap to better illustrate the concept of buckets:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prometheus HTTP 请求持续时间（单位：秒），按桶划分。这在 Grafana 热力图中显示，以更好地说明桶的概念：
- en: '![](img/f943c349-a36f-4a3c-8320-3518950d6dd4.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f943c349-a36f-4a3c-8320-3518950d6dd4.png)'
- en: Summaries
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Summaries are similar to histograms in some ways, but present different trade-offs
    and are generally less useful. They are also used to track sizes and latencies,
    and also provide both a sum and a count of observed events. Additionally (and
    if the client library used supports it), summaries can also provide pre-calculated
    quantiles over a predetermined sliding time window. The main reason to use summary
    quantiles is when accurate quantile estimation is needed, irrespective of the
    distribution and range of the observed events.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要在某些方面类似于直方图，但呈现了不同的权衡，并且通常不那么有用。它们也用于跟踪大小和延迟，并提供观察到的事件的总和和计数。此外（如果使用的客户端库支持），摘要还可以提供在预定滑动时间窗口上预先计算的分位数。使用摘要分位数的主要原因是，当需要准确的分位数估算时，无论观察到的事件的分布和范围如何。
- en: Quantiles in Prometheus are referred to as φ-quantiles, where 0 ≤ φ ≤ 1.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 中的分位数被称为 φ-分位数，其中 0 ≤ φ ≤ 1。
- en: Both quantiles and sliding window size are defined in the instrumentation code,
    so it's not possible to calculate other quantiles or window sizes on an ad hoc
    basis. Doing these calculations on the client side also means that the instrumentation
    and computational cost is a lot higher. The last downside to mention is that the
    resulting quantiles are not aggregable and thus of limited usefulness.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 分位数和滑动窗口大小都在仪表代码中定义，因此无法根据需要计算其他分位数或窗口大小。在客户端进行这些计算也意味着仪表和计算成本会更高。最后需要提到的缺点是，计算出来的分位数是不可聚合的，因此其实用性有限。
- en: One benefit that summaries have is that, without quantiles, they are quite cheap
    to generate, collect, and store.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要的一个好处是，在没有分位数的情况下，它们生成、收集和存储的成本相对较低。
- en: 'To help visualize this type of metric, here is an example of a summary and
    its graphical representation, based on the test environment we created in the
    previous chapter:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助可视化这种类型的度量，以下是一个摘要及其图形表示，基于我们在上一章创建的测试环境：
- en: 'The maximum duration of the Prometheus rule group in seconds by quantile:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prometheus 规则组的最大持续时间（单位：秒）按分位数划分：
- en: '![](img/c663adc3-ae79-48e7-8d52-5511b1ba35f1.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c663adc3-ae79-48e7-8d52-5511b1ba35f1.png)'
- en: Longitudinal and cross-sectional aggregations
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纵向和横向聚合
- en: 'The last concept to grasp when thinking about time series is how aggregations
    work on an abstract level. One of Prometheus'' core strengths is that it makes
    the manipulation of time series data easy, and this slicing and dicing of data
    usually boils down to two kinds of aggregations, which are often used together:
    longitudinal and cross-sectional aggregations.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在思考时间序列时，最后一个需要掌握的概念是聚合如何在抽象层面上工作。Prometheus 的核心优势之一是，它使得时间序列数据的操作变得简单，这种对数据的切片与切分通常归结为两种聚合，且通常是一起使用的：纵向聚合和横向聚合。
- en: In the context of time series, an aggregation is a process that reduces or summarizes
    the raw data, which is to say that it receives a set of data points as input and
    produces a smaller set (often a single element) as output. Some of the most common
    aggregation functions in time series databases are minimum, maximum, average,
    count, and sum.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间序列的背景下，聚合是一个减少或总结原始数据的过程，也就是说，它接收一组数据点作为输入，并输出一个较小的集合（通常是一个单一元素）。在时间序列数据库中，一些最常见的聚合函数包括最小值、最大值、平均值、计数和总和。
- en: To better understand how these aggregations work, let's look at some data using
    the example time series we presented earlier in this chapter. To be clear, the
    next few sections will explain how these aggregations work on an abstract level
    and will hint at what their Prometheus counterparts are, but are not supposed
    to be a one-to-one match with PromQL (which we will explore thoroughly in [Chapter
    7](205ddb34-6ee8-4e22-b80f-39d5b2198c29.xhtml), *Prometheus Query Language – PromQL*).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这些聚合是如何工作的，我们来看看一些数据，使用本章前面介绍的示例时间序列。需要明确的是，接下来的几节将解释这些聚合是如何在抽象层面上工作的，并暗示它们在
    Prometheus 中的对应关系，但这些内容并不打算与 PromQL（我们将在[第 7 章](205ddb34-6ee8-4e22-b80f-39d5b2198c29.xhtml)中深入探讨，*Prometheus
    查询语言 – PromQL*）一一对应。
- en: 'Let''s pretend we''ve selected `{company=ACME, beverage=coffee}` and we''re
    now looking at the raw counters over time per location. The data would look something
    like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们选择了 `{company=ACME, beverage=coffee}`，现在我们正在查看每个位置上随时间变化的原始计数器。数据大概是这样的：
- en: '| **Location/Time** | **t=0** | **t=1** | **t=2** | **t=3** | **t=4** | **t=5**
    | **t=6** |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| **位置/时间** | **t=0** | **t=1** | **t=2** | **t=3** | **t=4** | **t=5** | **t=6**
    |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **Factory** | 1,045 | 1 | 2 | 3 | 4 | 5 | 6 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| **工厂** | 1,045 | 1 | 2 | 3 | 4 | 5 | 6 |'
- en: '| **Warehouse** | 223 | 223 | 223 | 223 | 224 | 224 | 224 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **仓库** | 223 | 223 | 223 | 223 | 224 | 224 | 224 |'
- en: '| **Headquarters** | 40,160 | 40,162 | 40,164 | 40,166 | 40,168 | 40,170 |
    40,172 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **总部** | 40,160 | 40,162 | 40,164 | 40,166 | 40,168 | 40,170 | 40,172 |'
- en: Actual data wouldn't look exactly like this, as each time series is collected
    at slightly different times. The data points would have their own timestamps associated,
    which means they would be out of alignment. This, in turn, impacts on the results
    of aggregations, as some method of interpolation would be applied to align data
    points.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 实际数据不会完全像这样，因为每个时间序列是略微不同时间点收集的。数据点会有各自的时间戳，这意味着它们会错开对齐。这反过来会影响聚合的结果，因为会应用某种插值方法来对齐数据点。
- en: For argument's sake, let's say that the samples were collected every minute.
    The metric type is probably a counter, as it's monotonically increasing, with
    the exception of the counter that's reset at `t=1` for `location=factory`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 假设每分钟收集一次样本。度量类型可能是计数器，因为它是单调递增的，除了在 `t=1` 时重置的计数器（对于 `location=factory`）。
- en: Cross-sectional aggregation
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 横向聚合
- en: 'Cross-sectional aggregations are the easiest to understand. As we can see in
    the following data representation, we take a column of data and apply an aggregation
    function to it:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 横向聚合是最容易理解的。正如我们在以下数据表示中看到的那样，我们从一列数据中应用聚合函数：
- en: '| **Location/Time** | **t=0** | **t=1** | **t=2** | **t=3** | **t=4** | **t=5**
    | **t=6** |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| **位置/时间** | **t=0** | **t=1** | **t=2** | **t=3** | **t=4** | **t=5** | **t=6**
    |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **Factory** | 1,045 | 1 | 2 | 3 | 4 | 5 | **6** |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **工厂** | 1,045 | 1 | 2 | 3 | 4 | 5 | **6** |'
- en: '| **Warehouse** | 223 | 223 | 223 | 223 | 224 | 224 | **224** |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| **仓库** | 223 | 223 | 223 | 223 | 224 | 224 | **224** |'
- en: '| **Headquarters** | 40160 | 40,162 | 40,164 | 40,166 | 40,168 | 40,170 | **40,172**
    |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **总部** | 40160 | 40,162 | 40,164 | 40,166 | 40,168 | 40,170 | **40,172**
    |'
- en: 'If we apply the `max()` aggregation, we can find out which location reported
    more coffees were dispensed—in this case, the result would be 40,172\. Applying
    `count()` would give us the number of offices reporting data for the dimensions
    that were selected (`{company=ACME, beverage=coffee}`): 3.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们应用 `max()` 聚合，我们可以找出报告更多咖啡分发量的地点——在这种情况下，结果将是 40,172。应用 `count()` 将告诉我们报告数据的办公室数量，针对所选择的维度（`{company=ACME,
    beverage=coffee}`）：3。
- en: It's not generally sane to apply `max()` to a counter, as we'll see in [Chapter
    7](205ddb34-6ee8-4e22-b80f-39d5b2198c29.xhtml), *Prometheus Query Language – PromQL*.
    This is a simple and abstract example to help you understand the basics of time
    series.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，应用 `max()` 到计数器上是不合理的，正如我们在[第7章](205ddb34-6ee8-4e22-b80f-39d5b2198c29.xhtml)中看到的，*Prometheus
    查询语言 – PromQL*。这是一个简单的抽象示例，帮助你理解时间序列的基础。
- en: This type of aggregation usually applies to the last data points in the requested
    set. The most common case where this is not true is when graphing the aggregation
    over time, as it needs to be calculated for each point in the graph.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的聚合通常应用于请求集中最后的数据点。唯一通常例外的情况是当绘制时间序列聚合图时，因为它需要对图中的每个点进行计算。
- en: You will notice that the selected data resembles a traditional column vector
    from linear algebra. As we'll see in [Chapter 7](205ddb34-6ee8-4e22-b80f-39d5b2198c29.xhtml),
    *Prometheus Query Language – PromQL*, dedicated to PromQL, these will be referred
    to as instant vectors.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，所选数据类似于线性代数中的传统列向量。正如我们在[第7章](205ddb34-6ee8-4e22-b80f-39d5b2198c29.xhtml)中看到的，*Prometheus
    查询语言 – PromQL*，专门讨论 PromQL，这些将被称为瞬时向量。
- en: Longitudinal aggregation
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纵向聚合
- en: 'Longitudinal aggregations are trickier to use because you need to select a
    time window over which to apply the aggregation. This means they work over rows,
    as we can see in the following representation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 纵向聚合的使用较为复杂，因为你需要选择一个时间窗口来进行聚合。这意味着它们是按行工作的，正如我们在以下表示中看到的那样：
- en: '| **Location/Time** | **t=0** | **t=1** | **t=2** | **t=3** | **t=4** | **t=5**
    | **t=6** |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| **位置/时间** | **t=0** | **t=1** | **t=2** | **t=3** | **t=4** | **t=5** | **t=6**
    |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **Factory** | 1,045 | 1 | 2 | 3 | **4** | **5** | **6** |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **工厂** | 1,045 | 1 | 2 | 3 | **4** | **5** | **6** |'
- en: '| **Warehouse** | 223 | 223 | 223 | 223 | **224** | **224** | **224** |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **仓库** | 223 | 223 | 223 | 223 | **224** | **224** | **224** |'
- en: '| **Headquarters** | 40,160 | 40,162 | 40,164 | 40,166 | **40,168** | **40,170**
    | **40,172** |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **总部** | 40,160 | 40,162 | 40,164 | 40,166 | **40,168** | **40,170** | **40,172**
    |'
- en: 'Since the current selectors we''re using return three rows of data, this means
    we''ll have three results when applying longitudinal aggregations. In this example,
    we''ve selected the last three minutes of data for aggregation (as we mentioned
    previously, we''re considering a 1-minute sample interval). If we apply the `max()`
    aggregation over time, since these are counters and there wasn''t a reset in the
    selected window, we will get the latest values in the selected set: 6 for `location=factory`,
    **224** for `location=warehouse`, and **40,172** for `location=headquarters`.
    `count()` will return the number of points that were selected in the specified
    time range—in this case, since the collection occurs every minute and we requested
    it for three minutes, it will return **3** for each location.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于当前我们使用的选择器返回三行数据，这意味着应用纵向聚合时，我们将得到三个结果。在这个例子中，我们选择了最后三分钟的数据进行聚合（正如前面所提到的，我们考虑的是
    1 分钟的样本间隔）。如果我们对时间应用 `max()` 聚合，因为这些是计数器且在选择的时间窗口内没有重置，我们将得到所选集合中的最新值：`location=factory`
    为 6，`location=warehouse` 为 **224**，`location=headquarters` 为 **40,172**。`count()`
    将返回在指定时间范围内选择的点数——在这个例子中，由于收集发生在每分钟一次，我们请求了三分钟的数据，它将为每个位置返回 **3**。
- en: A more interesting aggregation of this kind that wasn't mentioned before is
    `rate()`. It is a particularly useful aggregation to use with counters, as you
    can calculate the rate of change per unit of time—we will explore this in detail
    later in this book. In this example, `rate()` would return 1, 0, and 2 for each
    location, respectively.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 之前未提到的一种更有趣的聚合方法是 `rate()`。这是一个特别适用于计数器的聚合方法，因为你可以计算每单位时间的变化速率——我们将在本书后面详细探讨这一点。在这个例子中，`rate()`
    将分别返回每个位置的 1、0 和 2。
- en: Once again, we would like to point out the resemblance of the selected data
    to a traditional matrix from mathematics. These type of selections will be referred
    to as range vectors in PromQL.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次指出，所选数据与数学中传统矩阵的相似性。这类选择将被称为 PromQL 中的范围向量（range vectors）。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we came to understand what time series data is, and looked
    at an overview of how a modern time series database such as Prometheus works,
    not only logically, but physically as well. We went through the Prometheus metrics
    notation and how metric names and labels relate to each other, and also covered
    what defines a sample. Prometheus metrics have four types, and we had the chance
    to go through every one of them and provide some useful examples. Finally, we
    dived into how longitudinal and cross-sectional aggregations work, which is essential
    to fully take advantage of Prometheus' query language.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了什么是时间序列数据，并概述了现代时间序列数据库（如 Prometheus）如何工作，不仅是逻辑上，还有物理层面。我们回顾了 Prometheus
    的度量符号，度量名称和标签之间的关系，并讨论了什么定义了一个样本。Prometheus 的度量有四种类型，我们有机会逐一了解并提供了一些有用的示例。最后，我们深入探讨了纵向和横截面聚合如何工作，这是充分利用
    Prometheus 查询语言的关键。
- en: In the next chapter, we'll return to a more hands-on approach and go into Prometheus
    server configuration, and how to manage it on both virtual machines and Kubernetes.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回到更实用的方法，探讨 Prometheus 服务器的配置，以及如何在虚拟机和 Kubernetes 上管理它。
- en: Questions
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the mandatory requirement of any graphical time series representation?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何图形化时间序列表示的强制要求是什么？
- en: What are the components for a data point to be considered as time series data?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个数据点要被视为时间序列数据，它的组成部分是什么？
- en: When a Prometheus server crashes, what prevents it from losing data?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 Prometheus 服务器崩溃时，是什么防止它丢失数据？
- en: What is the Prometheus in-memory database time window for storing data?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Prometheus 内存数据库存储数据的时间窗口是多少？
- en: What are the components of a Prometheus sample?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Prometheus 样本的组成部分是什么？
- en: What are the common use cases for both histograms and summaries?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直方图和摘要的常见用例是什么？
- en: What is the difference between a cross-sectional and a longitudinal aggregation?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 横截面聚合和纵向聚合有什么区别？
- en: Further reading
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**Prometheus storage layout**: [https://prometheus.io/docs/prometheus/latest/storage/](https://prometheus.io/docs/prometheus/latest/storage/)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Prometheus 存储布局**: [https://prometheus.io/docs/prometheus/latest/storage/](https://prometheus.io/docs/prometheus/latest/storage/)'
- en: '**Prometheus storage format**: [https://github.com/prometheus/tsdb/blob/master/docs/format/README.md](https://github.com/prometheus/tsdb/blob/master/docs/format/README.md)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Prometheus 存储格式**: [https://github.com/prometheus/tsdb/blob/master/docs/format/README.md](https://github.com/prometheus/tsdb/blob/master/docs/format/README.md)'
- en: '**Fabian Reinartz – Writing a Time Series Database from Scratch**: [https://fabxc.org/tsdb/](https://fabxc.org/tsdb/)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fabian Reinartz – 从零开始编写时间序列数据库**: [https://fabxc.org/tsdb/](https://fabxc.org/tsdb/)'
- en: '**Prometheus data model**: [https://prometheus.io/docs/concepts/data_model/](https://prometheus.io/docs/concepts/data_model/)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Prometheus 数据模型**: [https://prometheus.io/docs/concepts/data_model/](https://prometheus.io/docs/concepts/data_model/)'
- en: '**Histograms and Summaries**: [https://prometheus.io/docs/practices/histograms/](https://prometheus.io/docs/practices/histograms/)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**历史记录和摘要**: [https://prometheus.io/docs/practices/histograms/](https://prometheus.io/docs/practices/histograms/)'
