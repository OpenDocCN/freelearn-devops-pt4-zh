- en: Dependency Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖管理
- en: In part one of this book, you learned how to continuously deploy your application.
    While doing so, one of the main issues you might run into is that the total time
    it takes to build your application is too long. Due to this, developers have to
    wait a long time for feedback on their changes. One way of coping with this is
    by splitting your solutions up into multiple builds.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一部分，你学习了如何持续部署你的应用程序。在此过程中，你可能遇到的一个主要问题是构建应用程序所需的总时间过长。因此，开发人员不得不长时间等待对更改的反馈。应对这一问题的一种方法是将解决方案拆分成多个构建。
- en: One approach to this is by introducing package management. Often, you will find
    that you want to reuse code from a previous project in a new project. Instead
    of copying and pasting this code from one project to another, you can create a
    shared library out of it. In this chapter, you will learn how to identify shared
    components and how to make them reusable using Azure Artifacts. In addition to
    this, you will learn how you can use Azure Artifacts for storing pipeline artifacts
    when working in a heterogeneous architecture. Here, you will also work with other
    CI/CD tools than just Azure DevOps. For this, you will learn how to use Azure
    Artifacts for universal packages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种方法是引入包管理。通常，你会发现你希望在新项目中重用以前项目中的代码。与其将代码从一个项目复制粘贴到另一个项目中，不如创建一个共享库。本章将教你如何识别共享组件，并如何使用
    Azure Artifacts 使其可重用。此外，你还将学习如何在异构架构中使用 Azure Artifacts 存储流水线工件。在这里，你还将使用不仅仅是
    Azure DevOps 的其他 CI/CD 工具。为此，你将学习如何使用 Azure Artifacts 来处理通用包。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Identifying shared components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别共享组件
- en: Creating a feed
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个源
- en: Publishing packages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布包
- en: Consuming packages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用包
- en: Working with universal packages
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通用包
- en: Exploring other tools
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索其他工具
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To experiment with the topics mentioned in this chapter, only an Azure DevOps
    organization is required.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要实验本章中提到的主题，仅需要一个 Azure DevOps 组织。
- en: Identifying shared components
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别共享组件
- en: Adopting DevOps practices, such as continuous integration/continuous delivery,
    can greatly reduce the amount of time you have to spend on building and testing
    your applications. Besides building your applications, there are also many other
    concerns that you can address in your pipelines.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 采用 DevOps 实践，例如持续集成/持续交付，可以大大减少构建和测试应用程序所需的时间。除了构建应用程序，还有许多其他问题可以在流水线中解决。
- en: When you start adding more and more tasks to your pipelines, you might run into
    a situation in which a single execution of your pipeline starts taking too long,
    sometimes longer than 5 minutes. Note that this a general recommendation for the
    maximum duration of a CI pipeline. In order to battle this, you might be interested
    in splitting your solution up into smaller builds and maybe even repositories.
    To do this, you could build parts of that application in isolation and then use
    the results of these builds in your main application as ready-built components.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始向流水线中添加越来越多的任务时，你可能会遇到流水线的单次执行开始耗时过长的情况，有时甚至超过 5 分钟。请注意，这是 CI 流水线最大持续时间的一般推荐。为了解决这个问题，你可能会想将解决方案拆分成更小的构建，甚至可能拆分成多个仓库。为此，你可以将应用程序的部分构建隔离开来，然后将这些构建的结果作为现成的组件，使用在主应用程序中。
- en: A general recommendation for the maximum duration of a CI pipeline is 5 minutes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: CI 流水线的最大持续时间的一般推荐为 5 分钟。
- en: 'Another reason for wanting to split your solution into parts is the use of
    shared projects. Imagine that you have two solutions that work closely together:
    one being a REST API and the other being a client package that you ship to your
    customers to work with that API. It is likely that these two solutions share at
    least one project with all the objects that are used for modeling the data that
    is sent back and forth between the two. Here, you could make a third solution
    with only the shared project, which you could then use as a package in your other
    solutions.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 希望将解决方案拆分成多个部分的另一个原因是使用共享项目。假设你有两个紧密协作的解决方案：一个是 REST API，另一个是你发给客户以供与该 API 配合使用的客户端包。这两个解决方案可能至少共享一个项目，其中包含用于建模在两者之间传输的数据的所有对象。在这种情况下，你可以创建一个只有共享项目的第三个解决方案，并将其作为包在其他解决方案中使用。
- en: Or what if you work at a team that is responsible for maintaining a whole series
    of solutions and you find that you have complete namespaces that are copied and
    pasted between these solutions. It is not a desirable situation and one that probably
    comes with a lot of issues. What if you could write this code just once, build
    it, package it, and then reuse it in all of these solutions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您在一个负责维护一系列解决方案的团队工作，并且发现您在这些解决方案之间复制和粘贴了完整的命名空间，这不是一种理想的情况，而且很可能伴随许多问题。如果您只需编写一次这段代码，构建它，打包它，然后在所有这些解决方案中重用它，那会怎样？
- en: 'To summarize, three reasons for starting to work with packages and artifact
    feeds are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，开始使用包和工件喂养的三个原因如下：
- en: Reducing build and CI times by splitting a larger solution into parts
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将较大的解决方案拆分为多个部分来减少构建和 CI 时间
- en: Extracting shared components into packages
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取共享组件到包中
- en: Building packages that are used by other teams
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建由其他团队使用的包
- en: In the remainder of this chapter, you will learn techniques for doing this by
    building packages out of (parts of) your application code, hosting them in a centralized
    location, and reusing them in one or more other solutions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，您将学习通过将（部分）应用程序代码构建为包、将其托管在集中位置，并在一个或多个其他解决方案中重用它们来实现这一目标的技巧。
- en: In all three scenarios, you might be looking to increase the reusability of
    the code, but also to reduce the time taken between checking for a change and
    receiving feedback for that change in the form of automated test results. Before
    you start breaking up your application, remember that moving part of your solution
    to a separate component does not always achieve this.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三种场景中，您可能希望提高代码的可重用性，但也希望减少检查更改与通过自动化测试结果收到反馈之间所花费的时间。在开始拆分应用程序之前，请记住，将应用程序的部分内容移动到一个独立的组件中，并不总能实现这一目标。
- en: If you break your application up into three components and one remaining main
    part, make sure that you can build and test these three components completely
    in isolation, or at least close to 100%. If you cannot test a component of your
    application in isolation, creating a separate repository and build for that component
    will actually increase the time between checking for a change and the moment of
    feedback to you as a developer. Both separate builds might run quicker, but now
    you need to wait for two builds before you receive any feedback.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将应用程序拆分为三个组件和一个剩余的主部分，请确保您可以完全独立构建和测试这三个组件，或者至少接近 100%。如果您不能独立测试应用程序的某个组件，为该组件创建一个独立的仓库和构建实际上会增加检查更改与反馈之间的时间。虽然两个独立的构建可能运行得更快，但现在您需要等待两个构建，才能收到任何反馈。
- en: If you break your application up into separate components, make sure that each
    component can be built and tested in isolation to a high degree.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将应用程序拆分为独立的组件，请确保每个组件可以在高程度上独立构建和测试。
- en: As well as this, you have to make sure that making a reusable component out
    of part of your application makes sense from a conceptual point of view. For example,
    components that are addressing a cross-cutting concern such as logging libraries
    or database abstraction layers are great candidates for factoring out to shared
    libraries. (On a side note, after you have done so, you might also want to consider
    replacing your own general-purpose libraries with off-the-shelf alternatives where
    possible.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还需要确保将应用程序的一部分做成可重用组件从概念上是合理的。例如，解决跨切面问题的组件，如日志库或数据库抽象层，非常适合提取到共享库中。（顺便提一下，在这样做之后，您还可以考虑在可能的情况下用现成的替代品替换您自己的通用库。）
- en: However, if splitting your solution into components makes sense, it can bring
    great benefits.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果将解决方案拆分为组件是合理的，它可以带来巨大的好处。
- en: Types of feeds
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 喂养的类型
- en: 'There are many types of package feeds that can be hosted in Azure Artifacts.
    How you will use an Artifact feed will depend on the language and ecosystem used
    by the application. The following ecosystems are supported in Azure Artifacts:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure Artifacts 中，可以托管多种类型的包喂养。您将如何使用工件喂养取决于应用程序使用的语言和生态系统。Azure Artifacts
    支持以下生态系统：
- en: '**NuGet**: When working with Microsoft .NET languages, the protocol used for
    package management is NuGet.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NuGet**: 在使用 Microsoft .NET 语言时，用于包管理的协议是 NuGet。'
- en: '**npm**: The npm protocol is used when building applications with JavaScript
    or TypeScript.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**npm**: 在使用 JavaScript 或 TypeScript 构建应用程序时，会使用 npm 协议。'
- en: '**Maven or Gradle**: Maven and Gradle are used from the Java ecosystem.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Maven 或 Gradle**：Maven 和 Gradle 用于 Java 生态系统。'
- en: '**Pip and Twine**: When working with Python packages, they can be obtained
    using these protocols.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pip 和 Twine**：在使用 Python 软件包时，可以通过这些协议获取它们。'
- en: '**Universal packages**: Universal packages are not associated with a specific
    ecosystem, but are a generic means for uploading and retrieving packages.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用软件包**：通用软件包与特定的生态系统无关，而是一种通用的上传和检索软件包的方式。'
- en: Whenever a new feed is created, no type needs to be specified. In fact, every
    feed can be accessed using any protocol, even with different protocols over time.
    However, in general, this does not make sense.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每当创建新的 Feed 时，无需指定类型。实际上，每个 Feed 都可以通过任何协议进行访问，甚至可以随着时间的推移使用不同的协议。然而，通常情况下，这种做法并没有太大意义。
- en: Creating a feed
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Feed
- en: 'Once you have identified one or more packages that you want to publish, you
    will need a place to store them. For this, you can use the Azure Artifacts offering.
    The following diagram shows the structural makeup of Azure Artifacts:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了要发布的一个或多个软件包，您需要一个地方来存储它们。为此，您可以使用 Azure Artifacts 提供的服务。以下图表显示了 Azure
    Artifacts 的结构构成：
- en: '![](img/b1ad6c02-14cf-41af-8b66-91ad6f853650.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1ad6c02-14cf-41af-8b66-91ad6f853650.png)'
- en: Within Azure Artifacts, you can create one or more feeds where you can store
    your packages. For each package, you can have multiple versions in a feed. The
    feed is the level on which you can set up authorizations for publishing packages.
    Within a feed, you can create one or more views that you can use for setting up
    authorizations for consuming packages. A specific version of any given package
    can be in more than one view at the same time. The following sections discuss
    all these concepts in more detail.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure Artifacts 中，您可以创建一个或多个 Feed 来存储您的软件包。每个软件包在 Feed 中可以有多个版本。Feed 是您设置发布软件包授权的层级。在一个
    Feed 中，您可以创建一个或多个视图，用于设置软件包消费的授权。任何给定软件包的特定版本可以同时出现在多个视图中。以下部分将更详细地讨论所有这些概念。
- en: Setting up a feed
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Feed
- en: 'Within Azure Artifacts, the feed is the location where your packages are stored.
    Each feed is a separate and fully isolated repository. To create a new feed, follow
    these steps:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure Artifacts 中，Feed 是存储您的软件包的位置。每个 Feed 是一个独立且完全隔离的存储库。要创建一个新的 Feed，请按照以下步骤操作：
- en: 'First, navigate to Azure Artifacts in the menu on the left and then click on
    the Create feed button (partially visible to access the view for creating a new
    feed):'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导航到左侧菜单中的 Azure Artifacts，然后点击“创建 Feed”按钮（部分可见，用于访问创建新 Feed 的视图）：
- en: '![](img/5fdf7dfd-0736-4d9d-b6fa-40ab7c192601.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5fdf7dfd-0736-4d9d-b6fa-40ab7c192601.png)'
- en: Specify a name for the feed. It should not contain any spaces and preferably
    contain only letters and numbers, since it will become part of a URL.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 Feed 指定一个名称。名称不能包含空格，最好仅包含字母和数字，因为它将成为 URL 的一部分。
- en: Next, it is possible to specify the initial settings for visibility. This determines
    which users can view the feed. This will be discussed in more detail later.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您可以指定初始的可见性设置。这将决定哪些用户可以查看该 Feed。稍后会更详细地讨论这个问题。
- en: Configure the use of upstream sources. This will also be covered in more detail
    later.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置使用上游源。这将在后续部分更详细地介绍。
- en: A few seconds after selecting Create, your feed will be available.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“创建”后，几秒钟内您的 Feed 就会可用。
- en: 'Once the feed is created, you can configure various settings such as hiding
    deleted packages, enabling package batches, and configuring retention policies.
    To learn how to do this, follow these steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Feed 后，您可以配置各种设置，如隐藏已删除的软件包、启用软件包批次以及配置保留策略。要了解如何操作，请按照以下步骤进行：
- en: After the feed is created, access the settings for the feed by clicking on the
    gearbox in the top-right corner.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 Feed 后，通过点击右上角的齿轮图标来访问 Feed 的设置。
- en: 'Choose Feed settings in the view shown in the following screenshot. In this
    view, you can configure a few more things:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下图所示的视图中，选择“Feed 设置”。在这个视图中，您可以配置更多设置：
- en: '![](img/8dea9422-70f3-41ee-8569-af19213a4a9a.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8dea9422-70f3-41ee-8569-af19213a4a9a.png)'
- en: Besides changing the name and adding a description, you can choose to hide deleted
    packages. When you do this, versions of a package that have been removed are no
    longer visible to administrators of the feed. Regular users are never able to
    view or use deleted packages, but this setting enables the same view logic as
    administrators.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了更改名称和添加描述外，您还可以选择隐藏已删除的包。这样做后，已删除的包的版本对于订阅的管理员不再可见。普通用户永远无法查看或使用已删除的包，但此设置启用了与管理员相同的视图逻辑。
- en: Another setting you can enable is that of package badges. A package badge is
    a visual element with the name of a package and the latest available version.
    If you enable this option, you can retrieve a URL for each package that will be
    a package badge for that package. This is useful for people who want to keep tabs
    on the latest version of a package.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个可以启用的设置是包徽章。包徽章是一个可视元素，显示包的名称和最新可用版本。如果启用此选项，您可以为每个包检索一个 URL，该 URL 将成为该包的包徽章。这对于希望跟踪包的最新版本的人很有用。
- en: Finally, you can configure a retention policy. Here, you can configure the automated
    removal when the number of versions of a package exceeds a certain threshold.
    While this helps you to save disk space and therefore costs, this can have the
    unintended effect of breaking downstream users of the feed. To put in a safeguard
    against this, you can prevent removing a package for *x* number of days after
    it has been downloaded for the last time. Next to that, keep in mind that any
    package version that is currently a member of a feed will not be removed.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您可以配置保留策略。在这里，您可以配置当包的版本数量超过一定阈值时自动删除。虽然这有助于节省磁盘空间和因此的成本，但可能会意外地影响订阅的下游用户。为了防范此类情况，您可以防止在最后一次下载包后
    *x* 天内删除包。此外，请记住，当前作为订阅成员的任何包版本都不会被删除。
- en: Once done, click on the Save button.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，单击保存按钮。
- en: After you have created and configured your feed, it is time to specify which
    users have access to the feed and what permissions they have. Let's learn how
    to do that next.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和配置订阅后，现在是指定哪些用户可以访问该订阅及其权限的时候了。让我们学习如何进行下一步操作。
- en: Securing access
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问安全
- en: 'There are four roles you can assign to a user or group, where the rights of
    each next role include the rights of the previous roles as well:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为用户或组分配四种角色，其中每个下一个角色的权限都包括前一个角色的权限：
- en: '**Readers** are able to list all packages in a feed and can download them.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读者**能够列出订阅中的所有包，并可以下载它们。'
- en: '**Collaborators** are also able to use packages from upstream sources.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作者**还能够使用上游源中的包。'
- en: '**Contributors** can also publish their own packages and unlist and deprecate
    packages.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**贡献者**还可以发布自己的包，取消列出和弃用包。'
- en: Finally, **owners** have full control over the feed and can also change permissions,
    rename, or delete the feed.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，**所有者**对订阅有完全控制权，还可以更改权限、重命名或删除订阅。
- en: 'To change the permission of a user, follow these steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改用户的权限，请按照以下步骤操作：
- en: 'Navigate to the Permissions view that you can see in the following screenshot. In
    this view, you can see a list of every user or group that has permissions assigned:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到权限视图，您可以在以下截图中看到。在此视图中，您可以查看已分配权限的每个用户或组的列表：
- en: '![](img/1ad71676-4d9d-4e06-a88b-089278359736.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ad71676-4d9d-4e06-a88b-089278359736.png)'
- en: To remove permissions, select the row and click on Delete.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要删除权限，请选择行并单击删除。
- en: To add a new row, click on the add button. This will open the view you see to
    the right.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加新行，请单击添加按钮。这将打开您在右侧看到的视图。
- en: As an alternative to adding users or groups as a reader on the whole feed, it
    is also possible to create one or more views on the feed and set access rights
    per view.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 作为将用户或组添加为整个订阅的读者的替代方案，还可以在订阅中创建一个或多个视图，并针对每个视图设置访问权限。
- en: Managing views on a feed
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理订阅中的视图
- en: A feed is a repository of packages that you can publish and download packages
    to and from. However, there are many cases where you do not want every uploaded
    package to be available for download. Often, you might find that you want to control
    who can use which versions of a package; for example, when you are implementing
    the continuous delivery of a shared library but want to share only stable versions
    with the rest of your organization.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Feed 是一个包的仓库，你可以将包发布到此处，也可以从此处下载包。然而，很多情况下，你可能不希望每个上传的包都可以供下载。通常，你可能希望控制哪些用户可以使用某个包的哪些版本；例如，当你在实现共享库的持续交付时，但希望只与组织中的其他成员共享稳定版本。
- en: To do this, you can create views. A view is a subset of the package versions
    within a feed. When working with a view, as a consumer, it behaves just as if
    it were a feed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，你可以创建视图。视图是 Feed 中包版本的子集。在使用视图时，作为消费者，它的表现就像一个 Feed。
- en: 'Views can be managed as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 视图可以按如下方式进行管理：
- en: 'Navigate and click on Views; you should see something similar to the following
    screenshot:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航并点击“视图”；你应该能看到类似于以下截图的内容：
- en: '![](img/f3c05b59-f7f6-4a4c-ad15-e8aee0c26329.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3c05b59-f7f6-4a4c-ad15-e8aee0c26329.png)'
- en: Here, you can see a list of all the current views and remove any views by selecting
    the row and clicking on Delete.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，你可以看到所有当前视图的列表，并通过选择行并点击“删除”来移除任何视图。
- en: Adding new views can be done using the add button, which opens the view you
    see to the right.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加新视图可以通过使用添加按钮来完成，点击后将打开右侧显示的视图界面。
- en: You can set permissions for reading from a view here as well. You can allow
    read access to your whole Azure DevOps organization, or specify specific users.
    Any user or group you add here will get reader permissions on this view only.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以在这里设置从视图的读取权限。你可以允许整个 Azure DevOps 组织的读取访问权限，或指定特定的用户。你在此添加的任何用户或组将仅在此视图上获得读取权限。
- en: Editing permissions can be done by selecting any row and choosing Edit.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑权限可以通过选择任何一行并选择“编辑”来进行设置。
- en: Once one or more views are available, packages can be promoted to a view for
    consumption through the view.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个或多个视图可用，包可以通过视图进行推广，以供通过该视图使用。
- en: Configuring upstream sources
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置上游源
- en: The final thing that you can configure on your feed is the upstream sources.
    Azure Artifacts feeds give you a repository where you can publish your own packages
    for reuse from one or more locations.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Feed 上配置的最后一项内容是上游源。Azure Artifacts Feed 为你提供了一个仓库，你可以在此发布你自己的包，供其他地方重用。
- en: However, you will probably also use packages that are publicly available on
    repositories such as `NuGet.org` or `npmjs.org`. In this case, you could use a
    combination of an Artifacts feed and `NuGet.org`, but you can also configure your
    feed to serve packages from `NuGet.org` as well. If you do this, `NuGet.org` is
    called an upstream source.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你也可能会使用在像 `NuGet.org` 或 `npmjs.org` 这样的仓库中公开可用的包。在这种情况下，你可以结合使用 Artifacts
    Feed 和 `NuGet.org`，但你也可以配置 Feed 以便从 `NuGet.org` 提供包。如果你这么做，`NuGet.org` 就被称为上游源。
- en: Along with simplicity, this gives you the added benefit of having one central
    location where you can see all the packages you are using in your solution(s).
    This enables you to quickly check which packages and versions you are using, which
    can be useful for compliance or security checks. Using the different permissions
    between the reader and the collaborator role, you can also configure which users
    are authorized to pull packages from `NuGet.org` to your feed, and which users
    are not.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简化操作外，这还带来了一个额外的好处：你可以在一个中央位置查看你在解决方案中使用的所有包。这使你能够快速检查你正在使用哪些包及版本，这对于合规性或安全性检查非常有用。通过在读取者和合作者角色之间设置不同的权限，你还可以配置哪些用户被授权从`NuGet.org`拉取包到你的
    Feed，而哪些用户没有此权限。
- en: 'Of course, you can do this for any repository that is accessible over the internet
    and implements one of the protocols that Azure Artifacts supports. To configure
    upstream sources, follow these steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以对任何通过互联网可访问并实现 Azure Artifacts 支持的协议的仓库执行此操作。要配置上游源，请按照以下步骤进行：
- en: 'Upstream sources can be configured after navigating to the following screen:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导航到以下屏幕后，可以配置上游源：
- en: '![](img/6750b743-bd18-482b-b4ee-297c70e06f8e.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6750b743-bd18-482b-b4ee-297c70e06f8e.png)'
- en: Upstream sources are configured in the same way as permissions and views. You
    can delete upstream sources using the Delete button in the menu bar.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上游源的配置方式与权限和视图相同。你可以使用菜单栏中的“删除”按钮删除上游源。
- en: Adding upstream sources is done by clicking on the Add upstream source button,
    which opens the view on the right.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击“添加上游源”按钮来添加上游源，这将打开右侧视图。
- en: A final thing to note about the use of upstream sources is that it is not possible
    to have the same version of a package published to your own feed if the same version
    of that package is already available in an upstream source.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用上游源的最后一点需要注意的是，如果某个包的相同版本已经在上游源中可用，就无法将该版本的包发布到你自己的源。
- en: This section discussed how to create and connect feeds. Now that these are in
    place, we will learn how to publish packages to those feeds in the next section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了如何创建和连接源。既然这些已经设置好了，接下来我们将学习如何将包发布到这些源。
- en: Publishing packages
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布包
- en: 'Now that you know how to create and manage feeds, it is time to learn how to
    publish packages to them. If you have experience of publishing packages to public
    feeds, you will see that publishing to Azure Artifacts works in precisely the
    same way. There are two ways in which you can publish packages to a feed:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解如何创建和管理源，是时候学习如何将包发布到这些源了。如果你有将包发布到公共源的经验，你会发现发布到 Azure Artifacts 的过程完全相同。有两种方式可以将包发布到源：
- en: Manually from your own computer
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从你自己的电脑手动操作
- en: By using Azure Pipelines
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 Azure Pipelines
- en: Both options are explored in the following sections.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节将探讨这两种选项。
- en: Uploading packages by hand
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动上传包
- en: 'To upload packages by hand, the following steps need to be performed:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 手动上传包时，需要执行以下步骤：
- en: 'First, you will have to retrieve the URL to your feed. To do this, click on
    Connect to feed for any of your feeds, as shown in the following screenshot:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要获取源的 URL。为此，点击任何源的“连接到源”按钮，如下图所示：
- en: '![](img/c7d5dae9-96c6-46f0-84fd-9615cbcb02a6.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7d5dae9-96c6-46f0-84fd-9615cbcb02a6.png)'
- en: In the list on the left, select the protocol to use for accessing the feed.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧列表中，选择用于访问源的协议。
- en: Select the correct view to use. Remember that for publishing packages, the full
    feed URL needs to be used since views are read-only.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择正确的视图进行操作。记住，发布包时需要使用完整的源 URL，因为视图是只读的。
- en: After making the correct selections, copy the correct URL to the clipboard using
    the copy button.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在做出正确选择后，使用复制按钮将正确的 URL 复制到剪贴板。
- en: 'Execute the following command to create a NuGet package from a regular `.csproj`
    file. If you do not have the `NuGet.exe` tool already available, you can download
    it using the link provided at the end of this chapter:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令，从常规的`.csproj`文件创建 NuGet 包。如果你没有`NuGet.exe`工具，可以通过本章末尾提供的链接下载它：
- en: '[PRE0]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Execute the final command for uploading the package to NuGet:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行最终命令，将包上传到 NuGet：
- en: '[PRE1]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After executing the final command, the package will be published and become
    available in your feed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完最后一个命令后，包将被发布并在你的源中可用。
- en: Publishing packages from a pipeline
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从管道发布包
- en: Uploading a package by hand is not a convenient solution if you need to do it
    more than once. In cases where you want to frequently generate and publish a new
    version of a library, you can use an Azure pipeline. As well as to the automation
    that this gives you, it is also a great way to introduce repeatability and reliability,
    since you can now use all of the benefits that pipelines offer you.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要多次上传包，手动上传包并不是一个方便的解决方案。在需要频繁生成并发布新版本库的情况下，你可以使用 Azure 管道。除了提供自动化功能外，它还是一种引入重复性和可靠性的绝佳方式，因为你现在可以充分利用管道所提供的所有好处。
- en: As an example, you can find a possible build definition for creating an `npm`
    package and publishing that as follows. The sources for this build are from an
    open source Microsoft GitHub repository called `tfs-cli`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，你可以找到一个用于创建`npm`包并将其发布的可能构建定义，具体如下。此构建的源来自一个名为`tfs-cli`的开源 Microsoft GitHub
    仓库。
- en: 'In this pipeline, there are three usages of the built-in `npm` task:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个管道中，有三种使用内置`npm`任务的方式：
- en: 'The first occurrence is an `npm install` command. This command is used for
    installing the dependencies for this package:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一次出现的是`npm install`命令。此命令用于安装该包的依赖项：
- en: '![](img/d86d3e0c-40cc-41e1-99d7-dd316a0c7067.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d86d3e0c-40cc-41e1-99d7-dd316a0c7067.png)'
- en: 'The second occurrence is running a custom command, `build`. This command is
    defined in the source code itself using `package.json` and is used for transpiling
    the sources from TypeScript to JavaScript:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个操作是运行自定义命令`build`。该命令在源代码中使用`package.json`定义，用于将源代码从 TypeScript 转换为 JavaScript：
- en: '![](img/35e773ee-03d3-4197-a282-f6e7a5392d48.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35e773ee-03d3-4197-a282-f6e7a5392d48.png)'
- en: 'The final and third task is running the `npm publish` command to publish the
    generated package to an `npm` feed. In this instance, there is no external feed
    selected but a built-in target registry: the Azure Artifacts feed:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，第三个任务是运行`npm publish`命令，将生成的包发布到`npm`源。在此情况下，没有选择外部源，而是选择了一个内置的目标注册表：Azure
    Artifacts 源：
- en: '![](img/dcf02618-730b-44f8-b89a-b60306f80e43.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dcf02618-730b-44f8-b89a-b60306f80e43.png)'
- en: After running this build, your package is available in your feed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此构建后，您的包就可以在您的源中使用了。
- en: Versioning packages
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包版本控制
- en: One of the things that is not done automatically using the tasks for uploading
    an `npm` package, or most types of packages for that matter, is managing the version
    number. Of course, there are many ways in which you can make sure your packages
    have proper versions, but a common approach is setting (part of) the version number
    during the build of a package.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上传`npm`包的任务（或大多数类型的包）时，自动完成的其中一项操作就是管理版本号。当然，确保包有适当版本的方法有很多种，但一种常见的方法是在包构建过程中设置（部分）版本号。
- en: 'Expanding on the `npm` package build that we demonstrated before, three changes
    can be made to the build definition:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展之前我们演示的`npm`包构建，可以对构建定义进行三处更改：
- en: First, the build number format for the build definition is updated to the following: `1.0$(Rev:.rrr)`.
    This guarantees that a unique number is automatically generated for every build.
    The `Ref:.rrr` variable will generate a number with three positions, leading with
    zeros if needed. The first time, this number will be `000`, and it will increase
    by one every time the rest of the build number is not changed.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，构建定义的构建号格式更新为：`1.0$(Rev:.rrr)`。这确保每次构建都会自动生成一个唯一的编号。`Ref:.rrr`变量将生成一个三位数的编号，必要时以零为前缀。第一次生成的编号将是`000`，每次构建号其余部分未更改时，编号将增加
    1。
- en: Second, a task is added to replace the version number that is currently specified
    in the source control, using the `{#Build.BuildNumber#}` token. This is a reference
    to the build variable with the name `Build.BuildNumber`, which contains the build
    number that was specified in *step 1*.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，添加一个任务，用`{#Build.BuildNumber#}`令牌替换当前在源控制中指定的版本号。这个令牌引用了名为`Build.BuildNumber`的构建变量，它包含在*步骤
    1*中指定的构建编号。
- en: 'Finally, a Replace Tokens task is added to the build before all other tasks.
    A possible configuration to replace the magic fixed-version number with the automatic
    version number for this task is shown as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在所有其他任务之前，构建中添加了一个替换令牌任务。以下是替换魔术固定版本号为自动版本号的任务配置示例：
- en: '![](img/b3b8b1b1-e1a5-4841-bd44-c64708fc484b.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3b8b1b1-e1a5-4841-bd44-c64708fc484b.png)'
- en: This task can be configured to replace the tokens in one or more target files
    (*1*). It will look for any series of characters starting with `{#` and ending
    in `#}`, take the text between these two markers, and then replace the whole text
    with the value of the corresponding variable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 该任务可以配置为替换一个或多个目标文件中的令牌(*1*)。它会查找任何以`{#`开头、以`#}`结尾的字符序列，提取这两个标记之间的文本，然后用对应变量的值替换整个文本。
- en: With this in place, every package that is built using the definition will have
    a unique and ever-increasing patch version number. Whenever the major or minor
    version number needs to be updated, this can be done by updating the build number
    format.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此设置，使用定义构建的每个包都将拥有唯一且不断增长的修订版本号。每当需要更新主版本或次版本号时，可以通过更新构建号格式来完成。
- en: As an alternative to this approach, there are many tasks available from the
    extensions marketplace that can help with versioning, including more complex scenarios.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这种方法的替代方案，扩展市场上提供了许多任务，可以帮助管理版本控制，包括更复杂的场景。
- en: This section discussed how to publish packages to a feed. With packages published
    to a feed, the next section will detail how these can be used with either Visual
    Studio or an Azure Pipeline.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了如何将包发布到源中。将包发布到源后，下一节将详细说明如何在 Visual Studio 或 Azure Pipeline 中使用这些包。
- en: Consuming packages
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费包
- en: Uploading packages to an Azure Artifacts feed or repository makes them available
    for use in many different scenarios. Two common scenarios are using your own packages
    with Visual Studio or from Azure Pipelines. Both scenarios will be detailed in
    the following sections.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将软件包上传到 Azure Artifacts 源或仓库，使它们在许多不同的场景中可供使用。两个常见的场景是使用您的软件包与 Visual Studio
    或 Azure Pipelines。接下来的部分将详细介绍这两个场景。
- en: Consuming packages from Visual Studio
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Visual Studio 使用软件包
- en: Once you have your shared libraries available as NuGet packages in an Azure
    Artifacts feed, you can start using them from Visual Studio. Before you can do
    this, you will have to register your feed in your Visual Studio instance.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的共享库作为 NuGet 软件包存在于 Azure Artifacts 源中，您就可以开始在 Visual Studio 中使用它们。在此之前，您需要在
    Visual Studio 实例中注册您的源。
- en: 'To do this, you first have to grab the URL of your feed. In order to do this,
    refer to the *Uploading packages by hand* section. Once you have your URL ready,
    go to manage NuGet files for your solution, as you would do normally. If you are
    not familiar with working with NuGet packages in Visual Studio, you can find this
    option in the solution explorer on the solution and project headers:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，您首先需要获取您的源的 URL。为此，请参考 *手动上传软件包* 部分。一旦您准备好 URL，请像平常一样去管理您解决方案中的 NuGet 文件。如果您不熟悉如何在
    Visual Studio 中使用 NuGet 软件包，您可以在解决方案资源管理器中找到此选项，在解决方案和项目头部：
- en: '![](img/46845a03-ffff-4830-9481-2c2566c214e9.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46845a03-ffff-4830-9481-2c2566c214e9.png)'
- en: 'Once you are here, walk through the following steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您到达这里，请按照以下步骤操作：
- en: Click on the small gearbox in the top-right corner to open the dialog where
    you can configure which NuGet feeds to use.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右上角的小齿轮按钮，打开对话框，在其中您可以配置使用哪些 NuGet 源。
- en: Add a new feed.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新源。
- en: Fill in both the name and the source of your own feed.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写您自己源的名称和来源。
- en: After doing so, do not forget to click on Update; otherwise, your changes to
    the Name and Source fields will not be saved and there will be no warning prompting
    you that you have unsaved changes.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，不要忘记点击更新；否则，您对名称和来源字段的更改将不会被保存，而且不会有任何提示警告您存在未保存的更改。
- en: After you have made these changes, you can now select your feed as the package
    source in the top right of the screen.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行这些更改之后，您现在可以在屏幕右上角选择将您的源作为软件包来源。
- en: From here onward, it is possible to work with these packages from your own feed
    just as you do with packages from `NuGet.org`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，您就可以像使用 `NuGet.org` 的软件包一样，使用来自您自己源的软件包。
- en: Consuming packages from a pipeline
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从管道中使用软件包
- en: Once you start using your packages in Visual Studio, it is very likely you will
    need them in Azure Pipelines as well. This is in order to perform CI/CD on the
    dependent application that uses your packages.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开始在 Visual Studio 中使用您的软件包，您很可能还需要在 Azure Pipelines 中使用它们。这样做是为了对依赖您的软件包的应用程序执行
    CI/CD。
- en: 'Fortunately, this can be achieved with a small configuration change on your
    NuGet restore task, as shown in the following screenshot. The following screenshot
    relates to the NuGet restore task that can be used with both the Visual Studio
    build tasks and the .Net Core build tasks. Both contain the same interface and
    can be used in the same way:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，您可以通过对 NuGet 恢复任务进行小的配置更改来实现这一点，如下图所示。以下截图涉及的是 NuGet 恢复任务，这个任务既可以与 Visual
    Studio 构建任务一起使用，也可以与 .Net Core 构建任务一起使用。两者的界面相同，可以以相同的方式使用：
- en: '![](img/81fed0eb-03ff-4db1-8001-2c0521612bb7.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/81fed0eb-03ff-4db1-8001-2c0521612bb7.png)'
- en: By default, only the radio button for using packages from NuGet is checked;
    so, to include packages from your own feeds as well, you need to select the correct
    feed in the drop-down list.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，仅选中了使用来自 NuGet 的软件包的单选按钮；因此，要同时包含来自您自己源的软件包，您需要在下拉列表中选择正确的源。
- en: If you ever find the need to include packages from more than one feed, you will
    be forced to create one aggregator feed and use the other feeds as upstream sources
    for that aggregator feed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要从多个源中包含软件包，您将不得不创建一个聚合源，并使用其他源作为该聚合源的上游源。
- en: This section covered how to consume component packages from Visual Studio. The
    next section will dive into working with universal packages for sharing general
    binary packages.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了如何从 Visual Studio 使用组件软件包。下一节将深入探讨如何使用通用软件包来共享通用的二进制软件包。
- en: Working with universal packages
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用通用软件包
- en: The previous sections have all concentered on using Azure Artifacts as a means
    for redistributing application packages such as libraries or other shared components.
    However, there is also another important use of Azure Artifacts, which is using
    a feed for storing any type of binary package. These are called universal packages.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的章节都集中在使用 Azure Artifacts 作为重新分发应用程序包（例如库或其他共享组件）的方式。然而，Azure Artifacts 还有一个重要用途，即使用源来存储任何类型的二进制包，这些包被称为通用包。
- en: Since a universal packages feed can be used to store any type of package, this
    makes it a good choice for storing build artifacts if you are working with more
    than one CI/CD tool. In this case, you can use universal packages for storing
    and serving your build artifacts to and from whichever tool you are using at that
    time. This can be particularly useful since the built-in storage for classic build
    and release pipelines cannot be accessed by other tools.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于通用包源可以用于存储任何类型的包，因此如果您使用多个 CI/CD 工具，它是存储构建产物的好选择。在这种情况下，您可以使用通用包来存储并提供构建产物，以便随时从您使用的工具进行获取。这特别有用，因为经典构建和发布管道的内置存储无法被其他工具访问。
- en: 'To use universal packages for staging your build artifacts in such a heterogeneous
    architecture, there are four basic operations you should understand: uploading
    and downloading universal packages from an Azure pipeline and uploading and downloading
    universal packages using the Azure CLI. The last one you can invoke from other
    tools.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要在异构架构中使用通用包来暂存构建产物，您需要理解四个基本操作：从 Azure pipeline 上传和下载通用包，以及使用 Azure CLI 上传和下载通用包。最后一个操作可以从其他工具中调用。
- en: Uploading and downloading universal packages from Azure Pipelines
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Azure Pipelines 上传和下载通用包
- en: Uploading build artifacts to a universal packages feed works in a similar way
    as uploading a regular build artifact. There are two changes you need to consider.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将构建产物上传到通用包源的方式与上传常规构建产物类似。您需要考虑两个更改。
- en: Firstly, you have to use another task for performing the upload. Instead of
    using the *publish build artifact* or *publish pipeline artifact* tasks, you have
    to use the task named Universal Packages. When using this task, you can still
    give a name to the artifact and specify a location on the filesystem of the build
    agent to upload it from. Next, you can specify a target feed and a version to
    use. This version can be either automatically incremented whenever a new package
    is uploaded or be specified using a build variable.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您必须使用另一个任务来执行上传。您不能再使用*发布构建产物*或*发布管道产物*任务，而需要使用名为“通用包”的任务。在使用此任务时，您仍然可以为产物命名，并指定从构建代理的文件系统上传它的位置。接下来，您可以指定目标源和版本。此版本可以在每次上传新包时自动递增，或者使用构建变量来指定。
- en: Secondly, you have to consider the fact that the uploaded package is not associated
    one-to-one with the build that produced it—as it is with regular build or pipeline
    artifacts. This means that no matter where you are using the package that has
    been uploaded, you have to find another way to find the correct version to download.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，您需要考虑上传的包与产生它的构建之间不是一对一关联的—与常规构建或管道产物不同。这意味着无论您在哪里使用已上传的包，都需要找到另一种方法来找到正确的版本进行下载。
- en: 'To perform the actual download, you can use the Universal Packages task again,
    as shown in the following screenshot:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行实际的下载，您可以再次使用通用包任务，如下截图所示：
- en: '![](img/da1afaf8-384a-4b16-9d05-772895c51fab.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da1afaf8-384a-4b16-9d05-772895c51fab.png)'
- en: 'Refer to the screenshot and follow these steps:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考截图并按照以下步骤操作：
- en: After adding the task, you can toggle it between upload and download.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加任务后，您可以在上传和下载之间切换。
- en: You can also specify a directory that is uploaded as the artifact.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以指定一个目录，将其作为产物上传。
- en: Or you can specify where the artifact should be downloaded.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，您可以指定下载产物的位置。
- en: Furthermore, the name of the feed needs to be specified.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，需要指定源的名称。
- en: Also, specify the name of the package.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，指定包的名称。
- en: Specify the version to be either upload or download.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定版本以决定是上传还是下载。
- en: Note that you can also use feeds that are not part of your own organization
    by choosing to use another feed at step *5*. If you do so, you need to create
    a service endpoint for reaching that feed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您还可以通过选择在第*5*步使用其他源来使用非自己组织的源。如果这样做，您需要创建一个服务终端以访问该源。
- en: Uploading and downloading universal packages using the Azure CLI
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Azure CLI 上传和下载通用包
- en: 'When you want to work with universal packages from a product other than Azure
    Pipelines, you will have to use the Azure CLI. To do this, perform the following
    steps:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当您希望与 Azure Pipelines 以外的产品一起使用通用包时，您必须使用 Azure CLI。为此，执行以下步骤：
- en: The first thing you have to do to work with universal packages using the Azure
    CLI is to install the CLI itself. The link to the CLI can be found at the end
    of this chapter.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Azure CLI 操作通用包的第一步是安装 CLI 本身。CLI 的链接可以在本章末尾找到。
- en: 'Next, it is time to install the extension for Azure DevOps. This can be done
    using the following command:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是安装 Azure DevOps 扩展。可以使用以下命令来进行安装：
- en: '[PRE2]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After making the extension for Azure DevOps available, you have to log in using
    the account that you also use to work within the Azure DevOps UI. You can log
    in by giving the following command:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Azure DevOps 扩展后，您需要使用与 Azure DevOps UI 中相同的账户进行登录。您可以通过以下命令登录：
- en: '[PRE3]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once logged in, you can upload a file as an artifact using the following command:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，您可以使用以下命令将文件作为构件上传：
- en: '[PRE4]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To download a particular version of an artifact again, you can use the following:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要重新下载特定版本的构件，您可以使用以下命令：
- en: '[PRE5]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using the CLI and these commands, you can use Azure Artifacts as a means for
    sharing build artifacts between multiple tools. When working with a number of
    tools on the same project, Universal Packages are a great tool for moving binaries
    around.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CLI 和这些命令，您可以将 Azure Artifacts 作为多工具之间共享构建构件的手段。当在同一项目中使用多个工具时，通用包是移动二进制文件的好工具。
- en: In the next section, other tools available for package management will be explored.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分中，将探讨用于包管理的其他可用工具。
- en: Exploring other tools
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索其他工具
- en: There are many other tools available for doing binary management. Three commonly
    used products are MyGet, Artifactory, and **Azure Container Registry** (**ACR**).
    The features they deliver do overlap, but they also have specific points at which
    they excel.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他工具可用于二进制管理。三种常用的产品是 MyGet、Artifactory 和 **Azure 容器注册表** (**ACR*)。它们提供的功能有重叠，但也有它们在特定方面的优势。
- en: MyGet
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MyGet
- en: MyGet is an alternative location for hosting your NuGet packages. MyGet allows
    you to create both public and private feeds that are managed by you. MyGet also
    supports defining upstream sources and delivers built-in dependency scanning to
    give you continuous feedback on the level of security of your dependencies.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: MyGet 是托管 NuGet 包的另一种选择。MyGet 允许您创建公共和私人包源，并由您自己管理。MyGet 还支持定义上游源，并提供内置的依赖项扫描功能，能够持续反馈依赖项的安全级别。
- en: Since MyGet is an implementation of the NuGet protocol, you can publish and
    use packages using the default NuGet tasks from Azure Pipelines.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 MyGet 是 NuGet 协议的实现，您可以使用 Azure Pipelines 的默认 NuGet 任务发布和使用包。
- en: Artifactory
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Artifactory
- en: Artifactory, a product by JFrog, is another tool that you can use for hosting
    your package feeds. Artifactory is originally an on-premises product, but it is
    now also available as a SaaS offering. Just like Azure Artifacts, it supports
    multiple protocols for interacting with package feeds. At the time of writing,
    Artifactory supports more repository protocols than Azure Artifacts. Examples
    of this include PHP Composer and **Red Hat Package Manager** (**RPM**).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Artifactory 是 JFrog 提供的另一款工具，您可以用它来托管您的包源。Artifactory 最初是一个本地产品，但现在也作为 SaaS
    服务提供。与 Azure Artifacts 一样，它支持与包源交互的多种协议。撰写本文时，Artifactory 支持比 Azure Artifacts
    更多的仓库协议。例如，PHP Composer 和 **Red Hat 包管理器** (**RPM*)。
- en: JFrog has published an Azure Pipelines extension for downloading and uploading
    packages.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: JFrog 已发布一个用于下载和上传包的 Azure Pipelines 扩展。
- en: Azure Container Registry
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure 容器注册表
- en: Another type of storage for reusable packages is ACR. ACR is designed specifically
    for container images and has an understanding of the layered buildup of these
    images. This allows it to receive only partial uploads when a new version of an
    image becomes available if not all of the layers have changed. This makes ACR
    a very good location for storing container images. Uploads will be faster and
    ACR storage is cheaper than Azure Artifacts storage. This is a big benefit since
    container images can be large.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种用于存储可重用包的存储类型是 ACR。ACR 专为容器镜像设计，能够理解这些镜像的分层构建。这使得它能够在镜像的新版本可用时，仅在部分层发生变化时接收部分上传。这使得
    ACR 成为存储容器镜像的非常好的位置。上传将更快，且 ACR 存储比 Azure Artifacts 存储更便宜。这是一个巨大的优势，因为容器镜像可能非常大。
- en: You can integrate with ACR from Azure Pipelines using the Docker integration
    extensions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 Docker 集成扩展从 Azure Pipelines 集成 ACR。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you learned how to identify shared components in your solutions:
    pieces of code that appear not only in multiple locations but are also logical
    units for reuse. You learned how to use Azure Artifacts feeds for hosting packages
    that contain these libraries. Furthermore, you learned how to use these hosted
    packages to build dependent solutions using both Visual Studio and Azure Pipelines.
    You also learned about using universal packages to share build artifacts between
    Azure Pipelines and other tools that you might use for CI/CD.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何识别解决方案中的共享组件：这些是不仅出现在多个位置，而且是逻辑上可重用的代码单元。你还学习了如何使用 Azure Artifacts
    源来托管包含这些库的包。此外，你学习了如何使用这些托管的包，通过 Visual Studio 和 Azure Pipelines 构建依赖的解决方案。你还了解了如何使用通用包在
    Azure Pipelines 和你可能使用的其他 CI/CD 工具之间共享构建工件。
- en: With this knowledge, you will now be able to identify shared components in your
    solution(s). Once you have identified such a component, you will also be able
    to isolate it in source control, build it, and publish it to an artifact feed.
    From here, you can distribute it to one or more consuming solutions. Finally,
    you are now also capable of using Artifact feeds for sharing build artifacts between
    different CI/CD products.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些知识，你现在将能够识别解决方案中的共享组件。一旦你识别出这样的组件，你还可以将其隔离在源代码管理中，构建它，并将其发布到工件源。然后，你可以将其分发到一个或多个消费解决方案中。最后，你现在还可以使用工件源在不同的
    CI/CD 产品之间共享构建工件。
- en: In the next chapter, you will learn about infrastructure and configuration as
    code. This is one of the fundamental DevOps practices that allows you to have
    your infrastructure definition in source control and use that as part of your
    release pipeline.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习基础设施和配置作为代码。这是 DevOps 的一项基本实践，它允许你将基础设施定义存储在源代码管理中，并将其作为发布管道的一部分使用。
- en: Questions
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the Appendix:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在总结时，以下是一些问题，用于测试你对本章内容的理解。你将在附录的*评估*部分找到答案：
- en: 'True or false: Any version of a package can be deployed to only one view within
    a feed.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断对错：任何版本的包只能部署到源中的一个视图。
- en: 'True or false: Pipeline artifacts can be used for sharing build outcomes (packages)
    from Azure DevOps to other products.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断对错：管道工件可以用于将 Azure DevOps 中的构建结果（包）共享到其他产品中。
- en: 'True or false: Azure Artifact feeds with universal packages can be used for
    sharing build outcomes (packages) from Azure DevOps to other products.'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断对错：带有通用包的 Azure Artifact 源可以用于将 Azure DevOps 中的构建结果（包）共享到其他产品中。
- en: Which of the following is needed to enable building a solution that uses packages
    from an Azure Artifacts feed in Visual Studio? (You can select more than one option.)
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项是为了在 Visual Studio 中构建使用 Azure Artifacts 源中包的解决方案所需的？（你可以选择多个选项。）
- en: Adding the full package URL to your project dependencies, instead of only the
    package name
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将完整的包 URL 添加到项目依赖项中，而不仅仅是包名称
- en: Having at least *reader* access to the feed or one of the views in the feed
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少具有*读取者*访问权限，或者具有源中的某个视图访问权限
- en: Having at least *consumer* access to the feed
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少具有*消费者*访问权限
- en: Configuring the location of the feed as a package source for Visual Studio
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将源的位置配置为 Visual Studio 的包源
- en: What can be the motivators for splitting a solution into multiple parts that
    are separated by Azure Artifacts feeds?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将解决方案拆分成多个通过 Azure Artifacts 源分隔的部分的动机是什么？
- en: Further reading
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: Exercises for practicing with Azure DevOps Artifacts can be found at [https://docs.microsoft.com/en-us/learn/modules/manage-build-dependencies/](https://docs.microsoft.com/en-us/learn/modules/manage-build-dependencies/).
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于练习Azure DevOps Artifacts的练习可以在[https://docs.microsoft.com/en-us/learn/modules/manage-build-dependencies/](https://docs.microsoft.com/en-us/learn/modules/manage-build-dependencies/)找到。
- en: You can find and download `NuGet.exe` from [https://www.nuget.org/downloads](https://www.nuget.org/downloads).
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以从[https://www.nuget.org/downloads](https://www.nuget.org/downloads)找到并下载`NuGet.exe`。
- en: Information on downloading and installing the Azure CLI can be found at [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest).
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载和安装Azure CLI的信息可以在[https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest)找到。
- en: More information about MyGet is available at [https://www.myget.org/](https://www.myget.org/).
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于MyGet的更多信息，请访问[https://www.myget.org/](https://www.myget.org/)。
- en: More information about JFrog Artifactory is available at [https://jfrog.com/artifactory/](https://jfrog.com/artifactory/),
    and the extension for Azure Pipelines can be found at [https://marketplace.visualstudio.com/items?itemName=JFrog.jfrog-artifactory-vsts-extension](https://marketplace.visualstudio.com/items?itemName=JFrog.jfrog-artifactory-vsts-extension).
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于JFrog Artifactory的更多信息，请访问[https://jfrog.com/artifactory/](https://jfrog.com/artifactory/)，Azure
    Pipelines的扩展可以在[https://marketplace.visualstudio.com/items?itemName=JFrog.jfrog-artifactory-vsts-extension](https://marketplace.visualstudio.com/items?itemName=JFrog.jfrog-artifactory-vsts-extension)找到。
- en: More information about ACR is available at [https://azure.microsoft.com/en-in/services/container-registry/](https://azure.microsoft.com/en-in/services/container-registry/).
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关ACR的更多信息，请访问[https://azure.microsoft.com/en-in/services/container-registry/](https://azure.microsoft.com/en-in/services/container-registry/)。
- en: You can find the Docker extensions for Azure Pipelines at [https://marketplace.visualstudio.com/items?itemName=ms-vscs-rm.docker](https://marketplace.visualstudio.com/items?itemName=ms-vscs-rm.docker).
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在[https://marketplace.visualstudio.com/items?itemName=ms-vscs-rm.docker](https://marketplace.visualstudio.com/items?itemName=ms-vscs-rm.docker)找到适用于Azure
    Pipelines的Docker扩展。
