- en: Dealing with Databases in DevOps Scenarios
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 DevOps 场景中处理数据库
- en: 'In the previous chapters, you have learned about the continuous integration
    and continuous deployment of your software. You also learned how the same principles
    can be applied to the delivery of configuration in infrastructure. Once you have
    adopted these principles and start increasing the flow of value delivery, you
    might run into another challenge: managing your database schema changes.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，您已经学习了软件的持续集成和持续部署。您还学到了如何将相同的原则应用于基础设施配置的交付。一旦您采用了这些原则并开始增加价值交付的流动，您可能会遇到另一个挑战：管理数据库模式的变更。
- en: Applying DevOps to databases can feel like trying to change the tires on a running
    car. You must find some way of coordinating changes between database schema and
    application code without taking the system down for maintenance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 将 DevOps 应用于数据库可能感觉像是在开动的汽车上更换轮胎。你必须找到某种方法，在不让系统停机维护的情况下，协调数据库模式和应用程序代码之间的更改。
- en: 'In this chapter, you will learn about different approaches for doing just that:
    managing these schema changes while avoiding downtime. With proper planning and
    a disciplined approach, this can be achieved in a way that manages risks well.
    You will see how you can treat your database schema as code, and you will learn
    about the different approaches that are available to do so. You will also see
    another approach that avoids database schemas altogether, namely, going schema-less.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解几种不同的方法来实现这一点：管理这些模式变更并避免停机。通过适当的规划和严格的方法，可以以良好的风险管理方式实现这一目标。您将看到如何将数据库模式视为代码，并将了解可用的不同方法。您还将看到另一种完全避免使用数据库模式的方法，即无模式化。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Managing a database schema as code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据库模式作为代码进行管理
- en: Applying database schema changes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用数据库模式更改
- en: Going schema-less
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无模式化
- en: Other approaches and concerns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他方法和问题
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to practice the ideas that are laid out in this chapter, you will
    need to have the following tools installed:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实践本章中阐述的思想，您需要安装以下工具：
- en: An application with the Entity Framework Core NuGet package installed
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个安装了 Entity Framework Core NuGet 包的应用程序
- en: Visual Studio with SQL Server Data Tools
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配备 SQL Server 数据工具的 Visual Studio
- en: Access to Azure Pipelines
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 Azure Pipelines
- en: An Azure subscription, for accessing Cosmos DB
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Azure 订阅，用于访问 Cosmos DB
- en: Managing a database schema as code
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据库模式作为代码进行管理
- en: For those of you who are familiar with working with relational databases from
    application code, it is very likely they have been working with an **object-relational
    mapper** (**ORM**). ORMs were introduced to fill the impedance mismatch between
    object-oriented programming languages and the relational database schema, which
    works with tables. Well-known examples are Entity Framework and NHibernate.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些熟悉通过应用程序代码与关系数据库交互的用户来说，很可能他们已经在使用**对象关系映射器**（**ORM**）。ORM 的出现是为了填补面向对象编程语言与使用表格的关系数据库模式之间的阻抗不匹配。知名的例子有
    Entity Framework 和 NHibernate。
- en: ORMs provide a layer of abstraction that allows for the storage and retrieval
    of objects from a database, without worrying about the underlying table structure
    when doing so. To perform automated mapping of objects to tables, or the other
    way around, ORMs often have built-in capabilities for describing a database schema,
    the corresponding object model, and the mappings between them in a markup language.
    Most of the time, neither of these have to be written by hand. Often, they can
    be generated from an object model or an existing database, and the mappings between
    them are often, by convention, generated or drawn in a visual editor.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 提供了一个抽象层，允许从数据库中存储和检索对象，而不必担心底层的表结构。为了自动将对象映射到表，或反向操作，ORM 通常内建有描述数据库模式、相应对象模型及其之间映射的功能，这些通常使用标记语言来实现。大多数情况下，这些内容不需要手动编写。它们通常可以从对象模型或现有数据库中生成，并且它们之间的映射通常通过约定生成或在可视化编辑器中绘制。
- en: While all this allows for the current database schema to be defined as code,
    this alone does not help with coping with schema changes, yet. For handling schema
    changes as code, two common approaches are available. The first one describes
    every change in code; the other one describes only the latest version of the schema
    in code. These approaches are known as migration-based and state-based approaches.
    Both can rely on third-party tooling to use these for applying the changes to
    the database.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些方法允许当前的数据库模式以代码的形式定义，但单靠这些方法尚不足以应对模式变化。为了将模式变化作为代码进行处理，有两种常见的方法。一种是在代码中描述每一个变化；另一种只在代码中描述最新版本的模式。这些方法分别被称为基于迁移和基于状态的方法。两者都可以依赖第三方工具，将这些变化应用到数据库中。
- en: Migrations
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移
- en: The first approach is based on keeping an ordered set of changes that have to
    be applied to the database. These changes are often called *migrations*, and they
    can be generated by tools such as Microsoft Entity Framework, or Redgate SQL Change
    Automation, or they can be written by hand.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法基于保持一组必须应用于数据库的有序变更。这些变更通常被称为*migrations*，可以由工具生成，如Microsoft Entity Framework、Redgate
    SQL Change Automation，或者可以手动编写。
- en: 'Tools can automatically generate the migration scripts based on a comparison
    of the current schema of the database and the new schema definition in source
    control. This is called **scaffolding**. The scripts generated by tools are not
    always perfect, and they can be improved by applying the domain knowledge that
    the programmer has, but the tool does not. Once one or more new migrations are
    scaffolded or written, they can be applied to a database using the chosen tool.
    A diagram showing how that works is shown here:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 工具可以基于当前数据库模式与源代码控制中新的模式定义的比较，自动生成迁移脚本。这被称为**脚手架生成**。工具生成的脚本并不总是完美的，它们可以通过程序员所掌握的领域知识进行改进，但工具本身没有这些知识。一旦一个或多个新的迁移被脚手架生成或手动编写，它们就可以通过所选工具应用到数据库中。下面是一个展示这一过程的图示：
- en: '![](img/f7b921f8-9d80-4f1c-a2f4-18aabca2489b.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7b921f8-9d80-4f1c-a2f4-18aabca2489b.png)'
- en: Here, we see how an ever-growing series of migrations, labeled m1 to m4, are
    generated to describe incremental changes to the database. To update the database
    to the latest version, the latest applied migration is determined and all migrations
    after that are added one after the other.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一系列不断增长的迁移（从m1到m4），用于描述数据库的增量变化。为了将数据库更新到最新版本，需要确定已应用的最新迁移，并依次添加其后所有的迁移。
- en: 'When editing migration scripts by hand, the following has to be kept in mind:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在手动编辑迁移脚本时，必须记住以下几点：
- en: The migration scripts should be ordered. Migrations describe the SQL statements
    that need to be executed in order to move the database from a version *x* to version
    *x+1*. Only once this is complete can the next migration be started.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移脚本应当是有序的。迁移描述了需要执行的SQL语句，以便将数据库从版本*x*迁移到版本*x+1*。只有当这一过程完成后，才能开始下一个迁移。
- en: A migration script should migrate not only the schema, but also the data. This
    can mean that in-between steps are needed. For example, moving two columns to
    another table often implies that the new columns are first created, then filled
    with the data from the old columns, and that only then are the old columns removed.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个迁移脚本不仅应迁移模式，还应迁移数据。这可能意味着需要一些中间步骤。例如，将两列数据移动到另一个表通常意味着先创建新的列，然后将旧列的数据填充到新列中，最后才删除旧列。
- en: It is advisable to include all database objects in the migration scripts. Extra
    indexes and constraints should not be applied to the production database only,
    but also to test environments. With migrations, there is already a mechanism for
    delivering those from source control. Having these in the same migration scripts
    also ensures that indexes and constraints are applied in the same order, and cannot
    unexpectedly block migrations by existing only in production.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议在迁移脚本中包含所有数据库对象。额外的索引和约束不应仅应用于生产数据库，还应应用于测试环境。使用迁移时，已经有机制可以将这些内容从源代码控制传送过去。将它们包含在相同的迁移脚本中，也确保了索引和约束按相同的顺序应用，避免了它们只存在于生产环境中而意外阻塞迁移的情况。
- en: If possible, migration scripts should be made idempotent. If there is ever an
    issue or the suspicion of an issue, being able to just rerun the last migration
    is a great way to ensure that it is fully applied.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能，迁移脚本应保持幂等性。如果出现问题或怀疑出现问题，能够重新执行最后一个迁移是确保其完全应用的一个好方法。
- en: 'One disadvantage of this approach is the strict ordering requirement that is
    imposed on generating and applying the generated migrations. This makes it hard
    to integrate this approach into a development workflow that relies heavily on
    the use of branches. Migrations created in different branches that are merged
    together only later might break the ordering of migrations or, even worse, merge
    a split in the migration path. For example, imagine the case where two migrations, *b*
    and *c*, in two different branches, have been created after an existing migration,
    *a*. How are these going to be merged? Neither order—*a, b, c* or *a, c, b—*is
    correct, since both *b* and *c* are created to be executed directly after *a.*
    The only way such an error can be fixed is by performing the following steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个缺点是，生成和应用迁移脚本时对顺序的严格要求。这使得将这种方法集成到依赖分支使用的开发工作流中变得困难。不同分支中创建的迁移在合并后可能会破坏迁移的顺序，或者更糟糕的是，合并迁移路径的分裂。例如，假设在现有迁移*a*之后，在两个不同的分支中创建了两个迁移*b*和*c*。这两个迁移如何合并？无论是按顺序应用*a,
    b, c* 还是 *a, c, b* 都不正确，因为*b*和*c*都是在*a*之后直接执行的。修复此类错误的唯一方法是执行以下步骤：
- en: Remove all migrations apart from the first new one, for example, *c* in this
    case.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了第一个新迁移（例如，在此情况下为*c*）之外，删除所有其他迁移。
- en: Apply all other migrations to a database that has none of the new migrations
    applied; in this case, only *b* if *a* was already applied, or both *a* and *b*.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有其他迁移应用于没有应用任何新迁移的数据库；在这种情况下，如果*a*已经应用，则只需应用*b*，或者同时应用*a*和*b*。
- en: Generate a new migration for the other migrations; in this case, a replacement
    for *c.*
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为其他迁移生成一个新的迁移；在这种情况下，*c*的替代。
- en: An advantage of this approach is that every individual schema change will be
    deployed against the database in the same fashion. Irrespective of whether one—or
    more than one—migration is applied to the production database at the same time,
    they will still run one by one in a predictable order and in the same way in which
    they ran against the test environment, even if they were applied there one by
    one.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个优点是，每个单独的模式变更都会以相同的方式部署到数据库中。无论一个或多个迁移是否同时应用于生产数据库，它们仍然会按可预测的顺序一个接一个地执行，并且与它们在测试环境中运行的方式相同，即使它们是逐个应用的。
- en: End state
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结束状态
- en: A different approach to managing schema changes is to not keep track of the
    individual changes (or migrations), but only store the latest version of the schema
    in source control. External tools are then used to compare the current schema
    in source control with the actual schema of the database, generate migration scripts,
    and apply these when running. The migration scripts are not stored, and are single-use
    only.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 管理模式变更的另一种方法是，不跟踪单个变更（或迁移），而是仅将模式的最新版本存储在源代码管理中。然后使用外部工具将源代码管理中的当前模式与数据库的实际模式进行比较，生成迁移脚本，并在运行时应用这些脚本。迁移脚本不会被存储，并且仅用于一次。
- en: 'Unlike writing migrations, it is not feasible to execute a task like this by
    hand. While tracking the newest version of the schema by hand in source control
    can be managed, the same is not feasible for an end-state approach. Generating
    a migration script while comparing the existing schema and the new schema and
    applying this migration script can only be done using a tool. Examples of these
    tools are Redgate SQL Source Control and SQL Server Data Tools. How these tools
    work, is shown in the here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与编写迁移不同，手动执行此类任务是不可行的。虽然手动在源代码管理中跟踪最新版本的模式是可以管理的，但对于结束状态方法则不可行。在比较现有模式和新模式时生成迁移脚本并应用该迁移脚本只能通过工具完成。这些工具的例子包括Redgate
    SQL源代码控制和SQL Server数据工具。如何使用这些工具，在此展示：
- en: '![](img/9bdb8efd-8b7a-43a1-9754-eeaa31b91458.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9bdb8efd-8b7a-43a1-9754-eeaa31b91458.png)'
- en: Here we see how the current actual database schema and the description of the
    desired database schema are compared to generate an upgrade and directly apply
    a script for making the changes needed to make the actual schema the same as the
    desired schema.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到如何将当前实际的数据库模式与期望的数据库模式的描述进行比较，以生成升级脚本，并直接应用这个脚本以进行必要的更改，使实际模式与期望模式相同。
- en: One advantage of this approach is that there is no series of scripts generated
    that have to be executed in a specific order. Therefore, this approach combines
    easily with extensive branching schemas, where changes are integrated more slowly
    over time. It also removes the need to write migrations by hand for simple scenarios,
    such as adding or deleting a column, table, or index.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个优势是，不需要生成一系列必须按特定顺序执行的脚本。因此，这种方法与广泛分支的架构非常契合，尤其适合逐步集成变更的场景。它还消除了手动编写迁移的需求，适用于简单的场景，如添加或删除列、表或索引。
- en: The disadvantage of this approach is that it makes it harder to handle changes
    that need data operations as well. Again, imagine a scenario of moving two columns
    to another table. Since the tooling only enforces the new schema, this will lead
    to data loss if there is no further intervention.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，它使得处理需要数据操作的变更变得更加困难。再举个例子，假设将两列移动到另一个表中。由于工具仅强制执行新的架构，如果没有进一步的干预，这将导致数据丢失。
- en: One possible form of intervention to circumvent this is the addition of pre-
    and post-deployment scripts to the schema package. In the pre-deployment script,
    the current data is staged in a temporary table. Then, after applying the new
    schema, the data is copied from the temporary table to the new location in the
    post-deployment script.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的干预方式是向架构包中添加部署前和部署后的脚本。在部署前脚本中，当前数据会被暂存到一个临时表中。然后，在应用新架构后，数据会从临时表复制到新位置，过程在部署后脚本中完成。
- en: This section was about managing database schema changes in a format that can
    be stored in source control. The next section discusses how these changes can
    be picked up at deploy time and then applied to a database.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本节内容介绍了如何以可存储在源代码管理中的格式管理数据库架构变更。下一节将讨论如何在部署时拾取这些变更，并将其应用到数据库中。
- en: Applying database schema changes
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用数据库架构变更
- en: With the database schema, and optionally, a series of migrations defined in
    source control, it is time to start thinking about when to apply changes to the
    database schema. There are two methods to do so. Database schema changes can be
    applied prior to deployment of the new application version, or by the application
    code itself.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有了数据库架构，并可选地定义了一系列迁移存储在源代码管理中，接下来就该考虑何时将这些变更应用到数据库架构中。有两种方法可以做到这一点。数据库架构的变更可以在部署新版本的应用程序之前应用，或者由应用程序代码本身来应用。
- en: Upgrading as part of the release
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为发布的一部分进行升级
- en: The first approach to applying databases changes is as part of the release pipeline.
    When this is the case, the tool that is responsible for reading and executing
    the migration scripts is invoked using a step in the pipeline.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 应用数据库变更的第一种方法是作为发布流程的一部分。当这种情况发生时，负责读取和执行迁移脚本的工具会通过管道中的一个步骤来调用。
- en: This invocation can be done using a custom script in PowerShell or another scripting
    language. However, this is error-prone, and with every change of tool, there is
    a risk that the scripts need to be updated. Luckily, for most of the migration-based
    tools, there are Azure Pipelines tasks that are readily available for starting
    the migration from the release.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种调用可以通过 PowerShell 或其他脚本语言中的自定义脚本完成。然而，这种方式容易出错，并且每次工具发生变更时，都有可能需要更新脚本。幸运的是，对于大多数基于迁移的工具，Azure
    Pipelines 提供了现成的任务，能直接从发布阶段开始执行迁移。
- en: For example, there is an Azure Pipelines extension available for applying Entity
    Framework Core migrations to a database directly from the `dll` file where they
    are defined. This task can be added to the release pipeline for updating the database,
    before the new application code is deployed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Azure Pipelines 提供了一个扩展，用于直接从定义它们的 `dll` 文件将 Entity Framework Core 迁移应用到数据库中。此任务可以添加到发布管道中，用于在部署新应用程序代码之前更新数据库。
- en: Another variation is a split between the build and the release phase of an application.
    In this case, the migration scripts are exported as a separate build artifact,
    either directly from source code—if written in SQL—or after executing a tool that
    generates the necessary SQL scripts as output. This artifact is then downloaded
    again in the release phase, where it is applied to the database using an Azure
    Pipelines task for executing SQL.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种变体是将应用程序的构建和发布阶段进行分离。在这种情况下，迁移脚本会作为独立的构建产物导出，可以直接从源代码导出（如果是 SQL 编写的），或者通过执行一个工具生成必要的
    SQL 脚本作为输出。然后，在发布阶段再次下载该构建产物，并使用 Azure Pipelines 的 SQL 执行任务将其应用到数据库中。
- en: Upgrading by the application code
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过应用程序代码进行升级
- en: Instead of applying schema changes from the release pipeline, they can also
    be applied by the application itself. Some of the ORMs, with migration support
    built in, have the capability to automatically detect whether the database schema
    matches the latest migration. If not, they can automatically migrate the schema
    to that latest version on the spot.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 架构变更可以由应用程序本身而非发布管道来应用。一些带有内置迁移支持的ORM具备自动检测数据库架构是否与最新迁移匹配的能力。如果不匹配，它们可以自动将架构迁移到最新版本。
- en: 'An example of an ORM that supports this is Entity Framework. The core version
    of Entity Framework does not have support for automatic migrations built in. In
    Entity Framework Core, a single line of application code can be used to initiate
    an upgrade at a time that is convenient from the perspective of the application.
    The code for doing so is shown in the following code snippet:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 支持此功能的ORM之一是Entity Framework。Entity Framework的核心版本不内置自动迁移支持。在Entity Framework
    Core中，一行应用程序代码就可以在对应用程序而言方便的时刻启动升级。以下代码片段展示了实现此功能的代码：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The advantage of this approach is that it is very simple to enable. Just a Boolean
    switch in the configuration of, for example, Entity Framework can enable this
    workflow. However, the disadvantage is that most ORMs that support this will enforce
    a global lock on the database—stopping all database transactions while the migrations
    are running. For any migration or set of migrations that take more than a few
    seconds, this approach might be impractical.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点在于启用非常简单。例如，Entity Framework中的一个布尔开关就可以启用此工作流。然而，缺点是大多数支持此功能的ORM会对数据库强制执行全局锁定——在迁移运行时停止所有数据库事务。对于任何需要几秒钟以上的迁移或一组迁移，这种方法可能不可行。
- en: This approach is normally only used for migration-based approaches. Approaches
    that use an end-state approach require an external third-party tool that is used
    to generate the necessary migration scripts and apply them. This is normally done
    from the release pipeline and is not wrapped in the application itself.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通常仅用于基于迁移的方法。使用终态方法的方案需要一个外部第三方工具，用于生成所需的迁移脚本并应用它们。通常这会通过发布管道完成，而不是由应用程序本身来处理。
- en: Adding a process
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加过程
- en: 'As the previous section illustrated, it is important to think about how and
    when changes to the database schema or the application (or applications!) that
    use that schema are applied. But no matter how the deployment of schema changes
    and code deployment are scheduled, there will always be a period at which one
    of the following is true:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所示，考虑如何以及何时应用数据库架构或使用该架构的应用程序（或多个应用程序）的变更是非常重要的。但无论架构变更和代码部署的安排如何，总会有一个时期，其中以下情况之一为真：
- en: The new application code is already running while the schema changes are not
    applied yet or are in the process of being applied.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的应用程序代码已经运行，而架构变更尚未应用或正在应用过程中。
- en: The old application code is still running while the schema changes are already
    applied or are in the process of being applied.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在架构变更已应用或正在应用的情况下，旧版应用程序代码仍在运行。
- en: The application code is not running while the schema changes are being applied.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用架构变更时，应用程序代码未运行。
- en: The third situation is highly undesirable. This is true in general, but especially
    when practicing DevOps. If changes are shipped often and during working hours,
    it is unacceptable to take the application down for every schema change.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种情况是非常不希望出现的。这通常是这样，尤其是在实践DevOps时。如果频繁发布变更并且在工作时间内进行，频繁因每次架构变更停机是无法接受的。
- en: 'To prevent having to take the application down while schema changes are being
    applied, one of the following conditions has to be met:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在应用架构变更时需要停机，必须满足以下条件之一：
- en: The schema changes are backward-compatible in such a way that the old version
    of the application code can run without errors against a database where the schema
    changes have already been applied, or are being applied.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构变更具有向后兼容性，使得旧版应用程序代码能够在架构变更已经应用或正在应用的数据库上无错误地运行。
- en: The new application code is backward-compatible in such a way that it can run
    against both the old and the new versions of the schema.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的应用程序代码具有向后兼容性，能够在旧版和新版架构上运行。
- en: Meeting the first of these conditions ensures that the old application code
    can continue to run while the schema changes are being applied. Meeting the second
    of these conditions ensures that the new version of the application code can be
    deployed first, and once that is completed, the database can be upgraded while
    this code is running. While either will work, it is often desirable to aim for
    the first condition. The reason is that schema changes often support application
    code changes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 满足第一个条件可以确保旧的应用程序代码在应用模式更改时仍然能够运行。满足第二个条件则确保新的应用程序版本可以首先部署，完成后可以在该代码运行时升级数据库。虽然两者都能工作，但通常希望满足第一个条件。原因是模式更改通常会支持应用程序代码的更改。
- en: 'This means that the following is a safe process for deploying schema changes
    without downtime:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，以下过程是安全的，在不发生停机的情况下部署模式更改：
- en: Create a new database.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的数据库。
- en: Apply the database changes.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用数据库更改。
- en: Verify that the changes have been applied properly, or abort the deployment
    pipeline.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证更改是否已正确应用，或者中止部署管道。
- en: Deploy the new application code.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署新的应用程序代码。
- en: It is important to realize that this process assumes failing forward. This means
    that if there ever is an issue with the deployment of schema changes, they should
    be resolved before going forward with the code changes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 需要意识到，这个过程假设前向失败。这意味着，如果在部署模式更改时遇到问题，应在继续进行代码更改之前先解决这些问题。
- en: 'Finally, meeting the condition of backward combability for schema changes can
    sometimes be impossible to fulfill for a schema change. If this is the case, the
    change can often be split into two partial changes that together have the same
    end result, while they both meet the condition of backward combability. For example,
    renaming a property, or changing the unit in which it stores a distance from feet
    to meters, can be executed as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，满足模式更改的向后兼容性条件，有时对于某些模式更改来说是无法完成的。如果是这种情况，可以将更改拆分为两个部分更改，两个部分共同完成相同的最终结果，并且都满足向后兼容性的条件。例如，重命名一个属性，或者将存储距离的单位从英尺改为米，可以按以下方式执行：
- en: Generate a migration that adds a new column to a database table, storing the
    distance in meters.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个迁移，向数据库表中添加一个新列，存储以米为单位的距离。
- en: Add an application code that reads from the old column, but writes to both columns.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个应用程序代码，从旧列中读取数据，但写入两个列。
- en: Deploy these changes to production.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些更改部署到生产环境。
- en: Add a new migration that migrates data from the old column to the new column
    for all cases where the new column is not yet filled, but the old column is.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的迁移，将旧列中的数据迁移到新列中，对于所有尚未填充新列但旧列已填充的情况。
- en: Update the application code to read and write only the new column.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新应用程序代码，使其仅读取和写入新列。
- en: Deploy these changes to production.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些更改部署到生产环境。
- en: Add a new migration that removes the old column.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的迁移，移除旧列。
- en: Using the correct tools and a proper process, it is possible to execute effective
    and safe deployments of schema changes. In the next section, another approach,
    using schema-less databases, is introduced.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正确的工具和适当的过程，可以执行有效且安全的模式更改部署。在下一部分中，将介绍另一种方法，即使用无模式数据库。
- en: Going schema-less
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 放弃使用模式
- en: In the previous sections, the focus was on relational databases, where strict
    schemas are applied to every table. A completely different approach to database
    schema management is to let go of having a database schema altogether. This can
    be done by using schema-less or document databases. A well-known example of a
    schema-less database is Azure Cosmos DB. These databases can store documents of
    different forms into the same table. Table is quoted here, since these types of
    databases often do not use the term "table", but call this a database, a container,
    or a collection.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，重点是关系型数据库，其中对每个表都应用严格的模式。另一种完全不同的数据库模式管理方法是完全放弃使用数据库模式。这可以通过使用无模式或文档型数据库来实现。一个著名的无模式数据库例子是
    Azure Cosmos DB。这些数据库可以将不同形式的文档存储到同一表中。这里所说的“表”是指，因为这些类型的数据库通常不使用“表”这个术语，而是将其称为数据库、容器或集合。
- en: Since these databases can store documents with a different schema in the same
    collection, schema changes no longer exist from a database's point of view. But
    of course, there will be changes to the structure of the corresponding objects
    in the application code over time. To see how to handle this, it is best to differentiate
    between storing objects in the database and reading them back.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些数据库可以在同一集合中存储不同模式的文档，从数据库的角度来看，模式变更已经不存在。但当然，随着时间的推移，应用程序代码中相应对象的结构会发生变化。要处理这种情况，最好区分存储对象到数据库和从数据库读取对象的过程。
- en: Writing objects to the database
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将对象写入数据库
- en: The documents that are stored in a schema-less database are often serializations
    of objects in application code. When working with a relational database, these
    objects are often stored using an **object-relational mapper** (**ORM**), such
    as Entity Framework, Dapper, or NHibernate. When working with a document database,
    these objects are often serialized and stored in the database. This means that
    a change in the definition of that code object will also result in a different
    document structure when saving the object. Due to the nature of document databases,
    this will work fine.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在无模式数据库中的文档通常是应用程序代码中对象的序列化。当使用关系型数据库时，这些对象通常通过**对象关系映射器**（**ORM**）进行存储，比如
    Entity Framework、Dapper 或 NHibernate。当使用文档数据库时，这些对象通常被序列化并存储在数据库中。这意味着代码对象定义的变化会导致在保存对象时文档结构的变化。由于文档数据库的特点，这种方式是有效的。
- en: 'As an example, take the following C# class and its JSON representation after
    serializing it to a document database:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，考虑以下 C# 类及其序列化到文档数据库后的 JSON 表示：
- en: '|'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'After this code has been running in a production environment for a while, and
    thousands of persons have been saved, a new requirement comes in. Next to the
    name of the person, the city where they live must also be recorded. For this reason,
    the `Person` class is extended to include another property. After performing this
    change and deploying the new code, whenever a person is saved, the following code
    is used, resulting in the JSON shown next to it:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码在生产环境中运行一段时间后，成千上万的人员已被保存，一个新的需求出现了。除了记录人员的姓名外，还必须记录他们所在的城市。因此，`Person`类扩展以包括另一个属性。进行此更改并部署新代码后，每当保存一个人员时，以下代码将被使用，结果是生成如下所示的
    JSON：
- en: '|'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: While the definition of the `Person` class has changed—and the corresponding
    JSON has as well—both document forms can be saved into the same collection.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`Person`类的定义发生了变化——相应的JSON也发生了变化——这两种文档形式仍然可以保存在同一集合中。
- en: This shows that from the viewpoint of writing information to the database, the
    schema-less approach is very convenient, since developers do not have to think
    about schema change management at all.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，从将信息写入数据库的角度来看，无模式方法非常方便，因为开发人员根本不需要考虑模式变更管理。
- en: Reading objects from the database
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数据库读取对象
- en: While schema-less databases make it extremely easy to write documents of different
    forms to the same collection, this can pose problems when reading documents back
    from that same collection and deserializing them. In reality, the problem of schema
    management is not removed, but deferred to a later point in time.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管无模式数据库使得将不同形式的文档写入同一个集合变得非常容易，但在从该集合中读取文档并进行反序列化时，可能会遇到问题。实际上，模式管理的问题并没有消除，而是被推迟到了稍后的时间点。
- en: Continuing the example from the previous section, deserializing the first person
    that was saved on the new C# `Person` class definition will result in a null value
    for the city property. This can be unexpected, since the C# code guarantees that
    a person without a city can never be constructed. This is a clear example of the
    challenges that schema-less databases pose.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前面的示例，在新的 C# `Person` 类定义下反序列化第一个保存的人的时候，`city`属性将得到一个空值。这可能是意料之外的，因为 C# 代码保证不会构造没有城市的人员。这清楚地展示了无模式数据库带来的挑战。
- en: 'In this example, the issue can be circumvented by updating the `Person` class
    to the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，可以通过将`Person`类更新为以下内容来规避该问题：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next to this scenario, where a property was added, there are many other scenarios
    that will require the C# class to be adapted in order to handle deserialization
    scenarios. Some examples are as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个添加属性的场景外，还有许多其他场景会要求对 C# 类进行适配，以处理反序列化场景。以下是一些示例：
- en: Adding a property of a primitive type
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加原始类型的属性
- en: Adding a complex property, another object, or an array
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个复杂属性、另一个对象或数组。
- en: Renaming a property
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重命名属性。
- en: Replacing a property of a primitive type with a complex property
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将原始类型的属性替换为复杂属性。
- en: Making nullable properties non-nullable
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可空属性改为非空属性。
- en: 'Adding code to objects to handle these situations increases the size and complexity
    of the code base, and pollutes the primary code base with the capabilities for
    coping with past situations. Especially when this happens often, this can lead
    to unwanted complications in a code base. To prevent this, a possible solution
    is to go through the following process whenever the schema of an object changes:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 向对象添加代码以处理这些情况会增加代码库的大小和复杂性，并将处理过去情况的功能污染主代码库。尤其是在这种情况频繁发生时，这可能会导致代码库中出现不必要的复杂性。为避免这种情况，可能的解决方案是，每当对象的模式发生变化时，按照以下过程操作：
- en: Change the schema of the object, ensuring that there are only properties added.
    Even when the goal is to remove a property, at this stage, only a property with
    the new name is added.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改对象的模式，确保只添加属性。即使目标是删除一个属性，在此阶段，只有具有新名称的属性被添加。
- en: Implement logic on the object to cope with the deserialization of old versions
    of the object.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对象上实现逻辑，以应对旧版本对象的反序列化。
- en: Deploy the new version of the object.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署对象的新版本。
- en: Start a background process that loads all objects of the type from the database
    one by one, and saves them back to the database.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个后台进程，从数据库中逐一加载该类型的所有对象，并将其保存回数据库。
- en: Once the background process has processed all existing entities, remove the
    code that is responsible for coping with the schema change during deserialization
    from the code base, along with any properties that are no longer used.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦后台进程处理完所有现有实体，删除负责处理反序列化过程中模式更改的代码，以及任何不再使用的属性。
- en: Using this approach, all changes are propagated to all stored versions of the
    object over a period of time. The downside to this approach is that the change
    to the object's structure is spread over two changes that must be deployed separately.
    Also, deployment of the second change must wait until all objects in the database
    have been converted.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，所有更改将在一段时间内传播到对象的所有存储版本。该方法的缺点是，对象结构的更改被分成两个必须分别部署的更改。此外，第二次更改的部署必须等待数据库中所有对象都已转换完毕。
- en: Other approaches and concerns
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他方法和关注点。
- en: Besides the more common approaches that were discussed previously, the following
    tips and approaches might help with reducing the amount of work in dealing with
    databases, or help reduce the risk associated with making database changes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面讨论的更常见的方法，以下的一些提示和方法可能有助于减少处理数据库时的工作量，或帮助降低与数据库更改相关的风险。
- en: Minimizing the influence of databases
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化数据库的影响。
- en: A first step in dealing with databases can be to reduce the chance that a database
    change has to be made. In many databases, it is possible to write stored procedures—or
    some other code or script—that executes within the database engine. While stored
    procedures come with some benefits, changing them can also count as a database
    schema change, or at the least result in changes that can be difficult to test.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 处理数据库的第一步可以是减少需要进行数据库更改的机会。在许多数据库中，可以编写存储过程——或者其他代码或脚本——在数据库引擎内部执行。虽然存储过程有一些好处，但更改它们也可能算作数据库模式的更改，或者至少会导致难以测试的更改。
- en: One simple approach for this is to just replace stored procedures with application
    code that allows for easier side-by-side changes using feature toggles.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的方法是将存储过程替换为应用程序代码，从而使用功能开关进行更简单的并行更改。
- en: Full side-by-side deployment
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完整的并行部署。
- en: 'When working in a high-risk environment, or with a fragile database, there
    is also another approach to database schema changes that can be taken. This approach
    is based on applying feature toggles and the blue–green deployment pattern, and
    goes as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在高风险环境或脆弱的数据库中工作时，也可以采取另一种方法进行数据库模式更改。该方法基于应用功能开关和蓝绿部署模式，具体步骤如下：
- en: Change the application code in such a way that it writes any update to not just
    one, but to two databases.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以这样的方式更改应用程序代码，使其将任何更新写入不止一个，而是两个数据库。
- en: In the production environment, create a complete, full copy of the existing
    database and configure the application code to write all changes to both databases.
    These databases will be called *old* and *new*, from now on.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生产环境中，创建现有数据库的完整副本，并配置应用程序代码以同时将所有更改写入两个数据库。这些数据库将被称为*旧*数据库和*新*数据库，之后将使用这些名称。
- en: Introduce the required changes to the new database schema and the application
    code *only* in the path that writes to the new database.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅在写入新数据库的路径中，引入对新数据库架构和应用程序代码的必要更改。
- en: Introduce the necessary changes in all code paths that read data in such a way
    that all queries run against both databases.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有读取数据的代码路径中引入必要的更改，使得所有查询都在两个数据库上运行。
- en: Update the application code to detect differences in the query results between
    the new and the old databases, and log an error when it finds any discrepancy.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新应用程序代码，检测新数据库和旧数据库之间查询结果的差异，并在发现任何不一致时记录错误。
- en: If the changes run without any issues, remove the old database, and the old
    read and write access paths, from the application code.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果更改顺利运行，请删除旧数据库，以及应用程序代码中的旧读写访问路径。
- en: If the changes run with errors, fix the issue. Next, restart by restoring the
    backup of the intended new database, and resume at step five.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果更改运行时出现错误，修复问题。接下来，通过恢复目标新数据库的备份来重新启动，并从第五步开始恢复。
- en: The advantage of this approach is that it is very lightweight. The downside
    is that it is very involved, takes a lot of work, and is more expensive. Also,
    the extra database costs and duration of backup and restore operations should
    be taken into account.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是非常轻量级。缺点是它非常复杂，需要大量的工作，且成本较高。同时，还应考虑额外的数据库成本和备份恢复操作的时间。
- en: Testing database changes
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试数据库更改
- en: Just as with application code, insights into the quality of database schema
    changes can be gathered through testing. Links to performing tests on database
    schemas can be found at the end of this chapter.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 就像应用程序代码一样，通过测试可以获得关于数据库架构更改质量的见解。关于如何对数据库架构进行测试的链接可以在本章末尾找到。
- en: In most cases, in order to fully cover the risks introduced by database changes,
    system tests are needed that execute against a fully deployed stack of the application.
    This type of test can cover most of the risks that come from faulty schemas, invalid
    stored procedures, and database and application code mismatches.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，为了全面覆盖数据库更改带来的风险，需要进行系统测试，这些测试会在完整部署的应用程序堆栈上执行。这种类型的测试可以覆盖大部分由错误的架构、无效的存储过程、数据库和应用程序代码不匹配引起的风险。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned how to manage your database schema and schema
    changes using source control. You know about both the migration-based and end
    state based storing of changes, and how to apply them to your production database
    in a safe manner.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学习了如何通过源代码控制管理数据库架构及其更改。您了解了基于迁移和最终状态的更改存储方法，以及如何以安全的方式将它们应用于生产数据库。
- en: Additionally, you have learned how schema-less databases can remove the burden
    of traditional schema management. However, this comes at the price of having to
    cope with schema differences when reading older versions of an object back from
    the database.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还学习了无架构数据库如何消除传统架构管理的负担。然而，这也意味着在从数据库读取对象的旧版本时，必须应对架构差异。
- en: In the next chapter, you will learn about continuous testing. You will not only
    learn about testing techniques, but also about which to apply at what point, and
    how testing is a crucial part of DevOps and a critical enabler of a continuous
    flow of value to end users.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习持续测试。您不仅将学习测试技术，还将了解在何时应用哪些测试技术，以及测试如何成为 DevOps 的关键组成部分，是持续向最终用户提供价值的关键驱动因素。
- en: Questions
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the Appendix:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在总结时，以下是一些问题，帮助你测试关于本章内容的知识。你可以在附录中的*评估*部分找到答案：
- en: 'True or false: When working with Entity Framework, schema management is  built
    in using migrations-based support.'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对与错：在使用 Entity Framework 时，架构管理是通过基于迁移的支持内建的。
- en: 'True or false: When working with a migrations-based approach for schema management,
    you do not need extra tracking tables in your database schema.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对与错：在使用基于迁移的架构管理方法时，您不需要在数据库架构中额外的跟踪表。
- en: 'True or false: When working with an end state-based approach for schema management,
    you do not need extra tracking tables in your database schema.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对还是错：在使用基于最终状态的架构管理方法时，你的数据库架构中不需要额外的跟踪表。
- en: 'What are the benefits of a full side-by-side approach to database schema changes?
    (Choose multiple answers):'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完整的并行数据库架构更改方法有哪些好处？（选择多个答案）：
- en: The risks are reduced to almost zero.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 风险几乎降到零。
- en: You can measure the actual performance impact of changes in a production-like
    environment.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在类似生产环境中衡量更改对性能的实际影响。
- en: Side-by-side migrations reduce cycle time.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并行迁移减少了周期时间。
- en: 'True or false: Schema-less databases remove the need for thinking about schema
    changes completely.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对还是错：无模式数据库完全消除了对架构更改的思考需求。
- en: What is a possible technology choice that you can make to limit the impact of
    changes on your database schema?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以做出什么样的技术选择来限制对数据库模式的更改影响？
- en: Further reading
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: More information about Entity Framework and Entity Framework Migrations can
    be found at [https://docs.microsoft.com/nl-nl/ef/](https://docs.microsoft.com/nl-nl/ef/)
    and [https://docs.microsoft.com/en-us/ef/ef6/modeling/code-first/migrations/](https://docs.microsoft.com/en-us/ef/ef6/modeling/code-first/migrations/).
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Entity Framework 和 Entity Framework 迁移的更多信息可以在 [https://docs.microsoft.com/nl-nl/ef/](https://docs.microsoft.com/nl-nl/ef/)
    和 [https://docs.microsoft.com/en-us/ef/ef6/modeling/code-first/migrations/](https://docs.microsoft.com/en-us/ef/ef6/modeling/code-first/migrations/)
    上找到。
- en: More information about Redgate and its database tooling can be found at [https://www.red-gate.com/](https://www.red-gate.com/).
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Redgate 及其数据库工具的更多信息可以在 [https://www.red-gate.com/](https://www.red-gate.com/)
    上找到。
- en: More information on SQL Server Data Tools can be found at [https://docs.microsoft.com/en-us/sql/ssdt/sql-server-data-tools?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/ssdt/sql-server-data-tools?view=sql-server-2017).
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 SQL Server 数据工具的更多信息可以在 [https://docs.microsoft.com/en-us/sql/ssdt/sql-server-data-tools?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/ssdt/sql-server-data-tools?view=sql-server-2017)
    上找到。
- en: The Azure Pipelines extension for deploying Entity Framework Core migrations
    from a DLL can be found at [https://marketplace.visualstudio.com/items?itemName=bendayconsulting.build-task](https://marketplace.visualstudio.com/items?itemName=bendayconsulting.build-task).
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于从 DLL 部署 Entity Framework Core 迁移的 Azure Pipelines 扩展可以在 [https://marketplace.visualstudio.com/items?itemName=bendayconsulting.build-task](https://marketplace.visualstudio.com/items?itemName=bendayconsulting.build-task)
    上找到。
