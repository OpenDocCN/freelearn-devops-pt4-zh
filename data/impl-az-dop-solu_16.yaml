- en: Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: Over the last couple of years, containers have become a hot topic. They allow
    you to package any application, any tool, written in any language, and deploy
    it on a basic host or cluster. When implementing DevOps, containers can be of
    tremendous value. That is why DevOps and containers are often mentioned in the
    same breath. However, they are not the same thing. While DevOps is more of a cultural
    thing, containers are a type of technology, an alternative way of hosting your
    applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，容器已成为热门话题。它们允许你将任何应用程序、任何工具（无论是用任何语言编写）打包，并将其部署到基本主机或集群上。在实施 DevOps
    时，容器可以带来巨大的价值。这就是为什么 DevOps 和容器常常被同时提及的原因。然而，它们并不是同一回事。虽然 DevOps 更像是一种文化现象，容器则是一种技术，是托管应用程序的替代方式。
- en: In this chapter, you will learn more about containers and how they work. This
    is achieved by exercises wherein custom container images are created and run on
    different hosting platforms, such as Azure Container Instances and Kubernetes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解更多关于容器以及它们是如何工作的。通过练习，创建自定义容器镜像并在不同的托管平台上运行，例如 Azure 容器实例和 Kubernetes。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: An introduction to containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器简介
- en: Building a container image
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建容器镜像
- en: Building images in Azure DevOps and running them in Azure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Azure DevOps 中构建镜像并在 Azure 中运行
- en: An introduction to Kubernetes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 介绍
- en: Kubernetes in action
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 实战
- en: Upgrading containers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级容器
- en: Scaling containers and Kubernetes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器和 Kubernetes 的扩展
- en: Deploying to Kubernetes with Azure DevOps
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Azure DevOps 部署到 Kubernetes
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To experiment with the techniques described in this chapter, you need one or
    more of the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要实验本章描述的技术，你需要以下一项或多项：
- en: Docker Desktop
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Desktop
- en: Visual Studio 2019
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019
- en: An Azure subscription
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 订阅
- en: The Azure CLI
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure CLI
- en: All these are available for free or can be obtained for a limited period for
    free for evaluation purposes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以免费获得，或者在有限的时间内免费用于评估目的。
- en: An introduction to containers
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器简介
- en: Containers are the evolution of virtualization. With virtualization, the resources
    of physical machines are shared among several virtual machines. Sharing those
    resources also means that all virtual machines have their own operating system.
    This is different when using containers. With containers, not only are the resources
    shared, but also the operating system kernel, making it very small in comparison
    with a virtual machine image.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是虚拟化的演进。通过虚拟化，物理机器的资源在多个虚拟机之间共享。共享这些资源也意味着每个虚拟机都有自己的操作系统。而使用容器时则不同。容器不仅共享资源，还共享操作系统内核，使其与虚拟机镜像相比非常小。
- en: 'Since the operating system kernel is shared, containers are also very portable.
    Images can be deployed on any type of host environment that supports running containers.
    This works because all the application''s binaries and configurations are stored
    inside the container. As a result, environment variables outside the container
    do not impact the application. Naturally, there are a number of caveats, however:
    a container shares the operating system kernel; Linux containers can only run
    on a Linux operating system, and the same applies to Windows containers.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于操作系统内核是共享的，容器也非常便携。镜像可以部署到任何支持运行容器的主机环境中。这是因为应用程序的所有二进制文件和配置都存储在容器内。因此，容器外部的环境变量不会影响应用程序。当然，也有一些注意事项：容器共享操作系统内核；Linux
    容器只能在 Linux 操作系统上运行，Windows 容器也同样如此。
- en: 'Containers provide the ability to virtualize an operating system in order to
    run multiple workloads on a single operating system. This is visualized in the
    following diagram, where you can see the difference between regular hosting, virtual
    machine hosting, and containers:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 容器提供了虚拟化操作系统的能力，以便在单一操作系统上运行多个工作负载。以下图表展示了常规托管、虚拟机托管和容器之间的区别：
- en: '![](img/d858e1dc-2312-4de8-b626-dffa43717c02.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d858e1dc-2312-4de8-b626-dffa43717c02.png)'
- en: If you have ever heard of containers, you almost certainly have also heard of
    Docker. This is because Docker is one of the most well-known container engines
    that can be used for running containers. The next section will delve into DevOps
    and containers, while the remainder of the chapter will go into more technical
    detail regarding containers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经听说过容器，那么几乎可以肯定你也听说过 Docker。这是因为 Docker 是最著名的容器引擎之一，用于运行容器。下一节将深入探讨 DevOps
    和容器，剩下的章节将详细介绍有关容器的更多技术细节。
- en: DevOps and containers
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DevOps 和容器
- en: 'As mentioned in the introduction, DevOps and containers are not the same thing.
    Containers are the technology that makes DevOps easier. This is because containers
    have benefits that make them *the* perfect tool for DevOps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如在介绍中提到的，DevOps 和容器并不是同一个概念。容器是让 DevOps 更加容易的技术。这是因为容器具有一些优点，使其成为 *DevOps* 的完美工具：
- en: '**Consistent**: Because you build the container images, the hurdle of "<q>it
    works on my machine</q>" is eliminated.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：因为你构建了容器镜像，所以"<q>它在我的机器上运行</q>"这一问题被消除了。'
- en: '**Separation of concerns**: When using containers, your application will be
    distributed between separate containers, which makes it easier to maintain and
    separate the processes.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**：使用容器时，您的应用程序将分布在不同的容器之间，这使得维护和分离进程变得更加容易。'
- en: '**Platform**: The solution can be run on different platforms. It does not matter
    whether this is in Azure, on Amazon Web Services, or in an on-premises environment.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台**：该解决方案可以在不同的平台上运行。无论是在 Azure、Amazon Web Services 还是本地环境中运行，都没有关系。'
- en: That aside, DevOps is more cultural than technical and, as mentioned in [Chapter
    1](889f9224-f1b6-414d-bc80-16563f66e1e7.xhtml), *Introduction to DevOps*, technical
    components are used to support DevOps. In the remainder of this chapter, we will
    focus on the technical side of things.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展来说，DevOps 更多的是一种文化，而非技术。如在[第1章](889f9224-f1b6-414d-bc80-16563f66e1e7.xhtml)《DevOps
    介绍》中提到的，*技术组件* 用于支持 DevOps。在本章的其余部分，我们将专注于技术方面的内容。
- en: Hosting options
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 托管选项
- en: As mentioned previously, one of the benefits of containers is that they are
    extremely portable. This also means that containers can be hosted on numerous
    platforms and technologies.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，容器的一个好处是它们非常便携。这也意味着容器可以托管在许多平台和技术上。
- en: 'To run the containers, there are a lot of options that will vary according
    to your use case. Some of these options are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行容器，有许多选项会根据您的使用案例有所不同。以下是其中一些选项：
- en: Azure App Services
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 应用服务
- en: Azure Service Fabric
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 服务框架
- en: Docker Swarm
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Swarm
- en: Docker Desktop
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 桌面版
- en: Kubernetes
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes
- en: Depending on the demands of the application/container, it could run on all the
    options mentioned in the preceding list.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用程序/容器的需求，它可以运行在前面提到的所有选项中。
- en: The images used to run containers (container images) also need to be hosted.
    These images are hosted in a so-called container registry. In a container registry,
    they are published privately or publicly. The two most well-know registries are
    the Docker Registry and the Azure Container Registry within the Azure platform.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 用于运行容器的镜像（容器镜像）也需要托管。这些镜像托管在一个所谓的容器注册表中。在容器注册表中，它们可以是私有或公开发布的。两个最著名的注册表是 Docker
    注册表和 Azure 平台中的 Azure 容器注册表。
- en: Now that we have gone through some of the background information regarding containers,
    we are ready to go more deeply into the techniques behind containers and find
    out what is needed to create a custom container image.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了关于容器的一些背景信息，接下来我们将深入探讨容器背后的技术，并了解创建自定义容器镜像所需的内容。
- en: Building a container image
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建容器镜像
- en: This section will take you through the process of building a container image
    and executing it on your local system. To do this, we will first have to create
    an application and then add Docker support to it before we create an image and
    finally test it. So let's begin!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将带领您了解构建容器镜像并在本地系统上执行的过程。为此，我们首先需要创建一个应用程序，然后为其添加 Docker 支持，接着创建镜像并最终进行测试。让我们开始吧！
- en: Creating an application
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序
- en: To be able to test and check what is running on the container, an application
    is required. For this, a new application can be created or you can use an existing
    application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够测试和检查容器中运行的内容，必须有一个应用程序。为此，可以创建一个新应用程序，也可以使用现有的应用程序。
- en: 'When creating a new application, the easiest option is to use the default ASP.NET
    Core website template within Visual Studio 2019\. Container support can be added
    in a few clicks. This is simply done by checking the Enable Docker Support box when
    creating the project:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新应用程序时，最简单的选项是在 Visual Studio 2019 中使用默认的 ASP.NET Core 网站模板。可以通过几次点击添加容器支持。只需在创建项目时勾选“启用
    Docker 支持”框即可。
- en: '![](img/8f581ba6-9178-4957-9d4c-5c5d729a39a6.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f581ba6-9178-4957-9d4c-5c5d729a39a6.png)'
- en: Keep the new application open or open your existing application. In the next
    section, we will investigate how Docker support can be added to an existing application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 保持新应用程序处于打开状态，或打开现有应用程序。在下一节中，我们将探讨如何向现有应用程序添加 Docker 支持。
- en: Adding Docker support to an existing application
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向现有应用程序添加 Docker 支持
- en: 'Adding Docker support to an existing application requires a couple of simple
    steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 向现有应用程序添加 Docker 支持需要几个简单的步骤：
- en: Open the project/solution in Visual Studio 2019 and right-click on the project.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 2019 中的项目/解决方案，右键点击项目。
- en: 'Choose Add and select Docker Support:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“添加”并选择“Docker 支持”：
- en: '![](img/0d2ac44e-3785-4c6a-a0a1-f8ea4fee799f.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d2ac44e-3785-4c6a-a0a1-f8ea4fee799f.png)'
- en: 'Depending on your client tools and Visual Studio configuration, there may also
    be a Container Orchestrator Support option. With this option, the cloud orchestrator
    of your choice can be chosen. In this sample, we used Docker because this format
    is supported by the major container orchestrators. Other cloud orchestrator options
    do exist, however:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的客户端工具和 Visual Studio 配置，也可能会有一个“容器编排器支持”选项。通过该选项，可以选择你选择的云编排器。在此示例中，我们使用
    Docker，因为这一格式被主要的容器编排器所支持。然而，也存在其他云编排器选项：
- en: Docker Swarm
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Swarm
- en: Kubernetes
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes
- en: Mesos Marathon
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mesos Marathon
- en: Depending on the cloud orchestrator used, a file is added to the project in
    the specific format for that orchestrator.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 根据所使用的云编排器，会向项目中添加一个特定格式的文件。
- en: 'By adding Docker support, a new file is added to the project named `Docker`.
    The Dockerfile is the specification of a container image. This file can be read
    by Docker, which sees it as instructions. The file is a text document that contains
    separate commands that can also be called within a command-line tool to assemble
    an image:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 Docker 支持，项目中会新增一个名为 `Docker` 的文件。Dockerfile 是容器镜像的规范。该文件可以被 Docker 读取，并视为指令。该文件是一个文本文件，包含一系列独立的命令，也可以在命令行工具中调用这些命令来组装镜像：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The example uses a technique called a multi-stage build file. This is because
    the file uses multiple `FROM` statements where there is a reference to a specific
    image.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例使用了一种名为多阶段构建文件的技术。这是因为该文件使用了多个 `FROM` 语句，每个语句都引用了特定的镜像。
- en: Prior to multi-stage build, it wasn't possible to use multiple `FROM` statements.
    During this time, it was hard to build efficient container images. Each statement
    in the file represented an additional layer on the image that resulted in it becoming
    larger and larger.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在多阶段构建之前，无法使用多个 `FROM` 语句。在那时，构建高效的容器镜像非常困难。文件中的每个语句代表镜像上的一个额外层，导致镜像越来越大。
- en: During this build process, it was also necessary to remove any components that
    were required during this process. For this reason, it was very common to have
    separate Dockerfiles for development and production.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中，还需要移除任何在该过程中需要的组件。因此，开发和生产通常会有单独的 Dockerfile。
- en: 'As mentioned, the Dockerfile comprises instructions and the most commonly used
    instructions are as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Dockerfile 由一系列指令组成，其中最常用的指令如下：
- en: '**FROM**: The `FROM` command is used to specify on which operating system or
    base image the image will be based. In the example, the `mcr.microsoft.com/dotnet/core/aspnet:3.0-buster-slim` image is
    used for the production version of the application, and the `mcr.microsoft.com/dotnet/core/sdk:3.0-buster` image is
    used to build the image.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FROM**：`FROM` 命令用于指定镜像基于的操作系统或基础镜像。在本例中，`mcr.microsoft.com/dotnet/core/aspnet:3.0-buster-slim`
    镜像用于应用程序的生产版本，`mcr.microsoft.com/dotnet/core/sdk:3.0-buster` 镜像用于构建镜像。'
- en: '**RUN**: The `RUN` command is used to install components or perform operations
    during the build process of the container image.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RUN**：`RUN` 命令用于在构建容器镜像的过程中安装组件或执行操作。'
- en: '**ENTRYPOINT**: The `ENTRYPOINT` command specifies what the entry point for
    a container image needs to be. In the example, the entry point is specified as
    a `.NET` application that references the library that was built during the compilation
    process.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ENTRYPOINT**：`ENTRYPOINT` 命令指定容器镜像的入口点需要是什么。在此示例中，入口点指定为一个 `.NET` 应用程序，它引用了编译过程中构建的库。'
- en: So far, we've created our application and added Docker support. Next, we'll
    see how to create an image with the application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了应用程序并添加了 Docker 支持。接下来，我们将看看如何用这个应用程序创建镜像。
- en: Creating an image with the application
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用应用程序创建镜像
- en: 'To be able to create a Docker image, Docker Desktop needs to be installed,
    as Visual Studio uses this to construct the image. With a complete Dockerfile,
    the image can be built using the following steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够创建 Docker 镜像，需要安装 Docker Desktop，因为 Visual Studio 会使用它来构建镜像。通过完整的 Dockerfile，可以使用以下步骤来构建镜像：
- en: 'Right-click the Dockerfile in Visual Studio and select Build Docker Image:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中右键单击 Dockerfile 并选择构建 Docker 镜像：
- en: '![](img/0ce5d270-2179-4c01-ac0a-762951e38fb0.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ce5d270-2179-4c01-ac0a-762951e38fb0.png)'
- en: 'During the compilation and building of the image, take a look at the output
    window. Looking at it will provide more insights into the layered approach of
    container images. This layered approach is visible via the steps shown in the
    output window:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在镜像的编译和构建过程中，请查看输出窗口。查看它可以提供有关容器镜像分层方法的更多见解。此分层方法可以通过输出窗口中显示的步骤来查看：
- en: '![](img/29d6b0f6-569c-4a6d-ae76-57c9b95a4097.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29d6b0f6-569c-4a6d-ae76-57c9b95a4097.png)'
- en: 'Docker Desktop also makes it possible to run and store images locally. After
    building the image, open a Terminal and run the following command:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Desktop 还使得在本地运行和存储镜像成为可能。构建镜像后，打开终端并运行以下命令：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The command displays all images currently on the machine. In this list, the
    base images that are downloaded during the creation of images are also listed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会显示当前机器上所有的镜像。在这个列表中，创建镜像时下载的基础镜像也会列出。
- en: Running the container image
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行容器镜像
- en: 'The container image can be started locally by running it within Docker. As
    we now have a container image, a container can be created:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像可以通过在 Docker 中运行来本地启动。现在我们已经有了一个容器镜像，可以创建一个容器：
- en: 'Run the following `docker container run` command:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下 `docker container run` 命令：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding command will start the container image specified at the end of
    the command. In addition, different arguments are specified:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将启动命令末尾指定的容器镜像。此外，还指定了不同的参数：
- en: '**Publish**: The `publish` argument opens a port from the host to the container.
    As mentioned in the example, this will open port `8123` and will route traffic
    to port `80` within the container.'
  id: totrans-83
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布**：`publish` 参数会将主机的端口打开到容器中。如示例所述，这将打开端口 `8123` 并将流量路由到容器内的端口 `80`。'
- en: '**Detach**: The `detach` argument will run the container in the background
    and print out its specific ID.'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分离**：`detach` 参数会在后台运行容器，并打印出其特定 ID。'
- en: '**Name**: The name for the container within Docker.'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：Docker 中容器的名称。'
- en: To list all running containers, use the `docker ps` command within the Terminal.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要列出所有正在运行的容器，可以在终端中使用 `docker ps` 命令。
- en: 'With the container running, open a browser and navigate to `http://localhost:8123`.
    If everything works fine, this should show a default ASP.NET Core web page:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器运行时，打开浏览器并导航到 `http://localhost:8123`。如果一切正常，这将显示默认的 ASP.NET Core 网页：
- en: '![](img/d0e39e85-3964-47f4-a1e4-4d2ffc71ad49.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0e39e85-3964-47f4-a1e4-4d2ffc71ad49.png)'
- en: Since building stuff locally and running it on your machine is not really the
    DevOps way of thinking, we will move to a different hosting platform in the upcoming
    sections.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在本地构建并在自己的机器上运行并不是 DevOps 思维方式的体现，我们将在接下来的章节中转向一个不同的托管平台。
- en: Building images in Azure DevOps and running them in Azure
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Azure DevOps 中构建镜像并在 Azure 中运行
- en: 'To support continuous integration and continuous delivery, the source files
    need to be shared in a repository. So, let''s share the resources in Azure Repos
    and try to build our container by using Azure Pipelines. After building the container
    image, a place to store the images and run the container are also required. Within
    the Azure platform, there are two perfect services for this scenario:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持持续集成和持续交付，源文件需要存储在一个代码库中。因此，让我们在 Azure Repos 中共享资源，并尝试使用 Azure Pipelines
    构建我们的容器。构建完容器镜像后，还需要一个存储镜像并运行容器的地方。在 Azure 平台中，有两个非常适合此场景的服务：
- en: '**Azure Container Registry**: This service is a managed private Docker registry
    based on the open source Docker Registry. Here, you can maintain and register
    container images.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 容器注册表**：此服务是基于开源 Docker 注册表的托管私有 Docker 注册表。在这里，你可以维护和注册容器镜像。'
- en: '**Azure Container Instance**: The Azure Container Instance, also referred to
    as ACI, is a solution for running isolated containers without a lot of management.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 容器实例**：Azure 容器实例，也称为 ACI，是一种运行隔离容器的解决方案，无需过多的管理。'
- en: For the simplicity of this guide, the files are already added to the repository
    and the Azure resource is already created.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化本指南，文件已预先添加到仓库中，且 Azure 资源已经创建。
- en: Creating a service endpoint
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务端点
- en: As already discussed within the book, connections within Azure DevOps with external
    services such as Azure and container registries are configured within a service
    endpoint. Because the image needs to be available in order for Azure Container
    Instances to retrieve it, it needs to be published to a container registry. The
    connection from Azure DevOps to the registry is configured within a service connection.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如书中所讨论的，Azure DevOps 中与 Azure 和容器注册表等外部服务的连接是通过服务端点进行配置的。由于镜像需要可用，以便 Azure
    容器实例能检索到它，因此需要将其发布到容器注册表。Azure DevOps 到注册表的连接是在服务连接中配置的。
- en: 'Perform the following steps to configure the service connection:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来配置服务连接：
- en: In the Azure DevOps project, open the project settings.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Azure DevOps 项目中，打开项目设置。
- en: Within the project settings, click on Service connections.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目设置中，点击服务连接。
- en: In the service connection overview, click on Create service connection and choose
    Docker Registry.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务连接概览中，点击创建服务连接并选择 Docker 注册表。
- en: 'In the fly-out that appears, fill in the correct information and save the connection:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的窗口中，填写正确的信息并保存连接：
- en: '![](img/7895daf8-24f3-4591-8a3c-5d24d6ffff52.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7895daf8-24f3-4591-8a3c-5d24d6ffff52.png)'
- en: Saving the connection will add a service connection to the project that can
    be used by the pipelines we will create, or that you will create in the future.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 保存连接将为项目添加一个服务连接，供我们创建的管道或你未来创建的管道使用。
- en: Creating a new pipeline
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新管道
- en: To be able to start building the container image and publish it to the registry,
    we will create a new pipeline. For this example, we will make use of the YAML
    pipeline experience.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够开始构建容器镜像并将其发布到注册表，我们将创建一个新的管道。对于这个示例，我们将使用 YAML 管道体验。
- en: 'Perform the following steps to get started with the pipeline:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以开始使用管道：
- en: Open you Azure DevOps project and click on Pipelines.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的 Azure DevOps 项目并点击管道。
- en: In the pipelines overview, click on New Pipeline.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在管道概览中，点击新建管道。
- en: 'Select Azure Repos Git, choose the correct repository, and then choose the
    Starter pipeline:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 Azure Repos Git，选择正确的仓库，然后选择启动管道：
- en: '![](img/4968a66e-f56a-4855-8f58-6ad821fed19b.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4968a66e-f56a-4855-8f58-6ad821fed19b.png)'
- en: From the starter pipeline, remove the two dummy script tasks and open the assistant.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从启动管道中删除两个虚拟脚本任务，并打开助手。
- en: In the assistant, search for the `Docker` tasks and add the tasks to the pipeline.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在助手中，搜索 `Docker` 任务并将任务添加到管道中。
- en: Choose the service connection created for the container registry and keep the
    other information as the defaults.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择为容器注册表创建的服务连接，并保持其他信息为默认设置。
- en: Make sure to change the `buildContext` property of the tasks to point to the
    correct directory. This is required for Docker to be able to reference the correct
    paths when building your image.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将任务的 `buildContext` 属性更改为指向正确的目录。这对于 Docker 能够在构建镜像时引用正确的路径是必要的。
- en: 'When added, the YAML should look like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 添加后，YAML 文件应如下所示：
- en: '[PRE3]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Save and run the pipeline. After the first run, the container image is created
    and published to the container registry.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行管道。第一次运行后，容器镜像将被创建并发布到容器注册表。
- en: 'The images in the container registry can be retrieved by using a predefined
    URL. This URL comprises a few specific components:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 容器注册表中的镜像可以通过使用预定义的 URL 进行检索。该 URL 包含几个特定的组件：
- en: '`[container registry]/[repository]:[tag]`:'
  id: totrans-119
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[container registry]/[repository]:[tag]`：'
- en: '**Container registry**: The base URL of the container registry.'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器注册表**：容器注册表的基础 URL。'
- en: '**Repository**: The repository as specified during the process of publishing
    the image.'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仓库**：在发布镜像过程中指定的仓库。'
- en: '**Tag**: The tag for the specific version of the image. By default, the Docker
    tag used is `BuildId`.'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签**：镜像特定版本的标签。默认情况下，使用的Docker标签是`BuildId`。'
- en: 'Now that we have a reference to the container image, Azure Container Instances
    should be able to retrieve the container and run it. The only thing needed for
    this is an Azure CLI command:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有了容器镜像的引用，Azure容器实例应该能够提取该容器并运行它。所需的只是一个Azure CLI命令：
- en: '[PRE4]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Since the reference to the image is different for each build (`BuildId` for
    the tag value), `BuildId` is retrieved in the Azure CLI command via the `$(Build.BuildId)` variable:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个构建的镜像引用不同（标签值为`BuildId`），因此`BuildId`将在Azure CLI命令中通过`$(Build.BuildId)`变量获取：
- en: '[PRE5]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To execute the preceding script, the Azure CLI task is added to the pipeline.
    In this task, we configure the correct subscription via the service endpoint and
    set the inline script.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行上述脚本，必须将Azure CLI任务添加到管道中。在此任务中，我们通过服务端点配置正确的订阅，并设置内联脚本。
- en: The script will create a container instance in the `aci-rg-devops` resource
    group with the name `aci-demo-app` and retrieve the `azuredevops` container image
    from the `msftazuredevops.azurecr.io` repository.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将在`aci-rg-devops`资源组中创建一个名为`aci-demo-app`的容器实例，并从`msftazuredevops.azurecr.io`仓库中提取`azuredevops`容器镜像。
- en: 'The complete YAML for this task looks like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 该任务的完整YAML如下所示：
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Running this pipeline will result in an Azure Container Instance in Azure.
    That container will be running the exact same application that was running locally:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此管道将导致在Azure中创建一个Azure容器实例。该容器将运行与本地运行的应用程序完全相同的内容：
- en: '![](img/55aa2959-0840-41e1-b4d4-63b1bb725ad6.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55aa2959-0840-41e1-b4d4-63b1bb725ad6.png)'
- en: 'When opening the Azure Container Instance in the Azure portal, you will see
    that it is a running instance and that there is an FQDN attached to the Azure
    Container Instance based on the value supplied, `dns-name-label`, within the Azure
    CLI command, `aci-msft-demo.westeurope.azurecontainer.io`. Open the URL in your
    browser and see the application we have pushed to the container:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Azure门户中的Azure容器实例时，您将看到它是一个正在运行的实例，并且根据Azure CLI命令中提供的值`dns-name-label`，会附带一个FQDN（完全限定域名），即`aci-msft-demo.westeurope.azurecontainer.io`。在浏览器中打开此URL，查看我们已推送到容器的应用程序：
- en: '![](img/fb1fd6f7-038f-4ce1-9933-b9ffdf6cbd7a.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb1fd6f7-038f-4ce1-9933-b9ffdf6cbd7a.png)'
- en: It shows the same content as the container that was started locally. This is
    because, in both places, the same container image was started.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示的内容与在本地启动的容器相同。这是因为在两个地方，启动的是相同的容器镜像。
- en: In this section, we started the container on Azure Container Instances, but
    how will we manage running containers and restart them when there are problems?
    This is where Kubernetes comes in.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们启动了Azure容器实例中的容器，但当容器出现问题时，我们如何管理正在运行的容器并重新启动它们呢？这就是Kubernetes的作用所在。
- en: An introduction to Kubernetes
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes简介
- en: Kubernetes is another service for running your containers. Kubernetes is a cluster
    orchestration technology first developed by Google. It is now an open source platform
    for automating deployment, scaling, and operations of application containers across
    clusters of hosts, thereby providing a container-centric infrastructure.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是一个用于运行容器的服务。它是由Google最初开发的集群编排技术，现在是一个开源平台，用于自动化应用容器在主机集群上的部署、扩展和操作，从而提供以容器为中心的基础设施。
- en: Functionalities of Kubernetes
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes的功能
- en: 'As mentioned earlier, containers offer you a great way to package your applications.
    When running the applications, you need to make sure that applications keep running
    and this is where Kubernetes comes in as it has the following core functionalities:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，容器为您提供了一个很好的打包应用程序的方式。在运行应用程序时，您需要确保应用程序继续运行，这正是Kubernetes的核心功能之一：
- en: '**Service discovery and load balancing**: How a container is exposed is controlled
    within Kubernetes and, in addition, it is also capable of balancing the traffic
    within the orchestration.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务发现与负载均衡**：容器的暴露方式在Kubernetes中进行控制，此外，它还能够在编排过程中平衡流量。'
- en: '**Storage orchestration**: The ability to mount different kinds of storage
    providers to the platform.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储编排**：能够将不同类型的存储提供商挂载到平台上。'
- en: '**Rollouts and rollbacks**: Kubernetes can automatically create and restart
    containers for the specified deployment.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布与回滚**：Kubernetes可以自动为指定的部署创建和重启容器。'
- en: '**Self-healing**: Kubernetes can heal containers when they are failing.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自愈**：Kubernetes可以在容器失败时进行自愈。'
- en: '**Secret and configuration management**: Kubernetes has a built-in functionality
    to manage secrets such as tokens, passwords, and keys.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥和配置管理**：Kubernetes 内建功能来管理机密信息，如令牌、密码和密钥。'
- en: In order to provide these functionalities, Kubernetes consists of a number of
    components.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供这些功能，Kubernetes 由多个组件组成。
- en: Kubernetes core components and services
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 核心组件和服务
- en: Kubernetes consists of a few core components that make it run. These components
    together make a great and stable product for running and managing containers.
    The next few subsections will go over each of these components individually.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 由一些核心组件组成，这些组件共同工作，提供一个出色且稳定的产品来运行和管理容器。接下来的几个小节将逐一介绍这些组件。
- en: Master node
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主节点
- en: 'One of the important components within Kubernetes is the master node. The node
    manages the cluster. It contains all the Kubernetes core components in order to
    manage the cluster:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中一个重要的组件是主节点。主节点负责管理集群，它包含所有 Kubernetes 核心组件，以便管理集群：
- en: '`kube-apiserver`: A component for exposing the Kubernetes API. This API is
    used by management tools of Kubernetes, such as `kubectl`, and the Kubernetes
    dashboard.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-apiserver`：一个用于暴露 Kubernetes API 的组件。该 API 被 Kubernetes 的管理工具使用，例如 `kubectl`
    和 Kubernetes 仪表盘。'
- en: '`etcd`: Used to maintain the state of the Kubernetes cluster.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etcd`：用于保持 Kubernetes 集群的状态。'
- en: '`kube-scheduler`: A component that selects nodes for the pods to run on.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-scheduler`：一个组件，用于选择运行 Pods 的节点。'
- en: '`kube-controller-manager`: The controller manager oversees a number of smaller
    controllers that perform actions such as replicating pods and managing node operations.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-controller-manager`：控制器管理器监督多个较小的控制器，执行诸如复制 Pods 和管理节点操作等任务。'
- en: By using these components, the master node can maintain the desired state for
    the cluster. It is good to know that when you are interacting with Kubernetes,
    you are communicating with the master node. The master node itself will then communicate
    with the other components within the cluster.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些组件，主节点可以保持集群的期望状态。需要知道的是，当你与 Kubernetes 交互时，你实际上是在与主节点进行通信。主节点随后会与集群内的其他组件进行通信。
- en: Regular nodes
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常规节点
- en: These nodes are the nodes that will run the containers. These can be virtual
    machines or even physical machines. On these machines, the so called `kubelet`
    is installed. `kubelet` is the agent that's used to run pods/containers within
    the nodes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些节点是运行容器的节点。它们可以是虚拟机，甚至是物理机器。在这些机器上，安装了所谓的 `kubelet`。`kubelet` 是一个代理，用于在节点内运行
    Pods/容器。
- en: As you may have noticed in the preceding sections, there are also other core
    services within Kubernetes and we will discuss these next.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的章节中可能已经注意到的，Kubernetes 内部还有其他核心服务，我们接下来将讨论这些服务。
- en: Pod
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pod
- en: Within Kubernetes, pods are used to run the applications. Within the pods, it
    is specified which resources are required to run the application. The scheduler
    (`kube-schedular`) within Kubernetes checks where to run the application depending
    on the demands and the nodes coupled to the cluster.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，Pods 用于运行应用程序。在 Pods 内部，指定了运行应用程序所需的资源。Kubernetes 中的调度器（`kube-scheduler`）会根据需求和与集群关联的节点来检查在哪里运行应用程序。
- en: Pods themselves have a limited lifespan and are removed when new versions are
    deployed or, for example, when a node fails, pods can be replaced by pods on the
    same or another node.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 本身有一个有限的生命周期，在部署新版本时会被删除，或者例如当节点失败时，Pod 可以被同一节点或其他节点上的 Pod 替代。
- en: Service
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: The service is sometimes also referred to as the load balancer and is used to
    provide a logical grouping of pods and furnish them with connectivity (a way to
    connect).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务有时也被称为负载均衡器，用于提供 Pods 的逻辑分组并为它们提供连接性（即连接方式）。
- en: 'Three major services are as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 三个主要服务如下：
- en: '**Cluster IP**: Adding an internal IP to a cluster of pods.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群 IP**：为一个 Pod 集群添加一个内部 IP 地址。'
- en: '**Node port**: Port mapping to the underlying node directory to connect to
    the application/pod with the IP address of the node.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点端口**：将端口映射到底层节点目录，以便通过节点的 IP 地址连接到应用程序/Pod。'
- en: '**Load balancer**: This service adds a load balancer resource and configures
    an external IP address on the load balancer. On the external side, the load balancer
    will route traffic to the specific nodes based on the rules configured in the
    load balancer and internally to the correct pod.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡器**：此服务添加一个负载均衡器资源，并在负载均衡器上配置一个外部 IP 地址。在外部，负载均衡器会根据在负载均衡器中配置的规则将流量路由到特定节点，并在内部将流量路由到正确的
    Pod。'
- en: With these services, the internal and external connections for pods are arranged.
    The services and pods are all specified within a deployment.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些服务，Pods 的内部和外部连接被安排好了。服务和 Pods 都在部署中指定。
- en: Deployment
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: A deployment describes the desired state of an application. It describes the
    number of replicas, but also the update strategy. Kubernetes will track the health
    of the pods and will remove or add pods when needed to comply with the desired
    state that is described in the deployment.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 部署描述了应用程序的期望状态。它描述了副本的数量，还包括更新策略。Kubernetes 会跟踪 Pod 的健康状况，并在需要时移除或添加 Pod，以符合部署中描述的期望状态。
- en: These deployments are specified in a YAML file. For example, when running a
    container in Kubernetes, you must specify a replica set. A replica set ensures
    that a specified number of pod replicas are running at any given time.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部署在 YAML 文件中指定。例如，在 Kubernetes 中运行容器时，必须指定副本集。副本集确保在任何给定时间都有指定数量的 Pod 副本在运行。
- en: Operation of Kubernetes
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 操作
- en: 'When you are new to containers, and especially to Kubernetes, it is hard to
    figure things out immediately. However, to aid your understanding of the concept,
    take a look at the following diagram:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刚接触容器，尤其是 Kubernetes 时，可能很难立刻弄明白。不过，为了帮助你理解这个概念，请看以下图示：
- en: '![](img/efb2bde7-c6dd-48c6-9261-6377d9728cfc.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/efb2bde7-c6dd-48c6-9261-6377d9728cfc.png)'
- en: Deployments of containers to a Kubernetes cluster are defined in the so-called
    deployment file (**1**). In these deployment files, the desired state of the application
    is described. This desired state is described as a YAML file.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 容器部署到 Kubernetes 集群中是在所谓的部署文件 (**1**) 中定义的。在这些部署文件中，描述了应用程序的期望状态。这个期望状态被描述为一个
    YAML 文件。
- en: In this example, the desired state is a load balancer service and three pods
    (**2**). These pods are divided by the Kubernetes API on the nodes that run the
    containers (**3**). The service defined in the deployments file ensures that the
    traffic is routed to the specific pods. The deployment can be changed by updating
    it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，期望状态是一个负载均衡器服务和三个 Pod (**2**)。这些 Pod 被 Kubernetes API 在运行容器的节点上划分 (**3**)。在部署文件中定义的服务确保流量被路由到特定的
    Pod。可以通过更新部署来更改部署。
- en: The scheduler can also change deployments when, for example, automatic scaling
    is configured for the application. In that kind of scenario, a fourth pod could
    be added to the cluster. In the service, there can also be an external load balancer
    to route traffic to the internal load balancer of Kubernetes (**4**).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 调度程序还可以在配置了自动扩展应用程序的情况下更改部署。例如，在这种情况下，可能会向集群中添加第四个 Pod。在服务中，也可以有一个外部负载均衡器，将流量路由到
    Kubernetes 的内部负载均衡器 (**4**)。
- en: Azure Kubernetes Service
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure Kubernetes 服务
- en: '**Azure Kubernetes Service**, or **AKS**, is the Microsoft implementation of
    Kubernetes. Setting up a regular Kubernetes cluster is a lot of work, but with
    AKS, it has been made easier. This is because Kubernetes is a managed platform
    and the reason why almost all operational tasks are handled by the platform itself.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**Azure Kubernetes 服务**，或称 **AKS**，是 Microsoft 实现的 Kubernetes。设置一个常规的 Kubernetes
    集群需要很多工作，但使用 AKS 后，它变得更加简单。这是因为 Kubernetes 是一个托管平台，几乎所有的操作任务都由平台本身处理。'
- en: 'Some key functionalities of AKS are as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: AKS 的一些关键功能如下：
- en: Azure manages critical tasks, such as health monitoring and maintenance, including
    Kubernetes version upgrades and patching.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 管理关键任务，如健康监控和维护，包括 Kubernetes 版本升级和修补。
- en: Azure performs simple cluster scaling.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 执行简单的集群扩展。
- en: The master node of Kubernetes is fully managed.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 的主节点是完全托管的。
- en: Master nodes are free, and you only pay for running agent nodes.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主节点是免费的，你只需为运行中的代理节点付费。
- en: By using the AKS, a Kubernetes cluster can be operational within minutes. Besides
    that, the focus will be on the application as the master node is fully managed.
    Now, let's try to run a Kubernetes cluster with custom images.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 AKS，Kubernetes 集群可以在几分钟内投入使用。此外，重点将放在应用程序上，因为主节点是完全托管的。现在，让我们尝试使用自定义镜像运行一个
    Kubernetes 集群。
- en: Kubernetes in action
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 实战
- en: In the first few sections of this chapter, we created a container and deployed
    it to an Azure Container Instance. Let's now deploy this container to a Kubernetes
    cluster.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前几节中，我们创建了一个容器并将其部署到 Azure 容器实例中。现在让我们将该容器部署到 Kubernetes 集群中。
- en: Creating a cluster can be done via the Azure CLI or an ARM template. For ease
    of demonstration, the Azure CLI is used.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 创建集群可以通过 Azure CLI 或 ARM 模板完成。为了方便演示，本示例使用 Azure CLI。
- en: 'First, a new resource group needs to be created to host the Azure Kubernetes
    cluster:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，需要创建一个新的资源组来托管 Azure Kubernetes 集群：
- en: '[PRE7]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, we can create our Kubernetes cluster.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建我们的 Kubernetes 集群。
- en: Creating a Kubernetes cluster
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Kubernetes 集群
- en: 'When the resource group is created, a new Kubernetes cluster can be added to
    the group:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 创建资源组后，可以向该组添加新的 Kubernetes 集群：
- en: '[PRE8]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This command creates a new Kubernetes cluster with the name `mykubernetescluster` and
    with a single node. This means that there will be one virtual machine created
    in the Azure portal that is configured as a node for the Kubernetes cluster. In
    addition, the monitoring add-ons will be enabled on the cluster.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将创建一个名为 `mykubernetescluster` 的新 Kubernetes 集群，并且只有一个节点。这意味着在 Azure 门户中将创建一个虚拟机，配置为
    Kubernetes 集群的节点。此外，集群上将启用监控附加组件。
- en: The creation of this cluster will take a couple of minutes. In Azure, the `mykubernetescluster` service
    will be created in the specified resource group. Alongside this resource group,
    another group will be created by the Azure platform itself.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 创建该集群将需要几分钟时间。在 Azure 中，将在指定的资源组中创建 `mykubernetescluster` 服务。同时，Azure 平台本身还会创建另一个资源组。
- en: Kubernetes infrastructure
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 基础设施
- en: 'In this resource group, all virtualized infrastructure that is needed to run
    the cluster is created. This also means that in the future, new components can
    be added to this resource group depending on the demands of the application:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在此资源组中，创建了运行集群所需的所有虚拟化基础设施。这也意味着未来可以根据应用程序的需求向该资源组添加新组件：
- en: '![](img/557e2c0d-fe12-4e28-a57e-7eaaaf033bb1.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/557e2c0d-fe12-4e28-a57e-7eaaaf033bb1.png)'
- en: 'In the resource group created, you will find all the resources as mentioned
    to run the cluster:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建的资源组中，您将找到运行集群所需的所有资源：
- en: '![](img/8d9d45c5-bb83-437e-b183-bf2588a7b9ef.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d9d45c5-bb83-437e-b183-bf2588a7b9ef.png)'
- en: With the Kubernetes infrastructure now up and running, the management and deployment
    of resources can begin.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Kubernetes 基础设施已启动并运行，可以开始资源的管理和部署。
- en: Managing Kubernetes
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理 Kubernetes
- en: 'To manage Kubernetes, the `kubectl` command line is used and installed locally
    (or used in the Azure cloud shell). This is command-line interface tooling that
    will communicate with the Kubernetes API. Let''s see how to work with Kubernetes
    with this command line:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要管理 Kubernetes，使用 `kubectl` 命令行工具并在本地安装（或在 Azure 云控制台中使用）。这是一个命令行界面工具，将与 Kubernetes
    API 通信。让我们看看如何使用这个命令行工具与 Kubernetes 配合工作：
- en: 'If you do not already have it installed, run the following command to install
    the Azure CLI on your machine:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您尚未安装 Azure CLI，请运行以下命令在您的机器上安装 Azure CLI：
- en: '[PRE9]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To connect to the cluster, the credentials need to be retrieved and saved to
    the local system. This can be done by using the `az aks get-credentials` command and
    specifying the resource group and cluster name:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要连接到集群，需要检索凭据并将其保存到本地系统。这可以通过使用 `az aks get-credentials` 命令并指定资源组和集群名称来完成：
- en: '[PRE10]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With all the prerequisites configured, a lot of the base functionality can
    be run against the Kubernetes cluster. Take a look at these two commands for example:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置好所有前提条件后，许多基本功能可以针对 Kubernetes 集群运行。例如，可以参考以下两个命令：
- en: 'Retrieve the nodes of the cluster:'
  id: totrans-210
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索集群中的节点：
- en: '[PRE11]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Get the pods in the cluster:'
  id: totrans-212
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取集群中的 Pod：
- en: '[PRE12]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next to the preceding commands, you can also try the following Azure CLI command
    to open up the Kubernetes dashboard. This dashboard is a management interface
    built on top of the Kubernetes API that can be used next to the `kubectl` command
    line:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了前面的命令，您还可以尝试以下 Azure CLI 命令来打开 Kubernetes 仪表板。此仪表板是建立在 Kubernetes API 之上的管理界面，可以与
    `kubectl` 命令行一起使用：
- en: '[PRE13]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The dashboard is shown in the following screenshot:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板显示在以下截图中：
- en: '![](img/ae230049-85ac-4017-b74a-cb55061420ee.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae230049-85ac-4017-b74a-cb55061420ee.png)'
- en: A deployment file needs to be created to be able to run containers within the
    cluster. So let's see how to do this.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 需要创建一个部署文件才能在集群中运行容器。现在我们来看看如何做这件事。
- en: Deploying a container image
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署容器镜像
- en: 'We will create a deployment file and deploy it to Kubernetes. To do this, perform
    the following steps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个部署文件并将其部署到Kubernetes。为此，请执行以下步骤：
- en: 'Make a new file in your favorite text editor and call it `deploy.yaml`. Add
    the following information to the `deploy.yaml` file:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你喜欢的文本编辑器中创建一个新文件，并命名为`deploy.yaml`。将以下信息添加到`deploy.yaml`文件中：
- en: '[PRE14]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this example, the following is specified:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，指定了以下内容：
- en: A deployment is created with the name `kubernetes-deployment` (`metadata.name`).
  id: totrans-224
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署将使用`kubernetes-deployment`作为名称创建（`metadata.name`）。
- en: The deployment will create three replicas of the specified container (`spec.replicas`).
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署将创建指定容器的三个副本（`spec.replicas`）。
- en: The selector, in combination with the labels tag, is used to specify which components
    this deployment file will manage within Kubernetes.
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择器结合标签标签，用于指定该部署文件将在Kubernetes中管理哪些组件。
- en: The deployment file will create a container for the `msftazuredevops.azurecr.io/azuredevops:586` image
    file.
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署文件将为`msftazuredevops.azurecr.io/azuredevops:586`镜像文件创建一个容器。
- en: 'To deploy this file to Kubernetes, we will again use the `kubectl` command
    line and make use of the `apply` command:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将此文件部署到Kubernetes，我们将再次使用`kubectl`命令行并使用`apply`命令：
- en: '[PRE15]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `-f` argument is used to specify that a local path is used as a reference
    to a deployment file. After executing the command, you can open the Kubernetes
    dashboard to see the status and maybe even observe errors.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f`参数用于指定使用本地路径作为部署文件的引用。执行命令后，你可以打开Kubernetes仪表盘查看状态，甚至可能观察到错误。'
- en: It is possible that you encounter an error stating that pulling the image from
    your location failed. This could be a security issue. Under the hood, AKS is using
    a service principal. You should also see this when creating a new Kubernetes cluster.
    Make sure to give this service principal access rights on the Azure registry.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会遇到一个错误，提示从你的位置拉取镜像失败。这可能是一个安全问题。在后台，AKS使用一个服务主体。你在创建新的Kubernetes集群时应该也会看到这个问题。确保为该服务主体授予Azure注册表的访问权限。
- en: Following a successful execution, try the `get pods` command to see whether
    there are three pods within the system. If everything proceeded correctly, there
    should be three pods running within Kubernetes, but the application is still not
    available to the outside world.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行成功后，尝试使用`get pods`命令查看系统中是否有三个pod。如果一切顺利，Kubernetes中应该运行着三个pod，但应用程序仍然无法对外部访问。
- en: To make it available, we need to add a service to the deployment file.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其可用，我们需要向部署文件中添加一个服务。
- en: If you want to add it to the same file, add a line with these characters, `---`,
    between the deployments. This is not required when you also define separate files
    for deployment.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将其添加到同一个文件中，在不同的部署之间添加一行`---`字符。这在你为部署定义单独文件时不是必需的。
- en: 'In the `deploy.yaml` file, add the following section:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在`deploy.yaml`文件中，添加以下部分：
- en: '[PRE16]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This YAML section creates a load balancer and attaches it to the specified selector
    (`spec.selector.app`), meaning it will be used for the pods as we previously specified.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此YAML部分创建一个负载均衡器，并将其附加到指定的选择器（`spec.selector.app`），意味着它将用于我们之前指定的pod。
- en: In the background, Kubernetes will create an Azure load balancer and a public
    IP for connection to the pods.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台，Kubernetes将创建一个Azure负载均衡器和一个公共IP，以便与pod连接。
- en: 'To retrieve the external IP address of the service, use the following command
    until it displays the external IP address:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取服务的外部IP地址，请使用以下命令，直到显示外部IP地址：
- en: '[PRE17]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will return all services and their external IP addresses if it is present.
    Also take a quick peak at the additional resource group of Kubernetes to see which
    Azure resources are created.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回所有服务及其外部IP地址（如果存在）。还可以快速查看Kubernetes的附加资源组，看看哪些Azure资源已被创建。
- en: Well done! In this section, you learned how to create a Kubernetes cluster and
    deploy a container image on it via `kubectl` and deployment files. In the next
    section, we will take this forward and learn how to upgrade these containers.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 做得好！在这一部分，你学会了如何创建一个Kubernetes集群，并通过`kubectl`和部署文件在其上部署容器镜像。在下一部分，我们将继续学习如何升级这些容器。
- en: Upgrading containers
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级容器
- en: In Kubernetes, applications are very easily updated. For this, Kubernetes uses
    rolling updates, which means that traffic to a container is first drained before
    the container is replaced. During an upgrade of the application, Kubernetes will
    deploy an additional pod and run it through some specified probes.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，应用程序更新非常简便。为此，Kubernetes 使用滚动更新，这意味着在替换容器之前，流量会首先被排空。在应用程序升级过程中，Kubernetes
    会部署一个额外的 Pod 并通过一些指定的探针进行检测。
- en: A probe is a diagnostic that is periodically performed on a pod to check its
    status. During the upgrading or creation of a pod, Kubernetes brings up the additional
    pod and makes sure that it passes the liveness and readiness probes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 探针是一种定期对 Pod 执行的诊断操作，用来检查其状态。在升级或创建 Pod 时，Kubernetes 会启动额外的 Pod，并确保它通过存活和就绪探针。
- en: If the newly created pod succeeds with both probes, the traffic to a single
    old pod is terminated and traffic to the new pod is opened. For this termination,
    Kubernetes uses a termination grace period. During this period, the 2 connection
    to the load balancer is stopped and active connections are processed successfully,
    and new traffic is routed to a running pod. The default grace period is 30 seconds,
    during which the pod will be in a termination state and all old traffic to this
    pod is redirected to the other pods.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新创建的 Pod 成功通过了两个探针的检查，那么对旧 Pod 的流量将被终止，流量将转向新 Pod。为了终止旧 Pod 的流量，Kubernetes
    使用一个终止宽限期。在这个期间，连接到负载均衡器的连接会停止，活动连接将被成功处理，新的流量将被路由到一个正在运行的 Pod。默认的宽限期是 30 秒，在此期间，Pod
    将处于终止状态，所有流向该 Pod 的旧流量将被重定向到其他 Pods。
- en: 'This process continues until all pods are replaced with the new version. All
    of this is default behavior within Azure Kubernetes. A deployment is simply triggered
    by adjusting the deployment file and applying it with the same command as used
    previously:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程会持续进行，直到所有 Pods 都被替换为新版本。这一切都是 Azure Kubernetes 中的默认行为。通过调整部署文件并使用与之前相同的命令应用部署，便可触发一次部署：
- en: '[PRE18]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'By default, `httpGet` probes are added to pods that are being exposed, but
    they can also be customized by adding the readiness probe or liveness probe to
    the deployment:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`httpGet` 探针会添加到正在暴露的 Pods 中，但也可以通过向部署中添加就绪探针或存活探针来进行自定义：
- en: '[PRE19]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This readiness probe performs an `httpGet` request on the pod and has the following
    options:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 此就绪探针对 Pod 执行一个 `httpGet` 请求，并具有以下选项：
- en: '`path`: The path it should call for the `httpGet` request.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：它应该为 `httpGet` 请求调用的路径。'
- en: '`port`: The port number it should use for the call. This is also configured
    in our deployment file.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port`：调用时应使用的端口号。这个端口号也在我们的部署文件中进行配置。'
- en: '`initialDelaySeconds`: The seconds it waits before running the probe once the
    container is started.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialDelaySeconds`：容器启动后，探针第一次运行前等待的秒数。'
- en: '`periodSeconds`: The number of seconds the probe waits before it times out.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`periodSeconds`：探针等待超时之前的秒数。'
- en: '`successThreshold`: The amount of success required for the probe minimum value
    is `1`.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`successThreshold`：探针所需的成功次数，最小值为 `1`。'
- en: 'As mentioned, a deployment has a default rolling upgrade scenario configured.
    The configuration of the rolling deployment can be retrieved by using the following
    command:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，部署有一个默认的滚动升级场景配置。可以使用以下命令来获取滚动部署的配置：
- en: '[PRE20]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you are interested in doing so, build a new version of your container and
    upgrade it within Kubernetes. Before running the upgrade, make sure you have the
    dashboard open and refresh the page during the update and you will see extra pods
    coming up and old pods being terminated.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣这样做，构建一个新版本的容器并在 Kubernetes 中进行升级。在运行升级之前，确保打开仪表板，并在更新期间刷新页面，你将看到额外的 Pods
    启动并且旧的 Pods 被终止。
- en: In this section, we learned how to upgrade containers, which will help you stay
    up to date with the latest version. Moving forward, in the next section, we will
    look further into the scaling of containers and Kubernetes.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何升级容器，这将帮助你保持最新版本。接下来，在下一节中，我们将进一步探讨容器和 Kubernetes 的扩展。
- en: Scaling containers and Kubernetes
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展容器和 Kubernetes
- en: 'As the demand for your application may grow, you will need to scale the application.
    Scaling the application can be done in multiple ways and different components
    can be scaled:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序需求的增长，你需要扩展应用程序。应用程序的扩展可以通过多种方式完成，不同的组件也可以进行扩展：
- en: '![](img/0ba82303-be6e-4768-9396-6f29a7de1f2a.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ba82303-be6e-4768-9396-6f29a7de1f2a.png)'
- en: The preceding diagram shows you the different ways to scale your application
    or cluster, which we will discuss over the upcoming subsections.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 上图展示了不同的扩展应用程序或集群的方法，接下来我们将会在以下小节中讨论这些方法。
- en: Scaling pods manually
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动扩展 pods
- en: 'Pods can easily be scaled by updating the number of replicas. Try getting your
    pods by using the `kubectl get pods` command and increase the number of replicas
    by using the following command:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过更新副本数量轻松扩展 pods。尝试使用 `kubectl get pods` 命令获取您的 pods，然后使用以下命令增加副本数量：
- en: '[PRE21]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this command, the pods are scaled up or down depending on the number of
    replicas. The up or specified scaling is down as per deployment.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令，pods 的数量将根据副本的数量进行扩展或收缩。扩展或收缩将根据部署中的设置进行。
- en: Autoscaling pods
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动扩展 pods
- en: Azure Kubernetes also supports autoscaling. The scheduler will then update the
    number of pods depending on CPU utilization or other metrics that are available.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Kubernetes 也支持自动扩展。调度程序将根据 CPU 使用率或其他可用指标来更新 pods 的数量。
- en: Kubernetes uses the metrics server for this. The metrics server collects metrics
    from the summary API of the kubelet agents that run on the nodes within the cluster.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 使用指标服务器来实现这一功能。指标服务器从在集群中运行的节点上的 kubelet 代理的总结 API 中收集指标。
- en: The metrics service is available by default if you are using Kubernetes version
    1.10 or above. If you are using an older version, you will have to install the
    metrics server manually.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 Kubernetes 1.10 或更高版本，默认情况下指标服务是可用的。如果您使用的是较旧版本，您将需要手动安装指标服务器。
- en: The autoscale functionality also requires some configuration on the deployment
    side of Kubernetes. For a deployment, you need to specify the requests and limits
    for the running container. These values are specified for a specific metric, for
    example, the CPU.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 自动扩展功能还需要在 Kubernetes 的部署端进行一些配置。对于部署，您需要指定正在运行的容器的请求和限制。这些值是针对特定指标指定的，例如 CPU。
- en: 'In the following example, there are requests and limits specified for the CPU
    metric. The CPU metric is measured in CPU units. In Azure, one unit stands for
    one core. For different platforms, it can have a different meaning:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，已为 CPU 指标指定了请求和限制。CPU 指标是以 CPU 单位来衡量的。在 Azure 中，一个单位代表一个核心。不同的平台上可能有不同的含义：
- en: '[PRE22]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This part can be added to the container in the deployment file and this will
    make sure that the pods can be autoscaled when large numbers of requests need
    to be served.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分可以添加到部署文件中的容器中，以确保当需要处理大量请求时，pods 可以自动扩展。
- en: 'With the updated deployment file, deploy it and make an autoscale rule within
    the Kubernetes cluster:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更新的部署文件进行部署，并在 Kubernetes 集群中创建一个自动扩展规则：
- en: '[PRE23]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This rule will update the deployment with autoscale functionality. If average
    CPU utilization across all pods exceeds 60% of their requested usage, the autoscaler
    increases the pods up to a maximum of 10 instances. A minimum of one instance
    is then defined for the deployment:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 该规则将使用自动扩展功能更新部署。如果所有 pods 的平均 CPU 使用率超过其请求使用量的 60%，自动扩展器将把 pods 扩展至最多 10 个实例。然后为部署定义最小
    1 个实例：
- en: 'After creating the autoscaler, you can check it by running the following command:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自动扩展器后，您可以通过运行以下命令检查它：
- en: '[PRE24]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**HPA** stands for **horizontal pod autoscaler**.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**HPA** 代表 **水平 Pod 自动扩展器**。'
- en: Try creating a CPU-intensive operation within an application and checking automatic
    pod creation during execution. The Kubernetes cluster will notice the significant
    amount of CPU usage and will scale out the cluster automatically by creating multiple
    pods.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在应用程序中创建一个 CPU 密集型操作，并检查执行期间的自动 pod 创建。Kubernetes 集群将注意到大量 CPU 使用情况，并会通过创建多个
    pods 自动扩展集群。
- en: Once the intensive operation is finished, Kubernetes will scale the number of
    pods down to the minimum.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦密集操作完成，Kubernetes 将把 pods 的数量缩减到最小值。
- en: Scaling nodes
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点扩展
- en: 'Alongside scaling pods, Kubernetes can also scale the number of nodes that
    run within the Kubernetes cluster. The number of nodes can be scaled using the
    following commands:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 除了扩展 pods，Kubernetes 还可以扩展在 Kubernetes 集群中运行的节点数量。可以使用以下命令来扩展节点数量：
- en: 'First, get the information pertaining to the current environment by requesting
    the number of nodes:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，获取有关当前环境的信息，方法是请求节点数量：
- en: '[PRE25]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, use this command to update the `nodepool`. Extract the name of the `nodepool`
    from the result of the last command:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用此命令更新 `nodepool`。从上一个命令的结果中提取 `nodepool` 的名称：
- en: '[PRE26]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Scaling the number of nodes up can increase the performance drastically. This
    will also make the cluster more expensive. By scaling the number of cluster nodes
    down, costs can decrease and you are only using the resources that are actually
    required by your application. To keep track of this, the nodes can also be autoscaled.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展节点数可以大幅提高性能。这也会使集群变得更昂贵。通过缩减集群节点数，可以降低成本，并且只使用应用程序实际需要的资源。为了跟踪这一点，节点还可以自动扩展。
- en: Autoscaling nodes
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动扩展节点
- en: 'Alongside the manual scaling of nodes, nodes can also scale automatically by
    updating the Kubernetes cluster. This can be done by using the `az aks update`
    command. With this command, you can set the minimum and maximum node counts. The
    autoscaler will then make sure that nodes are created when needed:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 除了手动扩展节点外，节点还可以通过更新 Kubernetes 集群自动扩展。这可以通过使用 `az aks update` 命令来完成。使用此命令，你可以设置最小和最大节点数量。然后，自动扩展器会确保在需要时创建节点：
- en: '[PRE27]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Azure Kubernetes also has the option to scale out with Azure Container Instances.
    To use this option, a specific configuration needs to be applied when creating
    the AKS cluster. This is mainly required because Azure Container Instances needs
    a specific subnet within the virtual network.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Kubernetes 还可以通过 Azure Container Instances 实现扩展。要使用此选项，在创建 AKS 集群时需要应用特定配置。主要是因为
    Azure Container Instances 需要在虚拟网络中指定一个子网。
- en: In this section, we learned to scale containers and the cluster to drastically
    increase performance. Next up is deployment from Azure DevOps to facilitate continuous
    deployment.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何扩展容器和集群，以大幅提升性能。接下来是从 Azure DevOps 进行部署，以便实现持续部署。
- en: Deploying to Kubernetes with Azure DevOps
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Azure DevOps 部署到 Kubernetes
- en: We have seen a lot of options for deploying and configuring the Kubernetes cluster
    via the command line. When working with DevOps, however, changes need to be applied
    in a continuous way.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了许多通过命令行部署和配置 Kubernetes 集群的选项。然而，在使用 DevOps 时，变化需要以持续的方式进行应用。
- en: 'For this, there is the Kubernetes manifest task within Azure DevOps, which
    contains a lot of functionalities to manage a Kubernetes cluster:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，Azure DevOps 中有 Kubernetes 清单任务，包含许多管理 Kubernetes 集群的功能：
- en: '[PRE28]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding example, the following is configured:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，配置了以下内容：
- en: '`action`: The kind of action to we want to perform. In this example, the `deploy` action
    is used because we want to deploy/apply a deployment file.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`action`：我们希望执行的操作类型。在此示例中，使用 `deploy` 操作，因为我们想要部署/应用一个部署文件。'
- en: '`kubernetesServiceConnection`: The service connection to the Kubernetes cluster.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubernetesServiceConnection`：与 Kubernetes 集群的服务连接。'
- en: '`manifests`: The path to the manifest file. As we are using the `deploy` action,
    this should be a reference to the deployment file.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`manifests`：清单文件的路径。由于我们使用的是 `deploy` 动作，因此这应该是指向部署文件的引用。'
- en: '`containers`: A special field where you can override the version of the container
    being deployed. By specifying the above, every image is specified in the deployment
    manifest with the `msftazuredevops.azurecr.io` reference and the `azuredevops` repository is
    replaced by the new value as configured in this field.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`containers`：一个特殊字段，你可以在这里覆盖要部署的容器的版本。通过指定上述内容，每个镜像都在部署清单中指定了 `msftazuredevops.azurecr.io`
    引用，并且 `azuredevops` 仓库会被替换为此字段中配置的新值。'
- en: Using a Kubernetes destination environment within Azure DevOps pipelines also
    has the advantage of seeing the environment running within Azure DevOps. This
    will show the number of running pods within the cluster.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure DevOps 管道中使用 Kubernetes 目标环境的另一个优点是能够看到在 Azure DevOps 中运行的环境。这将显示集群中正在运行的
    pods 数量。
- en: 'Try it out with the following stage configuration for a build that will publish
    the deployment files to the artifact location of Azure DevOps:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用以下阶段配置进行构建，该配置将把部署文件发布到 Azure DevOps 的工件位置：
- en: '[PRE29]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next to the build stage, add the following release stage. Following the initial
    execution of the pipeline, a new environment will be available within Azure DevOps.
    In the environment created by the release, attach the Kubernetes cluster to see
    information on the running pods:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建阶段旁边，添加以下发布阶段。管道初次执行后，Azure DevOps 中将提供一个新环境。在发布创建的环境中，附加 Kubernetes 集群，以查看正在运行的
    pods 信息：
- en: '[PRE30]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the example, two stages are specified for a multi-stage pipeline. The first
    stage will build the container image via the Docker task and publish it to a container
    registry. After publishing the image, it also publishes a number of build artifacts,
    in this case, the Kubernetes manifests.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，为多阶段管道指定了两个阶段。第一阶段将通过 Docker 任务构建容器镜像，并将其发布到容器注册表。发布镜像后，它还会发布一些构建产物，在本例中是
    Kubernetes 清单。
- en: The second stage deploys to a specific environment called Kubernetes. This environment
    will also be created in Azure DevOps if it has not already been added. During
    the remainder of the process, it retrieves the published artifacts of the build
    stage and uses the Kubernetes manifest task to deploy the Kubernetes resources.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段将部署到一个名为 Kubernetes 的特定环境。如果该环境尚未添加，它也将在 Azure DevOps 中创建。在剩余的过程中，它会检索构建阶段发布的产物，并使用
    Kubernetes 清单任务来部署 Kubernetes 资源。
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned what containers are and how they relate to
    DevOps. Where DevOps is more of a cultural thing, containers are a way to support
    it technically. You have also learned how to create container images via a Dockerfile,
    and specifically by using a multi-stage build file. Finally, we dived into Kubernetes,
    where we learned a way to host containers and also manage the running containers
    by using the `kubectl` command.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了容器是什么，以及它们如何与 DevOps 相关联。DevOps 更像是一种文化，而容器则是技术上支持 DevOps 的方式。你还学习了如何通过
    Dockerfile 创建容器镜像，特别是使用多阶段构建文件。最后，我们深入了解了 Kubernetes，学习了如何托管容器，并通过使用 `kubectl`
    命令管理正在运行的容器。
- en: Using the knowledge acquired in this chapter, you are now able to deploy applications
    to Kubernetes and make sure that it scales with the number of requests it receives.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 运用本章所学的知识，你现在能够将应用程序部署到 Kubernetes，并确保它随着接收的请求数量进行扩展。
- en: In the next chapter, you will learn more about facilitating the DevOps process
    by using Azure DevOps. You will learn what works for your organization and team
    and what doesn't and how to implement that structure and your approach using Azure
    DevOps.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何通过使用 Azure DevOps 来促进 DevOps 流程。你将了解哪些方法适合你的组织和团队，哪些不适合，并学习如何通过
    Azure DevOps 实现这些结构和方法。
- en: Questions
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding the material covered in this chapter. You will find the answers in the
    *Assessments* section of the Appendix:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，以下是一些问题，帮助你测试自己对本章内容的理解。你可以在附录的*评估*部分找到答案：
- en: What are the benefits of containers for DevOps?
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器对 DevOps 的好处有哪些？
- en: 'True or false: A specific container can be hosted on different platforms (Azure/AWS).'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断对错：特定容器可以托管在不同的平台上（Azure/AWS）。
- en: Is it possible to add container support to an existing application?
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否可以为现有应用程序添加容器支持？
- en: What is the `RUN` command used for within a Dockerfile?
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RUN` 命令在 Dockerfile 中的作用是什么？'
- en: Kubernetes can be scaled on different components. What are these components?
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes 可以在不同的组件上进行扩展。这些组件有哪些？
- en: Further reading
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Information on installing the Azure CLI: [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest)'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Azure CLI 的信息：[https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest)
- en: 'Information on installing Docker Desktop: [https://docs.docker.com/docker-for-windows/install/](https://docs.docker.com/docker-for-windows/install/)'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Docker Desktop 的信息：[https://docs.docker.com/docker-for-windows/install/](https://docs.docker.com/docker-for-windows/install/)
- en: 'More information on Kubernetes: [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Kubernetes 的更多信息：[https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)
- en: 'You can find more information regarding Azure Kubernetes at the following link:
    [https://azure.microsoft.com/en-us/topic/what-is-kubernetes/](https://azure.microsoft.com/en-us/topic/what-is-kubernetes/)'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过以下链接找到更多关于 Azure Kubernetes 的信息：[https://azure.microsoft.com/en-us/topic/what-is-kubernetes/](https://azure.microsoft.com/en-us/topic/what-is-kubernetes/)
- en: 'Information on Azure Container Registry: [https://docs.microsoft.com/en-us/azure/container-registry/container-registry-intro](https://docs.microsoft.com/en-us/azure/container-registry/container-registry-intro)'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Azure 容器注册表的信息：[https://docs.microsoft.com/en-us/azure/container-registry/container-registry-intro](https://docs.microsoft.com/en-us/azure/container-registry/container-registry-intro)
- en: 'More information regarding multi-stage builds: [https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/)'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关多阶段构建的更多信息：[https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/)
