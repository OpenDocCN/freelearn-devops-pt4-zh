- en: Introducing the GitLab Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 GitLab 架构
- en: Understanding the context of the GitLab project will help us to appreciate the
    choices that were made with regard to the design of the GitLab workflow. The GitLab
    project started out as a small, open source project, and has grown to be an organization
    of 400 people and thousands of volunteers. It is currently available in two versions,
    a free **Community Edition** (**CE**) and an **Enterprise Edition** (**EE**) with
    a proprietary license. There are several tiers of support for the enterprise version.
    Although it is proprietary licensed, the source code for that version is publicly
    available from GitLab.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 GitLab 项目的背景有助于我们理解在 GitLab 工作流设计中所做的选择。GitLab 项目最初是一个小型的开源项目，后来发展成了一个拥有
    400 人和数千名志愿者的组织。当前，它有两个版本：一个是免费的 **社区版**（**CE**），另一个是带有专有许可证的 **企业版**（**EE**）。企业版提供多个支持层级。虽然它是专有许可证，但该版本的源代码是公开的，可以从
    GitLab 获取。
- en: To master GitLab, it is necessary to have a solid understanding of its individual
    components. In this chapter, we will look at the basic components of a GitLab
    installation, paying special attention to GitLab **Continuous Integration** (**CI**)
    and the accompanying runners. As the different components can be distributed across
    servers or even cloud providers, we will also provide an overview of those providers
    and how GitLab views them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 要掌握 GitLab，必须对其各个组件有扎实的了解。在本章中，我们将探讨 GitLab 安装的基本组件，特别关注 GitLab **持续集成**（**CI**）及其附带的运行器。由于不同组件可以分布在不同的服务器或云服务提供商上，我们还将提供这些提供商的概述，并介绍
    GitLab 如何看待它们。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The origins of GitLab
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitLab 的起源
- en: GitLab CE or EE
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitLab CE 或 EE
- en: The core components of GitLab
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitLab 的核心组件
- en: GitLab CI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitLab CI
- en: GitLab Runners
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitLab 运行器
- en: Cloud native
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云原生
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow along with the instructions in this chapter, please download the Git
    repository with examples**,** available at GitHub: [https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter01](https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter01). You
    will also require Homebrew: [https://brew.sh/](https://brew.sh/).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章的操作步骤，请下载包含示例的 Git 仓库，网址为 GitHub：[https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter01](https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter01)。你还需要安装
    Homebrew：[https://brew.sh/](https://brew.sh/)。
- en: The origins of GitLab
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitLab 的起源
- en: 'The story began in 2011, when Dimitri Zaporozhets, a web programmer from Ukraine,
    was faced with a common problem. He wanted to switch to Git for version management
    and GitHub to collaborate, but that was not allowed in his company. He needed
    a tool that did not hinder him in developing code and was easy to use. Like many
    developers, he had issues with the collaboration tool that he was obliged to use.
    To get around those issues, he created his side project in Ruby on Rails: GitLab.
    Together with his colleague, Valery Sizov, he developed this project alongside
    his regular work.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 故事始于 2011 年，当时来自乌克兰的网页程序员 Dimitri Zaporozhets 面临一个常见问题。他想要使用 Git 来进行版本管理，并通过
    GitHub 进行协作，但在公司中无法使用。他需要一个既不妨碍他开发代码又易于使用的工具。像许多开发者一样，他遇到了被迫使用的协作工具的问题。为了解决这些问题，他用
    Ruby on Rails 创建了一个侧项目：GitLab。在与同事 Valery Sizov 的合作下，他在常规工作之余开发了这个项目。
- en: 'After this initiative, the project grew enormously:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一举措后，该项目迅速发展壮大：
- en: '| **Date** | **Fact** |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **日期** | **事实** |'
- en: '| 2011 | Sytze Sybrandij, the future CEO of GitLab, is impressed by the GitLab
    project and code, and offers Zaporozhets the opportunity to try to commercialize
    it via [https://about.gitlab.com/.](https://about.gitlab.com/) |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 2011 | GitLab 的未来 CEO Sytze Sybrandij 对 GitLab 项目和代码印象深刻，并邀请 Zaporozhets
    尝试通过 [https://about.gitlab.com/](https://about.gitlab.com/) 将其商业化。 |'
- en: '| 2012 | GitLab was announced to a broader audience via Hacker News ([https://news.ycombinator.com/item?id=4428278](https://news.ycombinator.com/item?id=4428278)).
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 2012 | GitLab 通过 Hacker News 向更广泛的受众发布 ([https://news.ycombinator.com/item?id=4428278](https://news.ycombinator.com/item?id=4428278))。
    |'
- en: '| 2013 | Dimitri Zaporozhets decides to work full-time on GitLab and joins
    the company. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 2013 | Dimitri Zaporozhets 决定全职投入到 GitLab，并加入公司。 |'
- en: '| 2015 | GitLab becomes part of the Y Combinator class and received VC funding
    that year. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 2015 | GitLab 成为 Y Combinator 的一部分，并获得了当年的风险资本资助。 |'
- en: '| 2018 | GitLab receives another $100 million of VC funding and is valued at
    $1 billion. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 2018 | GitLab 获得了 1 亿美元的风险投资，并估值为 10 亿美元。 |'
- en: '| 2019 | The GitLab company employs over 600 employees. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 2019 | GitLab 公司拥有超过 600 名员工。 |'
- en: The initial idea of GitLab was to earn money from open source technology by
    offering support services. However, what happened was that companies started to
    bring in consultants only to upgrade GitLab, and then they would stop the service
    contract. It became clear that going for a 100% open source was not going to be
    competitive. Instead of this, therefore, they chose **open core**. Under open
    core, a company releases a core software system under an open source license.
    A different version of the software is sold under a commercial license and contains
    more features.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 的最初想法是通过提供支持服务来从开源技术中赚钱。然而，发生的情况是，公司开始仅仅通过顾问来升级 GitLab，然后停止服务合同。很明显，100%
    开源的路线并不具有竞争力。因此，他们选择了**开放核心**模式。在开放核心下，公司以开源许可证发布核心软件系统。软件的不同版本则以商业许可证销售，并包含更多功能。
- en: 'So, GitLab was split up into two editions: an open source version, and an enterprise
    version.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，GitLab 被分为两个版本：一个是开源版本，一个是企业版本。
- en: Exploring GitLab editions – CE and EE
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 GitLab 版本 – CE 和 EE
- en: The core of the GitLab software is called the **CE**. It is distributed under
    the MIT license, which is a permissive free software license created at the Massachusetts
    Institute of Technology. You are allowed to modify the software and use it in
    your creations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 软件的核心被称为**CE**。它以 MIT 许可证发布，这是麻省理工学院创建的一种宽松的自由软件许可证。您可以修改该软件并在您的创作中使用它。
- en: No feature that ever made it to CE will ever be removed, or moved to a closed
    source version. When GitLab EE was created in 2013, it was, at its core, GitLab
    CE, but it had additional enterprise features, such as **Lightweight Directory
    Access Protocol** (**LDAP**) groups. Those features are not open source, per se,
    but can be added to the core version if they are perceived by the company as a
    core feature. The idea was that companies should also contribute as much as possible
    to solving problems and creating new features.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 任何进入 CE 的功能都不会被删除，或者移至封闭源版本。当 GitLab EE 在 2013 年创建时，其核心是 GitLab CE，但它具有额外的企业功能，如**轻量级目录访问协议**（**LDAP**）组。这些功能本身并不是开源的，但如果公司认为它们是核心功能，可以将它们添加到核心版本中。这个想法是，企业应该尽可能多地为解决问题和创建新功能做出贡献。
- en: 'In 2016, the GitLab EE product was divided into three tiers: Starter, Premium,
    and Ultimate. Each tier is about five times more expensive than the previous one
    and contains more features and support options, as mentioned in the following
    table:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 2016 年，GitLab EE 产品被分为三个层级：Starter、Premium 和 Ultimate。每个层级比前一个层级贵大约五倍，并包含更多功能和支持选项，如下表所示：
- en: '| **Version** | **Features (short list)** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **版本** | **功能（简要列表）** |'
- en: '| Starter | Everything on core GitLab CE:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '| Starter | 核心 GitLab CE 的所有功能：'
- en: CI/CD
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI/CD
- en: Project Issue Board
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目问题板
- en: Mattermost integrations
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mattermost 集成
- en: Time tracking
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间跟踪
- en: GitLab pages
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitLab 页面
- en: '|'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Premium | More enterprise features such as the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '| Premium | 更多企业功能，如下所示：'
- en: Maven and NPM repository functionality
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven 和 NPM 仓库功能
- en: Protected environments
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受保护环境
- en: Burndown charts
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 燃尽图
- en: Multiple LDAP servers and Active Directory support
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个 LDAP 服务器和 Active Directory 支持
- en: '|'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Ultimate | All options, including the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '| Ultimate | 所有选项，包括以下内容：'
- en: All security scanning tools
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有安全扫描工具
- en: Epics
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 史诗
- en: Free guest users
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 免费的访客用户
- en: Web terminal for the web IDE
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web IDE 的 Web 终端
- en: '|'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: GitLab has a lot of features, but let's concentrate first on the basic building
    blocks.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 有很多功能，但我们首先要集中讨论基本的构建模块。
- en: The core system components of GitLab
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitLab 的核心系统组件
- en: 'GitLab is not a monolithic application. It tries to follow the Unix philosophy,
    which means that a software module should do only one particular thing, and do
    it well. The components that GitLab is made of are not as small and elegant as
    Unix''s `awk` and `sed`, but each component has a single purpose. You can find
    a high-level overview of these components in the following diagram:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 不是一个单体应用程序。它试图遵循 Unix 的哲学，即软件模块应该只做一件特定的事情，并做好这件事。GitLab 的组件虽然不像 Unix
    的`awk`和`sed`那样小巧精致，但每个组件都有一个明确的目标。您可以在以下图表中找到这些组件的高级概览：
- en: '![](img/f9662aa4-972d-4c6f-9b9b-c406e97a3768.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f9662aa4-972d-4c6f-9b9b-c406e97a3768.png)'
- en: Gitlab started as a pure Ruby on Rails application, but some components were later
    redesigned using Go. Ruby on Rails is a development framework built on top of
    the Ruby programming language. It implements a model-view-controller pattern and
    offers methods to connect to different databases (for example, ActiveRecord).
    It values convention over configuration and **don't-repeat-yourself** (**DRY**)
    programming. It is very well suited to rapid development, and at the same time,
    it is highly performant and has many features.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 最初是一个纯 Ruby on Rails 应用程序，但后来一些组件使用 Go 重新设计。Ruby on Rails 是一个基于 Ruby
    编程语言构建的开发框架。它实现了模型-视图-控制器模式，并提供了连接不同数据库的方法（例如，ActiveRecord）。它提倡“约定优于配置”和 **不要重复自己**（**DRY**）编程。它非常适合快速开发，同时又具备高性能和许多功能。
- en: Let's dive a little deeper into those components in order to understand their
    roles.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解这些组件，以便理解它们的角色。
- en: NGINX
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NGINX
- en: 'The Unicorn web component cannot be used directly as it does not offer all
    the features for handling clients. The reverse proxy that is bundled by default
    is NGINX. It is also possible to use Apache as a frontend for GitLab, but it is
    preferable to use NGINX. There are many web servers available that could be installed
    in front of Unicorn, but in the end, there are basically two types, which are
    as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Unicorn Web 组件不能直接使用，因为它没有提供处理客户端的所有功能。默认捆绑的反向代理是 NGINX。也可以使用 Apache 作为 GitLab
    的前端，但推荐使用 NGINX。有很多可以安装在 Unicorn 前端的 Web 服务器，但最终基本上可以分为两种类型，分别如下：
- en: Process-based (forking or threaded)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于进程的（分叉或多线程）
- en: Asynchronous
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步
- en: NGINX and lighttpd are probably the two most-well known asynchronous servers.
    Apache is without a doubt the de facto standard process-based server. The biggest
    difference between the two types is how they handle scalability. For a process-based
    server, any new connections require a thread, while an event-driven, asynchronous
    server such as NGINX only needs a few threads (or, theoretically, only one). For
    lighter workloads, this does not matter much, but you will see a big difference
    when the number of connections grows, especially in terms of RAM. When serving
    tens of thousands of simultaneous connections, the amount of RAM used by NGINX
    would still hover around a couple of megabytes. Apache would either use hundreds,
    or it would not work at all. This is why NGINX is the better choice.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX 和 lighttpd 可能是两个最著名的异步服务器。Apache 毋庸置疑是事实上的标准进程型服务器。这两种服务器的最大区别在于它们如何处理可扩展性。对于进程型服务器，每一个新连接都需要一个线程，而像
    NGINX 这样的事件驱动异步服务器只需要几个线程（或理论上只需一个）。对于轻量级工作负载，这没有太大区别，但当连接数增多时，尤其是在内存方面，你会看到很大的差异。当处理成千上万的并发连接时，NGINX
    使用的内存仍然保持在几兆字节左右，而 Apache 则可能使用几百兆字节，或者根本无法工作。这就是为什么 NGINX 是更好的选择。
- en: You can run NGINX on many platforms and it is quite easy to install, as you
    can see in the next section, where you'll try it yourself!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在许多平台上运行 NGINX，并且安装过程非常简单，正如你在接下来的章节中看到的，你将亲自尝试！
- en: Installing NGINX
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 NGINX
- en: 'NGINX is part of most package management repositories, including `yum` and `apt`.
    Installing NGINX on `apt`-based distributions such as Debian and Ubuntu would
    involve the following commands:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX 是大多数包管理仓库的一部分，包括 `yum` 和 `apt`。在基于 `apt` 的发行版（如 Debian 和 Ubuntu）上安装 NGINX
    需要以下命令：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On macOS, we can use `brew` for a fast one-line command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，我们可以使用 `brew` 执行一个快速的一行命令：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Of course, it is always possible to install from the source. Remember to install
    the dependencies first. These include PCRE, zlib, and OpenSSL. You can find the
    source code at the following website: [http://nginx.org/en/download.html](http://nginx.org/en/download.html).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也可以从源代码安装。记得先安装依赖项，包括 PCRE、zlib 和 OpenSSL。你可以在以下网站找到源代码：[http://nginx.org/en/download.html](http://nginx.org/en/download.html)。
- en: Before you start NGINX, you need to provide a configuration file for it to connect
    to the Unicorn web component. The interface between the two servers is a local
    Unix domain socket.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动 NGINX 之前，你需要提供一个配置文件，使其能够连接到 Unicorn Web 组件。这两个服务器之间的接口是本地 Unix 域套接字。
- en: 'Please create a file called `nginx.config` and add the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请创建一个名为 `nginx.config` 的文件，并添加以下内容：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding section is mandatory and you can specify how NGINX will handle
    connections. For this example, we just accept the default; that is why the section
    is empty.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 上述部分是必需的，你可以指定 NGINX 如何处理连接。对于这个例子，我们接受默认设置；这就是为什么该部分为空的原因。
- en: 'The next section is an HTTP block. You can define several and let settings
    be inherited, but here, we define that HTTP requests should be redirected to `upstream
    gitlab-app`, which is Unicorn. You can also see that the interface is the Unix
    socket:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分是一个 HTTP 块。你可以定义多个，并让设置继承，但在这里，我们定义 HTTP 请求应该重定向到 `upstream gitlab-app`，即
    Unicorn。你还可以看到接口是 Unix 套接字：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, we have defined how NGINX connects to the backend, which is GitLab. On
    the frontend, we want to accept requests from HTTP clients. This is taken care
    of via a `server` block:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们已经定义了 NGINX 如何连接到后端，即 GitLab。在前端，我们希望接受来自 HTTP 客户端的请求。这是通过 `server` 块来处理的：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next directive inside this block handles a path that doesn''t exist on
    disk. It forwards the request to the app:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个块中的下一个指令处理磁盘上不存在的路径。它将请求转发到应用程序：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following is the definition of `gitlab-app`, and it modifies request headers
    to proxy the request to the upstream Unicorn server via the Unix socket:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `gitlab-app` 的定义，它修改请求头以通过 Unix 套接字将请求代理到上游 Unicorn 服务器：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Don''t forget to close the server and HTTP block:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记关闭服务器和 HTTP 块：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have a configuration, you can run this NGINX in the following way:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了配置文件，你可以通过以下方式运行这个 NGINX：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The command should return no output and the NGINX server runs in the background.
    You canverify this yourselfby checking the process list:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令不应返回任何输出，且 NGINX 服务器会在后台运行。你可以通过检查进程列表自己验证这一点：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that you have a running NGINX server, if you point your browser to `http://localhost:8080`, you
    should receive a 502 error. This is because there is no Unicorn server listening
    on a Unix socket yet. We will demonstrate how to run Unicorn in the next section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个运行中的 NGINX 服务器，如果你在浏览器中访问 `http://localhost:8080`，你应该会收到一个 502 错误。这是因为还没有
    Unicorn 服务器在 Unix 套接字上监听。我们将在下一部分展示如何运行 Unicorn。
- en: Unicorn
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unicorn
- en: Unicorn is an HTTP server for applications that deal with well-performing clients
    on connections that show low latency and have enough bandwidth. It takes advantage
    of features that are present in the core of Linux-like systems. It is called a
    **Rack HTTP server** because it implements HTTP for Rack applications. Rack, in
    turn, is actually a Ruby implementation of a minimal interface to deal with web
    requests, which you can use in your code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Unicorn 是一个为处理高性能客户端的应用程序设计的 HTTP 服务器，它能够在低延迟和足够带宽的连接上运行。它利用了 Linux 类系统内核中的特性。它被称为
    **Rack HTTP 服务器**，因为它实现了用于 Rack 应用程序的 HTTP。Rack 实际上是一个 Ruby 实现的最小接口，用于处理 Web 请求，你可以在代码中使用它。
- en: You can find the project at [https://rack.github.io](https://rack.github.io).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://rack.github.io](https://rack.github.io) 找到该项目。
- en: Unicorn runs as a daemon server in Unix and is programmed in Ruby and the C
    programming language. Using Ruby means that it can also run a Ruby on Rails application
    such as GitLab.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Unicorn 作为守护进程在 Unix 系统中运行，使用 Ruby 和 C 编程语言编写。使用 Ruby 意味着它还可以运行 Ruby on Rails
    应用程序，例如 GitLab。
- en: Now that you have a grasp of the basic concepts of Unicorn, we can install it,
    and also connect NGINX, which we installed earlier, to it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了 Unicorn 的基本概念，我们可以安装它，并将之前安装的 NGINX 连接到它。
- en: Installing Unicorn
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Unicorn
- en: 'If you have Ruby installed, you can easily install Unicorn using the following
    steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经安装了 Ruby，可以按照以下步骤轻松安装 Unicorn：
- en: 'The first step is installing Ruby on Rails:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是安装 Ruby on Rails：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next step it to install the Unicorn server binary:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是安装 Unicorn 服务器二进制文件：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s continue with installing web documents in `/usr/local/www`. We''ll begin
    by creating the directory:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续在 `/usr/local/www` 安装 Web 文档。我们从创建目录开始：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now create our Rails application that is to be served with Unicorn:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以创建我们的 Rails 应用程序，并通过 Unicorn 提供服务：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After an enormous output, which may look a bit scary, there is a preconfigured
    application ready for you. Let''s configure Unicorn to serve it. We can get a
    default configuration file here:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一大堆输出后，可能看起来有点吓人，但这实际上是一个为你预先配置好的应用程序。让我们配置 Unicorn 来提供服务。我们可以在这里获取默认的配置文件：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have to change some things. Let''s start by making a variable for the basic
    application folder:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要修改一些内容。让我们从为基本应用程序文件夹创建一个变量开始：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we can change the following paths:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以更改以下路径：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Unicorn can listen on ports and/or sockets. We are going to use listen on a
    Unix socket because that is the shortest path:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unicorn 可以监听端口和/或套接字。我们将使用 Unix 套接字进行监听，因为这是最短的路径：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can start Unicorn with the following command:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令启动 Unicorn：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If NGINX was started earlier as well, we can now point our browser to `http://localhost:8080`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 NGINX 也提前启动了，我们现在可以将浏览器指向 `http://localhost:8080`。
- en: Now, maybe you encountered errors and want to find out what went wrong. It may
    be necessary to know how to debug NGINX and Unicorn when there are problems. This
    will be covered in the next section.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，也许你遇到了错误，想要了解发生了什么问题。了解如何在出现问题时调试 NGINX 和 Unicorn 可能是必要的。下一节将介绍这一内容。
- en: Debugging Unicorn
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 Unicorn
- en: Maybe installing Unicorn produced errors, or you are experiencing bad performance
    that you suspect is caused by Unicorn not working properly.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是安装 Unicorn 时产生了错误，或者你遇到了性能问题，怀疑是 Unicorn 未正常工作所致。
- en: There are several ways to find the cause. The log files can point you in the
    right direction.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以找到问题的根源。日志文件可以为你指明方向。
- en: Timeouts in Unicorn logs
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unicorn 日志中的超时
- en: 'The following output is what a Unicorn worker timeout looks like in `unicorn_stderr.log`.
    This is not necessarily bad; it just means that a new worker is spawned:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出是 Unicorn 工作者超时在 `unicorn_stderr.log` 中的表现。这不一定是坏事，它只是意味着新的工作进程被启动了：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It could be that there are just not enough Unicorn workers available to respond
    to the requests at hand. NGINX buffers a lot of requests so we must check on the
    handover socket whether Unicorn can keep up. To do this,a little nifty script
    is available here: [https://github.com/jahio/unicorn-status](https://github.com/jahio/unicorn-status).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是 Unicorn 可用的工作进程不足以响应当前的请求。NGINX 会缓存大量请求，所以我们必须检查交接套接字，看看 Unicorn 是否能跟得上。为此，可以使用一个方便的脚本，地址为：[https://github.com/jahio/unicorn-status](https://github.com/jahio/unicorn-status)。
- en: 'It can be called with the following command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以通过以下命令调用：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first argument here is the `unicorn_status.rb` script, the second is the
    socket to connect to `../.socket`, and the last argument is the poll interval
    (`10`).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一个参数是 `unicorn_status.rb` 脚本，第二个是要连接的套接字 `../.socket`，最后一个参数是轮询间隔（`10`）。
- en: Unicorn processes disappear
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unicorn 进程消失
- en: On Linux, there is a mechanism called **Out-of-Memory** (**OOM**) **Killer**
    that will free up memory if the system is running low on memory, and you don't
    have any swap memory left. It might kill Unicorn if it is using too much memory.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，有一种机制叫做 **Out-of-Memory** (**OOM**) **Killer**，当系统内存不足且没有交换内存时，它会释放内存。如果
    Unicorn 占用了过多内存，它可能会被杀死。
- en: 'Use `dmesg | egrep -i ''killed process''` to search for OOM events:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dmesg | egrep -i 'killed process'` 搜索 OOM 事件：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Other kinds of errors or 100% CPU load
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他类型的错误或 100% CPU 占用
- en: 'The ultimate way to debug Unicorn processes is to run strace on them:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 调试 Unicorn 进程的终极方法是对其运行 strace：
- en: Run `sudo gdb -p (PID)` to attach to the Unicorn process.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `sudo gdb -p (PID)` 以附加到 Unicorn 进程。
- en: 'Run `call (void) rb_backtrace()` in the GDB console and find the generated
    Ruby backtrace in `/var/log/gitlab/unicorn/unicorn_stderr.log`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 GDB 控制台中运行 `call (void) rb_backtrace()` 并在 `/var/log/gitlab/unicorn/unicorn_stderr.log`
    中找到生成的 Ruby 回溯信息：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When you are done, leave GDB with `detach` and `exit`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，使用 `detach` 和 `exit` 退出 GDB。
- en: Sidekiq
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sidekiq
- en: '**Sidekiq** is a framework for background job processing. It allows you to
    scale your application by performing work in the background. For more information
    on Sidekiq, consult the following website: [https://github.com/mperham/sidekiq/wiki](https://github.com/mperham/sidekiq/wiki).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sidekiq** 是一个后台作业处理框架。它通过在后台执行任务来帮助你扩展应用程序。欲了解更多有关 Sidekiq 的信息，请访问以下网站：[https://github.com/mperham/sidekiq/wiki](https://github.com/mperham/sidekiq/wiki)。'
- en: Each Sidekiq server process pulls jobs from the queue in Redis and processes
    them. Like your web processes, Sidekiq boots Rails so that your jobs and workers
    have the full Rails API available for use, including ActiveRecord. The server
    will instantiate the worker and call perform with the given arguments. Everything
    else is up to your code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Sidekiq 服务器进程从 Redis 队列中拉取任务并处理它们。像你的 Web 进程一样，Sidekiq 启动 Rails，这样你的任务和工作进程就可以使用完整的
    Rails API，包括 ActiveRecord。服务器将实例化工作进程，并使用给定的参数调用 `perform`。其余部分由你的代码决定。
- en: Installing Sidekiq
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Sidekiq
- en: 'It''s very easy to start using Sidekiq. It can be installed as `gem`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Sidekiq 非常简单。它可以作为 `gem` 安装：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, some dependencies are installed as well, such as Redis, connection
    pooling, Rack, and Rack protection.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，某些依赖项也已安装，例如 Redis、连接池、Rack 和 Rack 保护。
- en: Debugging Sidekiq
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 Sidekiq
- en: 'As with Unicorn, there are several ways to debug Sidekiq processing. The easiest
    way is to log in to GitLab as an administrator and view the logs from there, and
    especially view the queues and jobs on the Background Jobs page, as shown in the
    following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Unicorn 一样，有多种方法可以调试 Sidekiq 处理。最简单的方法是以管理员身份登录 GitLab 并查看日志，特别是查看后台作业页面上的队列和作业，如以下截图所示：
- en: '![](img/d6577d62-2591-45a1-b48d-e7caacf8e987.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6577d62-2591-45a1-b48d-e7caacf8e987.png)'
- en: Sometimes, you experience troubles and find situations on your Linux server.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你会遇到问题，并在 Linux 服务器上发现一些情况。
- en: Sidekiq processes disappear
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sidekiq 进程消失
- en: As mentioned before, in the Unicorn section, the OOM Killer might kill Sidekiq
    if it is using too much memory.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在 Unicorn 部分中，OOM Killer 可能会在 Sidekiq 使用过多内存时终止它。
- en: 'Use `dmesg | egrep -i ''killed process''` to search for OOM events:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dmesg | egrep -i 'killed process'` 查找 OOM 事件：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A Sidekiq process is seemingly doing nothing
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sidekiq 进程似乎什么也不做
- en: If Sidekiq isn't doing any work and it seems stuck most of the time, this means
    that the program is waiting for something. A common wait situation is when you
    are doing remote network calls. If you think this could be the case, you could
    make Sidekiq processes dump a backtrace to the log by sending it a TTIN signal.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Sidekiq 没有执行任何工作并且大部分时间看起来卡住了，这意味着程序在等待某些东西。一种常见的等待情况是当你正在进行远程网络调用时。如果你认为这可能是原因，你可以通过发送
    TTIN 信号让 Sidekiq 进程转储堆栈跟踪到日志中。
- en: 'This is what a Sidekiq worker looks like in the log file in `/var/log/gitlan/sidekiq/current`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 `/var/log/gitlab/sidekiq/current` 中的日志文件中，Sidekiq 工作者的样子：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Since GitLab 12.0, the default output log format for Sidekiq is JSON, this makes
    it easier to read the log files into a tool like logstash because it is more structured.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从 GitLab 12.0 开始，Sidekiq 的默认输出日志格式是 JSON，这使得通过像 logstash 这样的工具读取日志文件变得更容易，因为它更加结构化。
- en: Other kind of errors or 100% CPU load
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他类型的错误或 100% CPU 占用
- en: 'The ultimate way to debug Sidekiq processes is to make it dump a backtrace
    via GDB:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 调试 Sidekiq 进程的终极方法是通过 GDB 让它转储堆栈跟踪信息：
- en: Run `sudo gdb -p (PID)` to attach to the Sidekiq worker process.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `sudo gdb -p (PID)` 来附加到 Sidekiq 工作进程。
- en: 'Run `call (void) rb_backtrace()` in the GDB console and find the generated
    Ruby backtrace in `/var/log/gitlab/sidekiq/current`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 GDB 控制台中运行 `call (void) rb_backtrace()`，并在 `/var/log/gitlab/sidekiq/current`
    中查找生成的 Ruby 堆栈跟踪：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It is very hard to read backtraces, but this process was doing network operations
    while being traced, we can see a  (`_read_from _socket`). You can read the source
    code to check what it is doing (there are line numbers mentioned).
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 堆栈跟踪信息非常难以阅读，但这个进程在被跟踪时正在进行网络操作，我们可以看到一个 (`_read_from _socket`)。你可以查看源代码来确认它正在做什么（源代码中提到有行号）。
- en: When you are done, leave GDB with `detach` and quit.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，使用 `detach` 离开 GDB 并退出。
- en: You can also use other tracing tools to examine the behavior of the looping
    process. On Linux, for instance, `strace -p <pid>` allows you to view the system
    calls that are being made by the process.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用其他跟踪工具来检查循环进程的行为。例如，在 Linux 中，`strace -p <pid>` 允许你查看进程正在执行的系统调用。
- en: GitLab Shell
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitLab Shell
- en: This component is used to provide access to Git repositories through SSH. In
    fact, for pushes via the `git-http` protocol, it is also called instead of the
    Rails app. It's essentially a small Ruby wrapper around the Git client. Git, through
    SSH, uses predefined commands that can be executed on the GitLab server. For authorization,
    it makes calls to the GitLab API. Before GitLab 5.0, this functionality was delivered
    by Gitolite and powered by the Perl programming language.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件用于通过 SSH 提供对 Git 仓库的访问。实际上，对于通过 `git-http` 协议的推送，它也会代替 Rails 应用程序被调用。它本质上是一个围绕
    Git 客户端的小 Ruby 封装。Git 通过 SSH 使用预定义的命令，这些命令可以在 GitLab 服务器上执行。为了进行授权，它会调用 GitLab
    API。在 GitLab 5.0 之前，这个功能由 Gitolite 提供，并由 Perl 编程语言驱动。
- en: 'The source code of this project can be found here: [https://gitlab.com/gitlab-org/gitlab-shell](https://gitlab.com/gitlab-org/gitlab-shell).
    You can see the following page:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的源代码可以在此找到：[https://gitlab.com/gitlab-org/gitlab-shell](https://gitlab.com/gitlab-org/gitlab-shell)。你可以看到以下页面：
- en: '![](img/e2bdece6-99dd-4f04-acf2-0f287a96396c.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2bdece6-99dd-4f04-acf2-0f287a96396c.png)'
- en: You can install it locally, but it's really only useful when deployed together
    with other GitLab components. When you have that installed (see [Chapter 2](8e9ca130-15d0-4c6e-af6b-2fe5292f3618.xhtml),
    *Installing GitLab*, for instructions on how), the next section describes a way
    to debug when you have problems.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将其安装在本地，但它仅在与其他 GitLab 组件一起部署时才真正有用。当您完成安装（有关如何安装，请参见 [第 2 章](8e9ca130-15d0-4c6e-af6b-2fe5292f3618.xhtml)，*安装
    GitLab*），下一部分将描述遇到问题时的调试方法。
- en: Debugging GitLab Shell
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 GitLab Shell
- en: 'In an omnibus installation, the log file for GitLab Shell can be found in the
    following location:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在全包安装中，GitLab Shell 的日志文件可以在以下位置找到：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Alternatively, it may be found in the following location, for installations
    from source:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代，源代码安装时可以在以下位置找到：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'What you will generally find are log lines that concern the basic operations
    of GitLab Shell:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您通常会发现的是与 GitLab Shell 基本操作相关的日志行：
- en: Git commands (such as `git push` and `git pull`).
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 命令（如 `git push` 和 `git pull`）。
- en: Authorization calls to the GitLab Rails API to check whether you are allowed
    to connect
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权调用 GitLab Rails API 以检查是否允许连接
- en: Execution of pre-receive hooks
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行预接收钩子
- en: Actions requested
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求的操作
- en: Post-receive actions
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收后操作
- en: Any custom post-receive actions
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何自定义的接收后操作
- en: 'Here, we have listed some lines from the log file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们列出了日志文件中的一些行：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: One way to find errors is to look for certain patterns, such as `failed`, as
    follows. This particular error points to a 500 error from Unicorn while checking
    whether a user has the right authorization to make a call to the GitLab API.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 查找错误的一种方法是寻找某些模式，例如`failed`，如下所示。这个特定错误指向 Unicorn 的 500 错误，检查用户是否有正确的授权来调用 GitLab
    API。
- en: 'This error should show up in the Unicorn logs (`production.log`) if you search
    for an HTTP 500 error:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 Unicorn 日志（`production.log`）中搜索 HTTP 500 错误，应该会显示此错误：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Redis
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redis
- en: 'Redis is a caching tool and HTTP session store that allows you to save cached
    data and session information from your website to an external location. This means
    that your website doesn''t have to calculate everything every time; instead, it
    can retrieve the data from the cache and load the website much faster. The user
    sessions are in memory even if the application goes down. Redis is a fast caching
    tool because it uses memory first. It has several useful advantages:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 是一个缓存工具和 HTTP 会话存储，允许您将网站的缓存数据和会话信息保存到外部位置。这意味着您的网站不必每次都进行计算；相反，它可以从缓存中检索数据并更快地加载网站。即使应用程序崩溃，用户会话也会保存在内存中。Redis
    是一个快速的缓存工具，因为它首先使用内存。它有几个有用的优点：
- en: Everything is stored in one place, so you only have to flush one cache.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一切都存储在一个地方，因此您只需刷新一个缓存。
- en: It is faster than Memcache. This is noticeable when using the websites of large
    shops.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它比 Memcache 更快。使用大型商店的网站时，可以明显感受到这一点。
- en: Sessions are stored in memory and not in the database.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话保存在内存中，而不是保存在数据库中。
- en: The backend becomes faster.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端变得更快。
- en: Redis is not merely a cache, but is also a data structure store. It is basically
    a database and should be viewed conceptually as such. With regard to its operation
    and how it handles data, it has more in common with a NoSQL database.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 不仅仅是一个缓存，它还是一个数据结构存储。它基本上是一个数据库，应该从概念上将其视为一个数据库。在其操作和数据处理方式方面，它与 NoSQL
    数据库更为相似。
- en: Installing Redis
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Redis
- en: 'Redis is available through all major package management systems. The following
    are the commands used to install it on different platforms:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 可通过所有主要的软件包管理系统获得。以下是不同平台上安装它的命令：
- en: 'This is for Mac with Homebrew installed:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于安装了 Homebrew 的 Mac：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is for Linux Ubuntu or other APT-based distributions:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于 Linux Ubuntu 或其他基于 APT 的发行版：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is for Red Hat or other YUM-based distributions:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于 Red Hat 或其他基于 YUM 的发行版：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: However, the preferred way of installing Redis is by compiling it from the source.
    This way, you can easily stay up to date. It has no special dependencies other
    than the GCC compiler and the standard C library. You can find the latest stable
    version at [http://download.redis.io/redis-stable.tar.gz](http://download.redis.io/redis-stable.tar.gz).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，安装 Redis 的首选方式是通过从源代码编译。这种方式可以轻松保持更新。除了 GCC 编译器和标准 C 库外，它没有其他特别的依赖项。您可以在
    [http://download.redis.io/redis-stable.tar.gz](http://download.redis.io/redis-stable.tar.gz)
    找到最新的稳定版本。
- en: 'Installing and compiling it is as easy as entering the following command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和编译它就像输入以下命令一样简单：
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After completing this successfully, you can choose to carry out the next logical
    step, which is to issue `make test` to execute tests against compiled sources.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 成功完成后，你可以选择进行下一步操作，即执行 `make test` 来对已编译的源代码进行测试。
- en: 'To install the binary in a useful place, use the following command:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 若要将二进制文件安装到一个有用的位置，请使用以下命令：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For a further explanation about the structure that has been compiled, go to
    the `src` directory. You will find the following information:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 关于已编译结构的进一步解释，请前往 `src` 目录。你将找到以下信息：
- en: '`redis-server`: The Redis server program'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redis-server`：Redis 服务器程序'
- en: '`redis-sentinel`: This is used to monitor Redis clusters'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redis-sentinel`：用于监控 Redis 集群的程序'
- en: '`redis-cli`: The command-line program to control Redis'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redis-cli`：用于控制 Redis 的命令行程序'
- en: '`redis-benchmark`: The program to be used to measure Redis performance'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redis-benchmark`：用于测量 Redis 性能的程序'
- en: '`redis-check-aof` and `redis-check-dump`: Utilities to assist when there is
    data corruption'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redis-check-aof` 和 `redis-check-dump`：用于处理数据损坏的工具'
- en: Now we have everything in place, let's start the server.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都准备就绪，我们可以启动服务器了。
- en: 'When installed on macOS with `brew`, use the following command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上通过 `brew` 安装时，使用以下命令：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'On other platforms, when built from the source, you can directly start the
    Redis server by running the `redis-server` command. In a fresh shell window, type
    the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他平台上，当从源代码构建时，你可以直接通过运行 `redis-server` 命令启动 Redis 服务器。在一个新的 shell 窗口中，输入以下命令：
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After hitting *Enter*, you will see the server starting:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 *Enter* 后，你将看到服务器启动：
- en: '![](img/aac23216-7d52-47e3-b04c-2c1dc3ee461e.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aac23216-7d52-47e3-b04c-2c1dc3ee461e.png)'
- en: 'You can test whether your Redis instance is working by issuing the following
    command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过执行以下命令来测试你的 Redis 实例是否正常工作：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When Redis is operational, there will be a reaction:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Redis 正常运行时，将会有响应：
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you receive `PONG`, then everything is in order.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收到 `PONG`，那么一切正常。
- en: Basic data operations in Redis
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redis 中的基础数据操作
- en: 'Let''s discover some of the basics of Redis by playing with the data structures.
    Start the `redis-cli` command-line utility again without the `ping` argument,
    and it will connect to the local Redis server:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过操作这些数据结构来探索 Redis 的一些基础。再次启动 `redis-cli` 命令行工具，不带 `ping` 参数，它将连接到本地的 Redis
    服务器：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It is not fair to view Redis as a simple hash database with key values. But
    still, the five data structures that are provided do actually consist of a key
    and a value. Let''s sum up the five data structures:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Redis 视为一个简单的哈希数据库并不公平，尽管它提供的五种数据结构实际上都由键和值组成。我们来总结一下这五种数据结构：
- en: '**String**: You can use the `set` command to write a value to Redis. In the
    case of a simple string, you can simply save the value in the datastore shown
    as follows. After setting the string value, you can retrieve the value again by
    issuing the `get` command:'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串**：你可以使用 `set` 命令将一个值写入 Redis。在简单字符串的情况下，你只需按如下所示将值保存到数据存储中。设置字符串值后，你可以通过发出
    `get` 命令再次检索该值：'
- en: '[PRE41]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Hash**: In the same way as the string, you can `set` an arbitrary number
    of values to a key. Generally speaking, Redis treats values as a byte array and
    doesn''t care what they are. This make Redis very handy for representing objects.
    Again, with the `get` command, you can retrieve the values. GitLab uses this type
    to store web session information from users:'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**哈希**：与字符串类似，你可以使用 `set` 命令将任意数量的值设置为一个键。一般来说，Redis 将值视为字节数组，并不关心它们是什么。这使得
    Redis 在表示对象时非常方便。同样，通过 `get` 命令，你可以检索这些值。GitLab 使用这种类型来存储用户的 web 会话信息：'
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**List**: The list type in Redis is implemented as a linked list. You can add items
    to the listquite quickly with `rpush` (right push, to the tail of the list) or
    `lpush` (left push, to the head of the list). On the other hand, accessing an
    item by index is not that fast because it has to search the linked list. Still,
    for a queue mechanism, this is a good solution.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表**：Redis 中的列表类型实现为链表。你可以通过 `rpush`（右推，向列表尾部添加项）或 `lpush`（左推，向列表头部添加项）快速地向列表中添加项。另一方面，通过索引访问项的速度就较慢，因为它需要搜索链表。然而，对于队列机制来说，这仍然是一个不错的解决方案。'
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**Sets**: Another datatype is the set. You add members with the `sadd` command.
    Don''t forget that these sets are unordered, so if you ask for the members with
    `smembers`, the order will mostly be different to how you entered it:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合**：另一种数据类型是集合。你可以使用 `sadd` 命令向集合中添加成员。别忘了，这些集合是无序的，因此，如果你使用 `smembers`
    查询成员，返回的顺序通常会与输入时不同：'
- en: '[PRE44]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**Sorted sets**: Fortunately, there is an ordered set as well. It is almost
    the same, but one difference is that you add a score to the entry, and that will
    automatically score the sort order, as you can see from the following:'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有序集合**：幸运的是，也有一个有序集合。它几乎一样，但一个不同之处是，你需要为条目添加一个分数，这将自动排序，如下所示：'
- en: '[PRE45]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Gitaly
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gitaly
- en: In the first versions of GitLab, all Git operations relied on using a local
    disk or network share. Gitaly is a project that tries to eliminate reliance on
    the **Network File System** (**NFS**). Instead of calls to a filesystem service,
    Gitaly provides GitLab with a system based on **Remote Procedure Calls** (**RPCs**)
    to access Git repositories. It is written in Go and uses **gRPC Remote Procedure**
    **Call** (**gRPC**), a cross-platform RPC framework from Google. It has been steadily
    developing since the beginning of 2017, and since GitLab 11.4, it can replace
    the need for a shared NFS filesystem.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitLab的早期版本中，所有Git操作都依赖于使用本地磁盘或网络共享。Gitaly是一个旨在消除对**网络文件系统**（**NFS**）依赖的项目。Gitaly提供了一个基于**远程过程调用**（**RPCs**）的系统，供GitLab访问Git仓库，而不是调用文件系统服务。它是用Go编写的，并使用**gRPC远程过程调用**（**gRPC**），这是Google的跨平台RPC框架。从2017年初开始，它一直在稳步开发，自GitLab
    11.4以来，它可以替代对共享NFS文件系统的需求。
- en: 'You can find an overview of Gitaly and its place in the GitLab architecture
    in the following screenshot:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下截图中查看Gitaly及其在GitLab架构中的位置：
- en: '![](img/604f4f42-3c54-490d-8b34-5c07ae8217a1.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/604f4f42-3c54-490d-8b34-5c07ae8217a1.png)'
- en: 'On a small installation, it runs in the same servers as all other components.
    In big clustered environments, you can set up dedicated Gitaly servers, which
    can be used by Gitaly clients such as the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在小型安装中，它与所有其他组件运行在同一台服务器上。在大型集群环境中，你可以设置专用的Gitaly服务器，Gitaly客户端可以使用这些服务器，如下所示：
- en: Unicorn
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独角兽
- en: Sidekiq
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sidekiq
- en: '`gitlab-workhorse`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gitlab-workhorse`'
- en: '`gitlab-shell`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gitlab-shell`'
- en: Elasticsearch indexer
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Elasticsearch索引器
- en: Gitaly as a client
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gitaly作为客户端
- en: 'The source code of this project can be found here: [https://gitlab.com/gitlab-org/gitaly](https://gitlab.com/gitlab-org/gitaly)[.](https://gitlab.com/gitlab-org/gitaly)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的源代码可以在这里找到：[https://gitlab.com/gitlab-org/gitaly](https://gitlab.com/gitlab-org/gitaly)[.](https://gitlab.com/gitlab-org/gitaly)
- en: Debugging Gitaly
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试Gitaly
- en: You can use debugging tools that are available for Golang. But for starters,
    you can take a look at the log file.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用可用于Golang的调试工具。但首先，你可以查看日志文件。
- en: 'For source installs, use this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于源代码安装，请使用此方法：
- en: '[PRE46]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'For Omnibus installations, use this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Omnibus安装，请使用此方法：
- en: '[PRE47]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following is an example of a log line:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个日志行的示例：
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can see the log level is `info` and this is a log event that captures a
    Git SSH command (`method=SSHUploadPack`). It started a Git `pack` command on the
    server, which means it rearranged and compressed data in a repository.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到日志级别是`info`，这是一个捕获Git SSH命令的日志事件（`method=SSHUploadPack`）。它在服务器上启动了一个Git
    `pack`命令，这意味着它重新排列并压缩了一个仓库中的数据。
- en: To generate more verbose logging, you can set the log level to a debug in the
    configuration file. It is configured via a **Tom's Obvious Minimal Language**
    (**TOML**) configuration file. This file is documented in the Gitaly source code
    repository mentioned previously.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成更详细的日志，你可以在配置文件中将日志级别设置为调试。它通过**Tom的明显最小语言**（**TOML**）配置文件进行配置。此文件在前面提到的Gitaly源代码库中有文档说明。
- en: 'For source installations, look here:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于源代码安装，请查看此处：
- en: '[PRE49]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can change the following section and change the level:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更改以下部分并更改级别：
- en: '[PRE50]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'For Omnibus installs, the following directives can be added to `gitlab.rb`
    to influence the level of monitoring of Gitaly. Set it to `debug` to enable debug-level
    logging:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Omnibus安装，可以将以下指令添加到`gitlab.rb`中，以影响Gitaly的监控级别。设置为`debug`以启用调试级别日志：
- en: '[PRE51]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: GitLab Workhorse
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitLab Workhorse
- en: 'GitLab Workhorse is a sophisticated reverse proxy that is set up in front of
    GitLab. Initially conceived to solve the problem of handling `git-http` requests,
    it started as a weekend project with the name `gitlab-git-httpserver`. The functionality
    was previously delivered by `gitlab-grack` ([https://gitlab.com/gitlab-org/gitlab-grack](https://gitlab.com/gitlab-org/gitlab-grack)). The
    main web application server, Unicorn, was not especially suited to cater for these
    requests, which can take a long time to finish. Handling these directly in Unicorn
    actually reverses the advantages that Unicorn can provide: fast and scalable HTTP
    requests.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab Workhorse是一个复杂的反向代理，位于GitLab前面。最初为了解决处理`git-http`请求的问题，它作为一个周末项目开始，名称为`gitlab-git-httpserver`。该功能之前由`gitlab-grack`（[https://gitlab.com/gitlab-org/gitlab-grack](https://gitlab.com/gitlab-org/gitlab-grack)）提供。主要的Web应用服务器Unicorn并不特别适合处理这些可能需要很长时间才能完成的请求。直接在Unicorn中处理这些请求实际上会抵消Unicorn可以提供的优势：快速和可扩展的HTTP请求。
- en: Workhorse was created in Golang, and was conceived by Jacob Vosmaer, one of
    the GitLab developers. You can read all about the process of creating it at [https://about.gitlab.com/2016/04/12/a-brief-history-of-gitlab-workhorse/](https://about.gitlab.com/2016/04/12/a-brief-history-of-gitlab-workhorse/).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Workhorse是用Golang创建的，由GitLab开发人员Jacob Vosmaer构思。你可以在[https://about.gitlab.com/2016/04/12/a-brief-history-of-gitlab-workhorse/](https://about.gitlab.com/2016/04/12/a-brief-history-of-gitlab-workhorse/)阅读关于它的创建过程。
- en: 'Although it was first designed to handle the Git HTTP protocol, GitLab Workhorse
    increasingly gained functionalities, such as these:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管最初设计用于处理Git HTTP协议，GitLab Workhorse逐渐增加了许多功能，例如：
- en: Certain static files, such as JavaScript and CSS files, are served directly.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些静态文件，如JavaScript和CSS文件，会直接提供服务。
- en: It can intercept requests from Rails about opening a file. Workhorse will open
    the file and send the content in the response body.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以拦截Rails关于打开文件的请求。Workhorse将打开文件并在响应正文中发送内容。
- en: It can intercept calls for Git **Large File Storage** (**LFS**) and insert a
    temporary path after preparing the file in the upload location. Git LFS is a feature
    where large files can be stored outside the project space in GitLab.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以拦截对Git **大文件存储** (**LFS**) 的调用，并在准备好文件并上传到指定位置后插入一个临时路径。Git LFS是一个功能，允许将大文件存储在GitLab项目空间之外。
- en: It can control WebSocket connections for Rails, such as the terminal output.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以控制Rails的WebSocket连接，例如终端输出。
- en: Workhorse sits behind NGINX, which handles request routing and SSL termination.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Workhorse位于NGINX后面，负责处理请求路由和SSL终止。
- en: Debugging GitLab Workhorse
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试GitLab Workhorse
- en: As workhorse is a Golang written application, you can use methods for this language
    to debug programs.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 由于workhorse是用Golang编写的应用程序，你可以使用该语言的方法来调试程序。
- en: It also supports remote error logging with Sentry. To activate this feature,
    set the `GITLAB_WORKHORSE_SENTRY_DSN` environment variable.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 它还支持使用Sentry进行远程错误日志记录。要启用此功能，请设置`GITLAB_WORKHORSE_SENTRY_DSN`环境变量。
- en: '**For Omnibus installations**'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于Omnibus安装**'
- en: 'The following is defined in the file (`/etc/gitlab/gitlab.rb`):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容在文件（`/etc/gitlab/gitlab.rb`）中定义：
- en: '[PRE52]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '**For Source installations**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于源代码安装**'
- en: 'The following environment variable can be set in the file (/`etc/default/gitlab`):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 以下环境变量可以在文件（`/etc/default/gitlab`）中设置：
- en: '[PRE53]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Of course, the first thing to look at is the log files that are produced by
    this component. On an Omnibus-based GitLab installation, you can find them in
    `/var/log/gitlab/gitlab-workhorse`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，首先要查看的是此组件生成的日志文件。在基于Omnibus的GitLab安装中，你可以在`/var/log/gitlab/gitlab-workhorse`中找到它们。
- en: 'The following is an excerpt of the default log file:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是默认日志文件的摘录：
- en: '[PRE54]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the preceding log file, you see, for example, `git-http` operations such
    as `git-upload-pack`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的日志文件中，例如，你会看到`git-http`操作，例如`git-upload-pack`。
- en: Database
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库
- en: 'There are two database varieties available for GitLab: PostgreSQL and MySQL/MariaDB.
    The use of the latter is not recommended because the fast development of iterations
    of GitLab, as a product, have focused primarily on PostgreSQL, meaning that a
    number of optimizations are not available on MySQL. Furthermore, the zero-downtime
    method is not available when using MySQL, and neither are features such as subgroups
    and GEO, which will be explained later in this book.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab有两种数据库可用：PostgreSQL和MySQL/MariaDB。由于GitLab作为一个产品的快速迭代发展主要集中在PostgreSQL上，因此不推荐使用后者，因为MySQL上没有许多优化。此外，使用MySQL时不能使用零停机时间方法，也没有如子组和GEO等功能，这些将在本书后面解释。
- en: As explained earlier, Ruby on Rails uses a so-called MVC approach. MVC is a
    well known architectural pattern that was developed by Trygve Reenskaug in the
    Smalltalk language. It was later enhanced for web applications (Model 2). The
    model in MVC is implemented by the `ActiveRecord` library, which is part of Ruby
    on Rails.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Ruby on Rails 使用所谓的 MVC 方法。MVC 是一个广为人知的架构模式，由 Trygve Reenskaug 在 Smalltalk
    语言中开发。后来它被改进为适用于 web 应用程序（Model 2）。MVC 中的模型由 `ActiveRecord` 库实现，这是 Ruby on Rails
    的一部分。
- en: 'The authoritative source for the data model can be found here: [https://gitlab.com/gitlab-org/gitlab-ee/blob/master/db/schema.rb](https://gitlab.com/gitlab-org/gitlab-ee/blob/master/db/schema.rb).
    It is auto generated and represents the current state of the database.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 数据模型的权威来源可以在此处找到：[https://gitlab.com/gitlab-org/gitlab-ee/blob/master/db/schema.rb](https://gitlab.com/gitlab-org/gitlab-ee/blob/master/db/schema.rb)。它是自动生成的，代表了当前数据库的状态。
- en: The default PostgreSQL database that is included in the Omnibus package can
    handle workloads for up to 10,000 users. Also, if you would like to create a **Disaster
    Recovery** (**DR**) plan using a cold standby setup, you can use specific failover
    mechanisms.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Omnibus 包中包含的默认 PostgreSQL 数据库可以处理最多 10,000 用户的工作负载。此外，如果你希望使用冷备份设置来创建一个**灾难恢复**（**DR**）计划，你可以使用特定的故障切换机制。
- en: 'A frequently used technique is to create a cold standby database (PostgreSQL
    DB 2) at another site, as illustrated by the following diagram:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常用的技术是创建一个冷备数据库（PostgreSQL 数据库 2）在另一个站点，如下图所示：
- en: '![](img/37c0d3a0-1133-4125-ba0e-84de5982ddc0.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37c0d3a0-1133-4125-ba0e-84de5982ddc0.png)'
- en: When you want to scale or increase the number of application servers, you need
    to scale the database too. There are three important aspects of database scaling.
    Firstly, you want to be able to scale database client connections as efficiently
    as possible. To do this, you can use PgBouncer, which is a lightweight connection
    pooler.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当你希望扩展或增加应用服务器的数量时，也需要扩展数据库。数据库扩展有三个重要方面。首先，你需要尽可能高效地扩展数据库客户端连接。为此，你可以使用 PgBouncer，它是一个轻量级的连接池管理器。
- en: Secondly, you want to have several database instances, one being the master
    node, and replicate the data from the master to the slave. In the former, DR situation,
    this was done by the basic built-in replication mechanism of PostgreSQL. In the
    current situation, a specific tool, repmgr, is used, a tool for clustering PostgreSQL and
    handling the failover.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你需要有多个数据库实例，其中一个是主节点，并将数据从主节点复制到从节点。在前述的灾难恢复（DR）情况下，这是通过 PostgreSQL 内建的基本复制机制完成的。在当前情况下，使用了一个特定的工具
    repmgr，这是一种用于 PostgreSQL 集群化和处理故障切换的工具。
- en: Finally, a service discovery tool such as **Consul** can be used to detect the
    PostgreSQL status of each node, and update the PGbouncer service setting that
    determines which Postgres instance to connect to.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，像**Consul**这样的服务发现工具可以用来检测每个节点的 PostgreSQL 状态，并更新决定连接哪个 Postgres 实例的 PGbouncer
    服务设置。
- en: 'The resulting architecture is as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的架构如下所示：
- en: '![](img/682c99a5-6e3f-4586-bf5c-66fff93cef8f.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/682c99a5-6e3f-4586-bf5c-66fff93cef8f.png)'
- en: As you can see, there are different ways of setting up your database for GitLab.
    The architectures highlighted in the preceding diagram will be used in examples
    for building high-availability environments in *Scaling the Server Infrastructure
    (High- Availability Setup*) section of this book.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，设置 GitLab 数据库有不同的方式。前面图中突出的架构将在本书*扩展服务器基础设施（高可用性设置）*章节中作为构建高可用性环境的示例。
- en: GitLab CI
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitLab CI
- en: GitLab CI is a feature that helps perform the **Continuous Integration** (**CI**)
    of software components. When several developers work together using a versioning
    system, problems can arise when changes made by one developer break the product
    as a whole. The best way to make sure this happens less often, or at least early
    in the process, is to use integration tests more frequently, hence the name continuous.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab CI 是一个帮助执行软件组件**持续集成**（**CI**）的功能。当多个开发人员使用版本控制系统协同工作时，如果某个开发者的更改破坏了整个产品，就可能会出现问题。确保这种情况发生的概率较低，或者至少能尽早发现的最佳方法是更频繁地使用集成测试，因此称为持续集成。
- en: GitLab CI was launched as a standalone project in 2013, but was later integrated
    into the main GitLab package. Combined with the GitLab Runner software, this feature
    has been very popular with developers and is an important driver of the business.
    It also enabled GitLab to build their product into a solution that not only does
    CI, but even continuous delivery up to production environments. The current product
    vision for GitLab is to serve as a complete DevOps life cycle product, from idea
    to production.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab CI于2013年作为一个独立项目推出，但后来被集成进了主GitLab包中。结合GitLab Runner软件，这一功能在开发者中非常受欢迎，也是推动业务发展的重要因素。它还使GitLab能够将其产品打造为一个不仅可以进行CI，还能够进行持续交付，甚至覆盖到生产环境的解决方案。目前GitLab的产品愿景是成为一个完整的DevOps生命周期产品，从创意到生产。
- en: 'Forrester classified GitLab as a leader in CI in *The Forrester Wave: Continuous
    Integration Tools, Q3 2017*. This is shown in the following diagram:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 'Forrester在*The Forrester Wave: Continuous Integration Tools, Q3 2017*中将GitLab评为持续集成（CI）领域的领导者。如下图所示：'
- en: '![](img/baa860a0-b398-48a1-9f42-754053ffd5d1.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/baa860a0-b398-48a1-9f42-754053ffd5d1.png)'
- en: Feedback, one of the important aspects of the **Extreme Programming** (**XP**)
    movement, is an important element of GitLab CI. It also serves as a way to communicate
    between developers.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 反馈是**极限编程**（**XP**）运动中一个重要的方面，也是GitLab CI的一个关键元素。它也作为开发者之间沟通的一种方式。
- en: Pipelines and jobs
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pipeline和作业
- en: 'Pipelines and build jobs are basic building blocks for a **Continuous Integrations/Continuous
    Delivery** (**CI/CD**) system nowadays. In GitLab, it is very easy to start a
    pipeline. You only need to add a `.gitlab-ci.yml` file to your project and then,
    on every commit/push to your repository, a pipeline will start. Every project
    has a pipeline''s overview; you can find it in the left-hand menu bar, under CI/CD:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Pipeline和构建作业是现代**持续集成/持续交付**（**CI/CD**）系统的基本构件。在GitLab中，启动一个pipeline非常简单。你只需将一个`.gitlab-ci.yml`文件添加到你的项目中，然后在每次提交/推送到代码库时，pipeline便会启动。每个项目都有一个pipeline概览；你可以在左侧菜单栏中的CI/CD下找到它：
- en: '![](img/9500b78c-c838-4e0f-ba0d-724581246c4c.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9500b78c-c838-4e0f-ba0d-724581246c4c.png)'
- en: 'Alternatively, you can view all jobs, by going to the Pipelines'' Jobs page,
    as shown in the following screenshot:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过访问Pipeline的作业页面查看所有作业，如下图所示：
- en: '![](img/d3a96279-4d98-4ae2-a324-1e8de043d63f.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3a96279-4d98-4ae2-a324-1e8de043d63f.png)'
- en: 'You can check the log of a job by clicking on the status of the job (for example,
    **failed** or **passed**). You can debug why some jobs fail and see exactly what
    happened:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过点击作业的状态（例如，**失败**或**成功**）查看作业的日志。你可以调试为什么某些作业失败，并准确查看发生了什么：
- en: '![](img/c2751d76-eda1-4258-b975-69917c7e97ae.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c2751d76-eda1-4258-b975-69917c7e97ae.png)'
- en: The importance of using pipelines and jobs for CI/CD cannot be overstated. In
    this section, you've seen the basic interface to pipelines in GitLab, but in several
    chapters time, this will be discussed in more detail (*Utilizing GitLab CI and
    CI Runners* section).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pipeline和作业进行CI/CD的重要性不容忽视。在本节中，你看到了GitLab中pipeline的基本界面，但在接下来的几章中，将对此进行更详细的讨论（*使用GitLab
    CI和CI Runner*部分）。
- en: GitLab Runners
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitLab Runners
- en: GitLab Runners were originally developed by Kamil Trzciński in 2015\. They're
    now one of the most popular features of GitLab.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab Runners最初由Kamil Trzciński于2015年开发。现在它们已成为GitLab最受欢迎的功能之一。
- en: The initial GitLab-CI-Runner was a very simple application written in Ruby,
    but worked well in quite basic setups. You can think of it as a reference implementation
    of what a bare runner could look like.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的GitLab-CI-Runner是一个用Ruby编写的非常简单的应用程序，但在相当基础的设置中运行良好。你可以将它看作是一个裸跑者可能是什么样子的参考实现。
- en: Issues with the old runner
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旧版runner的问题
- en: The main problem with the old runner is that it could only run one concurrent
    job at a time. If you wanted to run more, you could either set up a new server
    or create an additional user to build jobs.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版runner的主要问题是它每次只能运行一个并发作业。如果你想运行更多作业，你只能设置一台新服务器或创建一个额外的用户来构建作业。
- en: Secondly, it always ran projects on the server shell. This made it really hard
    to test projects using different versions of Ruby or any other dependencies. It
    was not stateless, meaning you had a contaminated build environment. Builds were
    therefore not very trustworthy. Nowadays, having a stateless and clean build environment
    every time is essential.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，它始终在服务器Shell中运行项目。这使得使用不同版本的Ruby或其他依赖项测试项目变得非常困难。它不是无状态的，这意味着你有一个被污染的构建环境。因此，构建结果并不可靠。如今，每次都拥有一个无状态且干净的构建环境至关重要。
- en: Another aspect of the old Runner that made it less favorable was that it only
    ran on Linux-based platforms. To make it work on macOS, a big GitLab user platform,
    you had to carry out additional hacking. Support for Microsoft Windows was out
    of the question.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版 Runner 的另一个缺点是它只能在基于 Linux 的平台上运行。为了让它在 macOS 上运行，GitLab 用户平台之一，你需要进行额外的修改。对于微软
    Windows 的支持更是不可想象。
- en: Finally, there were some heavy administrative burdens. The server was hard to
    scale, because setting up a new server took a long time due to the dependencies
    you needed to take care of in order to build projects.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，曾经有一些繁重的管理负担。服务器很难扩展，因为设置一个新服务器需要很长时间，因为你需要处理依赖关系，才能构建项目。
- en: The newer runner is a binary that you can put on a machine of any kind. It is
    really easy to set up as a service and can work with multiple projects and multiple
    GitLab CI coordinators. It also provides support for Docker, making it really
    easy to set up a build environment with different versions.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的 Runner 是一个二进制文件，可以放置在任何类型的机器上。它非常容易设置为服务，并且能够与多个项目和多个 GitLab CI 协调器一起工作。它还支持
    Docker，使得以不同版本设置构建环境变得非常简单。
- en: Switching to Go
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切换到 Go
- en: Go (or Golang) is a new language (less than 10 years old). It is already widely
    used by some impressive parties, such as Docker ([https://docker.com](https://docker.com)),
    Google, Kubernetes ([https://kubernetes.io](https://kubernetes.io)), and Prometheus
    ([https://prometheus.io](https://prometheus.io)). Go is a versatile tool that
    can help you to program at a low level, close to the operating system or at a
    high level in a language such as Java. It is perfectly suited to creating systems
    software. The language was created in 2009 by R. Griesemer, R. Pike, and K.Thompson
    while working for Google. The latter is very famous for co-creating the first
    Unix implementation and the B programming language. The most important feature
    of the Go language is that it can compile one binary without dependencies for
    multiple operating systems such as Linux, macOS, the BSDs, and Windows. This also
    means it runs on different processor architectures (i386, amd64, ARM, and PowerPC).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Go（或 Golang）是一种新的编程语言（不到 10 年）。它已经被一些令人印象深刻的公司广泛使用，如 Docker ([https://docker.com](https://docker.com))、Google、Kubernetes
    ([https://kubernetes.io](https://kubernetes.io)) 和 Prometheus ([https://prometheus.io](https://prometheus.io))。Go
    是一个多用途工具，可以帮助你在低级别接近操作系统的层面编程，也可以在像 Java 这样的高级语言中编程。它非常适合用来创建系统软件。该语言由 R. Griesemer、R.
    Pike 和 K. Thompson 在 2009 年为 Google 创建。后者因共同创造了第一版 Unix 实现和 B 编程语言而非常著名。Go 语言最重要的特点是它能够编译出一个不依赖任何库的二进制文件，适用于多个操作系统，如
    Linux、macOS、BSD 和 Windows。这也意味着它可以在不同的处理器架构上运行（i386、amd64、ARM 和 PowerPC）。
- en: 'A short list of the benefits of Go follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Go 的一些优点：
- en: Very good standard libraries (with good optional ones available elsewhere).
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常优秀的标准库（还有很多可选的库可以在其他地方找到）。
- en: It is very fast to develop and test in Go.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Go 中开发和测试非常快速。
- en: The culture/community chooses boring solutions over complex ones (which is good).
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文化/社区倾向于选择简单的解决方案而非复杂的解决方案（这很好）。
- en: Cool tools such as Gofmt, race detector, and `go vet`.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很酷的工具，如 Gofmt、竞争检测器和 `go vet`。
- en: Made for concurrency—for instance, you can use goroutines and channels.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为并发设计——例如，你可以使用 goroutine 和 channels。
- en: Type safety—will save you many times from run-time errors and wrongly defined
    data types.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型安全——可以避免许多运行时错误和错误的类型定义。
- en: Garbage collection—while programmers who use C know how to clean up, this can
    still be helpful.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾回收——虽然使用 C 的程序员知道如何清理内存，但这仍然是有帮助的。
- en: Closures or anonymous functions—enable the use of functional principles (higher-order
    functions).
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包或匿名函数——启用使用函数式编程原则（高阶函数）。
- en: All these characteristics make Go the perfect choice for GitLab Runners. With
    Go, you can create a relatively small binary that runs on a lot of platforms.
    It contains all that is needed to run your projects.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些特点使 Go 成为 GitLab Runners 的完美选择。使用 Go，你可以创建一个相对较小的二进制文件，能够在多个平台上运行。它包含了运行项目所需的一切。
- en: In a GitLab environment, jobs are being executed by the Runners. They run them
    as they are defined in a `.gitlab-ci.yml` file. The Runner itself can be running
    on a **Virtual Machine** (**VM**) such as VmWare (VM), VPS, a laptop, a Docker
    container, or in a Kubernetes cluster. Communication is one way from runner to
    GitLab and is mostly via an HTTP API, so that path must be accessible by the Runner.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitLab 环境中，作业由 Runner 执行。它们按照 `.gitlab-ci.yml` 文件中定义的方式运行。Runner 本身可以运行在 **虚拟机**（**VM**）上，例如
    VmWare（VM）、VPS、笔记本电脑、Docker 容器或 Kubernetes 集群中。通信是单向的，从 Runner 到 GitLab，主要通过 HTTP
    API 进行，因此该路径必须对 Runner 可访问。
- en: The `.yml` file defines what stages your CI/CD pipeline has and what to do in
    each stage. This typically consists of build, test, and deploy stages.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`.yml` 文件定义了你的 CI/CD 流水线有哪些阶段，以及每个阶段要做什么。通常包括构建、测试和部署阶段。'
- en: GitLab mentions *boring* in its handbook as a valued way of reducing complexity;
    see [https://about.gitlab.com/handbook/values/#efficiency](https://about.gitlab.com/handbook/values/#efficiency).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 在其手册中提到 *无聊* 作为减少复杂性的一种有价值的方式；参见 [https://about.gitlab.com/handbook/values/#efficiency](https://about.gitlab.com/handbook/values/#efficiency)。
- en: 'The project can be found at [https://gitlab.com/gitlab-org/gitlab-runner](https://gitlab.com/gitlab-org/gitlab-runner):'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 项目可以在 [https://gitlab.com/gitlab-org/gitlab-runner](https://gitlab.com/gitlab-org/gitlab-runner)
    找到：
- en: '![](img/f2c04da4-3bda-4d67-a67d-12136489b33b.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2c04da4-3bda-4d67-a67d-12136489b33b.png)'
- en: 'A runner can either be specific to a certain project or it can serve multiple
    projects in GitLab. If it serves all projects, it''s known as a Shared Runner. GitLab
    Runners implement a number of **executors** that can be used for your builds in
    different scenarios:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 执行器可以特定于某个项目，或者它可以服务于 GitLab 中的多个项目。如果它服务于所有项目，它被称为共享执行器。GitLab Runners 实现了许多
    **执行器**，可以在不同场景下用于你的构建：
- en: '**Shell executor**: The runner simply executes a shell. The dependencies for
    the build have to be installed manually.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Shell 执行器**：执行器简单地执行一个 shell。构建的依赖项需要手动安装。'
- en: '**Docker-based executor**: The runner runs from a container. This makes it
    easier to create clean builds because dependency management is shifted to the
    container image. It is also easier to create a build environment with services
    that need each other, such as PostgreSQL.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于 Docker 的执行器**：执行器从容器中运行。这使得创建干净的构建变得更容易，因为依赖管理被转移到容器镜像中。它还使得创建需要互相依赖的服务的构建环境变得更容易，例如
    PostgreSQL。'
- en: '**Autoscaling Docker SSH**: A Docker machine creates instances with the Docker
    Engine to run Docker containers.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动扩展 Docker SSH**：Docker 机器使用 Docker 引擎创建实例以运行 Docker 容器。'
- en: '**Kubernetes**: GitLab Runner can use Kubernetes to run builds on a Kubernetes
    cluster.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes**：GitLab Runner 可以使用 Kubernetes 在 Kubernetes 集群上运行构建。'
- en: Runners have evolved enormously over the last couple of years. GitLab itself
    sees them as one of the most important components of their suite. This section
    has given more insight into the development of this popular tool.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年中，Runners 发展了很多。GitLab 本身将它们视为其套件中最重要的组件之一。本节为你提供了更多关于这一流行工具发展的见解。
- en: Cloud native
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云原生
- en: Toward the end of 2016 and at the start of 2017, there was a public debate in
    the GitLab community about whether reverting back from the cloud to bare metal
    would be cost-effective for [GitLab.com](https://about.gitlab.com/). At the time,
    the filesystem used for repositories was Ceph. The performance of that distributed
    filesystem was not good enough to handle [GitLab.com](https://about.gitlab.com/).
    They asked the community for advice and received a lot of feedback from people
    who experienced similar moves firsthand. In the end, the decision was made to
    stay in the cloud ([https://about.gitlab.com/2017/03/02/why-we-are-not-leaving-the-cloud/](https://about.gitlab.com/2017/03/02/why-we-are-not-leaving-the-cloud/)).
    Instead, GitLab would focus on creating a solution, not on the filesystem level,
    but making sure that Git input/output (I/O) behavior is better managed at the
    application level. This can be seen as the birth of the Gitaly component. Sid
    Sijbrandij emphasized the importance of being a software company, not an infrastructure
    company.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2016 年末和 2017 年初，GitLab 社区就是否从云迁回裸金属服务器展开了公开辩论，讨论是否对 [GitLab.com](https://about.gitlab.com/)
    更具成本效益。当时，用于存储仓库的文件系统是 Ceph。这个分布式文件系统的性能不足以支撑 [GitLab.com](https://about.gitlab.com/)。他们向社区征求建议，收到了许多有类似经历的人的反馈。最终，决定继续留在云端（[https://about.gitlab.com/2017/03/02/why-we-are-not-leaving-the-cloud/](https://about.gitlab.com/2017/03/02/why-we-are-not-leaving-the-cloud/)）。GitLab
    反而决定专注于创建一个解决方案，重点不再是文件系统层面，而是确保 Git 输入/输出（I/O）行为在应用层面得到更好的管理。这也可以看作是 Gitaly 组件的诞生。Sid
    Sijbrandij 强调，GitLab 作为一家软件公司，而非基础设施公司，这一点非常重要。
- en: 'In August 2018, GitLab migrated their cloud-based offering, [GitLab.com](https://about.gitlab.com/),
    from Azure to **Google Cloud Platform** (**GCP**). The main reason for switching
    to GCP according to CEO, Sid Sijbrandij was as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 2018年8月，GitLab 将其基于云的服务，[GitLab.com](https://about.gitlab.com/)，从 Azure 迁移到
    **Google Cloud Platform**（**GCP**）。根据 CEO Sid Sijbrandij 的说法，迁移至 GCP 的主要原因如下：
- en: '"Google as a public cloud, they have more experience than the other public
    cloud providers because they basically made a cloud for themselves [...] you find
    that in things such as networking, where their network quality is ahead of everyone
    else. It''s more reliable, it has less jitter, and it''s just really, really impressive
    how they do that, and we''re happy to start hosting GitLab.com on that."'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: “作为一个公共云，Google 比其他云服务提供商有更多的经验，因为他们基本上是为自己打造了一套云 [...] 你可以在网络方面看到这一点，他们的网络质量超越了其他所有人。它更可靠，延迟更低，而且真的非常令人印象深刻，我们很高兴开始在上面托管
    GitLab.com。”
- en: It seems the move paid off; users have reported that [GitLab.com](https://about.gitlab.com/)
    is noticeably faster. Another transformation that is likely to cause further acceleration
    soon is the move to using Kubernetes as a container orchestrator. This is an important
    part of their strategy to incorporate functionality in a lot of places in GitLab
    besides the autoscaling of GitLab runners. GitLab's own high-availability tool,
    GEO, was used to synchronize the data from one cloud to another. Running on Google's
    architecture also allows GitLab to utilize object-storage for particular features
    as well, such as Git LFS.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来这次调整是值得的；用户反馈称，[GitLab.com](https://about.gitlab.com/)明显变得更快了。另一个很可能会带来进一步加速的转变是使用
    Kubernetes 作为容器编排器。这是他们战略中一个重要的部分，旨在将更多功能融入到 GitLab 中，除了自动扩展 GitLab 运行器之外。GitLab
    自己的高可用工具 GEO 被用来将数据从一个云同步到另一个云。运行在 Google 架构上的 GitLab 也可以利用对象存储来实现一些特定功能，例如 Git
    LFS。
- en: Summary
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned about the people and the organization behind
    GitLab. Starting from the beginning, we have shown you how the project has developed
    over the years. We went through the core components of GitLab and how to install
    them. For some components, we included ways to debug the installation.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们了解了 GitLab 背后的人和组织。从一开始，我们展示了该项目多年来的发展历程。我们详细讲解了 GitLab 的核心组件以及如何安装它们。对于某些组件，我们还介绍了调试安装的方法。
- en: We also gave a brief introduction to GitLab CI and the client programs that
    interact with it, such as GitLab Runner. We showed you why this feature is so
    important and how it is perceived by the IT industry.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还简要介绍了 GitLab CI 以及与其交互的客户端程序，例如 GitLab Runner。我们展示了这个功能为何如此重要，以及 IT 行业如何看待它。
- en: In the next chapter, we will install and configure GitLab on different kinds
    of systems. If you're new to the product, prepare to be amazed!
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何在不同系统上安装和配置 GitLab。如果你是该产品的新用户，准备好惊叹吧！
- en: Questions
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: When and by whom was GitLab initially developed?
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GitLab最初是由谁和何时开发的？
- en: How is GitLab funded?
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GitLab是如何获得资金的？
- en: Name all the programming languages that are used in the GitLab software.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举所有在GitLab软件中使用的编程语言。
- en: Which licenses are used by GitLab?
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GitLab使用了哪些许可证？
- en: Why are they using these licenses?
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么他们使用这些许可证？
- en: Name the core components of GitLab.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举GitLab的核心组件。
- en: How many offices does GitLab have?
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GitLab有多少个办公室？
- en: What is stored in Redis?
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Redis中存储了什么？
- en: What has Gitaly replaced?
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Gitaly替代了什么？
- en: Which cloud service was chosen by GitLab to focus on in 2018?
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GitLab在2018年选择了哪个云服务作为重点？
- en: Further reading
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Sidekiq—source and documentation: [https://github.com/mperham/sidekiq](https://github.com/mperham/sidekiq)'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Sidekiq—源代码和文档: [https://github.com/mperham/sidekiq](https://github.com/mperham/sidekiq)'
- en: 'Ruby on Rails: [https://rubyonrails.org](https://rubyonrails.org)'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ruby on Rails: [https://rubyonrails.org](https://rubyonrails.org)'
- en: 'Unicorn: [https://thorstenball.com/blog/2014/11/20/unicorn-unix-magic-tricks/](https://thorstenball.com/blog/2014/11/20/unicorn-unix-magic-tricks/)'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Unicorn: [https://thorstenball.com/blog/2014/11/20/unicorn-unix-magic-tricks/](https://thorstenball.com/blog/2014/11/20/unicorn-unix-magic-tricks/)'
- en: '*Cloud Native programming with Golang* by *Mina Andrawos*, *Martin Helmich*: [https://www.packtpub.com/in/application-development/cloud-native-programming-golang](https://www.packtpub.com/in/application-development/cloud-native-programming-golang)'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*云原生编程与Golang* 由 *Mina Andrawos*、*Martin Helmich* 编著: [https://www.packtpub.com/in/application-development/cloud-native-programming-golang](https://www.packtpub.com/in/application-development/cloud-native-programming-golang)'
- en: '*Nginx HTTP Server - Fourth Edition* by *Clement Nedelcu*, *Martin Fjordvald*: [https://www.packtpub.com/in/virtualization-and-cloud/nginx-http-server-fourth-edition](https://www.packtpub.com/in/virtualization-and-cloud/nginx-http-server-fourth-edition)'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Nginx HTTP服务器 - 第四版* 由 *Clement Nedelcu*、*Martin Fjordvald* 编著: [https://www.packtpub.com/in/virtualization-and-cloud/nginx-http-server-fourth-edition](https://www.packtpub.com/in/virtualization-and-cloud/nginx-http-server-fourth-edition)'
- en: '*Mastering Redis* by *Jeremy Nelson*: [https://www.packtpub.com/in/big-data-and-business-intelligence/mastering-redis](https://www.packtpub.com/in/big-data-and-business-intelligence/mastering-redis)'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*精通Redis* 由 *Jeremy Nelson* 编著: [https://www.packtpub.com/in/big-data-and-business-intelligence/mastering-redis](https://www.packtpub.com/in/big-data-and-business-intelligence/mastering-redis)'
- en: '*PostgreSQL Administration Cookbook, 9.5/9.6 Edition* by *Simon Riggs**,* *Gianni
    Ciolli*, *Gabriele Bartolini*: [https://www.packtpub.com/in/big-data-and-business-intelligence/postgresql-administration-cookbook-9596-edition](https://www.packtpub.com/in/big-data-and-business-intelligence/postgresql-administration-cookbook-9596-edition)'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PostgreSQL管理手册, 9.5/9.6版* 由 *Simon Riggs*、*Gianni Ciolli*、*Gabriele Bartolini*
    编著: [https://www.packtpub.com/in/big-data-and-business-intelligence/postgresql-administration-cookbook-9596-edition](https://www.packtpub.com/in/big-data-and-business-intelligence/postgresql-administration-cookbook-9596-edition)'
