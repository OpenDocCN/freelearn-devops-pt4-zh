- en: '*Chapter 2*: Comparing Podman and Docker'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第2章*：比较Podman与Docker'
- en: As we learned from the previous chapter, container technology is not as new
    as we may think and therefore its implementation and architecture has been influenced
    over the years to reach its current status.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一章中所了解到的，容器技术并不像我们想象的那样新，因此其实现和架构多年来一直在不断发展，最终形成了如今的状态。
- en: In this chapter, we’ll go through a bit of the history and the main architecture
    of Docker and Podman container engines, completing the picture with a side-by-side
    comparison to let readers with some Docker experience easily get on board and
    learn the main differences before going into a deep exploration of Podman.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾Docker和Podman容器引擎的历史和主要架构，并通过并排对比，帮助具备一定Docker经验的读者轻松理解两者之间的主要区别，然后再深入探索Podman。
- en: If you don’t have much experience with Docker, you can easily jump to the next
    chapter and return to this one once you feel it is time to learn the differences
    between Podman and Docker container engines.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对Docker没有太多经验，你可以轻松跳到下一章，并在准备好了解Podman与Docker容器引擎之间的区别时再回来阅读本章。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Docker container daemon architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker容器守护进程架构
- en: Podman daemonless architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman无守护进程架构
- en: The main differences between Docker and Podman
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker与Podman之间的主要区别
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter does not require any technical prerequisites; feel free to read
    it without worrying too much about installing or setting up any kind of software
    on your workstation!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不需要任何技术先决条件；你可以放心地阅读它，而无需担心在工作站上安装或设置任何软件！
- en: If you want to replicate some of the examples that will be described in this
    chapter, you’ll need to install and configure Podman and Docker on your workstation.
    As we described before, you can easily jump to the next chapter and come back
    to this one once you feel it’s time to learn the differences between Podman and
    Docker container engines.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想复制本章中将描述的一些示例，你需要在工作站上安装和配置Podman和Docker。如前所述，你可以轻松跳到下一章，并在准备好学习Podman和Docker容器引擎之间的区别时再回来阅读本章。
- en: Please consider that in the next chapter, you’ll be introduced to Podman’s installation
    and configuration, so you’ll be soon able to replicate any example you’ll see
    in this chapter and in the following ones.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在下一章中，你将接触到Podman的安装和配置，因此你很快就能复制本章和接下来章节中所见的任何示例。
- en: Docker container daemon architecture
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker容器守护进程架构
- en: Containers are a simple and smart answer to the need to run isolated process
    instances. We can safely affirm that containers are a form of application isolation
    that works at many levels, such as filesystem, network, resource usage, process,
    and so on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是一个简单且智能的解决方案，用于运行隔离的进程实例。我们可以安全地断言，容器是一种在多个层面上工作的应用隔离方式，比如文件系统、网络、资源使用、进程等等。
- en: As we saw in [*Chapter 1*](B17908_01_epub.xhtml#_idTextAnchor015), *Introduction
    to Container Technology*, in the *Containers versus virtual machines* section,
    containers also differ from virtual machines because containers share the same
    kernel with the host, while virtual machines have their own guest OS kernel. From
    a security point of view, virtual machines provide better isolation from potential
    attacks, but a virtual machine will usually consume more resources than a container.
    To spin up a guest OS, we usually need to allocate more RAM, CPU, and storage
    than the resources needed to start a container.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第1章*](B17908_01_epub.xhtml#_idTextAnchor015)《容器技术介绍》中所看到的，在*容器与虚拟机*部分，容器与虚拟机的不同之处在于，容器与宿主共享相同的内核，而虚拟机则拥有自己的客操作系统内核。从安全角度来看，虚拟机提供了更好的攻击隔离，但虚拟机通常会比容器消耗更多的资源。要启动一个客操作系统，通常需要分配比启动容器更多的内存、CPU和存储资源。
- en: Back in 2013, the Docker container engine appeared in the container landscape,
    and it rapidly became very popular.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 2013年，Docker容器引擎出现在容器领域，并迅速变得非常流行。
- en: As we explained before, a container engine is a software tool that accepts and
    processes requests from users to create a container; it can be seen as a sort
    of orchestrator. On the other hand, a container runtime is a lower-level piece
    of software used by container engines to run containers in the host, managing
    isolation, storage, networking, and so on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所解释的，容器引擎是一种接受并处理用户请求以创建容器的软件工具；它可以看作是一种协调器。另一方面，容器运行时是容器引擎用来在主机上运行容器的底层软件，负责管理隔离、存储、网络等功能。
- en: In the early stages, the Docker container engine used LXC as a container runtime
    but then replaced it after a while with their own implementation, *libcontainer*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期阶段，Docker 容器引擎使用 LXC 作为容器运行时，但之后不久便用他们自己实现的 *libcontainer* 替代了它。
- en: 'The Docker container engine consists of three fundamental pillars:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器引擎由三个基本支柱组成：
- en: Docker daemon
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 守护进程
- en: Docker REST API
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker REST API
- en: Docker CLI
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker CLI
- en: 'These three pillars are represented in the following architecture:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个支柱在以下架构中有所表示：
- en: '![Figure 2.1 – Docker architecture'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.1 – Docker 架构'
- en: '](img/B17908_02_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17908_02_01.jpg)'
- en: Figure 2.1 – Docker architecture
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – Docker 架构
- en: Once a Docker daemon is running, as shown in the preceding diagram, you can
    interact with it through a Docker client or a remote API. The Docker daemon is
    responsible for many local container activities as well as interacting with external
    registries to pull or push container images.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Docker 守护进程运行，如前图所示，你可以通过 Docker 客户端或远程 API 与其交互。Docker 守护进程负责许多本地容器活动，并与外部镜像仓库交互以拉取或推送容器镜像。
- en: The Docker daemon is the most critical piece of the architecture, and it should
    always be up and running, otherwise your beloved containers will not survive for
    long! Let’s see its details in the next section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 守护进程是架构中最关键的部分，它应该始终处于运行状态，否则你心爱的容器将无法生存太久！让我们在下一节中查看它的详细信息。
- en: The Docker daemon
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 守护进程
- en: A daemon is a process that runs in the background; it supervises the system
    or provides functionality to other processes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程是一个在后台运行的进程；它监督系统或为其他进程提供功能。
- en: 'The Docker daemon is the background process that is responsible for the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 守护进程是负责以下工作的后台进程：
- en: Listening for Docker API requests
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听 Docker API 请求
- en: Handling, managing, and checking for running containers
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理、管理并检查正在运行的容器
- en: Managing Docker images, networks, and storage volumes
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理 Docker 镜像、网络和存储卷
- en: Interacting with external/remote container image registries
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与外部/远程容器镜像仓库交互
- en: All these actions should be instructed to the daemon through a client or by
    calling its API, but let’s see how to communicate with it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作应该通过客户端或调用其 API 来指示守护进程，但让我们看看如何与之进行通信。
- en: Interacting with the Docker daemon
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 Docker 守护进程交互
- en: 'The Docker daemon can be contacted through the socket of a process, usually
    available in the filesystem of the host machine: `/var/run/docker.sock`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过进程的套接字联系到 Docker 守护进程，通常可以在主机文件系统中找到：`/var/run/docker.sock`。
- en: Depending on the Linux distribution of your choice, you may need to set the
    right permission for your non-root users to be able to interact with the Docker
    daemon or simply add your non-privileged users to the `docker` group.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你选择的 Linux 发行版，你可能需要为非 root 用户设置正确的权限，才能与 Docker 守护进程交互，或者仅需将非特权用户添加到 `docker`
    组。
- en: 'As you can see in the following command, these are the permissions set for
    the Docker daemon in a Fedora 34 operating system:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在以下命令中看到的，这些是为 Docker 守护进程在 Fedora 34 操作系统中设置的权限：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There is no other kind of security or authentication for a Docker daemon enabled
    by default, so be careful not to publicly expose the daemon to untrusted networks.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker 守护进程没有其他类型的安全性或身份验证，因此请小心不要将守护进程公开暴露到不受信任的网络中。
- en: The Docker REST API
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker REST API
- en: 'Once a Docker daemon is up and running, you can communicate through a client
    or directly through the REST API. Through the Docker API, you can do every kind
    of activity you can perform through the command-line tool, such as the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Docker 守护进程启动并运行，你可以通过客户端或直接通过 REST API 与其通信。通过 Docker API，你可以执行通过命令行工具进行的各种操作，例如以下操作：
- en: List containers
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出容器
- en: Create a container
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建容器
- en: Inspect a container
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查容器
- en: Get container logs
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取容器日志
- en: Export a container
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出容器
- en: Start or stop a container
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动或停止容器
- en: Kill a container
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制停止容器
- en: Rename a container
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重命名容器
- en: Pause a container
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停容器
- en: The list goes on. Looking at one of these APIs, we can easily discover how they
    work and what the sample output returned by the daemon is.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表还在继续。通过查看这些 API 的其中一个，我们可以轻松发现它们的工作原理以及守护进程返回的示例输出是什么。
- en: 'In the following command, we are going to use the Linux command line tool `curl`
    for making an HTTP request to get details about any container image already stored
    in the daemon’s local cache:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下命令中，我们将使用 Linux 命令行工具 `curl` 发出 HTTP 请求，以获取有关已存储在守护进程本地缓存中的任何容器镜像的详细信息：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see in the preceding command, the output is in JSON format, very
    detailed with multiple metadata information, from container image name to its
    size. In this example, we pre-fetched a **RHEL Universal Base Image** version
    7 in its minimal flavour that is only 80 MB!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的命令所示，输出是 JSON 格式，非常详细，包含多个元数据，从容器镜像名称到其大小。在这个例子中，我们预先拉取了 **RHEL Universal
    Base Image** 版本 7 的最小版本，仅 80 MB！
- en: Of course, APIs are not made for human consumption or interaction; they fit
    well with machine-to-machine interaction and so they are commonly used for software
    integration. For this reason, let’s now explore how the command-line client works
    and which options are available.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，API 并不是为人类消费或交互而设计的；它们非常适合机器对机器的交互，因此它们通常用于软件集成。基于此，让我们探索一下命令行客户端的工作原理以及可用的选项。
- en: Docker client commands
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 客户端命令
- en: The Docker daemon has its own companion that instructs and configures it – a
    command-line client.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 守护进程有自己的伴侣，它指示并配置守护进程——一个命令行客户端。
- en: 'The Docker command-line client has more than 30 commands with respective options
    that will enable any system administrator or Docker user to instruct and control
    the daemon and its containers. The following is an overview of the most common
    commands:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 命令行客户端有超过 30 个命令及其相应选项，能够让任何系统管理员或 Docker 用户指示和控制守护进程及其容器。以下是最常用命令的概述：
- en: '`build`: Build an image from a Dockerfile'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`: 从 Dockerfile 构建镜像'
- en: '`cp`: Copy files/folders between a container and the local filesystem'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cp`: 在容器和本地文件系统之间复制文件/文件夹'
- en: '`exec`: Run a command in a running container'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exec`: 在运行中的容器中执行命令'
- en: '`images`: List images'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`images`: 列出镜像'
- en: '`inspect`: Return low-level information on Docker objects'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inspect`: 返回关于 Docker 对象的低级信息'
- en: '`kill`: Kill one or more running containers'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kill`: 终止一个或多个正在运行的容器'
- en: '`load`: Load an image from a TAR archive or stdin'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load`: 从 TAR 存档或标准输入加载镜像'
- en: '`login`: Log in to a Docker registry'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`login`: 登录到 Docker 注册表'
- en: '`logs`: Fetch the logs of a container'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logs`: 获取容器日志'
- en: '`ps`: List running containers'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps`: 列出正在运行的容器'
- en: '`pull`: Pull an image or a repository from a registry'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pull`: 从注册表拉取镜像或仓库'
- en: '`push`: Push an image or a repository to a registry'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push`: 将镜像或仓库推送到注册表'
- en: '`restart`: Restart one or more containers'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restart`: 重启一个或多个容器'
- en: '`rm`: Remove one or more containers'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rm`: 删除一个或多个容器'
- en: '`rmi`: Remove one or more images'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rmi`: 删除一个或多个镜像'
- en: '`run`: Run a command in a new container'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run`: 在新容器中运行命令'
- en: '`save`: Save one or more images to a TAR archive (streamed to stdout by default)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`save`: 将一个或多个镜像保存到 TAR 存档中（默认通过 stdout 流式传输）'
- en: '`start`: Start one or more stopped containers'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`: 启动一个或多个已停止的容器'
- en: '`stop`: Stop one or more running containers'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop`: 停止一个或多个正在运行的容器'
- en: '`tag`: Create a `TARGET_IMAGE` tag that refers to `SOURCE_IMAGE`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tag`: 创建一个指向 `SOURCE_IMAGE` 的 `TARGET_IMAGE` 标签'
- en: The list goes on. As you can see from this subset, there are many commands available
    for managing the container images and the running containers, even exporting a
    container image or building a new one.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表还在继续。正如你从这个子集中看到的，管理容器镜像和运行中的容器有很多可用命令，甚至可以导出容器镜像或构建一个新的。
- en: Once you launch the Docker client with one of these commands and its respective
    options, the client will contact the Docker daemon, where it’ll instruct it in
    what is needed, and which action must be performed. Again, the daemon here is
    the key element of the architecture and it needs to be up and running, so ensure
    this before trying to use the Docker client as well as any of its REST APIs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你使用这些命令及其相应选项启动 Docker 客户端，客户端将联系 Docker 守护进程，并指示需要执行的操作。因此，守护进程是架构中的关键元素，必须保持运行，确保这一点之后再尝试使用
    Docker 客户端或其任何 REST API。
- en: Docker images
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 镜像
- en: A Docker image is a format introduced by Docker for managing binary data and
    metadata as a template for container creation. Docker images are packages for
    shipping and transferring runtimes, libraries, and all the stuff needed for a
    given process to be up and running.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像是一种由 Docker 引入的格式，用于管理二进制数据和元数据，作为容器创建的模板。Docker 镜像是用于运输和传输运行时、库以及运行某个特定进程所需的一切资源的封装。
- en: As we mentioned in [*Chapter 1*](B17908_01_epub.xhtml#_idTextAnchor015), *Introduction
    to Container Technology*, in the *Where do containers come from?* section, the
    creation of this format was really a game changer and significantly different
    from the various other container technologies that arose in the past.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [*第 1 章*](B17908_01_epub.xhtml#_idTextAnchor015)《容器技术简介》中提到的，在 *容器来自哪里？*
    一节中，这种格式的创建确实是一个游戏规则的改变，与过去出现的其他容器技术显著不同。
- en: Starting from version 1.12, Docker started adopting an image specification that
    has over the years evolved into the current version that adheres to the **OCI
    Image Format Specification**.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从 1.12 版本开始，Docker 开始采用一种镜像规范，这种规范随着时间的推移，已经发展为符合**OCI 镜像格式规范**的当前版本。
- en: 'The first Docker Image Specification included many concepts and fields that
    are now part of the OCI Image Format Specification, such as the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 Docker 镜像规范包含了许多现在已成为 OCI 镜像格式规范一部分的概念和字段，例如以下内容：
- en: A list of layers
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层的列表
- en: Creation date
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建日期
- en: Operating system
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统
- en: CPU architecture
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU 架构
- en: Configuration parameters for use within a container runtime
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于容器运行时的配置参数
- en: A Docker image’s content (binaries, libraries, filesystem data) is organized
    in layers. A layer is just a set of filesystem changes that does not contain any
    environment variable or default arguments for a given command. This data is stored
    in the **Image Manifest** that owns the configuration parameters.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像的内容（包括二进制文件、库、文件系统数据）是以层的形式组织的。每一层只是文件系统的更改集，不包含任何环境变量或特定命令的默认参数。这些数据存储在拥有配置参数的**镜像清单**中。
- en: But how are these layers created and then aggregated in a Docker image? The
    answer is not so simple. The layers in a container image are composed together
    using image metadata and merged into a single filesystem view. This result can
    be achieved in many ways, but as anticipated in the previous chapter, the most
    common approach today is by using union filesystems – combining two filesystems
    and providing a unique, *squashed* view. Finally, when a container is executed,
    a new, *read/write* ephemeral layer is created on top of the image, which will
    be lost after the container is destroyed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些层是如何在 Docker 镜像中创建并聚合的呢？答案并不简单。容器镜像中的层是通过使用镜像元数据组合在一起，并合并为单一的文件系统视图。这一结果可以通过多种方式实现，但正如前一章节所预测的那样，当前最常见的做法是使用联合文件系统——结合两个文件系统并提供一个独特的、*压缩*的视图。最后，当容器被执行时，会在镜像之上创建一个新的、*可读写*的临时层，该层在容器销毁后会丢失。
- en: As we said earlier in this chapter, container images and their distribution
    were the killer feature of Docker containers. So, in the next section, let’s look
    at the key element for container distribution, **Docker registries**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章早些时候所说，容器镜像及其分发是 Docker 容器的杀手级特性。因此，在下一节中，让我们来看看容器分发的关键元素——**Docker 注册表**。
- en: Docker registries
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 注册表
- en: A Docker registry is just a repository of Docker container images that holds
    the metadata and the layers of container images for making them available to several
    Docker daemons.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 注册表只是一个 Docker 容器镜像的存储库，它保存容器镜像的元数据和层，以便将这些镜像提供给多个 Docker 守护进程使用。
- en: A Docker daemon acts as a client to a Docker registry through an HTTP API, pushing
    and pulling container images depending on the action that the Docker client instructs.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 守护进程通过 HTTP API 作为客户端与 Docker 注册表进行交互，根据 Docker 客户端的指令推送和拉取容器镜像。
- en: Using a container registry could really help the use of containers on many independent
    machines that could be configured to ask to a registry some container images if
    they are not present in the Docker daemon local cache. The default registry that
    is preconfigured in Docker daemon settings is **Dockerhub**, a **Software-as-a-Service**
    container registry hosted by Docker company in the cloud. However, Dockerhub is
    not the only registry; many other container registries have appeared in recent
    years.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器注册表确实可以帮助在许多独立的机器上使用容器，这些机器可以被配置为在Docker守护进程的本地缓存中没有容器镜像时，向注册表请求容器镜像。Docker守护进程设置中预配置的默认注册表是**Dockerhub**，这是一个由Docker公司在云端托管的**软件即服务**容器注册表。然而，Dockerhub并不是唯一的注册表，近年来，许多其他容器注册表也相继出现。
- en: Almost every company or community working with containers created their own
    container registry with a different web interface. One of the free alternative
    services to Dockerhub is **Quay.io**, a Software-as-a-Service container registry
    hosted by the Red Hat company.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个使用容器的公司或社区都创建了自己的容器注册表，并且它们有不同的Web界面。Dockerhub的一个免费的替代服务是**Quay.io**，这是由Red
    Hat公司托管的一个软件即服务容器注册表。
- en: 'One great alternative to cloud services is the on-premises Docker registry,
    which can be created through a container on a machine running the Docker daemon
    with just one command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的替代云服务的方案是本地Docker注册表，它可以通过在运行Docker守护进程的机器上通过一个命令创建容器来实现：
- en: '[PRE2]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is not the objective of this book to go through the various Docker options
    and configuration, but if you want to know more about the Docker registry, you
    can refer to the main Docker documentation at [https://docs.docker.com/registry/deploying/](https://docs.docker.com/registry/deploying/).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目标不是详细讲解各种Docker选项和配置，但如果您想了解更多关于Docker注册表的信息，可以参考Docker官方文档：[https://docs.docker.com/registry/deploying/](https://docs.docker.com/registry/deploying/)。
- en: We have looked at a lot of stuff so far, namely the Docker API, client, daemon,
    images, and finally the registry, but, as we mentioned earlier, it’s all dependent
    on the correct usage of the Docker daemon that should be always healthy and up
    and running. So, let’s explore now what happens in the event that it stops working.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经查看了很多内容，包括Docker API、客户端、守护进程、镜像以及最终的注册表，但正如我们之前提到的，这一切都依赖于Docker守护进程的正确使用，守护进程应该始终健康并且正常运行。那么，现在让我们探索一下当它停止工作时会发生什么。
- en: What does a running Docker architecture look like?
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行中的Docker架构是什么样的？
- en: The Docker daemon is the central key element of the whole Docker architecture.
    We will explore in this section what a Docker daemon and a bunch of running containers
    look like.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Docker守护进程是整个Docker架构的核心关键元素。在这一部分，我们将探讨Docker守护进程和一堆运行中的容器的样子。
- en: 'We will not dive into the steps needed for installing and setting up the Docker
    daemon; instead, we will directly analyze a preconfigured operating system with
    it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入讨论安装和设置Docker守护进程所需的步骤；相反，我们将直接分析一个预配置的操作系统：
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see from the preceding command, we just verified that the Docker
    daemon is up and running, but it’s not the only container service running on the
    system. The Docker daemon has a companion that we skipped in the previous part
    to keep the description easy to understand: **Containerd**.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的命令中看到的，我们刚刚验证了Docker守护进程正在运行，但它不是系统上唯一运行的容器服务。Docker守护进程有一个我们在前面部分跳过的伙伴，为了保持描述的简洁性：**Containerd**。
- en: 'To better understand the workflow, have a look at the following diagram:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解工作流程，请查看下面的图表：
- en: '![Figure 2.2 – Running a Docker container'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2 – 运行Docker容器](img/B17908_02_02.jpg)'
- en: '](img/B17908_02_02.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17908_02_02.jpg)'
- en: Figure 2.2 – Running a Docker container
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 运行Docker容器
- en: Containerd is the project that decouples the container management (kernel interaction
    included) from the Docker daemon, and it also adheres to the OCI standard using
    `runc` as container runtime.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Containerd是一个将容器管理（包括与内核的交互）从Docker守护进程中解耦的项目，它还遵循OCI标准，并使用`runc`作为容器运行时。
- en: 'So, let’s check the status of Containerd in our preconfigured operating system:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们检查一下在我们预配置的操作系统中Containerd的状态：
- en: '[PRE4]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see from the preceding console output, the service is up and running
    and it has started three child processes: `/usr/bin/containerd-shim-runc-v2`.
    This matches perfectly what we just saw in *Figure 2.2*!'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的控制台输出中看到的，服务正在运行并已启动三个子进程：`/usr/bin/containerd-shim-runc-v2`。这与我们刚刚在*图2.2*中看到的完全匹配！
- en: 'Now, let’s check our running containers interacting with the Docker CLI:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查一下与Docker CLI交互的运行中的容器：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the Docker client confirms that we have three running containers
    on our system, all started through the `runc` container runtime, managed by the
    Containerd system service and configured through a Docker daemon.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Docker 客户端确认我们的系统上有三个正在运行的容器，所有容器都是通过 `runc` 容器运行时启动的，由 Containerd 系统服务管理，并通过
    Docker 守护进程配置。
- en: Now that we have introduced this new element, Containerd, let’s look at it in
    more depth in the next section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了这个新元素 Containerd，让我们在下一节深入了解它。
- en: Containerd architecture
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Containerd 架构
- en: 'Containerd architecture is composed of several components that are organized
    in subsystems. Components that link different subsystems are also referred to
    as modules in the Containerd architecture, as can be seen in the following diagram:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Containerd 架构由多个组件组成，这些组件被组织在子系统中。连接不同子系统的组件也被称为容器架构中的模块，如下图所示：
- en: '![Figure 2.3 – Containerd architecture'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.3 – Containerd 架构'
- en: '](img/B17908_02_03.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17908_02_03.jpg)'
- en: Figure 2.3 – Containerd architecture
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – Containerd 架构
- en: 'The two main subsystems available are the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的两个主要子系统如下：
- en: The bundle service that extracts bundles from disk images
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从磁盘镜像中提取包的包服务
- en: The runtime service that executes the bundles, creating the runtime containers
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行包的运行时服务，创建运行时容器
- en: 'The main modules that make the architecture fully functional are the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使架构完全功能化的主要模块如下：
- en: The `Executor` module, which implements the container runtime that is represented
    in the preceding architecture as the **Runtimes** block
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Executor` 模块，执行前面架构中作为**运行时**块表示的容器运行时'
- en: The `Supervisor` module, which monitors and reports container state that is
    part of the **Containers** block in the preceding architecture
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Supervisor` 模块，监控并报告容器状态，属于前面架构中的**容器**块'
- en: The `Snapshot` module, which manages filesystem snapshots
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Snapshot` 模块，管理文件系统快照'
- en: The `Events` module, which collects and consumes events
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Events` 模块，收集和消耗事件'
- en: The `Metrics` module, which exports several metrics via the metrics API
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Metrics` 模块，通过度量 API 导出多个指标'
- en: 'The steps needed by Containerd to place a container in a running state are
    too complex to be described in this section, but we can sum them up as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Containerd 将容器置于运行状态所需的步骤太复杂，无法在本节中详细描述，但我们可以将其总结如下：
- en: Pull metadata and content through a **Distribution Controller**.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过**分发控制器**拉取元数据和内容。
- en: Use the **Bundle Controller** to unpack the retrieved data, creating snapshots
    that will compose bundles.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**Bundle 控制器**解包获取的数据，创建将组成包的快照。
- en: 'Execute the container through the bundle just created through the **Runtime
    Controller**:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过**运行时控制器**执行刚刚创建的容器：
- en: '![Figure 2.4 – Containerd data flow diagram'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.4 – Containerd 数据流图'
- en: '](img/B17908_02_04.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17908_02_04.jpg)'
- en: Figure 2.4 – Containerd data flow diagram
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – Containerd 数据流图
- en: In this section, we have described the key features and design principles of
    the Docker container engine, with its daemon-centric approach. We can now move
    on to analyze the Podman daemonless architecture.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经描述了 Docker 容器引擎的关键特性和设计原则，以及它以守护进程为中心的方式。现在我们可以继续分析 Podman 无守护进程架构。
- en: Podman daemonless architecture
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Podman 无守护进程架构
- en: Podman (short for *POD MANager*) is a daemonless container engine that enables
    users to manage containers, images, and their related resources such as storage
    volumes or network resources. First-time users installing Podman soon realize
    that there is no service to start after the installation is complete. No background
    running daemon is required to run containers with Podman!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Podman（*POD MANager*的缩写）是一个无守护进程的容器引擎，允许用户管理容器、镜像及其相关资源，如存储卷或网络资源。首次安装 Podman
    的用户很快就会意识到，安装完成后没有需要启动的服务。运行容器时，Podman 不需要后台运行的守护进程！
- en: Once installed, the Podman binary acts both as a **command-line interface**
    (**CLI**) and as a container engine that orchestrates the container runtime execution.
    The following subsections will explore the details of the Podman behavior and
    building blocks.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，Podman 二进制文件既充当**命令行接口**（**CLI**），又充当一个容器引擎，协调容器运行时的执行。接下来的子节将详细介绍 Podman
    的行为和构建块。
- en: Podman commands and REST API
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Podman 命令和 REST API
- en: The Podman CLI provides a growing set of commands. The curated list is available
    at [https://docs.podman.io/en/latest/Commands.html](https://docs.podman.io/en/latest/Commands.html).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Podman CLI 提供了一个不断扩展的命令集。整理好的命令列表可在[https://docs.podman.io/en/latest/Commands.html](https://docs.podman.io/en/latest/Commands.html)找到。
- en: 'The following list explores a subset of the most commonly used commands:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表探讨了最常用命令的一个子集：
- en: '`build`: Build an image from a Containerfile or Dockerfile'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`: 从 Containerfile 或 Dockerfile 构建镜像'
- en: '`cp`: Copy files/folders between a container and the local filesystem'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cp`: 在容器和本地文件系统之间复制文件/文件夹'
- en: '`exec`: Run a command in a running container'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exec`: 在正在运行的容器中运行命令'
- en: '`events`: Show Podman events'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`events`: 显示 Podman 事件'
- en: '`generate`: Generate structured data such as Kubernetes YAML or systemd units'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generate`: 生成结构化数据，如 Kubernetes YAML 或 systemd 单元'
- en: '`images`: List local cached images'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`images`: 列出本地缓存的镜像'
- en: '`inspect`: Return low-level information on containers or images'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inspect`: 返回容器或镜像的低级信息'
- en: '`kill`: Kill one or more running containers'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kill`: 终止一个或多个正在运行的容器'
- en: '`load`: Load an image from a container TAR archive or stdin'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load`: 从容器 TAR 存档或标准输入加载镜像'
- en: '`login`: Log in to a container registry'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`login`: 登录到容器镜像仓库'
- en: '`logs`: Fetch the logs of a container'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logs`: 获取容器日志'
- en: '`pod`: Manage pods'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pod`: 管理 Pod'
- en: '`ps`: List running containers'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps`: 列出正在运行的容器'
- en: '`pull`: Pull an image or a repository from a registry'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pull`: 从镜像仓库拉取镜像或仓库'
- en: '`push`: Push an image or a repository to a registry'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push`: 将镜像或仓库推送到镜像仓库'
- en: '`restart`: Restart one or more containers'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restart`: 重启一个或多个容器'
- en: '`rm`: Remove one or more containers'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rm`: 删除一个或多个容器'
- en: '`rmi`: Remove one or more images'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rmi`: 删除一个或多个镜像'
- en: '`run`: Run a command in a new container'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run`: 在新的容器中运行命令'
- en: '`save`: Save one or more images to a TAR archive (streamed to stdout by default)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`save`: 将一个或多个镜像保存到 TAR 存档（默认通过标准输出流）'
- en: '`start`: Start one or more stopped containers'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`: 启动一个或多个已停止的容器'
- en: '`stop`: Stop one or more running containers'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop`: 停止一个或多个正在运行的容器'
- en: '`system`: Manage Podman (disk usage, container migration, REST API services,
    storage management, and pruning)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system`: 管理 Podman（磁盘使用、容器迁移、REST API 服务、存储管理和清理）'
- en: '`tag`: Create a `TARGET_IMAGE` tag that refers to `SOURCE_IMAGE`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tag`: 创建一个 `TARGET_IMAGE` 标签，指向 `SOURCE_IMAGE`'
- en: '`unshare`: Run a command in a modified user namespace'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unshare`: 在修改后的用户命名空间中运行命令'
- en: '`volume`: Manage container volumes (list, pruning, creation, inspection)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volume`: 管理容器卷（列出、清理、创建、检查）'
- en: In the upcoming chapters of the book, we will cover the preceding commands in
    greater detail and understand how to use them to manage the full container life
    cycle.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后续章节中，我们将更详细地介绍前述命令，并了解如何使用它们来管理整个容器生命周期。
- en: Users who have already worked with Docker will immediately spot the same commands
    they used to execute with the Docker CLI. Podman CLI commands are compatible with
    Docker ones to help a smooth transition between the two tools.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 已经使用 Docker 的用户会立即识别出与 Docker CLI 相同的命令。Podman CLI 命令与 Docker 命令兼容，有助于平滑过渡到这两个工具之间。
- en: Differently from Docker, Podman does not need a running Docker daemon listening
    on a Unix socket to execute the preceding commands. Users can still choose to
    run a Podman service and make it listen to a Unix socket to expose native REST
    APIs.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Docker 不同，Podman 不需要一个运行中的 Docker 守护进程来监听 Unix 套接字执行前述命令。用户仍然可以选择运行 Podman
    服务，并使其监听 Unix 套接字以暴露本地 REST API。
- en: 'By running the following command, Podman will create a socket endpoint on a
    path of preference and listen to API calls:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令，Podman 将在首选路径上创建一个套接字端点，并监听 API 调用：
- en: '[PRE6]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If not provided, the default socket endpoint is `unix://run/podman/podman.sock`
    for rootful services and `unix://run/user/<UID>/podman/podman.sock` for rootless
    containers.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未提供，默认的套接字端点为 `unix://run/podman/podman.sock`（rootful 服务）和 `unix://run/user/<UID>/podman/podman.sock`（rootless
    容器）。
- en: 'As a result, users can then make REST API calls to the socket endpoint. The
    following example queries Podman for the available local images:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，用户可以对套接字端点发出 REST API 调用。以下示例查询 Podman 以获取可用的本地镜像：
- en: '[PRE7]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Podman project maintains OpenAPI-compliant documentation of available REST
    API calls at [https://docs.podman.io/en/latest/_static/api.html](https://docs.podman.io/en/latest/_static/api.html).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 项目在[https://docs.podman.io/en/latest/_static/api.html](https://docs.podman.io/en/latest/_static/api.html)提供符合
    OpenAPI 的可用 REST API 调用文档。
- en: The piped `jq` command in the preceding example is useful to produce a more
    readable JSON-pretty output. We will explore the Podman REST API and systemd socket-based
    activation in greater detail in the post-installation customization section of
    [*Chapter 3*](B17908_03_epub.xhtml#_idTextAnchor068), *Running the First Container*.
    Let’s now describe Podman building blocks in greater detail.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例中的管道`jq`命令有助于生成更易读的JSON格式输出。我们将在安装后定制部分的[*第3章*](B17908_03_epub.xhtml#_idTextAnchor068)，*运行第一个容器*中，详细探讨Podman
    REST API和基于systemd socket的激活。接下来，我们将更详细地描述Podman的构建模块。
- en: Podman building blocks
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Podman构建模块
- en: 'Podman aims to adhere to open standards as much as possible; therefore, most
    of the runtime, build, storage, and networking components rely on community projects
    and standards. The components described in the following list can be seen as the
    main Podman building blocks:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Podman旨在尽可能遵循开放标准；因此，大多数运行时、构建、存储和网络组件都依赖于社区项目和标准。以下列出的组件可以看作是Podman的主要构建模块：
- en: 'The container life cycle is managed with the **libpod** library, already included
    in the Podman main repository: [https://github.com/containers/podman/tree/main/libpod.](https://github.com/containers/podman/tree/main/libpod'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器生命周期通过**libpod**库进行管理，该库已包含在Podman的主仓库中：[https://github.com/containers/podman/tree/main/libpod](https://github.com/containers/podman/tree/main/libpod)。
- en: )
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: The container runtime is based on the OCI specs implemented by OCI-compliant
    runtimes, such as **crun** and **runc**. We will see in this chapter how container
    runtimes work and the main difference between the above-mentioned ones.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器运行时基于OCI规范，OCI兼容的运行时（如**crun**和**runc**）实现了这些规范。在本章中，我们将看到容器运行时的工作原理以及上述运行时之间的主要区别。
- en: At the same time, image management implements the **containers/image** library
    ([https://github.com/containers/image](https://github.com/containers/image)).
    This is a set of Go libraries used both by container engines and container registries.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时，镜像管理通过**containers/image**库实现（[https://github.com/containers/image](https://github.com/containers/image)）。这是一个Go语言库，既被容器引擎使用，也被容器注册中心使用。
- en: Container and image storage is implemented adopting the **containers/storage**
    library ([https://github.com/containers/storage](https://github.com/containers/storage)),
    another Go library to manage filesystem layers, container images, and container
    volumes at runtime.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器和镜像存储通过**containers/storage**库（[https://github.com/containers/storage](https://github.com/containers/storage)）实现，这是另一个Go语言库，用于在运行时管理文件系统层、容器镜像和容器卷。
- en: Image builds are implemented with Buildah ([https://github.com/containers/buildah](https://github.com/containers/buildah)),
    which is both a binary tool and a library for building OCI images. We will cover
    Buildah later in this book.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像构建通过Buildah（[https://github.com/containers/buildah](https://github.com/containers/buildah)）实现，Buildah既是一个二进制工具，也是一个用于构建OCI镜像的库。我们将在本书稍后的章节介绍Buildah。
- en: Container runtime monitoring and communication with the engine is implemented
    with **Conmon**, a tool for monitoring OCI runtimes, used by both Podman and **CRI-O**
    ([https://github.com/containers/conmon](https://github.com/containers/conmon)).
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器运行时监控和与引擎的通信通过**Conmon**工具实现，Conmon是一个用于监控OCI运行时的工具，被Podman和**CRI-O**（[https://github.com/containers/conmon](https://github.com/containers/conmon)）共同使用。
- en: 'Container networking support is implemented through the Kubernetes `bridge`
    CNI plugin. An extended list of plugins is available in the following repository:
    https://github.com/containernetworking/plugins.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 容器网络支持通过Kubernetes `bridge` CNI插件实现。更多插件列表可在以下仓库中找到：https://github.com/containernetworking/plugins。
- en: As stated earlier, Podman orchestrates the container life cycle thanks to the
    libpod library, described in the next subsection.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Podman通过libpod库来协调容器生命周期，具体内容将在下一小节中描述。
- en: The libpod library
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: libpod库
- en: Podman core foundations are based on the libpod library, which is also adopted
    by other open source projects such as CRI-O. This library contains all the necessary
    logic to orchestrate the container life cycle and we can safely say that the development
    of this library was the key to the birth of the Podman project as we know it today.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Podman的核心基础依赖于libpod库，其他开源项目如CRI-O也采用了该库。这个库包含了所有协调容器生命周期所需的逻辑，可以说这个库的开发是Podman项目诞生的关键。
- en: 'The library is written in Go and is thus accessed as a **Go package** and is
    intended to implement all the high-level functionalities of the engine. According
    to the libpod and Podman documentation, its scope includes the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 该库是用Go编写的，因此作为**Go包**访问，旨在实现引擎的所有高级功能。根据libpod和Podman文档，其范围包括以下内容：
- en: Managing container image format, which includes both OCI and Docker images.
    This includes the full image life cycle management, from authenticating and pulling
    from a container registry, and local storage of the image layers and metadata,
    to the building of new images and pushing to remote registries.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理容器镜像格式，包括OCI和Docker镜像。这包括完整的镜像生命周期管理，从认证和从容器注册表拉取，存储镜像层和元数据的本地存储，到构建新镜像并推送到远程注册表。
- en: Container life cycle management – from container creation (with all the necessary
    preliminary steps involved) and running the container to all the other runtime
    functionalities such as stop, kill, resume, and delete, process execution on running
    containers, and logging.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器生命周期管理——从容器创建（包括所有必要的初步步骤）到运行容器，再到所有其他运行时功能，如停止、杀死、恢复、删除、在运行容器上执行进程以及日志记录。
- en: Managing both simple containers and **pods**, which are groups of sandboxed
    containers that share namespaces together (notably UTC, IPC, Network, and recently
    Pid) and are also managed together as a whole.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理简单的容器和**Pod**，Pod是共享命名空间的沙箱容器组（特别是UTC、IPC、网络，最近还包括PID），这些容器和Pod作为整体一起管理。
- en: Supporting **rootless** containers and pods that can be executed by standard
    users with no need for privilege escalation.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持**无根**容器和Pod，这些容器和Pod可以由标准用户执行，无需特权提升。
- en: Managing container resource isolation. This is achieved at a low level with
    CGroup but Podman users can interact using CLI options during container execution
    to manage memory and CPU reservation or limit read/write rate on a storage device.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理容器资源隔离。这在低层次上通过CGroup实现，但Podman用户可以在容器执行过程中使用CLI选项来管理内存和CPU的预留或限制存储设备的读写速率。
- en: Supporting a CLI that can be used as a Docker-compatible alternative. Most Podman
    commands are the same as in the Docker CLI.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持一个可以用作Docker兼容替代品的CLI。大多数Podman命令与Docker CLI中的命令相同。
- en: Providing a Docker-compatible REST API with local Unix sockets (not enabled
    by default). Libpod REST APIs provide all the functionalities provided by the
    Podman CLI.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供与Docker兼容的REST API，通过本地Unix套接字（默认未启用）。Libpod REST API提供Podman CLI所提供的所有功能。
- en: The lidpod package interacts, at a lower level, with container runtimes, Conmon,
    and packages such as container/storage, container/image, Buildah, and CNI. In
    the next section, we will focus on the container runtime execution.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: lidpod包在较低层次上与容器运行时、Conmon以及如container/storage、container/image、Buildah和CNI等包进行交互。在下一节中，我们将重点关注容器运行时执行。
- en: The runc and crun OCI container runtimes
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: runc和crun OCI容器运行时。
- en: As illustrated in the previous chapter, a container engine takes care of the
    high-level orchestration of the container life cycle, while the low-level actions
    necessary to create and run the container are delivered by a container runtime.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一章节所示，容器引擎负责容器生命周期的高级编排，而创建和运行容器所需的低级操作由容器运行时提供。
- en: 'An industry standard has emerged in the last few years, with the help of the
    major container environment contributors: the **OCI Runtime Specification**. The
    full specification is available at [https://github.com/opencontainers/runtime-spec](https://github.com/opencontainers/runtime-spec).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，随着主要容器环境贡献者的帮助，**OCI运行时规范**已成为行业标准。完整规范可以在[https://github.com/opencontainers/runtime-spec](https://github.com/opencontainers/runtime-spec)上查看。
- en: 'From this repository, the *Runtime and Lifecycle* document provides a full
    description of how the container runtime should handle the container creation
    and execution: [https://github.com/opencontainers/runtime-spec/blob/master/runtime.md](https://github.com/opencontainers/runtime-spec/blob/master/runtime.md).'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个代码库中，*运行时和生命周期*文档提供了容器运行时如何处理容器创建和执行的完整描述：[https://github.com/opencontainers/runtime-spec/blob/master/runtime.md](https://github.com/opencontainers/runtime-spec/blob/master/runtime.md)。
- en: '**Runc** ([https://github.com/opencontainers/runc](https://github.com/opencontainers/runc))
    is currently the most widely adopted OCI container runtime. Its history leads
    back to 2015, when Docker announced the spin out of all its infrastructure plumbing
    into a dedicated project called runC.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**Runc** ([https://github.com/opencontainers/runc](https://github.com/opencontainers/runc))
    是当前最广泛采用的 OCI 容器运行时。它的历史可以追溯到 2015 年，当时 Docker 宣布将所有基础设施模块拆分到一个名为 runC 的专用项目中。'
- en: RunC fully supports Linux containers and OCI runtime specs. The project repository
    includes the **libcontainer** package, which is a Go package for creating containers
    with namespaces, cgroups, capabilities, and filesystem access controls. Libcontainer
    was an independent Docker project before, and when the runC project was created,
    it was moved inside its main repository for the sake of consistence and clarity.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: RunC 完全支持 Linux 容器和 OCI 运行时规范。该项目仓库包含 **libcontainer** 包，这是一个用于创建带有命名空间、cgroups、能力和文件系统访问控制的容器的
    Go 包。Libcontainer 曾是一个独立的 Docker 项目，当 runC 项目创建时，它被移到其主仓库中，以确保一致性和清晰性。
- en: The libcontainer package defines the inner logic and the low-level system interaction
    to bootstrap a container from scratch, from the initial isolation of namespaces
    to the execution as PID 1 of the binary program inside the container itself.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: libcontainer 包定义了容器从零开始引导的内部逻辑和低级系统交互，从命名空间的初步隔离到容器内部二进制程序作为 PID 1 执行。
- en: 'The runtime recalls the libcontainer library to fulfil the following tasks:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时回调 libcontainer 库以完成以下任务：
- en: Consume the container mount point and the container metadata provided by Podman
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消耗 Podman 提供的容器挂载点和容器元数据。
- en: Interact with the kernel to start the container and execute the isolated process
    using the `clone()` and `unshare()` syscalls
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与内核交互，使用 `clone()` 和 `unshare()` 系统调用启动容器并执行隔离进程。
- en: Set up CGroup resource reservations
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 CGroup 资源预留。
- en: Set up SELinux Policy, Seccomp, and App Armor rules
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 SELinux 策略、Seccomp 和 AppArmor 规则。
- en: Along with running processes, libcontainer handles the initialization of namespaces
    and file descriptors, the creation of the container rootFS and bind mounts, exporting
    logs from container processes, managing security restrictions with seccomp, SELinux
    and AppArmor, and creating and mapping users and groups
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 除了运行进程，libcontainer 还处理命名空间和文件描述符的初始化，容器 rootFS 和绑定挂载的创建，导出容器进程的日志，通过 seccomp、SELinux
    和 AppArmor 管理安全限制，以及创建和映射用户和组。
- en: The libcontainer architecture is quite a complex topic for this book and obviously
    needs further investigation to better understand its internals.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: libcontainer 架构是本书中一个相当复杂的话题，显然需要进一步的研究以更好地理解其内部实现。
- en: For readers interested in viewing the code and understanding Podman internals,
    the container interface that adheres to the OCI runtime specs is defined in the
    [https://github.com/opencontainers/runc/blob/master/libcontainer/container.go](https://github.com/opencontainers/runc/blob/master/libcontainer/container.go)
    source file.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些有兴趣查看代码并了解 Podman 内部实现的读者，符合 OCI 运行时规范的容器接口定义在 [https://github.com/opencontainers/runc/blob/master/libcontainer/container.go](https://github.com/opencontainers/runc/blob/master/libcontainer/container.go)
    源文件中。
- en: The methods for the Linux OS that implement the interface are defined in [https://github.com/opencontainers/runc/blob/master/libcontainer/container_linux.go](https://github.com/opencontainers/runc/blob/master/libcontainer/container_linux.go).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 实现该接口的 Linux 操作系统方法定义在 [https://github.com/opencontainers/runc/blob/master/libcontainer/container_linux.go](https://github.com/opencontainers/runc/blob/master/libcontainer/container_linux.go)
    中。
- en: The low-level execution of `clone()` and `unshare() syscall` to isolate the
    process namespaces is handled by the `nsexec()` function. This is a C function
    embedded in the Go code thanks using **cgo**.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `clone()` 和 `unshare()` 系统调用隔离进程命名空间的低级执行由 `nsexec()` 函数处理。这是一个嵌入在 Go 代码中的
    C 函数，通过 **cgo** 实现。
- en: 'The code of `nsexec()` can be found here:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`nsexec()` 的代码可以在这里找到：'
- en: '[https://github.com/opencontainers/runc/blob/master/libcontainer/nsenter/nsexec.c](https://github.com/opencontainers/runc/blob/master/libcontainer/nsenter/nsexec.c'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/opencontainers/runc/blob/master/libcontainer/nsenter/nsexec.c](https://github.com/opencontainers/runc/blob/master/libcontainer/nsenter/nsexec.c)'
- en: )
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: Along with `runC`, many other container runtimes have been created. An alternative
    runtime we will discuss in this book is `crun` was to provide an improved OCI
    runtime that could leverage the C design approach for a cleaner and lightweight
    runtime. Since they are both OCI runtimes, `runC` and `crun` can be used interchangeably
    by a container engine.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 与`runC`一起，许多其他容器运行时也已经被创建。在本书中我们将讨论的一个替代运行时是`crun`，它旨在提供一个改进的OCI运行时，可以利用C语言设计方法，打造一个更清晰、更轻量的运行时。由于它们都是OCI运行时，`runC`和`crun`可以在容器引擎中互换使用。
- en: For example, in 2019, the Fedora project made a brave move and chose to release
    Fedora 31 with CGroup V2 as the default ([https://www.redhat.com/sysadmin/fedora-31-control-group-v2](https://www.redhat.com/sysadmin/fedora-31-control-group-v2)).
    At the time of this choice, `runC` was not yet capable of managing containers
    under CGroup V2\.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，2019年，Fedora项目做出了一个大胆的决定，选择将CGroup V2作为默认选项发布Fedora 31（[https://www.redhat.com/sysadmin/fedora-31-control-group-v2](https://www.redhat.com/sysadmin/fedora-31-control-group-v2)）。在做出这个选择时，`runC`尚不支持在CGroup
    V2下管理容器\。
- en: Consequently, the Podman release for Fedora adopted `crun` as the default runtime
    since it was already capable of managing both CGroup V1 and V2\. This switch was
    almost seamless for end users, who continued to use Podman in the same way with
    the same commands and behaviors. Later, `runC` finally introduced support for
    CGroup V2, from v1.0.0-rc93, and can now be used on newer distributions seamlessly.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Fedora的Podman版本采用了`crun`作为默认运行时，因为它已经能够管理CGroup V1和V2\. 对最终用户来说，这一切几乎是无缝的，他们依旧使用Podman，并保持相同的命令和行为。后来，`runC`终于从v1.0.0-rc93版本开始支持CGroup
    V2，现在可以在较新的发行版上无缝使用。
- en: However, the CGroup topic was not the only differentiator between `runC` and
    `crun`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，CGroup 主题并不是`runC`和`crun`之间唯一的区分点。
- en: '`crun` provides some interesting advantages against `runC`, such as the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`crun`相比`runC`提供了一些有趣的优势，具体如下：'
- en: '`crun` build is approximately 50 times smaller than a `runC` build.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crun`的构建文件大约比`runC`的构建文件小50倍。'
- en: '`crun` is faster on instrumenting the container than `runC` under the same
    execution conditions.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在相同的执行条件下，`crun`在容器执行时比`runC`更快。
- en: '`crun` consumes less than half the memory of `runC`. A smaller memory footprint
    is extremely helpful when dealing with massive container deployments or IoT appliances.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crun`消耗的内存不到`runC`的一半。较小的内存占用在处理大规模容器部署或物联网设备时非常有帮助。'
- en: '`crun` can also be used as a library and integrated in other OCI-compliant
    projects. Both `crun` and `runC` provide a CLI but are not meant to be used manually
    by end users, who are supposed to use a container engine such as Podman or Docker
    to manage the container life cycle.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`crun`还可以作为一个库使用，并集成到其他符合OCI标准的项目中。`crun`和`runC`都提供了CLI，但并不打算由最终用户手动使用，最终用户应该使用容器引擎，如Podman或Docker来管理容器生命周期。'
- en: 'How easy is it to switch between the two runtimes in Podman? Let’s see the
    following examples. Both examples run a container using the `–runtime` flag to
    provide an OCI runtime binary path. The first one runs the container using `runC`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在Podman中切换这两种运行时有多容易？让我们看看以下示例。两个示例都使用`–runtime`标志来提供OCI运行时二进制路径。第一个示例使用`runC`运行容器：
- en: '[PRE8]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The second line runs the same container with the `crun` binary:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行使用`crun`二进制文件运行相同的容器：
- en: '[PRE9]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The examples assume that both runtimes are already installed in the system.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例假设两个运行时已经在系统中安装。
- en: Both `crun` and `runC` support **eBPF** and **CRIU**.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`crun`和`runC`都支持**eBPF**和**CRIU**。'
- en: '**eBPF** stands for **Extended Berkeley Packet Filter** and is a kernel-based
    technology that allows the execution of user-defined programs in the Linux kernel
    to add extra capabilities to the system without the need to recompile the kernel
    or load extra modules. All eBPF programs are executed inside a sandbox virtual
    machine and their execution is secure by design. Today, eBPF is gaining momentum
    and attracting industry interest, leading to wide adoption in different use cases,
    most notably networking, security, observability, and tracing.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**eBPF**代表**扩展伯克利数据包过滤器**，是一种基于内核的技术，允许在Linux内核中执行用户定义的程序，向系统添加额外的功能，而无需重新编译内核或加载额外的模块。所有eBPF程序都在一个沙箱虚拟机内执行，其执行过程天生是安全的。今天，eBPF正获得越来越多的关注，并吸引了行业的兴趣，尤其在网络、安全、可观察性和追踪等领域得到了广泛应用。'
- en: '**Checkpoint Restore in Userspace** (**CRIU**) is a piece of software that
    enables users to freeze a running container and save its state to disk for further
    resume. Data structures saved in memory are dumped and restored accordingly.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户空间中的检查点恢复**（**CRIU**）是一款软件，它使用户能够冻结正在运行的容器并将其状态保存到磁盘以供后续恢复。内存中的数据结构会被转储并相应地恢复。'
- en: Another important architectural component used by Podman is Conmon, a tool for
    monitoring container runtime status. Let’s investigate this in more detail in
    the next subsection.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Podman使用的另一个重要架构组件是Conmon，一个用于监控容器运行时状态的工具。让我们在下一小节中更详细地探讨这个问题。
- en: Conmon
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Conmon
- en: We may still have some questions about runtime execution.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能仍然有一些关于运行时执行的问题。
- en: How do Podman (the container engine) and `runC`/`crun` (the OCI container runtime)
    interact with each other? Which is responsible for launching the container runtime
    process? Is there a way to monitor the container execution?
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Podman（容器引擎）和`runC`/`crun`（OCI容器运行时）是如何互相交互的？哪一个负责启动容器运行时进程？有没有方法可以监控容器的执行？
- en: Let’s introduce the Conmon project ([https://github.com/containers/conmon](https://github.com/containers/conmon)).
    Conmon is a monitoring and communication tool that sits between the container
    engine and the runtime.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们介绍一下Conmon项目（[https://github.com/containers/conmon](https://github.com/containers/conmon)）。Conmon是一个监控和通信工具，位于容器引擎和运行时之间。
- en: Every time a new container is created, a new instance of Conmon is launched.
    It detaches from the container manager process and runs daemonized, launching
    the container runtime as a child process.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建新容器时，都会启动一个新的Conmon实例。它会从容器管理进程中分离出来，并以守护进程方式运行，启动容器运行时作为子进程。
- en: 'If we attach a tracing tool to a Podman container, we can see in the following
    the order it’s written in:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们附加一个追踪工具到Podman容器，我们可以看到它以以下顺序写入：
- en: The container engine runs the Conmon process, which detaches and daemonizes
    itself.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器引擎运行Conmon进程，Conmon进程会分离并以守护进程方式运行。
- en: The Conmon process runs a container runtime instance that starts the container
    and exits.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Conmon进程运行一个容器运行时实例，启动容器并退出。
- en: The Conmon process continues to run to provide a monitoring interface, while
    the manager/engine process has exited or detached.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Conmon进程继续运行，以提供监控接口，而管理器/引擎进程则已退出或分离。
- en: 'The following diagram shows the logical workflow, from Podman execution to
    the running container:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了从Podman执行到运行容器的逻辑工作流：
- en: '![Figure 2.5 – Running a Podman container'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5 – 运行Podman容器'
- en: '](img/B17908_02_05.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17908_02_05.jpg)'
- en: Figure 2.5 – Running a Podman container
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 运行Podman容器
- en: On a system with many running containers, users will find many instances of
    the Conmon process, one for every container created. In other words, Conmon acts
    as a small, dedicated daemon to the container.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行多个容器的系统上，用户会发现有许多Conmon进程实例，每个容器都有一个。换句话说，Conmon充当容器的一个小型专用守护进程。
- en: 'Let’s look at the following example, where a simple shell loop is used to create
    three identical nginx containers:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的示例，其中使用简单的shell循环创建三个相同的nginx容器：
- en: '[PRE10]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After running the containers, a simple regular expression pattern applied to
    the output of the `ps aux` command shows three Conmon process instances.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行容器后，对`ps aux`命令输出应用一个简单的正则表达式模式，可以看到三个Conmon进程实例。
- en: Even if Podman is not running anymore (since there is no daemon), it is still
    possible to connect to the Conmon process and attach to the container. At the
    same time, Conmon exposes console sockets and container logs to log files or the
    systemd journal.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 即使Podman不再运行（因为没有守护进程），仍然可以连接到Conmon进程并附加到容器。同时，Conmon会将控制台套接字和容器日志暴露到日志文件或systemd日志中。
- en: Conmon is a lightweight project written in C. It also provides Go language bindings
    to pass config structures between the manager and the runtime.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Conmon是一个用C语言编写的轻量级项目。它还提供了Go语言绑定，用于在管理器和运行时之间传递配置结构。
- en: Rootless containers
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无根容器
- en: One of the most interesting features of Podman is the capability to run rootless
    containers, which means that users without elevated privileges can run their own
    containers.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Podman最有趣的特点之一是能够运行无根容器，这意味着没有提升权限的用户也可以运行自己的容器。
- en: 'Rootless containers provide better security isolation and let different users
    run their own container instances independently and, thanks to **fork/exec**,
    a daemonless approach adopted by Podman, rootless containers are amazingly easy
    to manage. A rootless container is simply run by the standard user with the usual
    commands and arguments, as in the following example:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 无根容器提供更好的安全隔离，并允许不同用户独立运行自己的容器实例。得益于**fork/exec**，Podman采用无守护进程的方法，使得无根容器的管理变得非常简单。无根容器只需通过标准用户使用常规命令和参数运行，如以下示例所示：
- en: '[PRE11]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When this command is issued, Podman creates a new user namespace and maps UIDs
    between the two namespaces using a `man user_namespaces`). This method allows
    you to have, for example, a root user inside the container mapped to an ordinary
    user in the host.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当发出此命令时，Podman创建一个新的用户命名空间，并使用`man user_namespaces`在两个命名空间之间映射UID。此方法允许您例如在容器内拥有一个root用户，并将其映射为主机中的普通用户。
- en: Rootless containers and image data are stored under the user home directory,
    usually under `$HOME/.local/share/containers/storage`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 无根容器和镜像数据存储在用户的主目录下，通常在`$HOME/.local/share/containers/storage`下。
- en: Podman manages network connectivity for rootless containers in a different way
    than rootful containers. An in-depth technical comparison between rootless and
    rootful containers, especially from the network and security point of view, will
    be covered later in this book.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Podman以不同于有根容器的方式管理无根容器的网络连接。关于无根容器和有根容器的深入技术比较，特别是从网络和安全的角度来看，将在本书后续章节中介绍。
- en: After an in-depth analysis of the runtime workflow, it is useful to provide
    an overview of the OCI image specs used by Podman.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在对运行时工作流进行深入分析之后，提供一个关于Podman使用的OCI镜像规格的概述是非常有用的。
- en: OCI images
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OCI镜像
- en: 'Podman and the container/image package implement the **OCI Image Format Specification**.
    The full specification is available on GitHub at the following link and pairs
    with the OCI runtime specification: [https://github.com/opencontainers/image-spec](https://github.com/opencontainers/image-spec).'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Podman和容器/镜像包实现了**OCI镜像格式规范**。完整的规范可在GitHub上通过以下链接查看，并与OCI运行时规范配套使用：[https://github.com/opencontainers/image-spec](https://github.com/opencontainers/image-spec)。
- en: 'An OCI image is made of the following elements:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一个OCI镜像由以下元素组成：
- en: Manifest
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清单
- en: An image index (optional)
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个镜像索引（可选）
- en: An image layout
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 镜像布局
- en: A filesystem layer changeset archive that will be unpacked to create a final
    filesystem
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个文件系统层变更集归档，将被解压以创建最终的文件系统
- en: An image configuration document to define layer ordering, as well as application
    arguments and environments
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个镜像配置文档，用于定义层次顺序，以及应用程序参数和环境
- en: Let’s see in detail what kinds of information and data are managed by the most
    relevant of the preceding elements.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解前面提到的最相关的元素管理的信息和数据种类。
- en: Manifest
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清单
- en: An image manifest specification should provide content-addressable images. The
    image manifest contains image layers and configurations for a specific architecture
    and operating system, such as Linux x86_64.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像清单规格应提供内容可寻址的镜像。镜像清单包含特定架构和操作系统（例如Linux x86_64）的镜像层和配置。
- en: 'Specification: [https://github.com/opencontainers/image-spec/blob/main/manifest.md](https://github.com/opencontainers/image-spec/blob/main/manifest.md)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 规范：[https://github.com/opencontainers/image-spec/blob/main/manifest.md](https://github.com/opencontainers/image-spec/blob/main/manifest.md)
- en: Image index
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 镜像索引
- en: An image index is an object that contains a list of manifests related to different
    architectures (for example, amd64, arm64, or 386) and operating systems, along
    with custom annotations.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像索引是一个包含与不同架构（例如amd64、arm64或386）和操作系统相关的镜像清单列表的对象，并附带自定义注释。
- en: 'Specification: [https://github.com/opencontainers/image-spec/blob/main/image-index.md](https://github.com/opencontainers/image-spec/blob/main/image-index.md)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 规范：[https://github.com/opencontainers/image-spec/blob/main/image-index.md](https://github.com/opencontainers/image-spec/blob/main/image-index.md)
- en: Image layout
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 镜像布局
- en: The OCI image layout represents the directory structure of image blobs. The
    image layout also provides the necessary manifest location references as well
    as image index (in JSON format) and the image configuration. The image `index.json`
    contains the reference to the image manifest, stored as a blob in the OCI image
    bundle.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: OCI镜像布局表示镜像块的目录结构。镜像布局还提供必要的清单位置引用，以及镜像索引（JSON格式）和镜像配置。镜像的`index.json`包含指向镜像清单的引用，该清单作为块存储在OCI镜像包中。
- en: 'Specification: [https://github.com/opencontainers/image-spec/blob/main/image-layout.md](https://github.com/opencontainers/image-spec/blob/main/image-layout.md)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 规范： [https://github.com/opencontainers/image-spec/blob/main/image-layout.md](https://github.com/opencontainers/image-spec/blob/main/image-layout.md)
- en: Filesystem layers
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件系统层
- en: Inside an image, one or more layers are applied on top of each other to create
    a filesystem that the container can use.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在镜像内部，一个或多个层叠加在一起，创建一个容器可以使用的文件系统。
- en: At a low level, layers are packaged as TAR archives (with compression options
    with gzip and zstd). The filesystem layer implements the logic of layers stacking
    and how the changeset layers (layers containing file changes) are applied.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在低层次上，层被打包为TAR档案（具有gzip和zstd的压缩选项）。文件系统层实现了层叠的逻辑以及如何应用更改集层（包含文件更改的层）。
- en: As described in the previous chapter, a copy-on-write or union filesystem has
    become a standard to manage stacking in a graph-like approach. To manage layers
    stacking, Podman uses **overlayfs** by default as a graph driver.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，写时复制（copy-on-write）或联合文件系统已成为管理图形方式叠加的标准。为了管理层叠，Podman默认使用**overlayfs**作为图形驱动程序。
- en: 'Specification: [https://github.com/opencontainers/image-spec/blob/main/layer.md](https://github.com/opencontainers/image-spec/blob/main/layer.md)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 规范： [https://github.com/opencontainers/image-spec/blob/main/layer.md](https://github.com/opencontainers/image-spec/blob/main/layer.md)
- en: Image configuration
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 镜像配置
- en: An image configuration defines the image layer composition and the corresponding
    execution parameters such as entry points, volumes, execution arguments, or environment
    variables, as well as additional image metadata.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像配置定义了镜像层的组成及相应的执行参数，例如入口点、卷、执行参数或环境变量，以及附加的镜像元数据。
- en: The image JSON holding the configurations is an **immutable** object; changing
    it means creating a new derived image.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 持有配置的镜像JSON是一个**不可变**的对象；更改它意味着创建一个新的衍生镜像。
- en: 'Specification: [https://github.com/opencontainers/image-spec/blob/main/config.md](https://github.com/opencontainers/image-spec/blob/main/config.md)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 规范： [https://github.com/opencontainers/image-spec/blob/main/config.md](https://github.com/opencontainers/image-spec/blob/main/config.md)
- en: 'The following diagram represents an OCI image implementation, composed of image
    layer(s), image index, and image configuration:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示表示了OCI镜像的实现，包含镜像层、镜像索引和镜像配置：
- en: '![Figure 2.6 – OCI image implementation'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6 – OCI镜像实现'
- en: '](img/B17908_02_06.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17908_02_06.jpg)'
- en: Figure 2.6 – OCI image implementation
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – OCI镜像实现
- en: 'Let’s inspect a realistic example from a basic, lightweight **alpine** image:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一个来自基础、轻量级**alpine**镜像的实际示例：
- en: '[PRE12]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The directory layout contains an `index.json` file, with the following content:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 目录布局包含一个`index.json`文件，内容如下：
- en: '[PRE13]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The index contains a manifests array with only one item inside. The object
    digest is a SHA256 and corresponds to filename as one of the blobs listed previously.
    The file is the image manifest and can be inspected:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 索引包含一个只包含一项的清单数组。对象摘要是SHA256，并且与前面列出的blob之一的文件名对应。该文件是镜像清单，可以进行检查：
- en: '[PRE14]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The manifest contains references to the image configuration and layers. In this
    particular case, the image has only one layer. Again, their digests correspond
    to the blob filenames listed before.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 清单包含对镜像配置和镜像层的引用。在这个特定的案例中，镜像只有一个层。同样，它们的摘要与前面列出的blob文件名相对应。
- en: 'The config file shows image metadata, environment variables, and command execution.
    At the same time, it contains `DiffID` references to the layers used by the image
    and image creation information:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件显示了镜像元数据、环境变量和命令执行。同时，它包含对镜像使用的层和镜像创建信息的`DiffID`引用：
- en: '[PRE15]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The image layer is the third blob file. This is a TAR archive that could be
    exploded and inspected. For space reasons, in this book the example is limited
    to an inspection of the file type:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像层是第三个blob文件。这是一个TAR档案，可以展开并进行检查。出于空间原因，本书中的示例仅限于检查文件类型：
- en: '[PRE16]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The result demonstrates that the file is a TAR gzipped archive.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明该文件是一个TAR gz压缩档案。
- en: The main differences between Docker and Podman
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker和Podman之间的主要区别
- en: In the previous sections, we went through the key features of Docker and Podman,
    looking into the underlying layer, discovering the companion open source projects
    that made these two tools unique in their container engine role, but now it’s
    time to compare them.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经讨论了Docker和Podman的关键特性，深入探讨了底层结构，发现了使这两种工具在容器引擎角色中独特的开源项目，但现在是时候进行对比了。
- en: As we saw earlier, the significant difference between the two is that Docker
    has a daemon-centric approach while Podman instead has a daemonless architecture.
    The Podman binary acts as CLI as well as a container engine and uses Conmon to
    orchestrate and monitor the container runtime.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，两者之间的显著区别在于，Docker 采用的是以守护进程为中心的方法，而 Podman 则采用无守护进程架构。Podman 的二进制文件既是
    CLI 也是容器引擎，并使用 Conmon 来协调和监控容器运行时。
- en: 'Looking under the hood into the internals of both projects, we will also find
    many other differences but, in the end, once the container has started, they both
    leverage OCI standard container runtimes but with some differences: Docker uses
    `runc` while Podman uses `crun` in most distributions, with some exceptions; for
    example, it still uses `runc` in the most conservative Red Hat Enterprise Linux
    8 with `crun` as an option.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解两个项目的内部机制，我们还会发现许多其他的差异，但最终，一旦容器启动，它们都利用了 OCI 标准的容器运行时，只是存在一些差异：Docker 使用
    `runc`，而 Podman 在大多数发行版中使用 `crun`，但也有一些例外；例如，在最为保守的 Red Hat Enterprise Linux 8
    中，它仍然使用 `runc`，并且将 `crun` 作为可选项。
- en: Despite the `crun` performance advantages described in the previous section,
    it is not the objective of this book to make a detailed performance comparison
    between the two. Anyway, readers interested in the topic will easily find literature
    about the performance differences between the two runtimes.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在前一部分中描述了 `crun` 在性能上的优势，但本书的目标并不是对这两者进行详细的性能比较。无论如何，读者如果对这个话题感兴趣，将很容易找到有关这两个运行时性能差异的文献。
- en: Another big gap that was recently filled by the Docker team was the rootless
    container. Podman was the first container engine to bring out this excellent feature
    that increases security and improve the usage of containers in many contexts but,
    as we mentioned, this feature is now available in Docker too.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 最近由 Docker 团队填补的另一个大空白是无根容器（rootless container）。Podman 是第一个推出这一出色功能的容器引擎，它增强了安全性并改善了容器在多个环境中的使用，但正如我们所提到的，这个功能现在也已经在
    Docker 中可用。
- en: But let’s go more practical in the next sections, by comparing them side by
    side through the command line first and then by running a container.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在接下来的部分中，我们将更实际地进行比较，首先通过命令行并排比较，然后运行一个容器。
- en: Command-line interface comparison
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令行接口比较
- en: In this section, we will go through a side-by-side comparison looking at the
    Docker and Podman CLIs.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将进行一个并排比较，看看 Docker 和 Podman 的命令行接口。
- en: 'Looking at the available commands for both CLIs, it is easy to spot the many
    similarities. The following table was truncated to improve readability:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 查看两个命令行接口（CLI）提供的命令，很容易就能发现它们之间的许多相似之处。为了提高可读性，下面的表格被截断了：
- en: '![Table 2.1 – Comparison of Docker and Podman commands'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 2.1 – Docker 和 Podman 命令比较'
- en: '](img/Table_2.1.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Table_2.1.jpg)'
- en: Table 2.1 – Comparison of Docker and Podman commands
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1 – Docker 和 Podman 命令比较
- en: 'As we stated many times in the preceding section, as well as in the previous
    chapter, Docker was born in 2013 while Podman only arrived 4 years later in 2017\.
    Podman was built keeping in mind how experienced container administrators were
    with the most famous container engine available at that time: Docker. For this
    reason, the Podman development team decided to not change too much the *look and
    feel* of the command-line tools for improving Docker users’ migration to the new-born
    Podman.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的部分以及上一章中多次提到的，Docker 于 2013 年诞生，而 Podman 则是在 2017 年才出现。Podman 的开发是在考虑到当时最著名的容器引擎
    Docker 的基础上进行的。出于这个原因，Podman 开发团队决定尽量不改变命令行工具的*外观和感觉*，以帮助 Docker 用户顺利迁移到新生的 Podman。
- en: There was a claim, in fact, at the beginning of the distribution of Podman that
    if you have any existing scripts that run Docker you can create an alias and it
    should work (`alias docker=podman`). It was also created a package that places
    a *fake* Docker command under `/usr/bin` that points to *Podman* binary instead.
    For this reason, if you are a Docker user, you can expect a smooth transition
    to Podman once you are ready.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在 Podman 发布初期曾有人声称，如果你有任何现有的运行 Docker 的脚本，你可以创建一个别名，它应该能正常工作（`alias docker=podman`）。同时还创建了一个包，在
    `/usr/bin` 下放置一个*伪* Docker 命令，它指向的是 Podman 的二进制文件。因此，如果你是 Docker 用户，一旦准备好转向 Podman，你可以期待一个平稳的过渡。
- en: Another important point is that the images created with Docker are compatible
    with the OCI standard, so you can easily migrate or pull again any image you previously
    used with Docker.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的点是，通过 Docker 创建的镜像与 OCI 标准兼容，因此你可以轻松迁移或重新拉取你之前使用过的任何 Docker 镜像。
- en: If we take a deep look into the command options available for Podman, you will
    notice that there are some additional commands that are not present in Docker,
    while some others are missing.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们深入查看 Podman 可用的命令选项，你会注意到一些额外的命令在 Docker 中并不存在，而其他一些命令则缺失。
- en: For example, Podman can manage, along with containers, **pods** (the name Podman
    is quite telling here). The pod concept was introduced with Kubernetes and represents
    the smallest execution unit in a Kubernetes cluster.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Podman 可以管理 **Pod**（Podman 这个名字在这里非常具有提示性）。Pod 概念最初是在 Kubernetes 中引入的，表示
    Kubernetes 集群中最小的执行单元。
- en: 'With Podman, users can create empty pods and then run containers inside them
    easily using the following command:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Podman，用户可以轻松创建空的 Pod，然后使用以下命令在其中运行容器：
- en: '[PRE17]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is not as easy with Docker, where users must first run a container and
    then create new ones attaching to the network namespace of the first container.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 中，这并不像 Podman 那样容易，在 Docker 中，用户必须首先运行一个容器，然后创建新的容器并连接到第一个容器的网络命名空间。
- en: Podman has additional features that could help users to move their containers
    in Kubernetes environments. Using the command `podman generate kube`, Podman can
    create a Kubernetes YAML file for a running container that can be used to create
    a pod inside a Kubernetes cluster.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 还具有一些额外功能，可以帮助用户将容器迁移到 Kubernetes 环境中。通过命令 `podman generate kube`，Podman
    可以为正在运行的容器创建一个 Kubernetes YAML 文件，该文件可用于在 Kubernetes 集群中创建一个 Pod。
- en: Running containers as systemd services is equally easy with the `podman generate
    systemd` command, which takes a running container or pod and generates a systemd
    unit file that can be used to automatically run services at system startup.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `podman generate systemd` 命令将容器作为 systemd 服务运行同样简单，该命令会获取一个正在运行的容器或 Pod，并生成一个
    systemd 单元文件，用于在系统启动时自动运行服务。
- en: 'A notable example: the **OpenStack** project, an open source cloud computing
    infrastructure, adopted Podman as the default manager for its containerized services
    when deployed with TripleO. All the services are executed by Podman and orchestrated
    by systemd in the control plane and compute nodes.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显著的例子：**OpenStack** 项目，一个开源云计算基础设施，在与 TripleO 部署时，将 Podman 作为其容器化服务的默认管理器。所有服务都由
    Podman 执行，并由 systemd 在控制平面和计算节点中进行编排。
- en: Having checked the surface of these container engines and having looked at their
    command lines, let’s recap the under-the-hood differences in the next section.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查了这些容器引擎的表面并查看了它们的命令行之后，让我们在下一节回顾一下它们在幕后的差异。
- en: Running a container
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行容器
- en: 'Running a container in a Docker environment, as we mentioned earlier, consists
    of using the Docker command-line client to communicate with the Docker daemon
    that will do the actions required to get the container up and running. Just to
    summarize the concepts we explained in this chapter, we can take a look the following
    diagram:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在 Docker 环境中运行容器，包含使用 Docker 命令行客户端与 Docker 守护进程进行通信，守护进程将执行所需的操作以启动容器。为了总结本章解释的概念，我们可以查看以下图示：
- en: '![Figure 2.7 – Docker simplified architecture'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.7 – Docker 简化架构'
- en: '](img/B17908_02_07.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17908_02_07.jpg)'
- en: Figure 2.7 – Docker simplified architecture
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – Docker 简化架构
- en: 'Podman, instead, interacts directly with the image registry, storage, and with
    the Linux kernel through the container runtime process (not a daemon), with Conmon
    as a monitoring process executed between Podman and the OCI runtime, as we can
    schematize in the following diagram:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，Podman 直接与镜像注册表、存储以及通过容器运行时进程（不是守护进程）与 Linux 内核进行交互，Conmon 作为一个监控进程在 Podman
    和 OCI 运行时之间执行，以下图示可以简要说明：
- en: '![Figure 2.8 – Podman simplified architecture'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.8 – Podman 简化架构'
- en: '](img/B17908_02_08.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17908_02_08.jpg)'
- en: Figure 2.8 – Podman simplified architecture
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – Podman 简化架构
- en: The core difference between the two architectures is the daemon-centric Docker
    vision versus the fork/exec approach of Podman.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种架构之间的核心区别是以守护进程为中心的 Docker 视角与 Podman 的 fork/exec 方法。
- en: 'This book does not get into the pros and cons of the Docker daemon architecture
    and features. Anyway, we safely can tell that a significant number of Docker users
    were concerned about this daemon-centric approach for many reasons, for example:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 本书并不深入讨论 Docker 守护进程架构和功能的优缺点。无论如何，我们可以肯定地说，许多 Docker 用户对于这种以守护进程为中心的方式存在许多担忧，原因有很多，例如：
- en: The daemon could be a single point of failure.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 守护进程可能是单点故障。
- en: If for some reason a failure occurs, then there will be orphaned processes.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果发生故障，可能会出现孤立的进程。
- en: The daemon owns all the running containers as child processes.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 守护进程拥有所有正在运行的容器，并将它们视为子进程。
- en: 'Despite the architectural differences, and the aliasing solutions described
    before to easily migrate projects without changing any script, running a container
    from the command line with Docker or Podman is pretty much the same thing for
    the end user:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在架构上的差异，以及前文提到的别名解决方案，可以轻松迁移项目而无需更改任何脚本，但无论是用 Docker 还是 Podman 从命令行运行容器，对最终用户来说几乎是一样的体验：
- en: '[PRE18]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For the same reason, most of the command-line arguments of CLI commands have
    been kept as close as possible to the original version in Docker.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 基于相同的原因，大多数命令行参数都尽量保持与 Docker 中原版本一致。
- en: Summary
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have discussed the main differences between Podman and Docker,
    both from architectural and usage points of view. We described the main building
    blocks of the two container engines and highlighted the different community projects
    that fuel the Podman project, especially OCI specifications and the `runC` and
    `crun` runtimes.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 Podman 和 Docker 之间的主要差异，既从架构角度，也从使用角度。我们描述了这两个容器引擎的主要构建模块，并突出了推动
    Podman 项目的不同社区项目，特别是 OCI 规范以及 `runC` 和 `crun` 运行时。
- en: The purpose of this book is not to debate why and how Podman could be a better
    choice than Docker. We think that everybody who works with containers should be
    extremely grateful to the Docker company and community for the great work they
    did in bringing containers to the masses and freeing them from niche adoption.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目的是探讨 Podman 是否比 Docker 更好的选择，而不是进行辩论。我们认为，所有使用容器的人都应当对 Docker 公司和社区所做的巨大贡献心存感激，正是他们将容器普及并从小众应用中解放出来。
- en: At the same time, the evolutionary approach of open source software facilitates
    the birth of new projects that try to compete to be adopted. Ever since it was
    born, the Podman project has grown exponentially and gained a wider user base
    day by day.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，开源软件的演化方式促进了新项目的诞生，这些项目力图竞争并被采纳。从它诞生之日起，Podman 项目便呈指数级增长，并且日益获得更广泛的用户基础。
- en: Understanding the engine internals is still an important task, anyway. For troubleshooting,
    performance tuning, or even just curiosity, investing time in understanding how
    each component relates to each other, reading the code, and testing builds is
    a smart choice that will pay back someday.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，理解引擎的内部结构仍然是一个重要任务。无论是为了故障排除、性能调优，还是仅仅出于好奇，投入时间去理解每个组件之间的关系，阅读代码并测试构建，是一个值得的选择，迟早会带来回报。
- en: In the next chapters, we will uncover in detail the features and behavior of
    this great container engine.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将详细揭示这个优秀容器引擎的特点和行为。
- en: Further reading
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information about the topics covered in this chapter, you can refer
    to the following:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 若想了解本章涉及的更多主题，您可以参考以下内容：
- en: '[https://developers.redhat.com/blog/2020/09/25/rootless-containers-with-podman-the-basics](https://developers.redhat.com/blog/2020/09/25/rootless-containers-with-podman-the-basics)'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developers.redhat.com/blog/2020/09/25/rootless-containers-with-podman-the-basics](https://developers.redhat.com/blog/2020/09/25/rootless-containers-with-podman-the-basics)'
- en: '[https://developers.redhat.com/blog/2020/11/19/transitioning-from-docker-to-podman](https://developers.redhat.com/blog/2020/11/19/transitioning-from-docker-to-podman)'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developers.redhat.com/blog/2020/11/19/transitioning-from-docker-to-podman](https://developers.redhat.com/blog/2020/11/19/transitioning-from-docker-to-podman)'
- en: '[https://github.com/opencontainers/runc/blob/master/docs/cgroup-v2.md](https://github.com/opencontainers/runc/blob/master/docs/cgroup-v2.md)'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/opencontainers/runc/blob/master/docs/cgroup-v2.md](https://github.com/opencontainers/runc/blob/master/docs/cgroup-v2.md)'
- en: '[https://www.redhat.com/sysadmin/introduction-crun](https://www.redhat.com/sysadmin/introduction-crun)'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.redhat.com/sysadmin/introduction-crun](https://www.redhat.com/sysadmin/introduction-crun)'
- en: '[https://ebpf.io/what-is-ebpf/](https://ebpf.io/what-is-ebpf/)'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://ebpf.io/what-is-ebpf/](https://ebpf.io/what-is-ebpf/)'
