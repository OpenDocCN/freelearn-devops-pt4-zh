- en: '*Chapter 3*: Running the First Container'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 3 章*：运行第一个容器'
- en: In the previous chapters, we discussed the history of containers, their adoption,
    and the various technologies that contribute to their spread, while also looking
    at the main differences between **Docker** and **Podman**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们讨论了容器的历史、其采用情况以及促使其传播的各种技术，同时也看到了 **Docker** 和 **Podman** 之间的主要区别。
- en: 'Now, it’s time to start working with real examples: in this chapter, we will
    learn about how to get Podman up and running on your preferred Linux operating
    system so that we can start our first container. We will discover the various
    installation methods, all the prerequisites, and then start a container.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，到了开始使用真实示例的时候：在本章中，我们将学习如何在你首选的 Linux 操作系统上安装并运行 Podman，以便我们可以启动我们的第一个容器。我们将了解各种安装方法，所有的先决条件，然后启动一个容器。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主要主题：
- en: Choosing an operating system and installation method
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择操作系统和安装方法
- en: Preparing your environment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备环境
- en: Running your first container
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行第一个容器
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Having good technical experience in administering a Linux operating system would
    be preferable for understanding the key concepts provided in this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有良好的 Linux 操作系统管理经验将有助于理解本章提供的关键概念。
- en: We will go through the main steps of installing new software on various Linux
    distributions, so having some experience as a Linux sysadmin could be helpful
    in troubleshooting possible issues during installation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍在各种 Linux 发行版上安装新软件的主要步骤，因此，作为一名 Linux 系统管理员拥有一定经验，在解决安装过程中可能出现的问题时会有所帮助。
- en: In addition, some of the theoretical concepts that were explained in the previous
    chapters could help you understand the procedures described in this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，前几章中解释的一些理论概念有助于你理解本章描述的过程。
- en: Choosing an operating system and installation method
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择操作系统和安装方法
- en: Podman is supported on different distributions and operating systems. It is
    very easy to install, and the various distributions now provide their own maintained
    packages that can be installed with their specific package managers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 在不同的发行版和操作系统中得到支持。它非常容易安装，并且各个发行版现在提供了自己维护的安装包，可以通过它们各自的包管理器进行安装。
- en: In this section, we will cover the different installation steps for the most
    common GNU/Linux distributions, as well as on macOS and Windows, despite the focus
    of this book being on Linux-based environments.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍最常见的 GNU/Linux 发行版的不同安装步骤，以及在 macOS 和 Windows 上的安装步骤，尽管本书的重点是 Linux
    环境。
- en: As a bonus topic, we will also learn how to build Podman directly from source.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为附加话题，我们还将学习如何从源代码直接构建 Podman。
- en: Choosing between Linux distributions and another OS
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Linux 发行版和其他操作系统之间的选择
- en: The choice between the different distributions of the GNU/Linux operating system
    is something that is dictated by the user’s preferences and needs, which are usually
    influenced by several factors that are outside the scope of this book.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的 GNU/Linux 发行版之间的选择是由用户的偏好和需求决定的，这些偏好和需求通常受到本书范围外的几个因素的影响。
- en: Many advanced users today choose Linux distributions as their main operating
    systems. However, there is a large quota, especially among developers, who stick
    to macOS as their standard operating system. Microsoft Windows still retains the
    largest market share on desktop workstations and laptops.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，许多高级用户选择 Linux 发行版作为他们的主要操作系统。然而，尤其在开发者中，仍然有一大部分人坚持将 macOS 作为标准操作系统。微软的 Windows
    仍然在桌面工作站和笔记本电脑中占据着最大的市场份额。
- en: Today, we have a huge ecosystem of Linux distributions that have evolved from
    a smaller subset of core, historical distributions such as Debian, Fedora, Red
    Hat Enterprise Linux, Gentoo, Arch, and openSUSE. Specialized websites such as
    **DistroWatch** ([https://distrowatch.com](https://distrowatch.com)) keep track
    of the many releases of Linux and BSD-based distributions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，我们拥有一个庞大的 Linux 发行版生态系统，这些发行版从 Debian、Fedora、Red Hat 企业版 Linux、Gentoo、Arch
    和 openSUSE 等少数核心历史发行版中发展而来。像 **DistroWatch** 这样的专业网站（[https://distrowatch.com](https://distrowatch.com)）追踪着
    Linux 和 BSD 发行版的众多版本。
- en: Despite running a Linux kernel, the various distributions have different architectural
    approaches for userspace behavior, such as filesystem structure, libraries, or
    packaging systems used to deliver software releases.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管运行的是Linux内核，不同的发行版在用户空间行为的架构方法上存在差异，例如文件系统结构、库或用于交付软件发布的打包系统。
- en: 'Another significant difference is related to security and mandatory access
    control subsystems: for example, Fedora, CentOS, Red Hat Enterprise Linux, and
    all the derivates lean on **SELinux** as their mandatory access control subsystem.
    On the other hand, Debian, Ubuntu, and their derivates are based on a similar
    solution called **AppArmor**.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个显著的区别与安全性和强制访问控制子系统有关：例如，Fedora、CentOS、Red Hat Enterprise Linux及其所有衍生版依赖于**SELinux**作为其强制访问控制子系统。另一方面，Debian、Ubuntu及其衍生版则基于类似的解决方案——**AppArmor**。
- en: Podman interacts with both SELinux and AppArmor to provide better container
    isolation, but the underlying interfaces are different.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Podman与SELinux和AppArmor交互，以提供更好的容器隔离，但其底层接口是不同的。
- en: Important Note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: All this book’s examples and source code has been written and tested using **Fedora
    Workstation 34** as the reference OS.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有示例和源代码均使用**Fedora Workstation 34**作为参考操作系统编写和测试。
- en: 'Those of you who want to reproduce an environment as close as possible to the
    book in their lab have different options:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 那些希望在实验室中尽可能复现本书环境的读者有不同的选择：
- en: Use the Fedora 34 Vagrant Box ([https://app.vagrantup.com/fedora/boxes/34-cloud-base](https://app.vagrantup.com/fedora/boxes/34-cloud-base)).
    **Vagrant** is a software solution developed by **Hashicorp** to create fast,
    lightweight VMs, especially suitable for development use. See [https://www.vagrantup.com/](https://www.vagrantup.com/)
    for further details about Vagrant and how to use it on your operating system of
    choice.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Fedora 34 Vagrant Box ([https://app.vagrantup.com/fedora/boxes/34-cloud-base](https://app.vagrantup.com/fedora/boxes/34-cloud-base))。**Vagrant**是由**Hashicorp**开发的软件解决方案，用于创建快速、轻量级的虚拟机，特别适用于开发使用。有关Vagrant及如何在你选择的操作系统上使用它的详细信息，请参阅[https://www.vagrantup.com/](https://www.vagrantup.com/)。
- en: Directly download the cloud image ([https://alt.fedoraproject.org/cloud/](https://alt.fedoraproject.org/cloud/))
    and create instances on the public/private cloud or just deploy it on a hypervisor
    of your choice.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接下载云镜像([https://alt.fedoraproject.org/cloud/](https://alt.fedoraproject.org/cloud/))，并在公共/私人云上创建实例，或者直接在你选择的虚拟化平台上部署它。
- en: Manually install Fedora Workstation. In this case, the official installation
    guide ([https://docs.fedoraproject.org/en-US/fedora/f34/install-guide/](https://docs.fedoraproject.org/en-US/fedora/f34/install-guide/))
    provides detailed instructions on deploying the OS.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动安装Fedora Workstation。在这种情况下，官方安装指南([https://docs.fedoraproject.org/en-US/fedora/f34/install-guide/](https://docs.fedoraproject.org/en-US/fedora/f34/install-guide/))提供了关于部署操作系统的详细说明。
- en: Running instances on public clouds is the best option for users who are not
    able to run virtual machines locally.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在公共云上运行实例是无法在本地运行虚拟机的用户的最佳选择。
- en: Providers such as Amazon Web Services, Google Cloud Platform, Microsoft Azure,
    and DigitalOcean also offer ready-to-use Fedora-based cloud instances with low
    monthly prices for smaller sizes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 提供商如Amazon Web Services、Google Cloud Platform、Microsoft Azure和DigitalOcean也提供基于Fedora的即用云实例，且小型实例的月租价格非常低。
- en: Prices can vary in time and across tiers and keeping track of them is beyond
    the purpose of this book. Almost all providers offer free plans for learning or
    basic use, with small/micro tiers at very low prices.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 价格可能随着时间和不同等级而变化，跟踪这些变化超出了本书的范围。几乎所有提供商都提供免费的学习或基础使用计划，且小型/微型套餐的价格非常低。
- en: Containers are Linux-based, and the different container engines and runtimes
    interact with the Linux kernel and libraries to operate. Windows has recently
    introduced support for native containers with an approach to isolation that’s
    quite close to the Linux namespace concepts described previously. However, only
    Windows-based images can run natively and not all container engines support native
    execution.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是基于Linux的，不同的容器引擎和运行时与Linux内核和库交互以运行。Windows最近引入了对本地容器的支持，其隔离方法与前面描述的Linux命名空间概念非常相似。然而，仅支持Windows基础镜像的本地运行，并不是所有容器引擎都支持本地执行。
- en: 'The same considerations are valid for macOS: its architecture is not based
    on Linux but on a hybrid Mach/BSD kernel called **XNU**. For this reason, it does
    not offer the Linux kernel features necessary to run containers natively.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对 macOS 来说，同样的考虑事项也适用：它的架构并非基于 Linux，而是基于一种名为 **XNU** 的混合 Mach/BSD 内核。因此，它不提供运行容器所需的
    Linux 内核特性。
- en: For both Windows and macOS, a virtualization layer that abstracts the Linux
    machine is necessary to run native Linux containers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 和 macOS，都需要一个虚拟化层来抽象出 Linux 机器，以运行本地 Linux 容器。
- en: Podman offers remote client functions for Windows and macOS, enabling users
    to connect to a local or remote Linux box.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 提供了适用于 Windows 和 macOS 的远程客户端功能，使用户能够连接到本地或远程的 Linux 主机。
- en: Windows users can also benefit from an alternative approach based on the **Windows
    Subsystem for Linux** (**WSL**) **2.0**, a compatibility layer that runs a lightweight
    VM to expose Linux kernel interfaces along with Linux userspace binaries, thanks
    to Hyper-V virtualization support.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 用户也可以受益于基于 **Windows Subsystem for Linux** (**WSL**) **2.0** 的替代方法，这是一种兼容层，通过
    Hyper-V 虚拟化支持运行轻量级虚拟机，以提供 Linux 内核接口和 Linux 用户空间二进制文件。
- en: The following sections will cover the necessary steps for installing Podman
    on the most popular Linux distributions, as well as macOS and Windows.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节将涵盖在最流行的 Linux 发行版、macOS 和 Windows 上安装 Podman 所需的步骤。
- en: Installing Podman on Fedora
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Fedora 上安装 Podman
- en: 'Fedora packages are maintained by its wide community and managed with the **DNF**
    package manager. To install Podman, run the following command from a terminal:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Fedora 包由其广泛的社区维护，并使用 **DNF** 包管理器进行管理。要安装 Podman，请在终端中运行以下命令：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command installs Podman and configures the environment with config files
    (covered in the next section). It also installs `systemd` units to provide additional
    features such as REST API services or container auto-updates.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令安装 Podman 并配置带有配置文件的环境（将在下一节中详细介绍）。它还安装了 `systemd` 单元，以提供额外的功能，如 REST API
    服务或容器自动更新。
- en: Installing Podman on CentOS
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 CentOS 上安装 Podman
- en: Podman can be installed on CentOS 7, CentOS 8, and CentOS Stream ([https://www.centos.org/](https://www.centos.org/)).
    Users installing on CentOS 7 must have the **Extras** repository enabled, while
    users installing on CentOS 8 and Stream must have the Podman package available
    from the already enabled **AppStream** repository.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 可以安装在 CentOS 7、CentOS 8 和 CentOS Stream 上 ([https://www.centos.org/](https://www.centos.org/))。在
    CentOS 7 上安装的用户必须启用 **Extras** 仓库，而在 CentOS 8 和 Stream 上安装的用户必须从已经启用的 **AppStream**
    仓库中获取 Podman 包。
- en: 'To install Podman, run the following command from a terminal:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Podman，请在终端中运行以下命令：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Like in Fedora, this command installs Podman and all its dependencies, including
    config files and `systemd` unit files.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Fedora 中一样，这个命令安装 Podman 及其所有依赖项，包括配置文件和 `systemd` 单元文件。
- en: Installing Podman on RHEL
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 RHEL 上安装 Podman
- en: To install Podman on **Red Hat Enterprise Linux** (**RHEL**) ([https://www.redhat.com/en/technologies/linux-platforms/enterprise-linux](https://www.redhat.com/en/technologies/linux-platforms/enterprise-linux)),
    users should follow two different procedures on RHEL 7 and RHEL 8.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 **Red Hat Enterprise Linux** (**RHEL**) ([https://www.redhat.com/en/technologies/linux-platforms/enterprise-linux](https://www.redhat.com/en/technologies/linux-platforms/enterprise-linux))
    上安装 Podman，用户应根据 RHEL 7 和 RHEL 8 执行不同的安装程序。
- en: 'On RHEL 7, users must enable the extra channel and then install the Podman
    package:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RHEL 7 上，用户必须启用额外的渠道，然后安装 Podman 包：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On RHEL 8, the Podman package is available on a dedicated module called **container-tools**.
    Modules are custom sets of RPM packages that can be organized in streams with
    independent release cycles:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RHEL 8 上，Podman 包可通过一个名为 **container-tools** 的专用模块获取。模块是可以通过独立发布周期组织的 RPM
    包的自定义集合：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `container-tools` module installs, along with Podman, two useful tools,
    both of which will be covered later in this book:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`container-tools` 模块安装了 Podman 和另外两个有用的工具，稍后在本书中会详细介绍：'
- en: '**Skopeo**, a tool for managing OCI images and registries'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Skopeo**，一个用于管理 OCI 镜像和注册表的工具'
- en: '**Buildah**, a specialized tool for building custom OCI images from Dockerfiles
    and from scratch'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Buildah**，一个用于从 Dockerfiles 或从零开始构建自定义 OCI 镜像的专业工具'
- en: (Not) Installing Podman on Fedora CoreOS and Fedora Silverblue
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: （不）在 Fedora CoreOS 和 Fedora Silverblue 上安装 Podman
- en: The title of this subsection is a bit of a joke. The reality is that Podman
    is already installed on both distributions and is a crucial tool for running containerized
    workloads.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节的标题有点开玩笑的成分。实际上，Podman 已经在这两个发行版上安装并成为运行容器化工作负载的关键工具。
- en: The **Fedora CoreOS** and **Fedora SilverBlue** distributions are immutable,
    atomic operating systems aimed to be used on server/cloud and desktop environments,
    respectively.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fedora CoreOS** 和 **Fedora SilverBlue** 发行版是不可变的、原子化的操作系统，分别旨在用于服务器/云和桌面环境。'
- en: Fedora CoreOS ([https://getfedora.org/en/coreos/](https://getfedora.org/en/coreos/))
    is the upstream of Red Hat CoreOS, the operating system used to run Red Hat OpenShift
    and the base OS of **OpenShift Kubernetes Distribution** (**OKD**), the community-based
    Kubernetes distribution used as the upstream of Red Hat OpenShift.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Fedora CoreOS ([https://getfedora.org/en/coreos/](https://getfedora.org/en/coreos/))
    是 Red Hat CoreOS 的上游版本，是运行 Red Hat OpenShift 和 **OpenShift Kubernetes Distribution**
    (**OKD**) 的操作系统，OKD 是用于构建 Red Hat OpenShift 的社区版本 Kubernetes 发行版。
- en: Fedora Silverblue ([https://silverblue.fedoraproject.org/](https://silverblue.fedoraproject.org/))
    is a desktop-focused immutable operating system that aims to provide a stable
    and comfortable desktop user experience, especially for developers working with
    containers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Fedora Silverblue ([https://silverblue.fedoraproject.org/](https://silverblue.fedoraproject.org/))
    是一个面向桌面的不可变操作系统，旨在提供稳定和舒适的桌面用户体验，特别是为从事容器开发的开发者提供支持。
- en: So, on both Fedora CoreOS and Fedora Silverblue, just open a terminal and run
    Podman.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 Fedora CoreOS 和 Fedora Silverblue 上，只需打开终端并运行 Podman。
- en: Installing Podman on Debian
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Debian 上安装 Podman
- en: The Podman package is available on **Debian** ([https://www.debian.org/](https://www.debian.org/))
    since version 11, codename Bullseye (named after the famous toy horse from the
    Toy Story 2 and 3 movies).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**Debian** ([https://www.debian.org/](https://www.debian.org/)) 自版本 11 起提供
    Podman，该版本的代号为 Bullseye（以《玩具总动员 2 和 3》中的著名玩具马命名）。'
- en: Debian uses the `apt-get` package handling utility to install and upgrade system
    packages.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Debian 使用 `apt-get` 包管理工具来安装和升级系统软件包。
- en: 'To install Podman on a Debian system, run the following command from the terminal:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Debian 系统上安装 Podman，请在终端中运行以下命令：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding command installs the Podman binary and its dependencies, along
    with its config files, `systemd` units, and man pages.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令安装了 Podman 二进制文件及其依赖项，以及其配置文件、`systemd` 单元和手册页。
- en: Installing Podman on Ubuntu
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Ubuntu 上安装 Podman
- en: 'Being built on Debian, **Ubuntu** ([https://ubuntu.com/](https://ubuntu.com/))
    behaves in an analogous way for package management. To install Podman on Ubuntu
    20.10 or later, run the following commands:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Debian 构建的 **Ubuntu** ([https://ubuntu.com/](https://ubuntu.com/)) 在软件包管理方面表现类似。要在
    Ubuntu 20.10 或更高版本上安装 Podman，请运行以下命令：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These two commands update the system packages and then install the Podman binaries
    and related dependencies.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令将更新系统软件包，然后安装 Podman 二进制文件及相关依赖项。
- en: Installing Podman on openSUSE
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 openSUSE 上安装 Podman
- en: 'The **openSUSE** distribution ([https://www.opensuse.org/](https://www.opensuse.org/))
    is backed by SUSE and is available in two different flavors – the rolling release
    known as **Tumbleweed,** and the LTS distribution known as **Leap**. Podman is
    available in the openSUSE repositories and can be installed with the following
    command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**openSUSE** 发行版 ([https://www.opensuse.org/](https://www.opensuse.org/)) 由
    SUSE 支持，并提供两种不同的版本——滚动发布的 **Tumbleweed** 和 LTS 版本的 **Leap**。Podman 可以通过 openSUSE
    仓库安装，使用以下命令：'
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Zypper package manager will download and install all the necessary packages
    and dependencies.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Zypper 包管理器将下载并安装所有必要的软件包和依赖项。
- en: Installing Podman on Gentoo
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Gentoo 上安装 Podman
- en: '**Gentoo** ([https://www.gentoo.org/](https://www.gentoo.org/)) is a clever
    distribution that is characterized by building installed packages directly on
    the target machine with the optional extra user customizations. To achieve this,
    it uses the **Portage** package manager, inspired by FreeBSD ports.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**Gentoo** ([https://www.gentoo.org/](https://www.gentoo.org/)) 是一个巧妙的发行版，其特点是直接在目标机器上构建已安装的软件包，并提供可选的用户自定义功能。为此，它使用
    **Portage** 包管理器，灵感来自 FreeBSD ports。'
- en: 'To install Podman on Gentoo, run the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Gentoo 上安装 Podman，请运行以下命令：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `emerge` utility will download and automatically build the Podman sources
    on the system.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`emerge` 工具将下载并自动在系统上构建 Podman 源代码。'
- en: Installing Podman on Arch Linux
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Arch Linux 上安装 Podman
- en: '**Arch Linux** ([https://archlinux.org/](https://archlinux.org/)) is a rolling
    Linux distribution that shines for being highly customizable. It uses the **pacman**
    package manager to install and update packages from official and users'' custom
    repositories.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**Arch Linux** ([https://archlinux.org/](https://archlinux.org/)) 是一个滚动更新的
    Linux 发行版，以高度可定制性而著称。它使用 **pacman** 包管理器从官方和用户自定义的仓库安装和更新软件包。'
- en: 'To install Podman on Arch Linux and derivate distributions, run the following
    command from the terminal:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Arch Linux 及其衍生发行版上安装 Podman，请在终端中运行以下命令：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'By default, Podman’s installation on Arch Linux does not permit rootless containers.
    To enable them, follow the official Arch wiki instructions: [https://wiki.archlinux.org/title/Podman#Rootless_Podman](https://wiki.archlinux.org/title/Podman#Rootless_Podman).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在 Arch Linux 上安装的 Podman 不支持无根容器。要启用该功能，请按照官方 Arch Wiki 指南操作：[https://wiki.archlinux.org/title/Podman#Rootless_Podman](https://wiki.archlinux.org/title/Podman#Rootless_Podman)。
- en: Installing Podman on Raspberry Pi OS
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Raspberry Pi OS 上安装 Podman
- en: The famous Raspberry Pi single-board computer has achieved enormous success
    among developers, makers, and hobbyists.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 著名的 Raspberry Pi 单板计算机在开发者、创客和爱好者中取得了巨大的成功。
- en: It runs the Raspberry Pi OS ([https://www.raspberrypi.org/software/operating-systems/#raspberry-pi-os-32-bit](https://www.raspberrypi.org/software/operating-systems/#raspberry-pi-os-32-bit)),
    which is based on Debian.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它运行的是 Raspberry Pi OS（[https://www.raspberrypi.org/software/operating-systems/#raspberry-pi-os-32-bit](https://www.raspberrypi.org/software/operating-systems/#raspberry-pi-os-32-bit)），该系统基于
    Debian。
- en: Podman’s arm64 build is available and can be installed by following the same
    steps described previously for the Debian distribution.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 的 arm64 构建版本已发布，并且可以通过遵循前述在 Debian 发行版上的安装步骤进行安装。
- en: Installing Podman on macOS
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 macOS 上安装 Podman
- en: Apple users who develop and run Linux containers can install and use Podman
    as a remote client, while the containers are executed on a remote Linux box. The
    Linux machine can also be a VM that’s executed on macOS and directly managed by
    Podman.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Apple 设备的用户可以安装并使用 Podman 作为远程客户端，而容器将在远程的 Linux 主机上执行。该 Linux 主机也可以是一个在
    macOS 上执行并直接由 Podman 管理的虚拟机。
- en: 'To install Podman using the Homebrew package manager, run the following command
    from the terminal:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 Homebrew 包管理器安装 Podman，请在终端中运行以下命令：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To initialize the VM running the Linux box, run the following commands:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化运行 Linux 虚拟机的环境，请运行以下命令：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Alternatively, users can create and connect to an external Linux host.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 用户也可以创建并连接到一个外部的 Linux 主机。
- en: Another valid approach on macOS to creating fast, lightweight VMs for development
    use is Vagrant. When the Vagrant machine is created, users can manually or automatically
    provision additional software such as Podman and start using the customized instance
    using the remote client.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，另一种创建快速、轻量级开发虚拟机的有效方法是 Vagrant。当 Vagrant 虚拟机创建完成后，用户可以手动或自动配置其他软件，如
    Podman，并开始使用通过远程客户端配置的定制实例。
- en: Installing Podman on Windows
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Windows 上安装 Podman
- en: To run Podman as a remote client, simply download and install the latest release
    from the GitHub releases page ([https://github.com/containers/podman/releases/](https://github.com/containers/podman/releases/)).
    Extract the archive in a suitable location and edit the TOML-encoded `containers.conf`
    file to configure a remote URI for the Linux machine or pass additional options.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要作为远程客户端运行 Podman，只需从 GitHub 发布页面下载并安装最新版本（[https://github.com/containers/podman/releases/](https://github.com/containers/podman/releases/)）。将归档文件解压到合适的位置，并编辑
    TOML 编码的 `containers.conf` 文件，配置远程 URI 以连接到 Linux 主机，或者传递其他选项。
- en: 'The following code snippet shows an example configuration:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了一个示例配置：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The remote Linux machine exposes Podman on a UNIX socket managed by a `systemd`
    unit. We will cover this topic in greater detail later in this book.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 远程 Linux 主机会通过 `systemd` 单元管理的 UNIX 套接字暴露 Podman。我们将在本书后续章节中详细介绍这个话题。
- en: To run Podman on WSL 2.0, users must first install a Linux distribution from
    the Microsoft Store on their Windows host. There is a variety of available distributions
    under the Microsoft catalog.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 WSL 2.0 上运行 Podman，用户必须首先从 Microsoft Store 在 Windows 主机上安装一个 Linux 发行版。Microsoft
    目录下有多种可用的发行版。
- en: 'The following example is based on Ubuntu 20.10:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例基于 Ubuntu 20.10：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding commands install the latest Podman stable release and configure
    the `/etc/containers/registries.conf` file to provide a registries whitelist.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令安装了最新的 Podman 稳定版本，并配置了 `/etc/containers/registries.conf` 文件，以提供一个注册表白名单。
- en: 'After its installation, some minor customizations are necessary to adapt it
    to the WSL 2.0 environment:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，某些小的定制化操作是必需的，以使其适应 WSL 2.0 环境：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding command configures logging and CGroup management to successfully
    run rootful containers in the subsystem.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令配置了日志记录和 CGroup 管理，以便在子系统中成功运行 rootful 容器。
- en: Building Podman from source
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从源代码构建 Podman
- en: 'Building an application from source has many advantages: users can inspect
    and customize code before building, cross-compile for different architectures,
    or selectively build only a subset of binaries. It is also a great learning opportunity
    to get into the project’s structure and understand its evolution. Last but not
    least, building from source lets the users get the latest development versions
    with cool new features, bugs included.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码构建应用程序有许多优点：用户可以在构建之前检查和自定义代码，进行跨架构编译，或仅选择构建部分二进制文件。这也是深入了解项目结构和理解其演变的一个很好的学习机会。最后但同样重要的是，从源代码构建可以让用户获得最新的开发版本，带有炫酷的新特性，当然也包括一些
    bugs。
- en: 'The following steps assume that the building machine is a Fedora distribution.
    First, we must install the necessary dependencies needed to compile Podman:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤假设构建机器使用的是 Fedora 发行版。首先，我们需要安装编译 Podman 所需的必要依赖：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This command will take a while to install all the packages and their cascading
    dependencies.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会花一些时间来安装所有的软件包及其级联的依赖关系。
- en: 'When the installation is complete, choose a working directory and clone the
    Podman repository using the `git` command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，选择一个工作目录并使用 `git` 命令克隆 Podman 仓库：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This command will clone the entire repository in the working directory.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在工作目录中克隆整个仓库。
- en: 'Change to the project directory and start the build:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到项目目录并开始构建：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `make package-install` command compiles the source code, builds the RPM
    files, and installs the packages locally. Remember that the RPM format is associated
    with Fedora/CentOS/RHEL distributions and managed by the `dnf` and `yum` package
    managers.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`make package-install` 命令编译源代码，构建 RPM 文件，并将包本地安装。请记住，RPM 格式与 Fedora/CentOS/RHEL
    发行版相关联，并由 `dnf` 和 `yum` 包管理器管理。'
- en: 'The build process will take a few minutes to complete. To test the successful
    installation of the packages, simply run the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程将需要几分钟才能完成。要测试软件包是否成功安装，只需运行以下代码：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Sometimes, it is useful to build the binaries on a dedicated build host and
    then deploy them on other machines, using either package managers or simple archives.
    To only build the binaries, run the following command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，将二进制文件在专用的构建主机上构建，再通过包管理器或简单的归档文件将其部署到其他机器上是很有用的。若只需要构建二进制文件，请运行以下命令：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'At the end of the build, the binaries will be available under the `bin/` folder.
    To install the compiled binaries and config files locally by simply copying them
    into the target directories defined in the Makefile, run the following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，二进制文件将位于 `bin/` 文件夹中。要通过将编译后的二进制文件和配置文件直接复制到 Makefile 中定义的目标目录来本地安装，请运行以下命令：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To create a binary release similar to the `.tar.gz` archive, which is available
    on the GitHub release page, run the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建类似于 `.tar.gz` 归档的二进制发布版本（该版本可在 GitHub 发布页面上获取），请运行以下命令：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`git` command. For example, to build v3.3.1, use the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`git` 命令。例如，要构建 v3.3.1，请使用以下命令：'
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this section, we learned how to install binary releases of Podman on different
    distributions using their respective package managers. We also learned how to
    install the Podman remote client on macOS and Windows, along with Windows WSL
    2.0 mode. We closed this section by showing you how to build from source.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们学习了如何使用各自的包管理器在不同的发行版上安装 Podman 的二进制发布版本。我们还学习了如何在 macOS 和 Windows
    上安装 Podman 远程客户端，并支持 Windows WSL 2.0 模式。最后，我们通过向你展示如何从源代码构建来结束这一部分。
- en: In the next section, we will learn how to configure Podman for the first run
    by preparing the system environment.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分中，我们将学习如何通过准备系统环境来配置 Podman 进行首次运行。
- en: Preparing your environment
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备你的环境
- en: Once the Podman packages have been installed, Podman is ready to be used *out
    of the box*. However, some minor customizations can be useful to provide better
    interoperability with external registries or to customize runtime behaviors.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Podman 包，Podman 就可以*开箱即用*了。然而，一些小的自定义配置可能对提高与外部注册表的互操作性或自定义运行时行为非常有用。
- en: Customizing the container registries search list
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义容器注册表搜索列表
- en: Podman searches for and downloads images from a list of trusted container registries.
    The `/etc/containers/registries.conf` file is a TOML config file that can be used
    to customize whitelisted registries that are allowed to be searched and used as
    image sources, as well as registry mirroring and insecure registries without TLS
    termination.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 会从一系列受信任的容器注册表中搜索并下载镜像。`/etc/containers/registries.conf` 文件是一个 TOML 配置文件，可用于自定义允许搜索和使用作为镜像来源的白名单注册表，以及注册表镜像和未经
    TLS 终止的不安全注册表。
- en: In this config file, the `unqualified-search-registries` key is populated with
    an array of unqualified registries with no specification regarding images repositories
    and tags.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置文件中，`unqualified-search-registries` 键填充了一个未指定图像仓库和标签的不合格注册表数组。
- en: 'On a Fedora system, with a new installation of Podman, this key has the following
    content:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Fedora 系统上，使用 Podman 的新安装中，此键具有以下内容：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Users can add or remove registries from this array to let Podman search and
    pull from them.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以向此数组添加或删除注册表，以让 Podman 从中搜索和拉取。
- en: Important Note
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Be very cautious when adding registries and use only trusted registries to avoid
    pulling images containing malicious code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加注册表时要非常谨慎，并且只使用可信的注册表，以避免拉取包含恶意代码的镜像。
- en: The default list is adequate to search for and run all the book examples. Those
    of you who are already running private registries can try to add them to the unqualified
    search registries array.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 默认列表足以搜索并运行所有的书本示例。那些已经运行私有注册表的用户可以尝试将它们添加到不合格搜索注册表数组中。
- en: Since registries are both private and public, please keep in mind that private
    registries usually require additional authentication to be accessed. This can
    be accomplished with the `podman login` command, which will be covered later in
    this book.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于注册表既可以是私有的也可以是公共的，请记住，通常需要额外的身份验证才能访问私有注册表。可以使用 `podman login` 命令来实现这一点，这将在本书的后续部分介绍。
- en: If the `$HOME/.config/containers/registries.conf` file is found in the user
    home, it overrides the `/etc/containers/registries.conf` file. In this way, different
    users on the same system will be able to run Podman with their custom registry
    whitelists and mirrors.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在用户的主目录中找到 `$HOME/.config/containers/registries.conf` 文件，则会覆盖 `/etc/containers/registries.conf`
    文件。这样，同一系统上的不同用户将能够使用其自定义注册表白名单和镜像运行 Podman。
- en: Optional – enable socket-based services
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选 - 启用基于套接字的服务
- en: This is an optional step and, in the absence of specific needs, this section’s
    contents can be safely skipped.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可选步骤，在没有特定需求的情况下，可以安全地跳过本节的内容。
- en: As we mentioned previously, Podman is a daemonless container manager that needs
    no background service to run containers. However, users may need to interact with
    the Libpod APIs exposed by Podman, especially when migrating from a Docker-based
    environment.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，Podman 是一种无守护进程的容器管理器，无需后台服务即可运行容器。但是，用户可能需要与 Podman 公开的 Libpod API
    进行交互，特别是在从基于 Docker 的环境迁移时。
- en: Podman can expose its APIs using a UNIX socket (default behavior) or a TCP socket.
    The latter option is less secure because it makes Podman accessible from the outside
    world, but it is necessary in some cases, such as when it should be accessed by
    a Podman client on a Windows or macOS workstation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 可以使用 UNIX 套接字（默认行为）或 TCP 套接字公开其 API。后者选项不太安全，因为它使 Podman 可以从外部访问，但在某些情况下是必需的，例如应由
    Windows 或 macOS 工作站上的 Podman 客户端访问时。
- en: Important Note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Be careful when running the API service using a TCP endpoint on a machine exposed
    to the internet since the service will be globally accessible.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 API 服务在暴露于互联网的机器上使用 TCP 端点时要小心，因为该服务将全局可访问。
- en: 'The following command exposes the Podman APIs on a UNIX socket:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将在 UNIX 套接字上公开 Podman API：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After running this command, users can connect to the API service.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，用户可以连接到 API 服务。
- en: Having to run this command on a terminal window is not a handy approach. Instead,
    the best approach is to use a `man systemd.socket`).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端窗口上运行此命令并不是一个方便的方法。而是最好的方法是使用 `man systemd.socket`）。
- en: 'Socket units in `systemd` are special kinds of service activators: when a request
    reaches the pre-defined endpoint of the socket, `systemd` immediately spawns the
    homonymous service.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Socket 单位在 `systemd` 中是一种特殊类型的服务激活器：当请求到达套接字的预定义端点时，`systemd` 立即生成同名的服务。
- en: 'When Podman is installed, the `podman.socket` and `podman.service` unit files
    are created. `podman.socket` has the following content:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装 Podman 时，会创建 `podman.socket` 和 `podman.service` 单元文件。`podman.socket` 具有以下内容：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `ListenStream` key holds the relative path of the socket, which is expanded
    to `/run/podman/podman.sock`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListenStream` 键保存套接字的相对路径，该路径扩展为 `/run/podman/podman.sock`：'
- en: 'The podman.service has the following content:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: podman.service 包含以下内容：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `ExecStart=` field indicates the command to be launched by the service,
    which is the same `podman system service` command we showed previously.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecStart=` 字段指示由服务启动的命令，这与我们之前展示的 `podman system service` 命令相同。'
- en: The `Requires=` field indicates that the `podman.service` unit needs `podman.socket`
    to be activated.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`Requires=` 字段指示 `podman.service` 单元需要激活 `podman.socket`。'
- en: So, what happens when we enable and start the `podman.socket` unit? `systemd`
    handles the socket and waits for a connection to the socket endpoint. When this
    event happens, it immediately starts the `podman.service` unit. After a period
    of inactivity, the service is stopped again.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当我们启用并启动 `podman.socket` 单元时会发生什么呢？`systemd` 处理该套接字并等待连接到套接字端点。当此事件发生时，它会立即启动
    `podman.service` 单元。经过一段时间的空闲后，服务会再次停止。
- en: 'To enable and start the socket unit, run the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用并启动套接字单元，请运行以下命令：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can test the results with a simple `curl` command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个简单的 `curl` 命令来测试结果：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The printed output will be a JSON payload that contains the container engine
    configuration.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 打印的输出将是一个 JSON 有效负载，其中包含容器引擎配置。
- en: What happened when we hit the URL? Under the hood, the service unit was immediately
    started and triggered by the socket when the connection was issued. Some of you
    may have noticed a slight delay (in the order of a 1/10th of a second) the very
    first time the command was executed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击 URL 时发生了什么？在后台，服务单元在发出连接时立即被套接字触发并启动。你们中的一些人可能注意到第一次执行命令时有轻微的延迟（大约 1/10
    秒）。
- en: After 5 seconds of inactivity, `podman.service` deactivates again. This is due
    to the default behavior of the `podman system service` command, which runs for
    5 seconds only by default unless the `–time` option is passed to provide a different
    timeout (a value of 0 means forever).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 5 秒钟的空闲时间后，`podman.service` 会再次停用。这是由于 `podman system service` 命令的默认行为，默认情况下它只运行
    5 秒，除非传递 `–time` 选项来提供不同的超时（值为 0 表示永远运行）。
- en: Optional – customize Podman’s behavior
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选 – 自定义 Podman 的行为
- en: 'Podman’s default configuration works out of the box for most use cases, but
    its configuration is highly flexible. The following configuration files are available
    for customizing its behavior:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 的默认配置适用于大多数使用场景，但其配置非常灵活。以下配置文件可用于自定义其行为：
- en: '`containers.conf`: This TOML-formatted file holds Podman runtime configurations,
    as well as search paths for `conmon` and container runtime binaries. It is installed
    by default under the `/usr/share/containers/` path and can be overridden by the
    `/etc/containers/containers.conf` and `$HOME/.config/containers/containers.conf`
    files for system-wide and user-wide settings, respectively.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`containers.conf`：该 TOML 格式的文件包含 Podman 运行时配置，以及 `conmon` 和容器运行时二进制文件的搜索路径。默认情况下，它安装在
    `/usr/share/containers/` 路径下，并可以通过 `/etc/containers/containers.conf` 和 `$HOME/.config/containers/containers.conf`
    文件分别覆盖系统范围和用户范围的设置。'
- en: This file can be used to customize the behavior of the engine. Users can influence
    how the container is created and its life cycle by customizing settings such as
    logging, DNS resolution, environment variables, shared memory usage, Cgroup management,
    and many others.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件可用于自定义引擎的行为。用户可以通过自定义设置（如日志记录、DNS 解析、环境变量、共享内存使用、Cgroup 管理等）来影响容器的创建及其生命周期。
- en: For a full list of settings, check out the related `man` page, which was installed
    along with the Podman package. (`man containers.conf`)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整设置列表，请查看随 Podman 包一起安装的相关 `man` 页面。(`man containers.conf`)
- en: '`storage.conf`: This TOML-formatted file is used to customize the storage settings
    that are used by the container engine. In particular, this file enables you to
    customize the default storage driver, as well as the read/write directory of the
    container storage (also known as the graph root), which is an additional driver
    storage option. By default, the driver is set to **overlay**.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storage.conf`：该 TOML 格式的文件用于自定义容器引擎使用的存储设置。特别地，该文件使你能够自定义默认的存储驱动程序以及容器存储的读/写目录（也称为图形根目录），这也是一个额外的驱动程序存储选项。默认情况下，驱动程序设置为
    **overlay**。'
- en: The default path of this file is `/usr/share/containers/storage.conf` and overrides
    can be found or created under `/etc/containers/storage.conf` for system-wide customizations.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件的默认路径是`/usr/share/containers/storage.conf`，可以在`/etc/containers/storage.conf`下找到或创建覆盖文件，用于系统范围的自定义配置。
- en: User-scoped configurations that impact rootless containers can be found under
    `$XDG_CONFIG_HOME/containers/storage.conf` or `$HOME/.config/containers/storage.conf`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 影响无根容器的用户范围配置可以在`$XDG_CONFIG_HOME/containers/storage.conf`或`$HOME/.config/containers/storage.conf`下找到。
- en: '`mounts.conf`: This file defines the volume mounts that should be automatically
    mounted inside a container when it is started. This is useful, for example, to
    automatically pass secrets such as keys and certificates inside a container.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mounts.conf`：此文件定义了在容器启动时应自动挂载的卷。这在自动传递容器内的密钥和证书等机密信息时非常有用。'
- en: It can be found under `/usr/share/containers/mounts.conf` and overridden by
    a file located at `/etc/containers/mounts.conf`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以在`/usr/share/containers/mounts.conf`找到，并可以通过位于`/etc/containers/mounts.conf`的文件进行覆盖。
- en: In rootless mode, the override file can be placed under `$HOME/.config/containers/mounts.conf`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在无根模式下，覆盖文件可以放置在`$HOME/.config/containers/mounts.conf`下。
- en: '`seccomp.json`: This is a JSON file that lets users customize the allowed `syscalls`
    that a process inside a container can perform and define the blocked ones at the
    same time. This topic will be covered again in [*Chapter 11*](B17908_11_epub.xhtml#_idTextAnchor206),
    *Securing Containers*, which will provide a deeper understanding of the security
    constraints of containers.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seccomp.json`：这是一个JSON文件，允许用户自定义容器内进程可以执行的`syscalls`，并同时定义被阻止的`syscalls`。这个话题将在[*第11章*](B17908_11_epub.xhtml#_idTextAnchor206)《容器安全》中再次讨论，届时会提供更深入的容器安全约束的理解。'
- en: The default path for this file is `/usr/share/containers/seccomp.json`. The
    seccomp man page (`man seccomp`) provides an overview of how seccomp works on
    a Linux system.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件的默认路径是`/usr/share/containers/seccomp.json`。seccomp手册页（`man seccomp`）提供了有关seccomp如何在Linux系统上工作的概述。
- en: '`policy.json`: This is a JSON file that defines how Podman will perform signature
    verification. The default path of this file is `/etc/containers/policy.json` and
    can be overridden by the user-scoped `$HOME/.config/containers/policy.json`.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`policy.json`：这是一个JSON文件，用于定义Podman如何执行签名验证。该文件的默认路径是`/etc/containers/policy.json`，并可以通过用户范围的`$HOME/.config/containers/policy.json`进行覆盖。'
- en: 'This config file accepts three kinds of policies:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 该配置文件接受三种类型的策略：
- en: '**insecureAcceptAnything**: Accept any image from the specified registry.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**insecureAcceptAnything**：接受来自指定注册表的任何镜像。'
- en: '**reject**: Reject any image from the specified registry.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**reject**：拒绝来自指定注册表的任何镜像。'
- en: '**signedBy**: Accept only images signed by a specific, known entity.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**signedBy**：仅接受由特定已知实体签名的镜像。'
- en: The default configuration is to accept every image (the `insecureAcceptAnything`
    policy), but it can be modified to pull only trusted images that can be verified
    by a signature. Users can define custom GPG keys to verify the signatures and
    the identity that signed them. For extra details about the possible policies and
    configuration examples, please refer to the related man page (`man containers-policy.json`).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 默认配置是接受每个镜像（`insecureAcceptAnything`策略），但可以修改为只拉取可以通过签名验证的受信镜像。用户可以定义自定义GPG密钥来验证签名及其签名者的身份。有关可能的策略和配置示例的更多细节，请参阅相关的手册页（`man
    containers-policy.json`）。
- en: In this section, we discussed some basic configurations of Podman that are useful
    to know from when Podman is first installed. In the next section, we will cover
    our first container execution examples.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了一些在Podman首次安装时需要了解的基本配置。下一节将介绍我们的第一个容器执行示例。
- en: Running your first container
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行第一个容器
- en: Now, it’s time to finally run our first container.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，终于可以运行我们的第一个容器了。
- en: In the previous section, we uncovered how to install Podman on our favorite
    Linux distribution, as well as what’s included in the base packages once installed.
    Now, we can start using our daemonless container engine.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们揭示了如何在我们喜欢的Linux发行版上安装Podman，以及安装后包含的基本软件包内容。现在，我们可以开始使用我们的无守护进程容器引擎了。
- en: Running containers in Podman is handled through the `podman run` command, which
    accepts many options for controlling the behavior of the just ran container, its
    isolation, its communication, its storage, and so on.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在Podman中运行容器是通过`podman run`命令来处理的，该命令接受许多选项来控制刚刚运行的容器的行为、隔离性、通信、存储等。
- en: 'The easiest and shortest Podman command for running a brand-new container is
    as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 运行全新容器的最简单和最短的 Podman 命令如下：
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We have to replace the `imageID` string with the image name/location/tag we
    want to run. If the image is not present in the cache or we have not downloaded
    it before, Podman will pull the image for us from the respective container registry.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将 `imageID` 字符串替换为我们想要运行的镜像名称/位置/标签。如果该镜像不在缓存中，或者我们之前没有下载过，Podman 将从相应的容器注册表为我们拉取镜像。
- en: Interactive and pseudo-tty
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交互式和伪终端（pseudo-tty）
- en: 'To introduce this command and its options, let’s start simple and run the following
    command:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了介绍这个命令及其选项，我们先从简单开始，执行以下命令：
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let’s see what Podman did once we executed the previous command:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在执行上一个命令后，Podman 做了什么：
- en: It recognized the image’s name, `fedora`, as an alias for the latest Fedora
    container image.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它识别出镜像名称 `fedora` 作为最新 Fedora 容器镜像的别名。
- en: It then realized that the image was missing from the local cache because it
    was the first time that we tried to run it.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它随后意识到，由于这是第一次尝试运行该镜像，镜像在本地缓存中是缺失的。
- en: It pulled down the image from the right registry. It chose the Fedora Project
    registry because it matched the aliases contained in the registries’ configurations.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从正确的注册表中拉取了镜像。它选择了 Fedora 项目注册表，因为它与注册表配置中包含的别名匹配。
- en: Finally, it started the container and presented us with an interactive shell,
    executing the Bash shell program that we requested.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终，它启动了容器，并为我们提供了一个交互式 shell，执行了我们请求的 Bash shell 程序。
- en: 'The previous command prompted an interactive shell thanks to the two options
    that we can analyze, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令启动了一个交互式 shell，这得益于我们可以分析的两个选项，如下所示：
- en: '`--tty, -t`: With this option, Podman allocates a `man pty`) and attaches it
    to the container’s standard input.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--tty, -t`：使用此选项，Podman 会为容器分配一个 `man pty` 并将其附加到容器的标准输入。'
- en: '`--interactive, -i`: With this option, Podman keeps `stdin` open and ready
    to be attached to the previous pseudo-tty.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--interactive, -i`：使用此选项，Podman 会保持 `stdin` 打开，并准备附加到之前的伪终端。'
- en: As stated in the previous chapters, when a container is created, the isolated
    processes inside it will run on a writable root filesystem, as a result of a layered
    overlay.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，当创建容器时，容器内部的隔离进程将在可写的根文件系统上运行，这是层叠叠加的结果。
- en: This allows any process to write files, but don’t forget that they will last
    until the container is running, as containers are ephemeral by default.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许任何进程写入文件，但不要忘记，这些文件会一直存在，直到容器停止运行，因为容器默认是短暂的。
- en: 'Now, you can execute any command and check its output in the console we just
    brought up:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以执行任何命令并检查我们刚刚启动的控制台中的输出：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, in the previous example, we just installed two packages for
    inspecting the container’s network configuration and then executing a ping to
    the default router that’s assigned to the virtual networking of our running container.
    Again, if we stop this container, any changes will be lost.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在上面的示例中，我们安装了两个软件包，用于检查容器的网络配置，然后执行 ping 测试，目标是分配给我们运行容器的虚拟网络的默认路由器。同样，如果我们停止该容器，任何更改都将丢失。
- en: To exit this interactive shell, we can just press *Ctrl* + *D* or execute the
    `exit` command. By doing this, the container will be terminated because the main
    running process we requested to execute (`/bin/bash`) will stop!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出这个交互式 shell，我们只需要按下*Ctrl* + *D* 或执行 `exit` 命令。这样，容器将被终止，因为我们请求执行的主进程（`/bin/bash`）将停止！
- en: Now, let’s look at some other nice and useful options we can use with the `podman
    run` command.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些我们可以与 `podman run` 命令一起使用的其他有用选项。
- en: Detaching from a running container
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从运行中的容器中分离
- en: As we learned previously, Podman gives us the chance to attach an interactive
    shell to our running container. However, we will soon discover that this is not
    the preferred way to run our containers.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前学到的，Podman 让我们有机会将交互式 shell 附加到正在运行的容器中。然而，我们很快会发现，这并不是运行容器的首选方式。
- en: 'Once a container has been started, we can easily detach from it, even if we
    start it with an interactive `tty` attached:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦容器启动，我们可以轻松地从容器中分离，即使我们是用附加交互式 `tty` 启动的：
- en: '[PRE31]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'What now? To detach from our running container, we just need to press these
    special keyboard shortcuts: *Ctrl* + *P*, *Ctrl* + *Q*. With this sequence, we
    will return to our shell prompt while the container will keep running.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在怎么办？要从运行中的容器中分离，我们只需按下以下特殊快捷键：*Ctrl* + *P*，*Ctrl* + *Q*。通过这个组合，我们将返回到我们的 shell
    提示符，同时容器会继续运行。
- en: 'To recover our detached container’s `tty`, we must get the list of running
    containers:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了恢复我们分离的容器的`tty`，我们必须获取正在运行的容器列表：
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will explore this command in more detail in the next chapter, but for the
    moment, just take note of `Container ID` and then execute the following command
    to re-attach to the previous `tty`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中更详细地探讨此命令，但目前，只需记下`容器 ID`，然后执行以下命令以重新连接到之前的`tty`：
- en: '[PRE33]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Note that we can easily start a container in *detached* mode by simply adding
    the `-d` option to `podman run`, like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们只需将`-d`选项添加到`podman run`命令中，就可以轻松启动一个容器并进入*分离*模式，如下所示：
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the next section, we’ll learn how to use the detach option for special purposes.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何在特殊情况下使用分离选项。
- en: Network port publishing
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络端口发布
- en: As we mentioned in the previous chapters, Podman, like any other container engine,
    attaches a virtual network to a container in a running state that has been isolated
    from the original host network. For this reason, if we want to easily reach our
    container or even expose it outside our host network, we need to instruct Podman
    to do port mapping.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中提到的，Podman像其他容器引擎一样，在容器运行时会附加一个虚拟网络，这个网络与原主机网络是隔离的。因此，如果我们想要轻松访问容器，甚至将它暴露到主机网络外部，我们需要指示Podman进行端口映射。
- en: 'The Podman `-p` option publishes a container’s port to the host:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Podman的`-p`选项将容器的端口发布到主机：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Both `hostPort` and `containerPort` could be a range of ports, and if the host
    IP is not set or it is set to `0.0.0.0`, then the port will be bound to all the
    IP addresses of the host.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`hostPort`和`containerPort`都可以是端口范围，如果主机IP未设置或设置为`0.0.0.0`，则端口将绑定到主机的所有IP地址。'
- en: 'If we take back the command we used in the previous section, it becomes the
    following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾上一节使用的命令，它变成了以下内容：
- en: '[PRE36]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we can take note of what `Container ID` has been assigned to our running
    container:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以记录下分配给我们正在运行的容器的`容器 ID`：
- en: '[PRE37]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, we can look at the port mapping we just defined:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以查看我们刚才定义的端口映射：
- en: '[PRE38]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we can test whether this port mapping works using `curl`, an easy-to-use
    HTTP web client. Alternatively, you can point your favorite web browser to the
    same URL, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用`curl`命令测试端口映射是否有效，`curl`是一个易于使用的HTTP客户端。或者，您也可以使用您喜欢的网页浏览器访问相同的URL，如下所示：
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Before concluding this chapter, let’s take a look at other interesting options
    that could be useful for managing configuration and container behavior at runtime.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束前，让我们看一下其他一些有趣的选项，这些选项可能在运行时管理配置和容器行为时非常有用。
- en: Configuration and environment variables
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置和环境变量
- en: The `podman run` command has tons of options for letting us configure the container
    behavior at runtime – we are talking about around 120 options at the time of writing
    this book.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman run`命令提供了大量的选项，允许我们在运行时配置容器的行为——在撰写本书时，大约有120个选项。'
- en: 'For example, we have an option for changing the time zone of our running containers;
    that is, `--tz`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有一个选项可以更改正在运行的容器的时区，也就是`--tz`：
- en: '[PRE40]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can change the DNS of our brand-new container with the `--dns` option:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`--dns`选项更改我们新容器的DNS：
- en: '[PRE41]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can also add a host to the `/etc/hosts` file to override a local internal
    address:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将一个主机添加到`/etc/hosts`文件中，以覆盖本地内部地址：
- en: '[PRE42]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We can even add an HTTP proxy to let our container use a proxy for HTTP requests.
    The default Podman behavior is to pass many environment variables from the host,
    some of which are `http_proxy`, `https_proxy`, `ftp_proxy`, and `no_proxy`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以添加一个HTTP代理，让容器使用代理进行HTTP请求。Podman的默认行为是从主机传递许多环境变量，其中一些是`http_proxy`、`https_proxy`、`ftp_proxy`和`no_proxy`。
- en: 'On the other hand, we can also define custom environment variables that we
    can pass to our container thanks to the `–env` option:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们也可以定义自定义的环境变量，借助`–env`选项将它们传递给容器：
- en: '[PRE43]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Adding and using environment variables with our containers is a best practice
    for passing configuration parameters to the application and influencing the service’s
    behavior from the operating system host. As we saw in [*Chapter 1*](B17908_01_epub.xhtml#_idTextAnchor015),
    *Introduction to Container Technology*, containers are immutable and ephemeral
    by default. So, for this reason, we should leverage environment variables, as
    we did in the preceding example, to configure a container at runtime.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用环境变量并与我们的容器一起使用是传递配置参数给应用程序并从操作系统主机影响服务行为的最佳实践。正如我们在[*第1章*](B17908_01_epub.xhtml#_idTextAnchor015)中看到的，*容器技术简介*，容器默认是不可变且短暂的。因此，出于这个原因，我们应该像前面的示例中那样利用环境变量，在运行时配置容器。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we started playing around with Podman’s basic commands, we
    learned how to run a container by looking at the most interesting options available,
    and we are now ready to move on to the next level: container management. To work
    as a system administrator in the container world, we must understand and learn
    about the management commands that let us inspect and check the health of our
    running containerized services; that’s what we saw in this chapter.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始玩转Podman的基本命令，我们通过查看最有趣的选项学习了如何运行容器，现在我们准备进入下一个层次：容器管理。要在容器世界中作为系统管理员工作，我们必须理解并学习那些让我们检查和检查正在运行的容器化服务健康状况的管理命令；这正是我们在本章中看到的内容。
- en: In the next chapter, which is deeply focused on container management, we are
    going to learn how to manage image and container life cycles with Podman. We will
    learn how to inspect and extract logs from running containers and will also introduce
    pods, how to create them, and how to run containers within them.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入学习容器管理，我们将学习如何使用Podman管理镜像和容器生命周期。我们将学习如何检查和提取正在运行的容器的日志，并且还将介绍Pod，如何创建它们，以及如何在其中运行容器。
- en: Further reading
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'For more information about the topics that were covered in this chapter, you
    can refer to the following resources:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章中涉及的主题的更多信息，请参考以下资源：
- en: 'Installing Podman on MacOS: [https://podman.io/blogs/2021/09/06/podman-on-macs.html](https://podman.io/blogs/2021/09/06/podman-on-macs.html)'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MacOS上安装Podman：[https://podman.io/blogs/2021/09/06/podman-on-macs.html](https://podman.io/blogs/2021/09/06/podman-on-macs.html)
- en: 'Installing Podman on Windows: [https://www.redhat.com/sysadmin/podman-windows-wsl2](https://www.redhat.com/sysadmin/podman-windows-wsl2)'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows上安装Podman：[https://www.redhat.com/sysadmin/podman-windows-wsl2](https://www.redhat.com/sysadmin/podman-windows-wsl2)
- en: 'Managing container registries: [https://www.redhat.com/sysadmin/manage-container-registries](https://www.redhat.com/sysadmin/manage-container-registries)'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理容器注册表：[https://www.redhat.com/sysadmin/manage-container-registries](https://www.redhat.com/sysadmin/manage-container-registries)
- en: 'Podman API documentation: [https://docs.podman.io/en/latest/_static/api.html](https://docs.podman.io/en/latest/_static/api.html)'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman API文档：[https://docs.podman.io/en/latest/_static/api.html](https://docs.podman.io/en/latest/_static/api.html)
- en: 'Systemd socker manual: [https://www.freedesktop.org/software/systemd/man/systemd.socket.html](https://www.freedesktop.org/software/systemd/man/systemd.socket.html)'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: systemd socket手册：[https://www.freedesktop.org/software/systemd/man/systemd.socket.html](https://www.freedesktop.org/software/systemd/man/systemd.socket.html)
- en: 'Podman and seccomp profiles: [https://podman.io/blogs/2019/10/15/generate-seccomp-profiles.html](https://podman.io/blogs/2019/10/15/generate-seccomp-profiles.html)'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman和seccomp配置文件：[https://podman.io/blogs/2019/10/15/generate-seccomp-profiles.html](https://podman.io/blogs/2019/10/15/generate-seccomp-profiles.html)
