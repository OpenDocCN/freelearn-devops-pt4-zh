- en: '*Chapter 7*: Integrating with Existing Application Build Processes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第七章*: 与现有应用构建流程的集成'
- en: After learning how to create custom container images using Podman and Buildah,
    we can now focus on special use cases that can make our build workflows more efficient
    and portable. For instance, small images are a very common requirement in an enterprise
    environment, for performance and security reasons. We will explore how to achieve
    this goal by breaking down the build process into different stages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 学会了如何使用 Podman 和 Buildah 创建自定义容器镜像后，我们现在可以集中精力处理一些特殊的用例，从而使我们的构建工作流更加高效和可移植。例如，在企业环境中，小尺寸镜像是非常常见的需求，出于性能和安全性的考虑。我们将探讨如何通过将构建过程拆分为不同阶段来实现这一目标。
- en: This chapter will also try to uncover scenarios where Buildah is not expected
    to run directly on a developer machine but is driven instead by a container orchestrator
    or embedded inside custom applications that are expected to call its libraries
    or **command line interface** (**CLI**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还将尝试揭示一些场景，其中 Buildah 不是直接在开发者机器上运行，而是由容器编排器驱动，或者嵌入在预期调用其库或**命令行界面**(**CLI**)的自定义应用程序中。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将覆盖以下主要主题：
- en: Multistage container builds
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多阶段容器构建
- en: Running Buildah inside a container
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中运行 Buildah
- en: Integrating Buildah with custom builders
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Buildah 与自定义构建工具集成
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before proceeding with this chapter, a machine with a working Podman installation
    is required. As stated in [*Chapter 3*](B17908_03_epub.xhtml#_idTextAnchor068),
    *Running the First Container*, all the examples in the book are executed on a
    Fedora 34 system or later versions but can be reproduced on the reader's OS of
    choice.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本章内容之前，需要一台已安装并正常运行 Podman 的机器。如[*第三章*](B17908_03_epub.xhtml#_idTextAnchor068)《运行第一个容器》中所述，本书中的所有示例都是在
    Fedora 34 或更高版本的系统上执行的，但也可以在读者选择的操作系统上重现。
- en: A good understanding of the topics covered in [*Chapter 6*](B17908_06_epub.xhtml#_idTextAnchor116),
    *Meet Buildah – Building Containers from Scratch*, will be useful to easily grasp
    concepts regarding builds, both with native Buildah commands and from Dockerfiles.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[*第六章*](B17908_06_epub.xhtml#_idTextAnchor116)《了解 Buildah —— 从头开始构建容器》中的内容有一个良好的理解，将有助于轻松掌握构建相关的概念，无论是使用本地
    Buildah 命令还是从 Dockerfile 中构建。
- en: Multistage container builds
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多阶段容器构建
- en: We have learned so far how to create builds with Podman and Buildah using Dockerfiles
    or native Buildah commands that unleash potential advanced building techniques.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何使用 Podman 和 Buildah 通过 Dockerfile 或本地 Buildah 命令来创建构建，从而释放潜在的高级构建技术。
- en: There is still an important point that we haven't already discussed – the size
    of the images.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个我们尚未讨论的重要点——镜像的大小。
- en: When creating a new image, we should always take care of its final size, which
    is the result of the total number of layers and the number of changed files inside
    them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新镜像时，我们应该始终关注其最终大小，这是总层数和其中变更的文件数量的结果。
- en: Minimal images with a small size have the great advantage of being able to be
    pulled faster from registries. Nevertheless, a large image will eat a lot of precious
    disk space in the host's local store.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 小尺寸的最小镜像具有一个很大的优势，即能够更快地从注册表中拉取。然而，较大的镜像将占用主机本地存储中大量宝贵的磁盘空间。
- en: We already showed examples of some best practices to keep images compact in
    size, such as building from scratch, cleaning up package manager caches, and reducing
    the amount of `RUN`, `COPY`, and `ADD` instructions to the minimum necessary.
    However, what happens when we need to build an application from its source and
    create a final image with the final artifacts?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了一些最佳实践的例子，以保持镜像紧凑小巧，例如从头开始构建、清理包管理器缓存，以及将 `RUN`、`COPY` 和 `ADD` 指令的数量减少到最少必要量。然而，当我们需要从源代码构建应用并创建包含最终制品的最终镜像时，情况会如何？
- en: Let's say we need to build a containerized Go application – we should start
    from a base image that includes Go runtimes, copy the source code, and compile
    to produce the final binary with a series of intermediate steps, most notably
    downloading all the necessary Go packages inside the image cache. At the end of
    the build, we should clean up all the source code and the downloaded dependencies
    and put the final binary (which is statically linked in Go) in a working directory.
    Everything will work, but the final image will still include the Go runtimes included
    in the base image, which are no longer necessary at the end of the compilation
    process.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要构建一个容器化的 Go 应用程序——我们应该从一个包含 Go 运行时的基础镜像开始，复制源代码，并通过一系列中间步骤进行编译以生成最终的二进制文件，最重要的是在镜像缓存中下载所有必要的
    Go 包。在构建结束时，我们应该清理所有源代码和下载的依赖项，并将最终的二进制文件（Go 中静态链接）放在工作目录中。一切正常，但最终的镜像仍然包含基础镜像中的
    Go 运行时，而这些在编译过程结束后已经不再需要。
- en: When Docker was introduced and Dockerfiles gained momentum, this problem was
    circumnavigated in different ways by DevOps teams who struggled to keep images
    minimal. For example, **binary builds** were a way to inject the final artifact
    compiled externally inside the built image. This approach solves the image size
    problem but removes the advantage of a standardized environment for builds provided
    by runtime/compiler images.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Docker 被引入并且 Dockerfile 逐渐流行时，DevOps 团队通过不同的方法解决了这个问题，他们努力保持镜像的最小化。例如，**二进制构建**是一种将外部编译的最终产物注入到构建镜像中的方法。这种方法解决了镜像大小的问题，但消除了运行时/编译器镜像提供的标准化构建环境的优势。
- en: A better approach is to share volumes between containers and have the final
    container image grab the compiled artifacts from a first build image.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是通过容器之间共享卷，并让最终的容器镜像从第一个构建镜像中获取编译后的产物。
- en: To provide a standardized approach, Docker, and then the OCI specifications,
    introduced the concept of `FROM` instructions and have subsequent images grab
    contents from the previous ones.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一种标准化的方法，Docker 和随后的 OCI 规范引入了 `FROM` 指令的概念，允许后续镜像从前一个镜像中抓取内容。
- en: In the next subsections, we will explore how to achieve this result with Dockerfiles/Containerfiles
    and with Buildah's native commands.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的子章节中，我们将探讨如何使用 Dockerfile/Containerfile 和 Buildah 的原生命令实现这一结果。
- en: Multistage builds with Dockerfiles
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Dockerfile 进行多阶段构建
- en: The first approach to multistage builds is by creating multiple stages in a
    single Dockerfile/Containerfile, with each block beginning with a `FROM` instruction.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段构建的第一种方法是在单个 Dockerfile/Containerfile 中创建多个阶段，每个阶段以 `FROM` 指令开始。
- en: Build stages can copy files and folders from previous ones using the `--from`
    option to specify the source stage.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 构建阶段可以使用 `--from` 选项从前一个阶段复制文件和文件夹，以指定源阶段。
- en: 'The next examples show how to create a minimal multistage build for the Go
    application, with the first stage acting as a pure build context and the second
    stage copying the final artifact inside a minimal image:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下列示例展示了如何为 Go 应用程序创建一个最小的多阶段构建，第一个阶段作为纯粹的构建上下文，第二个阶段将最终产物复制到一个最小的镜像中：
- en: Chapter07/http_hello_world/Dockerfile
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter07/http_hello_world/Dockerfile
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first stage copies the source `main.go` file and the `go.mod` file to manage
    the Go module dependencies. After downloading the dependency packages (`go get
    -d -v ./...`), the final application is built (`go build –v ./...`).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个阶段将源 `main.go` 文件和 `go.mod` 文件复制过来，以管理 Go 模块依赖关系。下载依赖包（`go get -d -v ./...`）后，最终应用程序将被构建（`go
    build -v ./...`）。
- en: The second stage grabs the final artifact (`/go/src/hello-world/hello-world`)
    and copies it under the new image root. To specify that the source file should
    be copied from the first stage, the `--from=0` syntax is used.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个阶段抓取最终的产物（`/go/src/hello-world/hello-world`）并将其复制到新镜像的根目录下。为了指定源文件应从第一个阶段复制，使用
    `--from=0` 语法。
- en: In the first stage, we used the official `docker.io`/`library`/`golang` image,
    which includes the latest version of the Go programming language. In the second
    stage, we used the **ubi-micro** image, a minimal image from Red Hat with a reduced
    footprint, optimized for microservices and statically linked binaries. Universal
    Base Images will be covered in greater detail in [*Chapter 8*](B17908_08_epub.xhtml#_idTextAnchor149),
    *Choosing the Container Base Image*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一阶段，我们使用了官方的 `docker.io`/`library`/`golang` 镜像，其中包含 Go 编程语言的最新版本。在第二阶段，我们使用了
    **ubi-micro** 镜像，这是来自 Red Hat 的一个最小化镜像，具有减少的体积，针对微服务和静态链接二进制文件进行了优化。通用基础镜像将在[*第八章*](B17908_08_epub.xhtml#_idTextAnchor149)中更详细地介绍，*选择容器基础镜像*。
- en: 'The Go application listed as follows is a basic web server that listens on
    port `8080/tcp` and prints a crafted HTML page with the *"Hello World!"* message
    when it receives a `GET /` request:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出的 Go 应用程序是一个基础的 web 服务器，它监听 `8080/tcp` 端口，并在收到 `GET /` 请求时打印一个包含 *"Hello
    World!"* 消息的 HTML 页面：
- en: Important Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: For the purpose of this book, it is not necessary to be able to write or understand
    the Go programming language. However, a basic understanding of the language syntax
    and logic will prove to be very useful, since the greatest part of container-related
    software (such as Podman, Docker, Buildah, Skopeo, Kubernetes, and OpenShift)
    is written in Go.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目的并不要求能够编写或理解 Go 编程语言。然而，了解语言的基本语法和逻辑将非常有用，因为大部分与容器相关的软件（如 Podman、Docker、Buildah、Skopeo、Kubernetes
    和 OpenShift）都是用 Go 编写的。
- en: Chapter07/http_hello_world/main.go
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter07/http_hello_world/main.go
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The application can be built using either Podman or Buildah. In this example,
    we choose to build the application with Buildah:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以使用 Podman 或 Buildah 构建。在此示例中，我们选择使用 Buildah 来构建应用程序：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we can check the resulting image size:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以检查结果镜像的大小：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The final image has a size of only 45 MB!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的镜像大小只有 45 MB！
- en: 'We can improve our Dockerfile by adding custom names to the base images using
    the keyword `AS`. The following example is a rework of the previous Dockerfile
    following this approach, with the key elements highlighted in bold:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `AS` 关键字为基础镜像添加自定义名称，从而改进我们的 Dockerfile。以下示例是按照此方法重新制作的 Dockerfile，关键元素用粗体显示：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, the name of the builder image is set as `builder`,
    while the final image is named `srv`. Interestingly, the `COPY` instruction can
    now specify the builder as using the custom name with the `--from=builder` option.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，构建器镜像的名称设置为 `builder`，而最终的镜像命名为 `srv`。有趣的是，`COPY` 指令现在可以使用 `--from=builder`
    选项指定构建器并使用自定义名称。
- en: Dockerfile/Containerfile builds are the most common approach but still lack
    some flexibility when it comes to implementing a custom build workflow. For those
    special use cases, Buildah native commands come to our rescue.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile/Containerfile 构建是最常见的方法，但在实现自定义构建工作流程时仍缺乏一定的灵活性。对于那些特殊的使用案例，Buildah
    原生命令为我们提供了帮助。
- en: Multistage builds with Buildah native commands
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Buildah 原生命令的多阶段构建
- en: As mentioned before, the multistage build feature is a great approach to produce
    images with a small footprint and a reduced attack surface. To provide greater
    flexibility during the build process, the Buildah native commands come to our
    rescue. As we mentioned earlier in [*Chapter 6*](B17908_06_epub.xhtml#_idTextAnchor116),
    *Meet Buildah – Building Containers from Scratch*, Buildah offers a series of
    commands that replicate the behavior of the Dockerfile instructions, thus offering
    greater control over the build process when those commands are included in scripts
    or automations.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，多阶段构建功能是一种很好的方法，可以生成小体积且减少攻击面图像。为了在构建过程中提供更大的灵活性，Buildah 原生命令派上了用场。正如我们在[*第六章*](B17908_06_epub.xhtml#_idTextAnchor116)中提到的，*遇见
    Buildah——从零开始构建容器*，Buildah 提供了一系列命令，复制了 Dockerfile 指令的行为，从而在将这些命令包含在脚本或自动化过程中时，提供了更大的构建过程控制。
- en: The same concept applies when working with multistage builds, where we can also
    apply extra steps between the stages. For instance, we can mount the build container
    overlay file system and extract the built artifact to release alternate packages,
    all before building the final runtime image.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在多阶段构建中也适用相同的概念，我们还可以在阶段之间应用额外的步骤。例如，我们可以挂载构建容器的覆盖文件系统，并提取构建的工件以发布备用包，所有这些都可以在构建最终运行时镜像之前完成。
- en: 'The following example builds the same `hello-world` Go application by translating
    the previous Dockerfile instructions into native Buildah commands, with everything
    inside a simple shell script:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例通过将之前的 Dockerfile 指令转换为本地 Buildah 命令，在一个简单的 shell 脚本中构建相同的 `hello-world`
    Go 应用程序：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding example, we highlighted the two working containers' creation
    commands and the related `container1` and `container2` variables that store the
    container ID.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们突出了创建两个工作容器的命令以及相关的 `container1` 和 `container2` 变量，这些变量存储了容器 ID。
- en: Also, note the `buildah copy` command, where we have defined the source container
    with the `--from` option, and used the `--chown` option to define user and group
    owners of the copied resource. This approach proves to be more flexible than the
    Dockerfile-based workflow, since we can enrich our script with variables, conditionals,
    and loops.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，注意 `buildah copy` 命令，我们在其中通过 `--from` 选项定义了源容器，并使用 `--chown` 选项定义了复制资源的用户和组所有者。这种方法比基于
    Dockerfile 的工作流更加灵活，因为我们可以用变量、条件和循环来丰富我们的脚本。
- en: For instance, we have tested with the `if` condition in the Bash script to check
    the existence of the `go.mod` and `main.go` files before copying them inside the
    working container dedicated to the build.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们在 Bash 脚本中测试了使用 `if` 条件来检查 `go.mod` 和 `main.go` 文件是否存在，然后再将它们复制到专用于构建的工作容器内。
- en: 'Let''s now add an extra feature to the script. In the following example, we
    evolved the previous one by adding a semantic versioning for the build and creating
    a version archive before starting the build of the final runtime image:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们向脚本添加一个额外的功能。在以下示例中，我们通过为构建添加语义化版本控制，并在开始构建最终运行时镜像之前创建版本归档，进一步改进了之前的脚本：
- en: Important Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The concept of semantic versioning is aimed to provide a clear and standardized
    way to manage software versioning and dependency management. It is a set of standard
    rules whose purpose is to define how software release versions are applied and
    follows the **X.Y.Z** versioning pattern, where **X** is the major version, **Y**
    is the minor version, and **Z** is the patch version. For more information, check
    out the official specifications: [https://semver.org/](https://semver.org/).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 语义化版本控制的概念旨在提供一种清晰且标准化的方式来管理软件版本和依赖关系管理。它是一套标准规则，其目的是定义如何应用软件发布版本，并遵循 **X.Y.Z**
    版本模式，其中 **X** 是主版本号，**Y** 是次版本号，**Z** 是补丁版本号。有关更多信息，请查看官方规范：[https://semver.org/](https://semver.org/)。
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The key changes in the script are again highlighted in bold. First, we added
    a `RELEASE` variable that tracks the release version of the application. Then,
    we extracted the build artifact using the `buildah unshare` command, followed
    by the `--mount` option to pass the container mount point. The user namespace
    unshare was necessary to make the script capable of running rootless.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本中的关键更改再次以粗体突出显示。首先，我们添加了一个 `RELEASE` 变量，用于跟踪应用程序的发布版本。然后，我们使用 `buildah unshare`
    命令提取了构建产物，接着使用 `--mount` 选项传递了容器的挂载点。用户命名空间的 unshare 是必要的，以使脚本能够以无根（rootless）模式运行。
- en: After extracting the artifact, we created a gzipped archive using the `$RELEASE`
    variable inside the archive name and removed the temporary files.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 提取构建产物后，我们使用 `$RELEASE` 变量在归档文件名中创建了一个 gzipped 压缩文件，并删除了临时文件。
- en: Finally, we started the build of the runtime image and committed using the `$RELEASE`
    variable again as the image tag.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们开始构建运行时镜像，并使用 `$RELEASE` 变量再次提交，作为镜像标签。
- en: In this section, we have learned how to run multistage builds with Buildah using
    both Dockerfiles/Containerfiles and native commands. In the next section, we will
    learn how to isolate Buildah builds inside a container.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们学习了如何使用 Buildah 运行多阶段构建，使用 Dockerfiles/Containerfiles 和本地命令。在下一部分，我们将学习如何在容器内隔离
    Buildah 构建。
- en: Running Buildah inside a container
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器内运行 Buildah
- en: Podman and Buildah follow a fork/exec approach that makes them very easy to
    run inside a container, including rootless containers scenarios.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 和 Buildah 遵循 fork/exec 方法，使得它们非常容易在容器内运行，包括无根容器场景。
- en: There are many use cases that imply the need for containerized builds. Nowadays,
    one of the most common adoption scenarios is the application build workflow running
    on top of a **Kubernetes** cluster.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多用例需要容器化构建。如今，其中一个最常见的应用场景是基于 **Kubernetes** 集群的应用构建工作流。
- en: Kubernetes is basically a container orchestrator that manages the scheduling
    of containers from a control plane over a set of worker nodes that run a container
    engine compatible with the **Container Runtime Interface** (**CRI**). Its design
    allows great flexibility in customizing networking, storage, and runtimes, and
    leads to the great flourishing of side projects that are now incubating or matured
    inside the **Cloud Native Computing Foundation** (**CNCF**).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 基本上是一个容器编排器，管理通过控制平面调度容器，容器运行在与 **容器运行时接口** (**CRI**) 兼容的容器引擎上。它的设计允许在网络、存储和运行时的定制上具有极大的灵活性，推动了许多侧项目的蓬勃发展，这些项目现在正在
    **云原生计算基金会** (**CNCF**) 内孵化或成熟。
- en: '**Vanilla** Kubernetes (which is the basic community release without any customization
    or add-ons) doesn''t have any native build feature but offers the proper framework
    to implement one. Over time, many solutions appeared trying to address this need.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vanilla** Kubernetes（即没有任何自定义或附加组件的基本社区版本）本身没有原生构建功能，但提供了实现此功能的适当框架。随着时间的推移，许多解决方案应运而生，试图解决这一需求。'
- en: For example, Red Hat **OpenShift** introduced, way back when Kubernetes 1.0
    was released, its own build APIs and the *Source-to-Image* toolkit to create container
    images from source code directly on top of the OpenShift cluster.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，**OpenShift**（红帽的 Kubernetes 平台）在 Kubernetes 1.0 发布时就引入了自己的构建 API 和 *Source-to-Image*
    工具包，用于直接在 OpenShift 集群上从源代码创建容器镜像。
- en: Another interesting solution is Google's **kaniko**, which is a build tool to
    create container images inside a Kubernetes cluster that runs every build step
    inside user space.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的解决方案是谷歌的 **kaniko**，它是一个构建工具，可以在 Kubernetes 集群内创建容器镜像，并且每个构建步骤都在用户空间中运行。
- en: Besides using already implemented solutions, we can design our own running Buildah
    inside containers that are orchestrated by Kubernetes. We can also leverage the
    rootless-ready design to implement secure build workflows.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用已实现的解决方案外，我们还可以设计自己在 Kubernetes 编排下运行的 Buildah 容器。我们还可以利用无根设计实现安全的构建工作流。
- en: It is possible to run CI/CD pipelines on top of a Kubernetes cluster and embed
    containerized builds within a pipeline. One of the most interesting CNCF projects,
    **Tekton Pipelines**, offers a cloud-native approach to accomplish this goal.
    Tekton allows running pipelines that are driven by Kubernetes' custom resources
    – special APIs that extend the basic API set.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 Kubernetes 集群之上运行 CI/CD 流水线，并将容器化构建嵌入到流水线中。**Tekton Pipelines** 是一个非常有趣的
    CNCF 项目，提供了一种云原生的方法来实现这一目标。Tekton 允许运行由 Kubernetes 自定义资源驱动的流水线——这些是扩展基本 API 集的特殊
    API。
- en: Tekton Pipelines are made up of many different tasks, and users can either create
    their own or grab them from **Tekton Hub** ([https://hub.tekton.dev/](https://hub.tekton.dev/)),
    a free repository where many pre-baked tasks are available to be consumed immediately,
    including examples from Buildah ([https://hub.tekton.dev/tekton/task/buildah](https://hub.tekton.dev/tekton/task/buildah)).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Tekton Pipelines 由许多不同的任务组成，用户可以创建自己的任务，也可以从 **Tekton Hub** ([https://hub.tekton.dev/](https://hub.tekton.dev/))
    中获取任务，这是一个免费的仓库，提供了许多可以立即使用的预制任务，包括来自 Buildah 的示例 ([https://hub.tekton.dev/tekton/task/buildah](https://hub.tekton.dev/tekton/task/buildah))。
- en: The preceding examples are useful to understand why containerized builds are
    important. In this book, we want to focus on the details of running builds within
    containers, with special attention paid to security-related constraints.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子有助于理解为什么容器化构建如此重要。在本书中，我们将重点关注在容器中运行构建的细节，特别关注与安全相关的约束。
- en: Running rootless Buildah containers with volume stores
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行无根权限的 Buildah 容器并使用卷存储
- en: For the examples in this subsection, the stable upstream `quay.io/buildah/stable`
    Buildah image will be used. This image already embeds the latest stable Buildah
    binary.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中的例子将使用稳定的上游 `quay.io/buildah/stable` Buildah 镜像。此镜像已嵌入最新的稳定 Buildah 二进制文件。
- en: 'Let''s run our first example with a rootless container that builds the contents
    of the `~/build` directory in the host and stores the output in a local volume
    named `storevol`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行第一个示例，使用一个无根容器，它构建主机中 `~/build` 目录的内容，并将输出存储在名为 `storevol` 的本地卷中：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This example brings some peculiar options that deserve attention, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子引入了一些值得注意的特殊选项，具体如下：
- en: The `--device /dev/fuse` option, which loads the fuse kernel module in the container,
    which is necessary to run fuse-overlay commands
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--device /dev/fuse` 选项会在容器中加载 fuse 内核模块，这是运行 fuse-overlay 命令所必需的'
- en: The `-v ~/build:/build:z` option, which bind-mounts the `/root/build` directory
    inside the container, assigning proper SELinux labeling with the `:z` suffix
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v ~/build:/build:z` 选项，它将 `/root/build` 目录绑定挂载到容器内部，并通过 `:z` 后缀为其分配适当的 SELinux
    标签。'
- en: The `-v storevol:/var/lib/containers` option, which creates a fresh volume mounted
    on the default container store where all the layers are created
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v storevol:/var/lib/containers` 选项，它创建了一个新的卷并挂载到默认的容器存储路径，所有层都在该位置创建。'
- en: 'When the build is complete, we can run a new container using the same volume
    and inspect or manipulate the built image:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建完成后，我们可以使用相同的卷运行一个新容器，检查或操作已构建的镜像：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We have successfully built an image whose layers have been stored inside the
    `storevol` volume. To recursively list the content of the store, we can extract
    the volume mount point with the `podman volume inspect` command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功构建了一个镜像，其层存储在 `storevol` 卷中。要递归列出存储内容，我们可以使用 `podman volume inspect` 命令提取卷的挂载点：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'From now on, it is possible to launch a new Buildah container to authenticate
    to the remote registry, and tag and push the image. In the next example, Buildah
    tags the resulting image, authenticates to the remote registry, and finally pushes
    the image:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，可以启动一个新的 Buildah 容器来对远程注册表进行身份验证，并标记和推送镜像。在下一个示例中，Buildah 会标记生成的镜像、对远程注册表进行身份验证，并最终推送镜像：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When the image is successfully pushed, it is finally safe to remove the volume:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当镜像成功推送后，可以安全地移除该卷：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Despite working perfectly, this approach has some limits that are worth discussing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法工作得非常完美，但它有一些值得讨论的限制。
- en: The first limit we can notice is that the store volume is not isolated, and
    thus any other container can access its contents. To overcome this issue, we can
    use SELinux's `:Z` suffix in order to apply categories to the volume and make
    it accessible exclusively to the running container.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到的第一个限制是存储卷没有隔离，因此其他任何容器都可以访问其内容。为了解决这个问题，我们可以使用 SELinux 的 `:Z` 后缀，应用类别标签到该卷，并使其仅对正在运行的容器可访问。
- en: However, since a second container would run by default with different category
    labels, we should grab the volume categories and run the second tag/push container
    with the `--security-opt label=level:s0:<CAT1>,<CAT2>` option.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于第二个容器默认会使用不同的类别标签，我们需要获取卷的类别标签，并使用 `--security-opt label=level:s0:<CAT1>,<CAT2>`
    选项来运行第二个标记/推送容器。
- en: 'Alternatively, we can just run build, tag, and push commands in one single
    container, as shown in the following example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在一个容器中运行构建、标记和推送命令，如以下示例所示：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Important Note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In the preceding examples, we used the Buildah login by directly passing the
    username and password in the command. Needless to say, this is far from being
    an acceptable security practice.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们通过直接在命令中传递用户名和密码来使用 Buildah 登录。毋庸置疑，这远远不是一种可接受的安全做法。
- en: Instead of passing sensitive data in the command line, we can mount the authentication
    file that contains a valid session token as a volume inside the container.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将包含有效会话令牌的认证文件作为一个卷挂载到容器内部，而不是通过命令行传递敏感数据。
- en: 'The next example mounts a valid `auth.json` file, stored under the `/run/user/<UID>`
    tmpfs, inside the build container, and the `--authfile /auth.json` option is then
    passed to the `buildah push` command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例将一个有效的 `auth.json` 文件挂载到构建容器中，文件存储在 `/run/user/<UID>` 的 tmpfs 中，然后将 `--authfile
    /auth.json` 选项传递给 `buildah push` 命令：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Finally, we have a working example that avoids exposing clear credentials in
    the commands passed to the container.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个有效的示例，避免了在传递给容器的命令中暴露明文凭据。
- en: 'To provide a working authentication file, we need to authenticate from the
    host that will run the containerized build or copy a valid authentication file.
    To authenticate with Podman, we''ll use the following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供有效的认证文件，我们需要从将运行容器化构建的主机进行认证，或者复制一个有效的认证文件。为了通过 Podman 进行认证，我们将使用以下命令：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If the authentication process succeeds, the obtained token is stored in the
    `/run/user/<UID>/containers/auth.json` file, which stores a JSON-encoded object
    with a structure similar to the following example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果认证过程成功，获取的令牌将存储在 `/run/user/<UID>/containers/auth.json` 文件中，该文件存储了一个 JSON
    编码的对象，其结构类似于以下示例：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Security Alert!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 安全警告！
- en: If the authentication file mounted inside the container has multiple authentication
    records for different registries, they will be exposed inside the build container.
    This can lead to potential security issues, since the container will be able to
    authenticate on those registries using the tokens specified in the file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果挂载到容器内的身份验证文件包含多个针对不同注册表的身份验证记录，它们将暴露在构建容器中。这可能导致潜在的安全问题，因为容器可以使用文件中指定的令牌在这些注册表上进行身份验证。
- en: The volume-based approach we just described has some small impact on the performance
    when compared to a native host build but provides better isolation of the build
    process, a reduced attack surface, thanks to the rootless execution and standardization
    of the build environment across different hosts.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚描述的基于卷的方法与本地主机构建相比，在性能上有一些小的影响，但由于采用无根执行和跨主机标准化构建环境，它提供了更好的构建过程隔离，减少了攻击面。
- en: Let's now inspect how to run containerized builds using bind-mounted stores.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看如何使用绑定挂载的存储来运行容器化的构建。
- en: Running Buildah containers with bind-mounted stores
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用绑定挂载存储运行 Buildah 容器
- en: In the highest isolation scenario, where DevOps teams follow a zero-trust approach,
    every build container should have its own isolated store populated at the beginning
    of the build and destroyed upon completion. Isolation can be easily achieved with
    SELinux MCS security.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在最高隔离的场景下，当 DevOps 团队遵循零信任方法时，每个构建容器应该拥有自己独立的存储，该存储在构建开始时创建，在构建完成后销毁。隔离可以通过
    SELinux MCS 安全轻松实现。
- en: 'To test this approach, let''s start by creating a temporary directory that
    will host the build layers. We also want to generate a random suffix for a name
    in order to host multiple builds without conflicts:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这种方法，首先创建一个临时目录，用于存放构建层。我们还需要为名称生成一个随机后缀，以便在不发生冲突的情况下托管多个构建：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Important Note
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The preceding example and the next builds are executed as root.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例和接下来的构建都是以 root 身份执行的。
- en: 'We can now run the build and bind-mount the new directory to the `/var/lib/containers`
    folder inside the container and add the `:Z` suffix to ensure multi-category security
    isolation:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行构建并将新目录绑定挂载到容器内的`/var/lib/containers`文件夹，并添加`:Z`后缀，以确保多类别的安全隔离：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The MCS isolation guarantees isolation from other containers. Every build container
    will have its own custom store, and this implies the need to re-pull the base
    image layers on every execution, since they are never cached.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: MCS 隔离确保与其他容器的隔离。每个构建容器将拥有自己的自定义存储，这意味着每次执行时都需要重新拉取基础镜像层，因为它们从未被缓存。
- en: Despite being the most secure in terms of isolation, this approach also offers
    the slowest performance because of the continuous pulls on the build run.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在隔离方面是最安全的，但这种方法也因为在构建运行过程中持续拉取镜像而提供最慢的性能。
- en: On the other hand, the less secure approach does not expect any store isolation,
    and all the build containers mount the default host store under `/var/lib/containers`.
    This approach provides better performance, since it allows the reuse of cached
    layers from the host store.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，较不安全的方法不期望任何存储隔离，所有构建容器都将默认主机存储挂载到`/var/lib/containers`下。这种方法提供更好的性能，因为它允许重用主机存储中的缓存层。
- en: SELinux will not allow a containerized process to access the host store; therefore,
    we need to relax SELinux security restrictions to run the following example using
    the `--security-opt label=disable` option.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 不允许容器化的进程访问主机存储；因此，我们需要放宽 SELinux 安全限制，以使用`--security-opt label=disable`选项运行以下示例。
- en: 'The following example runs another build using the default host store:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用默认主机存储运行另一个构建：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The approach described in this example is the opposite of the previous one –
    better performances but worse security isolation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中描述的方法与前一种方法相反——性能更好，但安全隔离较差。
- en: A good compromise between the two implies the usage of a secondary, read-only
    image store to provide access to the cached layers. Buildah supports the usage
    of multiple image stores, and the `/etc/containers/storage.conf` file *inside
    the Buildah stable image* already configures the `/var/lib/shared` folder for
    this purpose.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间的良好折中方法是使用一个次要的只读镜像存储来提供对缓存层的访问。Buildah 支持使用多个镜像存储，且`/etc/containers/storage.conf`文件*在
    Buildah 稳定镜像内*已经配置了`/var/lib/shared`文件夹以实现此目的。
- en: 'To prove this, we can inspect the content of the `/etc/containers/storage.conf`
    file, where the following section is defined:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这一点，我们可以检查 `/etc/containers/storage.conf` 文件的内容，在其中定义了以下部分：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This way, we can get good isolation and better performance, since cached images
    from the host will be already available in the read-only store. The read-only
    store can be prepopulated with the most used images to speed up builds or can
    be mounted from a network share.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可以实现良好的隔离和更好的性能，因为来自主机的缓存镜像将已经可用于只读存储。只读存储可以预先填充以加快构建速度，或者可以从网络共享中挂载。
- en: 'The following example shows this approach, by bind-mounting the read-only store
    to the container and executing the build with the advantage of reusing pre-pulled
    images:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了这种方法，通过将只读存储绑定到容器并执行构建，利用重新拉取的镜像的优势：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The examples showed in this subsection are also inspired by a great technical
    article written by *Dan Walsh* (one of the leads of the Buildah and Podman projects)
    on the *Red Hat Developer* blog; refer to the *Further reading* section for the
    original article link. Let's close this section with an example of native Buildah
    commands.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此子节中显示的示例也受到了 *Dan Walsh*（Buildah 和 Podman 项目的主要负责人之一）在 *Red Hat Developer*
    博客上撰写的一篇出色技术文章的启发；请参阅 *进一步阅读* 部分以获取原始文章链接。让我们通过一个原生 Buildah 命令的示例来结束这一节。
- en: Running native Buildah commands inside containers
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在容器内运行原生 Buildah 命令
- en: 'We have so far illustrated examples using Dockerfiles/Containerfiles, but nothing
    prevents us from running containerized native Buildah commands. The following
    example creates a custom Python image built from a Fedora base image:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经演示了使用 Dockerfiles/Containerfiles 的示例，但没有任何东西阻止我们运行容器化的原生 Buildah 命令。以下示例创建了一个基于
    Fedora 基础映像构建的自定义 Python 镜像：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: From a performance standpoint as well as the build process, nothing changes
    from the previous examples. As already stated, this approach provides more flexibility
    in the build operations.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能和构建过程的角度来看，与之前的示例相比，没有任何变化。如前所述，这种方法在构建操作上提供了更多的灵活性。
- en: 'If the commands to be passed are too many, a good workaround can be to create
    a shell script and inject it into the Buildah image using a dedicated volume:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要传递的命令太多，一个很好的解决方法是创建一个 shell 脚本，并通过专用卷将其注入到 Buildah 镜像中：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`build.sh` is the name of the shell script file containing all the build custom
    commands.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`build.sh` 是包含所有构建自定义命令的 shell 脚本文件的名称。'
- en: In this section, we have learned how to run Buildah in containers covering both
    volume mounts and bind mounts. We have learned how to run rootless build containers
    that can be easily integrated into pipelines or Kubernetes clusters to provide
    an end-to-end application life cycle workflow. This is due to the flexible nature
    of Buildah, and for the same reason, it is very easy to embed Buildah inside custom
    builders, as we will see in the next section.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们学习了如何在容器中运行 Buildah，涵盖了卷挂载和绑定挂载。我们学习了如何运行无根构建容器，这些容器可以轻松集成到管道或 Kubernetes
    集群中，以提供端到端的应用程序生命周期工作流程。这归功于 Buildah 的灵活性，出于同样的原因，将 Buildah 嵌入到自定义构建器中也非常容易，我们将在下一节中看到。
- en: Integrating Buildah in custom builders
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在自定义构建器中集成 Buildah
- en: As we saw in the previous section of this chapter, Buildah is a key component
    of Podman's container ecosystem. Buildah is a dynamic and flexible tool that can
    be adapted to different scenarios to build brand-new containers. It has several
    options and configurations available, but our exploration is not yet finished.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章的前一节中看到的那样，Buildah 是 Podman 容器生态系统的关键组件。Buildah 是一个动态和灵活的工具，可以适应不同的场景来构建全新的容器。它有多个选项和配置可用，但我们的探索还没有结束。
- en: Podman and all the projects developed around it have been built with extensibility
    in mind, making every programmable interface available to be reused from the outside
    world.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 和围绕它开发的所有项目都考虑到了可扩展性，使得每个可编程接口都可以从外部世界重用。
- en: Podman, for example, inherits Buildah capabilities for building brand-new containers
    through the `podman build` command; with the same principle, we can embed Buildah
    interfaces and its engine in our custom builder.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Podman 通过 `podman build` 命令继承了 Buildah 的能力，可以用相同的原则将 Buildah 接口及其引擎嵌入我们的自定义构建器中，用于构建全新的容器。
- en: Let's see how to build a custom builder in the Go language; we will see that
    the process is pretty straightforward, because Podman, Buildah, and many other
    projects in this ecosystem are actually written in the Go language.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 Go 语言中构建自定义构建器；我们会发现过程相当简单，因为 Podman、Buildah 和这个生态系统中的许多其他项目实际上都是用
    Go 语言编写的。
- en: Including Buildah in our Go build tool
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Buildah 包含到我们的 Go 构建工具中
- en: As a first step, we need to prepare our development environment, downloading
    and installing all the required tools and libraries for creating our custom build
    tool.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们需要准备我们的开发环境，下载并安装所有所需的工具和库来创建我们的自定义构建工具。
- en: In [*Chapter 3*](B17908_03_epub.xhtml#_idTextAnchor068), *Running the First
    Container*, we saw various Podman installation methods. In the following section,
    we will use a similar procedure while going through the preliminary steps for
    building a Buildah project from scratch, downloading its source file to include
    in our custom builder.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第3章*](B17908_03_epub.xhtml#_idTextAnchor068)，*运行第一个容器*，我们看到了一些 Podman 的安装方法。在接下来的章节中，我们将使用类似的过程，进行从头开始构建
    Buildah 项目的初步步骤，下载其源文件并将其包含在我们的自定义构建器中。
- en: 'First of all, let''s ensure we have all the needed packages installed on our
    development host system:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们确保在我们的开发主机系统上安装了所有所需的包：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After installing the Go language core libraries and some other development
    tools, we are ready to create the directory structure for our project and initialize
    it:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了 Go 语言核心库和一些其他开发工具后，我们已准备好为我们的项目创建目录结构并初始化它：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As shown in the previous example, we followed these steps:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的示例所示，我们按照以下步骤进行了操作：
- en: Created the project root directory
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了项目根目录
- en: Defined the Go language root path that we are going to use
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义了我们将要使用的 Go 语言根路径
- en: We are now ready to create our Go module that will create our customized container
    image with a few easy steps.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备创建我们的 Go 模块，它将通过几个简单的步骤来创建我们定制的容器镜像。
- en: 'To speed up the example and avoid any writing errors, we can download the Go
    language code that we are going to use for this test from the official GitHub
    repository of this book:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快示例并避免任何书写错误，我们可以从本书的官方 GitHub 仓库下载我们将要用于本次测试的 Go 语言代码：
- en: 'Go to [https://github.com/PacktPublishing/Podman-for-DevOps](https://github.com/PacktPublishing/Podman-for-DevOps)
    or run the following command:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 [https://github.com/PacktPublishing/Podman-for-DevOps](https://github.com/PacktPublishing/Podman-for-DevOps)
    或运行以下命令：
- en: '[PRE25]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After that, copy the files provided in the `Chapter07/*` directory into the
    newly created `~/custombuilder/` directory.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，将 `Chapter07/*` 目录中的文件复制到新创建的 `~/custombuilder/` 目录中。
- en: 'You should have the following files in your directory at this point:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的目录中应该有以下文件：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'At this point, we can run the following command to let the Go tools acquire
    all the needed dependencies to ready the module for execution:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以运行以下命令，让 Go 工具获取所有需要的依赖项，为执行模块做准备：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The tool analyzed the provided `custombuilder.go` file, and it found all the
    required libraries, populating the `go.mod` file.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 工具分析了提供的 `custombuilder.go` 文件，找到了所有所需的库，并填充了 `go.mod` 文件。
- en: Important Note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Please be aware that the previous command will verify whether a module is available,
    and if it is not, the tool will start downloading it from the internet. So, be
    patient during this step!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，之前的命令将验证模块是否可用，如果不可用，工具将开始从互联网下载它。所以在此步骤中请耐心等待！
- en: 'We can check that the previous commands downloaded all the required packages
    by inspecting the directory structure we created earlier:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查之前创建的目录结构来验证前面的命令是否下载了所有必需的包：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We are now ready to run our custom builder module, but before going forward,
    let's take a look at the key elements contained in the Go source file.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备运行我们的自定义构建器模块，但在继续之前，让我们看一下 Go 源文件中包含的关键元素。
- en: If we start looking at the `custombuilder.go` file, just after defining the
    package and the libraries to use, we defined the main function of our module.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们开始查看 `custombuilder.go` 文件，在定义包和要使用的库之后，我们定义了模块的主函数。
- en: 'In the main function, at the beginning of the definition, we inserted a fundamental
    code block:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数中，在定义的开始，我们插入了一个基本的代码块：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This piece of code enables the usage of `unshare` package, available through
    `github.com/containers/storage/pkg/unshare`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使得能够使用 `unshare` 包，该包可通过 `github.com/containers/storage/pkg/unshare` 获取。
- en: To leverage the build features of Buildah, we have to instantiate `buildah.Builder`.
    This object has all the methods to define the build steps, configure the build,
    and finally run it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用 Buildah 的构建功能，我们必须实例化 `buildah.Builder`。这个对象包含定义构建步骤、配置构建和最终运行构建的所有方法。
- en: 'To create `Builder`, we need an object called `storage.Store` from the `github.com/containers/storage`
    package. This element is responsible for storing the intermediate and resultant
    container images. Let''s see the code block we are discussing:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建 `Builder`，我们需要一个叫做 `storage.Store` 的对象，它来自 `github.com/containers/storage`
    包。这个元素负责存储中间的和最终的容器镜像。让我们来看一下我们正在讨论的代码块：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see from the previous example, we are getting the default options
    and passing them to the `storage` module to request a `Store` object.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中可以看到，我们获取了默认选项，并将其传递给 `storage` 模块来请求一个 `Store` 对象。
- en: 'Another element we need for creating `Builder` is the `BuilderOptions` object.
    This element contains all the default and custom options we might assign to Buildah''s
    `Builder`. Let''s see how to define it:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `Builder` 所需的另一个元素是 `BuilderOptions` 对象。这个元素包含我们可能分配给 Buildah 的 `Builder`
    的所有默认和自定义选项。让我们来看一下如何定义它：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the previous code block, we defined a `BuilderOptions` object that contains
    the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码块中，我们定义了一个 `BuilderOptions` 对象，其中包含以下内容：
- en: 'An initial image that we are going to use to build our target container image:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将用来构建目标容器镜像的初始镜像：
- en: In this case, we chose the Node.js image based on Alpine Linux distribution.
    This is because, in our example, we are simulating the build process of a Node.js
    application.
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们选择了基于 Alpine Linux 发行版的 Node.js 镜像。这是因为，在我们的示例中，我们正在模拟构建一个 Node.js
    应用程序的过程。
- en: Isolation mode to adopt once the build starts. In this case, we are going to
    use chroot isolation that fits a lot of build scenarios well – less isolation
    but fewer requirements.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建开始时采用的隔离模式。在这种情况下，我们将使用 chroot 隔离，它非常适合许多构建场景——隔离较少，但要求较低。
- en: 'Some default options for the build, network, and system contexts:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些构建、网络和系统上下文的默认选项：
- en: '`SystemContext` objects define the information contained in configuration files
    as parameters.'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SystemContext` 对象定义了包含在配置文件中的信息作为参数。'
- en: 'Now that we have all the necessary data for instantiating `Builder`, let''s
    do it:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有必要的数据来实例化 `Builder`，让我们来做吧：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, we are calling the `NewBuilder` function, with all the required
    options that we created in code earlier in this section, to get `Builder` ready
    to create our custom container image.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们调用了 `NewBuilder` 函数，传入了在本节前面代码中创建的所有必需选项，以准备好 `Builder` 来创建我们的自定义容器镜像。
- en: 'Now that we are ready to instruct `Builder` with the required options to create
    the custom image, let''s first add into the container image the **JavaScript**
    file containing our application, for which we are creating this container image:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好给 `Builder` 指定所需的选项来创建自定义镜像，首先让我们将包含我们应用程序的 **JavaScript** 文件添加到容器镜像中，正是为了这个容器镜像我们正在进行创建：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We are assuming that the JavaScript main file is stored next to the Go module
    that we are writing and using in this example, and we are copying this file into
    the `/home/node` directory, which is the default path where the base container
    image expects to find this kind of data.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设 JavaScript 主文件存储在我们正在编写并使用的 Go 模块旁边，并且我们将这个文件复制到 `/home/node` 目录中，这是基础容器镜像期望找到这种数据的默认路径。
- en: 'The JavaScript program that we are going to copy into the container image and
    use for this test is really simple – let''s inspect it:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将复制到容器镜像并用于此测试的 JavaScript 程序非常简单——让我们来查看一下：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Without going deep into the JavaScript language syntax and its concepts, we
    can note looking at the JavaScript file that we are using the HTTP library for
    listening on port `8080` for incoming requests, responding to these requests with
    a default welcome message: `Hello Podman and Buildah friends. This page is provided
    to you through a container running Node.js`. We also append the Node.js version
    to the response string.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在不深入探讨 JavaScript 语言语法及其概念的情况下，我们可以注意到，从这个 JavaScript 文件来看，我们使用了 HTTP 库来监听 `8080`
    端口上的传入请求，并用一个默认的欢迎信息来响应这些请求：`Hello Podman and Buildah friends. This page is provided
    to you through a container running Node.js`。我们还将 Node.js 的版本号附加到响应字符串中。
- en: Important Note
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Please consider that JavaScript, also known as **JS**, is a high-level programming
    language that is compiled just in time. As we stated earlier, we are neither going
    deep into the definition of the JavaScript language nor its most famous runtime
    environment, Node.js.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，JavaScript，也称为**JS**，是一种即时编译的高级编程语言。正如我们之前所说，我们既不会深入探讨JavaScript语言的定义，也不会深入Node.js这个最著名的运行时环境。
- en: 'After that, we configure the default command to run for our custom container
    image:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们配置了默认命令，以便为我们的自定义容器镜像运行：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We just set the command to execute the Node.js execution runtime, referring
    to the JavaScript program that we just added to the container image.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚设置了执行Node.js执行运行时的命令，指向我们刚刚添加到容器镜像中的JavaScript程序。
- en: 'For committing the changes we made, we need to get the image reference that
    we are working on. At the same time, we will also define the container image name
    that `Builder` will create:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提交我们所做的更改，我们需要获取正在处理的镜像引用。同时，我们还将定义`Builder`将创建的容器镜像名称：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we are ready to commit the changes and call the `commit` function of `Builder`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好提交更改并调用`Builder`的`commit`函数：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As we can see, we just requested `Builder` to commit the changes, passing the
    image reference we obtained earlier, and then we finally print it as a reference.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们只是请求`Builder`提交了更改，传递了我们之前获得的镜像引用，然后我们最终将其作为引用打印出来。
- en: 'We are now ready to run our program! Let''s execute it:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好运行我们的程序了！让我们执行它：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can now test the custom container image we just built:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以测试刚刚构建的自定义容器镜像：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As we can see in the previous code block, we are running the container image
    we just created with the following options:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码块中看到的，我们正在运行我们刚刚创建的容器镜像，并使用以下选项：
- en: '`-d`: Detached mode, which runs the container in the background'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`：分离模式，在后台运行容器'
- en: '`-t`: Allocates a new pseudo-TTY'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-t`：分配一个新的伪终端'
- en: '`-p`: Publishes the container port to the host system'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`：将容器端口发布到主机系统'
- en: '`podmanbook/nodejs-welcome:latest`: The name of our custom container image'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podmanbook/nodejs-welcome:latest`：我们自定义容器镜像的名称'
- en: Finally, we use the `curl` command-line tool for requesting and printing the
    HTTP response provided by our JavaScript program, which is containerized in the
    custom container image that we created!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`curl`命令行工具来请求并打印我们的JavaScript程序提供的HTTP响应，该程序被容器化到我们创建的自定义容器镜像中！
- en: Important Note
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The example described in this section is just a simple overview of all the great
    features that the Buildah Go module can enable for our custom image builders.
    To learn more about the various functions, variables, and code documentation,
    you can refer to the docs at [https://pkg.go.dev/github.com/containers/buildah](https://pkg.go.dev/github.com/containers/buildah).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述的示例仅是Buildah Go模块为我们自定义镜像构建器启用的所有强大功能的简要概述。要了解更多有关各种功能、变量和代码文档的信息，您可以参考[https://pkg.go.dev/github.com/containers/buildah](https://pkg.go.dev/github.com/containers/buildah)上的文档。
- en: As we saw in this section, Buildah is a really flexible tool, and with its libraries,
    it can support custom builders in many different scenarios.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节中看到的，Buildah是一个非常灵活的工具，凭借其库，它可以在许多不同的场景中支持自定义构建器。
- en: If we try to search on the internet, we can find many examples of Buildah supporting
    the creation of custom container images. Let's see some of them.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在互联网上搜索，可以找到许多关于Buildah支持创建自定义容器镜像的示例。让我们来看看其中的一些。
- en: Quarkus-native executables in containers
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Quarkus原生可执行文件在容器中的运行
- en: '**Quarkus** is defined as the Kubernetes-native Java stack leveraging OpenJDK
    (the open Java development kit) project and the GraalVM project. GraalVM is a
    Java virtual machine that has many special features, such as the compilation of
    Java applications for fast startup and low memory footprint.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**Quarkus**被定义为一个Kubernetes原生Java栈，利用OpenJDK（开放Java开发工具包）项目和GraalVM项目。GraalVM是一个具有许多特殊功能的Java虚拟机，例如为快速启动和低内存占用编译Java应用程序。'
- en: Important note
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We will not go into the details of Quarkus, GraalVM, and any other companion
    projects. The example that we will deep-dive into is only for your reference.
    We encourage you to learn more about these projects by going through their web
    pages and reading the related documentation.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入讨论Quarkus、GraalVM以及任何其他相关项目。我们将要深入研究的示例仅供参考。我们鼓励您通过浏览它们的网页和阅读相关文档来了解更多关于这些项目的信息。
- en: If we take a look at the Quarkus documentation web page, we can easily find
    that, after a long tutorial in which we can learn how to build a Quarkus-native
    executable, we can then pack and execute this executable in a container image.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看Quarkus文档网页，我们很容易发现，在经过一个长时间的教程之后，我们可以学习如何构建一个Quarkus原生可执行文件，接着我们可以将该可执行文件打包并在容器镜像中执行。
- en: 'The steps provided in the Quarkus documentation leverage a Maven wrapper with
    a special option. Maven was born as a Java build automation tool, but then it
    was also extended to other programming languages. If we take a quick look at this
    command, we will note the name of Podman inside:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus文档中提供的步骤利用了带有特殊选项的Maven包装器。Maven最初作为一个Java构建自动化工具诞生，但后来也扩展到了其他编程语言。如果我们快速查看这个命令，会注意到Podman的名字出现在其中：
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This means that the Maven wrapper program will invoke a Podman build to create
    a container image with the preconfigured environment shipped by the Quarkus project
    and the binary application that we are developing.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Maven包装器程序将调用Podman构建来创建一个包含由Quarkus项目提供的预配置环境以及我们正在开发的二进制应用程序的容器镜像。
- en: We saw the name of Podman inside the option. This is because, as we saw in [*Chapter
    6*](B17908_06_epub.xhtml#_idTextAnchor116), *Meet Buildah – Building Containers
    from Scratch*, Podman borrows Buildah's build logic by vendoring its libraries.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在选项中看到了Podman的名字。这是因为，正如我们在[*第6章*](B17908_06_epub.xhtml#_idTextAnchor116)中所看到的，*了解Buildah——从零构建容器*，Podman通过使用其库来借用Buildah的构建逻辑。
- en: To explore this example further, we can take a look at [https://quarkus.io/guides/building-native-image](https://quarkus.io/guides/building-native-image).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步探索这个示例，我们可以查看[https://quarkus.io/guides/building-native-image](https://quarkus.io/guides/building-native-image)。
- en: A Buildah wrapper for the Rust language
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust语言的Buildah包装器
- en: 'Another cool example of build tools made through the Buildah library or CLI
    is the Buildah wrapper for the **Rust** programming language. Rust is a programming
    language similar to C++, designed for performance and safe concurrency. The main
    project page is available at this URL: [https://github.com/Dennis-Krasnov/Buildah-Rust](https://github.com/Dennis-Krasnov/Buildah-Rust).'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个通过Buildah库或CLI制作的酷工具示例是Rust编程语言的Buildah包装器。Rust是一种类似C++的编程语言，旨在提供性能和安全的并发。其主项目页面可以在以下网址找到：[https://github.com/Dennis-Krasnov/Buildah-Rust](https://github.com/Dennis-Krasnov/Buildah-Rust)。
- en: This Buildah wrapper leverages the Rust package manager names **Cargo** for
    downloading the needed dependencies, compiles it in a package, and makes it distributable.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Buildah包装器利用Rust包管理器**Cargo**来下载所需的依赖项，将其编译成一个包，并使其可分发。
- en: Important Note
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We will not go into the details of Rust, Cargo, and any other companion projects.
    The example that we will deep-dive into is only for your reference. We encourage
    you to learn more about these projects by going through their web pages and reading
    the related documentation.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入Rust、Cargo以及其他相关项目的细节。我们将深入探讨的示例仅供参考。我们鼓励你通过浏览这些项目的网页并阅读相关文档，来了解更多关于这些项目的知识。
- en: 'The example in the project homepage is really simple, as you can see in the
    following code block:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 项目主页中的示例非常简单，如下所示的代码块：
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The first command, after selecting the directory named `examples`, executes
    a simple block of code that is needed to create a container, while the second
    tests the container image that the Buildah wrapper has just made through Buildah
    itself.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令，在选择名为`examples`的目录后，执行一个简单的代码块，创建容器所需的代码，而第二个命令则通过Buildah本身测试刚刚由Buildah包装器创建的容器镜像。
- en: 'We can take a look at the Rust code used in the first command of the previous
    code block. The first command executes the small piece of code in the `nginx.rs`
    file:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看在之前代码块中的第一个命令使用的Rust代码。第一个命令执行的是`nginx.rs`文件中的一小段代码：
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As stated before, we will not dive deep into the code syntax or into the library
    itself; anyway, the code is pretty simple, and it just imports the Buildah wrapper
    library, creates a container image starting from `nginx:1.21`, and finally, copies
    the local `html` directory to the container image's destination path.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们不会深入探讨代码语法或库本身；无论如何，代码相当简单，它只是导入了Buildah包装器库，从`nginx:1.21`创建容器镜像，最后将本地的`html`目录复制到容器镜像的目标路径。
- en: To explore this example further, take a look at [https://github.com/Dennis-Krasnov/Buildah-Rust](https://github.com/Dennis-Krasnov/Buildah-Rust).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步探索这个示例，查看[https://github.com/Dennis-Krasnov/Buildah-Rust](https://github.com/Dennis-Krasnov/Buildah-Rust)。
- en: This concludes this section. We have learned, through a lot of useful examples,
    about how to integrate Buildah in different scenarios to support custom builders
    of the container images of our projects.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 本节到此结束。通过许多有用的示例，我们了解了如何在不同的场景中集成 Buildah，以支持我们项目的容器镜像自定义构建器。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned how to leverage Podman's companion, Buildah,
    in some advanced scenarios to support our development projects.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在一些高级场景中利用 Podman 的伙伴工具 Buildah 来支持我们的开发项目。
- en: We saw how to use Buildah for multistage container image creation, which allows
    us to create builds with multiple stages using different `FROM` instructions and,
    subsequently, to have images that grab contents from the previous ones.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了如何使用 Buildah 进行多阶段容器镜像创建，这使得我们可以使用不同的 `FROM` 指令创建多个阶段的构建，随后拥有从之前阶段抓取内容的镜像。
- en: Then, we discovered that there are many use cases that imply the need for containerized
    builds. Nowadays, one of the most common adoption scenarios is the application
    build workflow running on top of a Kubernetes cluster. For this reason, we went
    into the details of containerizing Buildah.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们发现有许多使用场景需要容器化构建。如今，最常见的采用场景之一是应用构建工作流运行在 Kubernetes 集群之上。基于此，我们深入探讨了容器化
    Buildah。
- en: Finally, we learned through a lot of interesting examples how to integrate Buildah
    to create custom builders for container images. As we saw in this chapter, there
    are several options and methods to actually build a container image with the Podman
    ecosystem tools, and most of the time, we usually start from a base image for
    customizing and extending a previous OS layer to fit our use cases.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过大量有趣的示例，我们学习了如何集成 Buildah 来创建容器镜像的自定义构建器。正如本章所示，实际上有几种选择和方法可以使用 Podman
    生态系统工具来构建容器镜像，而且大多数时候，我们通常是从基础镜像开始，定制和扩展前一个操作系统层，以适应我们的使用场景。
- en: In the next chapter, we will learn more about container base images, how to
    choose them, and what to look out for when we are making our choice.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步了解容器基础镜像，如何选择它们，以及在选择时需要注意的事项。
- en: Further readings
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'A list of CNCF projects: [https://landscape.cncf.io/](https://landscape.cncf.io/)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'CNCF 项目列表: [https://landscape.cncf.io/](https://landscape.cncf.io/)'
- en: '*Best practices for running Buildah in a container*: [https://developers.redhat.com/blog/2019/08/14/best-practices-for-running-buildah-in-a-container](https://developers.redhat.com/blog/2019/08/14/best-practices-for-running-buildah-in-a-container)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在容器中运行 Buildah 的最佳实践*: [https://developers.redhat.com/blog/2019/08/14/best-practices-for-running-buildah-in-a-container](https://developers.redhat.com/blog/2019/08/14/best-practices-for-running-buildah-in-a-container)'
- en: 'The Buildah Go module documentation: [https://pkg.go.dev/github.com/containers/buildah](https://pkg.go.dev/github.com/containers/buildah)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Buildah Go 模块文档: [https://pkg.go.dev/github.com/containers/buildah](https://pkg.go.dev/github.com/containers/buildah)'
- en: 'Quarkus-native executables: [https://quarkus.io/guides/building-native-image](https://quarkus.io/guides/building-native-image)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Quarkus 本地可执行文件: [https://quarkus.io/guides/building-native-image](https://quarkus.io/guides/building-native-image)'
- en: 'The Buildah wrapper for the Rust language: [https://github.com/Dennis-Krasnov/Buildah-Rust](https://github.com/Dennis-Krasnov/Buildah-Rust)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Buildah Rust 语言封装: [https://github.com/Dennis-Krasnov/Buildah-Rust](https://github.com/Dennis-Krasnov/Buildah-Rust)'
