- en: '*Chapter 8*: Choosing the Container Base Image'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：选择容器基础镜像'
- en: 'The fastest and easiest way to learn about and get some experience with containers
    is to start working with pre-built container images, as we saw in the previous
    chapters. After a deep dive into container management, we discovered that sometimes,
    the available service, its configuration, or even the application version is not
    the one that our project requires. Then, we introduced Buildah and its feature
    for building custom container images. In this chapter, we are going to address
    another important topic that is often questioned in community and enterprise projects:
    the choice of a **container base image**.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 学习容器并获得一些经验的最快和最简单方法是开始使用预构建的容器镜像，正如我们在前几章中看到的那样。在深入研究容器管理后，我们发现有时可用的服务、其配置或甚至应用程序版本并不是我们项目所需要的。接着，我们介绍了
    Buildah 及其用于构建自定义容器镜像的功能。在本章中，我们将讨论另一个在社区和企业项目中常被提问的重要话题：**容器基础镜像**的选择。
- en: 'Choosing the right container base image is an important task of the container
    journey: a container base image is the underlying operating system layer that
    our system''s service, application, or code will rely on. Due to this, we should
    choose one that fits our best practices concerning security and updates.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的容器基础镜像是容器之旅中的一项重要任务：容器基础镜像是我们的系统服务、应用程序或代码所依赖的底层操作系统层。因此，我们应该选择一个符合安全性和更新最佳实践的镜像。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: The Open Container Initiative image format
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放容器倡议镜像格式
- en: Where do container images come from?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像来自哪里？
- en: Trusted container image sources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可信的容器镜像来源
- en: Introducing Universal Base Image
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍通用基础镜像
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete this chapter, you will need a machine with a working Podman installation.
    As stated in [*Chapter 3*](B17908_03_epub.xhtml#_idTextAnchor068), *Running the
    First Container*, all the examples in this book have been executed on a Fedora
    34 system or later but can be reproduced on an operating system of your choice.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章内容，您需要一台安装了 Podman 的工作机器。正如在[*第3章*](B17908_03_epub.xhtml#_idTextAnchor068)《运行第一个容器》中所述，本书中的所有示例都已在
    Fedora 34 或更高版本的系统上执行，但也可以在您选择的操作系统上重现。
- en: Having a good understanding of the topics that we covered in [*Chapter 4*](B17908_04_epub.xhtml#_idTextAnchor083),
    *Managing Running Containers*, will help you easily grasp concepts regarding container
    images.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们在[*第4章*](B17908_04_epub.xhtml#_idTextAnchor083)《管理运行中的容器》中涉及的内容有一个良好的理解，将帮助您轻松掌握有关容器镜像的概念。
- en: The Open Container Initiative image format
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开放容器倡议镜像格式
- en: As we described in [*Chapter 1*](B17908_01_epub.xhtml#_idTextAnchor015), *Introduction
    to Container Technology*, back in 2013, Docker was introduced in the container
    landscape and became very popular rapidly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第1章*](B17908_01_epub.xhtml#_idTextAnchor015)《容器技术简介》中所描述的那样，早在 2013 年，Docker
    就在容器领域推出并迅速变得非常流行。
- en: At a high level, the Docker team introduced the concept of container images
    and container registries, which was a game-changer. Another important step was
    being able to *extract* containerd projects from Docker and donate them to the
    **Cloud Native Computing Foundation** (**CNCF**). This motivated the open source
    community to start working seriously on container engines that could be injected
    into an orchestration layer, such as Kubernetes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，Docker 团队引入了容器镜像和容器注册表的概念，这改变了游戏规则。另一个重要的步骤是能够将 containerd 项目从 Docker
    中提取并捐赠给 **云原生计算基金会**（**CNCF**）。这激励了开源社区开始认真开发可以注入到编排层（如 Kubernetes）的容器引擎。
- en: Similarly, in 2015, Docker, with the help of many other companies (Red Hat,
    AWS, Google, Microsoft, IBM, and others), started the **Open Container Initiative**
    (**OCI**) under the Linux Foundation umbrella.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，在 2015 年，Docker 在许多其他公司（如 Red Hat、AWS、Google、Microsoft、IBM 等）的帮助下，启动了 **开放容器倡议**（**OCI**），该倡议隶属于
    Linux 基金会。
- en: These contributors developed the Runtime Specification (runtime-spec) and the
    Image Specification (image-spec) to describe how the API and the architecture
    for new container engines should be created in the future.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些贡献者开发了运行时规范（runtime-spec）和镜像规范（image-spec），用于描述未来新容器引擎的 API 和架构应该如何创建。
- en: After a few months of work, the OCI team released its first implementation of
    a container engine that adhered to the OCI's specifications; the project was named
    `runc`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个月的工作后，OCI团队发布了其第一个符合OCI规范的容器引擎实现；该项目被命名为`runc`。
- en: It's worth looking at the container image specification in detail and going
    over some theory behind the practice, which we introduced in [*Chapter 2*](B17908_02_epub.xhtml#_idTextAnchor044),
    *Comparing Podman and Docker*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 值得详细了解容器镜像规范，并复习一些理论背景，我们在[*第2章*](B17908_02_epub.xhtml#_idTextAnchor044)，*比较Podman和Docker*
    中做了介绍。
- en: 'The specification defines an OCI container image that consists of the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该规范定义了一个OCI容器镜像，包含以下内容：
- en: '**Manifest**: This contains the metadata of the contents and dependencies of
    the image. This also includes the ability to identify one or more filesystem archives
    that will be unpacked to get the final runnable filesystem.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清单**：包含镜像内容和依赖项的元数据。这还包括识别一个或多个文件系统归档的能力，这些文件系统将被解压缩以获得最终的可运行文件系统。'
- en: '**Image Index (optional)**: This represents a list of manifests and descriptors
    that can provide different implementations of the image, depending on the target
    platform.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**镜像索引（可选）**：表示一个清单和描述符列表，可以根据目标平台提供镜像的不同实现。'
- en: '**Set of Filesystem Layers**: The actual set of layers that should be merged
    to build the final container filesystem.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件系统层集**：应合并的实际层集，以构建最终的容器文件系统。'
- en: '**Configuration**: This contains all the information that''s required by the
    container runtime engine to effectively run the application, such as arguments,
    environment variables, and so on.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：包含容器运行时引擎有效运行应用程序所需的所有信息，例如参数、环境变量等。'
- en: We will not deep dive into every element of the OCI Image Specification, but
    the Image Manifest deserves a closer look.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨OCI镜像规范的每个元素，但镜像清单值得仔细研究。
- en: OCI Image Manifest
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OCI镜像清单
- en: The Image Manifest defines a set of layers and the configuration for a single
    container image that is built for a specific architecture and an operating system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像清单定义了一组层和配置，用于为特定架构和操作系统构建的单个容器镜像。
- en: 'Let''s explore the details of the OCI Image Manifest by looking at the following
    example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看以下示例来探索OCI镜像清单的详细信息：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we are using the following keywords:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用以下关键字：
- en: '`schemaVersion`: A property that must be set to a value of `2`. This ensures
    backward compatibility with Docker.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`schemaVersion`：一个必须设置为`2`的属性，确保与Docker的向后兼容性。'
- en: '`config`: A property that references a container''s configuration through a
    digest:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`：引用容器配置的属性，通过摘要来标识：'
- en: '`mediaType`: This property defines the actual configuration format (just one
    currently).'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mediaType`：该属性定义了实际的配置格式（目前仅有一种）。'
- en: '`layers`: This property provides an array of descriptor objects:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layers`：该属性提供了一组描述符对象的数组：'
- en: '`MediaType`: In this case, this descriptor should be one of the media types
    that''s allowed for the layer''s descriptors.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MediaType`：在这种情况下，该描述符应该是层描述符允许的媒体类型之一。'
- en: '`annotations`: This property defines additional metadata for the image manifest.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`annotations`：该属性定义了镜像清单的附加元数据。'
- en: To summarize, the main goal of the specification is to make interoperable tools
    for building, transporting, and preparing a container image to be run.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，该规范的主要目标是创建可互操作的工具，用于构建、传输和准备容器镜像以运行。
- en: 'The Image Manifest Specification has three main goals:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像清单规范有三个主要目标：
- en: To enable hashing for the image's configuration, thereby generating a unique
    ID
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了启用镜像配置的哈希处理，从而生成唯一的ID
- en: To allow multi-architecture images due to its high-level manifest (image index)
    that references platform-specific versions of the image manifest
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许多架构镜像，因为其高级清单（镜像索引）引用了针对特定平台的镜像清单版本。
- en: To be able to easily translate the container image into the OCI Runtime Specification
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够轻松将容器镜像转换为OCI运行时规范
- en: Now, let's learn where these container images come from.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来了解这些容器镜像的来源。
- en: Where do container images come from?
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器镜像从哪里来？
- en: In the previous chapters, we used pre-built images to run, build, or manage
    a container, but where do these container images come from?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了预构建的镜像来运行、构建或管理容器，但这些容器镜像从哪里来呢？
- en: How can we dig into their source commands or into the Dockerfile/ContainerFile
    that's used to build it?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何深入了解它们的源命令或用于构建镜像的 Dockerfile/ContainerFile 呢？
- en: Well, as we've mentioned previously, Docker introduced the concept of container
    image and Container Registry for storing these images – even publicly. The most
    famous Container Registry is Docker Hub but after Docker's introduction, other
    cloud container registries were released too.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，Docker 引入了容器镜像和容器注册中心的概念，用于存储这些镜像——甚至是公开存储。最著名的容器注册中心是 Docker Hub，但在
    Docker 推出之后，其他云容器注册中心也陆续发布。
- en: 'We can choose between the following cloud container registries:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下云容器注册中心之间进行选择：
- en: '**Docker Hub**: This is the hosted registry solution by Docker Inc. This registry
    also hosts official repositories and security verified images for some popular
    open source projects.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Hub**：这是 Docker 公司提供的托管注册中心解决方案。该注册中心还托管官方仓库和经过安全验证的镜像，供一些流行的开源项目使用。'
- en: '**Quay**: This is the hosted registry solution that was born under the CoreOS
    company, though it is now part of Red Hat. It offers private and public repositories,
    automated scanning for security purposes, image builds, and integration with popular
    Git public repositories.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Quay**：这是由 CoreOS 公司创建的托管注册中心解决方案，现已成为 Red Hat 的一部分。它提供私有和公有仓库、用于安全目的的自动扫描、镜像构建以及与流行
    Git 公共仓库的集成。'
- en: '**Linux Distribution Registries**: Popular Linux distributions are typically
    community-based, such as Fedora Linux, or enterprise-based, such as **Red Hat
    Enterprise Linux** (**RHEL**). They usually offer public container registries,
    though these are often only available for projects or packages that have already
    been provided as system packages. These registries are not available to end users
    and they are fed by the Linux distributions'' maintainers.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux 发行版注册中心**：流行的 Linux 发行版通常是社区驱动的，比如 Fedora Linux，或企业驱动的，比如 **Red Hat
    Enterprise Linux** (**RHEL**) 。它们通常提供公共容器注册中心，但这些注册中心通常只提供已经作为系统包发布的项目或软件包。这些注册中心不对最终用户开放，它们由
    Linux 发行版的维护者提供支持。'
- en: '**Public Cloud Registries**: Amazon, Google, Microsoft, and other public cloud
    providers offer private container registries for their customers.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共云注册中心**：Amazon、Google、Microsoft 以及其他公共云服务提供商为他们的客户提供私有容器注册中心。'
- en: We will explore these registries in more detail in [*Chapter 9*](B17908_09_epub.xhtml#_idTextAnchor167),
    *Pushing Images to a Container Registry*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第9章*](B17908_09_epub.xhtml#_idTextAnchor167)《推送镜像到容器注册中心》中更详细地探讨这些注册中心。
- en: Docker Hub, as well as Quay.io, are public container registries where we can
    find container images that have been created by anyone. These registries are full
    of useful custom images that we can use as starting points for testing container
    images quickly and easily.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 和 Quay.io 是公共容器注册中心，任何人都可以在这些注册中心中找到已创建的容器镜像。这些注册中心充满了有用的自定义镜像，我们可以将其作为快速轻松测试容器镜像的起点。
- en: Just downloading and running a container image is not always the best thing
    to do – we could hit very old and outdated software that could be vulnerable to
    some known public vulnerability or, even worse, we could download and execute
    some malicious code that could compromise our whole infrastructure.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅下载并运行容器镜像并不总是最佳选择——我们可能会遇到非常旧且过时的软件，这些软件可能存在已知的公共漏洞，或者更糟糕的是，我们可能会下载并执行某些恶意代码，从而危及整个基础设施的安全。
- en: For this reason, Docker Hub and Quay.io usually offer features to underline
    where such images come from. Let's inspect them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，Docker Hub 和 Quay.io 通常会提供一些功能，以强调这些镜像的来源。让我们检查一下它们。
- en: Docker Hub container registry service
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Hub 容器注册中心服务
- en: As we introduced earlier, Docker Hub is the most famous Container Registry available.
    It hosts multiple container images for community and enterprise products.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前介绍的，Docker Hub 是最著名的容器注册中心，提供多种容器镜像，涵盖社区和企业产品。
- en: 'By looking at the detail page of a container image, we can easily discover
    all the required information about that project and its container images. The
    following screenshot shows Alpine Linux''s Docker Hub page:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看容器镜像的详细页面，我们可以轻松发现关于该项目及其容器镜像的所有必要信息。以下截图展示了 Alpine Linux 在 Docker Hub 上的页面：
- en: '![Figure 8.1 – Alpine Linux container image on Docker Hub'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1 – Docker Hub 上的 Alpine Linux 容器镜像](img/B17908_08_01.jpg)'
- en: '](img/B17908_08_01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17908_08_01.jpg)'
- en: Figure 8.1 – Alpine Linux container image on Docker Hub
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – Docker Hub 上的 Alpine Linux 容器镜像
- en: As you can see, at the top of the page, we can find helpful information, the
    latest tags, the supported architectures, and useful links to the project's documentation
    and the issue-reporting system.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在页面顶部，我们可以找到有用的信息，包括最新的标签、支持的架构以及指向项目文档和问题报告系统的有用链接。
- en: On the Docker Hub page, we can find the *Official Image* tag, just after the
    image's name, when that image is part of Docker's Official Images program. The
    images in this program are curated directly by the Docker team in collaboration
    with the upstream projects' maintainers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker Hub 页面上，当镜像属于 Docker 官方镜像计划时，我们可以在镜像名称后找到 *官方镜像* 标签。此计划中的镜像由 Docker
    团队与上游项目的维护者直接合作进行管理。
- en: Important note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: If you want to look at this page in more depth, point your web browser to [https://hub.docker.com/_/alpine](https://hub.docker.com/_/alpine).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更深入地查看此页面，请在网页浏览器中输入 [https://hub.docker.com/_/alpine](https://hub.docker.com/_/alpine)。
- en: Another important feature that's offered by Docker Hub (not only for official
    images) is the ability to look into the Dockerfile that was used to create a certain
    image.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 提供的另一个重要功能（不仅适用于官方镜像）是查看用于创建某个镜像的 Dockerfile。
- en: If we click on one of the available tags on the container image page, we can
    easily look at the Dockerfile of that container image tag.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击容器镜像页面上的某个可用标签，我们可以轻松查看该容器镜像标签的 Dockerfile。
- en: 'Clicking on the tag named `20210804, edge` on that page will redirect us to
    the GitHub page of the `docker-alpine` project, which is defined as the following
    Dockerfile: [https://github.com/alpinelinux/docker-alpine/blob/edge/x86_64/Dockerfile](https://github.com/alpinelinux/docker-alpine/blob/edge/x86_64/Dockerfile).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 点击该页面上名为 `20210804, edge` 的标签将会将我们重定向到 `docker-alpine` 项目的 GitHub 页面，该项目的 Dockerfile
    如下所示：[https://github.com/alpinelinux/docker-alpine/blob/edge/x86_64/Dockerfile](https://github.com/alpinelinux/docker-alpine/blob/edge/x86_64/Dockerfile)。
- en: We should always pay attention and prefer official images. If an official image
    is not available or it does not fit our needs, then we need to inspect the Dockerfile
    that the content creator published, as well as the container image.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应始终注意并优先选择官方镜像。如果没有官方镜像，或它不符合我们的需求，那么我们需要检查内容创建者发布的 Dockerfile 和容器镜像。
- en: Quay container registry service
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Quay 容器注册服务
- en: Quay is a container registry service that was acquired by CoreOS in 2014 and
    is now part of the Red Hat ecosystem.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Quay 是一个容器注册服务，2014年被 CoreOS 收购，现在是 Red Hat 生态系统的一部分。
- en: The registry allows its users to be more cautious once they've chosen a container
    image by providing security scanning software.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 该注册表允许用户在选择容器镜像后更加小心，因为它提供了安全扫描软件。
- en: 'Quay adopts the Clair project, a leading container vulnerability scanner that
    displays reports on the repository tags web page, as shown in the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Quay 采用 Clair 项目，这是一款领先的容器漏洞扫描工具，会在仓库标签网页上显示报告，如以下截图所示：
- en: '![Figure 8.2 – Quay vulnerability Security Scan page'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – Quay 漏洞安全扫描页面'
- en: '](img/B17908_08_02.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17908_08_02.jpg)'
- en: Figure 8.2 – Quay vulnerability Security Scan page
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – Quay 漏洞安全扫描页面
- en: On this page, we can click on **Security Scan** to inspect the details of that
    security scan. If you want to learn more about this feature, please go to [https://quay.io/repository/openshift-release-dev/ocp-release?tab=tags](https://quay.io/repository/openshift-release-dev/ocp-release?tab=tags).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在此页面上，我们可以点击 **Security Scan** 来检查该安全扫描的详细信息。如果您想了解更多关于此功能的信息，请访问 [https://quay.io/repository/openshift-release-dev/ocp-release?tab=tags](https://quay.io/repository/openshift-release-dev/ocp-release?tab=tags)。
- en: As we've seen, using a public registry that offers every user the security scan
    feature could help ensure that we choose the right and most secure flavor of the
    container image we are searching for.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，使用一个提供安全扫描功能的公共注册表可以帮助确保我们选择到正确且最安全的容器镜像。
- en: Red Hat Ecosystem Catalog
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Red Hat 生态系统目录
- en: The Red Hat Ecosystem Catalog is the default container registry for **Red Hat
    Enterprise Linux** (**RHEL**) and Red Hat **OpenShift Container Platform** (**OCP**)
    users. The web interface of this registry is publicly accessible to any users,
    whether they are authenticated or not, although almost all the images that are
    provided are reserved for paid users (RHEL or OCP users).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Red Hat 生态系统目录是 **Red Hat Enterprise Linux** (**RHEL**) 和 Red Hat **OpenShift
    容器平台** (**OCP**) 用户的默认容器注册表。该注册表的网页界面对任何用户开放，无论他们是否经过身份验证，尽管几乎所有提供的镜像都仅限于付费用户（RHEL
    或 OCP 用户）。
- en: 'We are talking about this registry because it combines all the features we
    talked about previously. This registry offers the following to its users:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们谈论这个注册表，是因为它结合了我们之前讨论的所有功能。这个注册表为用户提供以下功能：
- en: Official container images by Red Hat
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Red Hat 官方容器镜像
- en: ContainerFile/Dockerfile sources to inspect the content of the image
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ContainerFile/Dockerfile 源代码，用于检查镜像内容
- en: Security reports (index) about every container image that's distributed
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个分发的容器镜像的安全报告（索引）
- en: 'The following screenshot shows what this information looks like on the **Red
    Hat Ecosystem Catalog** page:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了在**Red Hat 生态系统目录**页面上，该信息的显示方式：
- en: '![Figure 8.3 – MariaDB container image description page on the Red Hat Ecosystem
    Catalog'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – Red Hat 生态系统目录中的 MariaDB 容器镜像描述页面'
- en: '](img/B17908_08_03.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17908_08_03.jpg)'
- en: Figure 8.3 – MariaDB container image description page on the Red Hat Ecosystem
    Catalog
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – Red Hat 生态系统目录中的 MariaDB 容器镜像描述页面
- en: 'As we can see, the page shows the description of the container image we have
    selected (MariaDB database), the version, the available architectures, and various
    tags that can be selected from the respective drop-down menu. Some tabs also mention
    the keywords we are interested in: *Security* and *Dockerfile*.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，页面展示了我们选择的容器镜像（MariaDB 数据库）的描述、版本、可用架构以及可从相应下拉菜单中选择的各种标签。有些选项卡还提到了我们感兴趣的关键字：*Security*
    和 *Dockerfile*。
- en: 'By clicking on the **Security** tab, we can see the status of the vulnerability
    scan that was executed for that image tag, as shown in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击**Security**选项卡，我们可以看到针对该镜像标签执行的漏洞扫描状态，如以下截图所示：
- en: '![Figure 8.4 – MariaDB container image Security page on the Red Hat Ecosystem
    Catalog'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.4 – Red Hat 生态系统目录中的 MariaDB 容器镜像安全页面'
- en: '](img/B17908_08_04.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17908_08_04.jpg)'
- en: Figure 8.4 – MariaDB container image Security page on the Red Hat Ecosystem
    Catalog
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – Red Hat 生态系统目录中的 MariaDB 容器镜像安全页面
- en: As we can see, at the time of writing, for this latest image tag, a security
    vulnerability has already been identified that's affecting three packages. To
    the right, we can find the Red Hat Advisory ID, which is linked to the public
    **Common Vulnerabilities and Exposures** (**CVEs**).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在撰写本文时，针对这个最新的镜像标签，已经识别出一个影响三个软件包的安全漏洞。在右侧，我们可以找到 Red Hat 咨询 ID，并且该 ID
    链接到公共的**常见漏洞与暴露**（**CVE**）列表。
- en: 'By clicking on the **Dockerfile** tab, we can look at the source ContainerFile
    that was used to build that container image:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击**Dockerfile**选项卡，我们可以查看用于构建该容器镜像的源 ContainerFile：
- en: '![Figure 8.5 – MariaDB container image Dockerfile page on Red Hat Ecosystem
    Catalog'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.5 – Red Hat 生态系统目录中的 MariaDB 容器镜像 Dockerfile 页面'
- en: '](img/B17908_08_05.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17908_08_05.jpg)'
- en: Figure 8.5 – MariaDB container image Dockerfile page on Red Hat Ecosystem Catalog
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – Red Hat 生态系统目录中的 MariaDB 容器镜像 Dockerfile 页面
- en: As we can see, we can look at the source ContainerFile that was used to build
    the container image we are going to pull and run. This is a great feature that
    we can access by clicking on the same description page of the container image
    we are looking for.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们可以查看用于构建我们将拉取并运行的容器镜像的源 ContainerFile。这是一个很棒的功能，我们可以通过点击容器镜像描述页面来访问它。
- en: 'If we take a closer look at the preceding screenshot, we can see that the MariaDB
    container image was built using a very special container base image: UBI8\.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细查看前面的截图，可以看到 MariaDB 容器镜像是使用一个非常特殊的容器基础镜像构建的：UBI8\。
- en: '**UBI** stands for **Universal Base Image**. It is an initiative that was launched
    by Red Hat that lets every user (Red Hat customers or not) open Red Hat container
    images. This allows the Red Hat ecosystem to expand by leveraging all the previously
    mentioned services that are offered by the Red Hat Ecosystem Catalog, as well
    as by leveraging the updated packages that are directly from Red Hat.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**UBI** 代表**通用基础镜像**。它是由 Red Hat 推出的一个倡议，允许每个用户（无论是否是 Red Hat 客户）打开 Red Hat
    容器镜像。这使得 Red Hat 生态系统能够通过利用 Red Hat 生态系统目录中提供的所有服务，并借助直接来自 Red Hat 的更新包，进一步扩展。'
- en: We will talk more about UBI and its container images later in this chapter.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面进一步讨论 UBI 及其容器镜像。
- en: Trusted container image sources
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可信的容器镜像源
- en: In the previous section, we defined the central role of the image registry as
    a source of truth for valid, usable images. In this section, we want to stress
    the importance of adopting trusted images that come from trusted sources.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们定义了镜像注册表在有效、可用镜像中的核心作用。接下来，我们要强调的是，采用来自可信来源的镜像的重要性。
- en: An OCI image is used to package binaries and runtimes in a structured filesystem
    with the purpose of delivering a specific service. When we pull that image and
    run it on our systems without any kind of control, we implicitly trust the author
    to not have tampered with its content by using malicious components. But nowadays,
    trust is something that cannot be granted so easily.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: OCI 镜像用于将二进制文件和运行时打包成结构化文件系统，目的是提供特定服务。当我们拉取该镜像并在系统上运行它时，如果没有任何控制措施，我们隐式地信任作者没有使用恶意组件篡改其内容。但如今，信任是无法轻易授予的。
- en: 'As we will see in [*Chapter 11*](B17908_11_epub.xhtml#_idTextAnchor206), *Securing
    Containers*, there are many attack use cases and malicious behaviors that can
    be conducted from a container: privilege escalation, data exfiltration, and miners
    are just a few examples. These behaviors can be amplified when containers that
    are run inside Kubernetes clusters (many thousands of clusters) can spawn malicious
    pods across the infrastructure easily.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第11章*](B17908_11_epub.xhtml#_idTextAnchor206)《*容器安全*》中所看到的那样，容器中可能存在许多攻击用例和恶意行为：特权升级、数据外泄和挖矿只是其中的几个例子。当容器在
    Kubernetes 集群（数以千计的集群）中运行时，这些行为可能会被放大，因为它们可以轻松地跨基础设施生成恶意的 pod。
- en: To help security teams mitigate this, the MITRE Corporation periodically releases
    **MITRE ATT&CK** matrices to identify all the possible attack strategies and their
    related techniques, with real-life use cases, and their detection and mitigation
    best practices. One of these matrixes is dedicated to containers, where many techniques
    are implemented based on insecure images where malicious behaviors can be conducted
    successfully.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助安全团队缓解这个问题，MITRE 公司定期发布**MITRE ATT&CK** 矩阵，旨在识别所有可能的攻击策略及其相关技术，提供实际案例，并列出检测和缓解的最佳实践。这些矩阵中有一部分专门针对容器，其中许多技术是基于不安全镜像实现的，在这些镜像中可以成功地执行恶意行为。
- en: Important Note
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should prefer images that come from a registry that supports vulnerability
    scans. If the scan results are available, check them carefully and avoid using
    images that spot critical vulnerabilities.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该优先选择来自支持漏洞扫描的注册表的镜像。如果扫描结果可用，务必仔细检查，并避免使用发现严重漏洞的镜像。
- en: With this in mind, what is the first step for creating a secure cloud-native
    infrastructure? The answer is choosing images that only come from trusted sources,
    and the first step is to configure trusted registries and patterns to block disallowed
    ones. We will cover this in the following subsection.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，创建安全的云原生基础设施的第一步是什么？答案是选择仅来自可信来源的镜像，而第一步是配置可信注册表和模式，以阻止不允许的注册表。我们将在接下来的小节中介绍这一点。
- en: Managing trusted registries
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理可信注册表
- en: As shown in [*Chapter 3*](B17908_03_epub.xhtml#_idTextAnchor068), *Running the
    First Container*, in the *Preparing your environment* section, Podman can manage
    trusted registries with config files.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[*第3章*](B17908_03_epub.xhtml#_idTextAnchor068)《*运行第一个容器*》的《*准备环境*》一节中所示，Podman
    可以通过配置文件管理可信注册表。
- en: The `/etc/containers/registries.conf` file (overridden by the user-related `$HOME/.config/containers/registries.conf`
    file, if present) manages a list of trusted registries that Podman can safely
    contact to search and pull images.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/containers/registries.conf` 文件（如果存在，被用户相关的 `$HOME/.config/containers/registries.conf`
    文件覆盖）管理着一个信任的注册表列表，Podman 可以安全地联系这些注册表来搜索和拉取镜像。'
- en: 'Let''s look at an example of this file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个文件示例：
- en: '[PRE1]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This file helps us define the trusted registries that can be used by Podman,
    so it deserves a detailed analysis.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件帮助我们定义 Podman 可以使用的可信注册表，因此值得进行详细分析。
- en: 'Podman accepts both **unqualified** and **fully-qualified** images. The difference
    is quite simple and can be illustrated as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 接受**未完全限定**和**完全限定**的镜像。两者的区别非常简单，可以通过以下方式说明：
- en: A fully-qualified image includes a registry server FQDN, namespace, image name,
    and tag. For example, `docker.io/library/nginx:latest` is a fully-qualified image.
    It has a full name that cannot be confused with any other Nginx image.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全限定的镜像包括注册表服务器 FQDN、命名空间、镜像名称和标签。例如，`docker.io/library/nginx:latest` 就是一个完全限定的镜像。它有一个完整的名称，无法与任何其他
    Nginx 镜像混淆。
- en: An unqualified image only includes the image's name. For example, the `nginx`
    image can have multiple instances in the searched registries. The majority of
    the images that result from the basic `podman search nginx` command will not be
    official and should be analyzed in detail to ensure they're trusted. The output
    can be filtered by the `OFFICIAL` flag and by the number of `STARS` (more is better).
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未限定的镜像只包括镜像的名称。例如，`nginx`镜像在搜索的注册表中可能有多个实例。大多数通过基本命令`podman search nginx`得到的镜像都不是官方镜像，应当进行详细分析以确保它们是可信的。输出可以通过`OFFICIAL`标志和`STARS`数量（更多更好）进行筛选。
- en: The first global setting of the registries configuration file is the `unqualified-search-registry`
    array, which defines the search list of registries for unqualified images. When
    the user runs the `podman search <image_name>` command, Podman will search across
    the registries defined in this list.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表配置文件的第一个全局设置是`unqualified-search-registry`数组，该数组定义了未限定镜像的注册表搜索列表。当用户运行`podman
    search <image_name>`命令时，Podman会在此列表中定义的注册表中进行搜索。
- en: By removing a registry from the list, Podman will stop searching the registry.
    However, Podman will still be able to pull a fully qualified image from a foreign
    registry.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从列表中移除一个注册表，Podman将停止在该注册表中搜索。然而，Podman仍然能够从外部注册表拉取完全限定的镜像。
- en: 'To manage single registries and create matching patterns for specific images,
    we can use the `[[registry]]` **Tom''s Obvious, Minimal Language** (**TOML**)
    tables. The main settings of these tables are as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理单一注册表并为特定镜像创建匹配模式，我们可以使用`[[registry]]` **Tom's Obvious, Minimal Language**
    (**TOML**) 表格。 这些表格的主要设置如下：
- en: '`prefix`: This is used to define the image names and can support multiple formats.
    In general, we can define images by following the `host[:port]/namespace[/_namespace_…]/repo(:_tag|@digest)`
    pattern, though simpler patterns such as `host[:port]`, `host[:port]/namespace`,
    and even `[*.]host` can be applied. Following this approach, users can define
    a generic prefix for a registry or a more detailed prefix to match a specific
    image or tag. Given a fully qualified image, if two `[[registry]]` tables have
    a prefix with a partial match, the longest matching pattern will be used.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prefix`：用于定义镜像名称，支持多种格式。通常，我们可以通过遵循`host[:port]/namespace[/_namespace_…]/repo(:_tag|@digest)`模式来定义镜像，尽管也可以使用更简洁的模式，如`host[:port]`、`host[:port]/namespace`，甚至`[*.]host`。按照这种方式，用户可以为注册表定义一个通用前缀，或为匹配特定镜像或标签定义一个更详细的前缀。给定一个完全限定的镜像，如果两个`[[registry]]`表格有一个部分匹配的前缀，则使用最长的匹配模式。'
- en: '`insecure`: This is a Boolean (`true` or `false`) that allows unencrypted HTTP
    connections or TLS connections based on untrusted certificates.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insecure`：这是一个布尔值（`true`或`false`），允许使用未加密的HTTP连接或基于不受信任证书的TLS连接。'
- en: '`blocked`: This is a Boolean (`true` or `false`) that''s used to define blocked
    registries. If it''s set to true, the registries or images that match the prefix
    are blocked.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blocked`：这是一个布尔值（`true`或`false`），用于定义被阻止的注册表。如果设置为true，则与前缀匹配的注册表或镜像会被阻止。'
- en: '`location`: This field defines the registry''s location. By default, it is
    equal to `prefix`, but it can have a different value. In that case, a pattern
    that matches a custom prefix namespace will resolve to the `location` value.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`location`：该字段定义了注册表的位置。默认情况下，它等于`prefix`，但可以有不同的值。在这种情况下，匹配自定义前缀命名空间的模式将解析为`location`值。'
- en: Along with the main `[[registry]]` table, we can define an array of `[[registry.mirror]]`
    TOML tables to provide alternate paths to the main registry or registry namespace.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除了主要的`[[registry]]`表格外，我们还可以定义一个`[[registry.mirror]]` TOML表格数组，以提供通往主注册表或注册表命名空间的备用路径。
- en: When multiple mirrors are provided, Podman will search across them first and
    then fall back to the location that's defined in the main `[[registry]]` table.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当提供多个镜像时，Podman将首先在它们之间搜索，然后回退到主`[[registry]]`表格中定义的位置。
- en: 'The following example extends the previous one by defining a namespaced registry
    entry and its mirror:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例通过定义一个命名空间注册表条目及其镜像，扩展了之前的内容：
- en: '[PRE2]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: According to this example, if a user tries to pull the image tagged as `registry.example.com:5000/foo/app:latest`,
    Podman will try `mirror1.example.com:5000/bar/app:latest`, then `mirror2.example.com:5000/bar/app:latest`,
    and fall back to `registry.example.com:5000/foo/app:latest` in case a failure
    occurs.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 根据此示例，如果用户尝试拉取标记为`registry.example.com:5000/foo/app:latest`的镜像，Podman将首先尝试`mirror1.example.com:5000/bar/app:latest`，然后尝试`mirror2.example.com:5000/bar/app:latest`，如果失败，则回退到`registry.example.com:5000/foo/app:latest`。
- en: 'Using a prefix provides even more flexibility. In the following example, all
    the images that match `example.com/foo` will be redirected to mirror locations
    and fall back to the main location at the end:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前缀提供更大的灵活性。在下面的示例中，所有匹配`example.com/foo`的镜像将被重定向到镜像位置，并在末尾回到主位置：
- en: '[PRE3]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, when we pull the `example.com/foo/app:latest` image, Podman
    will attempt `mirror1.example.com:5000/bar/app:latest`, followed by `mirror2.example.com:5000/bar/app:latest`
    and `registry.example.com:5000/foo/app:latest`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，当我们拉取`example.com/foo/app:latest`镜像时，Podman将尝试拉取`mirror1.example.com:5000/bar/app:latest`，然后是`mirror2.example.com:5000/bar/app:latest`和`registry.example.com:5000/foo/app:latest`。
- en: 'It is possible to use mirroring in a more advanced way, such as replacing public
    registries with private mirrors in disconnected environments. The following example
    remaps the `docker.io` and `quay.io` registries to a private mirror with different
    namespaces:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 可以更高级地使用镜像，例如在断开连接的环境中用私有镜像替换公共注册表。以下示例将`docker.io`和`quay.io`注册表重新映射到具有不同命名空间的私有镜像：
- en: '[PRE4]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Important Note
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Mirror registries should be kept up-to-date with mirrored repositories. For
    this reason, administrators or SRE teams should implement an image sync policy
    to keep the repositories updated.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像注册表应该与镜像仓库保持同步。因此，管理员或SRE团队应实施镜像同步策略以保持仓库更新。
- en: Finally, we are going to learn how to block a source that is not considered
    trusted. This behavior could impact a single image, a namespace, or a whole registry.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将学习如何阻止不被认为是可信的源。此行为可能会影响单个镜像、命名空间或整个注册表。
- en: 'The following example tells Podman to not search for or pull images from a
    blocked registry:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例告诉Podman不要搜索或拉取来自阻止的注册表的镜像：
- en: '[PRE5]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It is possible to refine the blocking policy by passing a specific namespace
    without blocking the whole registry. In the following example, every image search
    or pull that matches the `quay.io/foo` namespace pattern defined in the `prefix`
    field is blocked:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过传递特定命名空间来细化阻止策略，而不是阻止整个注册表。在下面的示例中，定义在`prefix`字段中的每个镜像搜索或拉取与`quay.io/foo`命名空间模式匹配的操作将被阻止：
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: According to this pattern, if the user tries to pull an image called `quay.io/foo/nginx:latest`
    or `quay.io/foo/httpd:v2.4`, the prefix is matched, and the pull is blocked. No
    blocking action occurs when the `quay.io/bar/fedora:latest` image is pulled.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 根据此模式，如果用户尝试拉取名为`quay.io/foo/nginx:latest`或`quay.io/foo/httpd:v2.4`的镜像，则匹配前缀并阻止拉取。当拉取`quay.io/bar/fedora:latest`镜像时不会执行任何阻止操作。
- en: 'Users can also define a very specific blocking rule for a single image or even
    a single tag by using the same approach that was described for namespaces. The
    following example blocks a specific image tag:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 用户还可以使用与命名空间相同的方法为单个镜像或甚至单个标签定义非常具体的阻止规则。以下示例阻止特定镜像标签：
- en: '[PRE7]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It is possible to combine many blocking rules and add mirror tables on top of
    them.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 可以结合多个阻止规则，并在其上添加镜像表。
- en: Important Note
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In a complex infrastructure with many machines running Podman (for example,
    developer workstations), a clever idea would be to keep the registry's configuration
    file updated using configuration management tools and declaratively apply the
    registry's filters.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个运行多台Podman的复杂基础架构中（例如，开发者工作站），一个聪明的想法是使用配置管理工具保持注册表的配置文件更新，并声明性地应用注册表的过滤器。
- en: Fully qualified image names can become quite long if we sum up the registry
    FQDN, namespace(s), repository, and tags. It is possible to create aliases using
    the `[aliases]` table to allow short image names to be used. This approach can
    simplify image management and reduce human error. However, aliases do not handle
    image tags or digests.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 完全限定的镜像名称可能会变得非常长，如果我们总结注册表的FQDN、命名空间、仓库和标签。可以使用`[aliases]`表创建别名，以允许使用短镜像名称。这种方法可以简化镜像管理并减少人为错误。但是，别名不处理镜像标签或摘要。
- en: 'The following example defines a series of aliases for commonly used images:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例定义了一系列常用镜像的别名：
- en: '[PRE8]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When an alias matches a short name, it is immediately used without the registries
    defined in the `unqualified-search-registries` list being searched.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当别名匹配短名称时，立即使用，而不会搜索`unqualified-search-registries`列表中定义的注册表。
- en: Important Note
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We can create custom files inside the `/etc/containers/registries.conf.d/` folder
    to define aliases without bloating the main configuration file.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`/etc/containers/registries.conf.d/`文件夹内创建自定义文件，以定义别名，而不会使主配置文件臃肿。
- en: With that, we have learned how to manage trusted sources and block unwanted
    images, registries, or namespaces. This is a security best practice but it does
    not relieve us from the responsibility of choosing a valid image that fits our
    needs while being trustworthy and having the lowest attack surface possible. This
    is also true when we're building a new application, where base images must be
    lightweight and secure. Red Hat UBI images can be a helpful solution for this
    problem.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一点，我们已经学会了如何管理可信的来源，并屏蔽不需要的镜像、注册表或命名空间。这是一个安全最佳实践，但它并不能解除我们选择一个适合我们需求、可信赖且攻击面最小的有效镜像的责任。在我们构建新的应用程序时也是如此，基础镜像必须是轻量且安全的。Red
    Hat的UBI镜像可以为这个问题提供一个有用的解决方案。
- en: Introducing Universal Base Image
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍通用基础镜像
- en: When working on enterprise environments, many users and companies adopt RHEL
    as the operating system of choice to execute workloads reliably and securely.
    RHEL-based container images are available too, and they take advantage of the
    same package versioning as the OS release. All the security updates that are released
    for RHEL are immediately applied to OCI images, making them wealthy, secure images
    to build production-grade applications with.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业环境中工作时，许多用户和公司选择RHEL作为执行工作负载的操作系统，以保证可靠性和安全性。基于RHEL的容器镜像也可以使用，它们利用与操作系统版本相同的包版本。所有发布的RHEL安全更新会立即应用到OCI镜像上，使得这些镜像成为构建生产级应用程序的强大且安全的基础。
- en: Unfortunately, RHEL images are not publicly available without a Red Hat subscription.
    Users who have activated a valid subscription can use them freely on their RHEL
    systems and build custom images on top of them, but they are not freely redistributable
    without breaking the Red Hat enterprise agreement.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有Red Hat订阅的用户无法公开访问RHEL镜像。已经激活有效订阅的用户可以在其RHEL系统上自由使用这些镜像，并在其上构建自定义镜像，但如果没有遵守Red
    Hat企业协议，不能自由再分发这些镜像。
- en: So, why worry? There are plenty of commonly used images that can replace them.
    This is true, but when it comes to reliability and security, many companies choose
    to stick to an enterprise-grade solution and this is not an exception for containers.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么要担心呢？有很多常用镜像可以替代它们。这确实是对的，但在可靠性和安全性方面，许多公司选择坚持使用企业级解决方案，容器领域也不例外。
- en: For these reasons, and to address the redistribution limitations of RHEL images,
    Red Hat created the **Universal Base Image**, also known as **UBI**. UBI images
    are freely redistributable, can be used to build containerized applications, middleware,
    and utilities, and are constantly maintained and upgraded by Red Hat.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些原因，并且为了应对RHEL镜像的再分发限制，Red Hat创建了**通用基础镜像**，也叫**UBI**。UBI镜像是可以自由再分发的，可用于构建容器化的应用程序、中间件和实用工具，并且始终由Red
    Hat进行维护和升级。
- en: 'UBI images are based on the currently supported versions of RHEL: at the time
    of writing, the **UBI7** and **UBI8** images are currently available (based on
    RHEL7 and RHEL8, respectively), along with the **UBI9-beta** image, which is based
    on RHEL9-beta. In general, we can consider UBI images as a subset of the RHEL
    operating system.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: UBI镜像基于当前受支持的RHEL版本：在撰写本文时，**UBI7**和**UBI8**镜像已经发布（分别基于RHEL7和RHEL8），此外还有**UBI9-beta**镜像，它基于RHEL9-beta。一般来说，我们可以将UBI镜像视为RHEL操作系统的一个子集。
- en: All UBI images are available on the public Red Hat registry ([registry.access.redhat.com](http://registry.access.redhat.com))
    and Docker Hub ([docker.io](http://docker.io)).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 所有UBI镜像都可以在公共的Red Hat注册表（[registry.access.redhat.com](http://registry.access.redhat.com)）和Docker
    Hub（[docker.io](http://docker.io)）上找到。
- en: 'There are currently four different flavors of UBI images, each one specialized
    for a particular use case:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有四种不同的UBI镜像，每种镜像都针对特定的使用场景进行了优化：
- en: '**Standard**: This is the standard UBI image. It has the most features and
    packages availability.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准版**：这是标准的UBI镜像，具有最全面的功能和包支持。'
- en: '**Minimal**: This is a stripped-down version of the standard image with minimalistic
    package management.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精简版**：这是一个经过简化的标准镜像版本，具有最基本的包管理功能。'
- en: '**Micro**: This is a UBI version with a smaller footprint, without a package
    manager.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微型版**：这是一个精简版的UBI镜像，没有包管理器。'
- en: '`systemd` init system so that you can manage the execution of multiple services
    in a single container.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemd`初始化系统，使你可以在单个容器中管理多个服务的执行。'
- en: All of these are **free to use and redistribute** inside custom images. Let's
    describe each in detail, starting with the UBI Standard image.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些镜像**免费使用和再分发**，可以用于自定义镜像中。我们将详细描述每种镜像，首先介绍UBI标准镜像。
- en: The UBI Standard image
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UBI Standard 镜像
- en: The UBI Standard image is the most complete UBI image version and the closest
    one to standard RHEL images. It includes the **YUM** package manager, which is
    available in RHEL, and can be customized by installing the packages that are available
    in its dedicated software repositories; that is, *ubi-8-baseos* and *ubi-8-appstream*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: UBI Standard 镜像是最完整的 UBI 镜像版本，也是最接近标准 RHEL 镜像的版本。它包含了 **YUM** 包管理器，这是在 RHEL
    中可用的，并且可以通过安装其专用软件仓库中的包进行自定义；也就是说，*ubi-8-baseos* 和 *ubi-8-appstream*。
- en: 'The following example shows a Dockerfile/ContainerFile that uses a standard
    UBI8 image to build a minimal `httpd` server:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一个使用标准 UBI8 镜像来构建最小化 `httpd` 服务器的 Dockerfile/ContainerFile：
- en: '[PRE9]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The UBI Standard image was designed for generic applications and packages that
    are available on RHEL and already includes a curated list of basic system tools
    (including `curl`, `tar`, `vi`, `sed`, and `gzip`) and OpenSSL libraries while
    still retaining a small size (around 230 MiB): fewer packages means more lightweight
    images and a smaller attack surface.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: UBI Standard 镜像是为通用应用程序和在 RHEL 上可用的包设计的，并且已经包含了一些基本系统工具（包括 `curl`、`tar`、`vi`、`sed`
    和 `gzip`）和 OpenSSL 库，同时保持了小巧的体积（大约 230 MiB）：更少的包意味着更轻量级的镜像和更小的攻击面。
- en: If the UBI Standard image is still considered too big, the UBI Minimal image
    might be a good fit.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 UBI Standard 镜像仍然被认为太大，UBI Minimal 镜像可能是一个不错的选择。
- en: The UBI Minimal image
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UBI Minimal 镜像
- en: The UBI Minimal image is a stripped-down version of the UBI Standard image and
    was designed for self-consistent applications and their runtimes (Python, Ruby,
    Node.js, and so on). For this reason, it's smaller in size, has a small selection
    of packages, and doesn't include the YUM package manager; this has been replaced
    with a minimal tool called `microdnf`. The UBI Minimal image is smaller than the
    UBI Standard image and is roughly half its size.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: UBI Minimal 镜像是 UBI Standard 镜像的精简版本，专为自包含应用及其运行时（如 Python、Ruby、Node.js 等）设计。因此，它的体积更小，包的选择也更少，并且不包含
    YUM 包管理器；它已被一个叫做 `microdnf` 的最小化工具所替代。UBI Minimal 镜像比 UBI Standard 镜像更小，大小大约是后者的一半。
- en: 'The following example shows a Dockerfile/ContainerFile using a UBI 8 Minimal
    image to build a proof-of-concept Python web server:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一个使用 UBI 8 Minimal 镜像来构建概念验证 Python Web 服务器的 Dockerfile/ContainerFile：
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'By looking at the source code of the Python web server that''s been executed
    by the container, we can see that the web server handler prints a *Hello World!*
    string when an HTTP GET request is received. The server also manages signal termination
    using the Python `signal` module, allowing the container to be stopped gracefully:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看由容器执行的 Python Web 服务器的源代码，我们可以看到，当收到 HTTP GET 请求时，Web 服务器处理程序会打印出一个 *Hello
    World!* 字符串。该服务器还通过 Python `signal` 模块管理信号终止，允许容器优雅地停止：
- en: '[PRE11]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, the Python executable is called by a minimal entry point script:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Python 可执行文件通过一个最小化的入口脚本被调用：
- en: '[PRE12]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The script launches the command that's passed by the array in the `CMD` instruction.
    Also, notice the `-u` option that's passed to the Python executable in the command
    array. This enables unbuffered output and has the container print access logs
    in real time.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本会启动通过 `CMD` 指令中的数组传递的命令。还要注意，`-u` 选项被传递给 Python 可执行文件。这启用了无缓冲输出，并使容器实时打印访问日志。
- en: 'Let''s try to build and run the container to see what happens:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试构建并运行容器，看看会发生什么：
- en: '[PRE13]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With that, our minimal Python `httpd` server is ready to operate and serve a
    lot of barely useful but warming *Hello World!* responses.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们的最小化 Python `httpd` 服务器已经准备好运行，并提供许多几乎没什么用处但温暖的 *Hello World!* 响应。
- en: UBI Minimal works best for these kinds of use cases. However, an even smaller
    image may be necessary. This is the perfect use case for the UBI Micro image.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: UBI Minimal 最适合这些用例。然而，可能还需要一个更小的镜像。这正是 UBI Micro 镜像的完美应用场景。
- en: The UBI Micro image
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UBI Micro 镜像
- en: The UBI Micro image is the latest arrival to the UBI family. Its basic idea
    was to provide a distroless image, a stripped-down package manager without all
    the unnecessary packages, to provide a very small image that could also offer
    a minimal attack surface. Reducing the attack surface is required to achieve secure,
    minimal images that are more complex to exploit.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: UBI Micro 镜像是UBI系列中最新的成员。它的基本理念是提供一个无发行版的镜像，一个简化的包管理器，没有所有不必要的包，提供一个非常小的镜像，同时也能提供最小的攻击面。减少攻击面是实现安全、最小化镜像的必要条件，这样的镜像更难被利用。
- en: 'The UBI 8 Micro image is great in multi-stage builds, where the first stage
    creates the finished artifact(s) and the second stage copies them inside the final
    image. The following example shows a basic multi-stage Dockerfile/ContainerFile
    where a minimal Golang application is being built inside a UBI Standard container
    while the final artifact is copied inside a UBI Micro image:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: UBI 8 Micro 镜像在多阶段构建中表现出色，其中第一阶段生成最终的制品，第二阶段将它们复制到最终镜像中。以下示例展示了一个基本的多阶段 Dockerfile/ContainerFile，在
    UBI Standard 容器内构建一个最小的 Golang 应用程序，同时将最终的制品复制到 UBI Micro 镜像中：
- en: '[PRE14]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The build's output results in an image that's approximately 45 MB in size.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 构建的输出结果是一个大约 45 MB 的镜像。
- en: The UBI Micro image has no built-in package manager, but it is still possible
    to install additional packages using Buildah native commands. This works effectively
    on an RHEL system, where all the Red Hat GPG certificates are installed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: UBI Micro 镜像没有内置的包管理器，但仍然可以使用 Buildah 原生命令安装额外的包。在 RHEL 系统上，这个方法效果良好，因为所有的 Red
    Hat GPG 证书都已安装。
- en: 'The following example shows a build script that can be executed on RHEL 8\.
    Its purpose is to install additional Python packages using the host''s `yum` package
    manager, on top of a UBI Micro image:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一个可以在 RHEL 8 上执行的构建脚本。它的目的是在 UBI Micro 镜像上使用主机的 `yum` 包管理器安装额外的 Python
    包：
- en: '[PRE15]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that the `yum install` command is executed by passing the `--installroot
    $mount` option, which tells the installer to use the working container mount point
    as the temporary root to install the packages.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`yum install` 命令通过传递 `--installroot $mount` 选项来执行，这告诉安装程序使用工作容器挂载点作为临时根目录来安装包。
- en: UBI Minimal and UBI Micro images are great for implementing microservices architectures
    where we need to orchestrate multiple containers together, with each running a
    specific microservice.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: UBI Minimal 和 UBI Micro 镜像非常适合实现微服务架构，在这种架构中，我们需要将多个容器协调在一起，每个容器运行一个特定的微服务。
- en: Now, let's look at the UBI Init image, which allows us to coordinate the execution
    of multiple services inside a container.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 UBI Init 镜像，它允许我们在容器内协调多个服务的执行。
- en: The UBI Init image
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UBI Init 镜像
- en: A common pattern in container development is to create highly specialized images
    with a single component running inside them.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 容器开发中的一个常见模式是创建高度专业化的镜像，每个镜像内部运行一个单独的组件。
- en: To implement multi-tier applications, such as those with a frontend, middleware,
    and a backend, the best practice is to create and orchestrate multiple containers,
    each one running a specific component. The goal is to have minimal and very specialized
    containers, each one running its own service/process while following the **Keep
    It Simple, Stupid** (**KISS**) philosophy, which has been implemented in UNIX
    systems since their inception.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现多层应用程序，例如具有前端、中间件和后端的应用程序，最佳实践是创建并协调多个容器，每个容器运行一个特定的组件。目标是拥有最小化且高度专业化的容器，每个容器运行自己的服务/进程，同时遵循**保持简单，傻瓜**（**KISS**）哲学，这一哲学自
    UNIX 系统诞生以来便被实现。
- en: Despite being great for most use cases, this approach does not always suit certain
    special scenarios where many processes need to be orchestrated together. An example
    is when we need to share all the container namespaces across processes, or when
    we just want a single, *uber* image.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法适用于大多数用例，但在某些特殊场景中，它并不总是合适，比如当需要协调多个进程时。举个例子，当我们需要共享所有容器命名空间给多个进程，或是当我们只想要一个单一的、*超级*镜像时。
- en: Container images are normally created without an init system and the process
    that's executed inside the container (invoked by the `CMD` instruction) usually
    gets **PID 1**.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像通常创建时没有初始化系统，容器内部执行的进程（由 `CMD` 指令调用）通常会获得**PID 1**。
- en: For this reason, Red Hat introduced the UBI Init image, which runs a minimal
    `1` to be executed.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，Red Hat 引入了 UBI Init 镜像，它运行一个最小的 `1` 来执行。
- en: The UBI Init image is slightly smaller than the Standard image but has more
    packages available than the Minimal image.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: UBI Init 镜像比 Standard 镜像稍小，但比 Minimal 镜像提供更多的可用包。
- en: The default CMD is set to `/sbin/init`, which corresponds to the Systemd process.
    Systemd ignores the `SIGTERM` and `SIGKILL` signals, which are used by Podman
    to stop running containers. For this reason, the image is configured to send `SIGRTMIN+3`
    signals for termination by passing the `STOPSIGNAL SIGRTMIN+3` instruction inside
    the image Dockerfile.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 CMD 设置为 `/sbin/init`，这对应于 Systemd 进程。Systemd 会忽略 `SIGTERM` 和 `SIGKILL` 信号，这些信号通常用于通过
    Podman 停止运行的容器。由于这个原因，镜像被配置为通过在镜像的 Dockerfile 中传递 `STOPSIGNAL SIGRTMIN+3` 指令来发送
    `SIGRTMIN+3` 信号以进行终止。
- en: 'The following example shows a Dockerfile/ContainerFile that installs the `httpd`
    package and configures a `systemd` unit to run the `httpd` service:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一个 Dockerfile/ContainerFile，该文件安装 `httpd` 包并配置一个 `systemd` 单元来运行 `httpd`
    服务：
- en: '[PRE16]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice the `RUN` instruction, where we create the `/etc/systemd/system/httpd.service.d/`
    folder and the Systemd unit file. This minimal example could be replaced with
    a `COPY` of pre-edited unit files, which is particularly useful when multiple
    services must be created.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `RUN` 指令，在这里我们创建了 `/etc/systemd/system/httpd.service.d/` 文件夹和 Systemd 单元文件。这个最小示例可以通过复制预先编辑的单元文件来替代，这在需要创建多个服务时特别有用。
- en: 'We can build and run the image and inspect the behavior of the `init` system
    inside the container using the `ps` command:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以构建并运行镜像，使用 `ps` 命令检查容器内 `init` 系统的行为：
- en: '[PRE17]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that the `/sbin/init` process is executed with a PID of `1` and that it
    spawns the `httpd` processes. The container also executed `dbus-daemon`, which
    is used by Systemd to expose its API, along with `systemd-journald` to handle
    logs.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`/sbin/init` 进程以 PID `1` 执行，并且它会生成 `httpd` 进程。容器还执行了 `dbus-daemon`，这是 Systemd
    用来暴露其 API 的进程，同时还执行了 `systemd-journald` 来处理日志。
- en: Following this approach, we can add multiple services that are supposed to work
    together in the same container and have them orchestrated by Systemd.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方法，我们可以在同一容器中添加多个应该共同工作的服务，并让它们由 Systemd 协调。
- en: So far, we have looked at the four currently available UBI images and demonstrated
    how they can be used to create custom applications. Many public Red Hat images
    are based on UBI. Let's take a look.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了四个当前可用的 UBI 镜像，并演示了它们如何用于创建自定义应用程序。许多公共的 Red Hat 镜像是基于 UBI 的。让我们来看一下。
- en: Other UBI-based images
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他基于 UBI 的镜像
- en: Red Hat uses UBI images to produce many pre-built specialized images, especially
    for runtimes. They are usually expected to not have redistribution limitations.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Red Hat 使用 UBI 镜像来生成许多预构建的专用镜像，特别是对于运行时。通常，它们不受再分发限制。
- en: This allows runtime images to be created for languages, runtimes, and frameworks
    such as Python, Quarkus, Golang, Perl, PDP, .NET, Node.js, Ruby, and OpenJDK.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得可以为 Python、Quarkus、Golang、Perl、PDP、.NET、Node.js、Ruby 和 OpenJDK 等语言、运行时和框架创建运行时镜像。
- en: UBI is also used as the base image for the **Source-to-Image** (**s2i**) framework,
    which is used to build applications natively in OpenShift without the use of Dockerfiles.
    With s2i, it is possible to assemble images from user-defined custom scripts and,
    obviously, application source code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: UBI 也被用作 **Source-to-Image** (**s2i**) 框架的基础镜像，该框架用于在 OpenShift 中原生构建应用程序，而无需使用
    Dockerfile。通过 s2i，用户可以从自定义脚本和应用程序源代码中组装镜像。
- en: Last but not least, Red Hat's supported releases of Buildah, Podman, and Skopeo
    are packaged using UBI 8 images.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，Red Hat 支持的 Buildah、Podman 和 Skopeo 的发行版本是使用 UBI 8 镜像打包的。
- en: Moving beyond Red Hat's offering, other vendors use UBI images to release their
    images too – Intel, IBM, Isovalent, Cisco, Aqua Security, and many others adopt
    UBI as the base for their official images on Red Hat Marketplace.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 超越 Red Hat 的提供，其他供应商也使用 UBI 镜像来发布他们的镜像——Intel、IBM、Isovalent、Cisco、Aqua Security
    等许多公司也采用 UBI 作为他们在 Red Hat Marketplace 上发布的官方镜像的基础。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about the OCI image specifications and the role
    of container registries.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 OCI 镜像规范以及容器注册表的作用。
- en: After that, we learned how to adopt secure image registries and how to filter
    out those registries using custom policies that allow us to block specific registries,
    namespaces, and images.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们学习了如何采用安全的镜像注册表，并通过自定义策略筛选出这些注册表，允许我们阻止特定的注册表、命名空间和镜像。
- en: Finally, we introduced UBI as a solution to create lightweight, reliable, and
    redistributable images based on RHEL packages.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了 UBI 作为一种基于 RHEL 包创建轻量级、可靠且可再分发镜像的解决方案。
- en: With the knowledge you've gained in this chapter, you should be able to understand
    OCI image specifications in more detail and manage image registries securely.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章所学的知识，你应该能够更详细地理解OCI镜像规范，并安全地管理镜像注册表。
- en: In the next chapter, we will explore the difference between private and public
    registries and how to create a private registry locally. Finally, we will learn
    how to manage container images with the specialized **Skopeo** tool.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨私有注册表与公共注册表之间的区别，以及如何在本地创建私有注册表。最后，我们将学习如何使用专门的**Skopeo**工具管理容器镜像。
- en: Further reading
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多本章所涉及的主题，请查看以下资源：
- en: 'MITRE ATT&CK® Matrix: [https://attack.mitre.org/matrices/enterprise/containers/](https://attack.mitre.org/matrices/enterprise/containers/)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'MITRE ATT&CK®矩阵: [https://attack.mitre.org/matrices/enterprise/containers/](https://attack.mitre.org/matrices/enterprise/containers/)'
- en: 'Things You Should Know on Kubernetes Threat Matrix: [https://cloud.redhat.com/blog/2021-kubernetes-threat-matrix-updates-things-you-should-know](https://cloud.redhat.com/blog/2021-kubernetes-threat-matrix-updates-things-you-should-know)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '关于Kubernetes威胁矩阵你应该知道的事情: [https://cloud.redhat.com/blog/2021-kubernetes-threat-matrix-updates-things-you-should-know](https://cloud.redhat.com/blog/2021-kubernetes-threat-matrix-updates-things-you-should-know)'
- en: 'How to manage Linux container registries: [https://www.redhat.com/sysadmin/manage-container-registries](https://www.redhat.com/sysadmin/manage-container-registries)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如何管理Linux容器注册表: [https://www.redhat.com/sysadmin/manage-container-registries](https://www.redhat.com/sysadmin/manage-container-registries)'
- en: 'Introducing the Red Hat Universal Base Image: [https://www.redhat.com/en/blog/introducing-red-hat-universal-base-image](https://www.redhat.com/en/blog/introducing-red-hat-universal-base-image)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '介绍Red Hat通用基础镜像: [https://www.redhat.com/en/blog/introducing-red-hat-universal-base-image](https://www.redhat.com/en/blog/introducing-red-hat-universal-base-image)'
- en: 'Introduction to Red Hat''s UBI Micro: [https://www.redhat.com/en/blog/introduction-ubi-micro](https://www.redhat.com/en/blog/introduction-ubi-micro)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Red Hat的UBI Micro简介: [https://www.redhat.com/en/blog/introduction-ubi-micro](https://www.redhat.com/en/blog/introduction-ubi-micro)'
