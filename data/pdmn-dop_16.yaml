- en: '*Chapter 13*: Docker Migration Tips and Tricks'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第13章*：Docker迁移技巧和窍门'
- en: Every technology has a pioneer company, project, and product that, once created
    and announced, becomes a real game-changer that allowed its base concepts to spread.
    For containers, this was Docker.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每项技术都有一个开创性的公司、项目和产品，它一旦被创建并宣布，便成为了一个真正的变革者，使其基本概念得以传播。对于容器来说，这就是Docker。
- en: As we learned in [*Chapter 1*](B17908_01_epub.xhtml#_idTextAnchor015), *Introduction
    to Container Technology*, Docker provided a new approach and great ideas to leveraging
    existing technologies and creating brand new ones. After a few years, it became
    the most used technology for containers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第1章*](B17908_01_epub.xhtml#_idTextAnchor015)《容器技术简介》中所学到的，Docker提供了一种新的方法和伟大的想法，利用现有技术并创造出全新的技术。几年后，它成为了最常用的容器技术。
- en: But as usually happens for open source projects, the community and the enterprise
    started looking for improvements, new architectures, and different implementations.
    That's where Podman found a place to grow and leverage the standardization that's
    offered by the **Open Container Initiative** (**OCI**).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如开源项目常见的情况一样，社区和企业开始寻找改进、全新的架构和不同的实现方式。正是在这里，Podman找到了生长的空间，并利用了**开放容器倡议**（**OCI**）所提供的标准化。
- en: 'Docker was (and still is) the most used container technology. For this reason,
    in this chapter, we are going to provide some tips and tricks regarding handling
    the migration process. We will be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Docker曾是（并且仍然是）最常用的容器技术。因此，在本章中，我们将提供一些关于迁移过程的技巧和窍门。我们将涵盖以下主题：
- en: Migrating existing images and playing with a command's alias
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移现有镜像并使用命令别名
- en: Podman commands versus Docker commands
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman命令与Docker命令的对比
- en: Using Docker Compose with Podman
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker Compose与Podman
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before you proceed with this chapter's lecture and examples, you will need a
    machine with a working Podman installation. As we mentioned in [*Chapter 3*](B17908_03_epub.xhtml#_idTextAnchor068),
    *Running the First Container*, all the examples in this book have been executed
    on a Fedora 34 system or later but can be reproduced on your choice of **operating
    system** (**OS**).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续阅读本章的讲解和示例之前，您需要一台安装了Podman的机器。正如我们在[*第3章*](B17908_03_epub.xhtml#_idTextAnchor068)《运行第一个容器》中提到的，书中的所有示例都在Fedora
    34系统或更高版本上执行，但可以在您选择的**操作系统**（**OS**）上重现。
- en: Having a good understanding of the topics that were covered in [*Chapter 4*](B17908_04_epub.xhtml#_idTextAnchor083),
    *Managing Running Containers*, [*Chapter 5*](B17908_05_epub.xhtml#_idTextAnchor101),
    *Implementing Storage for the Container's Data*, and [*Chapter 9*](B17908_09_epub.xhtml#_idTextAnchor167),
    *Pushing Images to a Container Registry*, will help you grasp the concepts that
    will be covered in this chapter regarding containers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于已经掌握了[*第4章*](B17908_04_epub.xhtml#_idTextAnchor083)《管理正在运行的容器》，[*第5章*](B17908_05_epub.xhtml#_idTextAnchor101)《实现容器数据存储》，以及[*第9章*](B17908_09_epub.xhtml#_idTextAnchor167)《推送镜像到容器注册表》中的内容，将帮助您理解本章将涉及的关于容器的概念。
- en: Migrating existing images and playing with a command's alias
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移现有镜像并使用命令别名
- en: Podman has one great feature that lets any previous Docker user easily adapt
    and switch to it – complete **command-line interface** (**CLI**) compatibility
    with Docker.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Podman有一个伟大的功能，可以让任何之前使用Docker的用户轻松适应并切换到它——与Docker的**命令行界面**（**CLI**）完全兼容。
- en: 'Let''s demonstrate this CLI compatibility with Docker by creating a shell command
    alias for the `docker` command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过为`docker`命令创建一个命令别名，来演示这种与Docker的CLI兼容性：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, we have created a command alias that binds the `podman` command
    to the `docker` one. If we try to execute the `docker` command after setting the
    alias, the output is returned from the `podman` command instead.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们创建了一个命令别名，将`podman`命令绑定到`docker`命令上。如果在设置别名后尝试执行`docker`命令，返回的输出将来自`podman`命令。
- en: 'Let''s try this out on the newly created alias by running a container:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行一个容器来尝试一下新创建的别名：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We should see something very funny – a running cat, similar to the one shown
    in the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该会看到一些非常有趣的东西——一个正在运行的猫，类似于以下截图所示：
- en: '![Figure 13.1 – Funny output from running a test container'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.1 – 运行测试容器时的有趣输出'
- en: '](img/B17908_13_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17908_13_01.jpg)'
- en: Figure 13.1 – Funny output from running a test container
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 运行测试容器时的有趣输出
- en: 'Let''s test something more interesting. Docker, for example, offers a tutorial
    based on a container image exposing a web server:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一些更有趣的内容。例如，Docker提供了一个基于容器镜像暴露Web服务器的教程：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we continued to use the `docker` alias command with the option for running
    it by using a daemon, `–d`, and the option for binding the HTTP port, `–p`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们继续使用带有通过守护进程运行选项`–d`和绑定HTTP端口选项`–p`的`docker`别名命令。
- en: 'If everything worked correctly, then we can point our favorite web browser
    to `http://localhost`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常工作，我们可以将我们最喜欢的网页浏览器指向`http://localhost`：
- en: '![Figure 13.2 – Docker tutorial home page'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.2 – Docker教程主页'
- en: '](img/B17908_13_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17908_13_02.jpg)'
- en: Figure 13.2 – Docker tutorial home page
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – Docker教程主页
- en: The first page of Dockerlabs, **Getting Started**, specifies the command that
    was just run. From the left column of the page, we can continue with the tutorial.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerlabs的第一页，**开始使用**，指定了刚刚运行的命令。从页面的左列，我们可以继续进行教程。
- en: Let's continue with the tutorial and double-check that the alias will work properly
    at every stage.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续教程，并在每个阶段仔细检查别名是否正常工作。
- en: The tutorial steps are very simple, and they can help you summarize the knowledge
    that was shared in the previous chapters, from building a container to using multiple
    container applications to create a dedicated network. Please stop before the **Using
    Docker Compose** section as we will look at this in more detail shortly.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 教程步骤非常简单，能够帮助你总结上一章节所分享的知识，从构建容器到使用多个容器应用创建专用网络。请在**使用Docker Compose**部分之前停下来，因为我们稍后会更详细地讨论这一部分内容。
- en: Don't forget that we are using an alias and that, under the hood, Podman is
    working actively to let our containers work as expected, ensuring Docker CLI compatibility.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了，我们正在使用别名，而且在幕后，Podman正在积极工作以确保我们的容器按预期运行，确保Docker CLI兼容性。
- en: But what about container migration in the case of swapping Docker in favor of
    Podman?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在用Podman替代Docker的情况下，容器迁移如何处理呢？
- en: Well, a direct way to move existing containers from Docker to Podman does not
    exist. It is recommended that you recreate the containers with the respective
    container images and reattach any volumes using Podman.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，直接将现有容器从Docker迁移到Podman的方式并不存在。建议你使用相应的容器镜像重新创建容器，并使用Podman重新附加任何卷。
- en: The container images can be exported using the `docker export` command, which
    will create a TAR archive file that can be imported into Podman via the `podman
    import` command. If you're using a container image registry, you can skip this.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像可以使用`docker export`命令导出，该命令将创建一个TAR归档文件，可以通过`podman import`命令导入到Podman中。如果你正在使用容器镜像注册表，可以跳过此步骤。
- en: To understand any limitations we may encounter when we're using commands, examples,
    and resources written for Docker with our Podman installation, let's compare various
    Podman and Docker commands.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解在使用为Docker编写的命令、示例和资源时，可能遇到的限制，我们可以比较各种Podman和Docker命令。
- en: Podman commands versus Docker commands
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Podman命令与Docker命令的对比
- en: As we saw in the previous section, as well as in [*Chapter 2*](B17908_02_epub.xhtml#_idTextAnchor044),
    *Comparing Podman and Docker*, the Podman CLI is based on the Docker CLI. However,
    because Podman does not require a runtime daemon to work, some of the Docker commands
    may not be directly available or they could require some workarounds.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一部分所看到的，以及在[*第2章*](B17908_02_epub.xhtml#_idTextAnchor044)中提到的，*比较Podman与Docker*，Podman
    CLI基于Docker CLI。然而，由于Podman不需要运行时守护进程，因此一些Docker命令可能无法直接使用，或者可能需要一些变通方法。
- en: 'The command list is exceptionally long, so the following table only specifies
    a few:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 命令列表非常长，因此以下表格仅列出了一部分：
- en: '![](img/Table_01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_01.jpg)'
- en: As you can see, the command's name is the same as comparing the `docker` command
    with the `podman` command. However, even though the name is the same, due to architectural
    differences between Podman and Docker, some features or behaviors could be different.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，命令的名称与将`docker`命令与`podman`命令进行比较时相同。然而，尽管名称相同，由于Podman和Docker在架构上的差异，一些特性或行为可能会有所不同。
- en: Behavioral differences between Podman and Docker
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Podman与Docker之间的行为差异
- en: 'The following commands were intentionally implemented in another way by the
    Podman development team:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令是Podman开发团队故意以另一种方式实现的：
- en: '`podman volume create`: This command will fail if the volume already exists.
    In Docker, this command is idempotent, which means that if a volume already exists
    with the same name, then Docker will just skip this instruction. The actual behavior
    of Docker does not match the implementations for the other commands.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podman volume create`：如果卷已经存在，此命令将失败。在 Docker 中，此命令是幂等的，这意味着如果同名卷已经存在，Docker
    会跳过此指令。Docker 的实际行为与其他命令的实现不一致。'
- en: '`podman run -v /tmp/noexist:/tmp`: This command will fail if the source volume
    path does not exist. Instead, Docker will create the folder if it does not exist.
    Again, the Podman development team considered this a bug and changed it.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podman run -v /tmp/noexist:/tmp`：如果源卷路径不存在，此命令将失败。相反，Docker 会在路径不存在时创建该文件夹。Podman
    开发团队认为这是一个 bug 并已进行了修复。'
- en: '`podman run --restart`: The restart option in Podman will not persist after
    a system reboot. If required, we can run Podman from a `systemd.unit` file through
    `podman generate systemd`.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podman run --restart`：Podman 中的重启选项在系统重启后不会持久化。如果需要，我们可以通过 `podman generate
    systemd` 从 `systemd.unit` 文件中运行 Podman。'
- en: In the next section, we'll see which commands are missing from Podman that exist
    in Docker.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到 Podman 中缺少的命令，它们在 Docker 中是存在的。
- en: Missing commands in Podman
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Podman 中缺失的命令
- en: 'The following table shows a non-comprehensive list of Docker commands that,
    at the time of writing, don''t have equivalents in Podman:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了一些 Docker 命令的非全面列表，这些命令在撰写本文时在 Podman 中没有对应的命令：
- en: '![](img/Table_02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_02.jpg)'
- en: Now, let's see which commands are missing from Docker.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 Docker 中缺少的命令。
- en: Missing commands in Docker
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 中缺失的命令
- en: Similar to how Podman is missing some Docker commands, Docker is missing some
    Podman commands.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 Podman 缺少一些 Docker 命令，Docker 也缺少一些 Podman 命令。
- en: 'The following families of commands in Podman don''t have respective ones in
    Docker:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 中以下命令类别在 Docker 中没有对应命令：
- en: '`podman container`: This command can be used to manage containers.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podman container`：此命令可用于管理容器。'
- en: '`podman generate`: This command can be used to create a structured output (such
    as a YAML file) for a container, pod, or volume.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podman generate`：此命令可用于为容器、pod 或卷生成结构化输出（例如 YAML 文件）。'
- en: '`podman healthcheck`: This command provides you with a set of subcommands that
    you can use to manage container health checks.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podman healthcheck`：此命令提供了一组子命令，您可以使用它们来管理容器健康检查。'
- en: '`podman image`: This command can be used to manage container images.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podman image`：此命令可用于管理容器镜像。'
- en: '`podman init`: This command can be used to initialize a container with all
    the required steps but without running it.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podman init`：此命令可用于初始化容器，完成所有必要的步骤，但不启动容器。'
- en: '`podman machine`: This command lists a set of subcommands for managing Podman''s
    virtual machine on macOS.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podman machine`：此命令列出一组子命令，用于管理 macOS 上 Podman 的虚拟机。'
- en: '`podman mount`: This command mounts the container''s root filesystem in a location
    that can be accessed by the host.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podman mount`：此命令将容器的根文件系统挂载到主机可以访问的某个位置。'
- en: '`podman network exists/prune/reload`: This command checks and manages the status
    of a container''s network.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podman network exists/prune/reload`：此命令检查并管理容器网络的状态。'
- en: '`podman play`: This command creates containers, pods, or volumes based on the
    input from a structured (such as YAML) file input.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podman play`：此命令根据结构化文件（例如 YAML 文件）输入创建容器、pod 或卷。'
- en: '`podman pod`: This provides a set of subcommands for managing pods or groups
    of containers.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podman pod`：此命令提供了一组子命令，用于管理 pod 或容器组。'
- en: '`podman system`: This provides a set of subcommands for managing the Podman
    systems and retrieving information.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podman system`：此命令提供了一组子命令，用于管理 Podman 系统并检索信息。'
- en: '`podman unmount`: This command unmounts a working container''s root filesystem.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podman unmount`：此命令卸载工作容器的根文件系统。'
- en: '`podman unshare`: This command launches a process in a new user namespace (rootless
    containers).'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podman unshare`：此命令将在新的用户命名空间中启动进程（无根容器）。'
- en: '`podman untag`: This command removes one or more stored images.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podman untag`：此命令用于移除一个或多个存储的镜像。'
- en: '`podman volume exists`: This command checks if a volume exists.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podman volume exists`：此命令检查卷是否存在。'
- en: Of course, if a command is missing, this does not mean that the feature is missing
    in Docker.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果缺少某个命令，这并不意味着 Docker 中缺少该功能。
- en: Another useful feature that's available in Docker is Compose. We'll learn how
    to use it in Podman in the next section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 中另一个有用的功能是 Compose。我们将在下一节中学习如何在 Podman 中使用它。
- en: Using Docker Compose with Podman
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 与 Podman
- en: 'When it was first released, Docker quickly gained consensus thanks to its intuitive
    approach to container management. Along with the main container engine solution,
    another great feature was introduced to help users orchestrate multiple containers
    on a single host: **Docker Compose**.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 首次发布时，由于其直观的容器管理方式，迅速获得了共识。除了主要的容器引擎解决方案外，还引入了另一个伟大的功能，帮助用户在单一主机上编排多个容器：**Docker
    Compose**。
- en: The idea behind Compose is quite simple – it's a tool that can be used to orchestrate
    multi-container applications that are supposed to interact together on a single
    host and configured with a declarative file in YAML format. All the applications
    that are executed in a Compose stack are defined as services that can communicate
    with the other containers in the stack with a transparent name resolution.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Compose 的理念非常简单——它是一个用于编排多容器应用程序的工具，这些应用程序应该在单一主机上相互交互，并使用 YAML 格式的声明性文件进行配置。所有在
    Compose 堆栈中执行的应用程序都定义为服务，这些服务可以通过透明的名称解析与堆栈中的其他容器进行通信。
- en: The configuration file is named `docker-compose.yaml` and has a simple syntax
    where one or more **services** and related **volumes** are created and started.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件名为 `docker-compose.yaml`，其语法简单，可以创建和启动一个或多个 **服务** 和相关的 **卷**。
- en: Development teams can benefit from the stack's automation to quickly test applications
    on a single host. However, if we need to run our application on a production-like,
    multi-node environment, the best approach is to adopt a clustered orchestration
    solution such as Kubernetes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 开发团队可以利用该技术栈的自动化功能，在单一主机上快速测试应用程序。然而，如果我们需要在类似生产的多节点环境中运行应用程序，最佳做法是采用集群编排解决方案，如
    Kubernetes。
- en: When Podman was first released, its main purpose was to reach OCI full compatibility
    and feature parity with Docker CLI commands to become a valid daemonless alternative
    to the well-known container engine that inspired it. Unfortunately, this Compose
    compatibility was not supported in the first two major releases. Afterwards, the
    `podman-compose` project was introduced to fill the gap. The project was a separate
    development stream that needed to compensate for the lack of native Compose support
    in Podman.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Podman 首次发布时，其主要目的是实现 OCI 完全兼容性，并与 Docker CLI 命令达到功能对等，以成为一个无守护进程的有效替代方案，代替了它所启发的著名容器引擎。不幸的是，最初的两个主要版本并不支持该
    Compose 兼容性。随后，`podman-compose` 项目被引入以弥补这一空白。该项目是一个独立的开发流，需要弥补 Podman 中缺乏原生 Compose
    支持的问题。
- en: With Podman v3.0, native support for Docker Compose was finally introduced upstream,
    leaving users with the choice of using the original `docker-compose` utility or
    the new `podman-compose` utility.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Podman v3.0 中，终于引入了对 Docker Compose 的原生支持，使用户可以选择使用原始的 `docker-compose` 工具或新的
    `podman-compose` 工具。
- en: In this section, we learned how to configure Podman to orchestrate multiple
    containers with `docker-compose` to provide full compatibility to users migrating
    from Docker to Podman. In the next subsection, we'll look at an example of using
    `podman-compose` to leverage rootless container orchestration.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何配置 Podman 使用 `docker-compose` 来编排多个容器，从而为从 Docker 迁移到 Podman 的用户提供完全兼容性。在下一小节中，我们将看一个使用
    `podman-compose` 来实现无根容器编排的示例。
- en: Before we dig into setting up Podman, let's look at a few basic examples of
    Compose files to understand how they work.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解如何设置 Podman 之前，让我们先看几个 Compose 文件的基本示例，以帮助理解它们是如何工作的。
- en: Docker Compose quick start
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Compose 快速入门
- en: Compose files can be used to declare one or multiple containers being executed
    inside a common stack and also to define build instructions for custom applications.
    The advantage of this approach is that you can fully automate the entire application
    stack, including frontends, backends, and persistence services such as databases
    or in-memory caches.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Compose 文件可用于声明一个或多个在公共堆栈中执行的容器，还可定义自定义应用程序的构建指令。这种方法的优势在于，您可以完全自动化整个应用程序堆栈，包括前端、后端以及持久性服务（如数据库或内存缓存）。
- en: Important Note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The purpose of this section is to provide a quick overview of Compose files
    to help you understand how Podman can handle them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目的是快速概述 Compose 文件，帮助您理解 Podman 如何处理它们。
- en: 'For a detailed list of the latest Compose specification, please refer to the
    following URL: [https://docs.docker.com/compose/compose-file/compose-file-v3/](https://docs.docker.com/compose/compose-file/compose-file-v3/).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看最新的 Compose 规范详细列表，请参考以下 URL：[https://docs.docker.com/compose/compose-file/compose-file-v3/](https://docs.docker.com/compose/compose-file/compose-file-v3/)。
- en: A more extensive list of Compose examples can be found in the Docker Awesome
    Compose project at [https://github.com/docker/awesome-compose](https://github.com/docker/awesome-compose).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的Compose示例可以在Docker Awesome Compose项目中找到，网址为[https://github.com/docker/awesome-compose](https://github.com/docker/awesome-compose)。
- en: 'The following is a minimal configuration file that defines a single container
    running the Docker registry:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个最小配置文件，定义了一个运行Docker注册表的单一容器：
- en: Chapter13/registry/docker-compose.yaml
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter13/registry/docker-compose.yaml
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding example can be seen as a more structured and declarative way to
    define the execution parameters for a container. However, the real value of Docker
    Compose is its orchestration stacks, which are made up of multiple containers
    in a single instance.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子可以看作是定义容器执行参数的一种更加结构化和声明化的方式。然而，Docker Compose的真正价值在于其编排堆栈，这些堆栈由单个实例中的多个容器组成。
- en: 'The following example is even more interesting and shows a configuration file
    for a WordPress application that uses a MySQL database as its backend:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例更加有趣，展示了一个WordPress应用的配置文件，该应用使用MySQL数据库作为后端：
- en: Chapter13/wordpress/docker-compose.yaml
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter13/wordpress/docker-compose.yaml
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we can see the two main YAML objects – `services` and `volumes`. Under
    the `services` part of the code, we have two applications – `db` and `wordpress`.
    These have been highlighted for clarity.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到两个主要的YAML对象——`services`和`volumes`。在`services`部分的代码中，我们有两个应用——`db`和`wordpress`。这些已被突出显示以便清晰展示。
- en: 'In the `services` list, there''s a set of configuration values that define
    the container''s behavior. These are as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在`services`列表中，有一组配置值定义了容器的行为。具体如下：
- en: '`image`: The image that''s used by the container.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image`：容器使用的镜像。'
- en: '`command`: Additional commands to be passed to the container''s entry point.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`command`：传递给容器入口点的附加命令。'
- en: '`Volumes`: The list of volumes to be mounted in the container, along with their
    associated mount points. Along with new dedicated volumes, existing directories
    in the host can be bind-mounted on container mount points.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Volumes`：要挂载到容器中的卷列表，以及它们的相关挂载点。除了新的专用卷外，主机中的现有目录还可以绑定挂载到容器的挂载点上。'
- en: '`restart`: Container restart options in case an error occurs.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restart`：在发生错误时的容器重启选项。'
- en: '`expose`: The list of ports to be exposed by the container.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expose`：容器要暴露的端口列表。'
- en: '`ports`: The list of port mappings between the container and the host.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ports`：容器和主机之间的端口映射列表。'
- en: '`environment`: The list of environment variables to be created in the container.
    In this example, `WORDPRESS_DB_HOST`, `WORDPRESS_DB_USER`, `WORDPRESS_DB_PASSWORD`,
    `WORDPRESS_DB_NAME`, are injected into the WordPress container to provide connection
    parameters to the database.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environment`：要在容器中创建的环境变量列表。在这个例子中，`WORDPRESS_DB_HOST`、`WORDPRESS_DB_USER`、`WORDPRESS_DB_PASSWORD`、`WORDPRESS_DB_NAME`被注入到WordPress容器中，以提供连接数据库的参数。'
- en: Together with the service's declaration, we have a list of volumes that are
    managed by Compose. The engine can create these volumes in the Compose process
    or use existing volumes that have been labeled as `external`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务声明一起，我们有一个由Compose管理的卷列表。引擎可以在Compose过程中创建这些卷，或使用已标记为`external`的现有卷。
- en: 'The third and final example is a Compose file that builds a minimal REST API
    application that''s been written in Go that writes and retrieves data to a Redis
    in-memory store:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个也是最后一个例子是一个Compose文件，它构建了一个最小的REST API应用，该应用是用Go语言编写的，能够将数据写入并从Redis内存存储中检索数据：
- en: Chapter13/golang-redis/docker-compose.yaml
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter13/golang-redis/docker-compose.yaml
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this example, we have new elements that deserve attention:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一些值得注意的新元素：
- en: A `build` object, which defines the image to be built and also applies custom
    labels to the build.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`build`对象，定义了要构建的镜像，并且还应用了自定义标签到构建中。
- en: The `context` key holds the path for the build. In this example, the `./app`
    folder contains all the source code files and the Dockerfile for building the
    image.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context`键包含构建的路径。在这个例子中，`./app`文件夹包含所有源代码文件和用于构建镜像的Dockerfile。'
- en: A `labels` list, which holds a set of labels that are passed as strings in the
    build process.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`labels`列表，包含一组在构建过程中传递的标签，这些标签作为字符串传递。
- en: A `depends_on` list that specifies, for the web service, the other services
    that are considered dependencies; in this case, the `redis` service.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`depends_on`列表，指定了对于Web服务，其他被视为依赖的服务；在这种情况下是`redis`服务。
- en: An `environment` list that defines the name of the `redis` service that's used
    by the web app.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`environment`列表，定义了Web应用程序使用的`redis`服务名称。
- en: A `deploy` object in the `redis` service that lets us define custom configuration
    parameters, such as the number of container `replicas`.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redis`服务中的`deploy`对象，允许我们定义自定义配置参数，例如容器`replicas`的数量。'
- en: 'To bring up Compose applications with Docker, we can run the following command
    from the `compose` file''s folder:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Docker启动Compose应用程序，可以在`compose`文件所在的文件夹中运行以下命令：
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This command creates all the stack and related volumes while printing the output
    to `stdout`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会创建所有堆栈和相关的卷，并将输出打印到`stdout`。
- en: 'To run in detached mode, simply add the `-d` option to the command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 若要以分离模式运行，只需在命令中添加`-d`选项：
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following command builds the necessary images and starts the stack:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令构建必要的镜像并启动堆栈：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Alternatively, the `docker-compose build` command can be used to build the applications
    without starting them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用`docker-compose build`命令构建应用程序，而不启动它们。
- en: 'To shut down a stack running in the foreground, simply hit the *Ctrl* + *C*
    keyboard combination. Instead, to shut down a detached application, run the following
    command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭前台运行的堆栈，只需按下*Ctrl* + *C*键盘组合。而要关闭分离模式下的应用程序，请运行以下命令：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To kill an unresponsive container, we can use the `docker-compose kill` command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 若要杀死一个无响应的容器，我们可以使用`docker-compose kill`命令：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This command supports multiple signals with the `-s SIGNAL` option.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令支持通过`-s SIGNAL`选项传递多个信号。
- en: Now that we've covered the basic concepts surrounding Docker Compose, let's
    learn how to configure Podman to run Compose files.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经覆盖了有关Docker Compose的基本概念，接下来让我们学习如何配置Podman以运行Compose文件。
- en: Configuring Podman to interact with docker-compose
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Podman与docker-compose的交互
- en: To support Compose, Podman needs to expose its REST API service through a local
    UNIX socket. This service supports both Docker-compatible APIs and the native
    Libpod APIs.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持Compose，Podman需要通过本地UNIX套接字暴露其REST API服务。该服务支持Docker兼容的API和本地Libpod API。
- en: 'On a Fedora distribution, the `docker-compose` (which provides Docker Compose
    binaries) and `podman-docker` (which provides aliasing to the `docker` command)
    packages must be installed using the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在Fedora发行版上，必须使用以下命令安装`docker-compose`（提供Docker Compose二进制文件）和`podman-docker`（为`docker`命令提供别名）软件包：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Important Note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `docker-compose` package, when installed on a Fedora 34 system, installs
    version v1.28 at the time of writing, written in Python. The latest version, v2,
    was completely rewritten in Go and provides a significant performance improvement.
    It can be downloaded from the GitHub release page at [https://github.com/docker/compose/releases](https://github.com/docker/compose/releases).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose`软件包在Fedora 34系统上安装时，安装的是v1.28版本（截至本文编写时），该版本是用Python编写的。最新版本v2完全用Go重写，并提供了显著的性能提升。它可以从GitHub发布页面下载：[https://github.com/docker/compose/releases](https://github.com/docker/compose/releases)。'
- en: 'After installing the packages, we can enable and start the `systemd` unit that
    manages the UNIX socket service:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完软件包后，我们可以启用并启动管理UNIX套接字服务的`systemd`单元：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This command starts a socket that's listening on `/run/podman/podman.sock`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令启动一个监听`/run/podman/podman.sock`的套接字。
- en: 'Note that the native `docker-compose` command looks for a socket file in the
    `/run/docker.sock` path by default. For this reason, the `podman-docker` packages
    creates a symbolic link on the same path that points to `/run/podman/podman.sock`,
    as shown in the following example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，本地`docker-compose`命令默认会在`/run/docker.sock`路径下查找套接字文件。为此，`podman-docker`软件包会在该路径上创建一个符号链接，指向`/run/podman/podman.sock`，如下所示：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The UNIX socket that's exposed by Podman can be accessed by a process with root
    privileges only. It is possible to stretch the security restrictions by opening
    access to the file to all the users in the system or by allowing custom ACLs for
    a custom group. Later in this chapter, we will see that rootless container stacks
    can be executed with `podman-compose`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Podman暴露的UNIX套接字只能由具有root权限的进程访问。通过为系统中的所有用户打开文件访问权限或为自定义组允许自定义ACLs，可以放宽安全限制。本章稍后将介绍如何使用`podman-compose`执行无root容器堆栈。
- en: For the sake of simplicity, in the next subsection, you'll learn how to run
    `docker-compose` commands with Podman in rootfull mode.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简便起见，在下一小节中，您将学习如何在rootfull模式下使用Podman运行`docker-compose`命令。
- en: Running Compose workloads with Podman and docker-compose
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Podman和docker-compose运行Compose工作负载
- en: To help you learn how to operate `docker-compose` and create orchestrated multi-container
    deployments on our host, we will reuse the previous example of the Go REST API
    with a Redis in-memory store.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你学习如何操作 `docker-compose` 并在我们的主机上创建编排的多容器部署，我们将重用之前的 Go REST API 和 Redis
    内存存储的示例。
- en: We have already inspected the `docker-compose.yaml` file, which builds the web
    application and deploys one instance of the Redis container.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经检查了 `docker-compose.yaml` 文件，该文件构建了 Web 应用程序并部署了一个 Redis 容器实例。
- en: 'Let''s inspect the Dockerfile that''s used to build the application:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查用于构建应用程序的 Dockerfile：
- en: Chapter13/golang-redis/Dockerfile
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter13/golang-redis/Dockerfile
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we can see that the Go application is compiled in a multi-stage build
    and that the Go binary is copied inside a UBI-Minimal image.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 Go 应用程序在多阶段构建中被编译，并且 Go 二进制文件被复制到一个 UBI-Minimal 镜像中。
- en: The web frontend is minimal – it listens to port `8080`/`tcp` and only implements
    two endpoints – an `HTTP POST` method and an `HTTP GET` method to allow clients
    to upload and retrieve a JSON object that contains the name, email, and ID of
    a user. The JSON object is stored inside the Redis database.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Web 前端是简化版的 – 它监听 `8080`/`tcp` 端口，并且仅实现了两个端点 – 一个 `HTTP POST` 方法和一个 `HTTP GET`
    方法，用于允许客户端上传和检索包含用户姓名、电子邮件和 ID 的 JSON 对象。该 JSON 对象存储在 Redis 数据库中。
- en: Important Note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you're curious, the source code for the Go server is available in the `Chapter13/golang-redis/app/main.go`
    file. It isn't presented in this book for the sake of space and readability.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣，Go 服务器的源代码可以在 `Chapter13/golang-redis/app/main.go` 文件中找到。由于篇幅和可读性的原因，这本书中并没有展示。
- en: 'To build and run the application, we must change to the project directory and
    run the `docker-compose up` command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建并运行应用程序，我们必须切换到项目目录并运行 `docker-compose up` 命令：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we can see that `docker-compose` created two containers, whose names always
    follow the `<project_name>_<service_name>_<instance_count>` pattern.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 `docker-compose` 创建了两个容器，它们的名称始终遵循 `<project_name>_<service_name>_<instance_count>`
    的模式。
- en: The instance count varies when there is more than one replica in the service
    deployment.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务部署中有多个副本时，实例数量会有所不同。
- en: 'We can inspect the running containers with the usual `podman ps` command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用常规的 `podman ps` 命令检查正在运行的容器：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: One of the more interesting aspects is that the service names are automatically
    resolved.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的一点是，服务名称会自动被解析。
- en: When a Compose stack is created, Podman creates a new network, named with the
    `<project_name>_default` pattern.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建 Compose 堆栈时，Podman 会创建一个新的网络，名称遵循 `<project_name>_default` 模式。
- en: The new network uses the `dnsname` plugin to instantiate a `dnsmasq` process
    and resolve the containers' IPs to names that have been created after the service
    names.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 新的网络使用 `dnsname` 插件实例化一个 `dnsmasq` 进程，并将容器的 IP 地址解析为在服务名称之后创建的名称。
- en: 'We can inspect the network with the following command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令检查网络：
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `dnsmasq` service can be found using the `ps` command and filtered with
    `grep`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `ps` 命令并通过 `grep` 过滤来找到 `dnsmasq` 服务：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `/run/containers/cni/dnsname/golang-redis_default` directory holds the
    instance''s configuration. Inside the `addnhosts` file, we can find the mappings
    between the service names and the allocated container IPs:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`/run/containers/cni/dnsname/golang-redis_default` 目录保存了实例的配置。在 `addnhosts`
    文件中，我们可以找到服务名称与分配的容器 IP 地址之间的映射：'
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This means that a process inside a container can resolve a service name with
    a standard DNS query.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着容器内的进程可以通过标准的 DNS 查询解析服务名称。
- en: When we have multiple container replicas in a service, the resulting resolution
    that's delivered by `dnsmasq` is similar to a `db` service, for example), it will
    be resolved to as many different IPs as there are service replicas.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务中有多个容器副本时，`dnsmasq` 提供的解析结果类似于 `db` 服务（例如），它将解析为与服务副本数量相同的不同 IP 地址。
- en: 'Let''s go back to the `docker-compose.yaml` file. In the environment section
    of the `web` service configuration, we have the following variable:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 `docker-compose.yaml` 文件。在 `web` 服务配置的环境部分，我们有以下变量：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This variable is injected into the running container and represents the name
    of the `redis` service. It is used by the Go application to create the connection
    string to Redis and initialize the connection. When we're using a DNS-resolved
    service name, the container name and IP address of the `redis` service are completely
    irrelevant to our Go application.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 该变量被注入到正在运行的容器中，表示 `redis` 服务的名称。Go 应用程序使用它来创建连接字符串并初始化连接。当我们使用 DNS 解析的服务名称时，`redis`
    服务的容器名称和 IP 地址对 Go 应用程序完全无关。
- en: 'We can use the `docker-compose exec` command to verify that the variable was
    correctly injected inside the containers running as the `web` service in the stack:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `docker-compose exec` 命令来验证该变量是否正确注入到作为 `web` 服务运行的容器中：
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `env` command outputs the full list of environment variables in the container.
    This allows us to verify that the `REDIS_HOST` variable was created correctly.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`env` 命令输出容器中所有环境变量的完整列表。这样我们可以验证 `REDIS_HOST` 变量是否已正确创建。'
- en: Important Note
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Storing configurations such as connection strings in a database as constants
    in the application code is an anti-pattern in general, especially for modern cloud-native
    applications. The correct approach is to guarantee a strict separation between
    the application logic and the configuration parameters.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 将连接字符串等配置存储为数据库中的常量并直接嵌入应用程序代码中是一个反模式，特别是对于现代云原生应用程序。正确的方法是确保应用程序逻辑与配置参数之间有严格的分离。
- en: Configurations can be stored as environment variables or inside config/secret
    files that are injected at runtime in the container that runs the application.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 配置可以存储为环境变量或在运行时注入到运行应用程序的容器中的 config/secret 文件。
- en: These practices are well-defined in the **Twelve-Factor App** pattern specification,
    whose URL can be found in the *Further reading* section.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实践在 **十二因素应用** 模式规范中有明确定义，其 URL 可以在 *进一步阅读* 部分找到。
- en: 'It is finally time to test the application by posting a couple of JSON objects
    and retrieving one of them with the `curl` command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过发布几个 JSON 对象并使用 `curl` 命令检索其中一个来测试应用程序：
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The web container was successfully written to the Redis backend, which we can
    see by running the `docker-compose logs` command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Web 容器成功写入 Redis 后端，我们可以通过运行 `docker-compose logs` 命令来查看这一点：
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding command captures the logs of all the containers behind the `web`
    service.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令捕获所有 `web` 服务后面的容器的日志。
- en: 'Finally, we can retrieve the result. The web application reads back the object
    from the Redis database by looking at its `id`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以检索结果。Web 应用程序通过查看其 `id` 从 Redis 数据库中读取该对象：
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To shut down our application, we can simply use the `docker-compose down` command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭我们的应用程序，我们只需使用 `docker-compose down` 命令：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This command destroys the containers and their associated resources, including
    the custom network, but not volumes. To remove volumes, you must add the `-v`
    option to the end of the command.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令销毁容器及其关联的资源，包括自定义网络，但不包括卷。要删除卷，必须在命令末尾添加 `-v` 选项。
- en: The `docker-compose` utility is a great companion for building and deploying
    on a single host with Podman. However, in the next chapter, we will learn about
    some other useful solutions that will let us generate and execute Kubernetes Pod
    and Service resources, as well as containers that are executed by Systemd units.
    Before moving on, let's inspect the alternative `podman-compose` tool, which provides
    support for rootless containers.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose` 工具是一个非常适合在单个主机上与 Podman 一起构建和部署的好伙伴。然而，在下一章中，我们将学习一些其他有用的解决方案，这些解决方案将帮助我们生成并执行
    Kubernetes Pod 和 Service 资源，以及由 Systemd 单元执行的容器。在继续之前，让我们先了解一下替代工具 `podman-compose`，它支持无根容器。'
- en: Using podman-compose
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 podman-compose
- en: The `podman-compose` project started way before version 3.0 of Podman to provide
    a compatibility layer for users that needed to orchestrate containers with Compose
    files. In this subsection, we will look at an example of using `podman-compose`
    on Fedora.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman-compose` 项目在 Podman 3.0 版本之前就开始了，旨在为需要使用 Compose 文件编排容器的用户提供兼容层。在这一小节中，我们将查看在
    Fedora 上使用 `podman-compose` 的示例。'
- en: 'The `podman-compose` tool''s CLI is written in Python. The package can be installed
    with `dnf` or by getting the latest release from the respective GitHub repository
    (you can find the direct link in *Further reading* section):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman-compose` 工具的 CLI 是用 Python 编写的。可以通过 `dnf` 安装该软件包，或者从相应的 GitHub 仓库获取最新版本（你可以在
    *进一步阅读* 部分找到直接链接）：'
- en: '[PRE26]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Alternatively, it can be installed with Python''s package manager, `pip3`,
    which supports a broader set of operating systems and distributions:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用Python的包管理器`pip3`进行安装，它支持更广泛的操作系统和发行版：
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, we can run the same Compose stacks from the previous examples with the
    advantage of the rootless approach that's provided by `podman-compose`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过`podman-compose`提供的无根权限方法运行与前面示例中相同的Compose堆栈。
- en: 'The following are all the available commands that are compatible with `docker-compose`,
    along with their descriptions and some minor changes that are made by the output
    of the `podman-compose help` command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与`docker-compose`兼容的所有可用命令，以及它们的描述和由`podman-compose help`命令输出所做的一些较小更改：
- en: '`help`: Shows the tool''s help'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`help`: 显示工具的帮助'
- en: '`version`: Shows the command''s version'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`: 显示命令的版本'
- en: '`pull`: Pulls the stack images'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pull`: 拉取堆栈镜像'
- en: '`push`: Pushes the stack images'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push`: 推送堆栈镜像'
- en: '`build`: Builds the stack images'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`: 构建堆栈镜像'
- en: '`up`: Creates and starts the entire stack or some of its services'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`up`: 创建并启动整个堆栈或其中的一些服务'
- en: '`down`: Tears down the entire stack'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`down`: 拆除整个堆栈'
- en: '`ps`: Show the status of running containers'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps`: 显示运行容器的状态'
- en: '`run`: Creates a container similar to a service to run a one-off command'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run`: 创建类似服务的容器，以运行一次性命令'
- en: '`exec`: Executes a certain command in a running container'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exec`: 在运行的容器中执行特定命令'
- en: '`start`: Starts specific services'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`: 启动特定服务'
- en: '`stop`: Stops specific services'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop`: 停止特定服务'
- en: '`restart`: Restarts specific services'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restart`: 重启特定服务'
- en: '`logs`: Shows logs from services'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logs`: 显示服务的日志'
- en: 'The following command creates a stack from a directory containing the necessary
    configurations and the `docker-compose.yaml` file:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令从包含必要配置和`docker-compose.yaml`文件的目录创建堆栈：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The command's output is also very similar to the output provided by `docker-compose`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出也与`docker-compose`提供的输出非常相似。
- en: 'To shut down the stack, simply run the following command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭堆栈，只需运行以下命令：
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `podman-compose` project still hasn't reached total feature parity with
    `docker-compose`. However, it is a very interesting project to follow and contribute
    to to help implement a Podman-native utility that can evolve independently in
    the future.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman-compose`项目仍未完全达到与`docker-compose`的功能对等。但是，这是一个非常有趣的项目，可以在未来独立演变以帮助实现一个支持Podman本地的实用程序。'
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to manage a full migration from Docker to Podman.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何管理从Docker到Podman的完整迁移。
- en: We covered how to migrate images and create command aliases and we inspected
    the command compatibility matrix. Here, we provided a detailed overview of the
    different behaviors of specific commands and the different commands that are implemented
    in the two container engines – that is, Docker and Podman.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了如何迁移镜像并创建命令别名，并检查了命令兼容性矩阵。在此，我们详细介绍了两种容器引擎（即Docker和Podman）中特定命令的不同行为和不同的实现命令。
- en: Then, we learned how to migrate Docker Compose by illustrating native Podman
    3.0 support for the `docker-compose` command and the `podman-compose` alternative
    utility.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过说明原生Podman 3.0对`docker-compose`命令的支持以及`podman-compose`备选实用工具，学习了如何迁移Docker
    Compose。
- en: In the next and final chapter of this book, we will learn how to interact with
    Systemd by generating custom service units and turning containers into services
    that are started automatically inside the host. Then, we'll look at Kubernetes-oriented
    orchestration, where we will learn how to generate Kubernetes resources from running
    containers and pods and run them in Podman or Kubernetes natively.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一章，我们将学习如何通过生成自定义服务单元与Systemd进行交互，并将容器转换为在主机内自动启动的服务。然后，我们将探讨面向Kubernetes的编排，学习如何从运行的容器和Pod生成Kubernetes资源并在Podman或Kubernetes中运行它们。
- en: Further reading
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解本章涵盖的主题的更多信息，请查看以下资源：
- en: 'Docker Awesome Compose: [https://github.com/docker/awesome-compose](https://github.com/docker/awesome-compose)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Awesome Compose：[https://github.com/docker/awesome-compose](https://github.com/docker/awesome-compose)
- en: 'Podman-compose project on GitHub: [https://github.com/containers/podman-compose](https://github.com/containers/podman-compose)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman-compose项目GitHub链接：[https://github.com/containers/podman-compose](https://github.com/containers/podman-compose)
- en: 'Red Hat blog introduction to Docker Compose support in Podman: [https://www.redhat.com/sysadmin/podman-docker-compose](https://www.redhat.com/sysadmin/podman-docker-compose)'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Red Hat 博客介绍 Podman 中对 Docker Compose 的支持： [https://www.redhat.com/sysadmin/podman-docker-compose](https://www.redhat.com/sysadmin/podman-docker-compose)
- en: 'Twelve-Factor App: [https://12factor.net/](https://12factor.net/)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十二因素应用： [https://12factor.net/](https://12factor.net/)
- en: 'Podman man page: [https://github.com/containers/podman/blob/main/docs/source/markdown/podman.1.md](https://github.com/containers/podman/blob/main/docs/source/markdown/podman.1.md)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman 手册页： [https://github.com/containers/podman/blob/main/docs/source/markdown/podman.1.md](https://github.com/containers/podman/blob/main/docs/source/markdown/podman.1.md)
