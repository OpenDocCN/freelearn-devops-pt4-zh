## 《老年人的低语》

我花费了大量时间帮助公司改善他们的系统。我工作中最具挑战性的一部分是，在一次合作结束后回到家，知道下次再次拜访同一家公司时，我会发现没有任何实质性的改进。我不能说这完全不是我的错，确实是。可能我在做的事情上并不够好，或者我不擅长传达正确的信息，也许我的建议是错误的。造成这些失败的原因有很多，我承认它们大部分可能是我的错。然而，我还是无法摆脱一种感觉，觉得我的失败是由其他原因引起的。我认为根本原因在于错误的期望。

人们想要进步，这是我们天性的一部分。或者至少，大多数人是如此。我们成为工程师是因为我们充满好奇心。我们喜欢玩新的玩具，喜欢探索新的可能性。然而，随着我们在公司工作时间的增长，我们变得越来越自满。我们学到一些东西，然后就停止学习。我们的重点转向了爬升公司阶梯。时间一长，我们越来越注重捍卫自己的地位，而这通常意味着维持现状。

我们在某个领域变得非常专业，这种专业知识让我们获得了荣耀，并希望能带来一次或两次晋升。从那以后，我们就靠着这种荣耀前行。*看我，我是 DB2 专家，没错，就是我，设立了 VMWare 虚拟化。我把 Spring 的好处带到了我们的 Java 开发中。* 一旦发生这种情况，我们往往会试图确保这些好处永远保持不变。我们不会转向 NoSQL，因为那意味着我的 DB2 专业知识将不再那么有价值。我们不会转向云计算，因为我是 VMWare 背后的大师。我们不会采用 Go，因为我知道如何用 Java 编程。

这些声音很重要，因为它们是由资深人士发出的。每个人都需要听他们说话，尽管这些声音背后的真正动机往往是自私的。它们并非基于实际的知识，而是基于反复的经验。拥有二十年 DB2 经验并不等于二十年的进步，而是将同样的经验重复了二十次。然而，二十年的经验是有分量的。人们听你说话，并不是因为他们信任你，而是因为你资历深厚，管理层相信你有能力做出决策。

将老一辈的声音与管理层对未知的恐惧以及他们对短期利益的追求相结合，结果往往是维持现状。*那样做有效好多年了，为什么要改变呢？为什么要听一个初级开发人员告诉我该做什么？* 即使改变的倡导得到了像 Google、Amazon 和 Netflix 等巨头的经验支持（仅举几例），你也可能会得到类似以下的回应：*“我们不一样。”* *“这里不适用。”* *“我想做那件事，但由于一些我并不完全理解的规定，阻止了我做任何改变。”*

尽管如此，迟早会有改变的指令传来。你的 CTO 可能去了 Gartner 会议，在那里他被告知要转向微服务。太多人谈论敏捷，管理层不可能忽视。DevOps 是个大趋势，所以我们也需要实施它。Kubernetes 无处不在，所以我们很快就会开始做一个 PoC。

当这些事情真的发生时，当一个改变获得批准时，你可能会欣喜若狂。这是你的时刻。这时你会开始做一些令人兴奋的事情。往往正是这个时刻，我会接到电话。*“我们想做这个和那个，你能帮忙吗？”* 我通常（并非总是）会答应。这就是我的工作。尽管如此，我知道我的参与不会带来实质性的改进。我猜希望总是最后死去。

我为什么这么悲观？为什么我认为改进并不会带来切实的好处？答案在于所需改变的范围。

几乎每个工具都是特定流程的结果。另一方面，一个流程是某种文化的产物。如果在没有文化改变的情况下采用一个流程，那就是浪费时间。如果在没有理解背后流程的情况下采用工具，那也是徒劳的努力，结果只会是浪费时间，并可能导致可观的许可费用。在一些罕见的情况下，企业确实选择接受改变三者（文化、流程和工具）的需要。他们做出了决定，有时他们甚至开始朝着正确的方向迈进。这些是珍贵的案例，值得珍惜。但它们也可能失败。过了一段时间，通常是几个月后，我们会意识到这些改变的范围。只有勇敢的人才能生存下来，只有那些坚定的人才能坚持到底。

那些选择继续前进并真正改变他们的文化、流程和工具的人，会意识到它们与他们多年来开发的应用程序不兼容。容器与所有东西兼容，但当开发微服务时，效果才真正显著，而不是单体应用。测试驱动开发提高了信心、质量和速度，但前提是应用程序设计必须具有可测试性。零停机时间部署并不是神话。它们确实有效，但前提是我们的应用程序是云原生的，至少遵循了[十二因素](https://12factor.net/)等标准，等等。

这不仅仅是关于工具、流程和文化，还包括摆脱你多年来积累的技术债务。说到债务，我不一定是指你开始时做错了什么，而是时间把一些曾经很棒的东西变成了可怕的怪物。你是否花费了百分之五十的时间进行重构？如果没有，你就在积累技术债务。这是不可避免的。

当面对所有这些挑战时，放弃是预期的结果。当隧道尽头没有一丝光明时，扔下毛巾是人之常情。我不会责怪你。我感同身受。你没有前进，因为障碍太大了。但你必须站起来，因为没有其他选择。你会继续前行。你会进步。这会很痛苦，但除了你的竞争对手看着你即将死去的躯壳时缓慢死去之外，别无选择。

你已经走到了这一步，我只能假设有两种可能的解释。你是那些通过阅读技术书籍来逃避现实的人之一，或者你至少应用了我们迄今所讨论的一些内容。我希望是后者。如果是这样，你就不会成为“我又失败了”的又一个例子。我为此感谢你。这让我感觉好一些。

如果你真正应用了这本书的教训，而不是假装，你确实在做一件伟大的事情。没有办法假装持续交付（CD）。如果所有阶段都通过，你每次提交的代码都可以立即投入生产。是否部署到生产环境是基于业务或市场需求的决策，而非技术上的。你甚至可以更进一步，实践持续部署（CDP）。它消除了人为执行的唯一动作，并将每个通过的代码提交都部署到生产环境。这两者都不能假装。你不能部分地进行 CD 或 CDP。你不能几乎到达目标。如果你做到了，你只是在进行持续集成、最终会被部署的过程，或者其他什么操作。

总而言之，希望你已经准备好了。你将在 Kubernetes 集群内迈出实施持续部署的一步。在本书结束时，你唯一剩下的事情就是花费未知的时间“现代化”你的应用架构，或者将它们抛弃重来。你将改变你的工具、流程和文化。本书不会帮助你处理所有这些。我们专注于工具和流程。你将不得不自行解决文化和架构的问题。测试的方式也是如此。我不会教你测试，也不会宣扬 TDD。我假设你已经了解所有这些，我们可以专注于持续部署管道。

此时，你可能感到绝望。你可能还没准备好。你可能认为你的管理层没有同意，你公司的人员不会接受这个方向，或者你没有足够的时间和资金。不要沮丧。知道路径是最关键的部分。即使你不能立即到达那里，你也应该知道目的地是什么，这样你的步骤至少是朝着正确的方向迈进。

### 什么是持续部署？

就这样。这就是你能找到的最简短、最准确的持续部署定义。对你来说这是不是太多了？如果你认为你永远不能（或不应该）做到这一点，那我们可以退回到持续交付。

持续部署（CDP）和持续交付（CD）之间唯一实质性的区别是，前者将代码部署到生产环境，而后者需要我们选择要部署到生产环境的提交。这样不就简单多了吗？实际上并不是。其实几乎一样，因为在这两种情况下，我们都对流程有足够信心，认为每个提交都可以部署到生产环境。在持续交付的情况下，我们（人类）确实需要决定部署什么内容。但这正是导致重大混乱的原因。接下来是关键部分，请认真阅读。

如果每次提交（没有失败管道的提交）都可以部署到生产环境，那么就不需要工程师决定什么内容会被部署。**每个提交都可以部署**，我们只是可能不希望功能立刻对用户可用。这是一个商业决策。就这样。

作为一种学习经验，你应该让公司里技术能力最弱的人坐到屏幕前，查看构建情况，并让他（或她）选择要部署的版本。清洁服务的工作人员就是一个很好的候选人。在那个人点击按钮部署一个随机版本之前，你需要离开那个房间。

这里有个关键问题。你在那种情况下会有什么感受？如果你可以自信地去最近的酒吧喝咖啡，确信什么问题也不会发生，那么你就处在正确的位置。如果你会因此产生焦虑，那你离那里还很远。如果是这种情况，不必绝望。大多数人也会因为让一个随机的人部署一个随机版本而感到焦虑。但这并不重要。重要的是你是否想要达到那个目标。如果你想，那么继续往下读。如果你不想，那希望你只是在阅读本书的免费样章，并能做出明智的决定，避免浪费钱。换一本书读吧。

“等一下，”你可能会说，“我已经在做持续集成了，”你现在可能会这样想。“那么，持续交付或持续部署真的那么不同吗？”好吧，答案是它们并没有本质不同，但你可能误解了持续集成的定义。我甚至不打算给你定义它。自从持续集成成为一种实践已有超过十五年了。不过，我会问你几个问题。如果你对其中至少一个问题的回答是“否”，那么你并没有在做持续集成。开始吧。

+   你是否在每次提交时都在构建并至少部分测试你的应用程序，无论该提交被推送到哪个分支？

+   每个人每天至少提交一次吗？

+   如果你在几天后才将分支合并到*master*，而不是更频繁地合并，你会怎么做？

+   当构建失败时，你是否会停下正在做的事情去修复？这是否是最高优先级的任务（仅次于火灾紧急情况、地震和其他威胁生命的事件）？

就是这些。这些是你需要回答的唯一问题。对自己诚实一下。你真的对这四个问题都回答了“是”吗？如果是的话，你就是我的英雄。如果不是，剩下的只有一个问题需要回答。

**你真的想做持续集成（CI）、持续交付（CD）或持续部署（CDP）吗？**
