## 附录 A：安装 kubectl 并使用 minikube 创建集群

接下来的文本提供了你使用 minikube 创建本地 Kubernetes 集群所需的基本信息。此附录包含了 [《DevOps 2.3 工具包：Kubernetes》](https://amzn.to/2GvzDjy)中的几个子章节，请参考它以获取更详细的信息。

### 本地运行 Kubernetes 集群

Minikube 在你的笔记本电脑上创建一个单节点集群。尽管这并不是理想的，因为我们无法展示 Kubernetes 在多节点设置中提供的一些功能，但它应该足够用来解释 Kubernetes 背后的大部分概念。稍后，我们将转向更接近生产环境的设置，并探索在 Minikube 中无法展示的功能。

在我们深入 Minikube 安装之前，应该先设置一些先决条件。首先要做的是安装 `kubectl`。

### 安装 kubectl

Kubernetes 的命令行工具 `kubectl` 用于管理集群及其内部运行的应用程序。在本书中，我们将频繁使用 `kubectl`，所以现在不会详细介绍它。相反，我们将通过接下来的示例来讨论它的命令。目前，可以将它视为你与 Kubernetes 集群之间的对话者。

让我们来安装 `kubectl`。

如果你是 **MacOS 用户**，请执行以下命令。

```
`1` curl -LO https://storage.googleapis.com/kubernetes-release/release/`` ` ``curl -s https://`\`
`2` storage.googleapis.com/kubernetes-release/release/stable.txt`` ` ``/bin/darwin/amd64/kubec`\`
`3` tl
`4` 
`5` chmod +x ./kubectl
`6` 
`7` sudo mv ./kubectl /usr/local/bin/kubectl 
```

`````````````````````````````````` If you already have [Homebrew](https://brew.sh/) package manager installed, you can “brew” it with the command that follows.    ``` `1` brew install kubectl  ```   ````````````````````````````````` If, on the other hand, you’re a **Linux user**, the commands that will install `kubectl` are as follows.    ``` `1` curl -LO https://storage.googleapis.com/kubernetes-release/release/`$(`curl -s https:/`\` `2` /storage.googleapis.com/kubernetes-release/release/stable.txt`)`/bin/linux/amd64/kubec`\` `3` tl `4`  `5` chmod +x ./kubectl `6`  `7` sudo mv ./kubectl /usr/local/bin/kubectl  ```   ```````````````````````````````` Finally, **Windows users** should download the binary through the command that follows.    ``` `1` curl -LO https://storage.googleapis.com/kubernetes-release/release/`$(`curl -s https:/`\` `2` /storage.googleapis.com/kubernetes-release/release/stable.txt`)`/bin/windows/amd64/kub`\` `3` ectl.exe  ```   ``````````````````````````````` Feel free to copy the binary to any directory. The important thing is to add it to your `PATH`.    Let’s check `kubectl` version and, at the same time, validate that it is working correctly. No matter which OS you’re using, the command is as follows.    ``` `1` kubectl version  ```   `````````````````````````````` The output is as follows.    ``` `1` Client Version: version.Info{Major:"1", Minor:"9", GitVersion:"v1.9.0", GitCommit:"9\ `2` 25c127ec6b946659ad0fd596fa959be43f0cc05", GitTreeState:"clean", BuildDate:"2017-12-1\ `3` 5T21:07:38Z", GoVersion:"go1.9.2", Compiler:"gc", Platform:"darwin/amd64"} `4` The connection to the server localhost:8080 was refused - did you specify the right \ `5` host or port?  ```   ````````````````````````````` That is a very ugly and unreadable output. Fortunately, `kubectl` can use a few different formats for its output. For example, we can tell it to output the command in `yaml` format    ``` `1` kubectl version --output`=`yaml  ```   ```````````````````````````` The output is as follows.    ```  `1` `clientVersion``:`  `2`  `buildDate``:` `2017``-``12``-``15``T21``:``07``:``38``Z`  `3`  `compiler``:` `gc`  `4`  `gitCommit``:` `925``c127ec6b946659ad0fd596fa959be43f0cc05`  `5`  `gitTreeState``:` `clean`  `6`  `gitVersion``:` `v1``.``9.0`  `7`  `goVersion``:` `go1``.``9.2`  `8`  `major``:` `"1"`  `9`  `minor``:` `"9"` `10 `  `platform``:` `darwin``/``amd64` `11`  `12` `The` `connection` `to` `the` `server` `localhost``:``8080` `was` `refused` `-` `did` `you` `specify` `the` `right` `\` `13` `host` `or` `port``?`  ```   ``````````````````````````` That was a much better (more readable) output.    We can see that the client version is 1.9\. At the bottom is the error message stating that `kubectl` could not connect to the server. That is expected since we did not yet create a cluster. That’s our next step.    ### Installing Minikube    Minikube supports several virtualization technologies. We’ll use VirtualBox throughout the book since it is the only virtualization supported in all operating systems. If you do not have it already, please head to the [Download VirtualBox](https://www.virtualbox.org/wiki/Downloads) page and get the version that matches your OS. Please keep in mind that for VirtualBox or HyperV to work, virtualization must be enabled in the BIOS. Most laptops should have it enabled by default.    Finally, we can install Minikube.    If you’re using **MacOS**, please execute the command that follows.    ``` `1` brew cask install minikube  ```   `````````````````````````` If, on the other hand, you prefer **Linux**, the command is as follows.    ``` `1` curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-l`\` `2` inux-amd64 `&&` chmod +x minikube `&&` sudo mv minikube /usr/local/bin/  ```   ````````````````````````` Finally, you will not get a command if you are a Windows user. Instead, download the latest release from of the [minikube-windows-amd64.exe](https://storage.googleapis.com/minikube/releases/latest/minikube-windows-amd64.exe) file, rename it to `minikube.exe`, and add it to your path.    We’ll test whether Minikube works by checking its version.    ``` `1` minikube version  ```   ```````````````````````` The output is as follows.    ``` `1` minikube version: v0.23.0  ```   ``````````````````````` Now we’re ready to give the cluster a spin.    ### Creating A Local Kubernetes Cluster With Minikube    The folks behind Minikube made creating a cluster as easy as it can get. All we need to do is to execute a single command. Minikube will start a virtual machine locally and deploy the necessary Kubernetes components into it. The VM will get configured with Docker and Kubernetes via a single binary called localkube.    ``` `1` minikube start --vm-driver`=`virtualbox  ```   `````````````````````` A few moments later, a new Minikube VM will be created and set up, and a cluster will be ready for use.    When we executed the `minikube start` command, it created a new VM based on the Minikube image. That image contains a few binaries. It has both [Docker](https://www.docker.com/) and [rkt](https://coreos.com/rkt/) container engines as well as *localkube* library. The library includes all the components necessary for running Kubernetes. We’ll go into details of all those components later. For now, the important thing is that localkube provides everything we need to run a Kubernetes cluster locally.    Remember that this is a single-node cluster. While that is unfortunate, it is still the easiest way (as far as I know) to “play” with Kubernetes locally. It should do, for now. Later on, we’ll explore ways to create a multi-node cluster that will be much closer to a production setup.    Let’s take a look at the status of the cluster.    ``` `1` minikube status  ```   ````````````````````` The output is as follows.    ``` `1` `minikube``:` `Running` `2` `cluster``:` `Running` `3` `kubectl``:` `Correctly` `Configured``:` `pointing` `to` `minikube``-``vm` `at` `192.168``.``99.100`  ```   ```````````````````` Minikube is running, and it initialized a Kubernetes cluster. It even configured `kubectl` so that it points to the newly created VM.    You won’t see much UI in this book. I believe that a terminal is the best way to operate a cluster. More importantly, I am convinced that one should master a tool through its commands first. Later on, once we feel comfortable and understand how the tool works, we can choose to use a UI on top of it. We’ll explore the Kubernetes UI in one of the later chapters. For now, I’ll let you have a quick glimpse of it.    ``` `1` minikube dashboard  ```   ``````````````````` Feel free to explore the UI but don’t take too long. You’ll only get confused with concepts that we did not yet study. Once we learn about pods, replica-sets, services, and a myriad of other Kubernetes components, the UI will start making much more sense.    Another useful Minikube command is `docker-env`.    ``` `1` minikube docker-env  ```   `````````````````` The output is as follows.    ``` `1` export DOCKER_TLS_VERIFY="1" `2` export DOCKER_HOST="tcp://192.168.99.100:2376" `3` export DOCKER_CERT_PATH="/Users/vfarcic/.minikube/certs" `4` export DOCKER_API_VERSION="1.23" `5` # Run this command to configure your shell: `6` # eval $(minikube docker-env)  ```   ````````````````` If you worked with Docker Machine, you’ll notice that the output is the same. Both `docker-machine env` and `minikube docker-env` serve the same purpose. They output the environment variables required for a local Docker client to communicate with a remote Docker server. In this case, that Docker server is the one inside a VM created by Minikube. I assume that you already have Docker installed on your laptop. If that’s not the case, please go to the [Install Docker](https://docs.docker.com/engine/installation/) page and follow the instructions for your operating system. Once Docker is installed, we can connect the client running on your laptop with the server in the Minikube VM.    ``` `1` `eval` `$(`minikube docker-env`)`  ```   ```````````````` We evaluated (created) the environment variables provided through the `minikube docker-env` command. As a result, every command we send to our local Docker client will be executed on the Minikube VM. We can test that easily by, for example, listing all the running containers on that VM.    ``` `1` docker container ls  ```   ``````````````` The containers listed in the output are those required by Kubernetes. We can, in a way, consider them system containers. We won’t discuss each of them. As a matter of fact, we won’t discuss any of them. At least, not right away. All you need to know, at this point, is that they make Kubernetes work.    Since almost everything in that VM is a container, pointing the local Docker client to the service inside it should be all you need (besides `kubectl`). Still, in some cases, you might want to SSH into the VM.    ``` `1` minikube ssh `2`  `3` docker container ls `4`  `5` `exit`  ```   `````````````` We entered into the Minikube VM, listed containers, and got out. There’s no reason to do anything else beyond showing that SSH is possible, even though you probably won’t use it.    What else is there to verify? We can, for example, confirm that `kubectl` is also pointing to the Minikube VM.    ``` `1` kubectl config current-context  ```   ````````````` The output should be a single word, `minikube`, indicating that `kubectl` is configured to talk to Kubernetes inside the newly created cluster.    As an additional verification, we can list all the nodes of the cluster.    ``` `1` kubectl get nodes  ```   ```````````` The output is as follows.    ``` `1` NAME     STATUS ROLES  AGE VERSION `2` minikube Ready  <none> 31m v1.8.0  ```   ``````````` It should come as no surprise that there is only one node, conveniently called `minikube`.    If you are experienced with Docker Machine or Vagrant, you probably noticed the similar pattern. Minikube commands are almost exactly the same as those from Docker Machine which, on the other hand, are similar to those from Vagrant.    We can do all the common things we would expect from a virtual machine. For example, we can stop it.    ``` `1` minikube stop  ```   `````````` We can start it again.    ``` `1` minikube start  ```   ````````` We can delete it.    ``` `1` minikube delete  ```   ```````` One interesting feature is the ability to specify which Kubernetes version we’d like to use.    Since Kubernetes is still a young project, we can expect quite a lot of changes at a rapid pace. That will often mean that our production cluster might not be running the latest version. On the other hand, we should strive to have our local environment as close to production as possible (within reason).    We can list all the available versions with the command that follows.    ``` `1` minikube get-k8s-versions  ```   ``````` The output, limited to the first few lines, is as follows.    ``` `1` The following Kubernetes versions are available: `2 `        - v1.9.0 `3 `        - v1.8.0 `4 `        - v1.7.5 `5 `        - v1.7.4 `6 `        - v1.7.3 `7 `        - v1.7.2 `8 `        - v1.7.0 `9 `        ...  ```   `````` Now that we know which versions are available, we can create a new cluster based on, let’s say, Kubernetes v1.7.0.    ``` `1` minikube start \ `2 `    --vm-driver=virtualbox \ `3 `    --kubernetes-version="v1.7.0" `4`  `5` kubectl version --output=yaml  ```   ````` We created a new cluster and output versions of the client and the server.    The output of the latter command is as follows.    ```  `1` `clientVersion``:`  `2`  `buildDate``:` `2017``-``10``-``24``T19``:``48``:``57``Z`  `3`  `compiler``:` `gc`  `4`  `gitCommit``:` `bdaeafa71f6c7c04636251031f93464384d54963`  `5`  `gitTreeState``:` `clean`  `6`  `gitVersion``:` `v1``.``8.2`  `7`  `goVersion``:` `go1``.``8.3`  `8`  `major``:` `"1"`  `9`  `minor``:` `"8"` `10 `  `platform``:` `darwin``/``amd64` `11` `serverVersion``:` `12 `  `buildDate``:` `2017``-``10``-``04``T09``:``25``:``40``Z` `13 `  `compiler``:` `gc` `14 `  `gitCommit``:` `d3ada0119e776222f11ec7945e6d860061339aad` `15 `  `gitTreeState``:` `dirty` `16 `  `gitVersion``:` `v1``.``7.0` `17 `  `goVersion``:` `go1``.``8.3` `18 `  `major``:` `"1"` `19 `  `minor``:` `"7"` `20 `  `platform``:` `linux``/``amd64`  ```   ```` If you focus on the `serverVersion` section, you’ll notice that the `major` version is `1` and the `minor` is `7`.    ### What Now?    We are finished with a short introduction to Minikube. Actually, this might be called a long introduction as well. We use it to create a single-node Kubernetes cluster, launch the UI, do common VM operations like stop, restart, and delete, and so on. There’s not much more to it. If you are familiar with Vagrant or Docker Machine, the principle is the same, and the commands are very similar.    Before we leave, we’ll destroy the cluster. The next chapter will start fresh. That way, you can execute commands from any chapter at any time.    ``` `1` minikube delete  ```   `That’s it. The cluster is no more.` ```` ````` `````` ``````` ```````` ````````` `````````` ``````````` ```````````` ````````````` `````````````` ``````````````` ```````````````` ````````````````` `````````````````` ``````````````````` ```````````````````` ````````````````````` `````````````````````` ``````````````````````` ```````````````````````` ````````````````````````` `````````````````````````` ``````````````````````````` ```````````````````````````` ````````````````````````````` `````````````````````````````` ``````````````````````````````` ```````````````````````````````` ````````````````````````````````` ``````````````````````````````````
