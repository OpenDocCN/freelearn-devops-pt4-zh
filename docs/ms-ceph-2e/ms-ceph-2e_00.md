# 前言

Ceph 是一个统一的、高度弹性的分布式存储系统，提供块存储、对象存储和文件访问，近年来受到了广泛关注和使用。由于开源的优势，Ceph 得到了开发者和终端用户的快速采用，多个知名企业也参与了该项目。每个新版本的发布都进一步增强了其性能和功能，不断提升 Ceph 的地位。

随着对日益增长的数据存储需求和传统基于 RAID 的系统面临的挑战，Ceph 正好能为这些问题提供解决方案。随着世界逐步采纳新型云技术和基于对象的存储，Ceph 已准备好成为推动新一代存储技术的核心力量。

在本书中，我们将涵盖各种各样的话题，从安装和管理 Ceph 集群，到如何在遇到灾难时进行恢复，帮助你应对突发情况。对于那些有兴趣将应用程序与 Ceph 直接对接的读者，本书还将教你如何开发使用 Ceph 库的应用程序，甚至如何通过将自定义代码插入 Ceph 来执行分布式计算。通过本书的学习，你将顺利迈向掌握 Ceph 的道路。

《Mastering Ceph》第二版现已包含关于 Luminous 版本中新引入的 BlueStore 技术的更新，提供了帮助你理解 BlueStore 并升级现有集群以利用该技术的指南。

# 本书适合谁阅读

如果你是存储专业人员、系统管理员或云工程师，并且正在寻找构建强大存储系统的解决方案，适用于云环境和本地基础设施，那么这本书适合你。

# 本书内容概述

第一章，*Ceph 规划*，介绍了 Ceph 的基本原理、基本架构，并探讨了一些良好的应用案例。它还讨论了在实施 Ceph 之前你应该采取的规划步骤，包括设定设计目标、开发概念验证并进行基础设施设计。

第二章，*使用容器部署 Ceph*，是一个直截了当、按步骤讲解如何设置 Ceph 集群的章节。本章介绍了用于测试的 `ceph-deploy`，并进一步介绍了 Ansible。最后，我们还探讨了 Rook 项目，展示如何在 Kubernetes 集群上部署 Ceph 集群。章节还包括一个关于变更管理的部分，解释了变更管理对于大型 Ceph 集群稳定性的重要性。本章还为读者提供了一个共同的平台，帮助你构建本书后续使用的示例。

第三章，*BlueStore*，解释了 Ceph 必须能够提供数据和元数据的原子操作，并介绍了 FileStore 如何在标准文件系统之上构建，以提供这些保证。我们还将讨论这种方法所面临的问题。

本章接着介绍了 BlueStore，解释了它的工作原理及其解决的问题。将介绍其组件以及它们如何与不同类型的存储设备交互。我们将探索一些关键值存储的概览，包括 BlueStore 使用的 RocksDB。本章还将讨论一些 BlueStore 的设置以及它们如何与不同硬件配置交互。

本章最后讨论了将集群升级到 BlueStore 的方法，并通过一个升级示例指导读者完成升级过程。

第四章，*Ceph 与非本地协议*，讨论了 Ceph 为本地 Ceph 客户端提供的存储功能，并突出说明了在一些尚未广泛采用的传统存储部署中存在的问题。接着本章探讨了如何通过 NFS 和 iSCSI 将 Ceph 导出到非本地 Ceph 客户端，并通过实例演示配置。

第五章，*RADOS 池和客户端访问*，探讨了 Ceph 如何通过三种主要协议（块、文件和对象）提供存储。本章讨论了每种协议的使用场景以及用于提供每种协议的 Ceph 组件。章节还讲解了复制池和纠删码池之间的区别，并深入探讨了纠删码池的操作。

第六章，*使用 Librados 开发*，解释了如何使用 librados 构建可以直接与 Ceph 集群交互的应用程序。接着通过不同语言中的多个使用 librados 的示例，帮助读者了解如何使用 librados，包括在原子事务中的应用。

第七章，*使用 Ceph RADOS 类进行分布式计算*，讨论了将处理过程直接移至 OSD 进行有效的分布式计算的好处。然后介绍了如何通过构建简单的 Lua RADOS 类来开始使用 RADOS 类。接着探讨了如何将自己的 C++ RADOS 类构建到 Ceph 源代码树中，并对比在客户端和 OSD 上执行处理的基准测试。

第八章，*Ceph 监控*，首先描述了监控为何重要，并讨论了警报和监控之间的区别。接着本章讲解了如何从所有 Ceph 组件中获取性能计数器，解释了其中一些关键计数器的含义，以及如何将它们转化为可用的数值。

一个使用 Graphite 的示例将展示能够操作捕获数据并以图形形式提供更有意义输出的价值。本书还介绍了 Ceph Mimic 版本中新推出的 Ceph Dashboard，并提供了一个逐步的示例，说明如何在运行中的 Ceph 集群上启用它。

第九章，*调优 Ceph*，首先简要概述了如何调整 Ceph 和操作系统。它还介绍了避免调优非瓶颈部分的基本概念。本章还涵盖了你可能希望调优的领域，并建立如何衡量调优成功的方法。接下来，本章展示了如何对 Ceph 进行基准测试并进行基准测量，以确保所获得的任何结果都有意义。最后，讨论了不同的工具及基准测试如何与实际性能相关联。

第十章，*使用 Ceph 进行分层*，解释了 Ceph 中的 RADOS 分层是如何工作的，在哪些情况下应使用以及它的缺点。本章将带领读者逐步了解如何在 Ceph 集群上配置分层，并最终介绍调优选项，以便从分层中提取最佳性能。

第十一章，*故障排除*，概述了虽然 Ceph 在很大程度上是自动化的，能够自我管理并从故障场景中恢复，但在某些情况下仍需要人工干预。本章将探讨常见的错误和故障场景，并通过故障排除帮助 Ceph 恢复健康状态。

第十二章，*灾难恢复*，详细说明了当 Ceph 处于完全丧失服务或数据丢失的状态时，如何使用不太常见的恢复技术来恢复集群的访问权限，并希望能够恢复数据。本章为你提供在这些场景中尝试恢复所需的知识。

# 为了充分利用本书

本书假设读者对 Linux 操作系统有中等水平的熟练度，并且具备存储技术和网络基础知识。虽然本书会介绍 Ceph 集群的简单多节点设置，但建议读者在使用 Ceph 前有一些相关经验。尽管本书使用的是 Virtual Box，但你也可以自由选择其他实验环境，如 VMware Workstation 或其他工具。

本书要求你拥有足够的资源来支持整个 Ceph 实验环境。最低硬件或虚拟要求如下所示：

+   CPU：2 核

+   内存：8 GB RAM（推荐 16 GB）

+   磁盘空间：40 GB

跟随本书操作，你将需要以下软件：

+   VirtualBox

+   vagrant

需要互联网连接，以便安装每章示例中的必要软件包。

# 下载示例代码文件

你可以从 [www.packt.com](http://www.packt.com) 的帐户中下载本书的示例代码文件。如果你在其他地方购买了本书，可以访问 [www.packt.com/support](http://www.packt.com/support)，注册后直接将文件发送到你的邮箱。

你可以按照以下步骤下载代码文件：

1.  登录或注册 [www.packt.com](http://www.packt.com)。

1.  选择 SUPPORT 标签。

1.  点击代码下载 & 勘误。

1.  在搜索框中输入书名并按照屏幕上的指示操作。

一旦文件下载完成，请确保使用最新版本的工具解压或提取文件夹：

+   适用于 Windows 的 WinRAR/7-Zip

+   适用于 Mac 的 Zipeg/iZip/UnRarX

+   适用于 Linux 的 7-Zip/PeaZip

本书的代码包也托管在 GitHub 上，地址为 [`github.com/PacktPublishing/Mastering-Ceph-Second-Edition`](https://github.com/PacktPublishing/Mastering-Ceph-Second-Edition)。如果代码有更新，将会在现有的 GitHub 仓库中更新。

我们的丰富书籍和视频目录中也有其他代码包，欢迎访问 **[`github.com/PacktPublishing/`](https://github.com/PacktPublishing/)**。赶快去看看！

# 下载彩色图片

我们还提供了一个 PDF 文件，其中包含本书中使用的截图/图表的彩色图片。你可以在此下载：[`www.packtpub.com/sites/default/files/downloads/9781789610703_ColorImages.pdf`](https://www.packtpub.com/sites/default/files/downloads/9781789610703_ColorImages.pdf)。

# 使用的约定

本书中使用了许多文本约定。

`CodeInText`：表示文本中的代码词汇、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 用户名。例如：“使用以下代码安装 `corosync`、`pacemaker` 和 `cmrsh` 工具集：”

代码块的设置如下：

```
Vagrant.configure("2") do |config|
nodes.each do |node|
config.vm.define node[:hostname] do |nodeconfig|
nodeconfig.vm.box = "bento/ubuntu-16.04" 
```

当我们希望引起你注意某一特定代码块时，相关的行或项目会以粗体显示：

```
Vagrant.configure("2") do |config|
nodes.each do |node|
config.vm.define node[:hostname] do |nodeconfig|
nodeconfig.vm.box = "bento/ubuntu-16.04" 
```

任何命令行输入或输出均按如下方式书写：

```
 yum install *.rpm 
```

**粗体**：表示新术语、重要词汇或屏幕上显示的文字。例如，菜单或对话框中的文字会这样显示。这里有一个例子：“点击 Repo URL 链接，将带你到仓库目录树。”

警告或重要说明如下所示。

小贴士和技巧如下所示。

# 联系我们

我们总是欢迎读者的反馈。

**一般反馈**：如果你对本书的任何部分有疑问，请在邮件主题中提到书名，并通过 `customercare@packtpub.com` 给我们发送邮件。

**勘误**：虽然我们已经尽最大努力确保内容的准确性，但错误还是难免发生。如果您在本书中发现任何错误，我们将非常感激您能向我们报告。请访问 [www.packt.com/submit-errata](http://www.packt.com/submit-errata)，选择您的书籍，点击勘误提交表格链接并填写详细信息。

**盗版**：如果您在互联网上遇到任何我们作品的非法复制品，无论何种形式，我们将非常感激您能提供该位置地址或网站名称。请通过 `copyright@packt.com` 与我们联系，并附上该材料的链接。

**如果您有兴趣成为作者**：如果您在某个领域具有专业知识并且有兴趣撰写或为书籍作贡献，请访问 [authors.packtpub.com](http://authors.packtpub.com/)。

# 评论

请留下评论。在您阅读并使用本书后，不妨在您购买本书的网站上留下评论。潜在读者可以看到并参考您的公正意见做出购买决策，我们在 Packt 可以了解您对我们产品的看法，而我们的作者也能看到您对他们书籍的反馈。谢谢！

有关 Packt 的更多信息，请访问 [packt.com](http://www.packt.com/)。
