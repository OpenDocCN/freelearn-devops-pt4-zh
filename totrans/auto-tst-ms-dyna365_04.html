<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">The Testability Framework</h1>
                </header>
            
            <article>
                
<p>With Dynamics NAV 2009 Service Pack 1, Microsoft introduced the testability framework in the platform. This enabled developers to build test scripts in C/AL to run so-called <strong>headless tests</strong>; that is, tests that do not use the <strong>user interface</strong> (<strong>UI</strong>) to execute business logic. It was a follow-up on an internal tool called the <strong>NAV Test Framework</strong> (<strong>NTF</strong>) and had been used and worked on for a couple of years already. It allowed tests to be programmed in C# and ran against the Dynamics NAV UI. It was a neat system, with a neat technical concept behind it. However, this <em>running test against the UI</em> was one of the major reasons for leaving NTF behind. I seem to recall that it was the major reason because accessing business logic through the UI is slow – too slow. Too slow to allow the Microsoft Dynamics NAV development team to run all their tests against the various versions in a reasonable time. Nowadays, Microsoft is supporting five major versions (NAV 2015, NAV 2016, NAV 2017, NAV 2018, and Business Central) for 20 countries, and each of these country versions is being built and tested at least once a day. Any delay in the tests has a huge impact on the build of these 100 versions.</p>
<p>In this chapter, we will have a look at what I call the five pillars of the testability framework. The five technical features that make up this framework are as follows:</p>
<ul>
<li>Test codeunits and test functions</li>
<li>asserterror</li>
<li>Handler functions</li>
<li>Test runner and test isolation</li>
<li>Test pages</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The five pillars of the testability framework</h1>
                </header>
            
            <article>
                
<p>In the following five sections, each <em>pillar</em> will be discussed and illustrated with a simple code example. Feel free to try them out yourself. But, of course, being a hands-on book, we will get to a lot of more relevant examples later on.</p>
<div class="packt_infobox">
<p>The code examples can be found on GitHub at <a href="https://github.com/PacktPublishing/Automated-Testing-in-Microsoft-Dynamics-365-Business-Central" target="_blank">https://github.com/PacktPublishing/Automated-Testing-in-Microsoft-Dynamics-365-Business-Central</a>.</p>
<p>Details on how to use this repository and how to set up VS Code are discussed in <a href="bbbc6672-5043-422a-b54e-a09df933c909.xhtml" target="_blank">Appendix B</a>, <em>Setting Up VS Code and Using the GitHub Project</em>.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pillar 1 – Test codeunits and test functions</h1>
                </header>
            
            <article>
                
<p>Goal: Understand what test codeunits and test functions are and learn how to build and apply them.</p>
<p>The foremost important pillar of the testability framework is the concept of test codeunits and test functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test codeunits</h1>
                </header>
            
            <article>
                
<p>A test codeunit is defined by its <kbd>Subtype</kbd>:</p>
<pre>codeunit Id MyFirstTestCodeunit<br/>{<br/>    Subtype = Test;<br/>}</pre>
<p>This makes it different from a standard codeunit in a couple of ways:</p>
<ul>
<li>It can contain the so-called test and handler functions next to the normal functions we are used to when writing app code</li>
<li>When executing a test codeunit, the platform will do the following:
<ul>
<li>Run the <kbd>OnRun</kbd> trigger and each test function that resides in the test codeunit, from top to bottom</li>
<li>Record the result of each test function</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test functions</h1>
                </header>
            
            <article>
                
<p>A <kbd>Test</kbd> function is defined by the <kbd>FunctionType</kbd> tag:</p>
<pre>[Test]<br/>procedure MyFirstTestFunction()<br/>begin<br/><br/>end;</pre>
<p>This makes it different from a standard function:</p>
<ul>
<li>It has to be global</li>
<li>It cannot have arguments</li>
<li>It yields a result, which is either <kbd>SUCCESS</kbd> or <kbd>FAILURE</kbd></li>
</ul>
<p>When <kbd>SUCCESS</kbd> is returned by a test, it means that no error occurred in the execution of the test. Consequently, when <kbd>FAILURE</kbd> is returned, the test execution did throw an error. This error could be due to various reasons, such as the following:</p>
<ul>
<li>Code execution hitting a <kbd>TestField</kbd>, <kbd>FieldError</kbd>, or <kbd>Error</kbd> call</li>
<li>Data modifications not being fulfilled because of version conflicts, primary key conflicts, or locks</li>
</ul>
<p>The latter, a <kbd>Test</kbd> function returning <kbd>FAILURE</kbd>, brings us to another typicality of a test codeunit—when a test fails, the execution of a test codeunit doesn't halt. It continues to execute the next <kbd>Test</kbd> function.</p>
<p>Let's build two simple tests, one returning <kbd>SUCCESS</kbd> and the other <kbd>FAILURE</kbd>:</p>
<pre>codeunit 60000 MyFirstTestCodeunit<br/> {<br/>     Subtype = Test;<br/> <br/>     [Test]<br/>     procedure MyFirstTestFunction()<br/>     begin<br/>         Message('MyFirstTestFunction');<br/>     end;<br/> <br/>     [Test]<br/>     procedure MySecondTestFunction()<br/>     begin<br/>         Error('MySecondTestFunction');<br/>     end;<br/> }</pre>
<p>Now you can run them.</p>
<p>As test functions are executed from top to bottom, the message thrown by <kbd>MyFirstTestFunction</kbd> will show the following screenshot first:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-881 image-border" src="assets/a0cb76f6-d505-4b6b-9384-9545f370c454.png" style="width:21.58em;height:10.08em;"/></p>
<p>After that, the following message is shown, being a resume message of the execution of the whole test codeunit:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-882 image-border" src="assets/44828026-ff61-45fe-a743-0fb375a16aa2.png" style="width:30.58em;height:14.67em;"/></p>
<div class="packt_infobox">Note that the error did not appear like a message box, but is collected by the platform and recorded as part of the result of the failing test.</div>
<p>To be able to run the test codeunit, I built a simple page, <kbd>MyTestsExecutor</kbd>, with an action calling <kbd>MyFirstTestCodeunit</kbd>:</p>
<pre>page 60000 MyTestsExecutor<br/> {<br/>     PageType = Card;<br/>     ApplicationArea = All;<br/>     UsageCategory = Tasks;<br/>     Caption = 'My Test Executor';<br/> <br/>     actions<br/>     {<br/>         area(Processing)<br/>         {<br/>             action(MyFirstTestCodeunit)<br/>             {<br/>                 Caption = 'My First Test Codeunit';<br/>                 ToolTip = 'Executes My First Test Codeunit';<br/>                 ApplicationArea = All;<br/>                 Image = ExecuteBatch;<br/>                 RunObject = codeunit MyFirstTestCodeunit;<br/>             }<br/>         }<br/>     }<br/> }</pre>
<p>If you are following me using the code on GitHub and have a hard time opening the <kbd>MyTestsExecutor</kbd> page, use any of the following options:</p>
<ul>
<li>Set <kbd>startupObjectType</kbd> to <kbd>Page</kbd> and <kbd>startupObjectId</kbd> to <kbd>60000</kbd> in the <kbd>launch.json</kbd></li>
<li>Add <kbd>?page=6000</kbd> to the web client URL in the address bar of your browser: <kbd>http://localhost:8080/BC130/?page=6000</kbd></li>
<li>Use <em>Alt</em> + <em>Q</em>, <span class="packt_screen">Tell me what you want</span>, in the web client and search for <kbd>My Test Executor</kbd></li>
<li>Launch the page directly from the VS Code, making use of a VS Code AL extension such as <span class="packt_screen">CRS AL Language Extension</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pillar 2 – asserterror</h1>
                </header>
            
            <article>
                
<p>Goal: Understand what the <kbd>asserterror</kbd> keyword means and learn how to apply it.</p>
<p class="mce-root">A substantial part of the business logic we implement specifies conditions under which a user action or a process should fail or stop to continue its execution. Testing the circumstances that lead to this failure are as important as testing the successful conclusion of an action or process. The second pillar allows us to write tests that are focused on checking whether errors do occur; a so called <strong>positive-negative</strong> or <strong>rainy</strong> <strong>path</strong> test. For example, that posting errors out because a posting date has not been provided, or that, indeed, a negative line discount percentage cannot be entered on a sales order line. To achieve this, the <kbd>asserterror</kbd> keyword should be applied in front of the <kbd>calling statement</kbd>:</p>
<pre>asserterror &lt;calling statement&gt;</pre>
<p>Let's use it in a new codeunit and run it:</p>
<pre>codeunit 60001 MySecondTestCodeunit<br/> {<br/>     Subtype = Test;<br/> <br/>     [Test]<br/>     procedure MyNegativeTestFunction()<br/>     begin<br/>         Error('MyNegativeTestFunction');<br/>     end;<br/> <br/>     [Test]<br/>     procedure MyPostiveNegativeTestFunction()<br/>     begin<br/>         asserterror Error('MyPostiveNegativeTestFunction');<br/>     end;<br/> }</pre>
<p>The <kbd>MyPostiveNegativeTestFunction</kbd> function is reported as a <kbd>SUCCESS</kbd>, and, consequently, no error message is recorded:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-883 image-border" src="assets/8b890c00-bb2a-4180-8e61-f48b5087bc1f.png" style="width:30.50em;height:14.83em;"/></p>
<p><span>If the</span> <kbd>calling statement</kbd> <span>following the <kbd>asserterror</kbd> keyword throws an error, the system will continue executing the following statements. However, if the <kbd>calling statement</kbd> does not throw an error, the <kbd>asserterror</kbd> statement will cause one:</span></p>
<pre>An error was expected inside an asserterror statement.</pre>
<p>Where <kbd>asserterror</kbd> enables the test to continue with the next statement, it will not check the error as such. As we will see later, it is up to you to verify whether the expected did occur or not. If there is no verification on the specific error following the <kbd>asserterror</kbd>, any error will make your test pass.</p>
<div class="packt_infobox">If a successful positive-negative test does not report the error, this does not mean that the error did not occur. It is thrown, and, therefore, when a write transaction was performed, a rollback will happen. Any data modifications will disappear.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pillar 3 – handler functions</h1>
                </header>
            
            <article>
                
<p>Goal: Understand what handler functions are and learn how to build and apply them.</p>
<p>In our first test codeunit example, the <kbd>Message</kbd> statement results in the display of a message box. Unless we want to wait until a user presses the <span class="packt_screen">OK</span> button, this message box stays there forever, halting the full execution of our test run. In order to be able to have a fully automated test run, we need a way to deal with any user interactions, such as a message box, a confirm dialog, a report request page, or a modal page.</p>
<p>For this, handler functions, also known as <strong>UI handlers</strong>, have been conceived. Handler functions are a special type of function that can only be created in test codeunits, and aim at handling UI interactions that exist in the code under test. Handler functions enable us to fully automate tests without the need of a real user to interact with them. As soon as specific UI interactions occur, and a handler has been provided for it, the platform takes care of calling the handler as a substitute for real user interactions.</p>
<p><kbd>Test</kbd> function handler functions are defined by the <kbd>FunctionType</kbd> tag. The currently available values are shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-884 image-border" src="assets/9bda944f-078a-4348-a466-46e6002c987e.png" style="width:25.42em;height:21.50em;"/></p>
<p>Each handler function addresses a different type of user interaction object and needs different parameters to let it interact adequately with the platform. Let VS Code and the AL extension be your guide in finding the right signature for a handler function. The following screenshot shows you the signature of a <kbd>MessageHandler</kbd> when you hover over the function name:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-723 image-border" src="assets/129e2d04-46fd-45a4-8936-fdcbb82a1390.png" style="width:30.25em;height:9.75em;"/></p>
<p>In case of a <kbd>MessageHandler</kbd> function, the signature is the text the message box would show to the user. Handing over this text to the <kbd>MessageHandler</kbd> enables you to determine if the right message was triggered.</p>
<div class="packt_tip">For a listing of the signature of each handler type, go to <a href="https://docs.microsoft.com/en-us/dynamics-nav/how-to--create-handler-functions">https://docs.microsoft.com/en-us/dynamics-nav/how-to--create-handler-functions</a>.<a href="https://docs.microsoft.com/en-us/dynamics-nav/how-to--create-handler-functions"/></div>
<p>So, to get the <kbd>Message</kbd> statement handled automatically in our first test codeunit, we should create a <kbd>MessageHandler</kbd> function:</p>
<pre>[MessageHandler]<br/> procedure MyMessageHandler(Message: Text[1024])<br/> begin<br/> <br/> end;</pre>
<p>But this is only half of the job, as this handler needs to be linked to the test that will execute the code calling <kbd>Message</kbd> one way or another. The <kbd>HandlerFunctions</kbd> tag is used to do this. Each handler function needs to be called in a <kbd>Test</kbd> function and must be added to the <kbd>HandlerFunctions</kbd> tag as text. If multiple handlers are needed, these will make up a comma separated string:</p>
<pre>HandlerFunctions('Handler1[,Handler2,…]'<em>)</em></pre>
<p>Let's apply this to <kbd>MyFirstTestFunction</kbd> in a new codeunit and run it:</p>
<pre>codeunit 60002 MyThirdTestCodeunit<br/> {<br/>     Subtype = Test;<br/> <br/>     [Test]<br/>     [HandlerFunctions('MyMessageHandler')]<br/>     procedure MyFirstTestFunction()<br/>     begin<br/>         Message(MyFirstTestFunction);<br/>     end;<br/> <br/>     [MessageHandler]<br/>     procedure MyMessageHandler(Message: Text[1024])<br/>     begin<br/> <br/>     end;<br/> }</pre>
<p>Instantly, <span>rather than showing a message box first, </span>the resume message of the execution of the whole test codeunit is shown:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-885 image-border" src="assets/8099a4c4-28b9-42cf-9382-55a173fe6ef1.png" style="width:18.08em;height:7.17em;"/></p>
<div class="packt_infobox">Any handler function you add to the <kbd>HandlerFunctions</kbd> tag must be called at least one time in the <kbd>Test</kbd> function. If the handler is not called upon, because the user interactions it should handle don't happen, an error will be thrown by the platform, saying: <em>The following UI handlers were not executed</em>, listing the handlers not called upon.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pillar 4 – Test runner and test isolation</h1>
                </header>
            
            <article>
                
<p>Goal: Understand what a test runner and its test isolation are and learn how to use and apply them.</p>
<p>Given the previous three pillars, we are positioned to write test cases as follows:</p>
<ul>
<li>Using <strong>test codeunit</strong> and <strong>test functions</strong></li>
<li>Either <em>sunny</em> or <em>rainy path</em>, the latter by applying the <kbd>asserterror</kbd> keyword</li>
<li>With fully automated execution addressing any user interactions by applying <strong>handler functions</strong></li>
</ul>
<p>Do we need more?</p>
<p>As a matter of fact, yes, we do, as we need a way to do the following:</p>
<ol>
<li>Run tests stored in multiple codeunits, control their execution, and collect and secure the results</li>
<li>Run tests in isolation, so that we can achieve the following:
<ul>
<li>Write transactions, in the end, do not alter the database we run the test on</li>
<li>Each rerun of a test is done using the same data setup</li>
</ul>
</li>
</ol>
<p>Both goals can be accomplished using a so-called <kbd>TestRunner</kbd> codeunit with a certain test isolation. A test runner codeunit is defined by its <kbd>Subtype</kbd> and the isolation by its <kbd>TestIsolation</kbd>:</p>
<pre>codeunit Id MyTestRunnerCodeunit<br/> {<br/>     Subtype = TestRunner;<br/>     TestIsolation = Codeunit;<br/> }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test runner</h1>
                </header>
            
            <article>
                
<p>Like any other codeunit, a test runner codeunit can have a <kbd>OnRun</kbd> trigger and normal user-defined functions, but, in addition to that, you can also add two test runner-specific triggers called <kbd>OnBeforeTestRun</kbd> and <kbd>OnAfterTestRun</kbd>. When test codeunits are called from the <kbd>OnRun</kbd> trigger of a test runner, <kbd>OnBeforeTestRun</kbd> and <kbd>OnAfterTestRun</kbd> will be triggered by the system as follows:</p>
<ul>
<li><kbd>OnBeforeTestRun</kbd>: This is triggered before the test codeunit is called, the test codeunit <kbd>OnRun</kbd> trigger is executed, and each of its test functions is run</li>
<li><kbd>OnAfterTestRun</kbd>: This is triggered after each test function has run and the test codeunit finishes</li>
</ul>
<p>Use the <kbd>OnBeforeTestRun</kbd> trigger to perform a test run pre-initialization and control the execution of a whole test codeunit and individual test functions. The latter can be achieved by using the Boolean return value of the <kbd>OnBeforeTestRun</kbd> trigger. Returning <kbd>TRUE</kbd>, the test codeunit or test function runs. Returning <kbd>FALSE</kbd>, it is skipped.</p>
<p>Use the <kbd>OnAfterTestRun</kbd> trigger to perform post-processing, such as logging the result of each test. When the <kbd>OnAfterTestRun</kbd> trigger is run, the standard result message box, as we have seen so far, is not shown.</p>
<p><span>Both </span><kbd>OnBeforeTestRun</kbd><span> and </span><kbd>OnAfterTestRun</kbd><span> are run in their own database transaction. This means that changes made to the database with each of these triggers are committed once their execution finishes.</span></p>
<div class="packt_infobox"><span>Further reading can be found as follows:<br/></span><kbd>OnBeforeTestRun</kbd><span>: </span><a href="https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/triggers/devenv-trigger-onbeforetestrun">https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/triggers/devenv-trigger-onbeforetestrun</a><a href="https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/triggers/devenv-trigger-onbeforetestrun"><br/></a><a href="https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/triggers/devenv-trigger-onbeforetestrun"><kbd>OnAfterTestRun</kbd><span>: </span></a><a href="https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/triggers/devenv-trigger-onaftertestrun">https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/triggers/devenv-trigger-onaftertestrun</a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test isolation</h1>
                </header>
            
            <article>
                
<p>With a test runner enabling us to control the execution of all tests in one run, we also need to have control of the data created in one test codeunit, so that it will not influence the results of the tests in the next test codeunit. For this, the test codeunit <kbd>TestIsolation</kbd> property has been introduced, and it has three possible values:</p>
<ul>
<li><kbd>Disabled</kbd>: When selecting this value, or not setting the <kbd>TestIsolation</kbd> property explicitly, as this is the default value, any database transaction will be effectuated; after the execution of tests triggered by the test runner, the database will have changed compared to before running the test runner</li>
<li><kbd>Codeunit</kbd>: When selecting this value, after a test codeunit execution has completed fully, all data changes made to the database will be reverted/rolled back</li>
<li><kbd>Function</kbd>: When selecting this value, when a single test function has completed, all data changes made to the database will be reverted/rolled back</li>
</ul>
<p>Related to this, it makes sense to share a couple of thoughts on running tests and their isolation:</p>
<ol>
<li>Test isolation applies to database transactions, but does not apply to changes made outside of the database, and to variables, including temporary tables</li>
<li>With test isolation, <kbd>Codeunit</kbd>, or <kbd>Function</kbd>, <strong>all</strong> data changes will be rolled back, even if they were explicitly committed using the AL <kbd>Commit</kbd> statement</li>
<li>Running test codeunits outside of the test isolation, either <kbd>Codeunit</kbd> or <kbd>Function</kbd> of a test runner will effectuate any database transaction</li>
<li>Using test isolation, <kbd>Function</kbd> will give extra overhead compared to <kbd>Codeunit</kbd>, resulting in longer execution time, as with the ending of each test function, the database changes have to be reverted</li>
</ol>
<ol start="5">
<li>Setting the test isolation to <kbd>Function</kbd> might be unwanted, as it fully disables dependencies between test functions, which might be needed when, for an extended test scenario, intermediate results should be reported, and this has been achieved by a series of individual, but interdependent, test functions</li>
<li>With the <kbd>TestIsolation</kbd> property of a test runner, we have control over how to revert data changes in a generic way; as we will later see, the test function <kbd>TransactionModel</kbd> tag allows us to have control of the transaction behavior of individual test functions</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pillar 5 – Test pages</h1>
                </header>
            
            <article>
                
<p>Goal: Understand what test pages are and learn how to apply them when testing the UI.</p>
<p>The initial trigger for adding the testability framework to the platform was to get away from testing the business logic through the UI. The testability framework enabled headless, and thus faster, testing of the business logic. And this is how the testability framework was implemented in NAV 2009 SP1. Pure headless testing. It included everything of the four pillars discussed so far, even though test isolation was implemented in a different way than it is today. It was previously not possible to test the UI.</p>
<p>Moving ahead, it became clear that sole headless tests excluded too much. How could we test business logic that typically resides on pages? For example, consider a product configurator in which options are displayed or hidden depending on values entered by the user. So, with NAV 2013, Microsoft added the fifth pillar to the testability framework: test pages.</p>
<p>A test page is a logical representation of a page and is strictly handled in memory displaying no UI. To define a test page, you need to declare a variable of the <kbd>TestPage</kbd> type:</p>
<pre>PaymentTerms: TestPage "Payment Terms";</pre>
<p class="mce-root">A <kbd>TestPage</kbd> variable can be based on any page existing in the solution.</p>
<p>A test page allows you to mimic a user carrying out the following actions:</p>
<ul>
<li>Accessing the page</li>
<li>Accessing its sub parts</li>
<li>Reading and changing data on it</li>
<li>Performing actions on it</li>
</ul>
<p>You can achieve this by using the various methods that belong to the test page object. Let's build a small codeunit in which we use a couple of them:</p>
<pre>codeunit 60003 MyFourthTestCodeunit<br/> {<br/>     Subtype = Test;<br/> <br/>     [Test]<br/>     procedure MyFirstTestPageTestFunction()<br/>     var<br/>         PaymentTerms: TestPage "Payment Terms";<br/>     begin<br/>         PaymentTerms.OpenView();<br/>         PaymentTerms.Last();<br/>         PaymentTerms.Code.AssertEquals('LUC');<br/>         PaymentTerms.Close();<br/>     end;<br/> <br/>     [Test]<br/>     procedure MySecondTestPageTestFunction()<br/>     var<br/>         PaymentTerms: TestPage "Payment Terms";<br/>     begin<br/>         PaymentTerms.OpenNew();<br/>         PaymentTerms.Code.SetValue('LUC');<br/>         PaymentTerms."Discount %".SetValue('56');<br/>         PaymentTerms.Description.SetValue(<br/>                 PaymentTerms.Code.Value()<br/>             );<br/>         ERROR('Code: %1 \ Discount %: %2 \Description: %3',<br/>                 PaymentTerms.Code.Value(),<br/>                 PaymentTerms."Discount %".Value(),<br/>                 PaymentTerms.Description.Value()<br/>             );<br/>         PaymentTerms.Close();<br/>     end;<br/> }</pre>
<div class="packt_infobox">Note that errors are forced to get some useful feedback on the resume message of the test codeunit.</div>
<p>So, we get the following as a result:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-886 image-border" src="assets/246fde13-01da-46b8-9cf3-fce9152c621f.png" style="width:26.42em;height:13.83em;"/></p>
<div class="packt_tip">
<p>For a complete listing of all test page methods, you can access the following URLs:<br/>
<strong>TestPage</strong>: <a href="https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testpage/testpage-data-type">https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testpage/testpage-data-type</a><a href="https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testpage/testpage-data-type"><br/></a><strong>TestField</strong>: <a href="https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testfield/testfield-data-type">https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testfield/testfield-data-type</a><a href="https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testfield/testfield-data-type"><br/></a><strong>TestAction</strong>: <a href="https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testaction/testaction-data-type">https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testaction/testaction-data-type</a></p>
</div>
<p>If you are running Microsoft 365 Business Central on-premises and you want to run tests using test pages, be sure that you have the <span class="packt_screen">Page Testability</span> module installed:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-887 image-border" src="assets/7de95738-6260-43a2-9a51-7492fe41e2e1.png" style="width:32.58em;height:37.50em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we discussed what the testability framework is by describing the five pillars it entails: the basic elements test codeunits and test functions, the new code keyword <kbd>asserterror</kbd>, handler functions to allow automatic handling of UI elements, the test runner to enable us to run tests in isolation, and, finally, test pages to build tests to check the behavior of pages.</p>
<p>In <a href="fdf2b65f-be7c-4710-a3a9-39f4cc34ee5c.xhtml" target="_blank">Chapter 3</a>, <em>The Test Tool and Standard Tests</em>, you will learn about the test tool that resides in Business Central and the set of standard tests being released by Microsoft with the product.</p>


            </article>

            
        </section>
    </body></html>