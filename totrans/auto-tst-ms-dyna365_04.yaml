- en: The Testability Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Dynamics NAV 2009 Service Pack 1, Microsoft introduced the testability
    framework in the platform. This enabled developers to build test scripts in C/AL
    to run so-called **headless tests**; that is, tests that do not use the **user
    interface** (**UI**) to execute business logic. It was a follow-up on an internal
    tool called the **NAV Test Framework** (**NTF**) and had been used and worked
    on for a couple of years already. It allowed tests to be programmed in C# and
    ran against the Dynamics NAV UI. It was a neat system, with a neat technical concept
    behind it. However, this *running test against the UI* was one of the major reasons
    for leaving NTF behind. I seem to recall that it was the major reason because
    accessing business logic through the UI is slow – too slow. Too slow to allow
    the Microsoft Dynamics NAV development team to run all their tests against the
    various versions in a reasonable time. Nowadays, Microsoft is supporting five
    major versions (NAV 2015, NAV 2016, NAV 2017, NAV 2018, and Business Central)
    for 20 countries, and each of these country versions is being built and tested
    at least once a day. Any delay in the tests has a huge impact on the build of
    these 100 versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will have a look at what I call the five pillars of the
    testability framework. The five technical features that make up this framework
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Test codeunits and test functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: asserterror
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handler functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test runner and test isolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The five pillars of the testability framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following five sections, each *pillar* will be discussed and illustrated
    with a simple code example. Feel free to try them out yourself. But, of course,
    being a hands-on book, we will get to a lot of more relevant examples later on.
  prefs: []
  type: TYPE_NORMAL
- en: The code examples can be found on GitHub at [https://github.com/PacktPublishing/Automated-Testing-in-Microsoft-Dynamics-365-Business-Central](https://github.com/PacktPublishing/Automated-Testing-in-Microsoft-Dynamics-365-Business-Central).
  prefs: []
  type: TYPE_NORMAL
- en: Details on how to use this repository and how to set up VS Code are discussed
    in [Appendix B](bbbc6672-5043-422a-b54e-a09df933c909.xhtml), *Setting Up VS Code
    and Using the GitHub Project*.
  prefs: []
  type: TYPE_NORMAL
- en: Pillar 1 – Test codeunits and test functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Goal: Understand what test codeunits and test functions are and learn how to
    build and apply them.'
  prefs: []
  type: TYPE_NORMAL
- en: The foremost important pillar of the testability framework is the concept of
    test codeunits and test functions.
  prefs: []
  type: TYPE_NORMAL
- en: Test codeunits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A test codeunit is defined by its `Subtype`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes it different from a standard codeunit in a couple of ways:'
  prefs: []
  type: TYPE_NORMAL
- en: It can contain the so-called test and handler functions next to the normal functions
    we are used to when writing app code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When executing a test codeunit, the platform will do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the `OnRun` trigger and each test function that resides in the test codeunit,
    from top to bottom
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Record the result of each test function
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Test functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `Test` function is defined by the `FunctionType` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes it different from a standard function:'
  prefs: []
  type: TYPE_NORMAL
- en: It has to be global
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It cannot have arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It yields a result, which is either `SUCCESS` or `FAILURE`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When `SUCCESS` is returned by a test, it means that no error occurred in the
    execution of the test. Consequently, when `FAILURE` is returned, the test execution
    did throw an error. This error could be due to various reasons, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Code execution hitting a `TestField`, `FieldError`, or `Error` call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data modifications not being fulfilled because of version conflicts, primary
    key conflicts, or locks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latter, a `Test` function returning `FAILURE`, brings us to another typicality
    of a test codeunit—when a test fails, the execution of a test codeunit doesn't
    halt. It continues to execute the next `Test` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build two simple tests, one returning `SUCCESS` and the other `FAILURE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now you can run them.
  prefs: []
  type: TYPE_NORMAL
- en: 'As test functions are executed from top to bottom, the message thrown by `MyFirstTestFunction`
    will show the following screenshot first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0cb76f6-d505-4b6b-9384-9545f370c454.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After that, the following message is shown, being a resume message of the execution
    of the whole test codeunit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44828026-ff61-45fe-a743-0fb375a16aa2.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the error did not appear like a message box, but is collected by the
    platform and recorded as part of the result of the failing test.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to run the test codeunit, I built a simple page, `MyTestsExecutor`,
    with an action calling `MyFirstTestCodeunit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are following me using the code on GitHub and have a hard time opening
    the `MyTestsExecutor` page, use any of the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: Set `startupObjectType` to `Page` and `startupObjectId` to `60000` in the `launch.json`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add `?page=6000` to the web client URL in the address bar of your browser:
    `http://localhost:8080/BC130/?page=6000`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use *Alt* + *Q*, Tell me what you want, in the web client and search for `My
    Test Executor`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launch the page directly from the VS Code, making use of a VS Code AL extension
    such as CRS AL Language Extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pillar 2 – asserterror
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Goal: Understand what the `asserterror` keyword means and learn how to apply
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A substantial part of the business logic we implement specifies conditions
    under which a user action or a process should fail or stop to continue its execution.
    Testing the circumstances that lead to this failure are as important as testing
    the successful conclusion of an action or process. The second pillar allows us
    to write tests that are focused on checking whether errors do occur; a so called
    **positive-negative** or **rainy** **path** test. For example, that posting errors
    out because a posting date has not been provided, or that, indeed, a negative
    line discount percentage cannot be entered on a sales order line. To achieve this,
    the `asserterror` keyword should be applied in front of the `calling statement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use it in a new codeunit and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MyPostiveNegativeTestFunction` function is reported as a `SUCCESS`, and,
    consequently, no error message is recorded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b890c00-bb2a-4180-8e61-f48b5087bc1f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the `calling statement` following the `asserterror` keyword throws an error,
    the system will continue executing the following statements. However, if the `calling
    statement` does not throw an error, the `asserterror` statement will cause one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Where `asserterror` enables the test to continue with the next statement, it
    will not check the error as such. As we will see later, it is up to you to verify
    whether the expected did occur or not. If there is no verification on the specific
    error following the `asserterror`, any error will make your test pass.
  prefs: []
  type: TYPE_NORMAL
- en: If a successful positive-negative test does not report the error, this does
    not mean that the error did not occur. It is thrown, and, therefore, when a write
    transaction was performed, a rollback will happen. Any data modifications will
    disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Pillar 3 – handler functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Goal: Understand what handler functions are and learn how to build and apply
    them.'
  prefs: []
  type: TYPE_NORMAL
- en: In our first test codeunit example, the `Message` statement results in the display
    of a message box. Unless we want to wait until a user presses the OK button, this
    message box stays there forever, halting the full execution of our test run. In
    order to be able to have a fully automated test run, we need a way to deal with
    any user interactions, such as a message box, a confirm dialog, a report request
    page, or a modal page.
  prefs: []
  type: TYPE_NORMAL
- en: For this, handler functions, also known as **UI handlers**, have been conceived.
    Handler functions are a special type of function that can only be created in test
    codeunits, and aim at handling UI interactions that exist in the code under test.
    Handler functions enable us to fully automate tests without the need of a real
    user to interact with them. As soon as specific UI interactions occur, and a handler
    has been provided for it, the platform takes care of calling the handler as a
    substitute for real user interactions.
  prefs: []
  type: TYPE_NORMAL
- en: '`Test` function handler functions are defined by the `FunctionType` tag. The
    currently available values are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bda944f-078a-4348-a466-46e6002c987e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Each handler function addresses a different type of user interaction object
    and needs different parameters to let it interact adequately with the platform.
    Let VS Code and the AL extension be your guide in finding the right signature
    for a handler function. The following screenshot shows you the signature of a `MessageHandler`
    when you hover over the function name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/129e2d04-46fd-45a4-8936-fdcbb82a1390.png)'
  prefs: []
  type: TYPE_IMG
- en: In case of a `MessageHandler` function, the signature is the text the message
    box would show to the user. Handing over this text to the `MessageHandler` enables
    you to determine if the right message was triggered.
  prefs: []
  type: TYPE_NORMAL
- en: For a listing of the signature of each handler type, go to [https://docs.microsoft.com/en-us/dynamics-nav/how-to--create-handler-functions](https://docs.microsoft.com/en-us/dynamics-nav/how-to--create-handler-functions).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to get the `Message` statement handled automatically in our first test
    codeunit, we should create a `MessageHandler` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'But this is only half of the job, as this handler needs to be linked to the
    test that will execute the code calling `Message` one way or another. The `HandlerFunctions`
    tag is used to do this. Each handler function needs to be called in a `Test` function
    and must be added to the `HandlerFunctions` tag as text. If multiple handlers
    are needed, these will make up a comma separated string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s apply this to `MyFirstTestFunction` in a new codeunit and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Instantly, rather than showing a message box first, the resume message of the
    execution of the whole test codeunit is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8099a4c4-28b9-42cf-9382-55a173fe6ef1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Any handler function you add to the `HandlerFunctions` tag must be called at
    least one time in the `Test` function. If the handler is not called upon, because
    the user interactions it should handle don''t happen, an error will be thrown
    by the platform, saying: *The following UI handlers were not executed*, listing
    the handlers not called upon.'
  prefs: []
  type: TYPE_NORMAL
- en: Pillar 4 – Test runner and test isolation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Goal: Understand what a test runner and its test isolation are and learn how
    to use and apply them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the previous three pillars, we are positioned to write test cases as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using **test codeunit** and **test functions**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either *sunny* or *rainy path*, the latter by applying the `asserterror` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With fully automated execution addressing any user interactions by applying
    **handler functions**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we need more?
  prefs: []
  type: TYPE_NORMAL
- en: 'As a matter of fact, yes, we do, as we need a way to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Run tests stored in multiple codeunits, control their execution, and collect
    and secure the results
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run tests in isolation, so that we can achieve the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write transactions, in the end, do not alter the database we run the test on
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each rerun of a test is done using the same data setup
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both goals can be accomplished using a so-called `TestRunner` codeunit with
    a certain test isolation. A test runner codeunit is defined by its `Subtype` and
    the isolation by its `TestIsolation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Test runner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like any other codeunit, a test runner codeunit can have a `OnRun` trigger
    and normal user-defined functions, but, in addition to that, you can also add
    two test runner-specific triggers called `OnBeforeTestRun` and `OnAfterTestRun`.
    When test codeunits are called from the `OnRun` trigger of a test runner, `OnBeforeTestRun`
    and `OnAfterTestRun` will be triggered by the system as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnBeforeTestRun`: This is triggered before the test codeunit is called, the
    test codeunit `OnRun` trigger is executed, and each of its test functions is run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnAfterTestRun`: This is triggered after each test function has run and the
    test codeunit finishes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `OnBeforeTestRun` trigger to perform a test run pre-initialization and
    control the execution of a whole test codeunit and individual test functions.
    The latter can be achieved by using the Boolean return value of the `OnBeforeTestRun`
    trigger. Returning `TRUE`, the test codeunit or test function runs. Returning
    `FALSE`, it is skipped.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `OnAfterTestRun` trigger to perform post-processing, such as logging
    the result of each test. When the `OnAfterTestRun` trigger is run, the standard
    result message box, as we have seen so far, is not shown.
  prefs: []
  type: TYPE_NORMAL
- en: Both `OnBeforeTestRun` and `OnAfterTestRun` are run in their own database transaction.
    This means that changes made to the database with each of these triggers are committed
    once their execution finishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further reading can be found as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnBeforeTestRun`: [https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/triggers/devenv-trigger-onbeforetestrun](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/triggers/devenv-trigger-onbeforetestrun)
    [](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/triggers/devenv-trigger-onbeforetestrun)
    [`OnAfterTestRun`: ](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/triggers/devenv-trigger-onbeforetestrun)[https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/triggers/devenv-trigger-onaftertestrun](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/triggers/devenv-trigger-onaftertestrun)'
  prefs: []
  type: TYPE_NORMAL
- en: Test isolation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With a test runner enabling us to control the execution of all tests in one
    run, we also need to have control of the data created in one test codeunit, so
    that it will not influence the results of the tests in the next test codeunit.
    For this, the test codeunit `TestIsolation` property has been introduced, and
    it has three possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Disabled`: When selecting this value, or not setting the `TestIsolation` property
    explicitly, as this is the default value, any database transaction will be effectuated;
    after the execution of tests triggered by the test runner, the database will have
    changed compared to before running the test runner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codeunit`: When selecting this value, after a test codeunit execution has
    completed fully, all data changes made to the database will be reverted/rolled
    back'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Function`: When selecting this value, when a single test function has completed,
    all data changes made to the database will be reverted/rolled back'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Related to this, it makes sense to share a couple of thoughts on running tests
    and their isolation:'
  prefs: []
  type: TYPE_NORMAL
- en: Test isolation applies to database transactions, but does not apply to changes
    made outside of the database, and to variables, including temporary tables
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With test isolation, `Codeunit`, or `Function`, **all** data changes will be
    rolled back, even if they were explicitly committed using the AL `Commit` statement
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running test codeunits outside of the test isolation, either `Codeunit` or `Function` of
    a test runner will effectuate any database transaction
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using test isolation, `Function` will give extra overhead compared to `Codeunit`,
    resulting in longer execution time, as with the ending of each test function,
    the database changes have to be reverted
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting the test isolation to `Function` might be unwanted, as it fully disables
    dependencies between test functions, which might be needed when, for an extended
    test scenario, intermediate results should be reported, and this has been achieved
    by a series of individual, but interdependent, test functions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `TestIsolation` property of a test runner, we have control over how
    to revert data changes in a generic way; as we will later see, the test function
    `TransactionModel` tag allows us to have control of the transaction behavior of
    individual test functions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pillar 5 – Test pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Goal: Understand what test pages are and learn how to apply them when testing
    the UI.'
  prefs: []
  type: TYPE_NORMAL
- en: The initial trigger for adding the testability framework to the platform was
    to get away from testing the business logic through the UI. The testability framework
    enabled headless, and thus faster, testing of the business logic. And this is
    how the testability framework was implemented in NAV 2009 SP1\. Pure headless
    testing. It included everything of the four pillars discussed so far, even though
    test isolation was implemented in a different way than it is today. It was previously
    not possible to test the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving ahead, it became clear that sole headless tests excluded too much. How
    could we test business logic that typically resides on pages? For example, consider
    a product configurator in which options are displayed or hidden depending on values
    entered by the user. So, with NAV 2013, Microsoft added the fifth pillar to the
    testability framework: test pages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A test page is a logical representation of a page and is strictly handled in
    memory displaying no UI. To define a test page, you need to declare a variable
    of the `TestPage` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A `TestPage` variable can be based on any page existing in the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'A test page allows you to mimic a user carrying out the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing its sub parts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and changing data on it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing actions on it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can achieve this by using the various methods that belong to the test page
    object. Let''s build a small codeunit in which we use a couple of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that errors are forced to get some useful feedback on the resume message
    of the test codeunit.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we get the following as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/246fde13-01da-46b8-9cf3-fce9152c621f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For a complete listing of all test page methods, you can access the following
    URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TestPage**: [https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testpage/testpage-data-type](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testpage/testpage-data-type)
    [](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testpage/testpage-data-type)
    **TestField**: [https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testfield/testfield-data-type](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testfield/testfield-data-type)
    [](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testfield/testfield-data-type)
    **TestAction**: [https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testaction/testaction-data-type](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testaction/testaction-data-type)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are running Microsoft 365 Business Central on-premises and you want
    to run tests using test pages, be sure that you have the Page Testability module
    installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7de95738-6260-43a2-9a51-7492fe41e2e1.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed what the testability framework is by describing
    the five pillars it entails: the basic elements test codeunits and test functions,
    the new code keyword `asserterror`, handler functions to allow automatic handling
    of UI elements, the test runner to enable us to run tests in isolation, and, finally,
    test pages to build tests to check the behavior of pages.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](fdf2b65f-be7c-4710-a3a9-39f4cc34ee5c.xhtml), *The Test Tool and
    Standard Tests*, you will learn about the test tool that resides in Business Central
    and the set of standard tests being released by Microsoft with the product.
  prefs: []
  type: TYPE_NORMAL
