- en: From Customer Wish to Test Automation - The Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从客户需求到测试自动化 - 基础
- en: We are technically fully set to start writing tests at this point. This is because
    we know how the testability framework functions, we know the test toolkit, we
    know about the existence of the standard test libraries, and we have been provided
    with various patterns to allow us to design efficient and effective tests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从技术上已经完全准备好开始编写测试。这是因为我们了解测试框架的运作方式，知道测试工具包，了解标准测试库的存在，并且已经获得了多种模式，帮助我们设计高效且有效的测试。
- en: But what are we going to test? What's our business case? What are the customer
    wishes we are going to implement?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们要测试什么呢？我们的业务案例是什么？我们将要实现的客户需求是什么？
- en: In this chapter, we will start applying the principles and techniques discussed
    in the previous chapters and we will build a number of basic automated tests.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始应用前几章讨论的原则和技术，并将构建一些基本的自动化测试。
- en: 'As such, this chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章涉及以下主题：
- en: Test example 1 – A first headless test
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试示例 1 – 第一个无头测试
- en: Test example 2 – A first positive-negative test
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试示例 2 – 第一个正负测试
- en: Test example 3 – A first UI test
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试示例 3 – 第一个 UI 测试
- en: Headless versus UI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无头与 UI
- en: From customer wish to test automation
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从客户需求到测试自动化
- en: 'Our customer wishes to extend standard Dynamics 365 Business Central with an
    elementary feature: the addition of a lookup field to the `Customer` table to
    be populated by the user. This field has to be carried over to the whole bunch
    of sales documents and also needs to be included in the warehouse shipping.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户希望扩展标准的 Dynamics 365 Business Central，增加一个基本功能：向 `Customer` 表中添加一个由用户填充的查找字段。该字段必须被传递到所有销售单据中，并且还需要包含在仓库发货中。
- en: Data model
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据模型
- en: Even though the purpose of such a field will be very specific, we will generically
    name it `Lookup Value Code`. As with any other lookup field in Business Central,
    this `Lookup Value Code` field will have a table relation (foreign key) with another
    table, in our case a new table called `Lookup Value`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管此字段的目的非常具体，我们将其通用命名为 `Lookup Value Code`。与 Business Central 中的任何其他查找字段一样，该
    `Lookup Value Code` 字段将与另一个表（我们这里是一个名为 `Lookup Value` 的新表）有一个表关系（外键）。
- en: 'The following relational diagram schematically describes the data model of
    this new feature, with the new table in the middle and the extended standard tables
    on the left and right sides:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下关系图示意性地描述了此新功能的数据模型，其中新的表位于中间，扩展的标准表位于左右两侧：
- en: '![](img/0944f2d1-a2c6-48f2-81e9-a322779925cf.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0944f2d1-a2c6-48f2-81e9-a322779925cf.png)'
- en: The `Lookup Value Code` field has to be editable on all tables except for the
    posted document header tables, that is, `Sales Shipment Header`, `Sales Invoice
    Header`, `Sales Cr.Memo Header`, `Return Receipts Header`, and `Posted Whse. Shipment
    Line`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lookup Value Code` 字段必须在所有表中可编辑，除了已过账的单据头表，例如：`Sales Shipment Header`、`Sales
    Invoice Header`、`Sales Cr.Memo Header`、`Return Receipts Header` 和 `Posted Whse.
    Shipment Line`。'
- en: Business logic
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务逻辑
- en: 'In compliance with standard Business Central behavior, the following business
    logic applies:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据标准的 Business Central 行为，以下业务逻辑适用：
- en: When creating a customer from a customer template, the `Lookup Value Code` field
    should be inherited from `Customer Template` to `Customer`
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从客户模板创建客户时，`Lookup Value Code` 字段应从 `Customer Template` 继承到 `Customer`
- en: When selecting a customer in the `Sell-to Customer` field on a sales document,
    the `Lookup Value Code` field should be inherited from the `Customer` to `Sales
    Header`
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在销售单据的 `Sell-to Customer` 字段中选择客户时，`Lookup Value Code` 字段应从 `Customer` 继承到 `Sales
    Header`
- en: When posting a sales document, it is mandatory that the `Lookup Value Code`
    field is populated
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在过账销售单据时，`Lookup Value Code` 字段必须被填充
- en: When posting a sales document, the `Lookup Value Code` field should be inherited
    from `Sales Header` to the header of the posted document. That is,
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在过账销售单据时，`Lookup Value Code` 字段应从 `Sales Header` 继承到已过账单据的头部。也就是说，
- en: '`Sales Shipment Header`'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sales Shipment Header`'
- en: '`Sales Invoice Header`'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sales Invoice Header`'
- en: '`Sales Cr.Memo Header`'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sales Cr.Memo Header`'
- en: '`Return Receipt Header`'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Return Receipt Header`'
- en: When archiving a sales document, the `Lookup Value Code` field should be inherited
    from `Sales Header` to `Sales Header Archive`
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在归档销售单据时，`Lookup Value Code` 字段应从 `Sales Header` 继承到 `Sales Header Archive`
- en: When creating a warehouse shipment from a sales order, the `Lookup Value Code`
    field should be inherited from `Sales Header` to `Warehouse Shipment Line`
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在从销售订单创建仓库出货单时，`Lookup Value Code`字段应从`Sales Header`继承到`Warehouse Shipment Line`。
- en: When posting a warehouse shipment, the `Lookup Value Code` field should be inherited
    from `Warehouse Shipment Line` to `Posted Whse. Shipment Line`
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发布仓库出货单时，`Lookup Value Code`字段应从`Warehouse Shipment Line`继承到`Posted Whse. Shipment
    Line`。
- en: LookupValue extension
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LookupValue扩展
- en: Based on these requirements, the `LookupValue` extension will be built, including
    automated tests.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些需求，将构建`LookupValue`扩展，包括自动化测试。
- en: Implementing a defined customer wish
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个已定义的客户需求
- en: 'Now that we have a clearly defined customer wish, we can start to implement
    it. As already introduced in the previous chapter, we will *kill five birds in
    one stroke*, that is, break down each wish into a list of tests for the following
    purposes:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的客户需求已清晰定义，我们就可以开始实现它。如前一章所述，我们将*一箭双雕*，即将每个需求分解为一系列测试，目的是：
- en: Detailing of **customer wish**
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**客户需求**的详细描述'
- en: Implementation of **application code**
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**应用代码**的实现'
- en: Structured execution of **manual tests**
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**手动测试**的结构化执行'
- en: Coding of **test automation**
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试自动化**的编码'
- en: Up-to-date **documentation** of solution
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最新的**文档**解决方案
- en: Consequently, in the next basic test case examples, and the ones following in
    [Chapter 6](0f8efb81-438e-48ed-9f7f-bcfa5caa8e92.xhtml), *From Customer Wish to
    Test Automation - Next Level*, and [Chapter 7](bb9ee41e-4c60-4a27-8fad-5343adfcd86a.xhtml),
    *From Customer Wish to Test Automation - And Some More*, we will describe the
    *customer wish* by means of the **Acceptance Test-Driven Development** (**ATDD**)
    pattern. Using the `FEATURE`, `SCENARIO`, `GIVEN`, `WHEN`, and `THEN` tags, we
    will discuss the **application code** implementation and elaborate more extensively
    on the coding of the **test automation**.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在接下来的基础测试案例示例中，以及[第6章](0f8efb81-438e-48ed-9f7f-bcfa5caa8e92.xhtml)，*从客户需求到测试自动化
    - 下一步*，和[第7章](bb9ee41e-4c60-4a27-8fad-5343adfcd86a.xhtml)，*从客户需求到测试自动化 - 以及更多*，我们将通过**验收测试驱动开发**（**ATDD**）模式描述*客户需求*。使用`FEATURE`、`SCENARIO`、`GIVEN`、`WHEN`和`THEN`标签，我们将讨论**应用代码**的实现，并更广泛地阐述**测试自动化**的编码。
- en: '**Manual test** and **documentation** is out of the scope of the book.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**手动测试**和**文档**超出了本书的范围。'
- en: 'The `LookupValue` extension can be found on GitHub: [https://github.com/PacktPublishing/Automated-Testing-in-Microsoft-Dynamics-365-Business-Central](https://github.com/PacktPublishing/Automated-Testing-in-Microsoft-Dynamics-365-Business-Central).
    [](https://github.com/PacktPublishing/Automated-Testing-in-Microsoft-Dynamics-365-Business-Central)
    This repository also includes an Excel file containing a listing of all ATDD scenarios
    that apply to the `LookupValue` extension. Even though we will pick out specific
    scenarios as examples to elaborate on, note that the whole list of scenarios has
    been conceived upfront describing in full the extent of the customer wish.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`LookupValue`扩展可以在GitHub上找到：[https://github.com/PacktPublishing/Automated-Testing-in-Microsoft-Dynamics-365-Business-Central](https://github.com/PacktPublishing/Automated-Testing-in-Microsoft-Dynamics-365-Business-Central)。这个仓库还包括一个Excel文件，列出了所有适用于`LookupValue`扩展的ATDD场景。虽然我们会选取特定场景作为示例进行详细说明，但请注意，整个场景列表是在一开始就设计好的，完整描述了客户需求的范围。'
- en: Details on how to use this repository and how to set up VS Code are discussed
    in [Appendix B](bbbc6672-5043-422a-b54e-a09df933c909.xhtml), *Setting Up VS Code
    and Using the GitHub Project*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使用此仓库以及如何设置VS Code的详细信息，请参阅[附录B](bbbc6672-5043-422a-b54e-a09df933c909.xhtml)，*设置VS
    Code并使用GitHub项目*。
- en: Test example 1 – a first headless test
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试示例1 - 第一个无头测试
- en: Now, with our backpack full of tools handed over in the previous chapters, and
    the customer wish defined, we're set to start creating our first automated test.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，带着前几章交给我们的工具包，并且客户需求已定义，我们准备开始创建第一个自动化测试。
- en: Customer wish
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户需求
- en: 'Let''s pick up the fundamental part of our complete customer wish: the extension
    of the `Customer` table with a `Lookup Value Code` field.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从完整客户需求的基础部分开始：在`Customer`表中扩展一个`Lookup Value Code`字段。
- en: FEATURE
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能
- en: 'The feature we are building with our extension is called `LookupValue` and
    the specific part we are now working on is the `Customer` table. This leads to
    the following `[FEATURE]` tag:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在通过扩展构建的功能称为`LookupValue`，而我们现在正在处理的特定部分是`Customer`表。这导致了以下`[FEATURE]`标签：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: SCENARIO
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景
- en: 'The specific scenario to be implemented and tested is the assignment of a lookup
    value to a customer, so the `[SCENARIO]` tag would be as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现并测试的具体场景是将查找值分配给客户，因此`[SCENARIO]`标签应如下所示：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: GIVEN
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GIVEN
- en: 'The fixtures we need in order to assign a lookup value are a lookup value record
    and a customer record. Thus, we need the following two `[GIVEN]` tags:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的固定数据以便分配查找值，是一个查找值记录和一个客户记录。因此，我们需要以下两个`[GIVEN]`标签：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: WHEN
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WHEN
- en: 'Given the fixture, we can set the lookup value code on the `Customer` record
    and therefore define our `[WHEN]` tag as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 根据固定数据，我们可以在`Customer`记录上设置查找值代码，因此我们的`[WHEN]`标签可以定义如下：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: THEN
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: THEN
- en: 'Now that the action under test has been exercised, it is time to verify the
    result. Did the lookup value code field indeed get the lookup value from our fixture
    assigned to the customer record? This leads to the following `[THEN]` tag:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试操作已经执行过了，是时候验证结果了。查找值代码字段是否确实从我们分配给客户记录的固定数据中获取了查找值？这就导致了以下`[THEN]`标签：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Complete scenario
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完整场景
- en: 'So, the complete scenario definition would then be to allow us to copy it later
    when creating our test code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，完整的场景定义将允许我们稍后在创建测试代码时进行复制：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Application code
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序代码
- en: 'The first part of the customer wish, that is, `[SCENARIO #0001]`, defines the
    need for a `LookupValue`, which is a new table, from which a value can be assigned
    to a customer by means of a so-called `Lookup Value Code` field. This has been
    implemented by means of the following `.al` objects:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '客户需求的第一部分，即`[SCENARIO #0001]`，定义了对`LookupValue`的需求，这是一个新表，通过该表可以通过所谓的`Lookup
    Value Code`字段将一个值分配给客户。这已经通过以下`.al`对象实现：'
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the application code, the bare minimum has been included to save space. Properties
    like `Caption`, `ApplicationArea`, `DataClassification`, `UsageCategory`, and
    `ToolTip` have been left out. Download the `LookupValue` extension from GitHub
    to get the complete objects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序代码中，已经包含了最基本的内容以节省空间。像`Caption`、`ApplicationArea`、`DataClassification`、`UsageCategory`和`ToolTip`等属性已经省略。你可以从GitHub下载`LookupValue`扩展以获取完整的对象。
- en: Test code
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试代码
- en: With the first part of the customer wish clear, we have a neat structure to
    start writing our first test.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 随着客户需求的第一部分已经明确，我们有了一个整洁的结构来开始编写我们的第一个测试。
- en: Steps to take
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要采取的步骤
- en: 'The following are the steps to take:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是需要采取的步骤：
- en: Create a test codeunit, with a name based on `[FEATURE]` tag
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个以`[FEATURE]`标签为基础命名的测试代码单元
- en: Embed the customer wish into a test function with a name based on `[SCENARIO]`
    tag
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将客户需求嵌入到基于`[SCENARIO]`标签命名的测试函数中
- en: Write your test story, based upon `[GIVEN]`, `[WHEN]`, and `[THEN]` tags
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于`[GIVEN]`、`[WHEN]`和`[THEN]`标签编写你的测试故事
- en: Construct your real code
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写你的实际代码
- en: Create a test codeunit
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个测试代码单元
- en: 'Using `[FEATURE]` tag name the basic structure of our codeunit will be like
    this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`[FEATURE]`标签命名时，我们的代码单元的基本结构将是这样的：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, the UT added to the `[FEATURE]` tag stands for Unit Test, marking
    that the tests are unit tests and not functional tests.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，添加到`[FEATURE]`标签的UT代表单元测试，标明这些测试是单元测试而非功能测试。
- en: 'As an easy start: codeunit 81000 already exists in the `LookupValue` extension
    on GitHub.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个简单的开始：`LookupValue`扩展中的代码单元81000已经存在于GitHub上。
- en: Embed the customer wish into a test function
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将客户需求嵌入到测试函数中
- en: Now, we create a test function with a name based on the `SCENARIO` description
    and embed the customer wish, `GIVEN`-`WHEN`-`THEN`, in this function.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们基于`SCENARIO`描述创建一个测试函数，并在此函数中嵌入客户需求，`GIVEN`-`WHEN`-`THEN`。
- en: 'I call this "embedding the *green*", being the out-commented `GIVEN`-`WHEN`-`THEN`
    sentences, before you start programming the *black*, being the `.al` test code. Look
    at what the codeunit has now become:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我称之为“嵌入*绿色*”，即在你开始编写*黑色*的`.al`测试代码之前，先写下被注释掉的`GIVEN`-`WHEN`-`THEN`语句。看看现在代码单元已经变成了什么样：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Write your test story
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写你的测试故事
- en: For me, writing the first *black* parts is about writing pseudo-English, defining
    what I need to achieve with my test. It makes my test readable by any non-technical
    peer in the project, and, if I need their support, the threshold for them to read
    the test is substantially lower than when I would have immediately started to
    write the *real* thing. And, maybe an even stronger argument—I will have my code
    embedded in reusable helper functions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，编写第一个*黑色*部分是写伪英语，定义我通过测试需要实现的目标。这使得任何非技术背景的项目成员都能读懂我的测试，如果我需要他们的支持，他们阅读测试的门槛比直接开始写*真实*代码时低得多。而且，或许更有力的论据是——我的代码将嵌入到可复用的辅助函数中。
- en: 'So here we go, let''s write the *black* parts:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们开始吧，让我们编写*黑色*部分：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With this story, I have been designing four helper functions with no argument(s)
    and return value yet. These will be defined in the next step.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个故事中，我设计了四个没有参数和返回值的辅助函数。这些将在下一步中定义。
- en: Note how close the names of the helper functions are to the description of the
    tag it belongs to.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，辅助函数的名称与它所属标签的描述有多么接近。
- en: Construct the real code
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建实际代码
- en: If you're a developer, I might have been challenging you with my pseudo code
    up until this point, using no real code but only a structure. Now, ready yourself
    as the real part starts right now, and I hope, for you and your peers, you will
    do the same with the tests you will be coding yourself in the future.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是开发人员，直到目前为止，我可能一直在用伪代码挑战你，虽然没有真正的代码，只有一个结构。现在，准备好迎接真正的部分吧，我希望你和你的同事们将来也能在未来编写的测试中做到同样的事情。
- en: 'While inspecting our first test function, I already concluded that I need the
    following four helper functions:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查我们的第一个测试函数时，我已经得出结论，我需要以下四个辅助函数：
- en: '`CreateLookupValueCode`'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CreateLookupValueCode`'
- en: '`CreateCustomer`'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CreateCustomer`'
- en: '`SetLookupValueOnCustomer`'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SetLookupValueOnCustomer`'
- en: '`VerifyLookupValueOnCustomer`'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VerifyLookupValueOnCustomer`'
- en: Let's construct and discuss these.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建并讨论这些。
- en: CreateLookupValueCode
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CreateLookupValueCode
- en: '`CreateLookupValueCode` is a manifold reusable helper function to create a
    pseudo-random `LookupValue` record as follows. In a later stage, we could promote
    this to a to be created library codeunit:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateLookupValueCode`是一个多用途的可重用辅助函数，用于创建一个伪随机的`LookupValue`记录，如下所示。在后续阶段，我们可以将其提升为一个待创建的库代码单元：'
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To populate the `PK` field, we make use of the `GenerateRandomCode` function
    from the standard test library `Library - Utility`, codeunit 131000. The `LibraryUtility` variable will
    be declared globally as Microsoft does in their test codeunits, making it reusable
    in other helper functions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了填充`PK`字段，我们利用标准测试库`Library - Utility`中的`GenerateRandomCode`函数，代码单元131000。`LibraryUtility`变量将像Microsoft在他们的测试代码单元中做的那样全局声明，使其可以在其他辅助函数中重用。
- en: Pseudo-random means that, whenever our test is executed in the same context,
    the `GenerateRandomCode` function will yield the same value, contributing to a
    reproducible test.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 伪随机意味着，每当我们的测试在相同上下文中执行时，`GenerateRandomCode`函数将产生相同的值，从而有助于测试的可重复性。
- en: The `Description` field is populated by the same value as the `Code` field as
    the specific value of `Description` is of no meaning, and this way it is the most
    effective.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Description`字段的值与`Code`字段相同，因为`Description`的具体值没有意义，这样做是最有效的。'
- en: I'll be using the `with…do` construct very often in my helper functions; this
    allows easy reusability of helper functions for similar purposes but applied to
    other tables as we only need to update the record variable (and the table it is
    referencing).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在我的辅助函数中非常频繁地使用`with…do`结构；这使得辅助函数可以轻松地在相似的场景中重用，但只需要更新记录变量（以及它所引用的表），即可应用到其他表。
- en: CreateCustomer
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CreateCustomer
- en: 'Using the `CreateCustomer` function in the standard library codeunit `Library
    - Sales`, codeunit 130509, our `CreateCustomer` creates a useable customer record
    and makes this helper function a straightforward exercise:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准库代码单元`Library - Sales`中的`CreateCustomer`函数，代码单元130509，我们的`CreateCustomer`函数创建了一个可用的客户记录，并使这个辅助函数成为一个直接的练习：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As with the preceding `LibraryUtility` variable, we will declare the `LibrarySales`
    variable globally.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前的`LibraryUtility`变量一样，我们将全局声明`LibrarySales`变量。
- en: You might wonder why we create a helper function that only has one statement
    line. As mentioned, using helper functions makes the test readable for non-technical
    peers as well as making it reusable. However, it also makes it more maintainable/extendable.
    If we need to add an update to the customer record created by the `CreateCustomer`
    function in the `Library - Sales` codeunit, we only need to add that to our local
    `CreateCustomer` function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么我们要创建一个只有一行语句的辅助函数。如前所述，使用辅助函数可以使测试对非技术同事可读，同时使其可重用。它还使其更具可维护性/扩展性。如果我们需要对由`Library
    - Sales`代码单元中的`CreateCustomer`函数创建的客户记录进行更新，我们只需要将更新添加到我们的本地`CreateCustomer`函数中。
- en: As a general rule, I never call library functions directly from test functions.
    This comes with some exceptions, as we will see later.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我从不直接在测试函数中调用库函数。这有一些例外，我们稍后会看到。
- en: SetLookupValueOnCustomer
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SetLookupValueOnCustomer
- en: 'Have a look at the implementation of `SetLookupValueOnCustomer`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`SetLookupValueOnCustomer`的实现：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Calling `Validate` is essential here. `SetLookupValueOnCustomer` is not just
    about assigning a value to the `Lookup Value Code` field, but also about making
    sure it is validated against the existing values in the `LookupValue` table. Note
    from the following that the `OnValidate` trigger of the `Lookup Value Code` field
    does not contain code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里调用`Validate`是至关重要的。`SetLookupValueOnCustomer`不仅仅是将值分配给`Lookup Value Code`字段，还确保该值会与`LookupValue`表中已有的值进行验证。请注意，下面的`Lookup
    Value Code`字段的`OnValidate`触发器没有包含代码。
- en: VerifyLookupValueOnCustomer
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VerifyLookupValueOnCustomer
- en: 'As mentioned in [Chapter 4](db955f66-11f4-4d9a-90c7-5af04058ebbe.xhtml), *Test
    Design*, *a test without verification is no test at all*, we need to verify that
    the lookup value code assigned to the `Lookup Value Code` field of the customer
    record is indeed the value that was created in the `Lookup Value` table. We, therefore,
    retrieve the record from the database as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第4章](db955f66-11f4-4d9a-90c7-5af04058ebbe.xhtml)《*测试设计*》中提到的，*没有验证的测试根本不是测试*，我们需要验证分配给客户记录中`Lookup
    Value Code`字段的查找值代码，确实是`Lookup Value`表中创建的值。因此，我们从数据库中检索记录，如下所示：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To verify that the expected value (first argument) and the actual value (second
    argument) are equal, we make use of the `AreEqual` function in the standard library
    codeunit `Assert`, 130000\. Of course, we could build our own verification logic
    using the `Error` system function, and that''s what `AreEqual` is doing. Have
    a look:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证预期值（第一个参数）和实际值（第二个参数）是否相等，我们使用标准库代码单元`Assert`中的`AreEqual`函数，130000。当然，我们也可以使用`Error`系统函数构建自己的验证逻辑，而`AreEqual`正是这么做的。看看这个：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By using the `AreEqual` function, we ensure that we get a standardized error
    message in case the expected and actual values are not equal. Over time, by reading
    the error of any failing test where the verification helper functions are making
    using of the `Assert` library, you will be able to recognize easily what kind
    of error occurred.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`AreEqual`函数，我们确保在预期值和实际值不相等时会收到标准化的错误信息。随着时间的推移，通过阅读任何失败测试的错误，其中验证辅助函数使用了`Assert`库，您将能够轻松识别发生了哪种错误。
- en: 'Our complete test codeunit would look like the following code that is ready
    for execution. Notice the variables and arguments added to the test codeunit and
    functions:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完整的测试代码单元将如下所示，准备执行。注意添加到测试代码单元和函数中的变量和参数：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Test execution
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试执行
- en: 'Now that we are ready with our first test, we can deploy the `LookupValue`
    extension to our Dynamics 365 Business Central installation. If we set the test
    tool page as the start object in the `launch.json`, we can immediately add our
    test codeunit to the `DEFAULT` suite as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好进行第一次测试，可以将`LookupValue`扩展部署到我们的Dynamics 365 Business Central安装中。如果我们将测试工具页面设置为`launch.json`中的启动对象，我们可以立即将我们的测试代码单元添加到`DEFAULT`套件中，如下所示：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Running the test by selecting the Run action will show that it executes successfully.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择“运行”操作来运行测试，将显示它成功执行。
- en: '![](img/cd822a48-df32-40e8-ad0a-bf4858f64466.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd822a48-df32-40e8-ad0a-bf4858f64466.png)'
- en: Congratulations, we have implemented our first successful test as the preceding
    screenshot shows!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，我们已经实现了第一个成功的测试，如上面的截图所示！
- en: Test the test
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试测试
- en: 'During my workshop, some skeptical minds would challenge me and cause me to
    ask: "Indeed the test result is successful, but how do I know success is a real
    success? How can I test the test?"'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的工作坊期间，一些怀疑的声音会挑战我，让我问：“确实，测试结果是成功的，但我怎么知道成功是真正的成功？我如何测试测试？”
- en: 'You have the following two options to test it:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您有以下两种方式来测试它：
- en: Test the data being created
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试创建的数据
- en: Adjust the test so the verification errs
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整测试，使验证出现错误
- en: Test the data being created
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试创建的数据
- en: 'Testing the data being created can be done in two ways:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数据的测试可以通过两种方式进行：
- en: Run the test outside of a test isolation and have a look at the `Customer` table.
    Find out that a new customer has been created with the `Lookup Value Code` field
    populated, and, of course, a related record in the `Lookup Value` table
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在没有测试隔离的情况下运行测试，并查看`Customer`表。发现一个新客户已创建，且`Lookup Value Code`字段已填充，当然，还在`Lookup
    Value`表中创建了相关记录。
- en: Debug your test and, using SQL Server Management Studio, run SQL queries on
    the `Customer` and `Lookup Value` table. Make sure that you read uncommitted data
    to find the same records before the test is finished.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调试您的测试，并使用SQL Server Management Studio在`Customer`和`Lookup Value`表上运行SQL查询。确保您读取的是未提交的数据，在测试完成之前找到相同的记录。
- en: The latter is my preferred method as it makes it possible to run tests in isolation,
    thus not changing the database irreversibly. It also allows us to see what data
    is being created.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 后者是我更喜欢的方法，因为它使得可以在隔离的环境中运行测试，从而不会不可逆转地更改数据库。它还允许我们看到正在创建的数据。
- en: Note that the second option Debug your test and run SQL queries is only possible
    in an on-premises or containerized installation of Dynamics 365 Business Central.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第二个选项“调试你的测试并运行SQL查询”仅在本地或容器化安装的Dynamics 365 Business Central中可用。
- en: Adjust the test so the verification errs
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整测试，使验证出现错误
- en: 'This is maybe the easiest and most robust option: make sure the verification
    fails by providing another value for the expected result. In the case of our test,
    for example, your own name:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是最简单和最可靠的选项：通过提供另一个期望结果值来确保验证失败。例如，在我们的测试中，可以使用你自己的名字：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As shown in the next screenshot the test indeed fails on the verification part:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，测试确实在验证部分失败：
- en: '![](img/9710545a-fbdf-42e0-ac63-19961e8fcc84.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9710545a-fbdf-42e0-ac63-19961e8fcc84.png)'
- en: 'The error thrown tells us that the expected value is `LUC` while the actual
    value is `GU00000000`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出的错误告诉我们，期望值是`LUC`，而实际值是`GU00000000`：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As mentioned before, First Error is a FlowField into which you can drill down.
    It will open the CAL Test Result window, which displays the whole test run history
    for a specific test. As the next screenshot displays, in case of the current test,
    it shows two lines being the results of the two runs we did for `AssignLookupValueToCustomer`
    so far:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，First Error是一个FlowField，你可以深入了解它。它将打开CAL测试结果窗口，显示特定测试的完整运行历史记录。正如下一个截图所示，在当前测试的情况下，它显示了我们迄今为止对`AssignLookupValueToCustomer`执行的两次测试结果：
- en: '![](img/70e45ea8-33b9-48da-a29b-4c71b4448071.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70e45ea8-33b9-48da-a29b-4c71b4448071.png)'
- en: 'Note that the Clear Results feature on the Test Tool window, as shown in the
    following screenshot, does not have an effect on the test run history as it will
    only clear the results displayed in the Test Tool window:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如下图所示，测试工具窗口中的“清除结果”功能不会对测试运行历史产生影响，它仅清除在测试工具窗口中显示的结果：
- en: '![](img/feb4bf03-302e-427a-9afb-b7c32af73441.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/feb4bf03-302e-427a-9afb-b7c32af73441.png)'
- en: Test example 2 – a first positive-negative test
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试示例2 —— 第一个正负测试
- en: 'This test example does not relate to a new customer wish and no new application
    code, but is complementary to our first test. It is a rainy path version of the
    same customer wish leading to a new scenario:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试示例与新的客户需求和新的应用程序代码无关，而是补充我们的第一个测试。它是相同客户需求的“雨天路径”版本，导致了新的场景：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Test code
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试代码
- en: Let's reuse the recipe applied for test example 1.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新使用应用于测试示例1的配方。
- en: Steps to take
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要采取的步骤
- en: 'You might already recall these are the steps to take:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经记得，以下是需要采取的步骤：
- en: Create a test codeunit, with a name based on the `[FEATURE]` tag
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试代码单元，名称应基于`[FEATURE]`标签
- en: Embed the customer wish into a test function with a name based on the `[SCENARIO]`
    tag
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将客户需求嵌入到测试函数中，名称应基于`[SCENARIO]`标签
- en: Write your test story, based on `[GIVEN]`, `[WHEN]`, and `[THEN]` tags
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据`[GIVEN]`、`[WHEN]`和`[THEN]`标签编写测试故事
- en: Construct your real code
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造你的实际代码
- en: Create a test codeunit
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个测试代码单元
- en: Sharing the same `[FEATURE]` tag values as test example 1, our new test case
    will share the same test codeunit, that is, codeunit 81000 `LookupValue UT Customer`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与测试示例1共享相同的`[FEATURE]`标签值，我们的新测试用例将共享相同的测试代码单元，即代码单元81000 `LookupValue UT Customer`。
- en: Embed the customer wish into a test function
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将客户需求嵌入到测试函数中
- en: '*Embedding the green* results in the following new test function in codeunit
    81000:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*嵌入绿色*结果将导致代码单元81000中以下新的测试函数：'
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Write your test story
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写你的测试故事
- en: 'Filling in the first *black* "story elements" leads to the following typical
    choices:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 填写第一个*黑色*“故事元素”会导致以下典型选择：
- en: Creating a non-existing lookup value is achieved by just providing a string
    constant that has no related record in the `Lookup Value` table.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个不存在的查找值只需提供一个在`Lookup Value`表中没有相关记录的字符串常量。
- en: To assign this value to the `Lookup Value Code` field on a customer, we do not
    need a customer record in the database. A local variable suffices to trigger the
    error we want to happen.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了将此值分配给客户的`Lookup Value Code`字段，我们不需要数据库中的客户记录。一个本地变量足以触发我们希望发生的错误。
- en: Setting the lookup value on the customer can be achieved by using the `SetLookupValueOnCustomer`
    from test example 1.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过使用测试示例1中的`SetLookupValueOnCustomer`来设置客户的查找值。
- en: 'As a consequence, the *test story* already has some more details than our previous
    test:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，*测试故事* 比我们之前的测试有更多细节：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Construct the real code
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建实际代码
- en: Reusing the `SetLookupValueOnCustomer` function, we only need to create one
    new helper function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 重用 `SetLookupValueOnCustomer` 函数，我们只需要创建一个新的辅助函数。
- en: VerifyNonExistingLookupValueError
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VerifyNonExistingLookupValueError
- en: 'Like in our first verification function, we make use of a function from the
    standard library codeunit `Assert` (130000) called `ExpectedError`. We only need
    to provide `ExpectedError` the expected error text. The actual error will be retrieved
    by `ExpectedError` using the `GetLastErrorText` system function as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在第一个验证函数中一样，我们使用了来自标准库代码单元 `Assert`（130000）中的 `ExpectedError` 函数。我们只需要向
    `ExpectedError` 提供预期的错误文本。实际的错误将通过 `ExpectedError` 使用 `GetLastErrorText` 系统函数来获取，如下所示：
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note how the expected error text is constructed by using the `StrSubstNo` system
    method in conjunction with the `ValueCannotBeFoundInTableTxt` label.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意如何通过结合使用 `StrSubstNo` 系统方法和 `ValueCannotBeFoundInTableTxt` 标签来构造预期的错误文本。
- en: Test execution
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试执行
- en: 'Let''s redeploy our extension and add the second test to the test tool by selecting
    Actions | Functions | Get Test Methods. Get Test Methods will update the selected
    test codeunit by adding all current test functions residing in the codeunit as
    lines to the test tool. Note that the Result column will be cleared. Now, run
    the test codeunit and see that both tests are successful:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新部署我们的扩展，并通过选择操作 | 函数 | 获取测试方法，将第二个测试添加到测试工具中。获取测试方法将通过将所有当前的测试函数作为行添加到测试工具中来更新选定的测试代码单元。请注意，结果列将被清空。现在，运行测试代码单元并查看两个测试都成功了：
- en: '![](img/417eba3e-1a53-4ee9-bfec-0f2dddc130a4.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/417eba3e-1a53-4ee9-bfec-0f2dddc130a4.png)'
- en: Test the test
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 测试
- en: 'How to verify that *the success is a real success*? We can do this in a similar
    way as we did with test example 1: provide a different expected value to the verification
    function of our test case. So let''s do it.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如何验证 *成功是真正的成功*？我们可以像在测试示例 1 中那样通过为测试用例的验证函数提供不同的预期值来做到这一点。所以让我们来做吧。
- en: Adjust the test so the verification errs
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整测试使验证出错
- en: 'Let’s adjust the verification in a similar way as we did in test example 1:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以与测试示例 1 类似的方式调整验证：
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is shown in the following screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示在以下截图中：
- en: '![](img/029e3190-2e5a-4756-99dc-13663ecd0b35.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/029e3190-2e5a-4756-99dc-13663ecd0b35.png)'
- en: 'The error thrown tells us that the expected value is `LUC` while the actual
    value is `SC #0002` as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '抛出的错误告诉我们预期值是 `LUC`，而实际值是 `SC #0002`，如下所示：'
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Removing asserterror
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除 asserterror
- en: 'With rainy path scenarios, we typically use an `asserterror` to wrap the `[WHEN]`
    part to catch the error, but we have another way to *test the test*: by removing
    the `asserterror` and running the test again. Now, you will get to see the real
    error:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在雨路径场景中，我们通常使用 `asserterror` 来包裹 `[WHEN]` 部分以捕获错误，但我们还有另一种方法来 *测试测试*：通过移除 `asserterror`
    并再次运行测试。现在，你将看到真正的错误：
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This error message allows us to build a text label in .al to construct the expected
    error.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 该错误消息允许我们在 .al 中构建文本标签来构造预期的错误。
- en: The `Modify` in `SetLookupValueOnCustomer` strictly is not possible in test
    example 2 as we do not retrieve a customer record from the database. The error
    thrown by the `Validate`, however, will prevent the `Modify` from being called.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试示例 2 中，由于我们没有从数据库中检索客户记录，因此 `SetLookupValueOnCustomer` 中的 `Modify` 严格来说是不可能的。然而，`Validate`
    抛出的错误将阻止 `Modify` 被调用。
- en: Test example 2 is built upon the assumption that the `TableRelation` set on
    the `Lookup Value Code` field on the `Customer` table uses the default setting
    of the `ValidateTableRelation` property on that field.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 测试示例 2 基于以下假设：在 `Customer` 表的 `Lookup Value Code` 字段上设置的 `TableRelation` 使用该字段上
    `ValidateTableRelation` 属性的默认设置。
- en: Test example 3 – a first UI test
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试示例 3 – 第一个 UI 测试
- en: The field `Lookup Value Code` had been implemented on the `Customer` table and
    tested. But, of course, to allow users to manage it, it needs to be made accessible
    in the UI. Consequently, it needs to be placed on the `Customer Card`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lookup Value Code` 字段已在 `Customer` 表上实现并经过测试。但当然，为了让用户管理它，必须使其在 UI 中可访问。因此，它需要被放置在
    `Customer Card` 上。'
- en: Customer wish
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户愿望
- en: 'The next stage of the customer wish is very close to the previous part defined
    by `[SCENARIO #0001]`. The main difference is that we now want to access a customer
    by means of the UI element `Customer Card`. By mimicking end users, our scenario
    describes creating a new `Customer Card` (see second `[GIVEN]`). Have a look:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '客户需求的下一个阶段非常接近由 `[SCENARIO #0001]` 定义的上一部分。主要的区别是我们现在希望通过 UI 元素 `Customer Card`
    来访问客户。通过模拟最终用户，我们的场景描述了创建一个新的 `Customer Card`（见第二个 `[GIVEN]`）。请看一下：'
- en: '[PRE26]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Application code
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序代码
- en: 'Based on the last addition to the customer wish, the `Customer Card` needs
    to be extended with the `Lookup Value Code` field as per the following `.al` object:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 基于客户需求的最后一个新增部分，`Customer Card` 需要按照以下 `.al` 对象扩展 `Lookup Value Code` 字段：
- en: '[PRE27]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Test code
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试代码
- en: Consecutively, let's step through our *how-to-implement-test-code* recipe.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们一步步实现我们的 *如何实现测试代码* 配方。
- en: Create a test codeunit
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建测试代码单元
- en: Again, sharing the same `[FEATURE]` tag values as in our previous tests, we
    can place our new test case in the same test codeunit, that is, codeunit 81000
    `LookupValue UT Customer`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，使用与我们之前测试相同的 `[FEATURE]` 标签值，我们可以将新的测试用例放入相同的测试代码单元中，即代码单元 81000 `LookupValue
    UT Customer`。
- en: Embed the customer wish into a test function
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将客户需求嵌入到测试函数中
- en: 'Wrap the *green* into a new test function in codeunit 81000 as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *绿色* 部分封装成一个新的测试函数，并放入代码单元 81000 中，如下所示：
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Write your test story
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试用例
- en: 'A straightforward version of the new test story, in parallel to test example
    1, would be:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 新的测试用例版本与测试示例 1 平行，可以是：
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Adding variables and arguments, the code becomes:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 添加变量和参数后，代码变为：
- en: '[PRE30]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To access the UI in automated tests, we need to make use of the 5th pillar:
    the `TestPage`. As you can see in the specific case of our test function `AssignLookupValueToCustomerCard`,
    the test page object is based on the `Customer Card` page.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动化测试中访问 UI，我们需要使用第五个支柱：`TestPage`。如您在我们测试函数 `AssignLookupValueToCustomerCard`
    的特定情况下所看到的，测试页面对象是基于 `Customer Card` 页面。
- en: Construct the real code
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建实际代码
- en: 'We can make use of the already existing helper functions `CreateLookupValueCode`
    and `VerifyLookupValueOnCustomer`, but we also need to construct the following
    two new helper functions:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用已经存在的辅助函数 `CreateLookupValueCode` 和 `VerifyLookupValueOnCustomer`，但我们还需要构建以下两个新的辅助函数：
- en: '`CreateCustomerCard`'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CreateCustomerCard`'
- en: '`SetLookupValueOnCustomerCard`'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SetLookupValueOnCustomerCard`'
- en: CreateCustomerCard
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CreateCustomerCard
- en: 'To create a new customer card we just call the `OpenNew` method that any editable
    `TestPage` has to its availability:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的客户卡，我们只需调用任何可编辑 `TestPage` 都有的 `OpenNew` 方法：
- en: '[PRE31]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: SetLookupValueOnCustomerCard
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SetLookupValueOnCustomerCard
- en: 'Using the control method `SetValue` we set the value of the `Lookup Value Code`
    field:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用控件方法 `SetValue` 设置 `Lookup Value Code` 字段的值：
- en: '[PRE32]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As `SetValue` mimics the user setting a value, it will trigger the validation
    of the field. If a non-existing value is entered, it will validate the value against
    the existing records in the `Lookup Value` table as we tested in test example
    2\. To retrieve the value of the `No.` field, we use the control method `Value`. We
    do need to close the page to trigger the system so save the changes to the record
    to the database.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `SetValue` 模拟了用户设置值的操作，因此它会触发字段的验证。如果输入了一个不存在的值，它会根据我们在测试示例 2 中测试过的 `Lookup
    Value` 表中的现有记录验证该值。为了检索 `No.` 字段的值，我们使用控件方法 `Value`。我们确实需要关闭页面以触发系统，保存更改到数据库中的记录。
- en: Note that `Value` has a twofold purpose. It can be used to get or set the value
    of a field (control). The difference between setting the value using `Value` or
    `SetValue` is that `Value` always takes a string as an argument, while the argument
    of `SetValue` should be the same data type as the data type of the field (control).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Value` 有双重用途。它可以用于获取或设置字段（控件）的值。使用 `Value` 设置值与使用 `SetValue` 设置值的区别在于，`Value`
    总是将一个字符串作为参数，而 `SetValue` 的参数应与字段（控件）的数据类型相同。
- en: 'We''re almost ready to run the new test. There is, however, one major thing
    failing in the `SetLookupValueOnCustomerCard` helper function. It will operate
    fine, but it does not take account for, in my opinion, a design flaw: `SetLookupValueOnCustomerCard`
    will run successfully, even when the `Lookup Value Code` field is not editable.
    Both `SetValue` and `Value` do not check on this. As the whole purpose of our
    test is to check whether the user can set the `Lookup Value Code` field, we need
    to add a small verification to determine whether the field is editable. Because
    of this, the `SetLookupValueOnCustomerCard` function needs to be updated to the
    following using another function from the `Assert` codeunit `IsTrue`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经几乎准备好运行新的测试了。然而，`SetLookupValueOnCustomerCard` 辅助函数有一个主要的失败点。它会正常工作，但它没有考虑到我认为的一个设计缺陷：`SetLookupValueOnCustomerCard`
    即使在“查找值代码”字段不可编辑时也会成功运行。`SetValue` 和 `Value` 都没有对此进行检查。因为我们测试的目的是检查用户是否可以设置“查找值代码”字段，我们需要添加一个小的验证，来判断该字段是否可编辑。因此，`SetLookupValueOnCustomerCard`
    函数需要更新为以下内容，使用 `Assert` 代码单元中的另一个函数 `IsTrue`：
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that both `Value` and `SetValue` will error when we try to apply them to
    a non-visible field.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们尝试将 `Value` 和 `SetValue` 应用到一个不可见字段时，它们都会报错。
- en: Test execution
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试执行
- en: 'Let''s again redeploy the extension, add the new test function using the Get
    Test Methods feature, and run the tests.  See the next screenshot:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次重新部署扩展，使用“获取测试方法”功能添加新的测试函数，并运行测试。请查看下一个截图：
- en: '![](img/6ba2373f-620d-406f-b723-5628d195a530.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ba2373f-620d-406f-b723-5628d195a530.png)'
- en: 'Shoot, an error has occurred. Error? Let’s read it and try to understand:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕，发生了一个错误。错误？让我们读一下并尝试理解：
- en: '[PRE34]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'I must confess I always get a bit nervous of those techie CLR exception thrown messages,
    but I have learned to scan for the things that relate to what I know. Here are
    two things:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须承认，每次看到那些技术性 CLR 异常抛出的消息时，我总是有点紧张，但我已经学会了扫描与我所知相关的内容。这里有两点：
- en: '`NavNCLMissingUIHandlerException`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NavNCLMissingUIHandlerException`'
- en: '`Unhandled UI: ModalPage 1340`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unhandled UI: ModalPage 1340`'
- en: 'Apparently there is a `ModalPage` occurrence that is not handled by our test.
    More specifically it is page 1340 that''s called modally and not handled. Page
    1340? It''s the `Config Templates` page, the one that pops up when you are going
    to create a new customer, as shown in the screenshot:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，存在一个 `ModalPage` 实例没有被我们的测试处理。更具体地说，是页面 1340 被模态调用但没有处理。页面 1340？它是“配置模板”页面，当你要创建新客户时会弹出，如截图所示：
- en: '![](img/18c83597-8529-4680-b7ac-d9c7c73a09a8.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18c83597-8529-4680-b7ac-d9c7c73a09a8.png)'
- en: 'So, we need to construct a `ModalPageHandler` and link that to our third test:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们需要构建一个 `ModalPageHandler` 并将其链接到我们的第三个测试：
- en: '[PRE35]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Set the `HandlerFunctions` tag to the test function with reference to the `ModalPageHandler`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `HandlerFunctions` 标签设置为与 `ModalPageHandler` 相关的测试函数：
- en: '[PRE36]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now the test runs successfully.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试成功运行。
- en: Test the test
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试测试
- en: Let's *test the test* and verify that it is a good test.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们*测试测试*并验证它是否是一个好的测试。
- en: Adjust the test so the verification errs
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整测试，使验证出错
- en: A proven method can be achieved in exactly the same way as we have done for
    test example 1.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 一种经过验证的方法可以通过与我们在测试示例 1 中所做的完全相同的方式实现。
- en: 'Next to that note, we have added another verification to our code:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这条注释旁边，我们在代码中添加了另一个验证：
- en: '[PRE37]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Change `IsTrue` into `IsFalse`. You will see that the test fails as the `Lookup
    Value Code` field is editable. The `IsTrue` verification ensures that, when the
    `Lookup Value Code` field is turned to non-editable, the test will fail.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `IsTrue` 改为 `IsFalse`。你会看到测试失败，因为“查找值代码”字段是可编辑的。`IsTrue` 验证确保当“查找值代码”字段变为不可编辑时，测试会失败。
- en: Headless versus UI
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无头模式与 UI
- en: 'As mentioned before, headless testing is the preferred mode for automated tests
    as it is faster than UI testing. With test example 1 and 3, we did implement the
    same kind of test: check that a lookup value can be assigned to a customer. Test
    example 1 in headless mode, while test example 3 uses the UI. Running both tests
    indeed shows that UI tests are slower than headless tests. Have a look at the
    graph of execution duration (in seconds).'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，无头测试是自动化测试的首选模式，因为它比 UI 测试更快。在测试示例 1 和 3 中，我们实现了相同类型的测试：检查查找值是否可以分配给客户。测试示例
    1 使用无头模式，而测试示例 3 使用 UI。运行这两个测试确实表明 UI 测试比无头测试慢。看看执行时长（以秒为单位）的图表。
- en: '![](img/739c78b8-542d-4e35-ae8a-918cf7229288.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/739c78b8-542d-4e35-ae8a-918cf7229288.png)'
- en: 'The average execution duration for the UI tests is 1.35 seconds, while the
    headless average is almost 7 times faster: 0.20 seconds.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: UI测试的平均执行时间为1.35秒，而无头模式的平均执行时间几乎快了7倍：0.20秒。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we got to build our first automated tests. We utilized the
    ATDD test case pattern to design each test and used it as a base structure in
    our *4-steps recipe* to create a test codeunit, embed the customer wishes into
    a test, write a test story, and finally construct your real code.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建我们的第一个自动化测试。我们利用ATDD测试用例模式来设计每个测试，并将其作为我们*四步法食谱*的基础结构，用来创建测试单元，嵌入客户需求到测试中，编写测试故事，最后构建实际代码。
- en: In the next chapter, we will continue to use ATDD and the 4-steps recipe to
    create some more advanced tests.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将继续使用ATDD和四步法食谱来创建一些更高级的测试。
