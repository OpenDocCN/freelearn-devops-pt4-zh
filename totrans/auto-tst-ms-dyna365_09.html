<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">From Customer Wish to Test Automation - Next Level</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we built our first basic test automation in Dynamics 365 Business Central. We looked at three simple examples that show how to apply the <strong>Acceptance Test-Driven Development</strong> (<strong>ATDD</strong>) test case pattern and our <em>4-steps recipe</em> to get customer wishes converted into an application and test code. In this chapter, we will use the same methodology to create some more tests that:</p>
<ul>
<li>Use a shared fixture</li>
<li>Are parametrized</li>
<li>Hand over variables to UI handlers</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sales documents, customer template, and warehouse shipment</h1>
                </header>
            
            <article>
                
<p>With the three examples of <a href="56634efe-664c-421a-9582-b2a6ae69722a.xhtml" target="_blank">Chapter 5</a>, <em>From Customer Wish to Test Automation - The Basics</em>, we added the <kbd>Lookup Value Code</kbd> field to the <kbd>Customer</kbd> table. However, that's just a part of the customer wish as it describes clearly that…</p>
<div class="packt_quote">"… this field has to be carried over to the whole bunch of sales documents and, at the same time, it needs to be included in the warehouse shipping."</div>
<p>So, before we dive into the following test examples, a note needs to be made that, parallel to the implementation of the <kbd>Lookup Value Code</kbd> field on the <kbd>Customer</kbd> table, the same field has to be implemented on the <kbd>Sales Header</kbd> table, the <kbd>Customer Template</kbd> table, the <kbd>Warehouse Shipment Line</kbd> table, and all related pages. The ATDD test case descriptions are very much alike, and this will be the same case for the application and test code. Copy and paste—the great virtue of any Business Central developer. </p>
<p>Let’s have a look at how the ATDD test case descriptions do look like for customer template:</p>
<pre><strong>[SCENARIO #0012]</strong> Assign lookup value to customer template<br/><strong>[GIVEN]</strong> A lookup value<br/><strong>[GIVEN]</strong> A customer template<br/><strong>[WHEN]</strong> Set lookup value on customer template<br/><strong>[THEN]</strong> Customer template has lookup value code field populate</pre>
<pre><strong>[SCENARIO #0013]</strong> Assign non-existing lookup value to customer template<br/><strong>[GIVEN]</strong> A non-existing lookup value<br/><strong>[GIVEN]</strong> A customer template record variable<br/><strong>[WHEN] </strong>Set non-existing lookup value to customer template<br/><strong>[THEN] </strong>Non existing lookup value error was thrown</pre>
<pre><strong>[SCENARIO #0014]</strong> Assign lookup value on customer template card<br/><strong>[GIVEN]</strong> A lookup value<br/><strong>[GIVEN]</strong> A customer template card<br/><strong>[WHEN] </strong>Set lookup value on customer template card<br/><strong>[THEN] </strong>Customer template has lookup value code field populated</pre>
<p>Do you see the resemblance with scenarios <kbd>#0001</kbd>, <kbd>#0002</kbd>, and <kbd>#0003</kbd>?</p>
<div class="packt_infobox">On GitHub, you will find both the full list of ATDD scenarios and the complete test code.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test example 4 – how to set up a shared fixture</h1>
                </header>
            
            <article>
                
<p>Although it isn't explicitly mentioned, we created a <em>fresh fixture</em> for each of the three previous tests as defined per the <kbd>[GIVEN]</kbd> tags, being a lookup value record and a customer record. For speed purposes, however, it does make sense to consider whether you need a fresh fixture for each test or a shared fixture for a group of tests. In the case of scenarios <kbd>#0001</kbd> and <kbd>#0003</kbd>, we could perfectly do with the same <kbd>LookupValueCode</kbd>, no need to create a new lookup value record for each of these tests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Customer wish</h1>
                </header>
            
            <article>
                
<p>Let's use the part of the customer wish that prescribes to have a <kbd>Lookup Value Code</kbd> field on all sales documents to illustrate how a shared fixture can be achieved. This would come down to the following eight scenarios, leaving out the <kbd>GIVEN</kbd>-<kbd>WHEN</kbd>-<kbd>THEN</kbd> part to save space:</p>
<pre><strong>[SCENARIO #0004]</strong> Assign lookup value to sales header<br/><strong>[SCENARIO #0005]</strong> Assign non-existing lookup value on sales header<br/><strong>[SCENARIO #0006]</strong> Assign lookup value on sales quote document page<br/><strong>[SCENARIO #0007]</strong> Assign lookup value on sales order document<br/>                 page<br/><strong>[SCENARIO #0008]</strong> Assign lookup value on sales invoice document<br/>                 page<br/><strong>[SCENARIO #0009]</strong> Assign lookup value on sales credit memo document<br/>                 page<br/><strong>[SCENARIO #0010]</strong> Assign lookup value on sales return order<br/>                 document page<br/><strong>[SCENARIO #0011]</strong> Assign lookup value on blanket sales order<br/>                 document page</pre>
<p>With <a href="56634efe-664c-421a-9582-b2a6ae69722a.xhtml" target="_blank">Chapter 5</a>,<em> From Customer Wish to Test Automation – The Basics</em>, fresh in your mind, you might notice that scenario <kbd>#0001</kbd> and <kbd>#0004</kbd> are quite similar. This is the same for scenario <kbd>#0003</kbd> and <kbd>#0006</kbd> through <kbd>#0011</kbd>. As such, all of these scenarios share the following same <kbd>[GIVEN]</kbd> part:</p>
<pre> <strong>[GIVEN]</strong> A lookup value</pre>
<p>Straightforward implementation of this requirement would lead to creating a lookup value record<span> </span><span>seven times</span><span>.</span> So<span>, we'll be laz</span>y and apply the shared fixture, or lazy setup, <span>pattern.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application code</h1>
                </header>
            
            <article>
                
<p>This part of the customer wish leads to the implementation of the <kbd>Lookup Value Code</kbd> field on the sales header, and a page control for this field on each of the sales document pages.</p>
<p>The next code snippet implements the extension of the <kbd>Sales Header</kbd> table, that is, scenarios <kbd>#0004</kbd> and <kbd>#0005</kbd>:</p>
<pre>tableextension 50001 "SalesHeaderTableExt" extends "Sales Header"<br/>{<br/>    fields<br/>    {<br/>        field(50000; "Lookup Value Code"; Code[10])<br/>        {<br/>            Caption = 'Lookup Value Code';<br/>            DataClassification = ToBeClassified;<br/>            TableRelation = "LookupValue";<br/>        }<br/>    }<br/>}</pre>
<p>Furthermore, the following code block will implement the extension of the <kbd>Sales Order</kbd> page (see scenario <kbd>#0007</kbd>):</p>
<pre>pageextension 50002 "SalesOrderPageExt" extends "Sales Order" <br/>{<br/>    layout<br/>    {<br/>        addlast(General)<br/>        {<br/>            field("Lookup Value Code"; "Lookup Value Code")<br/>            {<br/>                 ToolTip = 'Specifies the lookup value the<br/>                                 transaction is done for.';<br/>                 ApplicationArea = All;<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>Scenarios <kbd>#0006</kbd>, <kbd>#0008</kbd>, <kbd>#0009</kbd>, <kbd>#0010</kbd>, and <kbd>#0011</kbd> would lead in a similar manner to the extension of the <kbd>Sales Quote</kbd>, <kbd>Sales Invoice</kbd>, <kbd>Sales Credit Memo</kbd>, <kbd>Sales Return Order</kbd>, and <kbd>Blanket Sales Order</kbd> document pages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test Code</h1>
                </header>
            
            <article>
                
<p>With some big steps, we'll create our test code for scenarios <kbd>#0004</kbd>, <kbd>#0006</kbd>, and <kbd>#0007</kbd>, leaving scenarios <kbd>#0005</kbd>, <kbd>#0008</kbd>, <kbd>#0009</kbd>, <kbd>#0010</kbd>, and <kbd>#0011</kbd> for you to review on GitHub.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Create a test codeunit</h1>
                </header>
            
            <article>
                
<pre>codeunit 81001 "LookupValue UT Sales Document"<br/>{<br/>    Subtype = Test;<br/>    //[FEATURE] LookupValue UT Sales Document<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Embed the customer wish into a test function</h1>
                </header>
            
            <article>
                
<p>Embedding the three scenarios, <kbd>#0004</kbd>, <kbd>#0006</kbd>, and <kbd>#0007</kbd>, into test functions makes our new test codeunit look as follows:</p>
<pre>codeunit 81001 "LookupValue UT Sales Document"<br/>{<br/>    Subtype = Test;<br/><br/>    //[FEATURE] LookupValue UT Sales Document<br/><br/>    [Test]<br/>    procedure AssignLookupValueToSalesHeader()<br/>    begin<br/>        //[SCENARIO #0004] Assign lookup value to sales header<br/>        //                 page<br/>        //[GIVEN] A lookup value<br/>        //[GIVEN] A sales header<br/>        //[WHEN] Set lookup value on sales header<br/>        //[THEN] Sales header has lookup value code field<br/>        //       populated<br/>    end;<br/><br/>    [Test]<br/>    procedure AssignLookupValueToSalesQuoteDocument()<br/>    begin<br/>        //[SCENARIO #0006] Assign lookup value on sales quote<br/>        //                 document page<br/>        //[GIVEN] A lookup value<br/>        //[GIVEN] A sales quote document page<br/>        //[WHEN] Set lookup value on sales quote document<br/>        //[THEN] Sales quote has lookup value code field populated<br/>    end;<br/><br/>    [Test]<br/>    procedure AssignLookupValueToSalesOrderDocument()<br/>    begin<br/>        //[SCENARIO #0007] Assign lookup value on sales order<br/>        //                 document page<br/>        //[GIVEN] A lookup value<br/>        //[GIVEN] A sales order document page<br/>        //[WHEN] Set lookup value on sales order document<br/>        //[THEN] Sales order has lookup value code field populated<br/>    end;<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Write your test story</h1>
                </header>
            
            <article>
                
<p>Now that the structure is clear, we can pick out scenario <kbd>#0007</kbd> to create more detail:</p>
<pre>codeunit 81001 "LookupValue UT Sales Document"<br/>{<br/>    Subtype = Test;<br/><br/>    //[FEATURE] LookupValue UT Sales Document<br/><br/>    [Test]<br/>    procedure AssignLookupValueToSalesOrderDocument()<br/>    begin<br/>        //[SCENARIO #0007] Assign lookup value on sales order<br/>        //                 document page<br/>        //[GIVEN] A lookup value<br/>        CreateLookupValueCode();<br/>        //[GIVEN] A sales order document page<br/>        CreateSalesOrderDocument();<br/>        //[WHEN] Set lookup value on sales order document<br/>        SetLookupValueOnSalesOrderDocument();<br/>        //[THEN] Sales order has lookup value code field populated<br/>        VerifyLookupValueOnSalesHeader();<br/>    end;<br/>}</pre>
<p>So, how do we go about setting up the shared fixture? We do this by using the <kbd>Initialize</kbd> function, as introduced in <a href="db955f66-11f4-4d9a-90c7-5af04058ebbe.xhtml" target="_blank">Chapter 4</a>, <em>Test Design</em>. This would change <kbd>AssignLookupValueToSalesOrderDocument</kbd> into the following:</p>
<pre>[Test]<br/>procedure AssignLookupValueToSalesOrderDocument()<br/>begin<br/>    //[SCENARIO #0007] Assign lookup value on sales order<br/>    //                 document page<br/>    //[GIVEN] A lookup value<br/>    Initialize();<br/>    //[GIVEN] A sales order document page<br/>    CreateSalesOrderDocument();<br/>    //[WHEN] Set lookup value on sales order document<br/>    SetLookupValueOnSalesOrderDocument();<br/>    //[THEN] Sales order has lookup value code field populated<br/>    VerifyLookupValueOnSalesHeader();<br/>end;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Construct the real code</h1>
                </header>
            
            <article>
                
<p>Let's build a simple <kbd>Initialize</kbd>:</p>
<pre>local procedure Initialize()<br/>begin<br/>    if isInitialized then<br/>        exit;<br/><br/>    LookupValueCode := CreateLookupValueCode();<br/><br/>    isInitialized := true;<br/>    Commit();<br/>end;</pre>
<p>Here, both <kbd>isInitialized</kbd> and <kbd>LookupValueCode</kbd> are global variables of respectively <kbd>Boolean</kbd> and <kbd>Code[10]</kbd> data types. Once <kbd>Initialize</kbd> has been called, <kbd>isInitialized</kbd> will be <kbd>true</kbd> and the <kbd>if</kbd>-statement will evaluate to <kbd>true</kbd> any time <kbd>Initialize</kbd> is being called, always leading to a straight exit from <kbd>Initialize</kbd>.</p>
<p>With respect to scenario <kbd>#0007</kbd>, our test codeunit would become as follows, including the various variables, parameters, and other helper functions:</p>
<pre>codeunit 81001 "LookupValue UT Sales Document"<br/>{<br/>    Subtype = Test;<br/><br/>    var<br/>        Assert: Codeunit Assert;<br/>        LibrarySales: Codeunit "Library - Sales";<br/>        isInitialized: Boolean;<br/>        LookupValueCode: Code[10];<br/> <br/>    //[FEATURE] LookupValue UT Sales Document<br/> <br/>    procedure AssignLookupValueToSalesOrderDocument()<br/>    var<br/>        SalesHeader: Record "Sales Header";<br/>        SalesDocument: TestPage "Sales Order";<br/>        DocumentNo: Code[20];<br/>    begin<br/>        //[SCENARIO #0007] Assign lookup value on sales order<br/>        //                 document page<br/>        //[GIVEN] A lookup value<br/>        Initialize();<br/>        //[GIVEN] A sales order document page<br/>        CreateSalesOrderDocument(SalesDocument);<br/>        //[WHEN] Set lookup value on sales order document<br/>        DocumentNo := SetLookupValueOnSalesOrderDocument(<br/>                        SalesDocument, LookupValueCode);<br/>        //[THEN] Sales order has lookup value code field populated<br/>        VerifyLookupValueOnSalesHeader(<br/>                SalesHeader."Document Type"::Order,<br/>                DocumentNo,<br/>                LookupValueCode);<br/>    end;<br/><br/>    local procedure Initialize()<br/>    begin<br/>        if isInitialized then<br/>            exit;<br/><br/>        LookupValueCode := CreateLookupValueCode();<br/><br/>        isInitialized := true;<br/>        Commit();<br/>    end;<br/><br/>    local procedure CreateLookupValueCode(): Code[10]<br/>    begin<br/>        //for implementation see test example 1; this smells like<br/>        //duplication ;-)<br/>    end;<br/><br/>    local procedure CreateSalesOrderDocument(<br/>                        var SalesDocument: TestPage "Sales Order")<br/>    begin<br/>        SalesDocument.OpenNew();<br/>    end;<br/> <br/>    local procedure SetLookupValueOnSalesOrderDocument(<br/>                        var SalesDocument: TestPage "Sales Order";<br/>                        LookupValueCode: Code[10])<br/>                            DocumentNo: Code[20]<br/>    begin<br/>        with SalesDocument do begin<br/>            //for rest of implementation see test example 1 <br/>        end;<br/>    end;<br/> <br/>    local procedure VerifyLookupValueOnSalesHeader(<br/>                        DocumentType: Option Quote,Order,Invoice,<br/>                                    "Credit Memo","Blanket Order",<br/>                                    "Return Order";<br/>                        DocumentNo: Code[20];<br/>                        LookupValueCode: Code[10])<br/>    var<br/>        SalesHeader: Record "Sales Header";<br/>        FieldOnTableTxt: Label '%1 on %2';<br/>    begin<br/>        with SalesHeader do begin<br/>            Get(DocumentType, DocumentNo);<br/>            //for rest of implementation see test example 1 <br/>        end;<br/>    end;<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test execution</h1>
                </header>
            
            <article>
                
<p>Running a full-fledged codeunit 81001 yields a bunch of successes:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-763 image-border" src="assets/1d92a997-0fcd-4fad-a2b6-9dd9f9bc234f.png" style="width:105.42em;height:51.92em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test the test</h1>
                </header>
            
            <article>
                
<p>By now, I guess you know what to do here: adjust the test so the verification errs. Give it a try, or use the completed code on GitHub as your cheat sheet.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test example 5 – how to parametrize tests</h1>
                </header>
            
            <article>
                
<p>Writing test automation, including design and coding, is a considerable effort, which has a lot of details to pay attention to. However, once you've got the hang of it and have it in place, you will enjoy it and continue to profit from it. This is the case unless you're sloppy on the details at both the design and coding levels, and thus have to keep fixing your tests. Nevertheless, you will enjoy writing even more if you make your tests generic by parameterizing them. By the nature of the testability framework, you will not be able to parametrize a test function, but you can achieve this by encapsulating your generic test code in a helper function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Customer wish</h1>
                </header>
            
            <article>
                
<p>Let's illustrate this with another part of our customer's wish: archiving a sales document. As Business Central enables the user to archive a sales quote, a sales order, and a sales return order, we have to include this in our extension. This is expressed in the following three scenarios:</p>
<pre><strong>[FEATURE]</strong> LookupValue Sales Archive<br/><br/><strong>[SCENARIO #0018]</strong> Archive sales order with lookup value<br/><strong>[GIVEN]</strong> A sales order with a lookup value<br/><strong>[WHEN]</strong> Sales order is archived<br/><strong>[THEN]</strong> Archived sales order has lookup value from sales order<br/><br/><strong>[SCENARIO #0019]</strong> Archive sales quote with lookup value<br/><strong>[GIVEN]</strong> A sales quote with a lookup value<br/><strong>[WHEN]</strong> Sales quote is archived<br/><strong>[THEN]</strong> Archived sales quote has lookup value from sales quote<br/><br/><strong>[SCENARIO #0020]</strong> Archive sales return order with lookup value<br/><strong>[GIVEN]</strong> A sales return order with a lookup value<br/><strong>[WHEN]</strong> Sales return order is archived<br/><strong>[THEN]</strong> Archived sales return order has lookup value from sales return order</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application code</h1>
                </header>
            
            <article>
                
<p>The data model extension is implemented by the following <kbd>.al</kbd> object:</p>
<pre>tableextension 50009 "SalesHeaderArchiveTableExt"<br/>                            extends "Sales Header Archive"<br/>{<br/>    fields<br/>    {<br/>        field(50000; "Lookup Value Code"; Code[10])<br/>        {<br/>            Caption = 'Lookup Value Code';<br/>            DataClassification = ToBeClassified;<br/>            TableRelation = "LookupValue";<br/>        }<br/>    }<br/>}</pre>
<p>And the UI is extended subsequently as follows for scenario <kbd>#0019</kbd>. It will look very much alike for scenarios <kbd>#0018</kbd> and <kbd>#0020</kbd>:</p>
<pre>pageextension 50042 "SalesQuoteArchivePageExt"<br/>                            extends "Sales Quote Archive"<br/>{<br/>    layout<br/>    {<br/>        addlast(General)<br/>        {<br/>            field("Lookup Value Code"; "Lookup Value Code")<br/>            {<br/>                ToolTip = 'Specifies the lookup value the<br/>                                transaction is done for.';<br/>                ApplicationArea = All;<br/>            }<br/>        }<br/>    }<br/>}<br/><br/>pageextension 50045 "SalesQuoteArchivesPageExt"<br/>                            extends "Sales Quote Archives"<br/>{<br/>    layout<br/>    {<br/>        addfirst(Control1)<br/>        {<br/>            field("Lookup Value Code"; "Lookup Value Code")<br/>            {<br/>                ToolTip = 'Specifies the lookup value the<br/>                                transaction is done for.';<br/>                ApplicationArea = All;<br/>            }<br/>        }<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test code</h1>
                </header>
            
            <article>
                
<p>Now that the app code has set lets have a look at the test code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Create, embed, and write</h1>
                </header>
            
            <article>
                
<p>With one big step of "creating, embedding and writing" this is how the test stories <kbd>#0018</kbd>, <kbd>#0019</kbd>, and <kbd>#0020</kbd> could look like, when placed in a new test codeunit:</p>
<pre>codeunit 81004 "LookupValue Sales Archive"<br/>{<br/>    Subtype = Test;<br/><br/>    //[FEATURE] LookupValue Sales Archive<br/><br/>    [Test]<br/>    procedure ArchiveSalesOrderWithLookupValue();<br/>    begin<br/>        //[SCENARIO #0018] Archive sales order with lookup value<br/>        //[GIVEN] A sales order with a lookup value<br/>        CreateSalesOrderWithLookupValue();<br/>        //[WHEN] Sales order is archived<br/>        ArchiveSalesOrderDocument();<br/>        //[THEN] Archived sales order has lookup value from<br/>        //       sales order<br/>        VerifyLookupValueOnSalesOrderArchive();<br/>    end;<br/><br/>    [Test]<br/>    procedure ArchiveSalesQuoteWithLookupValue();<br/>    begin<br/>        //[SCENARIO #0019] Archive sales quote with lookup value<br/>        //[GIVEN] A sales quote with a lookup value<br/>        CreateSalesQuoteWithLookupValue();<br/>        //[WHEN] Sales quote is archived<br/>        ArchiveQuoteDocument();<br/>        //[THEN] Archived sales quote has lookup value from<br/>        //       sales quote<br/>        VerifyLookupValueOnSalesQuoteArchive();<br/>    end;<br/><br/>    [Test]<br/>    procedure ArchiveSalesReturnOrderWithLookupValue();<br/>    begin<br/>        //[SCENARIO #0020] Archive sales return order with lookup<br/>        //                 value<br/>        //[GIVEN] A sales return order with a lookup value<br/>        CreateSalesReturnOrderWithLookupValue();<br/>        //[WHEN] Sales return order is archived<br/>        ArchiveSalesReturnOrderDocument();<br/>        //[THEN] Archived sales return order has lookup value from<br/>        //       sales return order<br/>        VerifyLookupValueOnSalesReturnOrderArchive();<br/>    end;<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Construct the real code</h1>
                </header>
            
            <article>
                
<p>When all three scenarios are testing the process of archiving a sales document, they boil down to a generic story with only one variable being the document type—quote, order, or return order. Consequently, we can thicken this into one test story:</p>
<pre>[Test]<br/>procedure ArchiveSalesDocumentWithLookupValue();<br/>begin<br/>    //[SCENARIO #....] Archive sales document with lookup<br/>    //                 value<br/>    //[GIVEN] A sales document with a lookup value<br/>    CreateSalesDocumentWithLookupValue();<br/>    //[WHEN] Sales document is archived<br/>    ArchiveSalesDocumentDocument();<br/>    //[THEN] Archived sales document has lookup value from<br/>    //       sales document<br/>    VerifyLookupValueOnSalesDocumentArchive();<br/>end;</pre>
<p>As said, we cannot parametrize a <kbd>test</kbd> function, but we can cast this into a local method to be called from the three tests:</p>
<pre>local procedure ArchiveSalesDocumentWithLookupValue(<br/>                    DocumentType: Option<br/>                            Quote,Order,Invoice,<br/>                            "Credit Memo","Blanket Order",<br/>                            "Return Order"): Code[20]<br/>var<br/>    SalesHeader: record "Sales Header";<br/>begin<br/>    //[GIVEN] A sales document with a lookup value<br/>    CreateSalesDocumentWithLookupValue(SalesHeader, DocumentType);<br/>    //[WHEN] Sales document is archived<br/>    ArchiveSalesDocument(SalesHeader);<br/>    //[THEN] Archived sales document has lookup value from sales<br/>    //       document<br/>    VerifyLookupValueOnSalesDocumentArchive(<br/>        DocumentType,<br/>        SalesHeader."No.",<br/>        SalesHeader."Lookup Value Code",<br/>        1);  // Used 1 for No. of Archived Versions<br/>    exit(SalesHeader."No.")<br/>end;</pre>
<p>The three tests will then become:</p>
<pre>[Test]<br/>procedure ArchiveSalesOrderWithLookupValue();<br/>var<br/>    SalesHeader: record "Sales Header";<br/>begin<br/>    //[SCENARIO #0018] Archive sales order with lookup value<br/>    ArchiveSalesDocumentWithLookupValue(<br/>        SalesHeader."Document Type"::Order)<br/>end;<br/><br/>[Test]<br/>procedure ArchiveSalesQuoteWithLookupValue();<br/>var<br/>    SalesHeader: record "Sales Header";<br/>begin<br/>    //[SCENARIO #0019] Archive sales quote with lookup value<br/>    ArchiveSalesDocumentWithLookupValue(<br/>        SalesHeader."Document Type"::Quote)<br/>end;<br/><br/>[Test]<br/>procedure ArchiveSalesReturnOrderWithLookupValue();<br/>var<br/>    SalesHeader: record "Sales Header";<br/>begin<br/>    //[SCENARIO #0020] Archive sales return order with lookup value<br/>    ArchiveSalesDocumentWithLookupValue(<br/>        SalesHeader."Document Type"::"Return Order")<br/>end;</pre>
<p>Copy and paste: three birds in one stroke.</p>
<div class="packt_infobox">Go to GitHub to have a look at the implementation of the other helper functions and an additional scenario, <kbd>#00021</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test execution</h1>
                </header>
            
            <article>
                
<p>Show me the green successes:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-764 image-border" src="assets/dbb328b0-9275-4e1a-92e8-56e3e90b98c5.png" style="width:97.00em;height:42.50em;"/></p>
<p>Ouch ...... RED?</p>
<p>Apparently, as the test errors indicate in Test Tool, we need to handle a <kbd>Confirm</kbd>. Let's go into the application and try to archive a sales order.</p>
<p>To accomplish this take the following steps:</p>
<ol>
<li>Use <em>Alt</em> + <em>Q</em>, the <span class="packt_screen">Tell Me What You Want</span> feature</li>
<li>Type <kbd>Sales Orders</kbd> and select the <span class="packt_screen">Sales Orders</span> hyperlink to open the <kbd>Sales Orders</kbd> page</li>
<li>Open the document page of the first sales order</li>
<li>Select <span class="packt_screen">Actions</span> | <span class="packt_screen">Functions</span> | <span class="packt_screen">Archive Document</span></li>
</ol>
<p>Indeed, a dialog appears here asking the user to confirm (or not):</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-765 image-border" src="assets/9b476d1b-f990-4a2b-bf29-fd6a38d16317.png" style="width:96.92em;height:47.08em;"/></p>
<p>See what happens when we click <span class="packt_screen">Yes</span> in the confirm dialog: a message appears informing the user that the document has been archived, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-766 image-border" src="assets/043f228f-2772-456d-86c4-ca7916b6aaef.png" style="width:97.00em;height:46.83em;"/></p>
<p>Once the user clicks <span class="packt_screen">OK</span> in the message dialog, the archiving of the document is complete. With respect to our test automation, we need to create two handler functions—one handler function to handle the confirm dialog, and the other to handle the message, as follows:</p>
<pre>[ConfirmHandler]<br/>procedure ConfirmHandlerYes(Question: Text[1024]; var Reply: Boolean);<br/>begin<br/>    Reply := true;<br/>end;<br/><br/>[MessageHandler]<br/>procedure MessageHandler(Message: Text[1024]);<br/>begin<br/>end;</pre>
<div class="packt_infobox">Both the handlers are minimally implemented; they will just handle the dialogs and not check anything. I will elaborate on that some more in the next example.</div>
<p>Link them to our tests using the <kbd>HandlerFunctions</kbd> tag:</p>
<pre>[HandlerFunctions('ConfirmHandler,MessageHandler')]</pre>
<p>The test codeunit for scenario <kbd>#0018</kbd> will then become:</p>
<pre>[Test]<br/>[HandlerFunctions('ConfirmHandler,MessageHandler')]<br/>procedure ArchiveSalesOrderWithLookupValue();<br/>var<br/>    SalesHeader: record "Sales Header";<br/>begin<br/>    //[SCENARIO #0018] Archive sales order with lookup value<br/>    ArchiveSalesDocumentWithLookupValue(<br/>        SalesHeader."Document Type"::Order)<br/>end;</pre>
<p>Now, run it again! Do show us the green, please:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-767 image-border" src="assets/3c67e45c-c8fc-47ec-ad04-91fe40430c82.png" style="width:97.08em;height:41.83em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test the test</h1>
                </header>
            
            <article>
                
<p>You know what to do. Yes, you do, right?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A missing scenario?</h1>
                </header>
            
            <article>
                
<p>One of the great reviewers of this book, Steven Renders, pointed out to me that there is a hole in the scenarios for the customer wish that, when archiving a sales document, the lookup value should be carried over to the archived sales document. Before I step into the specifics, this a perfect illustration of what I already mentioned in <a href="db955f66-11f4-4d9a-90c7-5af04058ebbe.xhtml" target="_blank">Chapter 4</a>, <em>Test Design</em>: "a test design is an object to help the team discuss their test effort, to reveal the holes in their thoughts…"</p>
<p>So, what is this hole? If you have a confirmation, asking the user for a <span class="packt_screen">Yes</span> or <span class="packt_screen">No,</span> there are at least two scenarios that need to be tested, and my scenarios only handles the <span class="packt_screen">Yes</span>. So, what about the <span class="packt_screen">No</span>? This indeed is a user scenario as such, but I do not consider it a scenario to be tested within the context of our customer wish. It is a scenario that relates to the bigger feature of archiving sales documents. As such, this scenario was not added to our collection on the assumption that this is handled by standard tests.</p>
<p>Nevertheless, in any future project be triggered when confirm statements are used, as in principle, these lead to at least two scenarios.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test example 6 – how to hand over data to UI handlers</h1>
                </header>
            
            <article>
                
<p>Just now, with the previous test example where we hit upon the need for two dialog handlers, it makes sense to discuss how to hand over data to a UI handler, as we cannot directly control this. However, the platform does, and the argument list is a fixed one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Customer wish</h1>
                </header>
            
            <article>
                
<p>In this context, we pick up another part of our customer wish—when creating a new customer from the UI, by clicking the standard <span class="packt_screen">New</span> action on the ribbon, the user has to select a template to base the new customer on (or simply bypass it by selecting <span class="packt_screen">Cancel</span>), as shown in this screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-768 image-border" src="assets/50b3e26d-4519-4cbb-b764-830f685f9c71.png" style="width:97.08em;height:47.17em;"/></p>
<p>We've had to tackle the appearance of the ModalPage already in test example 3 of the previous chapter. This part of the customer wish tells us that the configuration template that's behind the templates the user can choose should be set up, so that it will autopopulate the <kbd>Lookup Value Code</kbd> field on the newly created customer from the selected template.</p>
<p>This is what scenario <kbd>#0028</kbd> entails:</p>
<pre><strong>[FEATURE]</strong> LookupValue Inheritance<strong><br/>[SCENARIO #0028]</strong> Create customer from configuration template with<br/>                  lookup value<br/><strong>[GIVEN]</strong> A configuration template (customer) with lookup value<br/><strong>[WHEN]</strong> Create customer from configuration template<br/><strong>[THEN]</strong> Lookup value on customer is populated with lookup value of<br/>        configuration template</pre>
<p>We can accomplish this by setting up a configuration template. There is no need for any application code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test code</h1>
                </header>
            
            <article>
                
<p>Let's wrap scenario <kbd>#0028</kbd> in a new test codeunit.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Create, embed, and write</h1>
                </header>
            
            <article>
                
<p>This leads to the following code construction:</p>
<pre>codeunit 81006 "LookupValue Inheritance"<br/>{<br/>    Subtype = Test;<br/><br/>    [Test]<br/>    procedure<br/>        InheritLookupValueFromConfigurationTemplateToCustomer();<br/>    begin<br/>        //[SCENARIO #0028] Create customer from configuration<br/>        //                 template with lookup value<br/>        Initialize();<br/>        //[GIVEN] A configuration template (customer) with lookup<br/>        //        value<br/>        CreateCustomerConfigurationTemplateWithLookupValue();<br/>        //[WHEN] Create customer from configuration template<br/>        CreateCustomerFromConfigurationTemplate();<br/>        //[THEN] Lookup value on customer is populated with lookup<br/>        //       value of configuration template<br/>        VerifyLookupValueOnCustomer();<br/>    end;<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Construct the real code</h1>
                </header>
            
            <article>
                
<p>Including all technical details, like variables and arguments, this codeunit would become:</p>
<pre>codeunit 81006 "LookupValue Inheritance"<br/>{<br/>    Subtype = Test;<br/><br/>    [Test]<br/>    [HandlerFunctions('HandleConfigTemplates')]<br/>    procedure<br/>        InheritLookupValueFromConfigurationTemplateToCustomer();<br/>    var<br/>        CustomerNo: Code[20];<br/>        ConfigTemplateHeaderCode: Code[10];<br/>        LookupValueCode: Code[10];<br/>    begin<br/>        //[SCENARIO #0028] Create customer from configuration<br/>        //                 template with lookup value<br/>        Initialize();<br/>        //[GIVEN] A configuration template (customer) with lookup<br/>        //        value<br/>        ConfigTemplateHeaderCode :=<br/>               CreateCustomerConfigurationTemplateWithLookupValue(<br/>                   LookupValueCode);<br/>        //[WHEN] Create customer from configuration template<br/>        CustomerNo :=<br/>                CreateCustomerFromConfigurationTemplate(<br/>                        ConfigTemplateHeaderCode);<br/>        //[THEN] Lookup value on customer is populated with lookup<br/>        //       value of configuration template<br/>        VerifyLookupValueOnCustomer(CustomerNo, LookupValueCode);<br/>    end;<br/>}</pre>
<p>We need to create the following four helper functions and one UI handler:</p>
<ul>
<li><kbd>Initialize</kbd></li>
<li><kbd>CreateCustomerConfigurationTemplateWithLookupValue</kbd></li>
<li><kbd>CreateCustomerFromConfigurationTemplate</kbd></li>
<li><kbd>VerifyLookupValueOnCustomer</kbd></li>
<li><kbd>HandleConfigTemplates</kbd></li>
</ul>
<p>Two of the five procedures needed can be <em>inherited</em> from earlier test examples:</p>
<ul>
<li><kbd>Initialize</kbd> takes care of the Lookup Value and can be copied from test example 4</li>
<li><kbd>VerifyLookupValueOnCustomer</kbd> can be taken from test example 1</li>
</ul>
<p>The other three functions, <kbd>CreateCustomerConfigurationTemplateWithLookupValue</kbd>, <kbd>CreateCustomerFromConfigurationTemplate</kbd>, and <kbd>HandleConfigTemplates</kbd>, will be as follows. The function names describe exactly what the function is doing. I will leave it you to read and grasp the meaning of the first two. In the context of this test example we will elaborate more on <kbd>HandleConfigTemplates</kbd>:</p>
<pre>local procedure CreateCustomerConfigurationTemplateWithLookupValue(<br/>        LookupValueCode: Code[10]): Code[10]<br/>// Adopted from Codeunit 132213 Library - Small Business<br/>var<br/>    ConfigTemplateHeader: record "Config. Template Header";<br/>    Customer: Record Customer;<br/>begin<br/>    LibraryRapidStart.CreateConfigTemplateHeader(<br/>       ConfigTemplateHeader);<br/>    ConfigTemplateHeader.Validate("Table ID", Database::Customer);<br/>    ConfigTemplateHeader.Modify(true);<br/><br/>    LibrarySmallBusiness.CreateCustomerTemplateLine(<br/>        ConfigTemplateHeader,<br/>        Customer.FieldNo("Lookup Value Code"),<br/>        Customer.FieldName("Lookup Value Code"),<br/>        LookupValueCode);<br/><br/>    exit(ConfigTemplateHeader.Code);<br/>end;<br/><br/>local procedure CreateCustomerFromConfigurationTemplate(<br/>        ConfigurationTemplateCode: Code[10]) CustomerNo: Code[20]<br/>var<br/>    CustomerCard: TestPage "Customer Card";<br/>begin<br/>    CustomerCard.OpenNew();<br/>    CustomerNo := CustomerCard."No.".Value();<br/>    CustomerCard.Close();<br/>end;<br/><br/>[ModalPageHandler]<br/>procedure HandleConfigTemplates(<br/>        var ConfigTemplates: TestPage "Config Templates")<br/>begin<br/>    ConfigTemplates.GoToKey(<br/>        &lt;provide the PK of the Config Template&gt;);<br/>    ConfigTemplates.OK.Invoke();<br/>end;</pre>
<p>As soon as a new customer card is created in <kbd>CreateCustomerFromConfigurationTemplate</kbd>, the <kbd>Config Templates</kbd> page needs to be handled by the ModalPageHandler <kbd>HandleConfigTemplates</kbd>. Out of the list of configuration templates, it should select the configuration template created by <kbd>CreateCustomerConfigurationTemplateWithLookupValue</kbd>. With the <kbd>GoToKey</kbd> method of a TestPage, we can achieve this, but it needs to provide the PK value of the template, as marked by the triangular brackets in the preceding code.</p>
<p>A straightforward solution would be to create a global variable called <kbd>ConfigTemplateCode</kbd>, which would be populated in the <kbd>[GIVEN]</kbd> part of our test, as follows:</p>
<pre>ConfigTemplateCode :=<br/>       CreateCustomerConfigurationTemplateWithLookupValue(<br/>           LookupValueCode);</pre>
<p>This would <span class="tlid-translation translation"><span class="">successively</span></span> be picked up by our <kbd>ModalPageHandler</kbd>. This would undoubtedly be a perfectly valid solution. But picture yourself having to hand over multiple different values of different data types in one test codeunit, stacking global variable upon global variable. To overcome this, Microsoft has provided us with a neat feature implemented in the codeunit, <kbd>Library - Variable Storage</kbd>. It consists of a queue of 25 variant elements. Using <kbd>Enqueue</kbd> and <kbd>Dequeue</kbd>, you can store and retrieve your variable in a first in, first out manner.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enqueue</h1>
                </header>
            
            <article>
                
<p>Call <kbd>Enqueue</kbd> in your test code before the handler is triggered, as follows:</p>
<pre>//[GIVEN] A configuration template (customer) with lookup<br/>//        value<br/>ConfigTemplateCode :=<br/>       CreateCustomerConfigurationTemplateWithLookupValue(<br/>           LookupValueCode);<br/>//[WHEN] Create customer from configuration template<br/>LibraryVariableStorage.Enqueue(ConfigTemplateCode);<br/>CustomerNo :=<br/>       CreateCustomerFromConfigurationTemplate(<br/>           ConfigTemplateCode);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dequeue</h1>
                </header>
            
            <article>
                
<p>In the handler, call <kbd>Dequeue</kbd> to retrieve the variable, as follows:</p>
<pre>[ModalPageHandler]<br/>procedure HandleConfigTemplates(<br/>        var ConfigTemplates: TestPage "Config Templates")<br/>var<br/>    ConfigTemplateCode: Code[10];<br/>    "Value": Variant;<br/>begin<br/>    LibraryVariableStorage.Dequeue("Value");<br/>    ConfigTemplateCode:= "Value";<br/><br/>    ConfigTemplates.GoToKey(ConfigTemplateCode);<br/>    ConfigTemplates.OK.Invoke();<br/>end;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test execution</h1>
                </header>
            
            <article>
                
<p>Fingers crossed for green results:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-769 image-border" src="assets/e8a6f37d-a354-4b90-9518-8350b2e1af54.png" style="width:97.08em;height:38.92em;"/></p>
<p>Success! Notice the first test function line of codeunit <kbd>81006</kbd>, <kbd>LookupValue Inheritance</kbd>, containing another scenario, <kbd>#0024</kbd>, implemented by test function <kbd>InheritLookupValueFromCustomerOnSalesDocument</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test the test</h1>
                </header>
            
            <article>
                
<p>By now, you know how to adjust a test so the verification errs. But does the queue do its job right? How about enqueuing a none existing configuration template code? Let's randomly choose one—<kbd>LUC</kbd>.</p>
<p>Running the test now throws the following error:</p>
<pre>Unexpected CLR exception thrown.: Microsoft.Dynamics.Framework.UI.FormAbortException: Page New - Customer Card has to close ---&gt; Microsoft.Dynamics.Nav.Types.Exceptions.NavTestRowNotFoundException: The row does not exist on the TestPage. ---&gt; System.</pre>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-770 image-border" src="assets/369bccd4-6217-4849-be30-e6c0254f08e8.png" style="width:97.08em;height:38.83em;"/></p>
<p>The error message does not mention the row key value, but it surely lets us know that it cannot find the row the test wants to be selected—<kbd>LUC</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>By building three more test examples, we learned how to set up a shared fixture, how to parametrize tests, and how to hand over variables to UI handlers. These are three techniques that will be of invaluable worth in your future test automation practices.</p>
<p>In the next chapter, we will add two more <em>tools</em> to your test toolkit. You will learn how to test a report dataset and how to workout a more complex scenario.</p>


            </article>

            
        </section>
    </body></html>