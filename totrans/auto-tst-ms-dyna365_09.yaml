- en: From Customer Wish to Test Automation - Next Level
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we built our first basic test automation in Dynamics
    365 Business Central. We looked at three simple examples that show how to apply
    the **Acceptance Test-Driven Development** (**ATDD**) test case pattern and our
    *4-steps recipe* to get customer wishes converted into an application and test
    code. In this chapter, we will use the same methodology to create some more tests
    that:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Use a shared fixture
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are parametrized
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hand over variables to UI handlers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sales documents, customer template, and warehouse shipment
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the three examples of [Chapter 5](56634efe-664c-421a-9582-b2a6ae69722a.xhtml), *From
    Customer Wish to Test Automation - The Basics*, we added the `Lookup Value Code`
    field to the `Customer` table. However, that's just a part of the customer wish
    as it describes clearly that…
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '"… this field has to be carried over to the whole bunch of sales documents
    and, at the same time, it needs to be included in the warehouse shipping."'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: So, before we dive into the following test examples, a note needs to be made
    that, parallel to the implementation of the `Lookup Value Code` field on the `Customer`
    table, the same field has to be implemented on the `Sales Header` table, the `Customer
    Template` table, the `Warehouse Shipment Line` table, and all related pages. The
    ATDD test case descriptions are very much alike, and this will be the same case
    for the application and test code. Copy and paste—the great virtue of any Business
    Central developer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at how the ATDD test case descriptions do look like for customer
    template:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Do you see the resemblance with scenarios `#0001`, `#0002`, and `#0003`?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: On GitHub, you will find both the full list of ATDD scenarios and the complete
    test code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Test example 4 – how to set up a shared fixture
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although it isn't explicitly mentioned, we created a *fresh fixture* for each
    of the three previous tests as defined per the `[GIVEN]` tags, being a lookup
    value record and a customer record. For speed purposes, however, it does make
    sense to consider whether you need a fresh fixture for each test or a shared fixture
    for a group of tests. In the case of scenarios `#0001` and `#0003`, we could perfectly
    do with the same `LookupValueCode`, no need to create a new lookup value record
    for each of these tests.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Customer wish
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use the part of the customer wish that prescribes to have a `Lookup
    Value Code` field on all sales documents to illustrate how a shared fixture can
    be achieved. This would come down to the following eight scenarios, leaving out
    the `GIVEN`-`WHEN`-`THEN` part to save space:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With [Chapter 5](56634efe-664c-421a-9582-b2a6ae69722a.xhtml),* From Customer
    Wish to Test Automation – The Basics*, fresh in your mind, you might notice that
    scenario `#0001` and `#0004` are quite similar. This is the same for scenario
    `#0003` and `#0006` through `#0011`. As such, all of these scenarios share the
    following same `[GIVEN]` part:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Straightforward implementation of this requirement would lead to creating a
    lookup value record seven times. So, we'll be lazy and apply the shared fixture,
    or lazy setup, pattern.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Application code
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part of the customer wish leads to the implementation of the `Lookup Value
    Code` field on the sales header, and a page control for this field on each of
    the sales document pages.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'The next code snippet implements the extension of the `Sales Header` table,
    that is, scenarios `#0004` and `#0005`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Furthermore, the following code block will implement the extension of the `Sales
    Order` page (see scenario `#0007`):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Scenarios `#0006`, `#0008`, `#0009`, `#0010`, and `#0011` would lead in a similar
    manner to the extension of the `Sales Quote`, `Sales Invoice`, `Sales Credit Memo`,
    `Sales Return Order`, and `Blanket Sales Order` document pages.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Test Code
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With some big steps, we'll create our test code for scenarios `#0004`, `#0006`,
    and `#0007`, leaving scenarios `#0005`, `#0008`, `#0009`, `#0010`, and `#0011`
    for you to review on GitHub.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Create a test codeunit
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Embed the customer wish into a test function
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Embedding the three scenarios, `#0004`, `#0006`, and `#0007`, into test functions
    makes our new test codeunit look as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Write your test story
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the structure is clear, we can pick out scenario `#0007` to create
    more detail:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So, how do we go about setting up the shared fixture? We do this by using the
    `Initialize` function, as introduced in [Chapter 4](db955f66-11f4-4d9a-90c7-5af04058ebbe.xhtml),
    *Test Design*. This would change `AssignLookupValueToSalesOrderDocument` into
    the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Construct the real code
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s build a simple `Initialize`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, both `isInitialized` and `LookupValueCode` are global variables of respectively
    `Boolean` and `Code[10]` data types. Once `Initialize` has been called, `isInitialized`
    will be `true` and the `if`-statement will evaluate to `true` any time `Initialize`
    is being called, always leading to a straight exit from `Initialize`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'With respect to scenario `#0007`, our test codeunit would become as follows,
    including the various variables, parameters, and other helper functions:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Test execution
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running a full-fledged codeunit 81001 yields a bunch of successes:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d92a997-0fcd-4fad-a2b6-9dd9f9bc234f.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: Test the test
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By now, I guess you know what to do here: adjust the test so the verification
    errs. Give it a try, or use the completed code on GitHub as your cheat sheet.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Test example 5 – how to parametrize tests
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing test automation, including design and coding, is a considerable effort,
    which has a lot of details to pay attention to. However, once you've got the hang
    of it and have it in place, you will enjoy it and continue to profit from it.
    This is the case unless you're sloppy on the details at both the design and coding
    levels, and thus have to keep fixing your tests. Nevertheless, you will enjoy
    writing even more if you make your tests generic by parameterizing them. By the
    nature of the testability framework, you will not be able to parametrize a test
    function, but you can achieve this by encapsulating your generic test code in
    a helper function.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Customer wish
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s illustrate this with another part of our customer''s wish: archiving
    a sales document. As Business Central enables the user to archive a sales quote,
    a sales order, and a sales return order, we have to include this in our extension.
    This is expressed in the following three scenarios:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Application code
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The data model extension is implemented by the following `.al` object:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And the UI is extended subsequently as follows for scenario `#0019`. It will
    look very much alike for scenarios `#0018` and `#0020`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Test code
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the app code has set lets have a look at the test code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Create, embed, and write
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With one big step of "creating, embedding and writing" this is how the test
    stories `#0018`, `#0019`, and `#0020` could look like, when placed in a new test
    codeunit:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Construct the real code
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When all three scenarios are testing the process of archiving a sales document,
    they boil down to a generic story with only one variable being the document type—quote,
    order, or return order. Consequently, we can thicken this into one test story:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As said, we cannot parametrize a `test` function, but we can cast this into
    a local method to be called from the three tests:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The three tests will then become:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Copy and paste: three birds in one stroke.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Go to GitHub to have a look at the implementation of the other helper functions
    and an additional scenario, `#00021`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Test execution
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Show me the green successes:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbb328b0-9275-4e1a-92e8-56e3e90b98c5.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: Ouch ...... RED?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Apparently, as the test errors indicate in Test Tool, we need to handle a `Confirm`.
    Let's go into the application and try to archive a sales order.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this take the following steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Use *Alt* + *Q*, the Tell Me What You Want feature
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `Sales Orders` and select the Sales Orders hyperlink to open the `Sales
    Orders` page
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the document page of the first sales order
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Actions | Functions | Archive Document
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Indeed, a dialog appears here asking the user to confirm (or not):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b476d1b-f990-4a2b-bf29-fd6a38d16317.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: 'See what happens when we click Yes in the confirm dialog: a message appears
    informing the user that the document has been archived, as shown in the following
    screenshot:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/043f228f-2772-456d-86c4-ca7916b6aaef.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
- en: 'Once the user clicks OK in the message dialog, the archiving of the document
    is complete. With respect to our test automation, we need to create two handler
    functions—one handler function to handle the confirm dialog, and the other to
    handle the message, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Both the handlers are minimally implemented; they will just handle the dialogs
    and not check anything. I will elaborate on that some more in the next example.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Link them to our tests using the `HandlerFunctions` tag:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The test codeunit for scenario `#0018` will then become:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, run it again! Do show us the green, please:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c67e45c-c8fc-47ec-ad04-91fe40430c82.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: Test the test
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You know what to do. Yes, you do, right?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: A missing scenario?
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the great reviewers of this book, Steven Renders, pointed out to me
    that there is a hole in the scenarios for the customer wish that, when archiving
    a sales document, the lookup value should be carried over to the archived sales
    document. Before I step into the specifics, this a perfect illustration of what
    I already mentioned in [Chapter 4](db955f66-11f4-4d9a-90c7-5af04058ebbe.xhtml),
    *Test Design*: "a test design is an object to help the team discuss their test
    effort, to reveal the holes in their thoughts…"'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: So, what is this hole? If you have a confirmation, asking the user for a Yes
    or No, there are at least two scenarios that need to be tested, and my scenarios
    only handles the Yes. So, what about the No? This indeed is a user scenario as
    such, but I do not consider it a scenario to be tested within the context of our
    customer wish. It is a scenario that relates to the bigger feature of archiving
    sales documents. As such, this scenario was not added to our collection on the
    assumption that this is handled by standard tests.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, in any future project be triggered when confirm statements are
    used, as in principle, these lead to at least two scenarios.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Test example 6 – how to hand over data to UI handlers
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just now, with the previous test example where we hit upon the need for two
    dialog handlers, it makes sense to discuss how to hand over data to a UI handler,
    as we cannot directly control this. However, the platform does, and the argument
    list is a fixed one.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Customer wish
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this context, we pick up another part of our customer wish—when creating
    a new customer from the UI, by clicking the standard New action on the ribbon,
    the user has to select a template to base the new customer on (or simply bypass
    it by selecting Cancel), as shown in this screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50b3e26d-4519-4cbb-b764-830f685f9c71.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: We've had to tackle the appearance of the ModalPage already in test example
    3 of the previous chapter. This part of the customer wish tells us that the configuration
    template that's behind the templates the user can choose should be set up, so
    that it will autopopulate the `Lookup Value Code` field on the newly created customer
    from the selected template.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what scenario `#0028` entails:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can accomplish this by setting up a configuration template. There is no need
    for any application code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Test code
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's wrap scenario `#0028` in a new test codeunit.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Create, embed, and write
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This leads to the following code construction:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Construct the real code
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Including all technical details, like variables and arguments, this codeunit
    would become:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We need to create the following four helper functions and one UI handler:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '`Initialize`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateCustomerConfigurationTemplateWithLookupValue`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateCustomerFromConfigurationTemplate`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VerifyLookupValueOnCustomer`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HandleConfigTemplates`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two of the five procedures needed can be *inherited* from earlier test examples:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '`Initialize` takes care of the Lookup Value and can be copied from test example
    4'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VerifyLookupValueOnCustomer` can be taken from test example 1'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The other three functions, `CreateCustomerConfigurationTemplateWithLookupValue`,
    `CreateCustomerFromConfigurationTemplate`, and `HandleConfigTemplates`, will be
    as follows. The function names describe exactly what the function is doing. I
    will leave it you to read and grasp the meaning of the first two. In the context
    of this test example we will elaborate more on `HandleConfigTemplates`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As soon as a new customer card is created in `CreateCustomerFromConfigurationTemplate`,
    the `Config Templates` page needs to be handled by the ModalPageHandler `HandleConfigTemplates`.
    Out of the list of configuration templates, it should select the configuration
    template created by `CreateCustomerConfigurationTemplateWithLookupValue`. With
    the `GoToKey` method of a TestPage, we can achieve this, but it needs to provide
    the PK value of the template, as marked by the triangular brackets in the preceding
    code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'A straightforward solution would be to create a global variable called `ConfigTemplateCode`,
    which would be populated in the `[GIVEN]` part of our test, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This would successively be picked up by our `ModalPageHandler`. This would undoubtedly
    be a perfectly valid solution. But picture yourself having to hand over multiple
    different values of different data types in one test codeunit, stacking global
    variable upon global variable. To overcome this, Microsoft has provided us with
    a neat feature implemented in the codeunit, `Library - Variable Storage`. It consists
    of a queue of 25 variant elements. Using `Enqueue` and `Dequeue`, you can store
    and retrieve your variable in a first in, first out manner.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Enqueue
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Call `Enqueue` in your test code before the handler is triggered, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Dequeue
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the handler, call `Dequeue` to retrieve the variable, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Test execution
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fingers crossed for green results:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8a6f37d-a354-4b90-9518-8350b2e1af54.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: Success! Notice the first test function line of codeunit `81006`, `LookupValue
    Inheritance`, containing another scenario, `#0024`, implemented by test function
    `InheritLookupValueFromCustomerOnSalesDocument`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Test the test
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you know how to adjust a test so the verification errs. But does the
    queue do its job right? How about enqueuing a none existing configuration template
    code? Let's randomly choose one—`LUC`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经知道如何调整测试以便让验证失败。但是队列能否正确执行它的任务呢？试试将一个不存在的配置模板代码加入队列怎么样？我们随便选一个—`LUC`。
- en: 'Running the test now throws the following error:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行测试会抛出以下错误：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![](img/369bccd4-6217-4849-be30-e6c0254f08e8.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/369bccd4-6217-4849-be30-e6c0254f08e8.png)'
- en: The error message does not mention the row key value, but it surely lets us
    know that it cannot find the row the test wants to be selected—`LUC`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息没有提到行键值，但它明确告诉我们无法找到测试想要选择的行—`LUC`。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: By building three more test examples, we learned how to set up a shared fixture,
    how to parametrize tests, and how to hand over variables to UI handlers. These
    are three techniques that will be of invaluable worth in your future test automation
    practices.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构建三个额外的测试示例，我们学习了如何设置共享固定装置、如何参数化测试，以及如何将变量传递给UI处理程序。这三项技术将在你未来的测试自动化实践中具有无价的价值。
- en: In the next chapter, we will add two more *tools* to your test toolkit. You
    will learn how to test a report dataset and how to workout a more complex scenario.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将向你的测试工具包中添加两个*工具*。你将学习如何测试报告数据集以及如何处理更复杂的场景。
