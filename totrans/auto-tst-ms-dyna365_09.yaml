- en: From Customer Wish to Test Automation - Next Level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we built our first basic test automation in Dynamics
    365 Business Central. We looked at three simple examples that show how to apply
    the **Acceptance Test-Driven Development** (**ATDD**) test case pattern and our
    *4-steps recipe* to get customer wishes converted into an application and test
    code. In this chapter, we will use the same methodology to create some more tests
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a shared fixture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are parametrized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hand over variables to UI handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sales documents, customer template, and warehouse shipment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the three examples of [Chapter 5](56634efe-664c-421a-9582-b2a6ae69722a.xhtml), *From
    Customer Wish to Test Automation - The Basics*, we added the `Lookup Value Code`
    field to the `Customer` table. However, that's just a part of the customer wish
    as it describes clearly that…
  prefs: []
  type: TYPE_NORMAL
- en: '"… this field has to be carried over to the whole bunch of sales documents
    and, at the same time, it needs to be included in the warehouse shipping."'
  prefs: []
  type: TYPE_NORMAL
- en: So, before we dive into the following test examples, a note needs to be made
    that, parallel to the implementation of the `Lookup Value Code` field on the `Customer`
    table, the same field has to be implemented on the `Sales Header` table, the `Customer
    Template` table, the `Warehouse Shipment Line` table, and all related pages. The
    ATDD test case descriptions are very much alike, and this will be the same case
    for the application and test code. Copy and paste—the great virtue of any Business
    Central developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at how the ATDD test case descriptions do look like for customer
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Do you see the resemblance with scenarios `#0001`, `#0002`, and `#0003`?
  prefs: []
  type: TYPE_NORMAL
- en: On GitHub, you will find both the full list of ATDD scenarios and the complete
    test code.
  prefs: []
  type: TYPE_NORMAL
- en: Test example 4 – how to set up a shared fixture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although it isn't explicitly mentioned, we created a *fresh fixture* for each
    of the three previous tests as defined per the `[GIVEN]` tags, being a lookup
    value record and a customer record. For speed purposes, however, it does make
    sense to consider whether you need a fresh fixture for each test or a shared fixture
    for a group of tests. In the case of scenarios `#0001` and `#0003`, we could perfectly
    do with the same `LookupValueCode`, no need to create a new lookup value record
    for each of these tests.
  prefs: []
  type: TYPE_NORMAL
- en: Customer wish
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use the part of the customer wish that prescribes to have a `Lookup
    Value Code` field on all sales documents to illustrate how a shared fixture can
    be achieved. This would come down to the following eight scenarios, leaving out
    the `GIVEN`-`WHEN`-`THEN` part to save space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With [Chapter 5](56634efe-664c-421a-9582-b2a6ae69722a.xhtml),* From Customer
    Wish to Test Automation – The Basics*, fresh in your mind, you might notice that
    scenario `#0001` and `#0004` are quite similar. This is the same for scenario
    `#0003` and `#0006` through `#0011`. As such, all of these scenarios share the
    following same `[GIVEN]` part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Straightforward implementation of this requirement would lead to creating a
    lookup value record seven times. So, we'll be lazy and apply the shared fixture,
    or lazy setup, pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Application code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part of the customer wish leads to the implementation of the `Lookup Value
    Code` field on the sales header, and a page control for this field on each of
    the sales document pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next code snippet implements the extension of the `Sales Header` table,
    that is, scenarios `#0004` and `#0005`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, the following code block will implement the extension of the `Sales
    Order` page (see scenario `#0007`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Scenarios `#0006`, `#0008`, `#0009`, `#0010`, and `#0011` would lead in a similar
    manner to the extension of the `Sales Quote`, `Sales Invoice`, `Sales Credit Memo`,
    `Sales Return Order`, and `Blanket Sales Order` document pages.
  prefs: []
  type: TYPE_NORMAL
- en: Test Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With some big steps, we'll create our test code for scenarios `#0004`, `#0006`,
    and `#0007`, leaving scenarios `#0005`, `#0008`, `#0009`, `#0010`, and `#0011`
    for you to review on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Create a test codeunit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Embed the customer wish into a test function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Embedding the three scenarios, `#0004`, `#0006`, and `#0007`, into test functions
    makes our new test codeunit look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Write your test story
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the structure is clear, we can pick out scenario `#0007` to create
    more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So, how do we go about setting up the shared fixture? We do this by using the
    `Initialize` function, as introduced in [Chapter 4](db955f66-11f4-4d9a-90c7-5af04058ebbe.xhtml),
    *Test Design*. This would change `AssignLookupValueToSalesOrderDocument` into
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Construct the real code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s build a simple `Initialize`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, both `isInitialized` and `LookupValueCode` are global variables of respectively
    `Boolean` and `Code[10]` data types. Once `Initialize` has been called, `isInitialized`
    will be `true` and the `if`-statement will evaluate to `true` any time `Initialize`
    is being called, always leading to a straight exit from `Initialize`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With respect to scenario `#0007`, our test codeunit would become as follows,
    including the various variables, parameters, and other helper functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Test execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running a full-fledged codeunit 81001 yields a bunch of successes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d92a997-0fcd-4fad-a2b6-9dd9f9bc234f.png)'
  prefs: []
  type: TYPE_IMG
- en: Test the test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By now, I guess you know what to do here: adjust the test so the verification
    errs. Give it a try, or use the completed code on GitHub as your cheat sheet.'
  prefs: []
  type: TYPE_NORMAL
- en: Test example 5 – how to parametrize tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing test automation, including design and coding, is a considerable effort,
    which has a lot of details to pay attention to. However, once you've got the hang
    of it and have it in place, you will enjoy it and continue to profit from it.
    This is the case unless you're sloppy on the details at both the design and coding
    levels, and thus have to keep fixing your tests. Nevertheless, you will enjoy
    writing even more if you make your tests generic by parameterizing them. By the
    nature of the testability framework, you will not be able to parametrize a test
    function, but you can achieve this by encapsulating your generic test code in
    a helper function.
  prefs: []
  type: TYPE_NORMAL
- en: Customer wish
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s illustrate this with another part of our customer''s wish: archiving
    a sales document. As Business Central enables the user to archive a sales quote,
    a sales order, and a sales return order, we have to include this in our extension.
    This is expressed in the following three scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Application code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The data model extension is implemented by the following `.al` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And the UI is extended subsequently as follows for scenario `#0019`. It will
    look very much alike for scenarios `#0018` and `#0020`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Test code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the app code has set lets have a look at the test code.
  prefs: []
  type: TYPE_NORMAL
- en: Create, embed, and write
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With one big step of "creating, embedding and writing" this is how the test
    stories `#0018`, `#0019`, and `#0020` could look like, when placed in a new test
    codeunit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Construct the real code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When all three scenarios are testing the process of archiving a sales document,
    they boil down to a generic story with only one variable being the document type—quote,
    order, or return order. Consequently, we can thicken this into one test story:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As said, we cannot parametrize a `test` function, but we can cast this into
    a local method to be called from the three tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The three tests will then become:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy and paste: three birds in one stroke.'
  prefs: []
  type: TYPE_NORMAL
- en: Go to GitHub to have a look at the implementation of the other helper functions
    and an additional scenario, `#00021`.
  prefs: []
  type: TYPE_NORMAL
- en: Test execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Show me the green successes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbb328b0-9275-4e1a-92e8-56e3e90b98c5.png)'
  prefs: []
  type: TYPE_IMG
- en: Ouch ...... RED?
  prefs: []
  type: TYPE_NORMAL
- en: Apparently, as the test errors indicate in Test Tool, we need to handle a `Confirm`.
    Let's go into the application and try to archive a sales order.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Use *Alt* + *Q*, the Tell Me What You Want feature
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `Sales Orders` and select the Sales Orders hyperlink to open the `Sales
    Orders` page
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the document page of the first sales order
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Actions | Functions | Archive Document
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Indeed, a dialog appears here asking the user to confirm (or not):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b476d1b-f990-4a2b-bf29-fd6a38d16317.png)'
  prefs: []
  type: TYPE_IMG
- en: 'See what happens when we click Yes in the confirm dialog: a message appears
    informing the user that the document has been archived, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/043f228f-2772-456d-86c4-ca7916b6aaef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the user clicks OK in the message dialog, the archiving of the document
    is complete. With respect to our test automation, we need to create two handler
    functions—one handler function to handle the confirm dialog, and the other to
    handle the message, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Both the handlers are minimally implemented; they will just handle the dialogs
    and not check anything. I will elaborate on that some more in the next example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Link them to our tests using the `HandlerFunctions` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The test codeunit for scenario `#0018` will then become:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run it again! Do show us the green, please:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c67e45c-c8fc-47ec-ad04-91fe40430c82.png)'
  prefs: []
  type: TYPE_IMG
- en: Test the test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You know what to do. Yes, you do, right?
  prefs: []
  type: TYPE_NORMAL
- en: A missing scenario?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the great reviewers of this book, Steven Renders, pointed out to me
    that there is a hole in the scenarios for the customer wish that, when archiving
    a sales document, the lookup value should be carried over to the archived sales
    document. Before I step into the specifics, this a perfect illustration of what
    I already mentioned in [Chapter 4](db955f66-11f4-4d9a-90c7-5af04058ebbe.xhtml),
    *Test Design*: "a test design is an object to help the team discuss their test
    effort, to reveal the holes in their thoughts…"'
  prefs: []
  type: TYPE_NORMAL
- en: So, what is this hole? If you have a confirmation, asking the user for a Yes
    or No, there are at least two scenarios that need to be tested, and my scenarios
    only handles the Yes. So, what about the No? This indeed is a user scenario as
    such, but I do not consider it a scenario to be tested within the context of our
    customer wish. It is a scenario that relates to the bigger feature of archiving
    sales documents. As such, this scenario was not added to our collection on the
    assumption that this is handled by standard tests.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, in any future project be triggered when confirm statements are
    used, as in principle, these lead to at least two scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Test example 6 – how to hand over data to UI handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just now, with the previous test example where we hit upon the need for two
    dialog handlers, it makes sense to discuss how to hand over data to a UI handler,
    as we cannot directly control this. However, the platform does, and the argument
    list is a fixed one.
  prefs: []
  type: TYPE_NORMAL
- en: Customer wish
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this context, we pick up another part of our customer wish—when creating
    a new customer from the UI, by clicking the standard New action on the ribbon,
    the user has to select a template to base the new customer on (or simply bypass
    it by selecting Cancel), as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50b3e26d-4519-4cbb-b764-830f685f9c71.png)'
  prefs: []
  type: TYPE_IMG
- en: We've had to tackle the appearance of the ModalPage already in test example
    3 of the previous chapter. This part of the customer wish tells us that the configuration
    template that's behind the templates the user can choose should be set up, so
    that it will autopopulate the `Lookup Value Code` field on the newly created customer
    from the selected template.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what scenario `#0028` entails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We can accomplish this by setting up a configuration template. There is no need
    for any application code.
  prefs: []
  type: TYPE_NORMAL
- en: Test code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's wrap scenario `#0028` in a new test codeunit.
  prefs: []
  type: TYPE_NORMAL
- en: Create, embed, and write
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This leads to the following code construction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Construct the real code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Including all technical details, like variables and arguments, this codeunit
    would become:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to create the following four helper functions and one UI handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Initialize`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateCustomerConfigurationTemplateWithLookupValue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateCustomerFromConfigurationTemplate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VerifyLookupValueOnCustomer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HandleConfigTemplates`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two of the five procedures needed can be *inherited* from earlier test examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Initialize` takes care of the Lookup Value and can be copied from test example
    4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VerifyLookupValueOnCustomer` can be taken from test example 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The other three functions, `CreateCustomerConfigurationTemplateWithLookupValue`,
    `CreateCustomerFromConfigurationTemplate`, and `HandleConfigTemplates`, will be
    as follows. The function names describe exactly what the function is doing. I
    will leave it you to read and grasp the meaning of the first two. In the context
    of this test example we will elaborate more on `HandleConfigTemplates`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As soon as a new customer card is created in `CreateCustomerFromConfigurationTemplate`,
    the `Config Templates` page needs to be handled by the ModalPageHandler `HandleConfigTemplates`.
    Out of the list of configuration templates, it should select the configuration
    template created by `CreateCustomerConfigurationTemplateWithLookupValue`. With
    the `GoToKey` method of a TestPage, we can achieve this, but it needs to provide
    the PK value of the template, as marked by the triangular brackets in the preceding
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'A straightforward solution would be to create a global variable called `ConfigTemplateCode`,
    which would be populated in the `[GIVEN]` part of our test, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This would successively be picked up by our `ModalPageHandler`. This would undoubtedly
    be a perfectly valid solution. But picture yourself having to hand over multiple
    different values of different data types in one test codeunit, stacking global
    variable upon global variable. To overcome this, Microsoft has provided us with
    a neat feature implemented in the codeunit, `Library - Variable Storage`. It consists
    of a queue of 25 variant elements. Using `Enqueue` and `Dequeue`, you can store
    and retrieve your variable in a first in, first out manner.
  prefs: []
  type: TYPE_NORMAL
- en: Enqueue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Call `Enqueue` in your test code before the handler is triggered, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Dequeue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the handler, call `Dequeue` to retrieve the variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Test execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fingers crossed for green results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8a6f37d-a354-4b90-9518-8350b2e1af54.png)'
  prefs: []
  type: TYPE_IMG
- en: Success! Notice the first test function line of codeunit `81006`, `LookupValue
    Inheritance`, containing another scenario, `#0024`, implemented by test function
    `InheritLookupValueFromCustomerOnSalesDocument`.
  prefs: []
  type: TYPE_NORMAL
- en: Test the test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you know how to adjust a test so the verification errs. But does the
    queue do its job right? How about enqueuing a none existing configuration template
    code? Let's randomly choose one—`LUC`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the test now throws the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/369bccd4-6217-4849-be30-e6c0254f08e8.png)'
  prefs: []
  type: TYPE_IMG
- en: The error message does not mention the row key value, but it surely lets us
    know that it cannot find the row the test wants to be selected—`LUC`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By building three more test examples, we learned how to set up a shared fixture,
    how to parametrize tests, and how to hand over variables to UI handlers. These
    are three techniques that will be of invaluable worth in your future test automation
    practices.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will add two more *tools* to your test toolkit. You
    will learn how to test a report dataset and how to workout a more complex scenario.
  prefs: []
  type: TYPE_NORMAL
