- en: From Customer Wish to Test Automation - And Some More
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Getting the hang of it by now? Well, you did get this far, right? Let''s do
    another *one for the road*, or actually two. We''ll supplement your tool box with
    a last duo of test tools for Microsoft Dynamics 365 Business Central. In this
    chapter, we''ll expand on how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Test a report
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up a more complex scenario
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test example 7 – how to test a report
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reports have always been a substantial part of many Business Central projects
    and solutions. It makes perfect sense to have a look at how to test them in an
    automated manner. Now, how do we go about doing that? In this example, we will
    work out testing the dataset being created by a report. Layout testing is another
    job to do, and one outside of the testability framework.
  prefs: []
  type: TYPE_NORMAL
- en: Customer wish
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our customer''s wish describes that the `Lookup Value Code` field of the customer
    has to be carried over to the various sales documents. The logical consequence,
    even though not explicitly stated, would be that each printed version of these
    documents would have to be extended with this field. Note that at this point in
    time, we cannot extend a standard report. Extending a standard report can now
    only be achieved by cloning it into our extension. As sales document reports are
    quite comprehensive, both on the dataset and on the layout side, we take a simpler
    example. We''ll clone report 101, `Customer - List`, and add the `Lookup Value
    Code` field to it as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6c851b4-12ce-449a-a9e3-a6655f329107.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This could be a possible translation into an ATDD test case description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Why two customers, you might wonder. As the report should be able to list multiple
    customers, it makes sense not to test for just one customer.
  prefs: []
  type: TYPE_NORMAL
- en: Application code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A condensed version of the cloned report on this and next page, shows where
    we have added the `Lookup Value Code` field. The preceding screenshot depicts
    the field placed in the layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Test code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have a look at our `.al` implementation of scenario `#0029`.
  prefs: []
  type: TYPE_NORMAL
- en: Create, embed, and write
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the codeunit, embedding the ATDD scenario, and writing the story will
    result in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Construct the real code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: See, how the helper functions look like.
  prefs: []
  type: TYPE_NORMAL
- en: '`Initialize` makes sure our report only picks up the two newly created customers
    by deleting all customer records that exist in the database; as the test will
    be run in isolation, this deletion will be reverted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`CreateCustomerWithLookupValue` and `CreateLookupValueCode` are becoming our
    next door neighbors to help us out in almost all of our scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing a report dataset is about browsing its XML structure, therefore, `CommitAndRunReportCustomerList`
    calls `RunReportAndLoad` in codeunit `Library - Report Dataset` (131007) to stream
    the dataset in a temporary `TempBlob` record (table 99008535) to be used in the
    verification part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In `VerifyCustWithLookupValueOnCustListReport`, we see that `FindRow` reads
    the customer number (column `Customer_No_`) and our lookup value (column `Customer_Lookup_Value_Code`)
    and determines their row position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'A few notes more:'
  prefs: []
  type: TYPE_NORMAL
- en: Elements in the definition of the report dataset are referred to as *columns*.  In
    the `Library - Report Dataset` codeunit, and thus in the test, for the same the
    term row is used which refers to the row in the xml of the dataset that has been
    generated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that the delta between the rows is verified to be `13`, meaning, referring
    to the previous note, that the column `Customer_Lookup_Value_Code` is the 13th
    column in the dataset after the column `Customer_No_`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For valid reasons, you could wonder if this is a relevant check; it will for
    sure error when the row math does not work out right anymore, as we will see later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You might have noticed: global variables declaration has been omitted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s becoming a habit: green, green, green!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/494128a7-eddb-486c-b419-f4e4a35d61f3.png)'
  prefs: []
  type: TYPE_IMG
- en: Test the test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Come on! We control it ourselves. Let's do it.
  prefs: []
  type: TYPE_NORMAL
- en: Adjust the test so the verification errs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How about changing…
  prefs: []
  type: TYPE_NORMAL
- en: The hardcoded `13` in `VerifyCustWithLookupValueOnCustListReport` to `56`, or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its `LookupValueCode` parameter when being called from the test function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These will throw the following errors, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The latter might be kind of unexpected, as it doesn't show something comparable
    as before, stating `LUC` as the expected value and so on. Here, our verification
    is done by the `FindRow` method, and as `LUC` is not in the dataset, `FindRow`
    will return `a -1`, and as `Customer_No_` is on Row [3], the math will result
    in `-4`.
  prefs: []
  type: TYPE_NORMAL
- en: Test example 8 – how to construct an extensive scenario
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To achieve your goals as an end-user in Dynamics 365 Business Central, being
    the ERP package it is, you often end up exercising a substantial chain of consecutive
    actions. How do you go about constructing a suite of tests for that? How to create
    reusable parts? And how to make use of already existing helper functions in the
    Microsoft test libraries?
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this, we elaborate on another part of our customer wish.
  prefs: []
  type: TYPE_NORMAL
- en: Customer wish
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the business logic description of our customer wish it is mentioned that:'
  prefs: []
  type: TYPE_NORMAL
- en: When creating a warehouse shipment from a sales order, the Lookup Value Code
    field should be inherited from the Sales Header to the Warehouse Shipment Line.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is expressed in the following two scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This, however, implies that the `Lookup Value` field already exists on both
    the `Warehouse Shipment Line` and `Posted Whse. Shipment Line` tables, which is
    defined by the following three fundamental scenarios on our list, we have skipped
    so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As the scenarios are related, it won't be a surprise to find congruous parts.
    It's a message happily notifying us that we will be able to construct reusable
    parts and save time when working out all five scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the obvious ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'But you can often find hints inline. Compare the following taken from four
    of the five scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This tells us that, in all these cases, we will need a released sales order
    with a lookup value.
  prefs: []
  type: TYPE_NORMAL
- en: Application code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On account of scenarios `#0015`, `#00016` and `#0017`, the extension of the
    `Warehouse Shipment Line` and `Posted Whse. Shipment Line` tables and their related
    pages, is implemented with the next code (again in a bare minimum to save space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable scenarios `#0030` and `#0031`, the standard application only needs
    to be extended with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The subscriber `OnBeforeCreateShptLineFromSalesLineEvent` assures that the value
    of the `Lookup Value Code` field on a sales document is copied to the `Lookup
    Value Code` field on the warehouse shipment line.
  prefs: []
  type: TYPE_NORMAL
- en: Test code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's implement the four overlapping scenarios `#0015`, `#0017`, `#0030`, and
    `#0031`.
  prefs: []
  type: TYPE_NORMAL
- en: Create, embed, and write
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Construct the real code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the code on GitHub, we leave it to you to have a look at the major part
    of the implementation of these tests. Here, however, we''ll study closer scenario
    `#0030`, wherein both the `[GIVEN]` and `[THEN]` parts are shared with the other
    three scenarios. Paraphrasing the question with which we started this last test example,
    the goal here is to show you how:'
  prefs: []
  type: TYPE_NORMAL
- en: A complex scenario could be build up creating and using reusable parts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To find as much as possible reusable parts in the standard libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With `Initialize` being the first reusable that is shared, part of the data
    setup is being handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The structure of `Initialize` by now should look familiar, including the usage
    of the global Boolean variable `isInitialized`, the global `Code[10]` variable
    `LookupValueCode`, and local helper function `CreateLookupValueCode`, and why
    `CreateLookupValueCode` can be part of the lazy setup.
  prefs: []
  type: TYPE_NORMAL
- en: The creation of a location (with *require shipment*) and a warehouse employee
    can also be embedded in `Initialize` as these can easily be shared between the
    four scenarios. For this, `DefaultLocation` is set up as a global record variable
    (based on the `Location` table). The warehouse employee does not need to be stored
    as it will be retrieved from the database.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, use is made of two helper functions through a library codeunit
    variable `LibraryWarehouse` based on the standard codeunit called `Library - Warehouse`.
    Using the simple and quick file search method as mentioned in [Chapter 3](fdf2b65f-be7c-4710-a3a9-39f4cc34ee5c.xhtml),
    *The Test Tool and Standard Tests*, I hunted for a helper function to create a
    location, search string CreateLocation, and one to create a warehouse employee,
    search string CreateWarehouseEmployee.
  prefs: []
  type: TYPE_NORMAL
- en: Running the test functions, we eventually will have implemented the scenarios
    `#0015`, `#0017`, `#0030`, and `#0031` unambiguously, which shows that making
    use of the `Initialize` function is not only a matter of creating code that is
    easier to maintain and understand, it's also much faster and, as such, a must
    for automated tests.
  prefs: []
  type: TYPE_NORMAL
- en: Having run all four tests 10 times individually (and thus triggering `Initialize`
    as if it were a fresh setup), and also having run the four tests in one go 10
    times (now triggering `Initialize` to get a shared setup), it shows that the latter
    is more than 30% faster.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in both cases, scenario `#0015` is just as fast because it always
    makes `Initialize` run fully.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64112f97-0cae-40d2-bd09-6cad40acc690.png)'
  prefs: []
  type: TYPE_IMG
- en: VerifyLookupValueOnWarehouseShipmentLine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With `VerifyLookupValueOnWarehouseShipmentLine`, the second reusable part is
    found. It closely resembles the various `VerifyLookupValueOn` helper functions
    in the previous examples. Hence, with practicing the Business Central developer''s
    virtue, it''s a quick task to code `VerifyLookupValueOnWarehouseShipmentLine`:
    copy, paste, and adjust. We leave that to you.'
  prefs: []
  type: TYPE_NORMAL
- en: CreateWarehouseShipmentFromSalesOrder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have experience with the warehouse shipping feature of Business Central,
    you know that a series of steps have to be performed to get a warehouse shipment
    created. It's not as single fold an operation as creating a purchase invoice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The below process schema displays the tasks that need to be performed for the
    `[WHEN]` part of scenario `#0030`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23668512-6d19-4899-b799-868ed2a72d24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Based on this, the `.al` implementation becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next to the already encountered global codeunit variable `LibraryWarehouse`,
    we are using `LibrarySales`, based on standard codeunit `Library - Sales` and
    `LibraryRandom`, based on standard codeunit `Library - Random`. All three were
    the result of the search:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **A Helper method that** | **Is found with Search string** |'
  prefs: []
  type: TYPE_TB
- en: '| Creates a warehouse shipment from sales order | Procedure *CreateWhseShipmentFrom*
    |'
  prefs: []
  type: TYPE_TB
- en: '| Creates a sales document with an item and location | Procedure *CreateSalesDocumentWith*
    |'
  prefs: []
  type: TYPE_TB
- en: '| Release a sales document | Procedure *ReleaseSalesDoc* |'
  prefs: []
  type: TYPE_TB
- en: '| Generates a random number | Procedure *Random*, followed by procedure *Rand*
    |'
  prefs: []
  type: TYPE_TB
- en: We have created well readable, reusable, minimalistic functions. `CreateWarehouseShipmentFromSalesOrder`
    is being used by scenarios `#0015`, `#0017`, and `#0030`. `CreateAndReleaseSalesOrder`
    is directly being used by scenario `#0031` and indirectly by `#0015`, `#0017`,
    and `#0030`.
  prefs: []
  type: TYPE_NORMAL
- en: The two empty strings in the call to `LibrarySales.CreateSalesDocumentWithItem`
    trigger the creation of a customer and item.
  prefs: []
  type: TYPE_NORMAL
- en: Test execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Run, run, runnnnn. Grrrrrrrreeeeeeen!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c7f007d-a3ac-4ea3-aadb-c5d4de500d62.png)'
  prefs: []
  type: TYPE_IMG
- en: Test the test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have worked our way through this bigger challenge, let's, for the
    last time, test the test.
  prefs: []
  type: TYPE_NORMAL
- en: Adjust the test so the verification errs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us now adjust the test by providing another value for the expected result
    in scenarios `#0015`, `#0017`, `#0030`, and `#0031`: `LUC`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3acfe2a6-6841-462f-986a-099e0689d8c3.png)'
  prefs: []
  type: TYPE_IMG
- en: Refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, and actually the whole of section 3, we discussed various aspects
    of designing and coding automated tests for Dynamics 365 Business Central. We
    talked about and applied best practices, such as *reusability*, *readability*,
    and *minimalism*, but we did not apply it to the full extent. You might recall
    that at a couple of spots it was mentioned that some code part *smells like duplication*.
    This typically was a hint to refactor this code to make it reusable. We're not
    going to act on it within the confinement of this book. But the completed code
    that you can find on GitHub has been refactored resulting, among others, in the
    creation of two libraries with reusable helper methods. It also includes all scenarios
    that complete the full customer wish, as discussed at the start of [Chapter 5](56634efe-664c-421a-9582-b2a6ae69722a.xhtml),
    *From Customer Wish to Test Automation - The Basics*, but they have not been used
    as examples in the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the same time: be challenged and go and refactor the code you have created
    yourself so far while implementing the previous eight test examples. Having a
    complete set of application and test code in place allows you to refactor whatever
    you need to refactor, be it application or test code. But only one or the other.
    If refactoring application code leads to failing tests that used to succeed before,
    improve your refactored code and make all tests pass. If refactoring test code
    makes them fail where they didn''t previously, revert and do it better.'
  prefs: []
  type: TYPE_NORMAL
- en: Except for time shortage, and maybe a lazy mood, there is no reason not to refactor
    at this point. Get the best out of your code right now.
  prefs: []
  type: TYPE_NORMAL
- en: In case of code that is not yet covered by tests, write tests before doing any
    refactoring. If you don’t, the chances of breaking something and not noticing
    are very high.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to test a report dataset and how to build more
    extensive scenarios in such a way that the test code is readable, reusable, and,
    not least important, minimalistic, the latter by making use of standard helper
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, [Chapter 8](e9d66b9a-2c01-4581-acf0-986fa1407e31.xhtml), *How
    to Integrate Test Automation in Daily Development Practice*, we step into the
    last part of this book in which we will discuss how to integrate your test automation
    in your day-to-day development practice, including the tests provided by Microsoft.
  prefs: []
  type: TYPE_NORMAL
