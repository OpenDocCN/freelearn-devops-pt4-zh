<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">How to Integrate Test Automation in Daily Development Practice</h1>
                </header>
            
            <article>
                
<p>You've got this far into this book, so by now you have a clear notion on the needs for and benefits of test automation for Dynamics 365 Business Central. You have also already exercised designing and writing tests based on <a href="13a9d0b2-ae46-45ba-8790-8489439e70fc.xhtml" target="_blank">Section 3</a>, <em>Designing and Building Automated Tests for</em> <em>Microsoft Dynamics 365 Business Central</em>. The next step is to bring into practice what you have learned.</p>
<p class="mce-root">But from reading the book, and understanding the matters discussed, and working on your first exercises, making it part of your daily work might still be a threshold to take. As mentioned earlier, test automation is a team effort. Therefore, in this chapter, we will elaborate on a number of best practices that might turn out to be beneficial for you and your team in getting test automation working:</p>
<ul>
<li>Casting the customer wish into ATDD scenarios</li>
<li>Taking small steps</li>
<li>Making the test tool your friend</li>
<li>Integrating with daily build</li>
<li>Maintaining your test code</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Casting the customer wish into ATDD scenarios</h1>
                </header>
            
            <article>
                
<p>Crucial to getting test automation into your daily development practices is the adoption of it by the team. Like requirements and application code, tests and test code should be owned by the development team; not just formally, but also actively. Good <span>application </span>code does not emerge from a single-lined customer wish, it derives from a well detailed and formalized customer wish. And the same applies to tests and test code.</p>
<p>As discussed in <a href="db955f66-11f4-4d9a-90c7-5af04058ebbe.xhtml" target="_blank">Chapter 4</a>, <em>Test Design</em>, formalize your requirements by using the ATDD design pattern. Cast your customer wish in ATDD scenarios. Break down each wish into a list of tests, and make this your primary vehicle of communication for (1) detailing of your <strong>customer wish</strong>, (2) implementation of your <strong>application code</strong>, (3) structured execution of your <strong>manual tests</strong>, (4) coding of your <strong>test automation</strong> and (5) up-to-date <strong>documentation</strong> of your solution. Your test automation will be a logical result of all previous work.</p>
<p>As developers are the ones that will be doing both the application and tests coding, and in general are not the ones that understand the customer wish the best, ATDD scenarios already hit <em>two out of five birds in one stroke</em>. Make use of my ATDD Scenarios Excel sheet on GitHub, called <kbd>Clean sheet.xlsx</kbd><em>,</em> to get your team to start casting customer wishes into ATDD scenarios. It's exactly what I did when working on the test examples in <a href="56634efe-664c-421a-9582-b2a6ae69722a.xhtml" target="_blank">Chapter 5</a> through <a href="bb9ee41e-4c60-4a27-8fad-5343adfcd86a.xhtml" target="_blank">Chapter 7</a>. See the below screenshot for impression:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-777 image-border" src="assets/ad9d2554-1e1c-4f85-b5f6-0676c5d50266.png" style="width:129.42em;height:41.83em;"/></p>
<p>The first seven columns are for the product owners, functional consultants, and key users to fill in:</p>
<ul>
<li><kbd>Feature</kbd></li>
<li><kbd>Sub Feature</kbd></li>
<li><kbd>UI</kbd></li>
<li><kbd>Scenario</kbd></li>
<li><kbd>Given-When-Then (Tag)</kbd></li>
<li><kbd>Given-When-Then (Description)</kbd></li>
<li><kbd>Scenario #</kbd></li>
</ul>
<p><span>The last two columns, </span><kbd>ATDD Format</kbd><span> and </span><kbd>Code Format</kbd>, <span>are automatically populated as seen in the following screenshot. See that the latter column contains </span><em>the green</em><span>, that is, the formatted and already out-commented <kbd>GIVEN</kbd></span>-<span><kbd>WHEN</kbd></span>-<span><kbd>THEN</kbd> scenarios. These are ready to be copied and pasted into your test codeunit, and embedded into your test functions:</span></p>
<div class="packt_infobox">Currently, Jan Hoek and I are working to get this a step further. Have a look at our <kbd>ATDD.TestScriptor</kbd> that will, given an ATDD defined feature, construct the skeleton of the associated <kbd>.al</kbd> test codeunit: <a href="http://powershellgallery.com/packages/ATDD.TestScriptor">http://powershellgallery.com/packages/ATDD.TestScriptor</a>.<a href="http://powershellgallery.com/packages/ATDD.TestScriptor"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Taking small steps</h1>
                </header>
            
            <article>
                
<p>As the saying goes, <em>Rome wasn’t built in a day</em>. Likewise, get to master test automation one step at a time. Learn and improve by doing the following:</p>
<ul>
<li>Start casting the customer wish into the scenarios that come to mind. Try to keep it simple. Preferably, you would like to get a full coverage right away, but as it is a team effort, they will help you to identify the holes, and fill them.</li>
<li>Make use of my <em>4-steps</em> recipe, <em>create</em>, <em>embed</em>, <em>write</em>, and <em>construct</em>, for the conception of the test code:</li>
</ul>
<p style="padding-left: 120px">1. Create a test codeunit<br/>
2. Embed the customer wish into a test function<br/>
3. Write your test story<br/>
4. Construct the real code</p>
<ul>
<li>Get the test(s) run with every step performed, and as soon as the code is deployable. Do not wait until you’re finished, but verify your effort as soon as possible. See how your tests move from <strong>red</strong> to <strong>green</strong>.</li>
<li>Take joy in <em>testing the test</em> as a last small step in completing it. Either verify the data created or, often much easier, adjust the test so the verification errs.</li>
<li>Implement one scenario after the other and find yourself duplicating code parts. Do not force yourself into directly abstracting them into helper methods in libraries. This can wait until the <span>application</span> and test code are ready and refactoring can start. </li>
<li>Run the tests regularly, once the <span>application </span>code and tests are in and when a next update to the feature is made. While implementing, do not wait till the code is ready, verify each atomic change by running the tests, and add new tests for the new and updated scenarios.</li>
</ul>
<div class="packt_infobox">The aforementioned <kbd>ATDD.TestScriptor</kbd> will handle <em>Step 1</em> through <em>Step 3</em> of my 4-steps recipe for you.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making the test tool your friend</h1>
                </header>
            
            <article>
                
<p>In <a href="fdf2b65f-be7c-4710-a3a9-39f4cc34ee5c.xhtml" target="_blank">Chapter 3</a>, <em>The Test Tool and Standard Tests</em>, we introduced you to the test tool and we used it frequently during the work we did on the test examples. We applied it to <em>test the test</em> after having inserted a bug to let the <em>verification error</em>. Next to VS Code, your coding tool, and debugger, the test tool is your best friend. Keep it running while you develop, "<em>do not wait till the code is ready, verify each atomic change by running the tests</em>", as mentioned previously.</p>
<p>Create a specific test suite to hold the test codeunits that relate to the code you are working on. In most of your projects, it’s very likely, as with the <kbd>LookupValue</kbd> extension, that you end up with a bunch of test codeunits that will be executed within less than a minute. While working on a new test codeunit, create a new test suite to only hold that codeunit and repeatedly carry it out till coding is done.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test coverage map</h1>
                </header>
            
            <article>
                
<p>The test tool also holds a powerful feature we haven’t mentioned so far and can be of great help in picking out relevant test codeunits for the code update you are working on. It is called <strong>Test Coverage Map</strong> (<strong>TCM</strong>). It combines the result of the code coverage tool that also resides in Business Central and the test tool. Having TCM turned on, it adds two extra options to the <span class="packt_screen">Get Test Codeunits</span> feature already demoed in <a href="fdf2b65f-be7c-4710-a3a9-39f4cc34ee5c.xhtml" target="_blank">Chapter 3</a>, <em>The Test Tool and Standard Tests</em>. There, we explained that <span class="packt_screen">Get Test Codeunits</span> offers the following two options to let you populate your test suite:</p>
<ul>
<li><span class="packt_screen">Select Test Codeunits</span></li>
<li><span class="packt_screen">All Test Codeunits</span></li>
</ul>
<p>With TCM, two more options are added.</p>
<p><span>Choosing the third option, </span><em><span class="packt_screen">Get Test Codeunits based on Modified Objects</span></em><span>, will select those test codeunits that will hit the application objects you are working on. The fourth option, </span><em><span class="packt_screen">Get Test Codeunits based on Selected Objects</span></em><span>, let’s you select from a list those application objects you want to run tests against.</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-778 image-border" src="assets/5c52bbc5-3d31-45ed-8298-ad590f3b2aae.png" style="width:32.50em;height:16.42em;"/></p>
<p>At this very moment, the <em><span class="packt_screen">Get Test Codeunits based on Modified Objects</span></em> option only takes into account the application objects that reside in standard, that is, in C/SIDE. Unfortunately, it does not yet consider objects that reside in extensions.</p>
<p>The fourth option, <em><span class="packt_screen">Get Test Codeunits based on Selected Objects</span></em>, nevertheless includes all application objects.</p>
<p><span>To be able to use TCM, you need to turn it on. To do this, check mark the </span><span class="packt_screen">Update Test Coverage Map</span><span> field on a test suite. If this has not been turned on, on any test suite, TCM will not have data to allow you to choose </span><span class="packt_screen">Get Test Codeunits based on Modified Objects</span><span> </span>and<span> </span><span class="packt_screen">Get Test Codeunits based on Selected Objects</span><span> options as described previously.</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-802 image-border" src="assets/0c996815-62af-4afe-adcd-0f369cc4edeb.png" style="width:81.33em;height:39.25em;"/></p>
<div class="packt_infobox">For TCM to have the data available to do its job, the activated test suite should be run first.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extending the test tool</h1>
                </header>
            
            <article>
                
<p>When we started using the test tool more intensely years ago, there was one major omission that we decided to build a simple extension for. Once you have set up a test suite and run all the tests, you might end up having only a portion of the tests that passed successfully. And, logically, the other parts not passing.</p>
<p>While finding and fixing the cause of the failures, you presumably would only want to run the faulty ones. The standard test tool lets you only activate/deactivate by (un)checking the <span class="packt_screen">Run</span> field of each individual function line. Checking/unchecking <span class="packt_screen">Run</span> on a codeunit line also does the same on all the function lines it entails.</p>
<p>The test tool extension empowers you to select the <span class="packt_screen">Run</span> field on the following:</p>
<ul>
<li>All tests</li>
<li>Only failing tests and thus disabling all others</li>
<li>On none-failing tests, thus disabling failing tests</li>
</ul>
<p>And, as a fourth option to deselect all tests.</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-780 image-border" src="assets/a3c88a8e-206a-46c9-9469-de2e46a00890.png" style="width:81.42em;height:43.08em;"/></p>
<p>The following four actions have been added as seen in the preceding screenshot:</p>
<ul>
<li><span class="packt_screen">Select on All</span></li>
<li><span class="packt_screen">Deselect on All</span></li>
<li><span class="packt_screen">Select on Failures</span></li>
<li><span class="packt_screen">Select on None Failures</span></li>
</ul>
<p>Hence, when using <span class="packt_screen">Select on Failures</span>, all failing tests will have <span class="packt_screen">Run</span> checked, while all other tests will have it unchecked <span>as shown in the following screenshot</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-781 image-border" src="assets/f495a77e-1f0e-433b-94fc-8bcb073ee320.png" style="width:81.25em;height:43.17em;"/></p>
<p>The already existing features, such as TCM and the four actions extending the test tool, let you easily shift out the tests that help fix issues and enlarge the test collateral that you are building up.</p>
<div class="packt_infobox">
<p>The source of the test tool extension can be downloaded for this GitHub repository: <a href="https://github.com/fluxxus-nl/Test-Tool-Extension" target="_blank">https://github.com/fluxxus-nl/Test-Tool-Extension</a><a href="https://github.com/fluxxus-nl/Test-Tool-Extension" target="_blank"/></p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating with daily build</h1>
                </header>
            
            <article>
                
<p>Where software development is about building applications that link and automate business processes, modern software development adds this to its own processes as follows:</p>
<ul>
<li>Sharing code in source code repositories that can be accessed and managed through APIs from anywhere</li>
<li>Building your software from scratch at any time automatically</li>
<li>Running an automated test run, triggered by the completed build, to show the validity of the rebuild software</li>
<li>Deploying a build approved by the automated tests is automatic on a scheduled time</li>
<li>Collecting all the results and statuses of the foregoing processes on a dashboard to inform the stakeholders about the sanity of the software</li>
</ul>
<p>Contemporary development tools, such as Microsoft Azure DevOps, enable you to achieve this. The following screenshot shows a Azure DevOps dashboard integrating all of the preceding bullet points.</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-783 image-border" src="assets/bb4cd346-44c3-4db9-892d-5f7c23b115ac.png" style="width:114.50em;height:58.00em;"/></p>
<p>This is the world we are moving in with Dynamics 365 Business Central, induced by the arguments discussed in <a href="7b51635c-cd1c-4124-be24-c2597e6d7986.xhtml" target="_blank">Chapter 1</a>, <em>Introduction to Automated Testing</em>. Not in the least the requirements Microsoft is setting for us, and please, do not underestimate the ecosystem our customers are living in today, where they hear about scheduled builds, automated test runs and shorter release cycles than ever before.</p>
<p><strong>Continuous Integration</strong> (<strong>CI</strong>) and <strong>Continuous Delivery</strong> (<strong>CD</strong>) might have seemed something far out for Business Central development, but with the move to AL and extension development, it’s just around the corner. Automated tests are making up an essential part of this.</p>
<p>Where in the last decade, only a small number of Business Central development partners were putting effort in automating their development processes, more and more are picking up right now; and since a short while the Microsoft Dynamics 365 Business Central development team is openly advocating this too.</p>
<div class="packt_infobox">Read the blog post series by FreddyDK (Freddy D. Kristiansen) of Microsoft on CI/CD: <a href="https://community.dynamics.com/business/b/freddysblog/archive/tags/Continuous+Integration">https://community.dynamics.com/business/b/freddysblog/archive/tags/Continuous+Integration</a>. <br/>
But also follow guys like Gunnar Gestsson: <a href="https://community.dynamics.com/business/b/freddysblog/archive/tags/Continuous+Integration">(</a><a href="https://dynamics.is/">https://dynamics.is/</a><a href="https://community.dynamics.com/business/b/freddysblog/archive/tags/Continuous+Integration">),</a> Kamil Sáček: <a href="https://community.dynamics.com/business/b/freddysblog/archive/tags/Continuous+Integration">(</a><a href="https://dynamicsuser.net/nav/b/kine">https://dynamicsuser.net/nav/b/kine</a><a href="https://community.dynamics.com/business/b/freddysblog/archive/tags/Continuous+Integration">), </a>James Pearson: <a href="https://community.dynamics.com/business/b/freddysblog/archive/tags/Continuous+Integration">(</a><a href="https://jpearson.blog/">https://jpearson.blog/)</a><a href="https://community.dynamics.com/business/b/freddysblog/archive/tags/Continuous+Integration">,</a> Richard Robberse: <a href="https://community.dynamics.com/business/b/freddysblog/archive/tags/Continuous+Integration">(</a><a href="http://robberse-it-services.nl/blog/">http://robberse-it-services.nl/blog/</a><a href="https://community.dynamics.com/business/b/freddysblog/archive/tags/Continuous+Integration">), </a>and Michael Glue:<a href="https://community.dynamics.com/business/b/freddysblog/archive/tags/Continuous+Integration"> (</a><a href="https://navbitsbytes.com/">https://navbitsbytes.com/</a><a href="https://community.dynamics.com/business/b/freddysblog/archive/tags/Continuous+Integration">)</a></div>
<div>
<p>Be that as it may, you do not need to wait for a fully operational automated CI/CD pipeline to get the most out of your automated tests. With a simple PowerShell script triggered by a good old Windows task, you have your tests running on your application at any scheduled time. Before we started implementing our CI/CD pipeline on Azure DevOps, this was exactly what we had been doing for a couple of years. This allowed us to execute 18,000 plus automated tests every night with a resulting test report email to the team the next morning informing us on the sanity of our code. A drop in the success rate of the test run, occasionally happening, notified us that some unintended breaking changes had been added to our application and appropriate actions were needed.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Maintaining your test code</h1>
                </header>
            
            <article>
                
<p>Like application code, test code is code, so handle it as application code should be handled, for example:</p>
<ul>
<li>It needs to be secured, ideally by means of a source code management tool</li>
<li>It needs to be maintained and as any new customer wish will result in a change of the application code, it will most likely also change the test code</li>
<li>It needs to be debugged, whether you like it or not, as any coding done by a developer potentially inserts new bugs</li>
<li>It needs to be reviewed to assure that, like application code, it meets the coding standards</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extensions and tests</h1>
                </header>
            
            <article>
                
<p>Before we conclude this chapter, a note must be made on how to organize your extension code with respect to application and test code.</p>
<p>If we take the most restrictive requirement for extensions, being the ones Microsoft has set up for approving your extensions for release to AppSource, application and test code should be placed in separate extensions. I guess you might have already thought that the test extensions should have a dependency on the application extension. This unfortunately frustrates a parallel development of application and test code, since any change to the application extension results in a redeployment of it. This potentially also results in an update and redeployment of the test extension. Before you realize, you are juggling continuously with your extensions, taking the speed out of the development team. The best way to go about this, while developing, is to have application and test code placed in the same extension. Once ready, you can split up the code and create the two mandatory extensions by means of some automated (build) script or a specific merging strategy.</p>
<p>In case your extension is not to be put on AppSource, I would still strongly advise you to not release the test code in the application extension. This is for the same reason that standard <kbd>CRONUS</kbd> does not contain the standard test helper libraries and test codeunits: to prevent in whatever way that automated tests are run in a production environment. Sure, if test codeunits are run within the isolation of a test runner, no changes to the data will sustain, and the worst that can happen is that users will bump into locks, not the least on the <kbd>Object</kbd> table. But what if a test codeunit accidentally runs outside the isolation of a test runner and commits become real commits? Your client might think they’re having a great day with an outstanding turnover. But soon it will return on them when payments are not fulfilled and goods are <em>returned to sender</em> as addresses are unknown.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we paid attention to a number of best practices on how to embed test automation in your daily development practice. Get your functional peers writing ATDD scenarios to make use of the Excel sheet discussed. Do not overload yourself and your team and take small steps. Use the test tool next to your development tools and keep the tests running. Automate your development processes including running your tests. And last but not least, test code is code, so maintain it as you maintain your application code.</p>
<p>We’re on the verge of the last chapter, <a href="795b3870-b6f5-43be-953c-0ffd01db9102.xhtml" target="_blank">Chapter 9</a>, <em>Getting</em> <em>Business Central</em> <em>Standard Tests Working on Your Code</em>, in which we will have a closer look at the tests provided by Microsoft and how we could also integrate this humongous collateral of standard tests.</p>


            </article>

            
        </section>
    </body></html>