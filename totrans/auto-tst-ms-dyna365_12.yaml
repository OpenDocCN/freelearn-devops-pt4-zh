- en: How to Integrate Test Automation in Daily Development Practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've got this far into this book, so by now you have a clear notion on the
    needs for and benefits of test automation for Dynamics 365 Business Central. You
    have also already exercised designing and writing tests based on [Section 3](13a9d0b2-ae46-45ba-8790-8489439e70fc.xhtml),
    *Designing and Building Automated Tests for* *Microsoft Dynamics 365 Business
    Central*. The next step is to bring into practice what you have learned.
  prefs: []
  type: TYPE_NORMAL
- en: 'But from reading the book, and understanding the matters discussed, and working
    on your first exercises, making it part of your daily work might still be a threshold
    to take. As mentioned earlier, test automation is a team effort. Therefore, in
    this chapter, we will elaborate on a number of best practices that might turn
    out to be beneficial for you and your team in getting test automation working:'
  prefs: []
  type: TYPE_NORMAL
- en: Casting the customer wish into ATDD scenarios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking small steps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the test tool your friend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating with daily build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining your test code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting the customer wish into ATDD scenarios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Crucial to getting test automation into your daily development practices is
    the adoption of it by the team. Like requirements and application code, tests
    and test code should be owned by the development team; not just formally, but
    also actively. Good application code does not emerge from a single-lined customer
    wish, it derives from a well detailed and formalized customer wish. And the same
    applies to tests and test code.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [Chapter 4](db955f66-11f4-4d9a-90c7-5af04058ebbe.xhtml), *Test
    Design*, formalize your requirements by using the ATDD design pattern. Cast your
    customer wish in ATDD scenarios. Break down each wish into a list of tests, and make
    this your primary vehicle of communication for (1) detailing of your **customer
    wish**, (2) implementation of your **application code**, (3) structured execution
    of your **manual tests**, (4) coding of your **test automation** and (5) up-to-date
    **documentation** of your solution. Your test automation will be a logical result
    of all previous work.
  prefs: []
  type: TYPE_NORMAL
- en: 'As developers are the ones that will be doing both the application and tests
    coding, and in general are not the ones that understand the customer wish the
    best, ATDD scenarios already hit *two out of five birds in one stroke*. Make use
    of my ATDD Scenarios Excel sheet on GitHub, called `Clean sheet.xlsx`*,* to get
    your team to start casting customer wishes into ATDD scenarios. It''s exactly
    what I did when working on the test examples in [Chapter 5](56634efe-664c-421a-9582-b2a6ae69722a.xhtml) through
    [Chapter 7](bb9ee41e-4c60-4a27-8fad-5343adfcd86a.xhtml). See the below screenshot
    for impression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad9d2554-1e1c-4f85-b5f6-0676c5d50266.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first seven columns are for the product owners, functional consultants,
    and key users to fill in:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Feature`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sub Feature`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UI`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Scenario`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Given-When-Then (Tag)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Given-When-Then (Description)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Scenario #`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last two columns, `ATDD Format` and `Code Format`, are automatically populated
    as seen in the following screenshot. See that the latter column contains *the
    green*, that is, the formatted and already out-commented `GIVEN`-`WHEN`-`THEN`
    scenarios. These are ready to be copied and pasted into your test codeunit, and
    embedded into your test functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Currently, Jan Hoek and I are working to get this a step further. Have a look
    at our `ATDD.TestScriptor` that will, given an ATDD defined feature, construct
    the skeleton of the associated `.al` test codeunit: [http://powershellgallery.com/packages/ATDD.TestScriptor](http://powershellgallery.com/packages/ATDD.TestScriptor).
  prefs: []
  type: TYPE_NORMAL
- en: Taking small steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the saying goes, *Rome wasn’t built in a day*. Likewise, get to master test
    automation one step at a time. Learn and improve by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Start casting the customer wish into the scenarios that come to mind. Try to
    keep it simple. Preferably, you would like to get a full coverage right away,
    but as it is a team effort, they will help you to identify the holes, and fill
    them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Make use of my *4-steps* recipe, *create*, *embed*, *write*, and *construct*,
    for the conception of the test code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1\. Create a test codeunit
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Embed the customer wish into a test function
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Write your test story
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Construct the real code
  prefs: []
  type: TYPE_NORMAL
- en: Get the test(s) run with every step performed, and as soon as the code is deployable.
    Do not wait until you’re finished, but verify your effort as soon as possible.
    See how your tests move from **red** to **green**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take joy in *testing the test* as a last small step in completing it. Either
    verify the data created or, often much easier, adjust the test so the verification
    errs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement one scenario after the other and find yourself duplicating code parts.
    Do not force yourself into directly abstracting them into helper methods in libraries.
    This can wait until the application and test code are ready and refactoring can
    start.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the tests regularly, once the application code and tests are in and when
    a next update to the feature is made. While implementing, do not wait till the
    code is ready, verify each atomic change by running the tests, and add new tests
    for the new and updated scenarios.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The aforementioned `ATDD.TestScriptor` will handle *Step 1* through *Step 3*
    of my 4-steps recipe for you.
  prefs: []
  type: TYPE_NORMAL
- en: Making the test tool your friend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](fdf2b65f-be7c-4710-a3a9-39f4cc34ee5c.xhtml), *The Test Tool and
    Standard Tests*, we introduced you to the test tool and we used it frequently
    during the work we did on the test examples. We applied it to *test the test*
    after having inserted a bug to let the *verification error*. Next to VS Code,
    your coding tool, and debugger, the test tool is your best friend. Keep it running
    while you develop, "*do not wait till the code is ready, verify each atomic change
    by running the tests*", as mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: Create a specific test suite to hold the test codeunits that relate to the code
    you are working on. In most of your projects, it’s very likely, as with the `LookupValue`
    extension, that you end up with a bunch of test codeunits that will be executed
    within less than a minute. While working on a new test codeunit, create a new
    test suite to only hold that codeunit and repeatedly carry it out till coding
    is done.
  prefs: []
  type: TYPE_NORMAL
- en: Test coverage map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The test tool also holds a powerful feature we haven’t mentioned so far and
    can be of great help in picking out relevant test codeunits for the code update
    you are working on. It is called **Test Coverage Map** (**TCM**). It combines
    the result of the code coverage tool that also resides in Business Central and
    the test tool. Having TCM turned on, it adds two extra options to the Get Test
    Codeunits feature already demoed in [Chapter 3](fdf2b65f-be7c-4710-a3a9-39f4cc34ee5c.xhtml),
    *The Test Tool and Standard Tests*. There, we explained that Get Test Codeunits
    offers the following two options to let you populate your test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: Select Test Codeunits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All Test Codeunits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With TCM, two more options are added.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the third option, *Get Test Codeunits based on Modified Objects*, will
    select those test codeunits that will hit the application objects you are working
    on. The fourth option, *Get Test Codeunits based on Selected Objects*, let’s you
    select from a list those application objects you want to run tests against.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c52bbc5-3d31-45ed-8298-ad590f3b2aae.png)'
  prefs: []
  type: TYPE_IMG
- en: At this very moment, the *Get Test Codeunits based on Modified Objects* option
    only takes into account the application objects that reside in standard, that
    is, in C/SIDE. Unfortunately, it does not yet consider objects that reside in
    extensions.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth option, *Get Test Codeunits based on Selected Objects*, nevertheless
    includes all application objects.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to use TCM, you need to turn it on. To do this, check mark the Update
    Test Coverage Map field on a test suite. If this has not been turned on, on any
    test suite, TCM will not have data to allow you to choose Get Test Codeunits based
    on Modified Objects and Get Test Codeunits based on Selected Objects options as
    described previously.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c996815-62af-4afe-adcd-0f369cc4edeb.png)'
  prefs: []
  type: TYPE_IMG
- en: For TCM to have the data available to do its job, the activated test suite should
    be run first.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the test tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we started using the test tool more intensely years ago, there was one
    major omission that we decided to build a simple extension for. Once you have
    set up a test suite and run all the tests, you might end up having only a portion
    of the tests that passed successfully. And, logically, the other parts not passing.
  prefs: []
  type: TYPE_NORMAL
- en: While finding and fixing the cause of the failures, you presumably would only
    want to run the faulty ones. The standard test tool lets you only activate/deactivate
    by (un)checking the Run field of each individual function line. Checking/unchecking
    Run on a codeunit line also does the same on all the function lines it entails.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test tool extension empowers you to select the Run field on the following:'
  prefs: []
  type: TYPE_NORMAL
- en: All tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only failing tests and thus disabling all others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On none-failing tests, thus disabling failing tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And, as a fourth option to deselect all tests.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3c88a8e-206a-46c9-9469-de2e46a00890.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following four actions have been added as seen in the preceding screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: Select on All
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deselect on All
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select on Failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select on None Failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hence, when using Select on Failures, all failing tests will have Run checked,
    while all other tests will have it unchecked as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f495a77e-1f0e-433b-94fc-8bcb073ee320.png)'
  prefs: []
  type: TYPE_IMG
- en: The already existing features, such as TCM and the four actions extending the
    test tool, let you easily shift out the tests that help fix issues and enlarge
    the test collateral that you are building up.
  prefs: []
  type: TYPE_NORMAL
- en: The source of the test tool extension can be downloaded for this GitHub repository: [https://github.com/fluxxus-nl/Test-Tool-Extension](https://github.com/fluxxus-nl/Test-Tool-Extension)
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with daily build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Where software development is about building applications that link and automate
    business processes, modern software development adds this to its own processes
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Sharing code in source code repositories that can be accessed and managed through
    APIs from anywhere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your software from scratch at any time automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running an automated test run, triggered by the completed build, to show the
    validity of the rebuild software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a build approved by the automated tests is automatic on a scheduled
    time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting all the results and statuses of the foregoing processes on a dashboard
    to inform the stakeholders about the sanity of the software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contemporary development tools, such as Microsoft Azure DevOps, enable you to
    achieve this. The following screenshot shows a Azure DevOps dashboard integrating
    all of the preceding bullet points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb4cd346-44c3-4db9-892d-5f7c23b115ac.png)'
  prefs: []
  type: TYPE_IMG
- en: This is the world we are moving in with Dynamics 365 Business Central, induced
    by the arguments discussed in [Chapter 1](7b51635c-cd1c-4124-be24-c2597e6d7986.xhtml),
    *Introduction to Automated Testing*. Not in the least the requirements Microsoft
    is setting for us, and please, do not underestimate the ecosystem our customers
    are living in today, where they hear about scheduled builds, automated test runs
    and shorter release cycles than ever before.
  prefs: []
  type: TYPE_NORMAL
- en: '**Continuous Integration** (**CI**) and **Continuous Delivery** (**CD**) might
    have seemed something far out for Business Central development, but with the move
    to AL and extension development, it’s just around the corner. Automated tests
    are making up an essential part of this.'
  prefs: []
  type: TYPE_NORMAL
- en: Where in the last decade, only a small number of Business Central development
    partners were putting effort in automating their development processes, more and
    more are picking up right now; and since a short while the Microsoft Dynamics
    365 Business Central development team is openly advocating this too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read the blog post series by FreddyDK (Freddy D. Kristiansen) of Microsoft
    on CI/CD: [https://community.dynamics.com/business/b/freddysblog/archive/tags/Continuous+Integration](https://community.dynamics.com/business/b/freddysblog/archive/tags/Continuous+Integration).'
  prefs: []
  type: TYPE_NORMAL
- en: But also follow guys like Gunnar Gestsson: [(](https://community.dynamics.com/business/b/freddysblog/archive/tags/Continuous+Integration)[https://dynamics.is/](https://dynamics.is/)[),](https://community.dynamics.com/business/b/freddysblog/archive/tags/Continuous+Integration)
    Kamil Sáček: [(](https://community.dynamics.com/business/b/freddysblog/archive/tags/Continuous+Integration)[https://dynamicsuser.net/nav/b/kine](https://dynamicsuser.net/nav/b/kine)[), ](https://community.dynamics.com/business/b/freddysblog/archive/tags/Continuous+Integration)James
    Pearson: [(](https://community.dynamics.com/business/b/freddysblog/archive/tags/Continuous+Integration)[https://jpearson.blog/)](https://jpearson.blog/)[,](https://community.dynamics.com/business/b/freddysblog/archive/tags/Continuous+Integration)
    Richard Robberse: [(](https://community.dynamics.com/business/b/freddysblog/archive/tags/Continuous+Integration)[http://robberse-it-services.nl/blog/](http://robberse-it-services.nl/blog/)[), ](https://community.dynamics.com/business/b/freddysblog/archive/tags/Continuous+Integration)and
    Michael Glue:[ (](https://community.dynamics.com/business/b/freddysblog/archive/tags/Continuous+Integration)[https://navbitsbytes.com/](https://navbitsbytes.com/)[)](https://community.dynamics.com/business/b/freddysblog/archive/tags/Continuous+Integration)
  prefs: []
  type: TYPE_NORMAL
- en: Be that as it may, you do not need to wait for a fully operational automated
    CI/CD pipeline to get the most out of your automated tests. With a simple PowerShell
    script triggered by a good old Windows task, you have your tests running on your
    application at any scheduled time. Before we started implementing our CI/CD pipeline
    on Azure DevOps, this was exactly what we had been doing for a couple of years.
    This allowed us to execute 18,000 plus automated tests every night with a resulting
    test report email to the team the next morning informing us on the sanity of our
    code. A drop in the success rate of the test run, occasionally happening, notified
    us that some unintended breaking changes had been added to our application and
    appropriate actions were needed.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining your test code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like application code, test code is code, so handle it as application code
    should be handled, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: It needs to be secured, ideally by means of a source code management tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It needs to be maintained and as any new customer wish will result in a change
    of the application code, it will most likely also change the test code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It needs to be debugged, whether you like it or not, as any coding done by a
    developer potentially inserts new bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It needs to be reviewed to assure that, like application code, it meets the
    coding standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensions and tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we conclude this chapter, a note must be made on how to organize your
    extension code with respect to application and test code.
  prefs: []
  type: TYPE_NORMAL
- en: If we take the most restrictive requirement for extensions, being the ones Microsoft
    has set up for approving your extensions for release to AppSource, application
    and test code should be placed in separate extensions. I guess you might have
    already thought that the test extensions should have a dependency on the application
    extension. This unfortunately frustrates a parallel development of application
    and test code, since any change to the application extension results in a redeployment
    of it. This potentially also results in an update and redeployment of the test
    extension. Before you realize, you are juggling continuously with your extensions,
    taking the speed out of the development team. The best way to go about this, while
    developing, is to have application and test code placed in the same extension.
    Once ready, you can split up the code and create the two mandatory extensions
    by means of some automated (build) script or a specific merging strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case your extension is not to be put on AppSource, I would still strongly
    advise you to not release the test code in the application extension. This is
    for the same reason that standard `CRONUS` does not contain the standard test
    helper libraries and test codeunits: to prevent in whatever way that automated
    tests are run in a production environment. Sure, if test codeunits are run within
    the isolation of a test runner, no changes to the data will sustain, and the worst
    that can happen is that users will bump into locks, not the least on the `Object`
    table. But what if a test codeunit accidentally runs outside the isolation of
    a test runner and commits become real commits? Your client might think they’re
    having a great day with an outstanding turnover. But soon it will return on them
    when payments are not fulfilled and goods are *returned to sender* as addresses
    are unknown.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we paid attention to a number of best practices on how to embed
    test automation in your daily development practice. Get your functional peers
    writing ATDD scenarios to make use of the Excel sheet discussed. Do not overload
    yourself and your team and take small steps. Use the test tool next to your development
    tools and keep the tests running. Automate your development processes including
    running your tests. And last but not least, test code is code, so maintain it
    as you maintain your application code.
  prefs: []
  type: TYPE_NORMAL
- en: We’re on the verge of the last chapter, [Chapter 9](795b3870-b6f5-43be-953c-0ffd01db9102.xhtml), *Getting*
    *Business Central* *Standard Tests Working on Your Code*, in which we will have
    a closer look at the tests provided by Microsoft and how we could also integrate
    this humongous collateral of standard tests.
  prefs: []
  type: TYPE_NORMAL
