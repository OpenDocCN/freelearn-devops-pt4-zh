<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Test-Driven Development</h1>
                </header>
            
            <article>
                
<p>As the title of this appendix tells us, we will be talking about <strong>Test-Driven Development</strong> (<strong>TDD</strong>), a term we haven't used anywhere in this book so far. I deliberately chose not to. Why? Because I wanted us to focus on the following topics that I wanted to discuss in this book:</p>
<ul>
<li>Why we should use automated tests</li>
<li>When to use automated tests</li>
<li>How to write automated tests</li>
</ul>
<p>I didn't want anyone getting blocked by their knowledge of TDD, with it being a proven methodology, but also surrounded with skepticism. It makes <span>sense,</span><span> however,</span><span> </span><span>to pay some attention to it, as there are a number of practical parts of TDD that are worth drawing attention to. Hence, this appendix will not fully expose what TDD is. Rather, it will be a condensed description with annotations that point out parts that can be of value to your daily development practices.</span></p>
<p>In this appendix, we will discuss the following topics:</p>
<ul>
<li>A short description of TDD</li>
<li>The so-called red-green-refactor mantra as the way to implement code</li>
<li>How close our test examples were to TDD</li>
</ul>
<div class="packt_infobox">Indeed, we did use the term <strong>Acceptance Test-Driven Development</strong> (<strong>ATDD</strong>), which was introduced in <a href="fdf2b65f-be7c-4710-a3a9-39f4cc34ee5c.xhtml" target="_blank">Chapter 3</a>, <em>The Test Tool and Standard Tests</em>, which contains the word TDD, and we did adopt a part of ATDD, but it is not equal to the TDD methodology.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TDD, a short description</h1>
                </header>
            
            <article>
                
<p class="mce-root">The shortest possible description of TDD is actually the term itself. It is self-containing. It is describing that, by using this as your methodology for your software application development, the development will be driven by tests. Tests need to be defined to drive the writing of your application code, and in this way, your tests are directly derived from the requirements. This is an often uttered one-liner to describe TDD in a nutshell:</p>
<div class="packt_quote">"No tests, no code."</div>
<p>The ultimate consequence of this is that you will never build application code that does not have tests to it. And, as the tests are one-to-one related to the requirements, your application code should not have any undocumented features.</p>
<p>But this description is actually not the basic definition of TDD. TDD is defined only by<span> the following two rules, and everything else is deduced from that:</span></p>
<ul>
<li>Never write a single line of code unless you have a failing automated test</li>
<li>Eliminate duplication</li>
</ul>
<p>The <em>no tests, no code</em> one-liner is a direct result of these two rules. The following are the actionable steps derived from these rules:</p>
<ol>
<li>Transform requirements to code by defining the tests, a so-called <strong>test list</strong></li>
<li>Code one test at a time and write application code against it only to make the test pass</li>
<li>Refactor the code, both test and application, to clean up and eliminate duplication; the rerun of the test ensures that refactored code is still valid</li>
</ol>
<p>The great gain you will accomplish by bringing this into your daily practice is that you will end up with code that has been tested already, you only implement what is required, and you have accompanying test collateral that allows you to run and check the sanity of the application code.</p>
<div class="packt_infobox">
<p>If you want to read more on TDD, read the series I wrote years ago on TDD on my blog at: <a href="https://dynamicsuser.net/nav/b/vanvugt/posts/test-driven-development-in-nav-intro">https://dynamicsuser.net/nav/b/vanvugt/posts/test-driven-development-in-nav-intro</a>, there you will also find a number of useful references.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TDD, red-green-refactor</h1>
                </header>
            
            <article>
                
<p>Given a test list, the <em>actionable steps</em> are described by what has become the <em>red-green-refactor</em> mantra. Where red and green respectively refer to a failing (red) and succeeding (green) test, this <em>mantra</em> tells you to take the following steps:</p>
<ol>
<li>Take a test from the list and write the test code</li>
<li>Compile the test code yielding <strong>red</strong> as the application code that is not yet there</li>
<li>Implement <em>just enough</em> application code to make the test code compile</li>
<li>Run the test seeing it probably fail, still <strong>red</strong></li>
<li>Adjust the application code <em>just enough</em> to make it pass, that is, <strong>green</strong></li>
</ol>
<ol start="6">
<li><strong>Refactor</strong> your code, either test or application code or both, one after the other, and rerun the test after each change to prove all code is still well (green)</li>
<li>Move to the next test on the list and repeat from <em>Step 1</em></li>
</ol>
<p>The <em>red-green-refactor</em> mantra urges you to get things done step by step and as efficiently, that is, as minimalistic as possible. Only implement what is needed and one thing at a time. Taking this mantra seriously, your first test might end up being of a somewhat ridiculous level. Given that the test list has sufficient details, that is, consist of an adequate number of tests, implementing the next test will bring more detail to your code.</p>
<div class="packt_infobox">If you need an example of the <em>red-green-refactor</em> mantra in action, this can be found at: <a href="https://dynamicsuser.net/nav/b/vanvugt/posts/test-driven-development-in-nav-test-1">https://dynamicsuser.net/nav/b/vanvugt/posts/test-driven-development-in-nav-test-1</a><a href="https://dynamicsuser.net/nav/b/vanvugt/posts/test-driven-development-in-nav-test-1"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TDD and our test examples</h1>
                </header>
            
            <article>
                
<p>What if we applied TDD to our test examples in <a href="13a9d0b2-ae46-45ba-8790-8489439e70fc.xhtml" target="_blank">Section 3</a>, <em>Designing and Building Automated Tests for Microsoft Dynamics 365 Business Central</em>?</p>
<p>To be honest, it wouldn't have looked much different, as a lot of the TDD principles were implicitly exercised as follows:</p>
<ul>
<li>By defining our customer wishes by means of the ATDD scenarios, we created ourselves a sufficient set of tests, that is, a test list</li>
<li>By implementing our tests with the four steps recipe, we did the following:
<ol>
<li>We took small steps</li>
<li>We created a structure for each test based on the <kbd>GIVEN</kbd>-<kbd>WHEN</kbd>-<kbd>THEN</kbd> tags</li>
<li>We constructed the real code to get it to work</li>
<li>We ran the test, and if <strong>red</strong>, we adjusted the code till the test passed, that is <strong>green</strong></li>
</ol>
</li>
<li>And even though not worked out in the test examples as such, as discussed at the end of <a href="bb9ee41e-4c60-4a27-8fad-5343adfcd86a.xhtml" target="_blank">Chapter 7</a>, <em>From Customer Wish to Test Automation - And Some More</em>, I did refactor the code to get reusable parts and profit a lot from the automated tests I had available</li>
</ul>
<p>The only deviation from TDD is that application code was conceived before we started working on the test code. By the way, that's also how I prepared the <kbd>LookupValue</kbd> extension for this book.</p>
<p>The conclusion from this is, in my humble opinion, you can perfectly use TDD for Business Central. The biggest challenge is to get your team disciplined to spec the customer wish in ATDD scenarios. Note that the following describes the simplest way to start exercising this for bugs:</p>
<ul>
<li>Get the bug described in ATDD format:
<ul>
<li>In a way, this is not far off from what you do when reproducing the bug</li>
<li>Note that the ATDD scenario is describing how the feature is expected to work</li>
</ul>
</li>
<li>Based on the ATDD scenario(s), you build the test code</li>
<li>Running the test(s) should lead to red, as the bug is still there</li>
<li>Fix the application code to make the test pass: green</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Wrapping up this appendix, I would point out that the value of TDD is that it shows that it makes a lot of sense to do you work in small steps, define tests before coding (ATDD), and take one step at a time obeying the red-green-refactor rule.</p>


            </article>

            
        </section>
    </body></html>