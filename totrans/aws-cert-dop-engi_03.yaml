- en: 'Chapter 2: Fundamental AWS Services'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an understanding of the service principles and pillars that
    make up the best practices when using **Amazon Web Services** (**AWS**), it's
    time to look at some of the fundamental services that are used throughout the
    environments and accounts you will be working in. The fundamental services that
    we are referring to are compute services such as **Elastic Cloud Compute** (**EC2**),
    the global **Domain Name System** (**DNS**) service of **Route 53**, database
    services such as **RDS** and **Aurora**, and the advisory service of Trusted Advisor.
    This may seem like a review of services you are already familiar with if you have
    taken either the cloud practitioner, SysOps, or developer exams. However, since
    there is no longer a requirement to pass any of the lower associate exams before
    attempting (and passing) the DevOps professional test, it's not a bad idea to
    level-set on some of the basic services.
  prefs: []
  type: TYPE_NORMAL
- en: This is not meant to be an exhaustive look at these services. The services mentioned
    will be brought into the context of the DevOps exam, so skipping over this chapter
    is not advised. However, if you feel that you have a strong grasp of the topics
    mentioned, then verify this by checking the review questions, along with the reference
    material. Likewise, you can review any topics that you feel that you already have
    a strong grasp of.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up and accessing your AWS account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual Private Cloud networking and Route 53 networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message and queueing systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trusted Advisor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need an AWS account to access the Management Console and CLI, which
    will be mentioned in the initial part of this chapter. If you need assistance
    with creating your account, then the [https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/](https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/)
    page will walk you through the steps of creating a new account. Basic knowledge
    of how to use a terminal to complete the shell commands is also required.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will not be going over the geography, regions, Availability
    Zones, or edge locations of AWS. These are basic concepts that you should have
    a firm grasp of before attempting the DevOps exam.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up and accessing your AWS account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you most likely have an AWS account to work with; nevertheless,
    you may only have access through your workplace, where some of the permissions
    are restricted, so you would not be able to practice all of the skills that you
    need to feel confident in passing the DevOps professional exam.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't already have a personal account for testing things, then this would
    be the perfect time to set one up. Even if you do have an account, you may want
    to take the time to set up a new account just for the exam to ensure that you
    are allowed to take advantage of the free tier (allocated for your first year
    in AWS) on a number of the provided services.
  prefs: []
  type: TYPE_NORMAL
- en: If you do already have an account, making the switch to **AWS Organizations**,
    especially using Control Tower, is an excellent exercise if you wish to create
    service control policies, organizational units, **Single Sign-On** (**SSO**),
    and cross-account roles.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Control Tower takes a minimum of three distinct email accounts to get started
    for the three separate accounts that are created.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have created your master account, you can send an invitation to the
    previous account that you created and allow it to join the organization.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the AWS Management Console
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The AWS Management Console is the front door (GUI) to accessing your AWS account.
  prefs: []
  type: TYPE_NORMAL
- en: Start by opening any web browser and going to [https://aws.amazon.com/](https://aws.amazon.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'On the start page, look for the **My Account** menu item. Hovering over this
    menu should give you the option of choosing **AWS Management Console**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Accessing the AWS Management Console'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.1_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – Accessing the AWS Management Console
  prefs: []
  type: TYPE_NORMAL
- en: 'When following the link to log into AWS, so long as you are not going through
    an SSO portal, you will be presented with three fields: **Account ID or account
    alias**, **IAM user name**, and **Password**. Initially, when creating your account,
    you will only have the long account number to use, and this only has context to
    AWS. It is a good practice to create an account alias, enabling you to quickly
    associate the account ID with a logical name for the account. This becomes especially
    handy when adding multi-factor authentication to your accounts and seeing that
    logical names bring much more context than multiple rows of numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have logged in, you can search for services, change regions, designate
    favorite services for quick access, and open support requests. If you have the
    correct permissions, you can also access the billing console.
  prefs: []
  type: TYPE_NORMAL
- en: As an initial step, to perform the exercises, we need to create a user, associate
    that user with a role containing permissions, and then create a set of keys that
    we will download and use later when we configure the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have logged into the AWS Management Console, follow these steps to
    create your user and a set of access keys:'
  prefs: []
  type: TYPE_NORMAL
- en: In the top search bar, type `IAM`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **IAM** service; you will be taken to the IAM dashboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the left-hand navigation column, click on **Users**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you are in the user menu, click on the blue button at the top of the main
    screen, which is labeled **Add user**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the username, you can choose anything, but for our user, we are going to
    name them `devops`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are going to enter a custom password in the field that meets our password
    requirements and leave the box that is labeled **Require password reset** unchecked:![Figure
    2.2 – Creating our user
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_2.2_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 2.2 – Creating our user
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can then click **Next** to move on to the permissions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Set permissions**, we want to choose **Attach existing policies** **directly**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For this initial user, we are going to use the **AdministratorAccess** job
    function policy. Select this policy so that the box on the left is checked, and
    then click the button at the bottom that says **Next: Tags**:![Figure 2.3 – Attaching
    the policy'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_2.3_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 2.3 – Attaching the policy
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Just click the button at the bottom that says **Next: Review**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If everything looks correct, click the blue button that is labeled **Create
    User**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because we said that we wanted programmatic access, once we have created our
    user, we will be given the opportunity to both see the secret access key and download
    the access key and secret key pair in a CSV file. Take note of your secret key
    for this user or download the file as this will be the only time that the secret
    access key will be available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With that, we have set up our first user, along with their access policy, password,
    access key, and secret key. We will be referencing this user throughout other
    exercises in this book. You are free to set up any username you are comfortable
    with but for an administrative user account that is not using the root account,
    we will be using the *devops* user.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up and using the AWS CLI v2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can indeed perform most tasks using the graphical web-based interface of
    the Management Console. As a DevOps engineer, you will want to automate items
    in your environment, and the CLI gives you the power, via a set of scripting abilities,
    to do this. The CLI is one of the favorite tools of many for both its speed and
    powerful capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Note for Previous CLI v1 Users
  prefs: []
  type: TYPE_NORMAL
- en: If you have previously installed the AWS CLI v1, then it is strongly recommended
    that you uninstall v1 *before* installing CLI v2\. Both CLI commands use the same
    command name of `aws`. If you do not want to uninstall CLI v1, then you can put
    an alias in your path.
  prefs: []
  type: TYPE_NORMAL
- en: Mac setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So long as you have sudo privileges on your machine, you can easily install
    AWS CLI v2 on your Mac using the bundled installer:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a Terminal window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following two commands to install the AWS CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check that the correct version has been installed by running the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output should be similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So long as the number after `cli` starts with a `2`, you have successfully installed
    AWS CLI v2.
  prefs: []
  type: TYPE_NORMAL
- en: You can now skip to the Configuring the CLI section.
  prefs: []
  type: TYPE_NORMAL
- en: PC setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note for PC Users
  prefs: []
  type: TYPE_NORMAL
- en: To run CLI v2, you need to be running at least a 64-bit version of Windows XP
    or a later version of the Windows operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have administrative rights to install software on your machine, then
    you can follow these instructions to install AWS CLI v2:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the AWS CLI MSI installer for Windows: [https://awscli.amazonaws.com/AWSCLIV2.msi](https://awscli.amazonaws.com/AWSCLIV2.msi).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the downloaded MSI installer and follow the onscreen instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Confirm that the correct version has been installed by running the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Linux setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before installing CLI v2 on a Linux machine, there are a few prerequisites
    that must be taken care of first:'
  prefs: []
  type: TYPE_NORMAL
- en: You need the ability to unzip a package, either with the system `unzip` command
    or some other installed package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To have AWS CLI v2 run correctly, you need to make sure that the `glibc`, `groff`,
    and `less` packages are installed on your distribution. Most major distributions
    already have these packages installed by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS supports AWS CLI v2 on newer 64-bit versions of CentOS, Fedora, Ubuntu,
    Amazon Linux 1, and Amazon Linux 2\.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that the prerequisites have been met, you can use the following instructions
    to install the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following `curl` command to download the AWS CLI v2 ZIP file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that the ZIP file has been downloaded, we can unzip it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once unzipped, we can run the `install` program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check that the correct version has been installed by running the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output should be similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A reference to setting up the CLI from AWS can be found in their documentation
    at [https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have installed the CLI, it is a good idea to configure it. If you
    had the CLI v1 installed and had used profiles in the past, you should be able
    to use those same profiles going forward. To quickly configure your CLI, you can
    use the `aws configure` command; however, as a prerequisite, it's a good idea
    to have already created and downloaded a key and a secret key for your user from
    IAM. You will need this pair of credentials if you are configuring either your
    default profile or a secondary profile to use with the examples shown.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't already done so, log back into your AWS account via the Management
    Console and then navigate to the IAM service so that you can create yourself a
    user and role. Using this user, you can allocate an **access key ID** and **secret
    key ID** to input into the CLI that you can use for the tutorials in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have your key pair, follow these steps to configure your CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `aws configure` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When prompted, cut and paste the access key ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted, cut and paste the secret key ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted, set your default region (we will be using `us-east-2`) for the
    examples.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can just hit *Enter* to exit here and use the default JSON output; however,
    I find setting the output as a table is a lot more user-readable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For many of the examples you will see in this book, a *profile* will be added
    to the CLI commands.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud compute in AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we talk about compute in AWS, we are talking about several services, including
    Amazon EC2, Elastic Load Balancing, AWS Batch, Elastic Container Service, and
    Elastic Kubernetes Service, along with AWS Fargate, the managed service that allows
    you to run your containers with minimal overhead. It even includes Lightsail,
    which is one of the quickest ways to get up and running on the cloud for developers,
    with no need to configure software or networking:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Compute services in AWS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.4_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – Compute services in AWS
  prefs: []
  type: TYPE_NORMAL
- en: 'Although many services fall under the compute umbrella in AWS, the most foundational
    service is EC2\. This is your virtualized instance in the Amazon cloud. While
    other services, such as Elastic Container Service, Elastic Kubernetes Service,
    and even Elastic Beanstalk, can allow you to run containers in AWS, at their core,
    they are running on EC2 instances. Thus, knowing the foundational pieces of the
    EC2 service, such as how to select the correct instance type, how to use the optimal
    load balancer (as there are three to choose from), and how to add volumes to an
    instance, all become relative information, both when processing questions for
    the DevOps professional exam and in your day-to-day duties as a professional:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – EC2 in a real-world architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.5_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – EC2 in a real-world architecture
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we can see a real-life scenario where EC2 instances
    are being used in an Auto Scaling group to service the WebSphere platform. There
    are multiple EC2 instances in a private subnet that can only be accessed by an
    application load balancer that outside users see from a DNS entry in Route 53\.
    If internal users need to access any of the WebSphere servers, there is a bastion
    host that allows the SSH protocol in the public subnet. The bastion host is in
    an Auto Scaling group that spans both Availability Zones, but only one host is
    up at a time.
  prefs: []
  type: TYPE_NORMAL
- en: We will now take a closer look at some of these services, especially the EC2
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Elastic Cloud Compute (EC2)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Amazon EC2 allows you to create a virtual server to perform any number of tasks
    in the cloud. EC2 allows for a whole array of customization. There is a multitude
    of operating systems that you can use to meet your application needs. Appropriating
    the correct amount of memory and processing power is simply a matter of choosing
    the correct instance type based on the needs of your workload.
  prefs: []
  type: TYPE_NORMAL
- en: EC2 also has three different pricing models. Each allows you the flexibility
    or discounting to fit your needs. There are On-Demand Instances, Reserved Instances,
    and Spot Instances.
  prefs: []
  type: TYPE_NORMAL
- en: '**On-Demand Instances** are the default instance type and offer no long-term
    commitments when requesting an EC2 compute instance. You determine when you want
    to start, stop, hibernate, launch, or terminate the instance without any repercussions.
    From a pricing standpoint, you are only paying for On-Demand Instances per second
    while the instance is in the *running* state.'
  prefs: []
  type: TYPE_NORMAL
- en: If you have known workloads with EC2 that will be running constantly for a year
    or need a desired capacity in a certain Availability Zone, then **Reserved Instances**
    can provide cost savings, along with reserved capacity in that particular Availability
    Zone. There are two different term commitments available with Reserved Instances.
    These are known as 1 year and 3 years, with the latter establishing greater savings
    for longer-term commitments.
  prefs: []
  type: TYPE_NORMAL
- en: When AWS has extra capacity that isn't being utilized, then those instances
    are made available as **Spot Instances** at precipitous discounts. The supply
    and demand of different types of instances that are available makes the price
    fluctuate, sometimes rather rapidly. These savings can reach up to 80% off of
    the normal on-demand pricing; however, there are a few caveats that come along
    with it. First, you have to launch the instance immediately and you cannot stop
    or hibernate Spot Instances. When launching a Spot Instance, you will set a maximum
    price for what you are looking to spend, such as the current on-demand price,
    and if the price rises above the maximum price that you set, then AWS will send
    a signal and you will be given 2 minutes to save your work before the instance
    is terminated.
  prefs: []
  type: TYPE_NORMAL
- en: EC2 instance types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing, there are over 170 instance types that allow you to
    customize your compute needs for any type of workload that you would want to run
    into in the cloud. It's not important to try and memorize all the different types
    and sizes of the instances, along with their compute and memory specifications.
    However, it is a good idea to know the different categories that EC2 breaks down
    into for workload specificity and which EC2 families belong to those categories.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Only some EC2 instances allow enhanced networking and this can be a deciding
    factor when trying to choose the correct instance type. The enhanced networking
    feature can be especially important when dealing with troubleshooting or workloads
    as it supports higher bandwidth and higher packets per second.
  prefs: []
  type: TYPE_NORMAL
- en: Since there are many types of workloads moving to the cloud, each with its own
    specific needs, AWS has created several different EC2 instance families. Each
    of these families contains one or more instance types and has a preferred application
    profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'These instance families can be broken down into groupings, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: General-purpose instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute-optimized instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory-optimized instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accelerated computing instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage-optimized instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at these in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: General-purpose instances
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: General-purpose instances balance memory, compute, and network resources and
    are a good choice for an assortment of workloads. This includes the T class of
    instances, which have burstable credits that build up over time. General-purpose
    instances are a good starting point if you don't have a full classification of
    your workload.
  prefs: []
  type: TYPE_NORMAL
- en: '*Use cases*: Web servers, development and test servers, code repositories,
    small to mid-sized databases, and backend servers for SAP.'
  prefs: []
  type: TYPE_NORMAL
- en: Compute-optimized instances
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Compute-optimized instances are tailored for workloads that benefit from high-performance
    processors. The instances in this family also have the ability for enhanced networking
    pre-built in, along with being **Elastic Block Store** (**EBS**)-optimized by
    default.
  prefs: []
  type: TYPE_NORMAL
- en: '*Use cases*: Batch processing, video encoding, ad serving, distributed analytics,
    CPU-based machine learning, gaming, scientific modeling, and high-performance
    science and engineering applications such as genome analysis or computational
    fluid dynamics.'
  prefs: []
  type: TYPE_NORMAL
- en: Memory-optimized instances
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This family of instances is, as its name implies, designed for memory-intensive
    applications. They are designed to deliver fast performance capabilities on jobs
    that need lots of memory.
  prefs: []
  type: TYPE_NORMAL
- en: '*Use cases*: Open source databases, in-memory caches, and real-time analytics.'
  prefs: []
  type: TYPE_NORMAL
- en: Accelerated computing instances
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Accelerated computing instances contain co-processors or hardware accelerators
    that perform special functions much more efficiently than other processors. These
    functions can include data pattern matching, floating-point number calculations,
    and graphics processing.
  prefs: []
  type: TYPE_NORMAL
- en: '*Use cases*: Speech recognition, high-performance computing, drug discovery,
    computational finance, and autonomous vehicles.'
  prefs: []
  type: TYPE_NORMAL
- en: Storage-optimized instances
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Storage-optimized instances provide directly attached storage options that allow
    for specialized storage needs. This means that the instance storage can be optimized
    for very customized **input and output** (**I/O**) performance in the case of
    H1 instances or very high storage density in the case of **high storage** (**HS**)
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: '*Use cases*: NoSQL databases, data warehousing, Elasticsearch, in-memory databases,
    traditional databases, and analytics workloads.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instances are backed by two types of storage: **instance store** and EBS. When
    selecting an instance type, it will show whether the instance is backed by EBS
    or an instance store. There are some major differences between these two backing
    types, especially when it comes to persistence. One of the major advantages of
    an instance store is that it has high I/O and throughput. This comes from it being
    directly attached to the instance. The disadvantage of instance store-based volumes
    comes from persistence. If you restart an EC2 instance backed by an instance store,
    then you will lose all ephemeral data, such as logs and temporary files. This
    is not the case with EBS-based instances since the storage is not directly attached
    to the instance.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Amazon Machine Images (AMIs)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever you launch an EC2 instance, it must start from an **Amazon Machine
    Image** (**AMI**) so that it contains the required information to launch. These
    can be the base operating system images that are, for all intents and purposes,
    clean slates. Or they can be AMIs that you or some other entity has created as
    a valid checkpoint for a working system or systems running on a single instance.
  prefs: []
  type: TYPE_NORMAL
- en: AMIs can be provided by Amazon itself, your own user account, shared privately
    with your other accounts or from a partner account, created by a member from the
    community, or even available for free or for a per-hour cost on the AWS Marketplace.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases for AMIs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can create your own AMIs to use in Auto Scaling groups or to speed up the
    launch of complex instances that require multiple steps to download, install,
    and configure the software.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a case for a base image in an organization that has a pre-approved
    operating system, as well as security settings pre-installed for all users to
    conform to.
  prefs: []
  type: TYPE_NORMAL
- en: There are community AMIs available; however, you run these at your own risk
    since there may be unknown packages installed on them.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to use marketplace AMIs provided by vendors and partners that
    have vetted and known software already preconfigured. These AMIs often have an
    extra price per hour when running the instance.
  prefs: []
  type: TYPE_NORMAL
- en: Backing up Amazon EC2 instances
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to back up your instance either for point-in-time recovery purposes
    or to use it in a launch configuration with autoscaling, then you need to create
    an AMI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must find the latest version of the Amazon Linux2 AMI with a little
    help from the Systems Manager service and throw this into a variable for the next
    step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Launch an EC2 instance. Now that we know the latest version of our base AMI
    that we are going to use, we need to have an instance to back up and create the
    custom AMI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'ImageId value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's test our backup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, we are going back to our original command that we used in *Step 2* to
    create the instance, but now, we are going to substitute the original image ID
    for the AMI that we have just created:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, with just a few simple commands, we have taken our running EC2
    instance and not only backed it up but also created a launchable AMI from it.
    We could take our backup a step further and copy our AMI to another region; so
    long as there are no hardcoded region-specific items on the image, it should launch
    and run without issue.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have finished launching your EC2 instance and created your AMI, it
    is a good idea to terminate the instance and remove the AMI so that you don't
    get charged extra on your AWS account.
  prefs: []
  type: TYPE_NORMAL
- en: Using user data scripts to configure EC2 instances at launch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although we can launch our EC2 instances and then configure the software and
    packages that we need on them by hand, this is not the most efficient approach.
    Apart from following manual steps leading to human mistakes, this approach is
    much more time-consuming than using an automated process.
  prefs: []
  type: TYPE_NORMAL
- en: Example user data script
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will look at an example of a user data script that can configure an
    EC2 instance without user interaction by pre-forming items such as creating files
    from scratch, updating previously installed packages, updating software repositories,
    and even running commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have learned how to automatically configure EC2 instances at launch
    using user data scripts, which can do things such as install and upgrade packages,
    as well as run scripts and commands. Next, we will look at networking interfaces
    for EC2 instances.
  prefs: []
  type: TYPE_NORMAL
- en: Elastic Networking Interfaces (ENIs)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Elastic Networking Interfaces** (**ENIs**) work like virtual networking cards,
    so they allow the instance to have an IP address and be connected to a specific
    subnet. EC2 instances allow multiple ENIs to be attached, and each of those network
    interfaces can be on the same subnet or can traverse different subnets for specific
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – ENIs in separate security groups'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.6_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – ENIs in separate security groups
  prefs: []
  type: TYPE_NORMAL
- en: Since security groups are attached at the network interface level and not at
    the instance level, adding additional ENIs to your instances allows you to have
    your instance join more than one security group for specialized purposes. If you
    have a web server that needs to access the public internet, you can attach one
    interface to the security group that serves this purpose. Also, in the same instance,
    you may need to SSH into the machine so that a team member can check the logs
    or processes running on the server. Locking the security group down that is attached
    to a particular ENI that allows access to the SSH port (port `22`) can be done
    in this manner.
  prefs: []
  type: TYPE_NORMAL
- en: Elastic Block Store (EBS)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although EBS and EC2 are closely tied together, it is pertinent to remember
    that they are both separate services. EBS is a storage service that provides network-based
    storage that is allocated in the same Availability Zone as the instance and then
    mounted for usage. The amount of instance storage that's allocated to an instance
    varies by the instance type, and not all types of EC2 instances contain an instance
    store volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'EBS is different from an **instance store** based on some key attributes. The
    instance store volume is the storage that is physically attached to the EC2 instance.
    It is best used for temporary storage since the instance store does not persist
    through instance stops, terminations, or instance failures. In contrast, data
    stored on an EBS volume will persist:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – EBS overview in AWS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.7_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7 – EBS overview in AWS
  prefs: []
  type: TYPE_NORMAL
- en: EBS volumes can either be allocated at the time of instance creation or created
    once the instance has been placed in a service as additional storage.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key features to remember from a DevOps perspective, when it comes
    to allocating and restoring EBS volumes, is that a volume must stay in the same
    Availability Zone where it was created.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the key terms to understand when trying to decide which of the different
    types of EBS volumes to use is **input/output operations per second** (**IOPS**)
    or **Provisioned IOPS** (**PIOPs**). IOPS is the measure of I/O, measured in kilobytes,
    that a volume can perform in a second. Using CloudWatch Metrics, you can monitor
    the performance of a particular volume using volume metrics such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`VolumeReadOps`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VolumeReadBytes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VolumeWriteOps`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VolumeWriteBytes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know the basics of how EBS volume performance is measured, let's
    look at some of the different types of EBS volumes available.
  prefs: []
  type: TYPE_NORMAL
- en: Types of EBS volumes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are three main types of EBS volumes, all of which differ in terms of
    performance, optimal use cases, and cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solid State Drives** (**SSD**): This is a type of drive that''s optimized
    for heavy read and write operations and where a higher number of IOPS is needed.
    There are two types of SSD EBS volumes available for provisioning:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a. **General-purpose SSD**: Gives a balance of cost and performance, best used
    for development and test environments.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'b. **Provisioned IOPS SSD**: Used for mission-critical workloads where performance
    is key, such as databases or caches.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Hard Disk Drives** (**HDD**): This is a type of drive that is optimized for
    streaming workloads where performance is a necessity due to constant reads and/or
    writes. There are two types of HDD EBS volumes available for provisioning:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a. **Throughput-optimized HDD**: This type of EBS volume is best for data warehouses,
    log servers, or big data workloads.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'b. **Cold HDD**: This is a low-cost HDD that is best used for infrequently
    accessed data.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Previous generation**: This is a type of drive that is best used for smaller
    datasets that are not of critical importance. Rather than being on SSDs, these
    EBS volumes are on magnetic disks, which means they are not as performant as the
    other two types of EBS volumes. There is only one type of previous-generation
    EBS drive available and it''s best used for data that is infrequently accessed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at the EC2 service, which also covers AMIs and EBS volumes, there are
    many options to choose from, which allows you to choose the right size for your
    instance. This spans much deeper than the operating system that you choose, but
    also how fast you provision your instances and how performant you need your storage
    to be.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at AWS Batch, a service that allows us to perform large operations
    with ease either on-demand or on a schedule.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Batch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you need a large amount of compute resources.
  prefs: []
  type: TYPE_NORMAL
- en: An example to think about in this instance is tabulating voting results. Once
    voting has ended, multiple people and machines start the count at different regional
    centers. Each of the regional centers counts the votes and submits that sub-total
    to get the final results.
  prefs: []
  type: TYPE_NORMAL
- en: This process of counting the votes is a batch process. If the votes were all
    tallied in different **Comma Separated Value** (**CSV**) files, then they could
    all be uploaded and processed by the AWS Batch service.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Batch can run its jobs as either shell scripts, Linux executables, or Docker
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five main components in AWS Batch:'
  prefs: []
  type: TYPE_NORMAL
- en: Jobs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Job definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Job queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Job scheduler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at these in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Jobs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jobs in AWS Batch are nothing more than units of work. These units can take
    the form of a shell script, a Docker container image, or a Linux executable, but
    regardless of how the job is submitted, it will be run in a containerized environment.
  prefs: []
  type: TYPE_NORMAL
- en: Job definitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Telling the job how it should be run is the function of the AWS Batch job definition.
    This is also the place where you give extra detail to your jobs, such as which
    IAM role to use if the job needs to access other AWS resources, as well as defining
    how much memory and compute power the job will have.
  prefs: []
  type: TYPE_NORMAL
- en: Job queue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Until a compute environment is available to run the job, the job will sit in
    a job queue. You are not limited to a single job queue per AWS account as queues
    can be associated with different types of compute environments.
  prefs: []
  type: TYPE_NORMAL
- en: High-priority jobs may be placed in a queue where the compute environment is
    made up of On-Demand Instances. Lower-priority jobs may wait in a queue that is
    made up of Spot Instances and can run once the spot becomes available.
  prefs: []
  type: TYPE_NORMAL
- en: Job scheduler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once an AWS Batch job has been submitted to a queue, the scheduler assesses
    the current compute environments to see if they can run the job. Since jobs may
    be dependent on other jobs running and/or finishing before they can start, the
    scheduler also considers this. It is for this fact that jobs are run in a reasonable
    order from which they were previously submitted to the queue, but an exact order
    is not always possible.
  prefs: []
  type: TYPE_NORMAL
- en: Compute environments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you have set up your compute environments where the job queues will perform
    the tasks, you have several choices. You can choose managed or unmanaged compute
    and specify a particular instance type, or even only run on the newest types of
    instances available.
  prefs: []
  type: TYPE_NORMAL
- en: If one of the reasons you're using Batch is that that you are interested in
    cost savings, you can also determine the spot price for your compute instances.
    If the reliability of the compute environment is a necessity, then you are better
    off setting up your environment with On-Demand Instances.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Private Cloud networking and Route 53 networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Virtual Private Cloud** (**VPC**) service from AWS allows you to create
    a virtual network in the cloud. It allows your compute and database instances
    to either allow internet connectivity or segment it off from the internet. Security
    can be accomplished through either stateful or stateless virtual firewall rules,
    which provide the amount of network connectivity that you see fit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Network traffic and security in AWS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.8_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8 – Network traffic and security in AWS
  prefs: []
  type: TYPE_NORMAL
- en: The VPC service comprises multiple components that allow you to route and secure
    traffic from your AWS services and, optionally, the internet and/or your on-premises
    network.
  prefs: []
  type: TYPE_NORMAL
- en: VPC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the solution architect (or possibly the network architect) will often
    determine the CIDR address range that's used for the VPC, many times, it falls
    on the DevOps engineer to implement the VPC with **Infrastructure as Code** (**IaC**).
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few components that can help make up a VPC. While we will
    not be covering VPC extensively, we will look at some items that you should know
    about in case they come up in any exam questions.
  prefs: []
  type: TYPE_NORMAL
- en: Subnets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **subnet** defines a range of IP addresses in a VPC. There are both public
    and private subnets. A public subnet should be used for resources that will be
    accessed by the internet. A private subnet should be used for resources that won't
    be accessible from the internet. Each subnet can only inhabit one Availability
    Zone and cannot traverse multiple Availability Zones.
  prefs: []
  type: TYPE_NORMAL
- en: Security groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Security groups** act as virtual firewalls in Amazon VPC. You can have up
    to five security groups per EC2 instance, and security groups are enforced at
    the instance level (not at the subnet level).'
  prefs: []
  type: TYPE_NORMAL
- en: Security groups allow for stateful traffic, meaning that if the traffic is allowed
    in via the rules, then it's returned, notwithstanding any rules in place. You
    can specify inbound traffic rules based on a combination of port, IP range, or
    another security group.
  prefs: []
  type: TYPE_NORMAL
- en: Network Access Control Lists (NACLs)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Network Access Control Lists** (**NACLS**) work at the subnet level (unlike
    security groups, which work at the instance level).'
  prefs: []
  type: TYPE_NORMAL
- en: Whereas security groups are stateful, NACLs are stateless, and any traffic that
    needs to return through an NACL needs to have the port and IP range opened. NACL
    rules are evaluated in order, with the lowest rule being processed first.
  prefs: []
  type: TYPE_NORMAL
- en: Internet gateways
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unless you are running your VPC as a private extension of your data center,
    then you will need internet connectivity. **Internet gateways** provide the connection
    to the internet for VPCs in a highly available, scalable, and redundant manner.
    There are two main functions provided by the internet gateway: the first is to
    provide internet access to the subnets designated in the route table. The second
    is to provide network address translation for instances that have been assigned
    an IPv4 public address.'
  prefs: []
  type: TYPE_NORMAL
- en: Egress-only internet gateways
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using IPv6 for your VPC and instances, then you need an **egress-only
    internet gateway** rather than a regular internet gateway. This type of internet
    gateway prevents the internet from initiating connections to your instances, but
    still offers the same scalability, redundancy, and high availability as the other
    internet gateway.
  prefs: []
  type: TYPE_NORMAL
- en: Network Address Translator (NAT)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you have instances in a private subnet, by default, they cannot talk to
    the internet. Even if you have set up an internet gateway, you want to separate
    your private instances from direct internet access. This is where either a NAT
    instance or a NAT gateway comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: A **NAT** device forwards traffic from the instances in the private subnet to
    the internet or other AWS services. Since the advent of **VPC Endpoints**, using
    a NAT to talk to other AWS services in your account is considered a non-secure
    practice and should never be done in production environments.
  prefs: []
  type: TYPE_NORMAL
- en: VPC endpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need to talk to your AWS services securely from your VPC, then you can
    create VPC endpoints. A VPC endpoint allows EC2 instances and other AWS compute
    services (such as Lambda and Fargate) to communicate with supported AWS services
    such as S3 and DynamoDB, without the need to create an internet gateway or even
    the need to have a public DNS name.
  prefs: []
  type: TYPE_NORMAL
- en: This is especially useful for EC2 instances that neither need to nor should
    be connecting to the internet. Using a VPC endpoint allows the data connections
    to travel on the internal AWS network and does not require an internet gateway,
    a virtual private gateway, a NAT device, a VPN connection, or an AWS Direct Connect
    connection. VPC endpoints are virtual devices that can scale to meet demand, along
    with being redundant and highly available.
  prefs: []
  type: TYPE_NORMAL
- en: DHCP option sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you create a VPC, Amazon automatically creates a set of **Dynamic Host
    Configuration Protocol** (**DHCP**) options for you by default. You can, however,
    customize some of the available settings by creating a new **DHCP option set**
    and then attaching that DHCP option set to your VPC (and therefore removing the
    default DHCP option set).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the allowed options include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`domain-name-servers`: To use your own DNS instead of the AWS-provided DNS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`domain-name`: The default domain name for unqualified servers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ntp-servers`: You can specify up to four Network Time Protocol servers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`netbios-name-servers`: You can specify up to four NetBIOS name servers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`netbios-node-type`: The NetBIOS node type (1, 2, 4, or 8); this setting is
    blank by default and Amazon does not support broadcast or multicast.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Knowing the DHCP options is useful for configuring your VPCs in the real world,
    but memorizing the available options is not necessary for the DevOps professional
    exam.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using a custom DNS with your VPC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Amazon provides a default DNS server (Route 53 Resolver); however, you can use
    your own DNS server if you like. Some companies either run the DNS from their
    data centers in a hybrid environment, mirror their current DNS server to the cloud
    so that they do not have to create Route 53-hosted zones with all of the required
    information, or just choose to manage the DNS themselves on the platform that
    they feel the most comfortable with.
  prefs: []
  type: TYPE_NORMAL
- en: If this is the case and you want to specify the DNS versus using the default
    DNS server, then you would need to create a DHCP option set and complete the value
    for your DNS server. Once you've done this, you can attach the DCHP option set
    to your VPC, and the instances in that VPC will start using the designated DNS
    server that you have specified.
  prefs: []
  type: TYPE_NORMAL
- en: Ways to connect multiple networks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the world of AWS networking, multiple tools have been provided to help you
    connect your different networks.
  prefs: []
  type: TYPE_NORMAL
- en: VPN connections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can network AWS with your own **Virtual Private Network** (**VPN**) using
    a variety of options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AWS Site-to-Site VPN**: This option creates an IPSec connection between your
    VPN and the remote VPC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS Client VPN**: This option uses a managed client that allows your users
    to connect from almost any location using an OpenVPN-based client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS VPN CloudHub**: This option allows you to create a Site-to-Site VPN connection
    to multiple VPCs with your virtual private gateway. (The other options mentioned
    only create a VPN connection with a single VPC.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Third-party VPN appliance**: This option allows you to create a VPN connection
    using third-party software running on an EC2 instance. However, it''s important
    to note that when choosing this option, you are responsible for the maintenance
    and upkeep of the EC2 instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS Transit Gateway
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**AWS Transit Gateway** allows you to connect both on-premises networks and
    multiple VPCs through a central networking hub. Transit Gateway acts as a router
    for your cloud connections, allowing you to connect each network to the Transit
    Gateway only once. Once connected, those other networks can then talk to each
    other, using defined network rules, through the AWS global private network and
    not the public internet.'
  prefs: []
  type: TYPE_NORMAL
- en: AWS Direct Connect
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you or your company have consistent data transfers both to and from AWS,
    then the **Direct Connect** service can provide a private network connection between
    your premise and AWS. These dedicated connections are available in 1 Gbps, 10
    Gbps, or 100 Gbps denominations through direct connect providers.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike connecting directly over the public internet, using an AWS Direct Connect
    connection gives you consistent network performance by transferring data from
    your data center or office to an from AWS over dedicated channels rather than
    going over the public internet.
  prefs: []
  type: TYPE_NORMAL
- en: Route 53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The global DNS service that AWS provides is **Route 53**. This is one of the
    few services in AWS that is not tied to any specific region. The Route 53 service
    also has one of the strongest commitments, stating that it *will use commercially
    reasonable efforts to make Amazon Route 53 100% available* (Amazon Web Services,
    2021).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main components of Route 53 that are of foundational importance:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to register (and manage) domain names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DNS service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to perform health checks (and subsequently route traffic) on your
    web application based on the fact that it's functional, available, and reachable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will cover some of the basic information about the Route
    53 service, especially those topics that would be relevant to know for the DevOps
    exam.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the different types of records available in Route 53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many different DNS record types and at the time of writing, Route
    53 supports the following types of DNS records:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Address** (**A**) record'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AAAA (IPV6 address record)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Canonical name** (**CNAME**) record'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Certification Authority Authorization** (**CAA**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mail exchange** (**MX**) record'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Name authority pointer record** (**NAPTR**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Name server** (**NS**) record'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pointer** (**PTR**) record'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start of Authority** (**SOA**) record'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sender policy framework** (**SPF**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service** (**SRV**) location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Text** (**TXT**) record'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alias records (which are a Route53-specific extension of DNS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know what types of records Route 53 supports, let's take a look
    at the difference between a domain and a hosted zone.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the difference between a domain and a hosted zone
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the first things to understand about domains and a hosted zones is that,
    first, a domain is an internet construct of domain name servers that associates
    the unique name of a person or organization with a numerically addressed internet
    resource.
  prefs: []
  type: TYPE_NORMAL
- en: Domains have zone files that are text mappings of the different resources and
    their associated names, addresses, and type of record that the asset is currently
    mapped in. A hosted zone, on the other hand, is something only found in Route
    53\. It is similar to a DNS zone file (and you can import DNS zone files into
    your Route 53 hosted zones) in terms of its structure and mapping. One major difference,
    however, is that it can be managed and modified using the Route 53 interface,
    CLI, or API.
  prefs: []
  type: TYPE_NORMAL
- en: Route 53 health checks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Route 53 allows you to check the health of your applications and then reroute
    traffic to other servers or resources based on the rules that you provide. You
    can even see the recent status of your health checks in the Route 53 web console.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the health of a specific endpoint
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this case, you will be creating a check from Route 53 that performs checks
    at regular intervals specified by you. Your health checks are monitoring an endpoint
    that is either an IP address or a domain name. Route 53 then goes out at the interval
    and checks whether the server, the application, or another resource is available
    and operational. You can also request a specific web page or URL that would mirror
    most of the actions of your users, rather than just a simple health check page
    placed on the server that returns a simple 200 code if the system is up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Calculated health checks (health checks that monitor other health checks)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you have multiple resources that all perform the same function, then you
    may be wondering if a minimum number of resources are healthy. This is where calculated
    health checks come into play:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – An example of a calculated health check'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.9_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.9 – An example of a calculated health check
  prefs: []
  type: TYPE_NORMAL
- en: The calculated health check acts as a root health check where descendant checks
    can fail before the origin is considered unhealthy.
  prefs: []
  type: TYPE_NORMAL
- en: This type of health check is designed to fail if any of the alarms are set off.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the status of a CloudWatch alarm
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Route 53 can utilize the power of CloudWatch metrics and alarms. Once a CloudWatch
    alarm has been created, you can create a health check in Route 53 that observes
    the same data stream as the CloudWatch alarm.
  prefs: []
  type: TYPE_NORMAL
- en: To help improve both the availability and flexibility of the CloudWatch alarm
    health check, Route 53 looks at the data coming from CloudWatch, which then determines
    whether that route will be healthy or unhealthy. It does not wait for an ALARM
    state to be reached before setting the route to unhealthy.
  prefs: []
  type: TYPE_NORMAL
- en: Route 53 routing policies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Routing policies in Route 53 tell the service how to handle queries. These policies
    can be simple to complex, as we will see next.
  prefs: []
  type: TYPE_NORMAL
- en: Simple routing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is where the DNS is configured with no special configurations. You are
    simply setting the single record that the DNS file should point to. There is no
    weighting and no failover – just keep it simple.
  prefs: []
  type: TYPE_NORMAL
- en: Failover routing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With failover routing, you will have an alternative record in case the primary
    resource that is listed in the initial record set is unavailable or fails the
    defined health check(s).
  prefs: []
  type: TYPE_NORMAL
- en: This could be another server in a different region or a backup website being
    served by an S3 bucket.
  prefs: []
  type: TYPE_NORMAL
- en: Geolocation routing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you have an audience or userbase that spans either a country, a continent,
    or the world, and depending on their location would like them to have a custom
    message or website (without needing to use complex cookies and dynamic content),
    then you can use the **geolocation routing** feature of Route 53 to send them
    to the server or content origin that would be most relevant for their originating
    location.
  prefs: []
  type: TYPE_NORMAL
- en: You can specify the geographic locations by continent, country, or state in
    the United States.
  prefs: []
  type: TYPE_NORMAL
- en: Geoproximity routing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You may have a geographically diverse userbase but want the ability to push
    more (or less) traffic to a certain region or set of resources. This is where
    **geoproximity routing** differs from geolocation routing. It can create a bias
    for each specific resource that routes more or less traffic to that resource based
    on the bias number and the original location of the requesting user. A bias expands
    or shrinks the size of the geographic region in which traffic is routed to a resource.
  prefs: []
  type: TYPE_NORMAL
- en: Latency-based routing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you have an audience or userbase that is geographically spread out and
    you have resources running in multiple regions, then you can use latency-based
    routing to direct each user to the resource or content that will give them the
    quickest possible response time.
  prefs: []
  type: TYPE_NORMAL
- en: Question
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between geolocation routing and latency-based routing?
  prefs: []
  type: TYPE_NORMAL
- en: Although in both cases you are dealing with a geographically expanded user base,
    **latency-based routing** is based on latency records that Route 53 creates and
    stores on points of origin and IP or DNS points of record. These latency records
    can change from time to time, so it's best to have a uniform experience or have
    a customized experience based on customer settings.
  prefs: []
  type: TYPE_NORMAL
- en: '**Geolocation routing**, on the other hand, is matching the user request with
    the resource that has been geographically tied to that originating IP address,
    so you can have local content customized for the end user experience.'
  prefs: []
  type: TYPE_NORMAL
- en: Multi-answer routing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although multi-answer routing doesn't take the place of a load balancer, it
    does allow Route 53 to respond with up to eight healthy values chosen at random.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some scenarios where you would want to use multi-answer routing would be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating more than one record of the same name type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing traffic to multiple sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associating a Route 53 health check with records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weighted routing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you have multiple resources that you would like the requests to be sent to
    while distributing the traffic unevenly, you can set up weighted routing from
    Route 53\. This has a few applications, such as launching a canary release with
    major or minor updates and redirecting only a portion of the traffic to the new
    environment. You can then gauge key performance indicators, such as the number
    of abandoned carts.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing weighted routing starts with having more than one resource that
    you want the traffic to be balanced between. You can then create records inside
    your Route 53-hosted zone to reflect these resources. These have to be records
    of the same type within a domain or subdomain; that is, both need to be A records.
  prefs: []
  type: TYPE_NORMAL
- en: Once the records have been set, you can move on to configuring the routing by
    assigning a weight to the specific resource. The weighted value can be any number
    from 0 through 255 (if you specify 0, then that record will no longer receive
    traffic).
  prefs: []
  type: TYPE_NORMAL
- en: The traffic is balanced using a calculation that takes the weight of the current
    record. That is then divided by the sum of all the records.
  prefs: []
  type: TYPE_NORMAL
- en: '*Example*: If you had two servers running and the record for server A had a
    weight of 75 and the weight for server B had a weight of 150, then 75 + 150 =
    225 total weight, and server A would get 33% of the traffic using the formula
    75 / 225 = 0.3333333:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Creating a weighted record in Route 53'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.10_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.10 – Creating a weighted record in Route 53
  prefs: []
  type: TYPE_NORMAL
- en: Route 53 will be covered in a bit more detail once we get to [*Chapter 13*](B17405_13_Final_JM_ePub.xhtml#_idTextAnchor338),
    *Blue Green Deployments*, and discuss blue/green deployment strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you look at the following model, you may be wondering why there are so many
    databases. This comes from the evolution of the application architecture over
    the past few decades, where specialization, speed, and scale have all become keys
    to success in this industry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Database types and services in AWS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.11_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.11 – Database types and services in AWS
  prefs: []
  type: TYPE_NORMAL
- en: There is not enough space in this chapter to visit each type of database that
    AWS offers. However, as part of this foundational overview, we do want to cover
    some of the relational databases and their basic features.
  prefs: []
  type: TYPE_NORMAL
- en: We will be covering the key-value database, Dynamo DB, in more detail in an
    upcoming chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The word databases usually brings relational databases to mind, which have rows,
    columns, and schemas.
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases in AWS come in three main *flavors*, as well as engines
    that can be classified as part of a community, commercial, or cloud native. Cloud-native
    engines are used in the Aurora service since they are built based on community
    engines with cloud-native storage, backup, and replication capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'When we talk about cloud native, we are talking about building and running
    applications that take advantage of the cloud computing model: loosely coupled
    services that are dynamically scalable, can run on a multitenant platform, and
    have flexible networking and storage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Relational databases tend to follow the ACID set of database properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Atomic**: All of your transaction succeeds or none of it does.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistent**: Any data written to the database must be valid according to
    all defined rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolated**: Ensures that concurrent execution of transactions leaves the
    database in the same state that it would have been in if the transactions were
    executed sequentially.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Durable**: Once a transaction has been committed, it will remain in the system,
    even in the case of a system crash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational Database Service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Relational Database Service** (**RDS**) aims to take away the tasks that
    were previously performed by a database administrator, who had to be on staff
    but finds that many of their day-to-day duties are starting to be handled by automation
    and scripting. This includes provisioning a new database, creating backups, scaling
    out to read replicas, patching and upgrading instances, as well as switching over
    to a high-availability instance when an incident occurs. RDS streamlines the setup
    and installation of software and database provisioning. Using the managed RDS
    service also allows an organization to achieve a standard set of consistency when
    creating and deploying a database. No custom scripts are needed to deploy, set
    up, and patch the database since this is all handled in the background.'
  prefs: []
  type: TYPE_NORMAL
- en: After deployment, developers and applications have a database endpoint that
    can be accessed readily, where connections can be made with a client or authentication
    application, and then queries can be performed on the database.
  prefs: []
  type: TYPE_NORMAL
- en: RDS comes in several different engine formats, including two commercial engines
    and three popular open source engines. The two commercial engines that are supported
    are Oracle and Microsoft SQL Server. Both of these commercial engines are used
    in enterprises. RDS supports access to Oracle schemas via Oracle SQL, along with
    native tools such as SQL Server Management Studio for Microsoft SQL Server. In
    the community editions, RDS offers the ability to spin up databases using MySQL,
    PostgreSQL, and MariaDB. MySQL is one of the most popular community relational
    databases and AWS runs the community edition of this, defaulting InnoDB tables
    with the documentation, stating that MyISAM storage does not support reliable
    crash recovery.
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PostgreSQL is another extremely popular database, with developers using it for
    its rich feature set. RDS supports common tools such as pgAdmin or connections
    via JDBC/ODBC drivers to connect to the database.
  prefs: []
  type: TYPE_NORMAL
- en: After deciding on your engine of choice, you have the opportunity to choose
    an instance type that will give you varying levels of compute and memory power.
    There are burstable instances (T family) that are often only used for testing
    environments. A general (M family) and memory-optimized (R family) instance is
    preferred when taking your database workloads to a more productionized environment.
  prefs: []
  type: TYPE_NORMAL
- en: One of the differences between RDS and the same type of engines that you would
    run yourself on EC2 instances is how replicas work. Read replicas are extremely
    easy to provision by merely clicking a button, either in the same or a different
    Availability Zone; however, these nodes are read-only and cannot take a write.
    In the same context, you can make your instances instantly highly available, which
    replicates your data asynchronously to the copy of the master node in another
    Availability Zone or region. If an incident occurs, then it will be seamless to
    your application and end users as the DNS that both use to connect to the database
    stays the same. This secondary master, however, cannot take any load off your
    main primary server as it cannot serve any other function (such as being a read
    slave) except being the failover node. Read replicas can be promoted to a standalone
    database and at that point, they will have the ability to take writes. However,
    they will no longer stay in sync with the previous master that they were replicating
    with.
  prefs: []
  type: TYPE_NORMAL
- en: Aurora
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Amazon Aurora was built in response to customers wanting the performance of
    commercial-grade database engines such as Oracle or Microsoft SQL Server, without
    having to deal with all the hassle of the licensing handcuffs that came with those
    products.
  prefs: []
  type: TYPE_NORMAL
- en: The other keynote about Amazon Aurora is that, unlike the other RDS engines
    that are backed by EBS storage, Aurora built its own storage solution from the
    ground up after listening to multiple customer requests over the years.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Aurora comes in either MySQL-compatible or PostgreSQL versions. There
    are opportunities to run Aurora as a cluster or even run a serverless version
    of the Aurora database. The main item to know about the serverless version of
    Aurora is that it provides capacity on-demand as your application or users need
    for it. This is the distinct difference between provisioned Aurora clusters and
    the serverless version.
  prefs: []
  type: TYPE_NORMAL
- en: Key-value databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As applications are conceived, the number of users who will be served is not
    always known initially. There are usually hopes that at some point in the near
    future, the popularity of the application will grow from the initial set of users
    and testers to an exponential scale. To sustain that growth, the underlying database
    must be able to handle that scale seamlessly. This is one of the features of key-value
    databases.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at DynamoDB in more detail in [*Chapter 5*](B17405_05_Final_JM_ePub.xhtml#_idTextAnchor136),
    *Amazon DynamoDB*.
  prefs: []
  type: TYPE_NORMAL
- en: In-memory databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are accessing stored items frequently from your primary data store,
    such as a relational database, there are times when just requesting the data from
    the database won't provide the user experience that your customers are expecting.
    This is when an in-memory database such as **Amazon's Elasticache** becomes a
    viable option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Elasticache comes in two different engine versions: Redis and Memcached.'
  prefs: []
  type: TYPE_NORMAL
- en: Document databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A document database is one type of non-relational database that allows you to
    store documents and data in a JSON type format and query that data to find the
    data. One of the truly unique features of document databases is that there is
    no fixed schema and that they can have documents nested inside of each other.
  prefs: []
  type: TYPE_NORMAL
- en: AWS offers **Amazon DocumentDB** (with MongoDB compatibility) as a managed database
    service for those that have either used MongoDB in the past or are looking for
    the capabilities of a document database. If you have ever been on the operating
    side of MongoDB before, then you know that while it is powerful and has several
    advanced features, including self-electing a new master if the current master
    becomes unavailable, there are complex setup requirements to get it up and running.
  prefs: []
  type: TYPE_NORMAL
- en: It requires (in a production environment) at least three nodes – either two
    nodes and an arbiter or three master nodes. All of this complex setup goes away
    with DocumentDB. Amazon takes care of the setup and security and allows you to
    configure automatic backups that you can then store on S3\.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few small things that you are giving up, such as the ability to
    use admin or local tables, which means you can't use the `mongodump` or `mongorestore`
    utilities, but there are functions that take the place of these utilities.
  prefs: []
  type: TYPE_NORMAL
- en: Document databases are particularly good for teams who don't want to deal with
    the administrative aspects of a database, want to simplify the way initial schema
    values are used using JSON, and just want to start pushing data to the database,
    which will allow for both simple and advanced querying later.
  prefs: []
  type: TYPE_NORMAL
- en: Message and queueing systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you start to build out cloud-scale applications, you need ways to decouple
    the different tiers of the application so that it can scale independently. This
    is for several reasons, including making your application more resilient and allowing
    each tier to scale independently of other tiers. Having the ability to use a managed
    service to perform these tasks, where you or another member of your team doesn't
    have to worry about the setup and maintenance of the queues or messaging systems,
    allows expedited usage of these techniques when moving or developing in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at the messaging and queueing systems provided by AWS next and
    how they can be of benefit to you.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Notification Service (SNS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you need the ability to simply send messages either from your applications
    or from other services in several formats, such as email or text message, that
    can be used in a variety of ways. These can be based on programmatic calls or
    events that happen in your AWS account. This is where **Simple Notification Service**
    (**SNS**) comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'SNS is a publisher and consumer system, where publishers can push a message
    out to a **topic**. Then, any consumer who is subscribed to that topic can consume
    that message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – SNS fanout](img/Figure_2.12_B17405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – SNS fanout
  prefs: []
  type: TYPE_NORMAL
- en: The SNS topic acts as the channel where a single message can be broadcast to
    one or more subscribers. The publisher, which is the application in the preceding
    diagram, only has to send the message once to the topic; each consumer (or subscriber)
    can receive the message to be processed in a way that works for them. This can
    be stored for archival purposes in the case of S3, consumed on-demand in the case
    of mobile SMS or email, or be parsed and acted upon in the case of Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Queue Service (SQS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are looking for a fully managed queueing service that will allow you
    to break apart your application in a cloud-native manner, then this is where **Simple
    Queue Service** (**SQS**) is a real service fit. It comes in two flavors: **standard
    queues** and **First In First Out** (**FIFO**) **queues**. Standard queues allow
    for at least once delivery, whereas FIFO queues are capable of one-time delivery
    regarding messages placed in the queue. The other major difference between these
    two types of queues is that with FIFO queues, the messages are processed in the
    order in which they are received. A standard queue tries to preserve the ordering
    of the messages that are received; however, if a message is received out of order,
    it will not do any shuffling or re-ordering to keep the original message order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQS is a distributed queue system, which means it is spread out across different
    nodes in the region. This is one of the design features that brings the benefits
    of SQS, such as being highly scalable, available, reliable, and durable. SQS also
    allows for **Server-Side Encryption** (**SSE**), either through the service key
    provided by AWS via KMS or a custom key. You can also control who has access to
    the messages that are either produced or consumed via access policies. There are
    three main parts of the SQS distributed queue system:'
  prefs: []
  type: TYPE_NORMAL
- en: Producers/consumers (components)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The messages in the queue:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.13 – SQS distributed queue'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.13_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.13 – SQS distributed queue
  prefs: []
  type: TYPE_NORMAL
- en: Messages are placed in the SQS queue by producers; they are then distributed
    across the queue components for redundancy. When the consumer is ready to process
    a message, it uses either a long or short polling technique to see whether there
    are any messages in the queue for processing. If it detects messages for processing,
    then it consumes the message for processing in the queue; however, the message
    is only flagged as being processed and the visibility timeout begins. Once the
    consumer has successfully processed the message and deletes the message, the message
    is removed from all the nodes of the distributed queue.
  prefs: []
  type: TYPE_NORMAL
- en: Messages must be deleted by the consumer once they have been processed successfully.
    Because of the nature of the distributed system that SQS runs on, once a consumer
    has pulled down a message for processing, it is then marked so that no other consumers
    can pull down the same message. There is a timeout period, however, before which
    the consumer needs to acknowledge the message was processed. If this acknowledgment
    is never received by SQS, then the message is unflagged and available to another
    consumer for processing.
  prefs: []
  type: TYPE_NORMAL
- en: Where would you use SNS versus SQS?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When trying to decide which messaging service to use, there is a rule that
    you can use to help decide which one is going to serve you best; ask the following
    set of questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Do my messages need guaranteed delivery?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (If this answer is yes, then SQS is going to be the best choice as there is
    no option for guaranteed delivery with SNS.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are my messages going to be consumed only by my application?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (If this answer is yes, then SQS is going to be the best choice.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Are my messages going to be consumed by multiple sources?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (If this answer is yes, then SNS is going to be the best choice.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By using these three questions, you can determine whether you are dealing with
    a closed loop of gathering the messages and then processing them for use in the
    application (SQS) or creating a message to be consumed outside the application
    (SNS).
  prefs: []
  type: TYPE_NORMAL
- en: Amazon MQ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are migrating an application whose previous messaging system was either
    Apache MQ or Rabbit MQ and you no longer want to manage the instances, then **Amazon
    MQ** is a great option. Amazon MQ is more of a message broker than just a simple
    queue.
  prefs: []
  type: TYPE_NORMAL
- en: When you go to allocate your Amazon MQ, you must select either the Rabbit MQ
    or Apache MQ engine type. Once you have selected your engine type, when using
    the Management Console to provision Amazon MQ, it will prompt you, through a series
    of choices, to use a single broker or have an active and standby broker for high
    availability. It can even create a mesh network of single or active and standby
    brokers for you using predefined blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: Differences between Amazon MQ and SQS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While SQS is also a managed service from AWS, it is a scalable queue that doesn't
    require a message broker to be established. Amazon MQ's strength is that it allows
    previously built applications that have dependencies on APIs such as MQTT, OpenWire,
    or STOMP to be quickly and easily migrated to the cloud in a highly available
    fashion with minimal overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Email Service (SES)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Simple Email Service** (**SES**) allows you to set up and send emails without
    most of the complexities of running an SMTP server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SES only runs out of three regions: `us-east-1` (North Virginia), `us-west-2`
    (Oregon), and `eu-west-1` (Ireland).'
  prefs: []
  type: TYPE_NORMAL
- en: Amazon helps you verify where your mail is coming from. It provides trust to
    the email that you sent your customers by adding a series of DKIM records to the
    DNS records we send our emails from.
  prefs: []
  type: TYPE_NORMAL
- en: Trusted Advisor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the number of resources grows in your AWS account, it can sometimes be challenging
    to keep track of them all. Challenges start to arise, such as volumes that are
    sitting around not being used and **Elastic IPs** (**EIPs**) that are sitting
    there, not connected to any instance or interface, which is burning through your
    current budget. Once you enter the dashboard of Trusted Advisor, you will be presented
    with the four categories that the tool generates for automated checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – Trusted Advisor dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.14_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.14 – Trusted Advisor dashboard
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to **Fault Tolerance** checks, it can tell you if you have too
    many instances in a single Availability Zone or region.
  prefs: []
  type: TYPE_NORMAL
- en: The number of Trusted Advisor checks available increases with the support level
    associated with the account. With an account that has a basic or developer support
    level, a basic set of checks are displayed. Once the support level is raised to
    business or enterprise, then the account has access to all 115 Trusted Advisor
    checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even at a basic support level, Trusted Advisor provides several checks in four
    areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Cost optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fault tolerance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Did you notice that the four basic checks that Trusted Advisor provides can
    be mapped to four of the AWS service pillars?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On top of this, Trusted Advisor can be set up to send a weekly notification
    to either the billing contact, the operational contact, the security contact on
    the account, or any combination of the three contacts listed.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Trusted Advisor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Trusted Advisor has a graphical dashboard interface that can be viewed, and
    it even allows you to view potential monthly savings under the cost optimization
    icon when you view the service from the AWS console for the first time. AWS has
    worked to refine the console interface to make it easier to use and to be as intuitive
    as possible, displaying three icons under each major heading icon regarding the
    number of checks that have no warnings associated (green), investigation recommended
    (yellow), and then action recommended (red).
  prefs: []
  type: TYPE_NORMAL
- en: You can also access Trusted Advisor from the AWS CLI. This can be useful from
    a DevOps perspective, especially from a service limit check perspective. You can
    use your automated pipeline or a periodic Lambda job to check service levels for
    particular services, and then go out and automatically request a service-level
    increase or send out a notification to the correct email or distribution list
    so that you don't face disruption in your build process.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS continues to grow the number of services that it offers all the time. We
    have gone over quite a few of the services in this chapter, although briefly,
    but have only covered many of the essential services that are used to host and
    serve applications running on the AWS platform.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the foundational services offered by AWS. It will
    be these services, along with the others we will look at in the rest of part one,
    that we will use as the pieces of deployment in our DevOps journey. Having foundational
    knowledge of these services can let us do more from a development and deployment
    objective, and it also helps us when digesting the questions being asked on the
    DevOps professional exam, along with the scenarios being presented to us in our
    day-to-day professional lives.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to examine identity and access management,
    the basis for securing our AWS cloud account and assets.
  prefs: []
  type: TYPE_NORMAL
- en: Review questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you wanted to bid on Amazon EC2 spare capacity, which of the following would
    allow you to do this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Reserved Instances
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Auto Scaling
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. Spot Instances
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Savings plans
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The company you are working with wants to tighten up its network security. However,
    they don't currently want to have to declare egress for the return traffic. Which
    VPC construct can you use to help tune their security settings?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Network Access Control Lists (NACLs)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Network Address Translator (NAT)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. VPC endpoint
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Security groups
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'True/False: Trusted Advisor can notify you of the service limits your account
    is about to reach.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If your company was running a SQL Server instance in their current data center
    and wanted to migrate it to the AWS cloud, what options are available?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Running the database on EC2
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Setting up Direct Connect so that cloud resources can connect to the SQL
    Server instance
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. SQL Server on RDS
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. SQL Server on Amazon Aurora
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Which of the following statements about FIFO SQS queues is true?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. You are not guaranteed to get messages in the order that you sent them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Messages will be delivered exactly in a FIFO order.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. Messages will be delivered exactly once.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Messages can be delivered one or more times.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Review answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a and c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b and c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
