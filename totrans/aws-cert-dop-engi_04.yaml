- en: 'Chapter 3: Identity and Access Management and Working with Secrets in AWS'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a firm understanding of a myriad of fundamental services under our belt,
    we now move on to **Identity and Access Management** (**IAM**).
  prefs: []
  type: TYPE_NORMAL
- en: Defining the controls and policies that are used to manage access to different
    **Amazon Web Services** **(AWS**) services is what the premise of IAM is all about.
    This can come in the form of users, groups, policies, and even access, with federated
    access or short-term credentials. There is also the ability to use outside **identity
    providers** (**IdPs**) to allow users to access your applications. Understanding
    how to secure secrets using native AWS tools, especially in the context of a **continuous
    development** **(CD**) process, is an enterprise-level skill that is not only
    present in the DevOps professional exam, but also on the job.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Shared Responsibility Model in AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IAM roles, groups, users, and policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using **AWS Organizations** as part of your guidance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating federation with an AWS account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing secrets securely in AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using **Amazon Cognito** with application authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we go through this chapter, you should already have an AWS account created,
    along with the AWS **Command-Line Interface** (**CLI**) **version 2** (**v2**)
    installed so that you can follow along with the hands-on activities presented
    in this chapter. You will also need more than one AWS account if you are going
    to practice along with the AWS assume-role exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Shared Responsibility Model in AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we touched on it briefly in [*Chapter 1*](B17405_01_Final_JM_ePub.xhtml#_idTextAnchor015),
    *Amazon Web Service Pillars*, understanding the Shared Responsibility Model is
    imperative in order to work with the security of your account, and especially
    the IAM service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram provides an overview of the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – AWS Shared Responsibility Model: Infrastructure as a Service
    (IaaS)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.1_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.1 – AWS Shared Responsibility Model: Infrastructure as a Service (IaaS)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The essence of this Shared Responsibility Model is about providing flexibility
    and customer control. With this model there are two major concepts, outlined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Who is responsible for *security OF the cloud*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is where AWS holds the responsibility.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Who is responsible for *security IN the cloud*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is where you as the customer hold the responsibility.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: AWS controls the global infrastructure, which includes the data centers that
    host the servers running all of the AWS services. These data centers are run according
    to security best practices and a range of security compliance conventions. Although
    no customer is allowed to visit an actual data center, independent outside bodies
    certify and audit the centers and practices to ensure that the controls, policies,
    and procedures are being followed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple layers in which AWS secures its data centers, outlined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: At the perimeter layer—The buildings that AWS chooses to house its data and
    compute facilities are not disclosed to the public. These facilities also have
    strict entry requirements, along with intrusion detection and heavy surveillance
    to protect them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the environmental layer—Before even choosing a location, AWS looks at environmental
    risks such as severe weather, flooding, and potential earthquake activity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the infrastructure layer—Inside the building, there is a combination of fire
    detection and suppression equipment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a customer, one of the things that you are responsible for is the data you
    upload, store, and create in your account. You could both store and transmit it
    unencrypted, depending on what the requirements are for both you and your customers.
    If this is more stringent than just plaintext data, AWS offers a number of encryption
    options, or you could manage your own encryption. We will talk more about encrypting
    data both at rest and in transit later, in [*Chapter 19*](B17405_19_Final_JM_ePub.xhtml#_idTextAnchor447)*,*
    *Protecting Data in Flight and at Rest.*
  prefs: []
  type: TYPE_NORMAL
- en: Your responsibility on the AWS cloud also lies in who and what you allow to
    gain access to the various services in your accounts. This is where the IAM service
    plays a key role. By default, AWS will not allow access from any application or
    user to any other services.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping the operating system up to date with any patches and updates on your
    **Elastic Compute Cloud** (**EC2**) instances is also part of your responsibility
    in the Shared Responsibility Model. There are services such as **Systems Manager**
    (**SSM**) and Amazon Inspector that can help you with this task, identifying crucial
    security patches and adhering to a maintenance schedule. If you run the actual
    infrastructure services, then the ultimate responsibility falls to you.
  prefs: []
  type: TYPE_NORMAL
- en: How you allow traffic into your instance via the network layer is also your
    responsibility. In [*Chapter 2*](B17405_02_Final_JM_ePub.xhtml#_idTextAnchor056),
    *Fundamental AWS Services*, we discussed the **virtual private cloud** (**VPC**)
    and the tools you have to secure your network using security groups and **network
    access control lists** (**network ACLs**). Keeping your security rules to only
    the traffic that you need to allow—and nothing more—prevents outside entities
    gaining unwanted information from acts such as port scanning and other malicious
    activities.
  prefs: []
  type: TYPE_NORMAL
- en: This main shared security and responsibility model that was originally published
    by AWS reflects the responsibilities around the IaaS model. However, with different
    cloud computing models such as **Platform as a Service** (**PaaS**), in the case
    of container service offerings and managed service offerings that respond more
    like **Software as a Service** (**SaaS**), then Amazon takes even more of the
    responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the use of containers (especially in the case of Fargate), the security
    model shifts more to a PaaS model, so more of the responsibilities are pushed
    to AWS. No longer are you—the customer—responsible for the operating system, since
    AWS is managing this aspect. You are still, however, responsible for your customer
    data and the network traffic in and out of the system, as illustrated in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – AWS Shared Responsibility Model: container services'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.2_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.2 – AWS Shared Responsibility Model: container services'
  prefs: []
  type: TYPE_NORMAL
- en: One of the main things to understand is that in all of the Shared Responsibility
    Models, you are responsible for the protection of your data. This includes how
    many ports it will be exposed to, along with how it will be encrypted or whether
    it will be left unencrypted.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization versus authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we start to look at IAM, one of the first concepts we need to have a full
    understanding of is that of authorization versus authentication. Although the
    two terms may sound similar and are used in conjunction with each other quite
    frequently, understanding the differences between them is important as we move
    further.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Authentication is the process of verifying who you claim to be. The system is
    asking who you are and you are going to respond, many times, with a username and
    password, but other times with a secure session token. Authentication is answering
    the questions *Who are you?* and *Can you verify who you say you are?*
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Authorization happens after authentication and establishes what you are allowed
    to do. Most of the time, it happens after authentication. Rules and policies govern
    what you are authorized to access. In the world of computing, this can be relayed
    through a token, such as a bearer token or a **JavaScript Object Notation (JSON)
    Web Token** (**JWT**) that grants you access to services or **application processing
    interfaces** (**APIs**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The processes of authentication and authorization are illustrated in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Authentication versus authorization'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.3_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Authentication versus authorization
  prefs: []
  type: TYPE_NORMAL
- en: It can be easy to confuse authentication and authorization since they seem similar,
    but think of authentication as your picture identification and authorization as
    a **radio-frequency identification** (**RFID**) badge that allows you access.
    Let's take a look at another example for further clarity.
  prefs: []
  type: TYPE_NORMAL
- en: A practical example of authorization versus authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At many large office buildings, you need an ID badge with a photo to enter the
    building. In most cases, you are required to wear the badge at all times to show
    you have **authorization** to be in the building without being stopped by security.
    As you move to the elevator, you might need to scan your badge to access the floor
    you work on. Pressing your ID badge, which contains an RFID chip that is tied
    back to the policy system and your user profile, lets the central system know
    which floors you are allowed to access. If you work on the third floor, then you
    are **authenticated** to press button number 3 and then travel up to the third
    floor. There might be other doors in the building to which you may or may not
    have access at all, based on the level of your authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Terms to understand for IAM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we begin to talk about the IAM service and its individual components, it''s
    important to initially lay out the terms we will be using, along with their definitions.
    There is no need to memorize these terms for the professional exam, but they are
    the components of the whole service that you are expected to know from the lower
    exams. These terms are listed out here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Principal**: An application or person that uses either the AWS root account
    user, an IAM user, or an IAM role to authenticate to the account and make requests.
    This is someone or something that can take action on an AWS resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resources**: A resource is an item that you can work with inside of an AWS
    account. An example of a resource could include a Lambda function, an EC2 instance,
    or a **Simple Storage Service** (**S3**) bucket.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entities**: An entity can be an IAM user, a federated user, or a user who
    is coming in from an IdP, or it can be an assumed IAM role in the context of AWS.
    It is simply the IAM resource object that AWS uses for authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identities**: The resources that are used to identify who is using the services
    are known as identities in IAM. These are your users, groups, and roles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ways IAM can authenticate with a principal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'IAM has several ways in which it can authenticate with a principal, outlined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Username and p****assword**—A username and password are the initial way to
    get into the AWS Management Console.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access key and secret access key**—These are long-term security credentials
    that can be associated with users or the root user. They can be rotated, and a
    maximum of two access keys can be associated with any user at any single time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Session token**—You can use an assumed role to take advantage of the **Security
    Token Service** (**STS**) to pass a token that will allow you or your application
    to gain the allocated access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: AWS Management Console users can't use their username and password credentials
    to run any particular program and access AWS services or underlying infrastructure
    by default. This all comes with the authorization provided by IAM policies.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Authorization concepts with IAM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you look to add authorization to your users and applications, there are
    two models to be aware of: **role-based access control** (**RBAC**) and **attribute-based
    access control** (**ABAC**). We will go over the concepts of each next.'
  prefs: []
  type: TYPE_NORMAL
- en: RBAC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Traditional access control is based on grouping users and applications into
    groups (or roles) and then assigning permissions to the group. Many times, these
    are job functions, and the permissions that are associated with the group deal
    with the responsibilities of that job function.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping specific sets of permissions to a role, defining that role as a group
    in an authentication service such as **Active Directory** (**AD**) or AWS IAM,
    and then placing users in that group so that they may assume those permissions
    is defined as RBAC.
  prefs: []
  type: TYPE_NORMAL
- en: ABAC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three different types of attributes on which ABAC can base access
    control, listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: User attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes associated with the system to be accessed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current environmental conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In AWS, most of these attributes are managed with tags, account information
    (that is, account number, alias, or **organizational unit** (**OU**)), and federated
    data associated with the user.
  prefs: []
  type: TYPE_NORMAL
- en: IAM service concepts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most important concepts when using IAM and as you navigate through
    AWS access is to give only the minimal permissions necessary to do the job, and
    no more.
  prefs: []
  type: TYPE_NORMAL
- en: IAM roles, groups, users, and policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Controlling access to your resources in IAM comes down to how you craft your
    policies that you attach to your users, groups, and roles. Services themselves
    assume roles, and users are created in IAM and are much more easily managed if
    placed into groups.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There is a service limit of 500 IAM users per account.
  prefs: []
  type: TYPE_NORMAL
- en: IAM policies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An IAM policy is a set of permissions expressed as a JSON statement that says
    which access permissions an entity has.
  prefs: []
  type: TYPE_NORMAL
- en: As you start to dole out the permissions in your account, you will deal with
    these IAM policies. There are a number of policies that have been pre-crafted
    by AWS to help you get started, either to attach to users and groups or for services.
    Many AWS-based policies will have the resource listed as `*`; however, this allows
    for any resource to be accessed. There are multiple ways in which we can constrain
    the amount of resources that can be accessed, even in the case of a simple policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look here at a very simple example of an IAM policy that shows how we
    can give access to all object actions on all S3 buckets in the account, using
    wildcards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can, however, restrict which bucket our user can access by changing the
    resource line of the policy, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a number of different policy types that are available for use in
    AWS, as outlined in the following list. Each has its own role when it comes to
    permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: Identity-based policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource-based policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permissions boundaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizations' **service control policies** (**SCPs**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ACLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Session policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we know how IAM policies work, along with the different types of policies
    available, let's look at some of fundamental concepts around IAM policies and
    how the different types of policies work together to form effective permissions.
  prefs: []
  type: TYPE_NORMAL
- en: IAM policy concepts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you start to use IAM, you need to have an understanding of how the service
    evaluates policy requests based on its internal logic. Here is an overview of
    the rules that you need to remember:'
  prefs: []
  type: TYPE_NORMAL
- en: By default, all requests are denied (unless you are the root user).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any service has been explicitly denied, this rule takes precedence, even
    if another rule has the service allowed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An explicit `allow` in a policy will override the default implicit `deny`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a SCP, session policy, or permissions boundary grants access to a service
    then it too will override the implicit `deny`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a deeper understanding of how the rules are processed, I suggest you read
    the documentation available here: [https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_evaluation-logic.html](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_evaluation-logic.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the diagram pictured in *Figure 3.4* are three circles. The bottommost circle
    is the identity-based policy—that is, where the user or group is granting the
    permissions for that effective user. However, there are other identity policies
    at play that can limit—or in some cases expand—the effective permissions for a
    user. The center of where all the policies intersect—and in this case where the
    arrow is pointing—is the effective permission set for the user, as illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Effective policy permissions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.4_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Effective policy permissions
  prefs: []
  type: TYPE_NORMAL
- en: With knowledge of how these different types of polices interact together to
    form effective permissions, we can now go about creating our identities in the
    forms of roles, groups, and users.
  prefs: []
  type: TYPE_NORMAL
- en: Identities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you first create your AWS account, the email account you use to sign up
    with becomes your AWS root user. Although you have the ability to access the Management
    Console with this root user, and this user has a full unrestricted set of permissions
    to all services and resources in your AWS account, it is not recommended that
    you start creating resources and workloads with this user.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, we can see an example of how the root user is at
    the top of the AWS account structure, and then our groups are inherited by both
    users and roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – IAM users and groups'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.5_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – IAM users and groups
  prefs: []
  type: TYPE_NORMAL
- en: Once we have mapped out which groups we want to create in our account, along
    with the basis of the permissions that each group or role will be inheriting,
    we can then go about creating these groups.
  prefs: []
  type: TYPE_NORMAL
- en: IAM groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some important things to know about groups:'
  prefs: []
  type: TYPE_NORMAL
- en: A user can belong to multiple groups, and groups can have multiple users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Groups can only contain users, not other groups, hence groups can't be nested
    inside of each other and inherit privileges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users must be manually added to a group. Upon creation of a user or role, there
    is no default group where permissions are automatically assigned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating IAM groups
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we actually add our users, let''s create our groups and associate the
    Amazon-managed IAM policies with those groups, as shown in *Figure 3.5*. We will
    make the following groups and then associate the following managed policies with
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Groups and their associated managed policies'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.6_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – Groups and their associated managed policies
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know which groups we are going to set up, let''s use our CLI to
    create those groups, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up your terminal and type the following commands so that we can create
    our first group (`Admins`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s check the current groups in our account, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice how I changed the output here—this method for the four groups I''m about
    to show is not going to take multiple pages with the spacing that JSON formatting
    takes up. The output should be similar to what is shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we see all the groups listed, we can now start to attach the managed policies
    we identified before. However, in using the CLI, we need to know the `grep` to
    help our search, as illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: AdministratorAccess, which was the first returned result. The others were returned
    because they had AdministratorAccess as part of their name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have found the ARN for our managed policy, we can attach it to
    our group, as illustrated in the following code snippet. Once the IAM policy is
    attached to the group, any users we add later will automatically assume those
    permissions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once you execute this command, it will not give you any return or feedback.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We could check from the command line to see if our policy was attached to our
    group by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will then bring back the policy we just affixed to the group, as illustrated
    in the following code snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, we're done for the moment. We will need to create our users in
    order to add them to the group.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We could have also done this using a CloudFormation script, which would have
    made it a lot easier to roll back or clean up any groups we just made. We are
    going to take a deep dive into CloudFormation and **Infrastructure as Code** (**IaC**)
    in [*Chapter 7*](B17405_07_Final_JM_ePub.xhtml#_idTextAnchor188), *Using CloudFormation
    Templates to Deploy Workloads*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: IAM users
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An IAM user is a person or application who is credentialed to access and interact
    with a specified set of AWS services.
  prefs: []
  type: TYPE_NORMAL
- en: When you create your account, you are automatically provisioned as a root account
    user.
  prefs: []
  type: TYPE_NORMAL
- en: After creating a user, they start with no permissions, nor are they authorized
    to perform any actions on AWS resources until you or another administrator (or
    person with IAM permissions) grant them access via an inline policy, attach a
    managed policy to their user, or add them to a group.
  prefs: []
  type: TYPE_NORMAL
- en: IAM users cannot be associated with more than one AWS account.
  prefs: []
  type: TYPE_NORMAL
- en: The user's section of IAM is also where you store each individual user's **Secure
    Shell** (**SSH**) keys to access the AWS Git service CodeCommit. We don't dive
    deep into CodeCommit until [*Chapter 8*](B17405_08_Final_JM_ePub.xhtml#_idTextAnchor212),
    *Creating Workloads with CodeCommit and CodeBuild* ; however, understanding how
    the keys, users, and IAM permissions interact is important, especially if you
    want your users to have the ability to self-manage, add, remove, and rotate their
    own SSH keys.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to create more users with specified roles for your account
    then you can do so with the new roles that you have just created, using the steps
    outlined in [*Chapter 2*](B17405_02_Final_JM_ePub.xhtml#_idTextAnchor056), *Fundamental
    AWS Services,* to create a user.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: IAM roles allow you to empower services, applications, and other AWS services
    to have access without hardcoding credentials such as access key and secret access
    key directly into the application—or in the case of a user, even create an access
    key and secret access key pair.
  prefs: []
  type: TYPE_NORMAL
- en: Roles are also extremely useful when switching between accounts. If you have
    multiple accounts—let's say, development, testing, and production accounts—you
    can use your user in the development account and then create a role in the other
    two accounts, which are allowed to be assumed by your main user.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage to roles is that they can be assumed by multiple instances
    of the same service (for example, EC2/Lambda). Just as in IAM groups, if you need
    to add more permissions or remove permissions from a role's policy, those changes
    take effect almost immediately.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of EC2, you would use an **instance profile** to pass a role to
    an EC2 instance. An instance profile can only contain one role, and this is a
    hard service limit that cannot be increased. If the permission needs of the instance
    change, you can remove the current role attached to the instance profile and then
    attach a different role that contains a distinct set of permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Roles and role assumption are also a way to provide access to third parties
    who may also have their own AWS account but may need limited access to your account.
    This could be a third-party partner or an auditor who may just need read-only
    access.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For this exercise we will need two accounts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Account A**: This will be the account where we will create a role that we
    will allow to be assumed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Account B**: This will be the account we have been working on previously
    and will use one of our previously created users to assume the role and go to
    the other account.'
  prefs: []
  type: TYPE_NORMAL
- en: Before you start, it would be a good idea to know the account numbers and have
    them in a text document labeled *Account A* and *Account B*. This will make things
    easier when we start to go through the process of setting up the role. If you
    don't know your AWS account number, then the easiest way to find it is to click
    on your username on the top of the main menu. When the drop-down menu appears,
    then one of the items in that menu is **Account**, with your account number.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first go into *Account A* and create a role to be assumed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign in to the console with a user on *Account A* who has either Admin user
    privileges or the ability to create IAM users and roles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the IAM service at [https://console.aws.amazon.com/iam/home](https://console.aws.amazon.com/iam/home).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the left-hand menu, click **Roles**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the **Roles** screen appears in the main window, click the blue button
    labeled **Create Role**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The type of trusted identity you want to choose on the next screen is **Another
    AWS account**, as illustrated in the following screenshot:![Figure 3.7 – Creating
    an IAM role
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.7_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.7 – Creating an IAM role
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Enter the account number of *Account B* into the **Account** field and then
    press the **Next: Permissions** button at the bottom of the page.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the `S3FullAccess`. This should bring up the `AmazonS3FullAccess` policy.
    Click the box next to this policy name. After you have checked the box, as illustrated
    in the following screenshot, then click the blue button at the bottom of the page,
    labeled **Next: Tags**:![Figure 3.8 – IAM S3 full access policy'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.8_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.8 – IAM S3 full access policy
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We are not adding any tags in this exercise, so just click the blue button
    at the bottom of the screen that says **Next: Review**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we get to the `AssumeS3`; if you would like to type a description, you
    can do so (see the example description in the following screenshot), but this
    is not necessary. Make sure that everything looks correct and then click the **Create
    role** button at the bottom:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.9 – IAM assume S3 role review'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.9_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – IAM assume S3 role review
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our role set up in *Account A*, we can log out of this account
    and then log back in to *Account B* so that we can use this new role we created
    to switch from our main role to the `AssumeS3` role in *Account A*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have logged in, then click on your name in the top right-hand menu to
    expose the drop-down menu (we did this previously to find our account numbers).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the drop-down menu exposed, click on the menu item labeled **Switch Roles**,
    as illustrated in the following screenshot:![Figure 3.10 – Switching roles from
    AWS Management Console
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.10_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.10 – Switching roles from AWS Management Console
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, on the **Switch Roles** screen, click the blue button labeled **Switch
    Role**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the next screen, you will be presented with three textboxes to fill out,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. In the box labeled `AssumeS3`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'c. In the box labeled `AccountA_S3`, as illustrated in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Assuming role in Account A'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_3.11_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.11 – Assuming role in Account A
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With this information entered, you are now ready to switch roles.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After entering all this information, click the blue **Switch Role** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should now be in *Account A* with the `AssumeS3` permissions signified
    by the color at the top of the menu bar, along with the display name of the role,
    as illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.12 – AWS Management Console showing successful role switch'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.12_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – AWS Management Console showing successful role switch
  prefs: []
  type: TYPE_NORMAL
- en: We've just seen how roles can help us manage the permissions in our own account,
    as well as giving us the ability to take on a defined permission set in another
    account. Next, we will look at both ways to put limits in place from an account
    level with permissions boundaries, along with some IAM best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions boundaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Permissions boundaries are an advanced feature of IAM that allows you to use
    AWS managed policies but set the maximum resource limits for those policies. In
    practical usage, permissions boundaries can be extremely helpful to allow you
    to take an AWS managed policy that has the permissions you need for a service
    and attach it to a user, group, or role and then keep that entity from going outside
    of the resources they need to access using the permissions boundary policy.
  prefs: []
  type: TYPE_NORMAL
- en: If we refer back to *Figure 3.4*, look where the identity-based policy intersects
    with the permissions boundary policy. In the middle of those two policies is the
    effective policy for the entity. Most managed policies provided by AWS allow for
    a full scope in the `*`). For most organizations, both large and small, this is
    too wide open a permission set. Not only does this present a security concern
    across different sectors of an organization, but also limiting the access helps
    mitigate any blast radius that a user could cause in an accidental situation.
  prefs: []
  type: TYPE_NORMAL
- en: IAM best practices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s take a look at some best practices when using IAM, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Don't use the root account for day-to-day access. Only use the root account
    for the initial setup of administrative users and in emergency/break-glass scenarios.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always set up **multi-factor authentication** (**MFA**) for your root user.
    Also, it's a best practice to put MFA in place for any account administrators.
    Try to put MFA in place for all users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up a password policy that requires users to set a strong password that needs
    to be rotated on a regular basis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't set permissions directly to users; instead, use groups or allow users
    to assume roles—set permission sets to the roles and allow users to assume the
    roles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't allow secrets to be left in plaintext in code. Use a secret store such
    as Secrets Manager or Parameter Store to securely store secrets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will learn about using **AWS Organizations** as part
    of your guidance.
  prefs: []
  type: TYPE_NORMAL
- en: Using AWS Organizations as part of your guidance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**AWS Organizations** is a service that helps you consolidate multiple AWS
    accounts for ease of management and billing. Not only does AWS Organizations help
    you create new accounts under the organizational umbrella quickly and easily,
    but it also provides features for governance that are not available in a standalone
    AWS account.'
  prefs: []
  type: TYPE_NORMAL
- en: The two features of relevance to IAM are OUs and SCPs.
  prefs: []
  type: TYPE_NORMAL
- en: Separation with OUs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand OUs, we need to initially look at two basic concepts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Root
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **organization** is an entity that you create to unify the different AWS
    accounts under your control so that you can oversee them as a single unit. There
    is one master account assigned to an organization that can then branch off into
    zero or more units. Many times, organizations are organized in a tree-like configuration,
    with the root account at the top and the OUs and child accounts branching out
    underneath.
  prefs: []
  type: TYPE_NORMAL
- en: The **root** is the origin container for all other accounts in your organization.
    If you apply an SCP to the root account, it trickles down and hence gets applied
    to all organizational accounts and child accounts that are part of the organization.
  prefs: []
  type: TYPE_NORMAL
- en: An OU is simply a container for grouping accounts under the root account. Organizational
    accounts can be nested inside of other OU units creating the hierarchy of your
    organization, with the root account sitting at the top.
  prefs: []
  type: TYPE_NORMAL
- en: Features of organizations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Organizations allow you to centrally manage policies across AWS accounts. This
    helps you improve control over your AWS environment by using **AWS Organizations**
    to create a group of accounts and then attaching policies to a specified group,
    establishing that the correct policies are applied across those accounts without
    a need for any custom scripting.
  prefs: []
  type: TYPE_NORMAL
- en: You can integrate AWS **single sign-on** (**SSO**) to simply provision access
    for your users to different accounts in your organizations, in a single place.
  prefs: []
  type: TYPE_NORMAL
- en: SCPs allow organizations to administer permission guardrails to AWS services,
    resources, and regions.
  prefs: []
  type: TYPE_NORMAL
- en: '**AWS Organizations** also allows you to easily set up consolidated billing,
    using a single payment method for all of the accounts in an organization. This
    allows you to benefit from pricing advantages such as aggregated usage and volume
    discounts on different services that would not be available if all accounts were
    separated.'
  prefs: []
  type: TYPE_NORMAL
- en: SCPs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SCPs are a tool that you can use to manage policies throughout a specific OU
    or throughout your entire organization, through inheritance. They can either enhance
    or limit the scope of the permissions that your users currently have, and they
    are at their most effective when combined with advanced IAM constructs such as
    `Condition`, `ArnNotLike`, `StringNotLike`, and specific regions to provide the
    guardrails that your organization agrees upon, to ensure that users don't intentionally
    or unintentionally perform inappropriate actions.
  prefs: []
  type: TYPE_NORMAL
- en: Example of a SCP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code snippet provides an example of a SCP that you could attach
    at the root level of your organization to make sure that if anyone were going
    to delete an EC2 or **Relational Database Service** (**RDS**) instance, then a
    multi-factor device would first need to be present for verification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice how the SCP syntax looks almost exactly like the normal IAM policy
    syntax, containing an `Effect`, `Action`, `Resource`, and `SID`. This SCP actually
    has an optional value of a condition, which is where we are checking to see whether
    the MFA exists and if not, then the action is denied.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating federation with an AWS account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the users who will be accessing your account already have an authentication
    method, then there are a few different methods to incorporate federation into
    your AWS account.
  prefs: []
  type: TYPE_NORMAL
- en: '*"Identity federation is a system of trust between two parties for the purpose
    of authenticating users and conveying information needed to authorize access to
    resources. In this system, an Identity Provider (IdP) is responsible for user
    authentication, and a service provider (SP), such as a service or application,
    controls access to resources."* (AWS, 2021)'
  prefs: []
  type: TYPE_NORMAL
- en: When you incorporate federation, then your users are going to use STS to request
    a session for authorization into your account.
  prefs: []
  type: TYPE_NORMAL
- en: 'A session consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An access key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A secret access key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A security token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An expiration date (for when the security token is no longer valid)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A federated token by default will expire in 12 hours, but can be set to time
    out in as little as 15 minutes or as long as 36 hours.
  prefs: []
  type: TYPE_NORMAL
- en: 'Federated tokens are handed out from the STS service via a few different request
    types, a couple of which are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetFederatedToken`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AssumeRoleWithSAML`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When would you use federation?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few scenarios where federation makes perfect sense to use in your
    environment or accounts. The first would be if you have a **Security Assertion
    Markup Language** (**SAML**) 2.0-compatible corporate directory. Examples of this
    would be **AD Federation Service** (**AD FS**), Okta, Shibboleth, and many others.
    When your directory is SAML 2.0-compliant, then you can configure it to provide
    SSO access to the AWS Management Console.
  prefs: []
  type: TYPE_NORMAL
- en: Even if the directory isn't SAML 2.0-compliant, you still have the ability to
    furnish SSO to your users. In this case, though, you will need to produce an identity
    broker application to provide SSO access.
  prefs: []
  type: TYPE_NORMAL
- en: The second scenario in which you would likely use federation is if your users
    have identity management through a third party such as a web identity. In this
    case, the web IdP provides the authentication step, and then you can use federation
    to grant your users AWS access to the services they need. We will discuss this
    more when we talk about the use of the AWS Cognito service later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using AD federation with IAM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you use AD FS to provide access to your account, the flow happens in the
    following order:'
  prefs: []
  type: TYPE_NORMAL
- en: The user (or application) requests a session from the federation proxy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user is then authenticated via AD to ensure that they are an active user
    and have permissions to access the AWS cloud.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, AD determines the quantity of permissions the user is entitled to receive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the federation proxy initiates a `GetFederationToken` request from the
    STS service in the AWS account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The STS service then responds with the federated token (including the access
    key, secret key, and session token).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The federation proxy then passes the token to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user is then able to make API calls to the AWS account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using federation to authenticate to your AWS account is especially useful if
    you have a large organization and don't want to manage users in both AD and AWS
    IAM. It can also help you get around the service limit of 500 IAM users per account.
  prefs: []
  type: TYPE_NORMAL
- en: AWS offers a number of different *flavors* of AD depending on your needs, which
    we will look at next.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Directory Service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: AWS provides a multitude of different options for using AD in the cloud according
    to your needs. There are three levels of the AWS Directory Service offered, and
    each serves a different purpose.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Directory Service for Microsoft AD (MS AD)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are looking to run a managed service Enterprise version of AD in the
    cloud, then the AWS AD service is an excellent option. This service can handle
    up to 50,000 users and up to 200,000 AD objects. It also has the ability to be
    implemented in a highly available fashion across multiple regions. Multi-Region
    replication is only supported in the Enterprise edition of AWS Managed MS AD.
  prefs: []
  type: TYPE_NORMAL
- en: If you have more than 5,000 users and don't currently have an AD server or the
    need to manage users and/or AD objects in the AWS cloud, then AWS Directory Service
    is your best option.
  prefs: []
  type: TYPE_NORMAL
- en: One disadvantage of using this service is if you run into performance issues,
    you don't have a lot of knobs and levers to pull. This is, after all, a managed
    service and is supposed to take administrative tasks off your plate. This is also
    not fitting for web federation.
  prefs: []
  type: TYPE_NORMAL
- en: AD connector
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you already have an AD server on-premises and you want a way to quickly extend
    this to the cloud, then an AD connector is a good option. An AD connector doesn't
    cache information in the cloud, but rather serves as a proxy for your on-premises
    AD server. This also means that you can't make any changes to the AD connector
    in the cloud. All changes and updates have to take place on the on-premises server.
  prefs: []
  type: TYPE_NORMAL
- en: Simple AD
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Simple AD comes in two different sizes: small and large. The small version
    can support up to 500 users and 2,000 objects and the large version can support
    up to 5,000 users and 20,000 objects. If these numbers don''t support the growth
    rate of your organization, then you need to consider an alternative solution such
    as MS AD.'
  prefs: []
  type: TYPE_NORMAL
- en: Simple AD does support Kerberos-based SSO authentication and can be spun up
    using a CloudFormation script.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Simple AD is based on Samba 4 and isn't true MS AD. It won't support TRUST with
    other AD systems. It also doesn't support items such as MFA, PowerShell, AWS SSO,
    or Amazon Chime. While it is a good option if you only have a small set of users
    or if you are trying to provide a **fully qualified domain name** (**FQDN**) for
    a small number of Windows machines in the cloud, be mindful of its limitations—especially
    when reading through exam questions.
  prefs: []
  type: TYPE_NORMAL
- en: AWS SSO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even with the vast offerings of AWS, there are still other services you or your
    customers probably want to incorporate as SaaS offerings that require authentication.
    Rather than making users verify themselves to each and every **service provider**
    (**SP**), AWS makes this simple with its own SSO service.
  prefs: []
  type: TYPE_NORMAL
- en: This is even the case if you are using AD, be it on-premises or Azure-based
    AD. You might be using third-party authentication such as Okta or Ping Identity,
    and SSO can be incorporated with these services as well.
  prefs: []
  type: TYPE_NORMAL
- en: Where AWS SSO really eases the burden from administrators is when you are managing
    multiple AWS accounts, as you can map your users and their roles quickly and easily
    to accounts with a single point of entry. There is no longer a need to set up
    a SAML token or to go through the process of showing users which account to use
    to switch roles.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a user identity strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With all of these different methods to manage your users and different ways
    to manage their authorization, you might need some guidelines on when to use each
    method.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a small group, then that size of team is usually best served by
    using IAM groups.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use federation to manage your user logins and you already have
    an AD in place, then SAML federation via AD is going to be the correct route.
  prefs: []
  type: TYPE_NORMAL
- en: If you want federation and you don't yet have an AD and you want the extra features
    that AD provides, such as providing **Domain Name System** (**DNS**) management
    to Windows instances, then you can go to AWS Directory Services.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you want federation and don't want the hassle of setting up and
    managing AD or the licensing costs, then AWS SSO is going to be your best option.
  prefs: []
  type: TYPE_NORMAL
- en: Storing secrets securely in AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being a DevOps engineer and codifying our infrastructure and applications for
    deployment through deployment pipelines doesn't take out the necessity of credentialing
    items such as usernames and passwords or third-party API authentication from our
    application. It does, however, present a need to authenticate on a much more secure
    and repeatable basis so that development and testing aren't hindered, along with
    only sharing access only with those who absolutely need to know. Not every developer
    who is working on a system needs a username and password to the database if they
    are all using the same application. You can also limit the management overhead
    of having to change the credentials every time there is a personal change if you,
    instead of passing the credentials out to every developer, have the developer
    request the credentials from a secrets manager. Although there are third-party
    solutions that perform this task, AWS does provide two different native services
    that allow for secrets management, and even secrets rotation.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Secrets Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use Secrets Manager to store, rotate, monitor, and control access to
    secrets such as database credentials, API keys, and **Open Authorization** (**OAuth**)
    tokens. One of the main features of Secrets Manager is that it allows for automatic
    rotation of secrets using AWS Lambda functions.
  prefs: []
  type: TYPE_NORMAL
- en: There is no longer a need to place hardcoded secrets in your IaC or application
    code, or even to download to your instances at startup and have them stored in
    an unencrypted vulnerable state. You can now retrieve secrets when you need them
    simply and securely, with a call to Secrets Manager.
  prefs: []
  type: TYPE_NORMAL
- en: Access to Secrets Manager is also governed by IAM policies. Users or roles must
    have been granted access to either the Secrets Manager service as a whole or the
    specific instance of Secrets Manager in order to perform operations such as storing
    and retrieving secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Another feature of Secrets Manager is that every time a secret is accessed,
    an audit trail is left. This is a valuable feature in highly compliant industries.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be wondering: *Just what is a secret?* Well, in the context of Secrets
    Manager, a secret is typically a set of credentials (username and password) and
    the connection details that you use to access a secured device.'
  prefs: []
  type: TYPE_NORMAL
- en: The basic structure of a secret in Secrets Manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Secrets Manager, a secret contains encrypted secret text and several metadata
    elements that express the secret and define how Secrets Manager should deal with
    the secret, as illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Anatomy of a secret in Secrets Manager'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.13_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – Anatomy of a secret in Secrets Manager
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how Secrets Manager stores and versions the secrets that
    we place into it for safekeeping, let's go through an exercise of creating and
    storing a secret using AWS Secrets Manager.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and storing a secret in AWS Secrets Manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following exercise, we are going to store a secret securely using the
    AWS Management Console and AWS Secrets Manager. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up your browser and go back to the Amazon web console. You may have to
    log in if your session has expired. In the search bar at the top, type `Secrets
    Manager` to have the **Secrets Manager** icon appear. Click on the icon to go
    to the main **AWS Secrets Manager** page, as illustrated in the following screenshot:![Figure
    3.14 – The main Secrets Manager page
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.14_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.14 – The main Secrets Manager page
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On either the main `Secrets Manager` page or the **secrets list** page, once
    you have entered into the **Secrets Manager** section of the console, click **Store
    a new secret**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Store a new secret** page, choose **Other type of secrets**, as illustrated
    in the following screenshot:![Figure 3.15 – Choosing the secret type on the Store
    a new secret page
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.15_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.15 – Choosing the secret type on the Store a new secret page
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Under **Specify the key/value pairs to be stored in this secret**, choose **Secret
    key/value** so that you can type in the secret as key-value pairs, as illustrated
    in the following screenshot:![Figure 3.16 – Adding the key pair and values to
    your secret in Secrets Manager
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.16_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.16 – Adding the key pair and values to your secret in Secrets Manager
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For `DefaultEncryptionKey`, as illustrated in the following screenshot:![Figure
    3.17 – Secrets Manager encryption
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.17_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.17 – Secrets Manager encryption
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the first box, type `username`. In the second box, type `devopspro`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **+ Add row** to add a second key-value pair.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the first box, type `password`. In the second box, type `MyTopSecretP@ssword#`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we have typed in the values for our secret, we can view it in a JSON context
    before moving on to ensure it is correct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Choose `SecretString` field of the secret.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `DefaultEncryptionKey` and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under `chapter3/SecretManager`. This stores your secret in a virtual `chapter3`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `Secret Manager Tutorial` and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don't need to rotate this secret, so choose **Disable automatic rotation**,
    and then click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Review** page, you can check all of the settings that you have chosen.
    If you are using the secret within an application, be sure to review the **Sample
    code** section that has cut-and-paste-enabled code that you can put into your
    own applications to use this secret to retrieve the credentials. Each tab has
    the same code in different programming languages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To save your changes, choose **Store**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieving your secret from Secrets Manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we know how to use the AWS Management Console to save a secret, we
    will use the AWS CLI to retrieve the secret and see that it has been stored successfully.
    Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up your terminal if you closed it previously, and type the following command
    so that we can retrieve the secret:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After executing the preceding command, there should be a return somewhat like
    this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we can see our secret with the name `chapter3/SecretManager` stored
    in Secrets Manager, we can go about retrieving the secret by running the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We just used AWS Secrets Manager to successfully create, store, and retrieve
    a secret. One of the reasons why we could retrieve the secret is because our IAM
    role gives us the permissions to do so. Next, we will look at the other service
    that AWS offers for safekeeping of secrets: SSM Parameter Store.'
  prefs: []
  type: TYPE_NORMAL
- en: SSM Parameter Store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Parameter Store** is a managed service from AWS to store strings. These can
    be plaintext strings or, in the case of using it as a secrets manager, it can
    store encrypted data. Access to the parameters is governed by IAM policy access.'
  prefs: []
  type: TYPE_NORMAL
- en: Parameter Store is more flexible than Secrets Manager and if you store standard
    parameters there is no charge, but there is a limit of 10,000 parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secrets and values stored in Parameter Store can be accessed from many different
    AWS services, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: EC2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elastic Container Service** (**ECS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secrets Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS Lambda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudFormation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CodePipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CodeBuild
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CodeDeploy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you or your team are looking for a central way to separate your secrets and
    configuration data from your code base, along with the ability to store different
    values for different environments, then Parameter Store could be a good option
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets Manager versus Parameter Store
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we look at the different services that allow us to store secrets securely
    in AWS, we might wonder why we would choose one over the other. Let''s take a
    quick comparison of the two services and see the main differences, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are looking for an option that won't add any more to your budget, then
    SSM Parameter Store is the right choice for you and your organization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want the ability to store plaintext secrets, then SSM Parameter Store
    has this ability. AWS Secrets Manager cannot store values in plaintext.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both services are proportionately secure as both can use **Key Management Service**
    (**KMS**) to securely encrypt values at rest.
  prefs: []
  type: TYPE_NORMAL
- en: If you want the ability to automatically rotate secrets, then AWS Secrets Manager
    needs to be your service choice. (With Parameter Store, you would have to rotate
    the secrets manually.)
  prefs: []
  type: TYPE_NORMAL
- en: Using Cognito with application authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cognito is a service that allows web and mobile applications to authenticate
    to your platform using either username and password or third-party identification
    social IdPs such as Amazon, Facebook, or Google. The three main functions of **Amazon
    Cognito** are user management, authentication, and synchronization. Cognito can
    be used to coordinate the authentication of external users to your applications
    via third-party IdPs. You can also federate your users with any SAML-based IdP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the advantages of using Cognito include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ease of setup, whereby you can have an authentication and authorization system
    that integrates into your AWS services up and running in a matter of minutes,
    versus the amount of time it would take you for custom programming to do the same
    task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can quickly and easily integrate MFA into **Amazon Cognito**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cognito metrics are easily monitored using the CloudWatch service, with no extra
    effort or coding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any API calls made to the Cognito service are recorded to CloudTrail (assuming
    you have turned on CloudTrail for the account and region).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where would you use Cognito?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you build out an application for external customers (customers that are not
    part of your company) and you want these customers to have the same experience
    no matter what type of device they are using, this is a case to use AWS Cognito.
    Cognito allows users to have a similar login experience whether they are using
    a mobile device, tablet, laptop, or **virtual machine** (**VM**).
  prefs: []
  type: TYPE_NORMAL
- en: Another case for using Cognito is if you want to quickly incorporate **two-factor
    authentication** (**2FA**) such as email or **Simple Message Service** (**SMS**)
    authentication into your application.
  prefs: []
  type: TYPE_NORMAL
- en: User pools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first main component of Cognito is user pools. Essentially, user pools
    present sign-up and sign-in services. Understand these facts about user pools:'
  prefs: []
  type: TYPE_NORMAL
- en: They provide sign-up and sign-in services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User pools have a built-in **user interface** (**UI**) that is customizable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They allow for sign-in via social IdPs such as Amazon, Google, Facebook, and
    Apple, along with SAML IdPs from your user pool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They allow for security features such as MFA authentication, can check for compromised
    credentials, and have account takeover protection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User pools have phone and email verification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User pools allow for customized workflows along with user migration via AWS
    Lambda triggers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have successfully authenticated a user with a user pool, then Cognito
    issues a JWT that can be used to authorize access to either your AWS credentials
    or your APIs, as illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18 – Cognito user pool authentication'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.18_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.18 – Cognito user pool authentication
  prefs: []
  type: TYPE_NORMAL
- en: 'With an understanding of user pools and what function they serve, we can look
    at the other main component of **Amazon Cognito**: identity pools.'
  prefs: []
  type: TYPE_NORMAL
- en: Identity pools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second main component of **Amazon Cognito** is that of identity pools. Identity
    pools provide the credentials to access AWS services. With an identity pool, you
    can create unique identities for your users that give them temporary access credentials
    to AWS services.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the workflow shown in *Figure 3.17*, you will see that the user
    initiates the login (usually from an application on their device) with the web
    IdP. Once authenticated with the web IdP, a `GetId` call is passed to Amazon Cognito,
    which then validates the request. The app will then make a `GetCredentialsForIdentity`
    request. Cognito will once again validate this request. At this point, Cognito
    will call out to the STS service and get a short-lived token for the services
    the app is authorized for and will then pass that back on to the application,
    as illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.19 – Cognito identity pool authorization flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.19_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.19 – Cognito identity pool authorization flow
  prefs: []
  type: TYPE_NORMAL
- en: Identity pools also allow you to define your own custom developer-authenticated
    identities in addition to the social IdPs supported for authentication. You can
    do this in the Cognito console by choosing **Custom**, setting your own name,
    and then using the sample code provided by AWS as the base for creating your new
    custom federated identity pool.
  prefs: []
  type: TYPE_NORMAL
- en: Tip to remember
  prefs: []
  type: TYPE_NORMAL
- en: User pools provide the authentication, and identity pools provide the authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about authentication and authorization methods in
    AWS. We talked about how to authorize users either with username and password
    or via federation using the IAM service and then authenticating them using IAM
    policies. **AWS Organizations** also showed us how we could further restrict the
    authorization settings using SCPs. We looked at different models of federation
    with services such as AD, AWS SSO, and Cognito. We also looked at how to securely
    store secrets as we start to work with our applications using Secrets Manager
    or SSM Parameter Store.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will wrap up our section on AWS fundamentals with a
    look at the NoSQL service DynamoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Review questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Shared Responsibility Model presented by AWS for IaaS, who is responsible
    for operating system security and patching?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the major differences between a user and a role from the choices presented
    here?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. A role can be assumed by multiple principals; a user cannot be assumed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. A role uses long-term credentials.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. A role can be part of a group.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. A role does not use long-term credentials.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Which comes first: authorization or authentication?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which native service in AWS that stores secrets offers automatic secret rotation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A company wants to extend their current AD into the AWS cloud but doesn't want
    to manage more servers. Which service is the best choice for them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. AWS Simple Directory Service
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. AWS Cognito
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. AWS User Pools
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. AWS AD Connector
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Review answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The customer is responsible for operating system patching and security.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a and d.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Authentication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS Secrets Manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: d.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
