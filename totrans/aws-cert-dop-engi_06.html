<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer076">
			<h1 id="_idParaDest-132"><a id="_idTextAnchor136"/>Chapter 5: Amazon DynamoDB</h1>
			<p>As application architectures demand scalability and shift focus to serverless design patterns, developers look to data stores that are flexible, scalable, and have low management overhead. DynamoDB has become a proven, trusted solution for these types of features. However, it has continued to evolve, and many of the features that sprouted from this service have relevance in the DevOps professional exam. </p>
			<p>While knowing how to calculate the read to write ratio when provisioning a DynamoDB database isn't a topic of focus in the professional-level exam, understanding how this core AWS service fits into deployments and scenarios is. Having a firm understanding of the capabilities of DynamoDB, along with its features, will help you answer the exam questions, as well as allow you to implement solutions in your career engagements. </p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Understanding the basis and background of DynamoDB</li>
				<li>Understanding DynamoDB data modeling</li>
				<li>Inserting and accessing data in DynamoDB</li>
				<li>Understanding DynamoDB Streams</li>
				<li>Using the <strong class="bold">DynamoDB accelerator </strong>(<strong class="bold">DAX</strong>) </li>
				<li>Authenticating and authorizing in DynamoDB</li>
				<li>Monitoring DynamoDB</li>
			</ul>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor137"/>Understanding the basis and background of DynamoDB</h1>
			<p>DynamoDB<a id="_idIndexMarker522"/> is a NoSQL database. This means that it is not only SQL and, more importantly, that DynamoDB doesn't need a fully structured schema to enter data. Its flexibility and performance are what drives many to DynamoDB, along with its pay-per-use pricing model and high availability and scaling. </p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor138"/>DynamoDB origins</h2>
			<p>In 2007, Amazon published<a id="_idIndexMarker523"/> a whitepaper authored by the future AWS CTO, Werner Volgels<em class="italic">,</em> and others called <em class="italic">Dynamo: Amazon's Highly Available Key-value Store</em>. </p>
			<p>You can still find this paper today at <a href="https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf">https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf</a>.</p>
			<p>As Amazon built out its e-commerce platform, it was trying to solve issues such as the following:</p>
			<ul>
				<li>Partitioning</li>
				<li>High availability for writes </li>
				<li>Handling temporary failures </li>
				<li>Recovering from permeant failures </li>
				<li>Membership and failure detection</li>
			</ul>
			<p>The databases at the time were just not performant enough, and the e-commerce website was starting to see bottlenecks, especially at the database layer. </p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor139"/>NoSQL versus relational databases </h2>
			<p>Relational databases <a id="_idIndexMarker524"/>have been around since the 1970s. Relational databases are good when you need to enforce data integrity and can structure data using<a id="_idIndexMarker525"/> the <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>). Relational databases are optimized on the premise that storage is one of your most limiting factors. Once you run out of storage or disk drive space, you will need to procure more storage space. Knowing this fact is one <a id="_idIndexMarker526"/>of the reasons for the use of primary keys and joins when using relational<a id="_idIndexMarker527"/> databases. Using the ID of the data, and then retrieving the columns of the actual data needed using table joins, allows the data to only be stored a single time, hence saving space on the systems, as shown here:</p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="Images/Figure_5.1_B17405.jpg" alt="Figure 5.1 – Relational database tables &#13;&#10;" width="1007" height="460"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – Relational database tables </p>
			<p>With storage in the cloud, storage and its associated costs are no longer a limiting factor. This brings us to NoSQL, or Non-SQL (sometimes referred to as not only SQL). Rather than storing data in tables, NoSQL systems store their data alternately, frequently, as  in the case of DynamoDB, in <strong class="source-inline">JSON</strong> documents.</p>
			<p>NoSQL databases bring about the flexibility that relational databases just can't provide. Today's modern applications, such as web apps and gaming systems, along with mobile applications, need this type of flexibility, along with the ability to scale to meet their users' needs, as well as provide high performance when retrieving and inserting the data when requested.</p>
			<p>Unlike traditional relational databases, DynamoDB is more like a key store that is extremely efficient in both retrieving and storing data.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor140"/>Core components of Dynamo</h2>
			<p>Let's take a look at<a id="_idIndexMarker528"/> the main components that DynamoDB is comprised of:</p>
			<ul>
				<li>The table and its attributes</li>
				<li>The primary key</li>
				<li>Secondary indexes</li>
			</ul>
			<p>Let's get started.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor141"/>Tables and their attributes</h2>
			<p>A <strong class="bold">table</strong> in <a id="_idIndexMarker529"/>DynamoDB is comparative to a database in other database systems, rather than just a table in relational database systems. A<a id="_idIndexMarker530"/> table is a collection of data on a specific topic. Each table in Dynamo is a separate store of items, and this is where the data is stored.</p>
			<p>Each table <a id="_idIndexMarker531"/>contains zero or more <strong class="bold">items</strong>. Items <a id="_idIndexMarker532"/>have different fields and attributes.</p>
			<p>The following is a DynamoDB table that contains items:</p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="Images/Figure_5.2_B17405.jpg" alt="Figure 5.2 – Dynamo DB table and items&#13;&#10;" width="350" height="568"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Dynamo DB table and items</p>
			<p>If you look at<a id="_idIndexMarker533"/> the preceding table, you will see a few of the following things:</p>
			<ul>
				<li>Each item has a primary key. This is the unique identifier for the item (<strong class="source-inline">CarID</strong>).</li>
				<li>There is no set schema for the items. As long as the primary key is present, any of the other attributes can or cannot be present.</li>
				<li>The majority of the attributes only have one value. However, the last item has a features field. This is a nested value that can hold multiple attributes.</li>
			</ul>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor142"/>The primary key </h2>
			<p>As you<a id="_idIndexMarker534"/> are creating a table in DynamoDB, you must specify <a id="_idIndexMarker535"/>the <strong class="bold">primary key</strong>. This primary key is a unique identifier for each item in the table, which means no two items can have the same primary key. </p>
			<p>With the primary key, you can reference distinct items in the table. DynamoDB uses the primary key as the data for its own internal hashing algorithm. This hash is used to determine which partition should be used to store the attribute.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor143"/>Secondary indexes </h2>
			<p>Secondary indexes <a id="_idIndexMarker536"/>are optional keys that can be <a id="_idIndexMarker537"/>used to query against. There are two types of secondary indexes supported by DynamoDB:</p>
			<ul>
				<li>Global secondary index </li>
				<li>Local secondary index </li>
			</ul>
			<p>We will take a deeper look at secondary indexes later in this chapter. </p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor144"/>Other pertinent Dynamo information</h2>
			<p>As you start to think about<a id="_idIndexMarker538"/> your table, it's also important to note that there isn't a single server instance or machine hosting Dynamo. Once added, the data is distributed across multiple instances, which allows the key scaling and performance features of DynamoDB to be used. Write calls do not return as successful until the data has been redundantly stored. </p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor145"/>Understanding DynamoDB data modeling</h1>
			<p>If you have ever designed a <a id="_idIndexMarker539"/>relational database, then you are familiar with schemas such as star schemas. Each table needs to have a specified attribute and if that attribute has no value, then a null is kept in its place. </p>
			<p>DynamoDB uses partitions. These partitions<a id="_idIndexMarker540"/> can be either hot partitions or cold partitions. </p>
			<p>Every item in DynamoDB requires at least one attribute, and that is the partition key. This partition key is used by Dynamo to hash your data and place it in memory. To achieve optimal performance in DynamoDB, we need to choose a partition key that allows DynamoDB to spread its searches across the disk and not let a single partition get too <em class="italic">hot</em>. </p>
			<p>This is best <a id="_idIndexMarker541"/>demonstrated with a bad example of a partition key, such as date. If you are trying to gather lots of data all from the same date, then the hash value of the single date will be stored in the same partition. Different dates may be stored across different <a id="_idIndexMarker542"/>partitions since their hash will be different; however, when querying all the events that happened on a single date, that singular partition will become hot, and this can cause performance problems. </p>
			<p>Some examples of high-quality partition keys<a id="_idIndexMarker543"/> are as follows:</p>
			<ul>
				<li>Location ID</li>
				<li>Department ID</li>
				<li>Customer ID</li>
				<li>First letter of the last name </li>
			</ul>
			<p>In the preceding examples, the data would spread across different partitions when it comes to both reading and writing, as shown here: </p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="Images/Figure_5.3_B17405.jpg" alt="Figure 5.3 – Keys evenly spread across partitions &#13;&#10;" width="383" height="208"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – Keys evenly spread across partitions </p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor146"/>Read and write capacity </h2>
			<p>When you create your table, you must specify both your read and write capacity values. Once specified, DynamoDB reserves the resources needed to handle that capacity and divides it evenly across the partitions. </p>
			<p>There are two different types of capacity units that need to be specified:</p>
			<ul>
				<li><strong class="bold">Read capacity units</strong> (<strong class="bold">RCU</strong>): This is<a id="_idIndexMarker544"/> the number of <a id="_idIndexMarker545"/>strongly consistent reads per second that your table can handle. It can contain items up to 4 KB in size. </li>
				<li><strong class="bold">Write capacity units</strong> (<strong class="bold">WCU</strong>): This <a id="_idIndexMarker546"/>is the number of<a id="_idIndexMarker547"/> consistent writes per second in 1 KB units that your table can handle.</li>
			</ul>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor147"/>Adaptive capacity </h2>
			<p>If you have a workload that is imbalanced in nature, DynamoDB has a feature called <strong class="bold">adaptive capacity</strong> that <a id="_idIndexMarker548"/>helps minimize throttling. The <a id="_idIndexMarker549"/>best part about this feature is that it is enabled for every DynamoDB table automatically at no additional cost. There is no need to go into the settings and turn an adaptive capacity setting on or off. </p>
			<p>Although you may provision 10 <strong class="bold">Write Capacity Units</strong> (<strong class="bold">WCUs</strong>) per partition, there may be one partition that is receiving more writes than the others. If the total capacity of the table has not been exceeded, then DynamoDB can use the adaptive capacity feature and allow the <em class="italic">hot</em> partition to continue to receive the writes before throttling: </p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="Images/Figure_5.4_B17405.jpg" alt="Figure 5.4 – Adaptive capacity example&#13;&#10;" width="813" height="350"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – Adaptive capacity example</p>
			<p>The preceding <a id="_idIndexMarker550"/>diagram shows an example <a id="_idIndexMarker551"/>DynamoDB table consisting of 4 partitions. When created, we allocated a total of 40 WCSs across the table. <strong class="bold">Partition 2</strong>, <strong class="bold">Partition 3</strong>, and <strong class="bold">Partition 4</strong> are only consuming 5 WCUs each, for a total of 15 WCUs, thus leaving another 25 WCUs free, as allocated from our initial provisioning. <strong class="bold">Partition 1</strong>, however, has the most activity and is consuming 15 WCUs, or 5 over the allocated 10 per partition. The adaptive capacity feature takes into account that there is extra WCU capacity and adjusts without throttling the table.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor148"/>Data types available in DynamoDB tables</h2>
			<p>DynamoDB allows<a id="_idIndexMarker552"/> various types of data to be inserted into attributes.</p>
			<p>Number, string, Boolean, binary (which would need to be <strong class="source-inline">base64-encoded</strong>), and null values are all supported data types for attributes. These are all examples of single values that can be inserted into an attribute field.</p>
			<p>DynamoDB also allows sets of items to be inserted into an attribute. These sets can contain numbers, binaries, or strings. Sets must be all of the same type, so you can't mix a set of numbers and strings, and sets do not preserve order.</p>
			<p>Somewhat like a document database, DynamoDB allows <strong class="source-inline">JSON</strong> documents to be added as attributes, and they<a id="_idIndexMarker553"/> can nest up to 32 layers deep.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">Primary keys must be either string, number, or binary. </p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor149"/>Inserting and accessing data in DynamoDB</h1>
			<p>Now that we've covered the history and theory of DynamoDB, it's time to put our hands on our keyboards and actually get into the data. </p>
			<p>For our <a id="_idIndexMarker554"/>example, we will create a fictional database to keep track of the projects at our company. This can include information such as <strong class="source-inline">ProjectID</strong>, the name of the project, who the project owner is, what the <a id="_idIndexMarker555"/>contact email is for the project or the team, and even other information such as build and language information. Since DynamoDB has a flexible schema, not all this information is needed in all the rows. We do, however, need to declare our primary key and then, depending on what we query, our secondary key. </p>
			<p>Our schema will look like the following <strong class="source-inline">JSON</strong>:</p>
			<p class="source-code">{</p>
			<p class="source-code">Project_ID,</p>
			<p class="source-code">Department, </p>
			<p class="source-code">Owner, </p>
			<p class="source-code">&lt; optional information (like language or build id) &gt;, </p>
			<p class="source-code">Contact_Email</p>
			<p class="source-code">}</p>
			<p>With our schema defined, we can start creating our table. </p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor150"/>Creating tables in Dynamo DB </h2>
			<p>We can now <a id="_idIndexMarker556"/>open up our terminal and create our table using the <a id="_idIndexMarker557"/>following command:</p>
			<p class="source-code">$aws dynamodb create-table --table-name projects \</p>
			<p class="source-code">--attribute-definitions AttributeName=Project_Name,AttributeType=S \</p>
			<p class="source-code">--key-schema AttributeName=Project_Name,KeyType=HASH \</p>
			<p class="source-code">--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 </p>
			<p>If you compare the previous command with our schema, you will notice that we have only defined one column in the table: <strong class="source-inline">Project_Name</strong>. This is because this column is our hash key (the primary index). The other fields can be defined later and are not necessary. Those fields will be populated once the data has been inserted, either in bulk or row by row. It's important to know that now, all the strings in the <strong class="source-inline">Project_Name</strong> field must be unique; otherwise, they will be rejected from being inserted as duplicate values. </p>
			<p>You may have also noticed<a id="_idIndexMarker558"/> that, at the end of the statement, we allocated five<a id="_idIndexMarker559"/> read capacity units, along with five write capacity units, to our table initially. </p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor151"/>Inserting data into DynamoDB </h2>
			<p>In the <a id="_idIndexMarker560"/>GitHub directory for this book, under <strong class="source-inline">chapter five</strong>, we have several files to upload to the table that we have created. We have three different <strong class="source-inline">JSON</strong> files to download for this exercise:</p>
			<ul>
				<li><strong class="source-inline">project_item.json</strong></li>
				<li><strong class="source-inline">projects.json</strong></li>
				<li><strong class="source-inline">projects_bulk.json</strong></li>
			</ul>
			<p>We are going to do all the inserts via the CLI. Although you can do single-line and bulk inserts in<a id="_idIndexMarker561"/> the <strong class="bold">Amazon Management Console </strong>(<strong class="bold">AMC</strong>), we want to concentrate on the ability to script our commands so that we have can automate them later, if needed. </p>
			<p>The first type of insert we are going to do is a single item insert into the table. For this, we are going to need the <strong class="source-inline">project_item.json</strong> file, so if you haven't already downloaded the file, take a look at its structure, as shown here, to see what is going on with this <strong class="source-inline">JSON</strong> file:</p>
			<p class="source-code">{</p>
			<p class="source-code">    "Project_ID": {"N": "0100"},</p>
			<p class="source-code">    "Dept": {"S": "Test Team"},</p>
			<p class="source-code">    "Dept_ID": {"N": "0001"},</p>
			<p class="source-code">    "Project_Name": {"S": "Serverless Forms"},</p>
			<p class="source-code">    "Owner": {"S": "Jerry Imoto"},</p>
			<p class="source-code">    "Builds": {"NS":  ["2212121"] },</p>
			<p class="source-code">    "Language": {"S": "python" },</p>
			<p class="source-code">    "Contact": {"S": "test_team@testcompany.com" }</p>
			<p class="source-code">}</p>
			<p>Before we upload<a id="_idIndexMarker562"/> the file, we want to look at some of the notations of the file. You'll note that the data types are notated before each field. Here, we have used string fields, notated with <strong class="source-inline">S</strong>, numerical fields, notated with <strong class="source-inline">N</strong>, and finally, for our builds, we have a numerical list denoted with <strong class="source-inline">NS</strong>. </p>
			<p>We can now open up our terminal and run the following command to add the item to the DynamoDB table that we created earlier. Make sure that you navigate to the same directory where you have downloaded the files before you run the following command: </p>
			<p class="source-code">aws dynamodb put-item \</p>
			<p class="source-code">    --table-name projects \</p>
			<p class="source-code">    --item file://project_item.json \</p>
			<p class="source-code">    --return-consumed-capacity TOTAL</p>
			<p>Once you have executed the previous command, you should get a return statement similar to the following:</p>
			<p class="source-code">{</p>
			<p class="source-code">    "ConsumedCapacity": {</p>
			<p class="source-code">        "TableName": "projects",</p>
			<p class="source-code">        "CapacityUnits": 1.0</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Congratulations! You now have an item in your DynamoDB table. Just a single item is not great for querying, however, so we need to add some more data. Adding more than a single item to a table via the CLI requires both a different command and a different format for the file that is going to be used. </p>
			<p>In the <strong class="source-inline">projects.json</strong> file, we<a id="_idIndexMarker563"/> have provided <strong class="source-inline">10</strong> items that you can quickly add to your table via the <strong class="source-inline">batch-write-item</strong> command. You'll also notice that, in the <strong class="source-inline">batch-write-item</strong> command, unlike the <strong class="source-inline">put-item</strong> command, you don't need to specify the table. This information is specified in the table itself.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor152"/>Scanning data </h2>
			<p>Now that we have<a id="_idIndexMarker564"/> loaded the test data into the table, we can use a table scan to see those data entries. A scan operation will return either all the items in a table or in the index specified. </p>
			<p>If you haven't already done so, then go back to this book's GitHub repository and download the file named <strong class="source-inline">scan-values.json</strong>, since we will be using this file in the next exercise. </p>
			<p>Go back to your terminal (or reopen it if you closed it previously) and type in the following command:</p>
			<p class="source-code">aws dynamodb scan \</p>
			<p class="source-code">    --table-name projects \</p>
			<p class="source-code">    --filter-expression "Dept = :d" \</p>
			<p class="source-code">    --expression-attribute-values file://scan-values.json </p>
			<p>We're not going to show all the output from this command, but one of the things to look at is at the bottom of the command, where it will show you the <strong class="bold">Count</strong> of the number of rows returned and the <strong class="bold">Scanned Count</strong> of the total number of rows scanned. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">This is an expensive operation in terms of reads as you are going through all the data in the table. If you know the data you need, it is much better to perform a query and only call back the items and records that you need. </p>
			<h3>What is a scan in DynamoDB?</h3>
			<p>When you execute the <strong class="source-inline">scan</strong> command<a id="_idIndexMarker565"/> in a DynamoDB<a id="_idIndexMarker566"/> table, every item in that table or secondary index gets read. If you don't specify any filter conditions, then the scan will return all the items in a single scan, so long as the results are under 1 MB of data. </p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor153"/>Querying data </h2>
			<p>What if we only <a id="_idIndexMarker567"/>want to retrieve certain values from our table? Or if we want DynamoDB to give us a count of how many records match a certain criterion? In this case, instead of using a scan, it's much more efficient to use a query.</p>
			<p>Before we start to query, make sure that you have downloaded the file from <strong class="source-inline">chapter five</strong> named <strong class="source-inline">query-values.json</strong> from this book's GitHub repository.</p>
			<p>Let's open up our terminal once again so that we can perform our query and see what results are returned: </p>
			<ol>
				<li>First, make sure that you are either in the same directory where you downloaded the <strong class="source-inline">query-values.json</strong> file, or copy the file to your current working directory. </li>
				<li>Second, make sure that you have created the <strong class="source-inline">projects</strong> DynamoDB table; otherwise, the query will not be successful. </li>
				<li>In your terminal window, type the following command:<p class="source-code"><strong class="bold">aws dynamodb query \</strong></p><p class="source-code"><strong class="bold">    --table-name projects \</strong></p><p class="source-code"><strong class="bold">    --projection-expression "Dept" \</strong></p><p class="source-code"><strong class="bold">    --key-condition-expression "Project_Name = :v1" \</strong></p><p class="source-code"><strong class="bold">    --expression-attribute-values file://query-values.json \</strong></p><p class="source-code"><strong class="bold">    --return-consumed-capacity TOTAL</strong></p><p class="source-code"><strong class="bold">You should receive a result like the following one:{</strong></p><p class="source-code"><strong class="bold">    "Items": [</strong></p><p class="source-code"><strong class="bold">        {</strong></p><p class="source-code"><strong class="bold">            "Dept": {</strong></p><p class="source-code"><strong class="bold">                "S": "Training"</strong></p><p class="source-code"><strong class="bold">            }</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code"><strong class="bold">    ],</strong></p><p class="source-code"><strong class="bold">    "Count": 1,</strong></p><p class="source-code"><strong class="bold">    "ScannedCount": 1,</strong></p><p class="source-code"><strong class="bold">    "ConsumedCapacity": {</strong></p><p class="source-code"><strong class="bold">        "TableName": "projects",</strong></p><p class="source-code"><strong class="bold">        "CapacityUnits": 0.5</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code"><strong class="bold">}</strong></p></li>
			</ol>
			<p>Notice that, in the<a id="_idIndexMarker568"/> value for <strong class="source-inline">projection-expression</strong>, we noted the fields that we wanted to return from the table. We already knew the project name (we had to because it is our primary key), so we were trying to look up what department this project belonged to. This is one of the ways that a query is much more efficient than scanning all the data when searching and returning values in DynamoDB. </p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor154"/>Secondary indexes in Dynamo, both global and local</h2>
			<p>As you may have <a id="_idIndexMarker569"/>noticed, in our previous query, we had to use the primary key when performing our command. In our table's case, we are using a primary key (<strong class="source-inline">Project_Name</strong>). A table in DynamoDB can have many different indexes, which allows your applications to have a myriad of different query patterns to use, without having to resort to the scan operation. These indexes can contain all or just a subset of the data that is included in the table. </p>
			<p class="callout-heading">Note </p>
			<p class="callout">You must declare the index in your query for DynamoDB to know that you are performing the action against that particular index. If you don't declare a specific index, then the query will go against the table itself. </p>
			<h3>Local Secondary Index (LSI) </h3>
			<p>A <strong class="bold">Local Secondary Index</strong> (<strong class="bold">LSI</strong>) gives<a id="_idIndexMarker570"/> you the opportunity to change the sort key that was originally defined in your table. LSIs must always use<a id="_idIndexMarker571"/> the same primary key as the table where it was created. </p>
			<p>LSIs also share the same throughput as the table it was created on. As a final note about LSIs, they <strong class="bold">can only</strong> be created at the time of table creation. If you did not create one when you created your table, you either need to drop and recreate your table, create a new table and then migrate your data, or use a <strong class="bold">Global Secondary Index</strong> (<strong class="bold">GSI</strong>) instead. Also, you can't delete a local secondary index without deleting the base table. </p>
			<h3>GSI </h3>
			<p>If we wanted to<a id="_idIndexMarker572"/> use a different primary key to search with, then we would have to create a GSI. Another key difference between GSIs and LSIs is that unlike LSIs, which have to be declared and created at the same time as when the table is being created, a GSI can be created at any point in time. This is especially helpful if you notice that either your queries are not requesting the right <a id="_idIndexMarker573"/>information, in which case you only want to bring back a subset of the information that you could store in the GSI, or a certain subset of queries that you are requesting need to have more RCUs or WCUs allocated. </p>
			<p>Now, if we wanted to see our GSI after creating it, we could run the following command:</p>
			<p class="source-code">aws dynamodb describe-table \</p>
			<p class="source-code">    --table-name projects \</p>
			<p class="source-code">    --query "Table.GlobalSecondaryIndexes"</p>
			<p>This will show us any GSIs, if any, that have been created on our table. </p>
			<p>Understanding how to create indexes for optimal query performance is one of the key concepts to harnessing the power of DynamoDB. Next, we will move on to other features that DynamoDB can provide, such as replicating items using streams. </p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor155"/>Understanding DynamoDB Streams </h1>
			<p>There may be times when you have a table in DynamoDB and you want to either be updated when a change comes in or have an event-driven process happen. This was the exact reason why AWS created <strong class="bold">Dynamo Streams</strong>. Streams are a time-ordered sequence of item<a id="_idIndexMarker574"/> modifications, such as insert, update, and delete operations. </p>
			<p>When a stream in DynamoDB writes data, it does so in a strict ordering format. This means that as you write data to the table, pending the configuration settings you have set for the stream, it will push out the items in the same order in which they were written to the table.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor156"/>Global tables </h2>
			<p>There are times when you need to either have a high availability plan in place in case of a regional outage for a service such as DynamoDB, or must have quicker local access to your data from another region besides where you originally created your data. </p>
			<p>Global Tables, even <a id="_idIndexMarker575"/>though they are replicas of an origin table, are all owned by a single account. </p>
			<p>When setting up a global table, the first step is to create an initial table in your primary region.</p>
			<p>Then, you need to enable DB Streams on that initial table. </p>
			<p>Next, for every region where you want to replicate your global table, you must set up that same table with streaming enabled in a different region. </p>
			<p>Then, in the original region, you can define the global table's setup, which is made easy by the AWS Management Console.</p>
			<p>If there are requirements in your organization to maintain a certain level of uptime that has been<a id="_idIndexMarker576"/> relayed via <strong class="bold">service-level agreements</strong> (<strong class="bold">SLAs</strong>), then you can take care of this using a combination of Streams and Global Tables. Next, we will examine how to speed up query time in DynamoDB by using the DynamoDB accelerator. </p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor157"/>Using the DynamoDB accelerator (DAX) </h1>
			<p>DynamoDB, by<a id="_idIndexMarker577"/> itself, even with thousands of requests, can deliver millisecond latency response times. This satisfies the needs of many companies and customers, but there are some applications that need microsecond performance, and this is where <strong class="bold">DynamoDB Accelerator</strong> (<strong class="bold">DAX</strong>) comes into focus. </p>
			<p>DAX is almost equivalent to a turbo button for your DynamoDB table. It caches the most frequently requested results and then makes them available via an endpoint. There is no need to spin up a third-party cache, no need to manage nodes, and it's as easy to implement. You simply go to the DAX menu under the main DynamoDB page and then spin up your DAX cluster: </p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="Images/Figure_5.5_B17405.jpg" alt="Figure 5.5 – DAX example architecture&#13;&#10;" width="563" height="236"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – DAX example architecture</p>
			<p>Industries such as Ad-Tech can utilize the caching properties and speed of DAX when designing and implementing their systems to go out and place bids for digital advertising real estate. Those millisecond latencies in placing bids can equate to real dollars in that industry. </p>
			<p>Knowing how to<a id="_idIndexMarker578"/> handle queries in DynamoDB that are taking longer than expected is what we just covered with DAX's caching abilities. Now, we will look at how to authorize access in DynamoDB.</p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor158"/>Authenticating and authorizing in DynamoDB</h1>
			<p>As with other<a id="_idIndexMarker579"/> services in AWS, Dynamo DB allows fine-grained<a id="_idIndexMarker580"/> access control via the IAM service. You can either allow<a id="_idIndexMarker581"/> or disallow users at the service, table, or<a id="_idIndexMarker582"/> attribute level, depending on how you have structured your IAM policies. </p>
			<p>AWS recommends, as a best practice, that you use the principle of least privilege and only allow users to access the data in the tables that they require versus blanket access. </p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor159"/>Web Identity Federation</h2>
			<p>DynamoDB is an <a id="_idIndexMarker583"/>especially popular backend database for mobile and game developers. This can result in thousands of users needing to access even a single table. In this use case scenario, it is impractical to try to create an IAM user for each and every user: </p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="Images/Figure_5.6_B17405.jpg" alt="Figure 5.6 – Web Identity Federation to a DynamoDB table&#13;&#10;" width="555" height="313"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6 – Web Identity Federation to a DynamoDB table</p>
			<p>The best way to<a id="_idIndexMarker584"/> understand how users who are authenticating via a web identity provider, such as <em class="italic">Facebook</em> or <em class="italic">Google</em>, gain access to data in a DynamoDB table is to look at the steps that it takes to grant authorization:</p>
			<ol>
				<li value="1">The application authenticates to a web identity provider such as Amazon. That identity provider then returns an identity token. </li>
				<li>The application then calls the security token service to gain a temporary access credential based on a role that has been previously defined. </li>
				<li>That role should give access to not just the full DynamoDB table, but the user's items via the IAM policy.</li>
			</ol>
			<p>As DynamoDB is the preferred data store for mobile applications hosted on AWS, we looked at how to authorize web identity users to access specific data using a combination of IAM and STS tokens. Next, we will move on to monitoring our DynamoDB tables to make sure that we don't get caught off guard by throttles.</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor160"/>Monitoring DynamoDB </h1>
			<p>When you look<a id="_idIndexMarker585"/> at what metrics you need to concentrate on when monitoring DynamoDB, there are a few that come into focus:</p>
			<ul>
				<li>Our <strong class="source-inline">GET</strong> and <strong class="source-inline">PUT</strong> requests are in the range of what we expected</li>
				<li>We are not being throttled by either read or write capacity</li>
			</ul>
			<p>From the DynamoDB console itself, we can get quite a few metrics regarding our table's health. </p>
			<p>First, we can see both read and write capacity at a glance.</p>
			<p>There is also a section in the metrics of any table that you choose for basic latency showing four areas of interest: <strong class="source-inline">GET</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">Query</strong>, and <strong class="source-inline">Scan Latency</strong>. </p>
			<p>Let's log in to the <strong class="bold">Amazon Management Console</strong> and take a look at these basic metrics for ourselves: </p>
			<ol>
				<li value="1">Log in to the <strong class="bold">Amazon Management Console</strong> using the account you previously created for the projects table in DynamoDB.</li>
				<li>In the search box at the top, type <strong class="source-inline">DynamoDB</strong> so that the service name appears in the results. Click <strong class="bold">DynamoDB</strong> to be taken to the DynamoDB service. On the top-right-hand side, double-check that you are in the correct region where you created the table. </li>
				<li>Once you are at the main DynamoDB screen, click <strong class="bold">Tables</strong> on the left-hand side menu. Once clicked, you should see the table you created earlier, named <strong class="bold">projects</strong>: <div id="_idContainer074" class="IMG---Figure"><img src="Images/Figure_5.7_B17405.jpg" alt="Figure 5.7 – Showing the DynamoDB Tables menu option on the left-hand menu&#13;&#10;" width="917" height="167"/></div><p class="figure-caption">Figure 5.7 – Showing the DynamoDB Tables menu option on the left-hand menu</p></li>
				<li>Click on the table named <strong class="bold">Projects</strong> in the main window. This will open another pane, adding more information about your table. </li>
				<li>From here, we can<a id="_idIndexMarker586"/> select the <strong class="bold">metrics</strong> tab from the top tab bar in the rightmost pane: <div id="_idContainer075" class="IMG---Figure"><img src="Images/Figure_5.8_B17405.jpg" alt="Figure 5.8 – The top menu bar once in the DynamoDB table &#13;&#10;" width="1227" height="62"/></div><p class="figure-caption">Figure 5.8 – The top menu bar once in the DynamoDB table </p></li>
				<li>If, in the <strong class="bold">metrics</strong> display, you don't see much activity, then try running the queries from the CLI that we created previously in this chapter. This should prompt the metrics meters to start showing more PUT and GET objects of the data. </li>
			</ol>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor161"/>Contributor Insights</h2>
			<p>Enabling <strong class="bold">Contributor Insights</strong> for <a id="_idIndexMarker587"/>your DynamoDB <a id="_idIndexMarker588"/>table allows you to gain much better insight into the items that are being accessed and throttled. This allows you to make adjustments to your table or schema accordingly, if needed. </p>
			<p>Once you have enabled <strong class="bold">Contributor Insights</strong>, DynamoDB creates two rules on your behalf if you only have a primary key:</p>
			<ul>
				<li>Most accessed items (partition key) </li>
				<li>Most throttled keys (partition key) </li>
			</ul>
			<p>If you have a global secondary index or sort key, there will be two additional rules created for you by DynamoDB. These are specific to secondary indexes:</p>
			<ul>
				<li>Most accessed keys (partition and sort keys) </li>
				<li>Most throttled keys (partition and sort keys)</li>
			</ul>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor162"/>Summary</h1>
			<p>In this chapter, we looked at the NoSQL service known as DynamoDB. We explored how tables are created and partitioned, along with how to write and query data from DynamoDB. We also examined how to stream data from tables to other sources, along with using the <strong class="bold">DynamoDB Accelerator</strong> (<strong class="bold">DAX</strong>), a specialized cache, to help speed up our queries.</p>
			<p>We have now finished Part 1, <em class="italic">Establishing Fundamentals</em>, where we reviewed <strong class="bold">Amazon Web Services</strong>. Next, we will move on to <em class="italic">Part 2</em>, <em class="italic">Developing, Deploying, and Using Infrastructure as Code</em>. In the upcoming chapters, we will incorporate many of the services that we have just discussed and then put them into action. </p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor163"/>Review questions </h1>
			<ol>
				<li value="1">Our application is storing project data in a DynamoDB table. You need to run a query to find all the builds that were run by a specific department last month. Which attributes would you use in your query?<p>a. The partition key of <strong class="source-inline">Build_Date</strong> and the sort key of <strong class="source-inline">Department</strong></p><p>b. A composite primary key made up of <strong class="source-inline">Department</strong> and <strong class="source-inline">Build_Date</strong></p><p>c. The partition key of <strong class="source-inline">Department</strong> and the sort key of <strong class="source-inline">Build_Date</strong></p><p>d. The partition key of <strong class="source-inline">Build_Date</strong> and the sort key of <strong class="source-inline">Dept_ID</strong> </p></li>
				<li>Which of the following AWS services provides an in-memory write-through cache that has been optimized for DynamoDB?<p>a. ElastiCache</p><p>b. CloudFront</p><p>c. DAX</p><p>d. Athena </p></li>
				<li>A scan operation in DynamoDB is used for which of the following scenarios?<p>a. To return the entire contents of the table, filtered on the primary or sort key</p><p>b. To find items in a table based on a primary key attribute </p><p>c. To find items in a table based on a sort key attribute</p><p>d. To return all the items in a table </p></li>
				<li>Your developers have created a DynamoDB table and seem to find that the performance always slows down after 20-25 minutes of their testing process. They can see from the basic monitoring on the AWS console that their requests are being throttled. What can you do to help pinpoint the issue?<p>a. Increase the <strong class="bold">Read Capacity Units</strong> (<strong class="bold">RCUs</strong>) on the table so that the queries are no longer throttled.</p><p>b. Enable <strong class="bold">Contributor Insights</strong> on the table so that the keys that are being throttled the most are shown. </p><p>c. Add enhanced <strong class="bold">Cloud Watch</strong> monitoring with alarms whenever throttling occurs. </p><p>d. Add <strong class="bold">adaptive capacity</strong> to the table so that the extra <strong class="bold">Read Capacity Units</strong> (<strong class="bold">RCUs</strong>) are spread evenly across partitions that are becoming hot. </p></li>
				<li>Which of the following items would make a good partition key?<p><strong class="source-inline">a.</strong> <strong class="source-inline">OrderID </strong></p><p><strong class="source-inline">b.</strong> <strong class="source-inline">Ship_From_Location</strong></p><p><strong class="source-inline">c.</strong> <strong class="source-inline">Total</strong></p><p><strong class="source-inline">d.</strong> <strong class="source-inline">Product_Brand</strong></p></li>
			</ol>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor164"/>Review answers </h1>
			<ol>
				<li value="1">b </li>
				<li>c</li>
				<li>d</li>
				<li>b</li>
				<li>a</li>
			</ol>
		</div>
	</div></body></html>