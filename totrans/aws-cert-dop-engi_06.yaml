- en: 'Chapter 5: Amazon DynamoDB'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章：Amazon DynamoDB
- en: As application architectures demand scalability and shift focus to serverless
    design patterns, developers look to data stores that are flexible, scalable, and
    have low management overhead. DynamoDB has become a proven, trusted solution for
    these types of features. However, it has continued to evolve, and many of the
    features that sprouted from this service have relevance in the DevOps professional
    exam.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用架构对可扩展性的需求增加，并将重点转向无服务器设计模式，开发人员开始寻找灵活、可扩展且管理开销低的数据存储。DynamoDB 已成为满足这些特性需求的一个经过验证且值得信赖的解决方案。然而，它一直在不断发展，许多从该服务衍生出来的功能在
    DevOps 专业认证考试中具有重要意义。
- en: While knowing how to calculate the read to write ratio when provisioning a DynamoDB
    database isn't a topic of focus in the professional-level exam, understanding
    how this core AWS service fits into deployments and scenarios is. Having a firm
    understanding of the capabilities of DynamoDB, along with its features, will help
    you answer the exam questions, as well as allow you to implement solutions in
    your career engagements.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在专业级考试中，计算 DynamoDB 数据库的读写比率并不是重点，但理解该核心 AWS 服务如何融入部署和场景是非常重要的。对 DynamoDB
    的功能和特性有扎实的理解，将帮助你回答考试问题，也能帮助你在职业生涯中实施解决方案。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding the basis and background of DynamoDB
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 DynamoDB 的基础和背景
- en: Understanding DynamoDB data modeling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 DynamoDB 数据建模
- en: Inserting and accessing data in DynamoDB
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 DynamoDB 中插入和访问数据
- en: Understanding DynamoDB Streams
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 DynamoDB 流
- en: Using the **DynamoDB accelerator** (**DAX**)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **DynamoDB 加速器** (**DAX**)
- en: Authenticating and authorizing in DynamoDB
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 DynamoDB 中进行身份验证和授权
- en: Monitoring DynamoDB
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控 DynamoDB
- en: Understanding the basis and background of DynamoDB
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 DynamoDB 的基础和背景
- en: DynamoDB is a NoSQL database. This means that it is not only SQL and, more importantly,
    that DynamoDB doesn't need a fully structured schema to enter data. Its flexibility
    and performance are what drives many to DynamoDB, along with its pay-per-use pricing
    model and high availability and scaling.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: DynamoDB 是一个 NoSQL 数据库。这意味着它不仅仅是 SQL，更重要的是，DynamoDB 不需要完全结构化的模式来插入数据。它的灵活性和性能是许多人选择
    DynamoDB 的原因，此外，还有其按需付费的定价模式以及高可用性和可扩展性。
- en: DynamoDB origins
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DynamoDB 的起源
- en: 'In 2007, Amazon published a whitepaper authored by the future AWS CTO, Werner
    Volgels*,* and others called *Dynamo: Amazon''s Highly Available Key-value Store*.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '在 2007 年，亚马逊发布了一篇由未来 AWS 首席技术官 Werner Vogels 和其他人共同撰写的白皮书，名为 *Dynamo: Amazon
    的高可用键值存储*。'
- en: You can still find this paper today at [https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf](https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然可以在今天找到这篇论文，链接在这里：[https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf](https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf)。
- en: 'As Amazon built out its e-commerce platform, it was trying to solve issues
    such as the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当亚马逊构建其电商平台时，试图解决如下问题：
- en: Partitioning
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区
- en: High availability for writes
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写操作的高可用性
- en: Handling temporary failures
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理临时故障
- en: Recovering from permeant failures
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从永久故障中恢复
- en: Membership and failure detection
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员资格和故障检测
- en: The databases at the time were just not performant enough, and the e-commerce
    website was starting to see bottlenecks, especially at the database layer.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当时的数据库性能不够强大，电商网站开始在数据库层面遇到瓶颈。
- en: NoSQL versus relational databases
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NoSQL 与关系型数据库
- en: 'Relational databases have been around since the 1970s. Relational databases
    are good when you need to enforce data integrity and can structure data using
    the **Structured Query Language** (**SQL**). Relational databases are optimized
    on the premise that storage is one of your most limiting factors. Once you run
    out of storage or disk drive space, you will need to procure more storage space.
    Knowing this fact is one of the reasons for the use of primary keys and joins
    when using relational databases. Using the ID of the data, and then retrieving
    the columns of the actual data needed using table joins, allows the data to only
    be stored a single time, hence saving space on the systems, as shown here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库自1970年代以来就存在。当你需要强制数据完整性并使用**结构化查询语言**（**SQL**）来组织数据时，关系型数据库是非常合适的。关系型数据库的优化基于存储是你最有限的资源这一前提。一旦存储或磁盘空间用尽，你就需要购买更多的存储空间。知道这一点是使用关系型数据库时采用主键和连接的原因之一。通过使用数据的ID，然后通过表连接检索实际需要的列，数据可以只存储一次，从而节省系统的存储空间，如下所示：
- en: '![Figure 5.1 – Relational database tables'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 – 关系型数据库表'
- en: '](img/Figure_5.1_B17405.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.1_B17405.jpg)'
- en: Figure 5.1 – Relational database tables
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 关系型数据库表
- en: With storage in the cloud, storage and its associated costs are no longer a
    limiting factor. This brings us to NoSQL, or Non-SQL (sometimes referred to as
    not only SQL). Rather than storing data in tables, NoSQL systems store their data
    alternately, frequently, as in the case of DynamoDB, in `JSON` documents.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云存储的普及，存储及其相关成本不再是限制性因素。这就引出了NoSQL，或称非SQL（有时称为不仅仅是SQL）。与其将数据存储在表中，NoSQL系统则采用不同的方式存储数据，常见的如DynamoDB，它将数据存储在`JSON`文档中。
- en: NoSQL databases bring about the flexibility that relational databases just can't
    provide. Today's modern applications, such as web apps and gaming systems, along
    with mobile applications, need this type of flexibility, along with the ability
    to scale to meet their users' needs, as well as provide high performance when
    retrieving and inserting the data when requested.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库提供了关系型数据库无法提供的灵活性。如今的现代应用程序，如Web应用、游戏系统和移动应用，都需要这种灵活性，同时需要具备可扩展性，以满足用户需求，并在检索和插入数据时提供高性能。
- en: Unlike traditional relational databases, DynamoDB is more like a key store that
    is extremely efficient in both retrieving and storing data.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的关系型数据库不同，DynamoDB更像一个键值存储，它在数据的检索和存储方面非常高效。
- en: Core components of Dynamo
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dynamo的核心组件
- en: 'Let''s take a look at the main components that DynamoDB is comprised of:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下DynamoDB的主要组成部分：
- en: The table and its attributes
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表及其属性
- en: The primary key
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主键
- en: Secondary indexes
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 次级索引
- en: Let's get started.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Tables and their attributes
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表及其属性
- en: A **table** in DynamoDB is comparative to a database in other database systems,
    rather than just a table in relational database systems. A table is a collection
    of data on a specific topic. Each table in Dynamo is a separate store of items,
    and this is where the data is stored.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: DynamoDB中的**表**类似于其他数据库系统中的数据库，而不仅仅是关系型数据库系统中的表。一个表是关于某一特定主题的数据集合。Dynamo中的每个表都是单独存储项目的地方，数据就存储在这里。
- en: Each table contains zero or more **items**. Items have different fields and
    attributes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每个表包含零个或多个**项目**。项目有不同的字段和属性。
- en: 'The following is a DynamoDB table that contains items:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个包含项目的DynamoDB表：
- en: '![Figure 5.2 – Dynamo DB table and items'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2 – Dynamo DB表和项目'
- en: '](img/Figure_5.2_B17405.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.2_B17405.jpg)'
- en: Figure 5.2 – Dynamo DB table and items
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – Dynamo DB表和项目
- en: 'If you look at the preceding table, you will see a few of the following things:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看上面的表格，你会看到以下几点：
- en: Each item has a primary key. This is the unique identifier for the item (`CarID`).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个项目都有一个主键。这是该项目的唯一标识符（`CarID`）。
- en: There is no set schema for the items. As long as the primary key is present,
    any of the other attributes can or cannot be present.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目没有固定的模式。只要主键存在，其他任何属性可以存在，也可以不存在。
- en: The majority of the attributes only have one value. However, the last item has
    a features field. This is a nested value that can hold multiple attributes.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数属性只有一个值。然而，最后一项有一个特性字段。这是一个嵌套值，可以包含多个属性。
- en: The primary key
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主键
- en: As you are creating a table in DynamoDB, you must specify the **primary key**.
    This primary key is a unique identifier for each item in the table, which means
    no two items can have the same primary key.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 DynamoDB 表时，必须指定**主键**。这个主键是每个表项的唯一标识符，这意味着没有两个项可以拥有相同的主键。
- en: With the primary key, you can reference distinct items in the table. DynamoDB
    uses the primary key as the data for its own internal hashing algorithm. This
    hash is used to determine which partition should be used to store the attribute.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用主键，你可以引用表中的不同项。DynamoDB 使用主键作为其内部哈希算法的数据。这个哈希值用来确定应该使用哪个分区来存储该属性。
- en: Secondary indexes
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二级索引
- en: 'Secondary indexes are optional keys that can be used to query against. There
    are two types of secondary indexes supported by DynamoDB:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 二级索引是可选的键，可以用来进行查询。DynamoDB 支持两种类型的二级索引：
- en: Global secondary index
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局二级索引
- en: Local secondary index
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地二级索引
- en: We will take a deeper look at secondary indexes later in this chapter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面深入探讨二级索引。
- en: Other pertinent Dynamo information
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他相关的 Dynamo 信息
- en: As you start to think about your table, it's also important to note that there
    isn't a single server instance or machine hosting Dynamo. Once added, the data
    is distributed across multiple instances, which allows the key scaling and performance
    features of DynamoDB to be used. Write calls do not return as successful until
    the data has been redundantly stored.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始思考你的表时，重要的是要注意，Dynamo 并不是由单一的服务器实例或机器托管的。一旦添加数据，它会分布到多个实例中，这使得 DynamoDB
    可以利用其关键的扩展性和性能特点。写操作在数据被冗余存储之前不会被认为成功。
- en: Understanding DynamoDB data modeling
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 DynamoDB 数据建模
- en: If you have ever designed a relational database, then you are familiar with
    schemas such as star schemas. Each table needs to have a specified attribute and
    if that attribute has no value, then a null is kept in its place.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经设计过关系型数据库，那么你会熟悉诸如星型模式这样的架构。每个表都需要有一个指定的属性，如果该属性没有值，那么会保留一个空值。
- en: DynamoDB uses partitions. These partitions can be either hot partitions or cold
    partitions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: DynamoDB 使用分区。这些分区可以是热分区，也可以是冷分区。
- en: Every item in DynamoDB requires at least one attribute, and that is the partition
    key. This partition key is used by Dynamo to hash your data and place it in memory.
    To achieve optimal performance in DynamoDB, we need to choose a partition key
    that allows DynamoDB to spread its searches across the disk and not let a single
    partition get too *hot*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: DynamoDB 中的每个项目至少需要一个属性，即分区键。Dynamo 使用该分区键对数据进行哈希并将其放置在内存中。为了在 DynamoDB 中实现最佳性能，我们需要选择一个能够使
    DynamoDB 将搜索分散到磁盘上的分区键，而不是让单个分区过于*热点*。
- en: This is best demonstrated with a bad example of a partition key, such as date.
    If you are trying to gather lots of data all from the same date, then the hash
    value of the single date will be stored in the same partition. Different dates
    may be stored across different partitions since their hash will be different;
    however, when querying all the events that happened on a single date, that singular
    partition will become hot, and this can cause performance problems.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这最好通过一个不好的分区键示例来演示，比如日期。如果你尝试收集所有来自同一天的数据，那么这个日期的哈希值将存储在同一个分区中。不同的日期可能会存储在不同的分区中，因为它们的哈希值不同；然而，当查询某一天发生的所有事件时，这个单一的分区将变得过热，这可能会导致性能问题。
- en: 'Some examples of high-quality partition keys are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 高质量分区键的示例如下：
- en: Location ID
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置 ID
- en: Department ID
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部门 ID
- en: Customer ID
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户 ID
- en: First letter of the last name
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 姓氏的首字母
- en: 'In the preceding examples, the data would spread across different partitions
    when it comes to both reading and writing, as shown here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，数据在读取和写入时会分布到不同的分区，如下所示：
- en: '![Figure 5.3 – Keys evenly spread across partitions'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.3 – 键均匀分布在分区中'
- en: '](img/Figure_5.3_B17405.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.3_B17405.jpg)'
- en: Figure 5.3 – Keys evenly spread across partitions
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 键均匀分布在分区中
- en: Read and write capacity
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取和写入容量
- en: When you create your table, you must specify both your read and write capacity
    values. Once specified, DynamoDB reserves the resources needed to handle that
    capacity and divides it evenly across the partitions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 创建表时，必须同时指定读和写容量值。一旦指定，DynamoDB 将保留处理该容量所需的资源，并将其平均分配到各个分区。
- en: 'There are two different types of capacity units that need to be specified:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指定两种不同类型的容量单位：
- en: '**Read capacity units** (**RCU**): This is the number of strongly consistent
    reads per second that your table can handle. It can contain items up to 4 KB in
    size.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读取容量单位**（**RCU**）：这是您的表每秒可以处理的强一致性读取次数。它可以包含最大 4 KB 大小的项。'
- en: '**Write capacity units** (**WCU**): This is the number of consistent writes
    per second in 1 KB units that your table can handle.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**写容量单位**（**WCU**）：这是您的表每秒可以处理的每 1 KB 单位的写入次数。'
- en: Adaptive capacity
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自适应容量
- en: If you have a workload that is imbalanced in nature, DynamoDB has a feature
    called **adaptive capacity** that helps minimize throttling. The best part about
    this feature is that it is enabled for every DynamoDB table automatically at no
    additional cost. There is no need to go into the settings and turn an adaptive
    capacity setting on or off.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的工作负载本质上不平衡，DynamoDB 提供了一个名为 **自适应容量** 的功能，帮助最大限度减少限流。这个功能的最佳之处在于，它会自动为每个
    DynamoDB 表启用，无需额外费用。您无需进入设置去打开或关闭自适应容量设置。
- en: 'Although you may provision 10 **Write Capacity Units** (**WCUs**) per partition,
    there may be one partition that is receiving more writes than the others. If the
    total capacity of the table has not been exceeded, then DynamoDB can use the adaptive
    capacity feature and allow the *hot* partition to continue to receive the writes
    before throttling:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以为每个分区预配置 10 个 **写容量单位**（**WCUs**），但可能会有一个分区的写入操作比其他分区更多。如果表的总容量没有被超出，那么
    DynamoDB 可以使用自适应容量功能，允许 *热* 分区继续接收写入，而不进行限流：
- en: '![Figure 5.4 – Adaptive capacity example'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4 – 自适应容量示例'
- en: '](img/Figure_5.4_B17405.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.4_B17405.jpg)'
- en: Figure 5.4 – Adaptive capacity example
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 自适应容量示例
- en: The preceding diagram shows an example DynamoDB table consisting of 4 partitions.
    When created, we allocated a total of 40 WCSs across the table. **Partition 2**,
    **Partition 3**, and **Partition 4** are only consuming 5 WCUs each, for a total
    of 15 WCUs, thus leaving another 25 WCUs free, as allocated from our initial provisioning.
    **Partition 1**, however, has the most activity and is consuming 15 WCUs, or 5
    over the allocated 10 per partition. The adaptive capacity feature takes into
    account that there is extra WCU capacity and adjusts without throttling the table.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上图显示了一个包含 4 个分区的 DynamoDB 表的示例。创建时，我们为整个表分配了 40 个 WCS（写容量单位）。**分区 2**、**分区 3**
    和 **分区 4** 每个只消耗了 5 个 WCUs，总共消耗了 15 个 WCUs，剩余的 25 个 WCUs 是从我们初始预配置中分配的。**分区 1**
    则有最多的活动，消耗了 15 个 WCUs，比每个分区分配的 10 个 WCU 超出了 5 个。自适应容量功能考虑到还有额外的 WCU 容量，并在不限制表的情况下进行调整。
- en: Data types available in DynamoDB tables
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DynamoDB 表中可用的数据类型
- en: DynamoDB allows various types of data to be inserted into attributes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: DynamoDB 允许将各种类型的数据插入到属性中。
- en: Number, string, Boolean, binary (which would need to be `base64-encoded`), and
    null values are all supported data types for attributes. These are all examples
    of single values that can be inserted into an attribute field.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 数字、字符串、布尔值、二进制数据（需要 `base64 编码`）和空值都是支持的属性数据类型。这些都是可以插入到属性字段中的单一值示例。
- en: DynamoDB also allows sets of items to be inserted into an attribute. These sets
    can contain numbers, binaries, or strings. Sets must be all of the same type,
    so you can't mix a set of numbers and strings, and sets do not preserve order.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: DynamoDB 还允许将一组项插入到属性中。这些集合可以包含数字、二进制数据或字符串。集合必须是相同类型的，因此不能将数字和字符串混合在一个集合中，且集合不保留顺序。
- en: Somewhat like a document database, DynamoDB allows `JSON` documents to be added
    as attributes, and they can nest up to 32 layers deep.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于文档数据库，DynamoDB 允许将 `JSON` 文档作为属性添加，并且这些文档可以最多嵌套 32 层。
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Primary keys must be either string, number, or binary.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 主键必须是字符串、数字或二进制。
- en: Inserting and accessing data in DynamoDB
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 DynamoDB 中插入和访问数据
- en: Now that we've covered the history and theory of DynamoDB, it's time to put
    our hands on our keyboards and actually get into the data.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了 DynamoDB 的历史和理论，接下来是时候动手操作，真正开始处理数据了。
- en: For our example, we will create a fictional database to keep track of the projects
    at our company. This can include information such as `ProjectID`, the name of
    the project, who the project owner is, what the contact email is for the project
    or the team, and even other information such as build and language information.
    Since DynamoDB has a flexible schema, not all this information is needed in all
    the rows. We do, however, need to declare our primary key and then, depending
    on what we query, our secondary key.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将创建一个虚构的数据库，用来跟踪我们公司中的项目。这些信息可能包括 `ProjectID`、项目名称、项目负责人、项目或团队的联系邮箱，甚至其他信息如构建和语言信息。由于
    DynamoDB 具有灵活的模式，并非所有行都需要这些信息。然而，我们确实需要声明我们的主键，然后根据查询需求，再声明次级键。
- en: 'Our schema will look like the following `JSON`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模式将如下所示 `JSON`：
- en: '[PRE0]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With our schema defined, we can start creating our table.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 定义好我们的模式后，我们可以开始创建表格。
- en: Creating tables in Dynamo DB
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 DynamoDB 中创建表格
- en: 'We can now open up our terminal and create our table using the following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以打开终端，使用以下命令创建我们的表格：
- en: '[PRE1]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you compare the previous command with our schema, you will notice that we
    have only defined one column in the table: `Project_Name`. This is because this
    column is our hash key (the primary index). The other fields can be defined later
    and are not necessary. Those fields will be populated once the data has been inserted,
    either in bulk or row by row. It''s important to know that now, all the strings
    in the `Project_Name` field must be unique; otherwise, they will be rejected from
    being inserted as duplicate values.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将之前的命令与我们的模式进行对比，你会发现我们只定义了一个列：`Project_Name`。这是因为这个列是我们的哈希键（主索引）。其他字段可以稍后定义，不是必须的。这些字段将在数据插入后，无论是批量插入还是逐行插入时填充。需要注意的是，现在
    `Project_Name` 字段中的所有字符串必须是唯一的，否则它们将因为重复值而被拒绝插入。
- en: You may have also noticed that, at the end of the statement, we allocated five
    read capacity units, along with five write capacity units, to our table initially.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到，在语句的末尾，我们为表格最初分配了五个读取容量单位和五个写入容量单位。
- en: Inserting data into DynamoDB
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向 DynamoDB 插入数据
- en: 'In the GitHub directory for this book, under `chapter five`, we have several
    files to upload to the table that we have created. We have three different `JSON`
    files to download for this exercise:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的 GitHub 目录下，在 `chapter five` 中，我们有几个文件需要上传到我们创建的表格中。为了这个练习，我们需要下载三个不同的 `JSON`
    文件：
- en: '`project_item.json`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`project_item.json`'
- en: '`projects.json`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`projects.json`'
- en: '`projects_bulk.json`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`projects_bulk.json`'
- en: We are going to do all the inserts via the CLI. Although you can do single-line
    and bulk inserts in the **Amazon Management Console** (**AMC**), we want to concentrate
    on the ability to script our commands so that we have can automate them later,
    if needed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过 CLI 执行所有插入操作。虽然你可以在 **Amazon 管理控制台** (**AMC**) 中进行单行和批量插入，但我们希望集中精力编写脚本命令，以便将来在需要时可以自动化执行。
- en: 'The first type of insert we are going to do is a single item insert into the
    table. For this, we are going to need the `project_item.json` file, so if you
    haven''t already downloaded the file, take a look at its structure, as shown here,
    to see what is going on with this `JSON` file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行的第一种插入操作是将单个项目插入到表中。为此，我们需要 `project_item.json` 文件，如果你还没有下载该文件，请查看它的结构，如下所示，看看这个
    `JSON` 文件的内容：
- en: '[PRE2]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Before we upload the file, we want to look at some of the notations of the file.
    You'll note that the data types are notated before each field. Here, we have used
    string fields, notated with `S`, numerical fields, notated with `N`, and finally,
    for our builds, we have a numerical list denoted with `NS`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在上传文件之前，我们想先查看一下文件的一些标注。你会注意到每个字段前都有数据类型标注。这里我们使用了字符串类型字段，标注为 `S`，数值类型字段标注为
    `N`，最后，对于我们的构建，使用 `NS` 来表示一个数值列表。
- en: 'We can now open up our terminal and run the following command to add the item
    to the DynamoDB table that we created earlier. Make sure that you navigate to
    the same directory where you have downloaded the files before you run the following
    command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以打开终端，运行以下命令将项目添加到我们之前创建的 DynamoDB 表格中。在运行以下命令之前，请确保你已导航到下载文件所在的目录：
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once you have executed the previous command, you should get a return statement
    similar to the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完上述命令后，你应该会收到类似以下内容的返回信息：
- en: '[PRE4]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Congratulations! You now have an item in your DynamoDB table. Just a single
    item is not great for querying, however, so we need to add some more data. Adding
    more than a single item to a table via the CLI requires both a different command
    and a different format for the file that is going to be used.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！现在你在 DynamoDB 表中已经有了一个项。不过，仅有一个项对于查询来说并不理想，因此我们需要添加更多数据。通过 CLI 向表格添加多于一个项需要使用不同的命令和文件格式。
- en: In the `projects.json` file, we have provided `10` items that you can quickly
    add to your table via the `batch-write-item` command. You'll also notice that,
    in the `batch-write-item` command, unlike the `put-item` command, you don't need
    to specify the table. This information is specified in the table itself.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`projects.json`文件中，我们提供了`10`项，你可以通过`batch-write-item`命令将它们快速添加到表中。你还会注意到，在`batch-write-item`命令中，与`put-item`命令不同，你不需要指定表格。这个信息已经在表格中指定。
- en: Scanning data
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扫描数据
- en: Now that we have loaded the test data into the table, we can use a table scan
    to see those data entries. A scan operation will return either all the items in
    a table or in the index specified.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将测试数据加载到表格中，我们可以使用表扫描来查看这些数据项。扫描操作将返回表格中的所有项，或者在指定的索引中返回。
- en: If you haven't already done so, then go back to this book's GitHub repository
    and download the file named `scan-values.json`, since we will be using this file
    in the next exercise.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，请返回到本书的 GitHub 仓库，并下载名为`scan-values.json`的文件，因为我们将在下一个练习中使用这个文件。
- en: 'Go back to your terminal (or reopen it if you closed it previously) and type
    in the following command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到终端（如果之前关闭了，重新打开）并输入以下命令：
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We're not going to show all the output from this command, but one of the things
    to look at is at the bottom of the command, where it will show you the **Count**
    of the number of rows returned and the **Scanned Count** of the total number of
    rows scanned.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会显示此命令的所有输出，但需要关注的是命令底部的部分，它会显示**计数**（Count），即返回的行数，以及**扫描计数**（Scanned Count），即扫描的总行数。
- en: Note
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This is an expensive operation in terms of reads as you are going through all
    the data in the table. If you know the data you need, it is much better to perform
    a query and only call back the items and records that you need.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个高消耗的操作，因为你需要读取表格中的所有数据。如果你已经知道需要的数据，最好执行查询，只返回你需要的项和记录。
- en: What is a scan in DynamoDB?
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是 DynamoDB 中的扫描？
- en: When you execute the `scan` command in a DynamoDB table, every item in that
    table or secondary index gets read. If you don't specify any filter conditions,
    then the scan will return all the items in a single scan, so long as the results
    are under 1 MB of data.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 DynamoDB 表中执行`scan`命令时，表格或二级索引中的每一项都会被读取。如果你没有指定任何筛选条件，那么扫描将一次性返回所有项，只要结果数据不超过
    1 MB。
- en: Querying data
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询数据
- en: What if we only want to retrieve certain values from our table? Or if we want
    DynamoDB to give us a count of how many records match a certain criterion? In
    this case, instead of using a scan, it's much more efficient to use a query.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想从表中检索某些值，或者希望 DynamoDB 告诉我们符合某个条件的记录数该怎么办呢？在这种情况下，与其使用扫描，使用查询会更高效。
- en: Before we start to query, make sure that you have downloaded the file from `chapter
    five` named `query-values.json` from this book's GitHub repository.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始查询之前，确保你已经从本书的 GitHub 仓库下载了名为`query-values.json`的文件，该文件位于`chapter five`目录下。
- en: 'Let''s open up our terminal once again so that we can perform our query and
    see what results are returned:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次打开终端，这样我们就可以执行查询并查看返回的结果：
- en: First, make sure that you are either in the same directory where you downloaded
    the `query-values.json` file, or copy the file to your current working directory.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，确保你处在下载了`query-values.json`文件的同一目录下，或者将该文件复制到当前工作目录中。
- en: Second, make sure that you have created the `projects` DynamoDB table; otherwise,
    the query will not be successful.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二，确保你已经创建了`projects` DynamoDB 表；否则，查询将不会成功。
- en: 'In your terminal window, type the following command:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的终端窗口中，输入以下命令：
- en: '[PRE6]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that, in the value for `projection-expression`, we noted the fields that
    we wanted to return from the table. We already knew the project name (we had to
    because it is our primary key), so we were trying to look up what department this
    project belonged to. This is one of the ways that a query is much more efficient
    than scanning all the data when searching and returning values in DynamoDB.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`projection-expression`的值中，我们标注了希望从表中返回的字段。我们已经知道了项目名称（因为它是我们的主键），所以我们是在查找这个项目所属的部门。这就是查询相比扫描所有数据在DynamoDB中查找和返回值时效率更高的方式之一。
- en: Secondary indexes in Dynamo, both global and local
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DynamoDB中的二级索引，包括全局和本地
- en: As you may have noticed, in our previous query, we had to use the primary key
    when performing our command. In our table's case, we are using a primary key (`Project_Name`).
    A table in DynamoDB can have many different indexes, which allows your applications
    to have a myriad of different query patterns to use, without having to resort
    to the scan operation. These indexes can contain all or just a subset of the data
    that is included in the table.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在我们之前的查询中，我们必须在执行命令时使用主键。在我们表的情况下，我们使用的是主键（`Project_Name`）。DynamoDB中的表可以有多个不同的索引，这允许你的应用程序拥有多种不同的查询模式，而不必依赖扫描操作。这些索引可以包含表中所有数据或只是其中的一个子集。
- en: Note
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You must declare the index in your query for DynamoDB to know that you are performing
    the action against that particular index. If you don't declare a specific index,
    then the query will go against the table itself.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在查询中声明索引，以便DynamoDB知道你是针对那个特定的索引执行操作。如果你没有声明特定的索引，查询将会直接作用于表本身。
- en: Local Secondary Index (LSI)
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地二级索引（LSI）
- en: A **Local Secondary Index** (**LSI**) gives you the opportunity to change the
    sort key that was originally defined in your table. LSIs must always use the same
    primary key as the table where it was created.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地二级索引**（**LSI**）使你有机会更改表中最初定义的排序键。LSI必须始终使用与其创建的表相同的主键。'
- en: LSIs also share the same throughput as the table it was created on. As a final
    note about LSIs, they **can only** be created at the time of table creation. If
    you did not create one when you created your table, you either need to drop and
    recreate your table, create a new table and then migrate your data, or use a **Global
    Secondary Index** (**GSI**) instead. Also, you can't delete a local secondary
    index without deleting the base table.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: LSI也共享与创建它的表相同的吞吐量。关于LSI的最后一点，**它们只能**在表创建时进行创建。如果在创建表时没有创建LSI，那么你需要删除并重新创建表，或者创建一个新表然后迁移数据，或者改用**全局二级索引**（**GSI**）。此外，你不能在不删除基础表的情况下删除本地二级索引。
- en: GSI
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GSI
- en: If we wanted to use a different primary key to search with, then we would have
    to create a GSI. Another key difference between GSIs and LSIs is that unlike LSIs,
    which have to be declared and created at the same time as when the table is being
    created, a GSI can be created at any point in time. This is especially helpful
    if you notice that either your queries are not requesting the right information,
    in which case you only want to bring back a subset of the information that you
    could store in the GSI, or a certain subset of queries that you are requesting
    need to have more RCUs or WCUs allocated.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用不同的主键进行搜索，那么我们必须创建一个GSI。GSIs和LSIs之间的另一个关键区别是，LSI必须在表创建时声明和创建，而GSI可以在任何时间创建。如果你发现查询没有请求正确的信息，想要返回只包含部分信息的GSI，或者某些查询需要更多的RCU或WCU配额时，GSI尤其有用。
- en: 'Now, if we wanted to see our GSI after creating it, we could run the following
    command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想在创建完GSI后查看它，我们可以运行以下命令：
- en: '[PRE7]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will show us any GSIs, if any, that have been created on our table.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示我们表上创建的任何GSI（如果有的话）。
- en: Understanding how to create indexes for optimal query performance is one of
    the key concepts to harnessing the power of DynamoDB. Next, we will move on to
    other features that DynamoDB can provide, such as replicating items using streams.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 理解如何创建索引以优化查询性能是利用DynamoDB强大功能的关键概念之一。接下来，我们将继续了解DynamoDB的其他功能，例如使用流复制项目。
- en: Understanding DynamoDB Streams
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解DynamoDB流
- en: There may be times when you have a table in DynamoDB and you want to either
    be updated when a change comes in or have an event-driven process happen. This
    was the exact reason why AWS created **Dynamo Streams**. Streams are a time-ordered
    sequence of item modifications, such as insert, update, and delete operations.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您在 DynamoDB 中有一张表，您想要在变更发生时进行更新，或者发生事件驱动的流程。这正是 AWS 创建**Dynamo Streams**
    的确切原因。流是项目修改的按时间顺序排列的序列，例如插入、更新和删除操作。
- en: When a stream in DynamoDB writes data, it does so in a strict ordering format.
    This means that as you write data to the table, pending the configuration settings
    you have set for the stream, it will push out the items in the same order in which
    they were written to the table.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当 DynamoDB 中的流写入数据时，它会按严格的排序格式进行。这意味着当您向表中写入数据时，根据流的配置设置，它将按照写入到表中的顺序推送项目。
- en: Global tables
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局表
- en: There are times when you need to either have a high availability plan in place
    in case of a regional outage for a service such as DynamoDB, or must have quicker
    local access to your data from another region besides where you originally created
    your data.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您需要在出现服务（如 DynamoDB）的区域性中断时设置高可用性计划，或者除了您最初创建数据的区域外，还需要更快的本地访问您的数据。
- en: Global Tables, even though they are replicas of an origin table, are all owned
    by a single account.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 全局表，即使它们是原始表的副本，也都由单个账户拥有。
- en: When setting up a global table, the first step is to create an initial table
    in your primary region.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置全局表时，第一步是在您的主要区域创建一个初始表。
- en: Then, you need to enable DB Streams on that initial table.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，您需要在初始表上启用 DB 流。
- en: Next, for every region where you want to replicate your global table, you must
    set up that same table with streaming enabled in a different region.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于您希望复制全局表的每个区域，您必须在不同的区域中设置启用流的同一表。
- en: Then, in the original region, you can define the global table's setup, which
    is made easy by the AWS Management Console.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在原始区域中，您可以定义全局表的设置，AWS 管理控制台使这一切变得轻而易举。
- en: If there are requirements in your organization to maintain a certain level of
    uptime that has been relayed via **service-level agreements** (**SLAs**), then
    you can take care of this using a combination of Streams and Global Tables. Next,
    we will examine how to speed up query time in DynamoDB by using the DynamoDB accelerator.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的组织有通过**服务级别协议**（**SLA**）传达的需求，需要保持一定的运行时间，那么您可以使用流和全局表的组合来处理这些问题。接下来，我们将介绍如何通过
    DynamoDB 加速器加快查询时间。
- en: Using the DynamoDB accelerator (DAX)
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 DynamoDB 加速器（DAX）
- en: DynamoDB, by itself, even with thousands of requests, can deliver millisecond
    latency response times. This satisfies the needs of many companies and customers,
    but there are some applications that need microsecond performance, and this is
    where **DynamoDB Accelerator** (**DAX**) comes into focus.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有成千上万的请求，DynamoDB 本身也能以毫秒级的延迟响应时间提供服务。这满足了许多公司和客户的需求，但有一些应用程序需要微秒级的性能，这就是**DynamoDB
    加速器**（**DAX**）的用武之地。
- en: 'DAX is almost equivalent to a turbo button for your DynamoDB table. It caches
    the most frequently requested results and then makes them available via an endpoint.
    There is no need to spin up a third-party cache, no need to manage nodes, and
    it''s as easy to implement. You simply go to the DAX menu under the main DynamoDB
    page and then spin up your DAX cluster:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: DAX 几乎等同于 DynamoDB 表的涡轮按钮。它缓存最常请求的结果，然后通过端点提供这些结果。无需启动第三方缓存，也无需管理节点，实现起来非常简单。您只需转到
    DynamoDB 主页下的 DAX 菜单，然后启动您的 DAX 集群：
- en: '![Figure 5.5 – DAX example architecture'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5 – DAX 示例架构'
- en: '](img/Figure_5.5_B17405.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.5_B17405.jpg)'
- en: Figure 5.5 – DAX example architecture
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – DAX 示例架构
- en: Industries such as Ad-Tech can utilize the caching properties and speed of DAX
    when designing and implementing their systems to go out and place bids for digital
    advertising real estate. Those millisecond latencies in placing bids can equate
    to real dollars in that industry.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计和实施系统以进行数字广告竞价时，广告技术等行业可以利用 DAX 的缓存属性和速度。在竞标时的毫秒级延迟可以等同于该行业中的实际资金。
- en: Knowing how to handle queries in DynamoDB that are taking longer than expected
    is what we just covered with DAX's caching abilities. Now, we will look at how
    to authorize access in DynamoDB.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何处理在 DynamoDB 中执行时间超过预期的查询，这正是我们刚刚通过 DAX 的缓存功能介绍的。现在，我们将看看如何在 DynamoDB 中授权访问。
- en: Authenticating and authorizing in DynamoDB
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 DynamoDB 中进行身份验证和授权
- en: As with other services in AWS, Dynamo DB allows fine-grained access control
    via the IAM service. You can either allow or disallow users at the service, table,
    or attribute level, depending on how you have structured your IAM policies.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与 AWS 中的其他服务一样，DynamoDB 通过 IAM 服务允许精细的访问控制。你可以根据你如何构建 IAM 策略，选择在服务、表或属性级别允许或拒绝用户访问。
- en: AWS recommends, as a best practice, that you use the principle of least privilege
    and only allow users to access the data in the tables that they require versus
    blanket access.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 推荐作为最佳实践，使用最小权限原则，仅允许用户访问他们需要的数据表，而不是提供通用访问权限。
- en: Web Identity Federation
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web 身份联合
- en: 'DynamoDB is an especially popular backend database for mobile and game developers.
    This can result in thousands of users needing to access even a single table. In
    this use case scenario, it is impractical to try to create an IAM user for each
    and every user:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: DynamoDB 是一个特别受移动应用和游戏开发者欢迎的后端数据库。这可能导致成千上万的用户需要访问单一的表。在这种使用场景下，为每个用户创建一个 IAM
    用户是不可行的：
- en: '![Figure 5.6 – Web Identity Federation to a DynamoDB table'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.6 – Web 身份联合到 DynamoDB 表'
- en: '](img/Figure_5.6_B17405.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.6_B17405.jpg)'
- en: Figure 5.6 – Web Identity Federation to a DynamoDB table
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – Web 身份联合到 DynamoDB 表
- en: 'The best way to understand how users who are authenticating via a web identity
    provider, such as *Facebook* or *Google*, gain access to data in a DynamoDB table
    is to look at the steps that it takes to grant authorization:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 理解通过 Web 身份提供者（如 *Facebook* 或 *Google*）进行身份验证的用户如何访问 DynamoDB 表中的数据，最好的方法是查看授予授权的步骤：
- en: The application authenticates to a web identity provider such as Amazon. That
    identity provider then returns an identity token.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序通过如 Amazon 等 Web 身份提供者进行身份验证。身份提供者然后返回一个身份令牌。
- en: The application then calls the security token service to gain a temporary access
    credential based on a role that has been previously defined.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，应用程序调用安全令牌服务，以基于之前定义的角色获取临时访问凭证。
- en: That role should give access to not just the full DynamoDB table, but the user's
    items via the IAM policy.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该角色应当不仅仅提供对整个 DynamoDB 表的访问权限，还应通过 IAM 策略授予用户对其项目的访问权限。
- en: As DynamoDB is the preferred data store for mobile applications hosted on AWS,
    we looked at how to authorize web identity users to access specific data using
    a combination of IAM and STS tokens. Next, we will move on to monitoring our DynamoDB
    tables to make sure that we don't get caught off guard by throttles.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 DynamoDB 是托管在 AWS 上的移动应用的首选数据存储，我们探讨了如何通过 IAM 和 STS 令牌的组合授权 Web 身份用户访问特定数据。接下来，我们将继续监控我们的
    DynamoDB 表，以确保不会被限流所困扰。
- en: Monitoring DynamoDB
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控 DynamoDB
- en: 'When you look at what metrics you need to concentrate on when monitoring DynamoDB,
    there are a few that come into focus:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看在监控 DynamoDB 时需要关注哪些指标，有几个指标会特别突出：
- en: Our `GET` and `PUT` requests are in the range of what we expected
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的 `GET` 和 `PUT` 请求在我们预期的范围内
- en: We are not being throttled by either read or write capacity
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有受到读写容量的限制
- en: From the DynamoDB console itself, we can get quite a few metrics regarding our
    table's health.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从 DynamoDB 控制台本身，我们可以获得关于表健康状况的许多指标。
- en: First, we can see both read and write capacity at a glance.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以一眼看到读写容量。
- en: 'There is also a section in the metrics of any table that you choose for basic
    latency showing four areas of interest: `GET`, `PUT`, `Query`, and `Scan Latency`.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择的任何表的指标中也有一个关于基本延迟的部分，显示四个关注点：`GET`、`PUT`、`查询`和`扫描`延迟。
- en: 'Let''s log in to the **Amazon Management Console** and take a look at these
    basic metrics for ourselves:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们登录到 **Amazon 管理控制台**，亲自查看这些基本指标：
- en: Log in to the **Amazon Management Console** using the account you previously
    created for the projects table in DynamoDB.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你之前为 DynamoDB 中的项目表创建的账户登录到 **Amazon 管理控制台**。
- en: In the search box at the top, type `DynamoDB` so that the service name appears
    in the results. Click **DynamoDB** to be taken to the DynamoDB service. On the
    top-right-hand side, double-check that you are in the correct region where you
    created the table.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部的搜索框中，输入 `DynamoDB`，以便服务名称出现在搜索结果中。点击 **DynamoDB** 进入 DynamoDB 服务。在右上角，仔细检查你是否处于创建表的正确区域。
- en: Once you are at the main DynamoDB screen, click **Tables** on the left-hand
    side menu. Once clicked, you should see the table you created earlier, named **projects**:![Figure
    5.7 – Showing the DynamoDB Tables menu option on the left-hand menu
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您到达DynamoDB主屏幕，单击左侧菜单中的**Tables**。单击后，您应该可以看到之前创建的名为**projects**的表：![图 5.7
    – 显示左侧菜单中的 DynamoDB 表选项
- en: '](img/Figure_5.7_B17405.jpg)'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_5.7_B17405.jpg)'
- en: Figure 5.7 – Showing the DynamoDB Tables menu option on the left-hand menu
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.7 – 显示左侧菜单中的 DynamoDB 表选项
- en: Click on the table named **Projects** in the main window. This will open another
    pane, adding more information about your table.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击主窗口中名为**Projects**的表。这将打开另一个窗格，添加更多有关您的表的信息。
- en: From here, we can select the **metrics** tab from the top tab bar in the rightmost
    pane:![Figure 5.8 – The top menu bar once in the DynamoDB table
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以从最右侧窗格的顶部选项卡栏中选择**指标**标签：![图 5.8 – 进入DynamoDB表后，顶部菜单栏
- en: '](img/Figure_5.8_B17405.jpg)'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_5.8_B17405.jpg)'
- en: Figure 5.8 – The top menu bar once in the DynamoDB table
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.8 – 进入DynamoDB表后，顶部菜单栏
- en: If, in the **metrics** display, you don't see much activity, then try running
    the queries from the CLI that we created previously in this chapter. This should
    prompt the metrics meters to start showing more PUT and GET objects of the data.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在**指标**显示中，您没有看到太多活动，那么可以尝试运行我们在本章中先前创建的 CLI 查询。这应该会促使指标计量器开始显示更多的数据PUT和GET对象。
- en: Contributor Insights
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 贡献者洞察
- en: Enabling **Contributor Insights** for your DynamoDB table allows you to gain
    much better insight into the items that are being accessed and throttled. This
    allows you to make adjustments to your table or schema accordingly, if needed.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 启用**贡献者洞察**，可以让您更好地了解正在访问和受限的项。这使您能够在需要时相应地调整表或模式。
- en: 'Once you have enabled **Contributor Insights**, DynamoDB creates two rules
    on your behalf if you only have a primary key:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用**贡献者洞察**，如果您只有主键，DynamoDB会为您创建两个规则：
- en: Most accessed items (partition key)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最常访问的项（分区键）
- en: Most throttled keys (partition key)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最多受限的键（分区键）
- en: 'If you have a global secondary index or sort key, there will be two additional
    rules created for you by DynamoDB. These are specific to secondary indexes:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有全局二级索引或排序键，DynamoDB将为您创建两个附加规则。这些规则是针对二级索引的：
- en: Most accessed keys (partition and sort keys)
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最多访问的键（分区键和排序键）
- en: Most throttled keys (partition and sort keys)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最多受限的键（分区键和排序键）
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at the NoSQL service known as DynamoDB. We explored
    how tables are created and partitioned, along with how to write and query data
    from DynamoDB. We also examined how to stream data from tables to other sources,
    along with using the **DynamoDB Accelerator** (**DAX**), a specialized cache,
    to help speed up our queries.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了被称为DynamoDB的NoSQL服务。我们探讨了如何创建和分区表，以及如何从DynamoDB写入和查询数据。我们还研究了如何将数据从表流向其他源，并使用**DynamoDB加速器**（**DAX**），一种专门的缓存，来加速查询。
- en: We have now finished Part 1, *Establishing Fundamentals*, where we reviewed
    **Amazon Web Services**. Next, we will move on to *Part 2*, *Developing, Deploying,
    and Using Infrastructure as Code*. In the upcoming chapters, we will incorporate
    many of the services that we have just discussed and then put them into action.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了第一部分，*建立基础*，在这一部分中，我们回顾了**亚马逊Web服务**。接下来，我们将进入*第二部分*，*开发、部署和使用基础设施即代码*。在接下来的章节中，我们将整合我们刚才讨论的许多服务，并将它们付诸实践。
- en: Review questions
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习问题
- en: Our application is storing project data in a DynamoDB table. You need to run
    a query to find all the builds that were run by a specific department last month.
    Which attributes would you use in your query?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的应用程序正在将项目数据存储在DynamoDB表中。您需要运行查询，找出上个月由特定部门执行的所有构建。您会在查询中使用哪些属性？
- en: a. The partition key of `Build_Date` and the sort key of `Department`
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. `Build_Date` 的分区键和 `Department` 的排序键
- en: b. A composite primary key made up of `Department` and `Build_Date`
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 由 `Department` 和 `Build_Date` 组成的复合主键
- en: c. The partition key of `Department` and the sort key of `Build_Date`
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. `Department` 的分区键和 `Build_Date` 的排序键
- en: d. The partition key of `Build_Date` and the sort key of `Dept_ID`
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. `Build_Date` 的分区键和 `Dept_ID` 的排序键
- en: Which of the following AWS services provides an in-memory write-through cache
    that has been optimized for DynamoDB?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项AWS服务提供了一个针对DynamoDB优化的内存写通缓存？
- en: a. ElastiCache
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. ElastiCache
- en: b. CloudFront
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. CloudFront
- en: c. DAX
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. DAX
- en: d. Athena
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. Athena
- en: A scan operation in DynamoDB is used for which of the following scenarios?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DynamoDB 中的扫描操作适用于以下哪种场景？
- en: a. To return the entire contents of the table, filtered on the primary or sort
    key
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 返回表的所有内容，并根据主键或排序键进行过滤
- en: b. To find items in a table based on a primary key attribute
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 基于主键属性在表中查找项
- en: c. To find items in a table based on a sort key attribute
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 基于排序键属性在表中查找项
- en: d. To return all the items in a table
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 返回表中的所有项
- en: Your developers have created a DynamoDB table and seem to find that the performance
    always slows down after 20-25 minutes of their testing process. They can see from
    the basic monitoring on the AWS console that their requests are being throttled.
    What can you do to help pinpoint the issue?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的开发人员创建了一个 DynamoDB 表，并发现他们的性能总是在测试过程的 20-25 分钟后变慢。通过 AWS 控制台的基本监控，他们看到请求被限制。您可以做什么来帮助找出问题的根本原因？
- en: a. Increase the **Read Capacity Units** (**RCUs**) on the table so that the
    queries are no longer throttled.
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 增加表上的**读取容量单位**（**RCUs**），以使查询不再受限制。
- en: b. Enable **Contributor Insights** on the table so that the keys that are being
    throttled the most are shown.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 在表上启用**Contributor Insights**，以便显示被限制最多的键。
- en: c. Add enhanced **Cloud Watch** monitoring with alarms whenever throttling occurs.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 添加增强的**Cloud Watch**监控，并在发生限制时触发警报。
- en: d. Add **adaptive capacity** to the table so that the extra **Read Capacity
    Units** (**RCUs**) are spread evenly across partitions that are becoming hot.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 向表中添加**自适应容量**，使额外的**读取容量单位**（**RCUs**）均匀分布到变热的分区中。
- en: Which of the following items would make a good partition key?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪一项适合作为分区键？
- en: '`a.` `OrderID`'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`a.` `OrderID`'
- en: '`b.` `Ship_From_Location`'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`b.` `Ship_From_Location`'
- en: '`c.` `Total`'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`c.` `Total`'
- en: '`d.` `Product_Brand`'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`d.` `Product_Brand`'
- en: Review answers
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看答案
- en: b
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: c
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: d
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: b
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: a
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a
