- en: 'Chapter 5: Amazon DynamoDB'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As application architectures demand scalability and shift focus to serverless
    design patterns, developers look to data stores that are flexible, scalable, and
    have low management overhead. DynamoDB has become a proven, trusted solution for
    these types of features. However, it has continued to evolve, and many of the
    features that sprouted from this service have relevance in the DevOps professional
    exam.
  prefs: []
  type: TYPE_NORMAL
- en: While knowing how to calculate the read to write ratio when provisioning a DynamoDB
    database isn't a topic of focus in the professional-level exam, understanding
    how this core AWS service fits into deployments and scenarios is. Having a firm
    understanding of the capabilities of DynamoDB, along with its features, will help
    you answer the exam questions, as well as allow you to implement solutions in
    your career engagements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basis and background of DynamoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding DynamoDB data modeling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting and accessing data in DynamoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding DynamoDB Streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the **DynamoDB accelerator** (**DAX**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticating and authorizing in DynamoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring DynamoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the basis and background of DynamoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DynamoDB is a NoSQL database. This means that it is not only SQL and, more importantly,
    that DynamoDB doesn't need a fully structured schema to enter data. Its flexibility
    and performance are what drives many to DynamoDB, along with its pay-per-use pricing
    model and high availability and scaling.
  prefs: []
  type: TYPE_NORMAL
- en: DynamoDB origins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In 2007, Amazon published a whitepaper authored by the future AWS CTO, Werner
    Volgels*,* and others called *Dynamo: Amazon''s Highly Available Key-value Store*.'
  prefs: []
  type: TYPE_NORMAL
- en: You can still find this paper today at [https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf](https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: 'As Amazon built out its e-commerce platform, it was trying to solve issues
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High availability for writes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling temporary failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recovering from permeant failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Membership and failure detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The databases at the time were just not performant enough, and the e-commerce
    website was starting to see bottlenecks, especially at the database layer.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL versus relational databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Relational databases have been around since the 1970s. Relational databases
    are good when you need to enforce data integrity and can structure data using
    the **Structured Query Language** (**SQL**). Relational databases are optimized
    on the premise that storage is one of your most limiting factors. Once you run
    out of storage or disk drive space, you will need to procure more storage space.
    Knowing this fact is one of the reasons for the use of primary keys and joins
    when using relational databases. Using the ID of the data, and then retrieving
    the columns of the actual data needed using table joins, allows the data to only
    be stored a single time, hence saving space on the systems, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Relational database tables'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.1_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Relational database tables
  prefs: []
  type: TYPE_NORMAL
- en: With storage in the cloud, storage and its associated costs are no longer a
    limiting factor. This brings us to NoSQL, or Non-SQL (sometimes referred to as
    not only SQL). Rather than storing data in tables, NoSQL systems store their data
    alternately, frequently, as in the case of DynamoDB, in `JSON` documents.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL databases bring about the flexibility that relational databases just can't
    provide. Today's modern applications, such as web apps and gaming systems, along
    with mobile applications, need this type of flexibility, along with the ability
    to scale to meet their users' needs, as well as provide high performance when
    retrieving and inserting the data when requested.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike traditional relational databases, DynamoDB is more like a key store that
    is extremely efficient in both retrieving and storing data.
  prefs: []
  type: TYPE_NORMAL
- en: Core components of Dynamo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at the main components that DynamoDB is comprised of:'
  prefs: []
  type: TYPE_NORMAL
- en: The table and its attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primary key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondary indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Tables and their attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **table** in DynamoDB is comparative to a database in other database systems,
    rather than just a table in relational database systems. A table is a collection
    of data on a specific topic. Each table in Dynamo is a separate store of items,
    and this is where the data is stored.
  prefs: []
  type: TYPE_NORMAL
- en: Each table contains zero or more **items**. Items have different fields and
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a DynamoDB table that contains items:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Dynamo DB table and items'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.2_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Dynamo DB table and items
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the preceding table, you will see a few of the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Each item has a primary key. This is the unique identifier for the item (`CarID`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no set schema for the items. As long as the primary key is present,
    any of the other attributes can or cannot be present.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The majority of the attributes only have one value. However, the last item has
    a features field. This is a nested value that can hold multiple attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primary key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you are creating a table in DynamoDB, you must specify the **primary key**.
    This primary key is a unique identifier for each item in the table, which means
    no two items can have the same primary key.
  prefs: []
  type: TYPE_NORMAL
- en: With the primary key, you can reference distinct items in the table. DynamoDB
    uses the primary key as the data for its own internal hashing algorithm. This
    hash is used to determine which partition should be used to store the attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Secondary indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Secondary indexes are optional keys that can be used to query against. There
    are two types of secondary indexes supported by DynamoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: Global secondary index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local secondary index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will take a deeper look at secondary indexes later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Other pertinent Dynamo information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you start to think about your table, it's also important to note that there
    isn't a single server instance or machine hosting Dynamo. Once added, the data
    is distributed across multiple instances, which allows the key scaling and performance
    features of DynamoDB to be used. Write calls do not return as successful until
    the data has been redundantly stored.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding DynamoDB data modeling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have ever designed a relational database, then you are familiar with
    schemas such as star schemas. Each table needs to have a specified attribute and
    if that attribute has no value, then a null is kept in its place.
  prefs: []
  type: TYPE_NORMAL
- en: DynamoDB uses partitions. These partitions can be either hot partitions or cold
    partitions.
  prefs: []
  type: TYPE_NORMAL
- en: Every item in DynamoDB requires at least one attribute, and that is the partition
    key. This partition key is used by Dynamo to hash your data and place it in memory.
    To achieve optimal performance in DynamoDB, we need to choose a partition key
    that allows DynamoDB to spread its searches across the disk and not let a single
    partition get too *hot*.
  prefs: []
  type: TYPE_NORMAL
- en: This is best demonstrated with a bad example of a partition key, such as date.
    If you are trying to gather lots of data all from the same date, then the hash
    value of the single date will be stored in the same partition. Different dates
    may be stored across different partitions since their hash will be different;
    however, when querying all the events that happened on a single date, that singular
    partition will become hot, and this can cause performance problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of high-quality partition keys are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Location ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Department ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customer ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First letter of the last name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the preceding examples, the data would spread across different partitions
    when it comes to both reading and writing, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Keys evenly spread across partitions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.3_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – Keys evenly spread across partitions
  prefs: []
  type: TYPE_NORMAL
- en: Read and write capacity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you create your table, you must specify both your read and write capacity
    values. Once specified, DynamoDB reserves the resources needed to handle that
    capacity and divides it evenly across the partitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two different types of capacity units that need to be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Read capacity units** (**RCU**): This is the number of strongly consistent
    reads per second that your table can handle. It can contain items up to 4 KB in
    size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write capacity units** (**WCU**): This is the number of consistent writes
    per second in 1 KB units that your table can handle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adaptive capacity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have a workload that is imbalanced in nature, DynamoDB has a feature
    called **adaptive capacity** that helps minimize throttling. The best part about
    this feature is that it is enabled for every DynamoDB table automatically at no
    additional cost. There is no need to go into the settings and turn an adaptive
    capacity setting on or off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although you may provision 10 **Write Capacity Units** (**WCUs**) per partition,
    there may be one partition that is receiving more writes than the others. If the
    total capacity of the table has not been exceeded, then DynamoDB can use the adaptive
    capacity feature and allow the *hot* partition to continue to receive the writes
    before throttling:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Adaptive capacity example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.4_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – Adaptive capacity example
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows an example DynamoDB table consisting of 4 partitions.
    When created, we allocated a total of 40 WCSs across the table. **Partition 2**,
    **Partition 3**, and **Partition 4** are only consuming 5 WCUs each, for a total
    of 15 WCUs, thus leaving another 25 WCUs free, as allocated from our initial provisioning.
    **Partition 1**, however, has the most activity and is consuming 15 WCUs, or 5
    over the allocated 10 per partition. The adaptive capacity feature takes into
    account that there is extra WCU capacity and adjusts without throttling the table.
  prefs: []
  type: TYPE_NORMAL
- en: Data types available in DynamoDB tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DynamoDB allows various types of data to be inserted into attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Number, string, Boolean, binary (which would need to be `base64-encoded`), and
    null values are all supported data types for attributes. These are all examples
    of single values that can be inserted into an attribute field.
  prefs: []
  type: TYPE_NORMAL
- en: DynamoDB also allows sets of items to be inserted into an attribute. These sets
    can contain numbers, binaries, or strings. Sets must be all of the same type,
    so you can't mix a set of numbers and strings, and sets do not preserve order.
  prefs: []
  type: TYPE_NORMAL
- en: Somewhat like a document database, DynamoDB allows `JSON` documents to be added
    as attributes, and they can nest up to 32 layers deep.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Primary keys must be either string, number, or binary.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting and accessing data in DynamoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've covered the history and theory of DynamoDB, it's time to put
    our hands on our keyboards and actually get into the data.
  prefs: []
  type: TYPE_NORMAL
- en: For our example, we will create a fictional database to keep track of the projects
    at our company. This can include information such as `ProjectID`, the name of
    the project, who the project owner is, what the contact email is for the project
    or the team, and even other information such as build and language information.
    Since DynamoDB has a flexible schema, not all this information is needed in all
    the rows. We do, however, need to declare our primary key and then, depending
    on what we query, our secondary key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our schema will look like the following `JSON`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With our schema defined, we can start creating our table.
  prefs: []
  type: TYPE_NORMAL
- en: Creating tables in Dynamo DB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can now open up our terminal and create our table using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you compare the previous command with our schema, you will notice that we
    have only defined one column in the table: `Project_Name`. This is because this
    column is our hash key (the primary index). The other fields can be defined later
    and are not necessary. Those fields will be populated once the data has been inserted,
    either in bulk or row by row. It''s important to know that now, all the strings
    in the `Project_Name` field must be unique; otherwise, they will be rejected from
    being inserted as duplicate values.'
  prefs: []
  type: TYPE_NORMAL
- en: You may have also noticed that, at the end of the statement, we allocated five
    read capacity units, along with five write capacity units, to our table initially.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting data into DynamoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the GitHub directory for this book, under `chapter five`, we have several
    files to upload to the table that we have created. We have three different `JSON`
    files to download for this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '`project_item.json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`projects.json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`projects_bulk.json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to do all the inserts via the CLI. Although you can do single-line
    and bulk inserts in the **Amazon Management Console** (**AMC**), we want to concentrate
    on the ability to script our commands so that we have can automate them later,
    if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first type of insert we are going to do is a single item insert into the
    table. For this, we are going to need the `project_item.json` file, so if you
    haven''t already downloaded the file, take a look at its structure, as shown here,
    to see what is going on with this `JSON` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Before we upload the file, we want to look at some of the notations of the file.
    You'll note that the data types are notated before each field. Here, we have used
    string fields, notated with `S`, numerical fields, notated with `N`, and finally,
    for our builds, we have a numerical list denoted with `NS`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now open up our terminal and run the following command to add the item
    to the DynamoDB table that we created earlier. Make sure that you navigate to
    the same directory where you have downloaded the files before you run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have executed the previous command, you should get a return statement
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You now have an item in your DynamoDB table. Just a single
    item is not great for querying, however, so we need to add some more data. Adding
    more than a single item to a table via the CLI requires both a different command
    and a different format for the file that is going to be used.
  prefs: []
  type: TYPE_NORMAL
- en: In the `projects.json` file, we have provided `10` items that you can quickly
    add to your table via the `batch-write-item` command. You'll also notice that,
    in the `batch-write-item` command, unlike the `put-item` command, you don't need
    to specify the table. This information is specified in the table itself.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have loaded the test data into the table, we can use a table scan
    to see those data entries. A scan operation will return either all the items in
    a table or in the index specified.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't already done so, then go back to this book's GitHub repository
    and download the file named `scan-values.json`, since we will be using this file
    in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to your terminal (or reopen it if you closed it previously) and type
    in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We're not going to show all the output from this command, but one of the things
    to look at is at the bottom of the command, where it will show you the **Count**
    of the number of rows returned and the **Scanned Count** of the total number of
    rows scanned.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This is an expensive operation in terms of reads as you are going through all
    the data in the table. If you know the data you need, it is much better to perform
    a query and only call back the items and records that you need.
  prefs: []
  type: TYPE_NORMAL
- en: What is a scan in DynamoDB?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you execute the `scan` command in a DynamoDB table, every item in that
    table or secondary index gets read. If you don't specify any filter conditions,
    then the scan will return all the items in a single scan, so long as the results
    are under 1 MB of data.
  prefs: []
  type: TYPE_NORMAL
- en: Querying data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if we only want to retrieve certain values from our table? Or if we want
    DynamoDB to give us a count of how many records match a certain criterion? In
    this case, instead of using a scan, it's much more efficient to use a query.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start to query, make sure that you have downloaded the file from `chapter
    five` named `query-values.json` from this book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up our terminal once again so that we can perform our query and
    see what results are returned:'
  prefs: []
  type: TYPE_NORMAL
- en: First, make sure that you are either in the same directory where you downloaded
    the `query-values.json` file, or copy the file to your current working directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Second, make sure that you have created the `projects` DynamoDB table; otherwise,
    the query will not be successful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your terminal window, type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that, in the value for `projection-expression`, we noted the fields that
    we wanted to return from the table. We already knew the project name (we had to
    because it is our primary key), so we were trying to look up what department this
    project belonged to. This is one of the ways that a query is much more efficient
    than scanning all the data when searching and returning values in DynamoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Secondary indexes in Dynamo, both global and local
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may have noticed, in our previous query, we had to use the primary key
    when performing our command. In our table's case, we are using a primary key (`Project_Name`).
    A table in DynamoDB can have many different indexes, which allows your applications
    to have a myriad of different query patterns to use, without having to resort
    to the scan operation. These indexes can contain all or just a subset of the data
    that is included in the table.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You must declare the index in your query for DynamoDB to know that you are performing
    the action against that particular index. If you don't declare a specific index,
    then the query will go against the table itself.
  prefs: []
  type: TYPE_NORMAL
- en: Local Secondary Index (LSI)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **Local Secondary Index** (**LSI**) gives you the opportunity to change the
    sort key that was originally defined in your table. LSIs must always use the same
    primary key as the table where it was created.
  prefs: []
  type: TYPE_NORMAL
- en: LSIs also share the same throughput as the table it was created on. As a final
    note about LSIs, they **can only** be created at the time of table creation. If
    you did not create one when you created your table, you either need to drop and
    recreate your table, create a new table and then migrate your data, or use a **Global
    Secondary Index** (**GSI**) instead. Also, you can't delete a local secondary
    index without deleting the base table.
  prefs: []
  type: TYPE_NORMAL
- en: GSI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we wanted to use a different primary key to search with, then we would have
    to create a GSI. Another key difference between GSIs and LSIs is that unlike LSIs,
    which have to be declared and created at the same time as when the table is being
    created, a GSI can be created at any point in time. This is especially helpful
    if you notice that either your queries are not requesting the right information,
    in which case you only want to bring back a subset of the information that you
    could store in the GSI, or a certain subset of queries that you are requesting
    need to have more RCUs or WCUs allocated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we wanted to see our GSI after creating it, we could run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will show us any GSIs, if any, that have been created on our table.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how to create indexes for optimal query performance is one of
    the key concepts to harnessing the power of DynamoDB. Next, we will move on to
    other features that DynamoDB can provide, such as replicating items using streams.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding DynamoDB Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There may be times when you have a table in DynamoDB and you want to either
    be updated when a change comes in or have an event-driven process happen. This
    was the exact reason why AWS created **Dynamo Streams**. Streams are a time-ordered
    sequence of item modifications, such as insert, update, and delete operations.
  prefs: []
  type: TYPE_NORMAL
- en: When a stream in DynamoDB writes data, it does so in a strict ordering format.
    This means that as you write data to the table, pending the configuration settings
    you have set for the stream, it will push out the items in the same order in which
    they were written to the table.
  prefs: []
  type: TYPE_NORMAL
- en: Global tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are times when you need to either have a high availability plan in place
    in case of a regional outage for a service such as DynamoDB, or must have quicker
    local access to your data from another region besides where you originally created
    your data.
  prefs: []
  type: TYPE_NORMAL
- en: Global Tables, even though they are replicas of an origin table, are all owned
    by a single account.
  prefs: []
  type: TYPE_NORMAL
- en: When setting up a global table, the first step is to create an initial table
    in your primary region.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you need to enable DB Streams on that initial table.
  prefs: []
  type: TYPE_NORMAL
- en: Next, for every region where you want to replicate your global table, you must
    set up that same table with streaming enabled in a different region.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the original region, you can define the global table's setup, which
    is made easy by the AWS Management Console.
  prefs: []
  type: TYPE_NORMAL
- en: If there are requirements in your organization to maintain a certain level of
    uptime that has been relayed via **service-level agreements** (**SLAs**), then
    you can take care of this using a combination of Streams and Global Tables. Next,
    we will examine how to speed up query time in DynamoDB by using the DynamoDB accelerator.
  prefs: []
  type: TYPE_NORMAL
- en: Using the DynamoDB accelerator (DAX)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DynamoDB, by itself, even with thousands of requests, can deliver millisecond
    latency response times. This satisfies the needs of many companies and customers,
    but there are some applications that need microsecond performance, and this is
    where **DynamoDB Accelerator** (**DAX**) comes into focus.
  prefs: []
  type: TYPE_NORMAL
- en: 'DAX is almost equivalent to a turbo button for your DynamoDB table. It caches
    the most frequently requested results and then makes them available via an endpoint.
    There is no need to spin up a third-party cache, no need to manage nodes, and
    it''s as easy to implement. You simply go to the DAX menu under the main DynamoDB
    page and then spin up your DAX cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – DAX example architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.5_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – DAX example architecture
  prefs: []
  type: TYPE_NORMAL
- en: Industries such as Ad-Tech can utilize the caching properties and speed of DAX
    when designing and implementing their systems to go out and place bids for digital
    advertising real estate. Those millisecond latencies in placing bids can equate
    to real dollars in that industry.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to handle queries in DynamoDB that are taking longer than expected
    is what we just covered with DAX's caching abilities. Now, we will look at how
    to authorize access in DynamoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating and authorizing in DynamoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with other services in AWS, Dynamo DB allows fine-grained access control
    via the IAM service. You can either allow or disallow users at the service, table,
    or attribute level, depending on how you have structured your IAM policies.
  prefs: []
  type: TYPE_NORMAL
- en: AWS recommends, as a best practice, that you use the principle of least privilege
    and only allow users to access the data in the tables that they require versus
    blanket access.
  prefs: []
  type: TYPE_NORMAL
- en: Web Identity Federation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'DynamoDB is an especially popular backend database for mobile and game developers.
    This can result in thousands of users needing to access even a single table. In
    this use case scenario, it is impractical to try to create an IAM user for each
    and every user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Web Identity Federation to a DynamoDB table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.6_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – Web Identity Federation to a DynamoDB table
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to understand how users who are authenticating via a web identity
    provider, such as *Facebook* or *Google*, gain access to data in a DynamoDB table
    is to look at the steps that it takes to grant authorization:'
  prefs: []
  type: TYPE_NORMAL
- en: The application authenticates to a web identity provider such as Amazon. That
    identity provider then returns an identity token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application then calls the security token service to gain a temporary access
    credential based on a role that has been previously defined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That role should give access to not just the full DynamoDB table, but the user's
    items via the IAM policy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As DynamoDB is the preferred data store for mobile applications hosted on AWS,
    we looked at how to authorize web identity users to access specific data using
    a combination of IAM and STS tokens. Next, we will move on to monitoring our DynamoDB
    tables to make sure that we don't get caught off guard by throttles.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring DynamoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you look at what metrics you need to concentrate on when monitoring DynamoDB,
    there are a few that come into focus:'
  prefs: []
  type: TYPE_NORMAL
- en: Our `GET` and `PUT` requests are in the range of what we expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are not being throttled by either read or write capacity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the DynamoDB console itself, we can get quite a few metrics regarding our
    table's health.
  prefs: []
  type: TYPE_NORMAL
- en: First, we can see both read and write capacity at a glance.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a section in the metrics of any table that you choose for basic
    latency showing four areas of interest: `GET`, `PUT`, `Query`, and `Scan Latency`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s log in to the **Amazon Management Console** and take a look at these
    basic metrics for ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the **Amazon Management Console** using the account you previously
    created for the projects table in DynamoDB.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the search box at the top, type `DynamoDB` so that the service name appears
    in the results. Click **DynamoDB** to be taken to the DynamoDB service. On the
    top-right-hand side, double-check that you are in the correct region where you
    created the table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you are at the main DynamoDB screen, click **Tables** on the left-hand
    side menu. Once clicked, you should see the table you created earlier, named **projects**:![Figure
    5.7 – Showing the DynamoDB Tables menu option on the left-hand menu
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_5.7_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.7 – Showing the DynamoDB Tables menu option on the left-hand menu
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the table named **Projects** in the main window. This will open another
    pane, adding more information about your table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From here, we can select the **metrics** tab from the top tab bar in the rightmost
    pane:![Figure 5.8 – The top menu bar once in the DynamoDB table
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_5.8_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.8 – The top menu bar once in the DynamoDB table
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If, in the **metrics** display, you don't see much activity, then try running
    the queries from the CLI that we created previously in this chapter. This should
    prompt the metrics meters to start showing more PUT and GET objects of the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Contributor Insights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enabling **Contributor Insights** for your DynamoDB table allows you to gain
    much better insight into the items that are being accessed and throttled. This
    allows you to make adjustments to your table or schema accordingly, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have enabled **Contributor Insights**, DynamoDB creates two rules
    on your behalf if you only have a primary key:'
  prefs: []
  type: TYPE_NORMAL
- en: Most accessed items (partition key)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most throttled keys (partition key)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you have a global secondary index or sort key, there will be two additional
    rules created for you by DynamoDB. These are specific to secondary indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: Most accessed keys (partition and sort keys)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most throttled keys (partition and sort keys)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the NoSQL service known as DynamoDB. We explored
    how tables are created and partitioned, along with how to write and query data
    from DynamoDB. We also examined how to stream data from tables to other sources,
    along with using the **DynamoDB Accelerator** (**DAX**), a specialized cache,
    to help speed up our queries.
  prefs: []
  type: TYPE_NORMAL
- en: We have now finished Part 1, *Establishing Fundamentals*, where we reviewed
    **Amazon Web Services**. Next, we will move on to *Part 2*, *Developing, Deploying,
    and Using Infrastructure as Code*. In the upcoming chapters, we will incorporate
    many of the services that we have just discussed and then put them into action.
  prefs: []
  type: TYPE_NORMAL
- en: Review questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application is storing project data in a DynamoDB table. You need to run
    a query to find all the builds that were run by a specific department last month.
    Which attributes would you use in your query?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. The partition key of `Build_Date` and the sort key of `Department`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. A composite primary key made up of `Department` and `Build_Date`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. The partition key of `Department` and the sort key of `Build_Date`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. The partition key of `Build_Date` and the sort key of `Dept_ID`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Which of the following AWS services provides an in-memory write-through cache
    that has been optimized for DynamoDB?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. ElastiCache
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. CloudFront
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. DAX
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Athena
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A scan operation in DynamoDB is used for which of the following scenarios?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. To return the entire contents of the table, filtered on the primary or sort
    key
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. To find items in a table based on a primary key attribute
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. To find items in a table based on a sort key attribute
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. To return all the items in a table
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Your developers have created a DynamoDB table and seem to find that the performance
    always slows down after 20-25 minutes of their testing process. They can see from
    the basic monitoring on the AWS console that their requests are being throttled.
    What can you do to help pinpoint the issue?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Increase the **Read Capacity Units** (**RCUs**) on the table so that the
    queries are no longer throttled.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Enable **Contributor Insights** on the table so that the keys that are being
    throttled the most are shown.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. Add enhanced **Cloud Watch** monitoring with alarms whenever throttling occurs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Add **adaptive capacity** to the table so that the extra **Read Capacity
    Units** (**RCUs**) are spread evenly across partitions that are becoming hot.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Which of the following items would make a good partition key?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`a.` `OrderID`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`b.` `Ship_From_Location`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`c.` `Total`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`d.` `Product_Brand`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Review answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
