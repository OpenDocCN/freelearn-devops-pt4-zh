- en: 'Chapter 6: Understanding CI/CD and the SDLC'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **software development life cycle** (**SDLC**) section of the exam is the
    heaviest weighted of all the sections. Understanding the concept of SDLC, as well
    as **continuous integration** (**CI**) and **continuous deployment** (**CD**),
    is paramount for passing the **Amazon Web Services** (**AWS**) **development-operations**
    (**DevOps**) exam. There are multiple stages in the SDLC, and there are specific
    AWS and third-party services that map to these stages.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the role that the AWS services play—along with key third-party tools—is
    also essential, not only to pass the exam but also to know for your day-to-day
    duties as a DevOps engineer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the SDLC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development teams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the different types of deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to the SDLC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The SDLC consists of the following six basic cycles or stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy (for release)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These stages are depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Phases of CI/CD'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.1_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Phases of CI/CD
  prefs: []
  type: TYPE_NORMAL
- en: The first four of these stages fall on the development side of DevOps. The fifth
    falls on the operations side, and the final stage is done as a team exercise.
    You may notice in the preceding diagram that the planning phase is absent. Once
    again, this is a phase that, although a vital part of the SDLC, is not part of
    either the CI or CD process.
  prefs: []
  type: TYPE_NORMAL
- en: One of the initial things we need to understand in the context of this session
    is the use of the acronym *CI/CD*. As we think about the CI stage, we are talking
    about the first three steps of the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: CI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CI is a software development practice through which developers regularly merge
    their code changes into a central repository. After this, one or more automated
    builds are initiated, and tests are run against both the code that was committed
    and the previously existing code base.
  prefs: []
  type: TYPE_NORMAL
- en: AWS native tools for CI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we will look at some of the tools that AWS offers within its ecosystem
    to help with CI.
  prefs: []
  type: TYPE_NORMAL
- en: AWS CodeCommit
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**AWS CodeCommit** allows you to host private source control repositories in
    a highly scalable fashion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the main benefits of CodeCommit:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ability to collaborate**: Software teams can work together on a code base
    using known Git functions such as pull requests, branches, and merging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encryption**: CodeCommit repositories are automatically encrypted at rest
    using AWS **Key Management Service** (**KMS**). Code transfers to and from the
    repository are also encrypted via either **HyperText Transfer Protocol Secure**
    (**HTTPS**) or **Secure Shell** (**SSH**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access control**: Being fully integrated with the AWS **Identity and Access
    Management** (**IAM**) service allows you to specify which users have access to
    which repositories, without having to navigate through a third-party system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High availability**: AWS CodeCommit is backed by **Amazon Simple Storage
    Service** (**Amazon S3**) and **Amazon DynamoDB** for code-and-commit storage.
    This is a highly redundant and scalable setup to ensure that your repositories
    are accessible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Notifications**: CodeCommit can be integrated with **Amazon Simple Notification
    Service** (**Amazon SNS**) so that events significant to the repository can be
    broadcast to the correct channels. Notifications sent by CodeCommit include a
    status message and a link to the corresponding repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CodeBuild
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you look to compile the code you have committed in your source control repository
    and create software packages for deployment, **AWS CodeBuild** allows teams to
    customize their build-and-test process using the **YAML Ain't Markup Language**
    (**YAML**) language.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the main benefits of AWS CodeBuild:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fully managed**: With CodeBuild, there is no need to set up a separate build
    server. This means that there are no more software patches or updates, and nothing
    to manage. Jobs are set up and submitted, and then run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure**: CodeBuild is integrated with the IAM service and, hence, users
    can be assigned to specific build projects only. Any artifacts that CodeBuild
    produces are encrypted with AWS KMS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalable**: CodeBuild scales automatically according to the number of jobs
    that have been submitted at any one time. There is no need to think about vertical
    or horizontal scaling when a big burst of build jobs or tests is about to happen,
    as CodeBuild handles all this automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enables CI and CD**: As part of the **AWS Developer** services, CodeBuild
    naturally integrates into other CI/CD tools offered, such as **CodeCommit** and
    **CodePipeline**. Integration has also been done with other tools in the ecosystem—**Jenkins**,
    for example, has the ability to use CodeBuild as a scalable worker node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CodeArtifact
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As software builds get more regimented, companies and teams start to look for
    a way to ensure that everyone is using the same approved packages and versions
    of packages. This is where the managed artifact repository **CodeArtifact** comes
    into play.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in the security of your build process, then CodeArtifact
    offers a number of features that help your development teams create a safer environment.
    Firstly, packages and artifacts needed in the build process can be accessed from
    a **virtual private cloud** (**VPC**) using AWS PrivateLink endpoints. This means
    that if you have the necessary libraries and items needed for the build stored
    on your CodeArtifact service, then these files can be transferred to your functions
    and instances without a need to traverse the public internet.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, with the CodeArtifact service, you as an account administrator have
    the ability to approve packages for use. This approval process can also be automated
    using a combination of the CodeArtifact **application programming interfaces**
    (**APIs**) and the Amazon EventBridge service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thirdly, many package repositories have recently been placing download limits
    on their servers. Having a deployment or build fail due to the fact that the repository
    is not currently taking download requests from the current **Internet Protocol**
    (**IP**) address is not only frustrating—it can also become a real impediment
    for deployment. For example, if you are building your instances in real time versus
    having pre-built **Amazon Machine Images** (**AMIs**) and you have the need for
    certain node packages from public **Node Package Manager** (**npm**) servers,
    then if you are in an autoscaling state and are trying to scale to meet the traffic
    demands of your customers, this can become more than just a nuisance. However,
    if you have your packages stored on AWS CodeArtifact, then you are not limited
    by any third-party servers and can build your functions and instances, pulling
    down the required packages as many times as required, as illustrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – AWS CodeArtifact with connection to external repositories'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.2_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – AWS CodeArtifact with connection to external repositories
  prefs: []
  type: TYPE_NORMAL
- en: You can configure CodeArtifact to go out to public repositories and fetch popular
    packages for storage and versioning for your teams. CodeArtifact can work with
    package managers many developers are both familiar and comfortable with, including
    `pip`, `yarn`, `npm`, `Maven`, and `Gradle`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the main benefits of CodeArtifact:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Store and share artifacts securely**: If integrated with the KMS service,
    the artifacts you store in CodeArtifact can be encrypted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduce operational overhead**: CodeArtifact quashes the need for the setup
    and maintenance of an artifact server. It is a highly available service that scales
    automatically to the number of artifacts stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Publish and share packages**: CodeArtifact allows you a central place to
    publish the packages your team creates, eliminating the need to hunt around on
    the internet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm` registry, `NuGet.org`, and **Maven Central** with a couple of clicks
    instead of complex scripting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous delivery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the deployment to production occurs with continuous delivery, there will
    most likely be a manual approval process rather than an automated deployment.
  prefs: []
  type: TYPE_NORMAL
- en: AWS native tools for continuous delivery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's take a brief look at some of the AWS tools used in continuous delivery.
  prefs: []
  type: TYPE_NORMAL
- en: AWS CodeDeploy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These are the main benefits of CodeDeploy:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automated deployments**: CodeDeploy totally automates software deployments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ease of adoption**: CodeDeploy can easily be integrated into your existing
    deployment tooling, such as Jenkins, GitHub, or AWS CodePipeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consolidated control**: In one view, CodeDeploy can both show you the status
    of your deployment and provide the ability to send push notifications to one or
    multiple members of your team, letting them know the pass or fail status of builds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimize downtime**: In allowing you to introduce your changes incrementally,
    CodeDeploy helps preserve the availability of your application. It can also help
    the process of rolling back to a previous version should an issue be discovered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CodePipeline
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: AWS CodePipeline allows you to automate the building, testing, and deploying
    steps and phases that you go through while you produce your software and **Infrastructure
    as Code** (**IaC**). It can be integrated with third-party services such as GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the main benefits of CodePipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rapid delivery**: CodePipeline provides quick feedback to you and your team
    as you move your code through a structured process to deployment. Flaws can be
    found and fixed without too much effort.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to integrate**: If you have existing pieces already in use for your
    CI/CD process, then CodePipeline allows you to incorporate those items without
    any hassle. This can include a Jenkins server that is already set up to run tests
    running in the cloud or on-premises or even a third-party source code repository
    such as GitHub.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configurable workflow**: Each software release has a slightly different process
    depending on the tests configured or the service that it is being deployed. CodePipeline
    provides you the ability to customize your steps in a variety of ways, including
    with the **AWS Management Console** interface, using the **command-line interface**
    (**CLI**) or one of the available AWS **software development kits** (**SDKs**),
    or even by crafting your pipeline in a **CloudFormation template**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved quality**: CodePipeline allows you to automate all your processes
    in an easy-to-follow flow so that steps are not missed when doing a deployment.
    Having tests run automatically allows for consistency in your code and provides
    developers with instant feedback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With CD, there is no manual approval process as the code revisions are pushed
    into the production environment. Instead, testing practices and guidelines are
    relied on in order to ensure the integrity of code meets quality checks before
    being automatically deployed to the production environment. Any revisions that
    don't meet these guidelines then get failed as a build process, and feedback is
    given to either the individual developer or the development team. This initial
    feedback can be simple in nature, such as a notification that a build has failed,
    and can be in the form of an email or a **Short Message Service** (**SMS**) message
    that could be sent using the **SNS service**. An alternative to this could even
    be posted to a messaging service such as **Slack** or **Microsoft Teams**, using
    a combination of SNS and **AWS Lambda** to post the message.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery is *not* CD. This is a common mistake that many make. You
    need to understand, however, that with continuous delivery every commit that passes
    a set of automated tests is then pushed into the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how the SDLC translates into the different developer
    tools provided by AWS. You can see from the following diagram that almost every
    stage has its own dedicated service. The exceptions are the build and test stages,
    where AWS CodeBuild can perform both of these tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – AWS tools used in CI/CD'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.3_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – AWS tools used in CI/CD
  prefs: []
  type: TYPE_NORMAL
- en: As we look at CI and continuous delivery from an **Amazon code tools** point
    of view, there are several tools that can help you achieve these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing plays a vital role in the SDLC. It can help you improve the reliability,
    scalability, performance, and security of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Did you notice how many of the things that testing provides are pillars of AWS?
    Although it may seem faster to leave testing out of your initial pipeline design,
    it's a vital part of ensuring the stability, safety, and capabilities of your
    workload.
  prefs: []
  type: TYPE_NORMAL
- en: If you have potential weaknesses in your code, testing is one of the ways that
    you can discover many of them. This can prevent you from deploying a fatal flaw
    into your production environment. As you automate this process as a DevOps engineer,
    the initial outlay to build the pipelines can be a bit of an effort. Once the
    pipeline and tests have been established, then multiple types of code—including
    both IaC and application code—can be both tested and deployed in a rapid and repeatable
    fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Types of affiliated tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are a variety of different types of tests available to ensure that your
    code base is functioning as it should. Each type of test performs a specific task,
    and some take more time to run than others. Here''s a diagram showing the different
    testing stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Different stages of testing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.4_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – Different stages of testing
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the stages in *Figure 6.4*, we can see the relative speed at which
    tests can be performed. We can now examine each of the testing types in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Unit tests** are small in the amount of code they span but provide developers
    instant feedback, especially since they can be run directly from a developer''s
    individual machine. They can be added to a CI/CD pipeline, where they can be used
    to proactively prevent any known defects from entering into the code base.'
  prefs: []
  type: TYPE_NORMAL
- en: Service integration and component tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Integration tests** are used to check that all the different components in
    a system work together. These tests can also include tests of any third-party
    services or APIs. Examples of integration tests would be having the web layer
    insert a test value into a database to ensure connectivity or send a notification
    after an event.'
  prefs: []
  type: TYPE_NORMAL
- en: Performance and compliance tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you have built your application, you need to know that it will handle your
    estimated traffic effectively. This includes scaling out and in with your resources
    as need be and checking the system while it is under sizable load. **Performance
    tests** will help accomplish this task, exposing a lack of performance or bottlenecks
    that the system might display under normal usage or high usage. Two of the most
    popular types of performance tests are **stress** tests and **soak** tests. A
    stress test will simulate many users on the resources for a small duration of
    time or for a set number of routines, such as playing back web server logs to
    emulate past users. A soak test, on the other hand, gives a steady stream of users
    over a much longer period of time such as a week or more, trying to expose items
    such as memory leaks or bad routines that don't show up under short durations.
  prefs: []
  type: TYPE_NORMAL
- en: Adding security and compliance tests such as **static application security testing**
    (**SAST**) and **dynamic application security testing** (**DAST**) allows known
    vulnerabilities that have been reported and discovered to be exposed. Adding these
    types of tests to your CI/CD pipeline is part of the **development-security-operations**
    (**DevSecOps**) umbrella.
  prefs: []
  type: TYPE_NORMAL
- en: User interface tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the top of the pyramid are **user interface** (**UI**) tests. These tests
    are not just testing the **graphical UI** (**GUI**), but the system as a whole.
    Tests can encompass routines such as ensuring users can log in correctly or reset
    a password. They may contain activities such as uploading and downloading files
    or visiting specific pages that touch datastores and middleware components.
  prefs: []
  type: TYPE_NORMAL
- en: Although manual testing may be introduced out of necessity during this stage,
    it's better to keep manual tests to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: Maturing throughout the process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When initially starting to build your CI system, you may only have a few steps,
    such as pulling code from a source code repository and deploying to a test server.
  prefs: []
  type: TYPE_NORMAL
- en: As time goes on, the code base will gain a greater amount of test coverage and
    settings will be tuned so that team members will have much more confidence in
    the deployment process, so much so that they come to rely on it as just another
    day-to-day tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you mature, you will find that you are starting to gain the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Speed**: Teams become much more self-sufficient with automated pipelines
    and release processes. There is no more waiting for a particular person or team
    to install developed software packages or updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reliability**: Automating your process eliminates dependency on a single
    person who knows the process. Any team member who starts the process will feel
    confident that it will run the same each and every time it is invoked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: Creating a pipeline with standard steps for your deployments
    makes for a consistent process each time a process is initiated. This prevents
    any steps such as testing from being forgotten or skipped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: The frequency of updates can—and usually does—increase as
    your organization begins to scale. Automated pipelines that have steps to build,
    test, and deploy out to different environments help you scale without adding additional
    staff.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficiency**: Moving your testing from a manual to an automated process allows
    you to not only speed up the testing process but also allows the testing team
    to concentrate on developing new and improved tests versus spending their time
    manually testing the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have looked at the actual SDLC process, we will now look at optimizing
    the setup of teams for the CI/CD process.
  prefs: []
  type: TYPE_NORMAL
- en: Development teams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s a recommendation from AWS to have three development teams for implementing
    a CI/CD environment: **an application team**, **an infrastructure team**, and
    **a tools team**. Amazon preaches the concept of two-pizza teams, meaning that
    no team should be larger than could be fed by two pizzas. Smaller teams lead to
    better collaboration, have full ownership of their features or application, have
    full accountability, and—last but not least—this all aligns with the DevOps model
    of agility.'
  prefs: []
  type: TYPE_NORMAL
- en: The application team
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Application team** members are the ones responsible for creating an application
    itself. Members of this team are skilled in one or more programming languages,
    but also have (or come to have) a deep understanding of the platform and system
    configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: Application team members have responsibility for creating a backlog of items
    that need to be worked on, as well as creating a task for working on stories.
    In addition to having the programming skills to create and maintain an application,
    this team should also become skilled in automation to allow members to create
    their own pieces of the pipeline once the tooling has been created.
  prefs: []
  type: TYPE_NORMAL
- en: The infrastructure team
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order for the application team members to run their applications, they need
    some infrastructure to run them on. Even if an application is of a serverless
    nature, it still needs to have permissions created in IAM. If it's not a serverless
    setup, then there are servers to provision and manage.
  prefs: []
  type: TYPE_NORMAL
- en: With the **infrastructure team**, this is done via IaC either via CloudFormation,
    using scripts with the AWS CLI, or with the AWS **Cloud Development Kit** (**CDK**).
  prefs: []
  type: TYPE_NORMAL
- en: Many times, this team will also be responsible for things such as **Active Directory
    (AD) servers** and **single sign-on (SSO) integration**, especially because they
    are tightly coupled with the IAM permissions.
  prefs: []
  type: TYPE_NORMAL
- en: The tools team
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **tools team** both builds and manages the CI/CD pipeline. This team must
    be proficient in building and integrating all of the different pieces and components
    of the pipeline so that the dependent application teams have a smooth process.
    Although the tools team is not part of the two-pizza team, it is responsible for
    creating tooling and systems that enable the other teams to perform their jobs.
  prefs: []
  type: TYPE_NORMAL
- en: The team may choose to implement tools and services such as AWS CodeCommit,
    CodePipeline, CodeBuild, and CodeDeploy, along with other third-party tools such
    as Jenkins, GitHub, Bitbucket, Artifactory, and other related tools.
  prefs: []
  type: TYPE_NORMAL
- en: Many organizations will classify the tools team as the DevOps team, but this
    is a misnomer as DevOps is more of a practice of people and processes versus the
    use of tools.
  prefs: []
  type: TYPE_NORMAL
- en: Not every tools team is ready to make a complete buy-in to the AWS toolset,
    and AWS understands this. There is even an entire whitepaper around the automation
    server Jenkins. Having an understanding of how third-party tools interact and
    complement the AWS ecosystem is essential knowledge for the DevOps professional
    exam.
  prefs: []
  type: TYPE_NORMAL
- en: With our team members now having areas they can concentrate on to maximize their
    effectiveness, we will move on to the types of deployments and see how to choose
    a deployment strategy that best fits our needs.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the different types of deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you think about deployments, especially as we have been talking about the
    SDLC, you may think we are talking about application code. However, as you move
    to automate more and more of your systems in AWS, deployments can take on multiple
    meanings. Deployments can mean application code, but they could also mean infrastructure
    code, configuration code, or other layers.
  prefs: []
  type: TYPE_NORMAL
- en: There are five main types of deployment strategies to consider when dealing
    with deployments on AWS. Each method has its own advantages and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: 'When choosing a deployment strategy, these are the main things you need to
    consider:'
  prefs: []
  type: TYPE_NORMAL
- en: How quickly can you deploy?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are any **Domain Name System** (**DNS**) changes needed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Would there be any impact with a failed deployment?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What would the rollback process be?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where would the code be linked to? (New or existing instances?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this in mind, let's look at the five different deployment strategies in
    depth.
  prefs: []
  type: TYPE_NORMAL
- en: In-place deployments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you perform an **in-place deployment**, you are updating instances that
    have already been deployed to an environment. A load balancer can be used to deregister
    each instance while doing the deployment, perform a health check, and then place
    the healthy instance back into service. In-place deployments can be done all at
    once or they can be done as a rolling deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the pros and cons of in-place deployments, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.1 – In-place deployment pros and cons'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/012.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6.1 – In-place deployment pros and cons
  prefs: []
  type: TYPE_NORMAL
- en: Immutable and blue-green deployments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the case of **blue-green deployments**, a whole new set of infrastructure
    is created and often tested before doing a DNS switch to the new environment.
    This is the safest type of deployment method, but it takes time and is also the
    costliest since you are bringing up two full environments for a period of time
    until you do the DNS switchover. You then have an option to take down the secondary
    environment once it is not being used at that moment to save on costs, or you
    can keep it running in the background to save on deployment time and use it as
    a failover environment. In the case of a deployment failure, your customers would
    never even know, since when using blue-green deployments you only switch the DNS
    once your second (or green) environment is up and healthy.
  prefs: []
  type: TYPE_NORMAL
- en: '**Immutable deployments** refer to deploying code for a whole new set of resources
    using new configurations or new application code. This task is made much simpler
    in the cloud versus on-premises hardware as resources can be provisioned using
    simple API calls.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows both the pros and cons of immutable deployments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.2 – Blue-green deployment pros and cons'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6.2 – Blue-green deployment pros and cons
  prefs: []
  type: TYPE_NORMAL
- en: See [*Chapter 13*](B17405_13_Final_JM_ePub.xhtml#_idTextAnchor338), *Blue Green
    Deployments*, for a much deeper look at blue-green deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Canary deployments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `0`% on the new instance **Canonical Names** (**CNAMEs**) or by taking the
    new instances out of the load balancer. At that point, the new instances are taken
    down out of service, and any launch configurations that were previously updated
    can be updated to use a previous version of a working AMI.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following table, we compare the pros and cons of using a canary deployment
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.3 – Canary deployment pros and cons'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6.3 – Canary deployment pros and cons
  prefs: []
  type: TYPE_NORMAL
- en: Rolling deployments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using a **rolling deployment**, not all of the instances are updated at
    the same time. This strategy prevents any downtime since if a process fails, only
    a portion of the group is upgraded at any one particular time. As the initial
    instances are sent to the deployments, they must come back both healthy and online
    before further instances will be engaged in the new deployment.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that since not all members of the group are deployed
    at the same time with either the application code or system upgrades, then there
    could be multiple versions running for a user to experience. Using sticky sessions
    can help, but not eliminate, trying to provide a seamless experience to a customer
    during a single session while deployment is happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it''s not a long list of pros and cons, take a look at the following
    table to see the benefits and drawbacks of using a rolling deployment method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.4 – Rolling deployment pros and cons'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6.4 – Rolling deployment pros and cons
  prefs: []
  type: TYPE_NORMAL
- en: Linear deployments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a linear deployment, traffic is shifted equally in increments across resources
    over a set number of predefined increments. A linear deployment is a subset of
    the blue-green deployment type. Instead of deploying to the instances or resources
    that your application is currently running on, you are first standing up a new
    set of infrastructure and then over time shifting your traffic from the old code
    base to a new one, using a service such as **Route 53** and weighted routing.
    This way, you can keep a close eye on your new environment, and if any issues
    arise then you can quickly shift all traffic back to the original environment,
    with no downtime.
  prefs: []
  type: TYPE_NORMAL
- en: Linear deployments can also be done with Lambda aliases and Fargate containers
    in order to shift a percentage of your traffic to a new version of your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if your deployment window is 1 hour and you want to spread 100%
    of your traffic in equal increments to new resources in that hour, then your linear
    strategy may go something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimum 0-16% of traffic shifted over to the new resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum 10-32% of traffic shifted over to the new resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum 20-48% of traffic shifted over to the new resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum 30-64% of traffic shifted over to the new resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum 40-80% of traffic shifted over to the new resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum 50-96% of traffic shifted over to the new resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum 60-100% of traffic shifted over to the new resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are both pros and cons to using a linear deployment method, so let''s
    compare them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.5 – Linear deployment pros and cons'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6.5 – Linear deployment pros and cons
  prefs: []
  type: TYPE_NORMAL
- en: We will be covering Lambda in depth in [*Chapter 12*](B17405_12_Final_JM_ePub.xhtml#_idTextAnchor307),
    *Lambda Deployments and Versioning.*
  prefs: []
  type: TYPE_NORMAL
- en: All-at-once deployments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this type of deployment, all the traffic is shifted from the original environment
    to a new environment at the same time. This is the fastest of all deployment methods.
    This also means that any rollbacks that need to happen would also take the most
    amount of time, as the code would need to be redeployed to all instances. You
    *can have downtime* with this type of deployment if you have an issue as you wait
    for your rollback to come back online.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages and disadvantages of using an *all-at-once deployment method*
    are outlined in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.6 – All-at-once deployment pros and cons'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6.6 – All-at-once deployment pros and cons
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: An all-at-once deployment can also be called an in-place deployment. Be familiar
    with both terms as either can show up on test questions.
  prefs: []
  type: TYPE_NORMAL
- en: Review questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A medium-sized software company has hired you as a DevOps consultant to help
    set up its deployment pipeline. The staff want to be able to push their tested
    code into their production environment in a quick manner but do not want the possibility
    of dealing with downtime for their customers. Their DNS is hosted on a third-party
    service, and changes to the DNS would require a change ticket. Which deployment
    method would you recommend implementing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Blue-green deployment
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. In-place deployment
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. All-at-once deployment
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Rolling deployment
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A medical device company is looking to set up its development pipeline using
    Jenkins to deploy its code base in an automated fashion. Since this is only the
    development environment, they want to keep costs to a minimum and would be fine
    if the application team needed to redeploy in case of a failed deployment. Which
    strategy should they use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Blue-green deployment
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. In-place deployment
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. All-at-once deployment
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Rolling deployment
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A mobile gaming company is trying to speed up its production time with all the
    new enhancements it has been developing for its most popular game. Staff have
    noticed on social media that around the dates of the last two releases, users
    complained of an increased number of glitches. Some of the glitches reported were
    known issues to teams that were working on the development of the game. The gaming
    company already has an automated deployment pipeline set up with AWS CodePipeline,
    and its code is stored in AWS CodeCommit. What is the most cost-effective way
    to reduce the number of glitches being deployed in each release?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Spin up a new environment and run full UI tests before releasing the code
    to the production environment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Add a step in the current CodePipeline to spin up an EC2 instance that runs
    the Jenkins software and can use **Simple Systems Manager** (**SSM**) **Parameter
    Store** to download the current CodeCommit repository, after which it runs unit
    tests to pass or fail the build.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. Add a CodeDeploy step to the current AWS pipeline that runs the current set
    of unit tests connected to an AWS SNS topic so that on failure, the current build
    is failed and the development team is notified.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Add a CodeBuild step to the current AWS pipeline that runs the current set
    of unit tests connected to an AWS SNS topic so that on failure, the current build
    is failed and the development team is notified.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A research company is working on a confidential project and the management team
    wants to be aware of any progress made as soon as it happens. The developers are
    using AWS CodeCommit for their source code versioning, along with CodeBuild to
    run unit tests. Which measures can you put in place to allow the management team
    to get the updates they desire? (Choose all that apply)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Create an SNS topic for the management team and add all their emails.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Have AWS CodeCommit push notifications to an SNS topic any time that either
    a commit has been made or a feature branch has been merged with the master.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. Have CodeCommit create a daily report of commit activity and then push the
    report to S3 so that the management team can view it from a bucket to which they
    have access.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Enable notifications on AWS CodeBuild to an SNS topic for when a job passes
    or fails.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A growing company currently has a Jenkins server that runs on EC2\. Developers
    are complaining that they are waiting too long for their builds to get started
    and complete. You have been asked to help the tools team in coming up with a solution
    that can scale with the growth and speed of the development team but can also
    be implemented in the quickest and most cost-effective manner possible. Which
    solution will least need to be managed by the tools team?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Create an AMI from the Jenkins server and use the AMI to create three additional
    worker nodes, using the current Jenkins system as the master.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Rebuild the Jenkins server as a containerized system using `1`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Create an AMI from the Jenkins server and use the AMI to create a launch
    configuration for an autoscaling group that will launch a new Jenkins instance
    when the queue gets over a level of `1`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Review answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a, b, d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the **SDLC**, **CI**, **continuous delivery**,
    and **CD**. We also started to look at the tools AWS offers that can help us with
    these different stages of the SDLC. Then, we took a look at the different types
    of teams and what their job responsibilities consist of. Finally, we reviewed
    the different types of deployment strategies available in AWS and how they can
    best be used.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be taking a deeper dive into AWS's CloudFormation
    IaC service. We will see how to create reusable resources, along with the scripting
    methods available in CloudFormation templates.
  prefs: []
  type: TYPE_NORMAL
