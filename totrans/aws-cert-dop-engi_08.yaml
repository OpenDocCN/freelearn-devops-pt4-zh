- en: 'Chapter 6: Understanding CI/CD and the SDLC'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章：理解 CI/CD 和 SDLC
- en: The **software development life cycle** (**SDLC**) section of the exam is the
    heaviest weighted of all the sections. Understanding the concept of SDLC, as well
    as **continuous integration** (**CI**) and **continuous deployment** (**CD**),
    is paramount for passing the **Amazon Web Services** (**AWS**) **development-operations**
    (**DevOps**) exam. There are multiple stages in the SDLC, and there are specific
    AWS and third-party services that map to these stages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**软件开发生命周期**（**SDLC**）是考试中最重的部分。理解 SDLC 的概念，以及 **持续集成**（**CI**）和 **持续部署**（**CD**）是通过
    **亚马逊 Web 服务**（**AWS**） **开发运维**（**DevOps**）考试的关键。SDLC 包括多个阶段，AWS 和第三方服务与这些阶段相对应。'
- en: Knowing the role that the AWS services play—along with key third-party tools—is
    also essential, not only to pass the exam but also to know for your day-to-day
    duties as a DevOps engineer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 AWS 服务所扮演的角色—以及关键的第三方工具—不仅对通过考试至关重要，也是作为 DevOps 工程师日常工作中的必备知识。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主要内容：
- en: Introduction to the SDLC
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SDLC 介绍
- en: Development teams
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发团队
- en: Understanding the different types of deployments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解不同类型的部署
- en: Introduction to the SDLC
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SDLC 介绍
- en: 'The SDLC consists of the following six basic cycles or stages:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: SDLC 包括以下六个基本周期或阶段：
- en: Source
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码
- en: Build
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建
- en: Test
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Deploy (for release)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署（发布）
- en: Monitor
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控
- en: Plan
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计划
- en: 'These stages are depicted in the following diagram:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这些阶段的示意图：
- en: '![Figure 6.1 – Phases of CI/CD'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.1 – CI/CD 阶段'
- en: '](img/Figure_6.1_B17405.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.1_B17405.jpg)'
- en: Figure 6.1 – Phases of CI/CD
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – CI/CD 阶段
- en: The first four of these stages fall on the development side of DevOps. The fifth
    falls on the operations side, and the final stage is done as a team exercise.
    You may notice in the preceding diagram that the planning phase is absent. Once
    again, this is a phase that, although a vital part of the SDLC, is not part of
    either the CI or CD process.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个阶段属于 DevOps 的开发侧。第五个阶段属于运维侧，最后一个阶段是团队合作完成的。你可能注意到，前面的示意图中没有规划阶段。再次强调，虽然规划阶段是
    SDLC 的重要部分，但它不属于 CI 或 CD 流程的一部分。
- en: One of the initial things we need to understand in the context of this session
    is the use of the acronym *CI/CD*. As we think about the CI stage, we are talking
    about the first three steps of the pipeline.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的讨论中，我们需要理解的一个重要概念是缩写 *CI/CD* 的使用。我们在讨论 CI 阶段时，实际上是在谈论管道的前三个步骤。
- en: CI
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI
- en: CI is a software development practice through which developers regularly merge
    their code changes into a central repository. After this, one or more automated
    builds are initiated, and tests are run against both the code that was committed
    and the previously existing code base.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: CI 是一种软件开发实践，开发人员定期将代码更改合并到中央仓库中。然后，启动一个或多个自动化构建，并对已提交的代码以及之前的现有代码库运行测试。
- en: AWS native tools for CI
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AWS 原生 CI 工具
- en: Next, we will look at some of the tools that AWS offers within its ecosystem
    to help with CI.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看 AWS 在其生态系统中提供的一些工具，以帮助实现 CI。
- en: AWS CodeCommit
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: AWS CodeCommit
- en: '**AWS CodeCommit** allows you to host private source control repositories in
    a highly scalable fashion.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**AWS CodeCommit** 允许你以高度可扩展的方式托管私有源代码控制仓库。'
- en: 'These are the main benefits of CodeCommit:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 CodeCommit 的主要优势：
- en: '**Ability to collaborate**: Software teams can work together on a code base
    using known Git functions such as pull requests, branches, and merging.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作能力**：软件团队可以使用已知的 Git 功能，如拉取请求、分支和合并，共同协作开发代码库。'
- en: '**Encryption**: CodeCommit repositories are automatically encrypted at rest
    using AWS **Key Management Service** (**KMS**). Code transfers to and from the
    repository are also encrypted via either **HyperText Transfer Protocol Secure**
    (**HTTPS**) or **Secure Shell** (**SSH**).'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密**：CodeCommit 仓库使用 AWS **密钥管理服务**（**KMS**）在静态时自动加密。代码在往返仓库的传输过程中，也会通过 **安全超文本传输协议**（**HTTPS**）或
    **安全外壳协议**（**SSH**）加密。'
- en: '**Access control**: Being fully integrated with the AWS **Identity and Access
    Management** (**IAM**) service allows you to specify which users have access to
    which repositories, without having to navigate through a third-party system.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问控制**：与 AWS **身份与访问管理**（**IAM**）服务完全集成，允许你指定哪些用户可以访问哪些仓库，而无需通过第三方系统进行管理。'
- en: '**High availability**: AWS CodeCommit is backed by **Amazon Simple Storage
    Service** (**Amazon S3**) and **Amazon DynamoDB** for code-and-commit storage.
    This is a highly redundant and scalable setup to ensure that your repositories
    are accessible.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高可用性**：AWS CodeCommit 由**亚马逊简单存储服务**（**Amazon S3**）和**亚马逊 DynamoDB**支持，用于代码和提交存储。这是一种高度冗余且可扩展的设置，确保你的仓库可访问。'
- en: '**Notifications**: CodeCommit can be integrated with **Amazon Simple Notification
    Service** (**Amazon SNS**) so that events significant to the repository can be
    broadcast to the correct channels. Notifications sent by CodeCommit include a
    status message and a link to the corresponding repository.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知**：CodeCommit 可以与**亚马逊简单通知服务**（**Amazon SNS**）集成，使得与仓库相关的重要事件可以广播到正确的渠道。CodeCommit
    发送的通知包括状态信息和指向相应仓库的链接。'
- en: AWS CodeBuild
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: AWS CodeBuild
- en: As you look to compile the code you have committed in your source control repository
    and create software packages for deployment, **AWS CodeBuild** allows teams to
    customize their build-and-test process using the **YAML Ain't Markup Language**
    (**YAML**) language.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备编译你在源代码控制仓库中提交的代码并为部署创建软件包时，**AWS CodeBuild** 允许团队使用 **YAML Ain't Markup
    Language**（**YAML**）语言自定义他们的构建和测试过程。
- en: 'These are the main benefits of AWS CodeBuild:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 AWS CodeBuild 的主要优点：
- en: '**Fully managed**: With CodeBuild, there is no need to set up a separate build
    server. This means that there are no more software patches or updates, and nothing
    to manage. Jobs are set up and submitted, and then run.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完全托管**：使用 CodeBuild，无需设置单独的构建服务器。这意味着不再需要进行软件修补或更新，也无需管理任何东西。作业设置好并提交后，便会运行。'
- en: '**Secure**: CodeBuild is integrated with the IAM service and, hence, users
    can be assigned to specific build projects only. Any artifacts that CodeBuild
    produces are encrypted with AWS KMS.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全**：CodeBuild 与 IAM 服务集成，因此用户只能被分配到特定的构建项目。CodeBuild 生成的任何工件都使用 AWS KMS
    进行加密。'
- en: '**Scalable**: CodeBuild scales automatically according to the number of jobs
    that have been submitted at any one time. There is no need to think about vertical
    or horizontal scaling when a big burst of build jobs or tests is about to happen,
    as CodeBuild handles all this automatically.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展**：CodeBuild 会根据提交的作业数量自动进行扩展。当有大量构建作业或测试即将发生时，无需考虑垂直或水平扩展，因为 CodeBuild
    会自动处理所有这些。'
- en: '**Enables CI and CD**: As part of the **AWS Developer** services, CodeBuild
    naturally integrates into other CI/CD tools offered, such as **CodeCommit** and
    **CodePipeline**. Integration has also been done with other tools in the ecosystem—**Jenkins**,
    for example, has the ability to use CodeBuild as a scalable worker node.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持 CI 和 CD**：作为**AWS 开发者**服务的一部分，CodeBuild 自然地集成到其他提供的 CI/CD 工具中，例如 **CodeCommit**
    和 **CodePipeline**。它还与生态系统中的其他工具进行了集成——例如，**Jenkins** 可以将 CodeBuild 作为可扩展的工作节点使用。'
- en: AWS CodeArtifact
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: AWS CodeArtifact
- en: As software builds get more regimented, companies and teams start to look for
    a way to ensure that everyone is using the same approved packages and versions
    of packages. This is where the managed artifact repository **CodeArtifact** comes
    into play.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 随着软件构建变得越来越规范化，公司和团队开始寻找一种方式，确保每个人都在使用相同的已批准的软件包及其版本。这就是托管工件库**CodeArtifact**的作用所在。
- en: If you are interested in the security of your build process, then CodeArtifact
    offers a number of features that help your development teams create a safer environment.
    Firstly, packages and artifacts needed in the build process can be accessed from
    a **virtual private cloud** (**VPC**) using AWS PrivateLink endpoints. This means
    that if you have the necessary libraries and items needed for the build stored
    on your CodeArtifact service, then these files can be transferred to your functions
    and instances without a need to traverse the public internet.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对构建过程的安全性感兴趣，CodeArtifact 提供了许多功能，帮助开发团队创建一个更安全的环境。首先，构建过程中所需的包和工件可以通过使用
    AWS PrivateLink 终端节点从**虚拟私有云**（**VPC**）中访问。这意味着，如果你在 CodeArtifact 服务中存储了构建所需的库和文件，那么这些文件可以传输到你的函数和实例中，而无需穿越公共互联网。
- en: Secondly, with the CodeArtifact service, you as an account administrator have
    the ability to approve packages for use. This approval process can also be automated
    using a combination of the CodeArtifact **application programming interfaces**
    (**APIs**) and the Amazon EventBridge service.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，通过 CodeArtifact 服务，作为账户管理员的你可以批准使用特定的包。这个批准过程也可以通过结合使用 CodeArtifact **应用程序编程接口**（**API**）和
    Amazon EventBridge 服务来自动化。
- en: 'Thirdly, many package repositories have recently been placing download limits
    on their servers. Having a deployment or build fail due to the fact that the repository
    is not currently taking download requests from the current **Internet Protocol**
    (**IP**) address is not only frustrating—it can also become a real impediment
    for deployment. For example, if you are building your instances in real time versus
    having pre-built **Amazon Machine Images** (**AMIs**) and you have the need for
    certain node packages from public **Node Package Manager** (**npm**) servers,
    then if you are in an autoscaling state and are trying to scale to meet the traffic
    demands of your customers, this can become more than just a nuisance. However,
    if you have your packages stored on AWS CodeArtifact, then you are not limited
    by any third-party servers and can build your functions and instances, pulling
    down the required packages as many times as required, as illustrated in the following
    screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，许多包仓库最近开始对其服务器设置下载限制。由于仓库当前不接受来自当前**互联网协议**（**IP**）地址的下载请求而导致部署或构建失败，不仅令人沮丧——它还可能成为部署的真正障碍。例如，如果你是在实时构建实例，而不是使用预先构建的**Amazon
    机器镜像**（**AMI**），并且需要从公共**Node Package Manager**（**npm**）服务器获取某些节点包，那么如果你处于自动扩展状态并且试图扩大规模以满足客户的流量需求，这种情况就不仅仅是个小问题。然而，如果你将包存储在
    AWS CodeArtifact 上，那么你就不受任何第三方服务器的限制，可以根据需要多次下载所需的包，正如下图所示：
- en: '![Figure 6.2 – AWS CodeArtifact with connection to external repositories'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.2 – AWS CodeArtifact 与外部仓库的连接](img/Figure_6.2_B17405.jpg)'
- en: '](img/Figure_6.2_B17405.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.2_B17405.jpg)'
- en: Figure 6.2 – AWS CodeArtifact with connection to external repositories
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – AWS CodeArtifact 与外部仓库的连接
- en: You can configure CodeArtifact to go out to public repositories and fetch popular
    packages for storage and versioning for your teams. CodeArtifact can work with
    package managers many developers are both familiar and comfortable with, including
    `pip`, `yarn`, `npm`, `Maven`, and `Gradle`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以配置 CodeArtifact 从公共仓库获取流行的包，并为你的团队进行存储和版本控制。CodeArtifact 可以与许多开发者熟悉并且舒适使用的包管理工具协同工作，包括`pip`、`yarn`、`npm`、`Maven`和`Gradle`。
- en: 'These are the main benefits of CodeArtifact:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 CodeArtifact 的主要优点：
- en: '**Store and share artifacts securely**: If integrated with the KMS service,
    the artifacts you store in CodeArtifact can be encrypted.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全存储和共享制品**：如果与 KMS 服务集成，你在 CodeArtifact 中存储的制品可以被加密。'
- en: '**Reduce operational overhead**: CodeArtifact quashes the need for the setup
    and maintenance of an artifact server. It is a highly available service that scales
    automatically to the number of artifacts stored.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少运营开销**：CodeArtifact 消除了设置和维护制品服务器的需求。它是一个高度可用的服务，可以根据存储的制品数量自动扩展。'
- en: '**Publish and share packages**: CodeArtifact allows you a central place to
    publish the packages your team creates, eliminating the need to hunt around on
    the internet.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布和共享包**：CodeArtifact 为你提供了一个中心位置来发布你的团队创建的包，消除了在互联网上到处寻找的需求。'
- en: '`npm` registry, `NuGet.org`, and **Maven Central** with a couple of clicks
    instead of complex scripting.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只需点击几下，便可连接`npm`注册表、`NuGet.org`和**Maven Central**，无需复杂的脚本。
- en: Continuous delivery
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续交付
- en: If the deployment to production occurs with continuous delivery, there will
    most likely be a manual approval process rather than an automated deployment.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果生产环境的部署是通过持续交付完成的，那么很可能会有一个手动批准的过程，而不是自动部署。
- en: AWS native tools for continuous delivery
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AWS 原生工具用于持续交付
- en: Let's take a brief look at some of the AWS tools used in continuous delivery.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要了解一些用于持续交付的 AWS 工具。
- en: AWS CodeDeploy
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: AWS CodeDeploy
- en: 'These are the main benefits of CodeDeploy:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 CodeDeploy 的主要优点：
- en: '**Automated deployments**: CodeDeploy totally automates software deployments.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化部署**：CodeDeploy 完全自动化软件部署。'
- en: '**Ease of adoption**: CodeDeploy can easily be integrated into your existing
    deployment tooling, such as Jenkins, GitHub, or AWS CodePipeline.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于采用**：CodeDeploy 可以轻松集成到你现有的部署工具中，如 Jenkins、GitHub 或 AWS CodePipeline。'
- en: '**Consolidated control**: In one view, CodeDeploy can both show you the status
    of your deployment and provide the ability to send push notifications to one or
    multiple members of your team, letting them know the pass or fail status of builds.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集中控制**：在一个视图中，CodeDeploy 可以同时显示你的部署状态，并提供向一个或多个团队成员发送推送通知的功能，告知他们构建的通过或失败状态。'
- en: '**Minimize downtime**: In allowing you to introduce your changes incrementally,
    CodeDeploy helps preserve the availability of your application. It can also help
    the process of rolling back to a previous version should an issue be discovered.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化停机时间**：CodeDeploy 允许你逐步引入更改，从而帮助保持应用程序的可用性。如果发现问题，它还可以帮助你回滚到之前的版本。'
- en: AWS CodePipeline
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: AWS CodePipeline
- en: AWS CodePipeline allows you to automate the building, testing, and deploying
    steps and phases that you go through while you produce your software and **Infrastructure
    as Code** (**IaC**). It can be integrated with third-party services such as GitHub.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CodePipeline 允许你自动化构建、测试和部署步骤，以及你在生产软件和 **基础设施即代码**（**IaC**）过程中经过的各个阶段。它还可以与
    GitHub 等第三方服务集成。
- en: 'These are the main benefits of CodePipeline:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 CodePipeline 的主要优势：
- en: '**Rapid delivery**: CodePipeline provides quick feedback to you and your team
    as you move your code through a structured process to deployment. Flaws can be
    found and fixed without too much effort.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速交付**：CodePipeline 在你将代码通过结构化流程推进到部署过程中，快速地向你和你的团队提供反馈。缺陷可以在没有太多努力的情况下被发现并修复。'
- en: '**Easy to integrate**: If you have existing pieces already in use for your
    CI/CD process, then CodePipeline allows you to incorporate those items without
    any hassle. This can include a Jenkins server that is already set up to run tests
    running in the cloud or on-premises or even a third-party source code repository
    such as GitHub.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于集成**：如果你已经在 CI/CD 流程中使用了现有的组件，CodePipeline 允许你轻松集成这些组件。包括已经设置好在云端或本地运行测试的
    Jenkins 服务器，或者甚至是像 GitHub 这样的第三方源代码库。'
- en: '**Configurable workflow**: Each software release has a slightly different process
    depending on the tests configured or the service that it is being deployed. CodePipeline
    provides you the ability to customize your steps in a variety of ways, including
    with the **AWS Management Console** interface, using the **command-line interface**
    (**CLI**) or one of the available AWS **software development kits** (**SDKs**),
    or even by crafting your pipeline in a **CloudFormation template**.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可配置工作流**：每个软件发布的过程都有些微不同，取决于配置的测试或所部署的服务。CodePipeline 使你能够以多种方式自定义步骤，包括使用
    **AWS 管理控制台** 界面、**命令行界面**（**CLI**）或可用的 AWS **软件开发工具包**（**SDKs**），甚至可以通过编写 **CloudFormation
    模板** 来构建管道。'
- en: '**Improved quality**: CodePipeline allows you to automate all your processes
    in an easy-to-follow flow so that steps are not missed when doing a deployment.
    Having tests run automatically allows for consistency in your code and provides
    developers with instant feedback.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高质量**：CodePipeline 使你能够自动化所有流程，按照易于遵循的步骤执行，从而确保在部署过程中不会遗漏任何步骤。自动运行的测试确保了代码的一致性，并为开发者提供即时反馈。'
- en: CD
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CD
- en: With CD, there is no manual approval process as the code revisions are pushed
    into the production environment. Instead, testing practices and guidelines are
    relied on in order to ensure the integrity of code meets quality checks before
    being automatically deployed to the production environment. Any revisions that
    don't meet these guidelines then get failed as a build process, and feedback is
    given to either the individual developer or the development team. This initial
    feedback can be simple in nature, such as a notification that a build has failed,
    and can be in the form of an email or a **Short Message Service** (**SMS**) message
    that could be sent using the **SNS service**. An alternative to this could even
    be posted to a messaging service such as **Slack** or **Microsoft Teams**, using
    a combination of SNS and **AWS Lambda** to post the message.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CD，不需要手动批准流程，因为代码修订会被推送到生产环境中。相反，依赖于测试实践和指南来确保代码的完整性，在被自动部署到生产环境之前，必须通过质量检查。任何不符合这些指南的修订将会作为构建过程失败，并且会将反馈提供给开发者或开发团队。最初的反馈可能非常简单，比如通知构建失败，可以通过电子邮件或
    **短消息服务**（**SMS**）消息的形式发送，甚至可以使用 **SNS 服务** 发送。另一种选择是通过 **Slack** 或 **Microsoft
    Teams** 等消息服务发布，结合使用 SNS 和 **AWS Lambda** 来发布消息。
- en: Note
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Continuous delivery is *not* CD. This is a common mistake that many make. You
    need to understand, however, that with continuous delivery every commit that passes
    a set of automated tests is then pushed into the production environment.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付并*不是*CD。这是许多人常犯的错误。然而，你需要理解的是，持续交付意味着每次提交都必须通过一组自动化测试，然后才会推送到生产环境中。
- en: 'Let''s take a look at how the SDLC translates into the different developer
    tools provided by AWS. You can see from the following diagram that almost every
    stage has its own dedicated service. The exceptions are the build and test stages,
    where AWS CodeBuild can perform both of these tasks:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看SDLC如何在AWS提供的不同开发工具中得以实现。从以下图示中，你可以看到几乎每个阶段都有自己的专用服务。例外的是构建和测试阶段，AWS CodeBuild可以同时执行这两项任务：
- en: '![Figure 6.3 – AWS tools used in CI/CD'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.3 – AWS工具在CI/CD中的应用](img/Figure_6.3_B17405.jpg)'
- en: '](img/Figure_6.3_B17405.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.3 – AWS工具在CI/CD中的应用](img/Figure_6.3_B17405.jpg)'
- en: Figure 6.3 – AWS tools used in CI/CD
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – AWS工具在CI/CD中的应用
- en: As we look at CI and continuous delivery from an **Amazon code tools** point
    of view, there are several tools that can help you achieve these tasks.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从**Amazon代码工具**的角度来看，CI和持续交付有几个工具可以帮助你完成这些任务。
- en: Testing
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试
- en: Testing plays a vital role in the SDLC. It can help you improve the reliability,
    scalability, performance, and security of your application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 测试在软件开发生命周期（SDLC）中起着至关重要的作用。它可以帮助你提升应用程序的可靠性、可扩展性、性能和安全性。
- en: Note
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Did you notice how many of the things that testing provides are pillars of AWS?
    Although it may seem faster to leave testing out of your initial pipeline design,
    it's a vital part of ensuring the stability, safety, and capabilities of your
    workload.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到测试所提供的许多内容正是AWS的支柱？尽管将测试排除在最初的管道设计之外看似更快，但它是确保工作负载稳定性、安全性和能力的关键部分。
- en: If you have potential weaknesses in your code, testing is one of the ways that
    you can discover many of them. This can prevent you from deploying a fatal flaw
    into your production environment. As you automate this process as a DevOps engineer,
    the initial outlay to build the pipelines can be a bit of an effort. Once the
    pipeline and tests have been established, then multiple types of code—including
    both IaC and application code—can be both tested and deployed in a rapid and repeatable
    fashion.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码中存在潜在的弱点，测试是发现其中许多问题的途径之一。这可以防止你将致命缺陷部署到生产环境中。作为一名DevOps工程师，在自动化这个过程时，构建管道的初期投入可能会有些费力。一旦管道和测试建立完成，随后多种类型的代码——包括基础设施即代码（IaC）和应用程序代码——都可以以快速和可重复的方式进行测试和部署。
- en: Types of affiliated tests
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相关测试类型
- en: 'There are a variety of different types of tests available to ensure that your
    code base is functioning as it should. Each type of test performs a specific task,
    and some take more time to run than others. Here''s a diagram showing the different
    testing stages:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种不同类型的测试可以确保你的代码库按预期运行。每种类型的测试执行特定任务，有些测试需要的时间较长。以下是一个展示不同测试阶段的图示：
- en: '![Figure 6.4 – Different stages of testing'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.4 – 测试的不同阶段](img/Figure_6.4_B17405.jpg)'
- en: '](img/Figure_6.4_B17405.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.4 – 测试的不同阶段](img/Figure_6.4_B17405.jpg)'
- en: Figure 6.4 – Different stages of testing
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 测试的不同阶段
- en: Looking at the stages in *Figure 6.4*, we can see the relative speed at which
    tests can be performed. We can now examine each of the testing types in more detail.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看*图 6.4*，我们可以看到测试执行的相对速度。现在我们可以更详细地查看每种测试类型。
- en: Unit tests
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试
- en: '**Unit tests** are small in the amount of code they span but provide developers
    instant feedback, especially since they can be run directly from a developer''s
    individual machine. They can be added to a CI/CD pipeline, where they can be used
    to proactively prevent any known defects from entering into the code base.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**虽然覆盖的代码量较小，但为开发者提供即时反馈，尤其是因为它们可以直接在开发者的个人机器上运行。它们可以添加到CI/CD管道中，主动防止已知缺陷进入代码库。'
- en: Service integration and component tests
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务集成和组件测试
- en: '**Integration tests** are used to check that all the different components in
    a system work together. These tests can also include tests of any third-party
    services or APIs. Examples of integration tests would be having the web layer
    insert a test value into a database to ensure connectivity or send a notification
    after an event.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成测试**用于检查系统中不同组件是否能够协同工作。这些测试也可以包括对任何第三方服务或API的测试。例如，集成测试可能会测试Web层是否将一个测试值插入数据库以确保连接正常，或在事件发生后发送通知。'
- en: Performance and compliance tests
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能和合规性测试
- en: Once you have built your application, you need to know that it will handle your
    estimated traffic effectively. This includes scaling out and in with your resources
    as need be and checking the system while it is under sizable load. **Performance
    tests** will help accomplish this task, exposing a lack of performance or bottlenecks
    that the system might display under normal usage or high usage. Two of the most
    popular types of performance tests are **stress** tests and **soak** tests. A
    stress test will simulate many users on the resources for a small duration of
    time or for a set number of routines, such as playing back web server logs to
    emulate past users. A soak test, on the other hand, gives a steady stream of users
    over a much longer period of time such as a week or more, trying to expose items
    such as memory leaks or bad routines that don't show up under short durations.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你构建了应用程序，你需要知道它能够有效地处理你预计的流量。这包括根据需要扩展或缩减资源，并在系统承受较大负载时进行检查。**性能测试**将帮助完成这项任务，揭示系统在正常使用或高负载情况下可能表现出的性能问题或瓶颈。两种最常见的性能测试类型是**压力**测试和**浸泡**测试。压力测试会在短时间内或设定的例程数量内模拟大量用户使用资源，比如回放
    web 服务器日志以模拟过去的用户。浸泡测试则会在更长时间内（如一周或更长）持续提供稳定的用户流，尝试揭示如内存泄漏或在短时间内未能显示的问题。
- en: Adding security and compliance tests such as **static application security testing**
    (**SAST**) and **dynamic application security testing** (**DAST**) allows known
    vulnerabilities that have been reported and discovered to be exposed. Adding these
    types of tests to your CI/CD pipeline is part of the **development-security-operations**
    (**DevSecOps**) umbrella.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 添加安全性和合规性测试，如**静态应用安全测试**（**SAST**）和**动态应用安全测试**（**DAST**），可以揭示已报告和发现的已知漏洞。将这些类型的测试添加到你的
    CI/CD 管道中，是**开发-安全-运维**（**DevSecOps**）框架的一部分。
- en: User interface tests
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户界面测试
- en: At the top of the pyramid are **user interface** (**UI**) tests. These tests
    are not just testing the **graphical UI** (**GUI**), but the system as a whole.
    Tests can encompass routines such as ensuring users can log in correctly or reset
    a password. They may contain activities such as uploading and downloading files
    or visiting specific pages that touch datastores and middleware components.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在金字塔的顶端是**用户界面**（**UI**）测试。这些测试不仅测试**图形用户界面**（**GUI**），还测试整个系统。测试可以涵盖像确保用户能够正确登录或重置密码的例程。它们可能包括上传和下载文件或访问特定页面，这些页面涉及数据存储和中间件组件。
- en: Although manual testing may be introduced out of necessity during this stage,
    it's better to keep manual tests to a minimum.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这个阶段可能出于必要性引入手动测试，但最好将手动测试保持在最低限度。
- en: Maturing throughout the process
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在整个过程中不断成熟
- en: When initially starting to build your CI system, you may only have a few steps,
    such as pulling code from a source code repository and deploying to a test server.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当你最初开始构建 CI 系统时，可能只有几个步骤，比如从源代码仓库拉取代码并部署到测试服务器。
- en: As time goes on, the code base will gain a greater amount of test coverage and
    settings will be tuned so that team members will have much more confidence in
    the deployment process, so much so that they come to rely on it as just another
    day-to-day tool.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，代码库将获得更广泛的测试覆盖，设置也将调整，以便团队成员对部署过程更加自信，甚至依赖它作为日常工具之一。
- en: 'As you mature, you will find that you are starting to gain the following benefits:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的成熟，你会发现自己开始获得以下几个好处：
- en: '**Speed**: Teams become much more self-sufficient with automated pipelines
    and release processes. There is no more waiting for a particular person or team
    to install developed software packages or updates.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：团队通过自动化管道和发布过程变得更加自给自足。无需再等待特定人员或团队来安装已开发的软件包或更新。'
- en: '**Reliability**: Automating your process eliminates dependency on a single
    person who knows the process. Any team member who starts the process will feel
    confident that it will run the same each and every time it is invoked.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性**：自动化过程消除了对单个了解流程的人的依赖。任何启动过程的团队成员都会有信心每次启动时都能得到相同的结果。'
- en: '**Consistency**: Creating a pipeline with standard steps for your deployments
    makes for a consistent process each time a process is initiated. This prevents
    any steps such as testing from being forgotten or skipped.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：创建具有标准步骤的部署管道可以使每次启动过程时都保持一致的流程。这可以防止测试等步骤被遗忘或跳过。'
- en: '**Scalability**: The frequency of updates can—and usually does—increase as
    your organization begins to scale. Automated pipelines that have steps to build,
    test, and deploy out to different environments help you scale without adding additional
    staff.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：随着组织的扩展，更新的频率通常会增加。自动化流水线拥有构建、测试和部署到不同环境的步骤，帮助你在不增加额外人员的情况下实现扩展。'
- en: '**Efficiency**: Moving your testing from a manual to an automated process allows
    you to not only speed up the testing process but also allows the testing team
    to concentrate on developing new and improved tests versus spending their time
    manually testing the system.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：将测试从手动过程转移到自动化过程，不仅可以加速测试过程，还可以使测试团队将精力集中在开发新的和改进的测试上，而不是花时间手动测试系统。'
- en: Now that we have looked at the actual SDLC process, we will now look at optimizing
    the setup of teams for the CI/CD process.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了实际的SDLC过程，接下来我们将讨论如何优化CI/CD过程中的团队设置。
- en: Development teams
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发团队
- en: 'It''s a recommendation from AWS to have three development teams for implementing
    a CI/CD environment: **an application team**, **an infrastructure team**, and
    **a tools team**. Amazon preaches the concept of two-pizza teams, meaning that
    no team should be larger than could be fed by two pizzas. Smaller teams lead to
    better collaboration, have full ownership of their features or application, have
    full accountability, and—last but not least—this all aligns with the DevOps model
    of agility.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: AWS建议在实现CI/CD环境时，拥有三个开发团队：**应用团队**、**基础设施团队**和**工具团队**。亚马逊推崇“两块披萨团队”的概念，即任何团队的规模都不应超过两块披萨能够喂饱的程度。较小的团队有助于更好的协作，完全拥有自己的特性或应用程序，承担完整的责任，最后但同样重要的是，这一切与DevOps的敏捷模型一致。
- en: The application team
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用团队
- en: '**Application team** members are the ones responsible for creating an application
    itself. Members of this team are skilled in one or more programming languages,
    but also have (or come to have) a deep understanding of the platform and system
    configuration.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用团队**成员负责创建应用程序本身。该团队的成员精通一种或多种编程语言，并且深入理解平台和系统配置。'
- en: Application team members have responsibility for creating a backlog of items
    that need to be worked on, as well as creating a task for working on stories.
    In addition to having the programming skills to create and maintain an application,
    this team should also become skilled in automation to allow members to create
    their own pieces of the pipeline once the tooling has been created.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 应用团队成员负责创建待处理的事项清单，以及为工作中的故事创建任务。除了具备创建和维护应用程序的编程技能外，该团队还应该掌握自动化技术，以便在工具链创建完成后，团队成员可以创建自己部分的流水线。
- en: The infrastructure team
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础设施团队
- en: In order for the application team members to run their applications, they need
    some infrastructure to run them on. Even if an application is of a serverless
    nature, it still needs to have permissions created in IAM. If it's not a serverless
    setup, then there are servers to provision and manage.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使应用团队成员能够运行他们的应用程序，必须有一些基础设施来支持它们的运行。即便是无服务器应用，它仍然需要在IAM中创建权限。如果不是无服务器设置，则需要配置和管理服务器。
- en: With the **infrastructure team**, this is done via IaC either via CloudFormation,
    using scripts with the AWS CLI, or with the AWS **Cloud Development Kit** (**CDK**).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与**基础设施团队**合作，这一过程通过IaC（基础设施即代码）完成，可以通过CloudFormation，使用AWS CLI脚本，或使用AWS的**云开发工具包**（**CDK**）。
- en: Many times, this team will also be responsible for things such as **Active Directory
    (AD) servers** and **single sign-on (SSO) integration**, especially because they
    are tightly coupled with the IAM permissions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，工具团队还需要负责例如**Active Directory（AD）服务器**和**单点登录（SSO）集成**等任务，特别是因为它们与IAM权限紧密相连。
- en: The tools team
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具团队
- en: The **tools team** both builds and manages the CI/CD pipeline. This team must
    be proficient in building and integrating all of the different pieces and components
    of the pipeline so that the dependent application teams have a smooth process.
    Although the tools team is not part of the two-pizza team, it is responsible for
    creating tooling and systems that enable the other teams to perform their jobs.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**工具团队**负责构建和管理CI/CD流水线。该团队必须熟练构建和集成流水线的各个部分和组件，以确保依赖的应用团队能够顺利进行工作。虽然工具团队不是“两块披萨团队”的一部分，但它负责创建使其他团队能够执行任务的工具和系统。'
- en: The team may choose to implement tools and services such as AWS CodeCommit,
    CodePipeline, CodeBuild, and CodeDeploy, along with other third-party tools such
    as Jenkins, GitHub, Bitbucket, Artifactory, and other related tools.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 团队可能会选择实现诸如AWS CodeCommit、CodePipeline、CodeBuild和CodeDeploy等工具和服务，以及Jenkins、GitHub、Bitbucket、Artifactory等第三方工具。
- en: Many organizations will classify the tools team as the DevOps team, but this
    is a misnomer as DevOps is more of a practice of people and processes versus the
    use of tools.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组织会将工具团队归类为DevOps团队，但这是一个误称，因为DevOps更多的是一种人和过程的实践，而不是单纯的工具使用。
- en: Not every tools team is ready to make a complete buy-in to the AWS toolset,
    and AWS understands this. There is even an entire whitepaper around the automation
    server Jenkins. Having an understanding of how third-party tools interact and
    complement the AWS ecosystem is essential knowledge for the DevOps professional
    exam.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个工具团队都已经准备好完全采用AWS工具集，AWS也理解这一点。甚至有一份关于自动化服务器Jenkins的完整白皮书。了解第三方工具如何与AWS生态系统交互并互补，是DevOps专业考试的必备知识。
- en: With our team members now having areas they can concentrate on to maximize their
    effectiveness, we will move on to the types of deployments and see how to choose
    a deployment strategy that best fits our needs.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 随着团队成员现在可以集中精力在各自的领域中，以最大化其效率，我们将继续讨论部署类型，并了解如何选择最适合我们需求的部署策略。
- en: Understanding the different types of deployments
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解不同类型的部署
- en: When you think about deployments, especially as we have been talking about the
    SDLC, you may think we are talking about application code. However, as you move
    to automate more and more of your systems in AWS, deployments can take on multiple
    meanings. Deployments can mean application code, but they could also mean infrastructure
    code, configuration code, or other layers.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当你考虑部署时，尤其是我们一直在讨论的软件开发生命周期（SDLC），你可能会认为我们在讨论应用程序代码。然而，当你在AWS中自动化更多系统时，部署可能会有多种含义。部署可以指应用程序代码，但也可以指基础设施代码、配置代码或其他层级。
- en: There are five main types of deployment strategies to consider when dealing
    with deployments on AWS. Each method has its own advantages and disadvantages.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理AWS上的部署时，有五种主要的部署策略需要考虑。每种方法都有其优缺点。
- en: 'When choosing a deployment strategy, these are the main things you need to
    consider:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择部署策略时，以下是你需要考虑的主要事项：
- en: How quickly can you deploy?
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能多快完成部署？
- en: Are any **Domain Name System** (**DNS**) changes needed?
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否需要任何**域名系统**（**DNS**）的更改？
- en: Would there be any impact with a failed deployment?
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果部署失败，会有什么影响吗？
- en: What would the rollback process be?
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回滚过程将是什么样的？
- en: Where would the code be linked to? (New or existing instances?)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码会链接到哪里？（新实例还是现有实例？）
- en: With this in mind, let's look at the five different deployment strategies in
    depth.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们深入研究五种不同的部署策略。
- en: In-place deployments
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 就地部署
- en: When you perform an **in-place deployment**, you are updating instances that
    have already been deployed to an environment. A load balancer can be used to deregister
    each instance while doing the deployment, perform a health check, and then place
    the healthy instance back into service. In-place deployments can be done all at
    once or they can be done as a rolling deployment.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行**就地部署**时，你是在更新已经部署到环境中的实例。可以使用负载均衡器在部署过程中注销每个实例，进行健康检查，然后将健康的实例重新投入服务。就地部署可以一次性完成，也可以以滚动部署的方式进行。
- en: 'Let''s take a look at the pros and cons of in-place deployments, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下就地部署的优缺点，如下所示：
- en: '![Table 6.1 – In-place deployment pros and cons'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 6.1 – 就地部署的优缺点'
- en: '](img/012.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/012.jpg)'
- en: Table 6.1 – In-place deployment pros and cons
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.1 – 就地部署的优缺点
- en: Immutable and blue-green deployments
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变部署和蓝绿部署
- en: In the case of **blue-green deployments**, a whole new set of infrastructure
    is created and often tested before doing a DNS switch to the new environment.
    This is the safest type of deployment method, but it takes time and is also the
    costliest since you are bringing up two full environments for a period of time
    until you do the DNS switchover. You then have an option to take down the secondary
    environment once it is not being used at that moment to save on costs, or you
    can keep it running in the background to save on deployment time and use it as
    a failover environment. In the case of a deployment failure, your customers would
    never even know, since when using blue-green deployments you only switch the DNS
    once your second (or green) environment is up and healthy.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在**蓝绿部署**中，会创建一个全新的基础设施，并且通常在进行 DNS 切换之前进行测试。这是最安全的部署方法，但它需要时间并且成本最高，因为你需要为一段时间同时搭建两个完整的环境，直到进行
    DNS 切换。切换后，你可以选择在第二个环境不再使用时将其关闭以节省成本，或者将其保持运行以节省部署时间，并将其用作故障转移环境。如果部署失败，客户将完全感知不到任何问题，因为使用蓝绿部署时，只有当第二个（或绿色）环境上线并健康时，才会切换
    DNS。
- en: '**Immutable deployments** refer to deploying code for a whole new set of resources
    using new configurations or new application code. This task is made much simpler
    in the cloud versus on-premises hardware as resources can be provisioned using
    simple API calls.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可变部署**指的是使用新的配置或新应用程序代码部署整个资源集。这项任务在云端比在本地硬件上简单得多，因为资源可以通过简单的 API 调用进行配置。'
- en: 'The following table shows both the pros and cons of immutable deployments:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了不可变部署的优缺点：
- en: '![Table 6.2 – Blue-green deployment pros and cons'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 6.2 – 蓝绿部署的优缺点'
- en: '](img/02.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/02.jpg)'
- en: Table 6.2 – Blue-green deployment pros and cons
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.2 – 蓝绿部署的优缺点
- en: See [*Chapter 13*](B17405_13_Final_JM_ePub.xhtml#_idTextAnchor338), *Blue Green
    Deployments*, for a much deeper look at blue-green deployments.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[*第 13 章*](B17405_13_Final_JM_ePub.xhtml#_idTextAnchor338)，*蓝绿部署*，深入了解蓝绿部署的更多内容。
- en: Canary deployments
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 金丝雀部署
- en: A `0`% on the new instance **Canonical Names** (**CNAMEs**) or by taking the
    new instances out of the load balancer. At that point, the new instances are taken
    down out of service, and any launch configurations that were previously updated
    can be updated to use a previous version of a working AMI.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的实例**规范名称**（**CNAMEs**）上为 `0`%，或者通过将新实例从负载均衡器中移除来实现。此时，新实例将被下线，任何先前更新过的启动配置都可以更新为使用一个之前工作的
    AMI 版本。
- en: 'In the following table, we compare the pros and cons of using a canary deployment
    method:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下表中，我们对比了使用金丝雀部署方法的优缺点：
- en: '![Table 6.3 – Canary deployment pros and cons'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 6.3 – 金丝雀部署的优缺点'
- en: '](img/03.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/03.jpg)'
- en: Table 6.3 – Canary deployment pros and cons
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.3 – 金丝雀部署的优缺点
- en: Rolling deployments
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滚动部署
- en: When using a **rolling deployment**, not all of the instances are updated at
    the same time. This strategy prevents any downtime since if a process fails, only
    a portion of the group is upgraded at any one particular time. As the initial
    instances are sent to the deployments, they must come back both healthy and online
    before further instances will be engaged in the new deployment.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**滚动部署**时，并非所有实例都会同时更新。这一策略可以防止停机，因为如果某个进程失败，只有部分实例会在某个特定时间进行升级。当初始实例部署时，它们必须在进一步部署其他实例之前确保健康并在线。
- en: It's important to note that since not all members of the group are deployed
    at the same time with either the application code or system upgrades, then there
    could be multiple versions running for a user to experience. Using sticky sessions
    can help, but not eliminate, trying to provide a seamless experience to a customer
    during a single session while deployment is happening.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，由于无论是应用程序代码还是系统升级，组内的所有成员并非同时部署，因此用户可能会体验到多个版本。在部署过程中，使用粘性会话有助于提供尽可能无缝的客户体验，但无法完全消除这种体验的差异。
- en: 'Although it''s not a long list of pros and cons, take a look at the following
    table to see the benefits and drawbacks of using a rolling deployment method:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管优缺点列表不长，但请看下表，了解使用滚动部署方法的利弊：
- en: '![Table 6.4 – Rolling deployment pros and cons'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 6.4 – 滚动部署的优缺点'
- en: '](img/04.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/04.jpg)'
- en: Table 6.4 – Rolling deployment pros and cons
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.4 – 滚动部署的优缺点
- en: Linear deployments
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性部署
- en: In a linear deployment, traffic is shifted equally in increments across resources
    over a set number of predefined increments. A linear deployment is a subset of
    the blue-green deployment type. Instead of deploying to the instances or resources
    that your application is currently running on, you are first standing up a new
    set of infrastructure and then over time shifting your traffic from the old code
    base to a new one, using a service such as **Route 53** and weighted routing.
    This way, you can keep a close eye on your new environment, and if any issues
    arise then you can quickly shift all traffic back to the original environment,
    with no downtime.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在线性部署中，流量会按照预设的多个增量平等地切换到不同的资源上。线性部署是蓝绿部署的一种子集。与直接部署到应用当前运行的实例或资源不同，你首先需要搭建一套新的基础设施，然后在一段时间内将流量从旧的代码库迁移到新的代码库，可以使用如
    **Route 53** 和加权路由这样的服务。这样，你可以密切监控新环境，如果出现问题，能够迅速将所有流量切换回原始环境，从而避免停机。
- en: Linear deployments can also be done with Lambda aliases and Fargate containers
    in order to shift a percentage of your traffic to a new version of your code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 线性部署还可以通过 Lambda 别名和 Fargate 容器来实现，将部分流量切换到新版本的代码。
- en: 'For example, if your deployment window is 1 hour and you want to spread 100%
    of your traffic in equal increments to new resources in that hour, then your linear
    strategy may go something like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的部署窗口是 1 小时，并且希望在该小时内将 100% 的流量平均分配到新资源上，那么你的线性部署策略可能如下：
- en: Minimum 0-16% of traffic shifted over to the new resources
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最少 0-16% 的流量切换到新资源
- en: Minimum 10-32% of traffic shifted over to the new resources
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最少 10-32% 的流量切换到新资源
- en: Minimum 20-48% of traffic shifted over to the new resources
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最少 20-48% 的流量切换到新资源
- en: Minimum 30-64% of traffic shifted over to the new resources
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最少 30-64% 的流量切换到新资源
- en: Minimum 40-80% of traffic shifted over to the new resources
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最少 40-80% 的流量切换到新资源
- en: Minimum 50-96% of traffic shifted over to the new resources
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最少 50-96% 的流量切换到新资源
- en: Minimum 60-100% of traffic shifted over to the new resources
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最少 60-100% 的流量切换到新资源
- en: 'There are both pros and cons to using a linear deployment method, so let''s
    compare them here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线性部署方法有优缺点，因此我们在此进行比较：
- en: '![Table 6.5 – Linear deployment pros and cons'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 6.5 – 线性部署的优缺点'
- en: '](img/05.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/05.jpg)'
- en: Table 6.5 – Linear deployment pros and cons
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.5 – 线性部署的优缺点
- en: We will be covering Lambda in depth in [*Chapter 12*](B17405_12_Final_JM_ePub.xhtml#_idTextAnchor307),
    *Lambda Deployments and Versioning.*
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第 12 章*](B17405_12_Final_JM_ePub.xhtml#_idTextAnchor307) 中深入探讨 Lambda，*Lambda
    部署与版本管理*。
- en: All-at-once deployments
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一次性全部部署
- en: In this type of deployment, all the traffic is shifted from the original environment
    to a new environment at the same time. This is the fastest of all deployment methods.
    This also means that any rollbacks that need to happen would also take the most
    amount of time, as the code would need to be redeployed to all instances. You
    *can have downtime* with this type of deployment if you have an issue as you wait
    for your rollback to come back online.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种部署方式中，所有流量会同时从原始环境切换到新环境。这是所有部署方法中最快的。这也意味着，如果需要回滚，所需的时间将是最长的，因为代码需要重新部署到所有实例上。如果遇到问题，*你可能会有停机时间*，因为你需要等待回滚过程完成后才能恢复在线状态。
- en: 'The advantages and disadvantages of using an *all-at-once deployment method*
    are outlined in the following table:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *一次性全部部署方法* 的优缺点在下表中列出：
- en: '![Table 6.6 – All-at-once deployment pros and cons'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 6.6 – 一次性全部部署的优缺点'
- en: '](img/06.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/06.jpg)'
- en: Table 6.6 – All-at-once deployment pros and cons
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.6 – 一次性全部部署的优缺点
- en: Note
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: An all-at-once deployment can also be called an in-place deployment. Be familiar
    with both terms as either can show up on test questions.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性全部部署也可以称为就地部署。请熟悉这两个术语，因为它们都可能出现在测试题中。
- en: Review questions
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习问题
- en: A medium-sized software company has hired you as a DevOps consultant to help
    set up its deployment pipeline. The staff want to be able to push their tested
    code into their production environment in a quick manner but do not want the possibility
    of dealing with downtime for their customers. Their DNS is hosted on a third-party
    service, and changes to the DNS would require a change ticket. Which deployment
    method would you recommend implementing?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一家中型软件公司聘请你作为 DevOps 顾问，帮助搭建其部署流水线。员工希望能够快速将经过测试的代码推送到生产环境，但又不想面临客户停机的风险。他们的
    DNS 托管在第三方服务商上，DNS 的变更需要提交变更工单。你会推荐哪种部署方式？
- en: a. Blue-green deployment
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 蓝绿部署
- en: b. In-place deployment
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 原地部署
- en: c. All-at-once deployment
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 一次性部署
- en: d. Rolling deployment
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 滚动部署
- en: A medical device company is looking to set up its development pipeline using
    Jenkins to deploy its code base in an automated fashion. Since this is only the
    development environment, they want to keep costs to a minimum and would be fine
    if the application team needed to redeploy in case of a failed deployment. Which
    strategy should they use?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一家医疗设备公司希望通过 Jenkins 设置其开发流水线，以自动化部署代码库。由于这只是开发环境，他们希望保持成本最低，并且如果部署失败，应用团队重新部署也是可以接受的。应该使用哪种策略？
- en: a. Blue-green deployment
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 蓝绿部署
- en: b. In-place deployment
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 原地部署
- en: c. All-at-once deployment
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 一次性部署
- en: d. Rolling deployment
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 滚动部署
- en: A mobile gaming company is trying to speed up its production time with all the
    new enhancements it has been developing for its most popular game. Staff have
    noticed on social media that around the dates of the last two releases, users
    complained of an increased number of glitches. Some of the glitches reported were
    known issues to teams that were working on the development of the game. The gaming
    company already has an automated deployment pipeline set up with AWS CodePipeline,
    and its code is stored in AWS CodeCommit. What is the most cost-effective way
    to reduce the number of glitches being deployed in each release?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一家移动游戏公司正在努力加快其最受欢迎游戏的生产时间，以便开发新的功能。员工注意到，在最近两次发布的日期，用户在社交媒体上抱怨出现了更多的故障。有些故障是已知的，由负责游戏开发的团队处理。该游戏公司已经设置了一个自动化部署流水线，使用
    AWS CodePipeline，并将代码存储在 AWS CodeCommit 中。最具成本效益的方式是什么，以减少每次发布时出现的故障数量？
- en: a. Spin up a new environment and run full UI tests before releasing the code
    to the production environment.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 启动一个新环境，并在将代码发布到生产环境之前运行完整的 UI 测试。
- en: b. Add a step in the current CodePipeline to spin up an EC2 instance that runs
    the Jenkins software and can use **Simple Systems Manager** (**SSM**) **Parameter
    Store** to download the current CodeCommit repository, after which it runs unit
    tests to pass or fail the build.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 在当前的 CodePipeline 中添加一个步骤，启动一个运行 Jenkins 软件的 EC2 实例，并使用 **Simple Systems
    Manager** (**SSM**) **Parameter Store** 下载当前的 CodeCommit 仓库，然后运行单元测试来判断构建是否通过。
- en: c. Add a CodeDeploy step to the current AWS pipeline that runs the current set
    of unit tests connected to an AWS SNS topic so that on failure, the current build
    is failed and the development team is notified.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 在当前的 AWS 流水线中添加一个 CodeDeploy 步骤，该步骤运行当前的一组单元测试，并将其连接到 AWS SNS 主题，以便在测试失败时，当前构建失败，并通知开发团队。
- en: d. Add a CodeBuild step to the current AWS pipeline that runs the current set
    of unit tests connected to an AWS SNS topic so that on failure, the current build
    is failed and the development team is notified.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 在当前的 AWS 流水线中添加一个 CodeBuild 步骤，该步骤运行当前的一组单元测试，并将其连接到 AWS SNS 主题，以便在测试失败时，当前构建失败，并通知开发团队。
- en: A research company is working on a confidential project and the management team
    wants to be aware of any progress made as soon as it happens. The developers are
    using AWS CodeCommit for their source code versioning, along with CodeBuild to
    run unit tests. Which measures can you put in place to allow the management team
    to get the updates they desire? (Choose all that apply)
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一家研究公司正在进行一个机密项目，管理团队希望能够在任何进展发生时立即了解情况。开发人员使用 AWS CodeCommit 进行源代码版本控制，并使用
    CodeBuild 运行单元测试。你可以采取哪些措施来让管理团队获得他们想要的更新？（选择所有适用项）
- en: a. Create an SNS topic for the management team and add all their emails.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 为管理团队创建一个 SNS 主题，并添加他们所有的电子邮件。
- en: b. Have AWS CodeCommit push notifications to an SNS topic any time that either
    a commit has been made or a feature branch has been merged with the master.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 让AWS CodeCommit在每次提交或功能分支与主分支合并时，将通知推送到SNS主题。
- en: c. Have CodeCommit create a daily report of commit activity and then push the
    report to S3 so that the management team can view it from a bucket to which they
    have access.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 让CodeCommit创建每日提交活动报告，并将报告推送到S3，以便管理团队可以从他们有权限访问的存储桶中查看该报告。
- en: d. Enable notifications on AWS CodeBuild to an SNS topic for when a job passes
    or fails.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 在AWS CodeBuild上启用通知，当作业通过或失败时，通知推送到SNS主题。
- en: A growing company currently has a Jenkins server that runs on EC2\. Developers
    are complaining that they are waiting too long for their builds to get started
    and complete. You have been asked to help the tools team in coming up with a solution
    that can scale with the growth and speed of the development team but can also
    be implemented in the quickest and most cost-effective manner possible. Which
    solution will least need to be managed by the tools team?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一家正在成长的公司目前有一个在EC2上运行的Jenkins服务器。开发人员抱怨他们等待构建启动和完成的时间太长。你被要求帮助工具团队提出一个能够随着开发团队的增长和速度扩展，但又能以最快和最具成本效益的方式实施的解决方案。哪种解决方案最不需要工具团队的管理？
- en: a. Create an AMI from the Jenkins server and use the AMI to create three additional
    worker nodes, using the current Jenkins system as the master.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 从Jenkins服务器创建一个AMI，并使用该AMI创建三个额外的工作节点，当前的Jenkins系统作为主节点。
- en: b. Rebuild the Jenkins server as a containerized system using `1`.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 使用`1`将Jenkins服务器重建为一个容器化系统。
- en: d. Create an AMI from the Jenkins server and use the AMI to create a launch
    configuration for an autoscaling group that will launch a new Jenkins instance
    when the queue gets over a level of `1`.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 从Jenkins服务器创建一个AMI，并使用该AMI创建一个启动配置，用于自动扩展组，当队列超过`1`时启动新的Jenkins实例。
- en: Review answers
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾答案
- en: d
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: b
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: d
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: a, b, d
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a, b, d
- en: c
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at the **SDLC**, **CI**, **continuous delivery**,
    and **CD**. We also started to look at the tools AWS offers that can help us with
    these different stages of the SDLC. Then, we took a look at the different types
    of teams and what their job responsibilities consist of. Finally, we reviewed
    the different types of deployment strategies available in AWS and how they can
    best be used.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了**SDLC**、**CI**、**持续交付**和**CD**。我们还开始了解AWS提供的工具，这些工具可以帮助我们在SDLC的不同阶段中发挥作用。接着，我们探讨了不同类型的团队及其职责。最后，我们回顾了AWS中可用的不同类型的部署策略，以及如何最佳地使用它们。
- en: In the next chapter, we will be taking a deeper dive into AWS's CloudFormation
    IaC service. We will see how to create reusable resources, along with the scripting
    methods available in CloudFormation templates.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨AWS的CloudFormation基础设施即代码（IaC）服务。我们将看到如何创建可重用的资源，以及在CloudFormation模板中可用的脚本方法。
