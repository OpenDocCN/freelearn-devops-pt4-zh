- en: 'Chapter 7: Using CloudFormation Templates to Deploy Workloads'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章：使用 CloudFormation 模板部署工作负载
- en: CloudFormation templates offer DevOps engineers an easy way to create, manage,
    and provision related resources automatically. They also allow you to stand up
    the same infrastructure over and over again quickly, be it for development, testing,
    production, or disaster recovery. They are not only an essential concept to know
    of, but also to understand for the DevOps professional exam.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation 模板为 DevOps 工程师提供了一种简单的方法，能够自动创建、管理和配置相关资源。它们还允许你快速地重复搭建相同的基础设施，无论是用于开发、测试、生产还是灾难恢复。它们不仅是一个重要的概念，也是
    DevOps 专业认证考试中需要理解的内容。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Essential CloudFormation topics
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CloudFormation 的基本主题
- en: Creating nested stacks with dependencies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建带有依赖关系的嵌套堆栈
- en: Adding a helper script to a CloudFormation template
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 CloudFormation 模板添加辅助脚本
- en: Understanding how to detect drift in previously created stacks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何检测以前创建的堆栈中的漂移
- en: Using the **Cloud Development Kit** (**CDK**) as an open source framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **Cloud Development Kit**（**CDK**）作为开源框架
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In dealing with the CloudFormation templates, this chapter will be a bit more
    hands-on than previous chapters, which have focused more on theory. You should
    be comfortable with the YAML syntax. And at this point, you should be comfortable
    with both the AWS Management Console as well as the CLI. Most of the templates
    discussed in this chapter are too large to type out entirely on the following
    pages, as some CloudFormation templates can become a few thousand lines in length.
    We have included the templates discussed here in the GitHub repository for this
    book in the `Chapter-7` section: [https://github.com/PacktPublishing/AWS-Certified-DevOps-Engineer-Professional-Certification-and-Beyond/tree/main/Chapter-7](https://github.com/PacktPublishing/AWS-Certified-DevOps-Engineer-Professional-Certification-and-Beyond/tree/main/Chapter-7).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 CloudFormation 模板时，本章比前几章更加注重实践，而前几章更多关注理论。你应该对 YAML 语法感到熟悉，并且此时你应该对 AWS
    管理控制台以及 CLI 都有一定的了解。本章讨论的大多数模板由于过于庞大，无法在接下来的页面上完全列出，因为一些 CloudFormation 模板可能会有几千行。我们已经将这里讨论的模板包含在本书的
    GitHub 仓库中的 `Chapter-7` 部分：[https://github.com/PacktPublishing/AWS-Certified-DevOps-Engineer-Professional-Certification-and-Beyond/tree/main/Chapter-7](https://github.com/PacktPublishing/AWS-Certified-DevOps-Engineer-Professional-Certification-and-Beyond/tree/main/Chapter-7)。
- en: Essential CloudFormation topics
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CloudFormation 的基本主题
- en: As we look to make repeatable pieces of infrastructure that can be built with
    automation, having the correct **Infrastructure as Code** (**IaC**) tool allows
    for the implementation of these repeatable processes. It is these repeatable processes
    where the CloudFormation service comes into play. CloudFormation is IaC that can
    be checked into source control systems such as **CodeCommit** or **GitHub**. The
    fact that it is a piece of code allows it to be versioned and collaborated on
    with multiple team members. It can also be added to an automated build pipeline
    as part of a CI/CD process.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们希望构建可重复的基础设施并通过自动化实现的过程中，拥有正确的 **基础设施即代码**（**IaC**）工具，可以实现这些可重复的流程。正是这些可重复的流程使
    CloudFormation 服务发挥作用。CloudFormation 是一种 IaC，可以检查到源代码管理系统，如 **CodeCommit** 或 **GitHub**。它作为一段代码的特点，使得它可以进行版本控制，并且可以与多个团队成员协作。它也可以作为
    CI/CD 过程的一部分，添加到自动化构建管道中。
- en: CloudFormation templates have the flexibility to be built in either the **JSON**
    or **YAML** programming languages. Using YAML allows you to put comments and use
    short codes in your template. However, you do need to stick to the strict YAML
    formatting guidelines.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation 模板可以使用 **JSON** 或 **YAML** 编程语言构建。使用 YAML 允许在模板中添加注释并使用简短的代码。然而，你确实需要遵循严格的
    YAML 格式化规则。
- en: Once you have created a template, especially one with the proper mappings and
    without hardcoded references, then it has the ability to be reused over and over
    again. This means that you can use it both in multiple regions and across numerous
    accounts.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个模板，特别是一个包含正确映射且没有硬编码引用的模板，它就具备了反复使用的能力。这意味着你可以在多个区域和多个账户中使用它。
- en: The anatomy of a CloudFormation template
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CloudFormation 模板的结构
- en: A CloudFormation template can contain many different sections. There is only
    one mandatory section when creating CloudFormation templates, and that is the
    *resources* section. Sections don't necessarily need to be added in a particular
    order; however, as you look at different examples, there is a logical order in
    the way that sections are structured since some sections reference other sections.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 CloudFormation 模板可以包含许多不同的部分。在创建 CloudFormation 模板时，只有一个强制性的部分，那就是*资源*部分。部分不一定需要按照特定顺序添加；然而，当你查看不同的示例时，会发现部分的结构有一个逻辑顺序，因为某些部分引用了其他部分。
- en: Format version
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式版本
- en: This is the version that the CloudFormation follows. It is an *optional* section.
    If added, it is usually the first section of the template.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 CloudFormation 遵循的版本。它是一个*可选*部分。如果添加，通常是模板的第一个部分。
- en: Description
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: The description is a small section of text that tells users about the template.
    It must always follow the format version of the template. Descriptions are beneficial
    as you start to gather a more extensive collection of templates and then have
    the ability to quickly know what the template's purpose is and what type of resources
    it will create. It is an *optional* section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 描述是一个小段文本，告诉用户有关模板的信息。它必须始终位于模板的格式版本之后。描述非常有用，尤其是当你开始收集更多的模板时，它能帮助你快速了解模板的目的以及它将创建哪些类型的资源。这是一个*可选*部分。
- en: Metadata
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元数据
- en: This section contains objects that provide additional information about the
    template. It is an *optional* section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该部分包含提供有关模板的附加信息的对象。这是一个*可选*部分。
- en: Parameters
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: This is a section of values that can be passed into the template at runtime.
    Default values can also be defined in lieu of needing user input. These values
    can then be used when creating your resources. You can also refer to parameters
    from the **Resources** and **Output** sections of the template. This is an *optional*
    section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个值的部分，可以在运行时传递到模板中。默认值也可以定义，以替代需要用户输入的值。这些值在创建资源时可以使用。你也可以引用模板中的**资源**和**输出**部分的参数。这是一个*可选*部分。
- en: Rules
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规则
- en: Rules are used to validate one or more parameters that are transferred to a
    template at runtime. Rules can help enforce things such as making sure that a
    large enough EC2 instance is being spun up in a production environment or that
    particular subnets are used. Rules very often validate the input of parameters
    . This is an *optional* section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 规则用于验证在运行时传递到模板的一个或多个参数。规则可以帮助强制执行一些要求，比如确保在生产环境中启动一个足够大的 EC2 实例，或者使用特定的子网。规则通常用于验证参数的输入。这是一个*可选*部分。
- en: Mappings
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射
- en: Using the intrinsic `Fn:FindInMap` function allows CloudFormation to find the
    corresponding key to the matching value. One of the most frequent scenarios for
    the use of the mappings section is when declaring the correct **Amazon Machine
    Image** (**AMI**) for particular regions being used, ensuring that the template
    is reusable in more than a single region. This is an *optional* section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内建的 `Fn:FindInMap` 函数，CloudFormation 可以找到与匹配值对应的键。映射部分最常见的使用场景之一是声明特定区域使用的正确**Amazon
    机器映像**（**AMI**），确保模板可以在多个区域中重用。这是一个*可选*部分。
- en: We will look a bit more into mappings when we look at the intrinsic `Fn:FindInMap`
    function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看内建的 `Fn:FindInMap` 函数时，我们将深入了解映射。
- en: Conditions
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件
- en: Although CloudFormation templates don't have a lot of logical programming available
    to them, conditions inside of the template allow for certain values to be assigned
    or certain resources in the template to be created based on values being present.
    A good example would be if the stack were being created in the test environment,
    then it would create a database. However, if it were being created in the production
    environment, it would not. This is an *optional* section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 CloudFormation 模板没有很多可用的逻辑编程，但模板中的条件允许基于某些值的存在，分配特定值或创建特定资源。一个好的例子是，如果堆栈在测试环境中创建，那么它会创建一个数据库。然而，如果在生产环境中创建，它就不会创建。这是一个*可选*部分。
- en: Resources
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源
- en: This section actually declares the resources and their properties that will
    be created by the CloudFormation template. Resources can be a whole variety of
    AWS services from EC2 instances to IAM users to even **chatbots** and **Step Functions**.
    There are few services that AWS offers that cannot be created via CloudFormation
    templates. This is a *required* section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分实际上声明了将由CloudFormation模板创建的资源及其属性。资源可以是各种各样的AWS服务，从EC2实例到IAM用户，甚至是**聊天机器人**和**Step
    Functions**。AWS提供的几乎所有服务都可以通过CloudFormation模板创建。这个部分是*必需*的。
- en: Outputs
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出
- en: Outputs allow for the declaration of a key-value pair along with a corresponding
    description that can be consumed by an end user once the stack has completed creation
    or can be consumed by another stack. In the case of an end user, you might want
    to output the URL or IP of an EC2 instance that has just been spun up so that
    you don't have to go hunting around the console for it. Alternatively, in the
    case of creating outputs for other stacks to consume, **Amazon Resource Names**
    (**ARNs**) are one of the main items that can be used in other stacks as reference
    points. This is an *optional* section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 输出允许声明一个键值对及其对应的描述，该描述可以在堆栈创建完成后供最终用户使用，或者供另一个堆栈使用。在最终用户的情况下，你可能想要输出刚刚启动的EC2实例的URL或IP，以便你不需要在控制台中四处寻找。或者，在为其他堆栈创建输出供其使用时，**Amazon资源名称**（**ARNs**）是可以在其他堆栈中作为参考点使用的主要项之一。这是一个*可选*部分。
- en: Launching CloudFormation templates
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动CloudFormation模板
- en: 'Once you have your template ready to go, then you can launch it from either
    the AWS Management Console or the `sqs-queues.yml`. If you would like to follow
    along with the following exercise, then go to the repository and download this
    template. Alternatively, you can use one of your own CloudFormation templates,
    bearing in mind that the parameters and resources will not be the same as we go
    along, but the process will still follow the same steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你准备好了模板，就可以通过AWS管理控制台或`SQSqueues.yml`来启动它。如果你想跟随以下练习，请去仓库并下载这个模板。或者，你可以使用你自己的CloudFormation模板，但要记住，参数和资源会有所不同，尽管过程仍然遵循相同的步骤：
- en: 'Take the downloaded template and upload it to your S3 bucket, which we created
    in [*Chapter 4*](B17405_04_Final_JM_ePub.xhtml#_idTextAnchor110), *Amazon S3 Blob
    Storage*. (In our case, our bucket''s name is `devopspro-beyond`.):'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将下载的模板上传到你的S3存储桶，我们在[*第4章*](B17405_04_Final_JM_ePub.xhtml#_idTextAnchor110)中创建了该存储桶，*Amazon
    S3 Blob存储*。（在我们的例子中，存储桶的名称是`devopspro-beyond`）：
- en: '[PRE0]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that the template has been uploaded, log in to the AWS Management Console
    and navigate to the CloudFormation service page at [https://us-east-2.console.aws.amazon.com/cloudformation/](https://us-east-2.console.aws.amazon.com/cloudformation/).
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在模板已上传，登录到AWS管理控制台并导航到CloudFormation服务页面：[https://us-east-2.console.aws.amazon.com/cloudformation/](https://us-east-2.console.aws.amazon.com/cloudformation/)。
- en: Click the orange button on the right-hand side labeled **Create stack**.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右侧标有**创建堆栈**的橙色按钮。
- en: Under **Pre-requisite – Prepare template**, make sure that the radio button
    is already selected for the **Template is ready** option:![Figure 7.1 – CloudFormation
    prerequisites
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**前提条件 – 准备模板**下，确保已选择**模板已准备好**选项的单选按钮：![图 7.1 – CloudFormation前提条件
- en: '](img/Figure_7.1_B17405.jpg)'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.1_B17405.jpg)'
- en: Figure 7.1 – CloudFormation prerequisites
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.1 – CloudFormation前提条件
- en: Under **Specify template**, make sure that that the **Amazon S3 URL** option
    is already selected and then in the URL field, type the value of the location
    of your template, which in our case is [https://devopspro-beyond.s3.us-east-2.amazonaws.com/sqs-queues.yml](https://devopspro-beyond.s3.us-east-2.amazonaws.com/sqs-queues.yml):![Figure
    7.2 – CloudFormation Specify template screen
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**指定模板**下，确保已选择**Amazon S3 URL**选项，然后在URL字段中输入模板所在位置的值，在我们的例子中是[https://devopspro-beyond.s3.us-east-2.amazonaws.com/sqs-queues.yml](https://devopspro-beyond.s3.us-east-2.amazonaws.com/sqs-queues.yml)：![图
    7.2 – CloudFormation指定模板屏幕
- en: '](img/Figure_7.2_B17405.jpg)'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.2_B17405.jpg)'
- en: Figure 7.2 – CloudFormation Specify template screen
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.2 – CloudFormation指定模板屏幕
- en: Click the orange **Next** button at the bottom of the page.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面底部的橙色**下一步**按钮。
- en: We now need to fill out a few details before we can proceed. We'll start with
    the `SQSqueue` (no spaces are allowed).
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要填写一些细节，才能继续操作。我们从`SQSqueue`开始（不允许有空格）。
- en: Next, fill out the rest of the **Parameters** by adding your address for the
    **AlarmEmail** field and the name of the queue for the **QueueName** field. You
    can leave the other two values at their defaults. After you have done this, press
    the orange **Next** button at the bottom of the page:![ Figure 7.3 – Entering
    the parameters for the template
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，填写其余的**参数**，为**AlarmEmail**字段添加你的地址，为**QueueName**字段添加队列的名称。你可以将另外两个值保持为默认值。完成后，点击页面底部的橙色**下一步**按钮：![图
    7.3 – 输入模板的参数
- en: '](img/Figure_7.3_B17405.jpg)'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.3_B17405.jpg)'
- en: Figure 7.3 – Entering the parameters for the template
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.3 – 输入模板的参数
- en: On the next page, labeled **Configure stack options**, scroll down to the bottom
    of the page and click on the orange **Next** button.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一页，标记为**配置堆栈选项**，向下滚动到页面底部并点击橙色的**下一步**按钮。
- en: We are now at the point where we can review what we have entered, and if everything
    looks correct, scroll down to the bottom of the page and click the orange button,
    which is labeled **Create Stack**.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以查看我们输入的内容，如果一切看起来正确，向下滚动到页面底部并点击橙色按钮，标签为**创建堆栈**。
- en: Once we start the creation process, we will be taken to the **Stacks** screen,
    where we can see the **CREATE_IN_PROGRESS** notification while our stack is being
    created.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始创建过程，我们将被带到**Stacks**屏幕，在那里我们可以看到**CREATE_IN_PROGRESS**通知，表示我们的堆栈正在创建中。
- en: There is a menu at the top of this section that allows you to see the specific
    resources that each stack creates, specific stack info, any outputs that you have
    declared for the stack to show after its creation, the parameters you entered
    when creating the stack, the actual template used to create the stack, and change
    sets used on the stack.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分的顶部有一个菜单，允许你查看每个堆栈创建的具体资源、堆栈的具体信息、堆栈创建后你声明的任何输出、创建堆栈时输入的参数、用于创建堆栈的实际模板以及在堆栈上使用的变更集。
- en: When you launch a CloudFormation template, that template is saved in an S3 bucket,
    which AWS creates in the region in which you are launching the template if you
    have not previously saved the template into an S3 bucket. Each time that you either
    update the template or launch a new version, a new copy of the template is added
    to this bucket.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动一个CloudFormation模板时，该模板会保存在一个S3桶中。如果你之前没有将模板保存到S3桶中，AWS会在你启动模板的区域创建一个S3桶。每次你更新模板或启动新版本时，模板的一个新副本会被添加到这个桶中。
- en: Using the CLI to launch templates
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用CLI启动模板
- en: 'After going through all the steps from the Management Console to launch a template,
    we can see that if we are going to automate our deployments as part of a CI/CD
    pipeline, then doing this each and every time would not be practical. The AWS
    CLI does have a `deploy` command that allows us to launch a stack with one line.
    Before we run the command, be sure that you have downloaded the YAML template
    from the GitHub repository in the `Chapter-7` folder. Once downloaded, open up
    your terminal window and either copy or move that template to your working directory
    or change your working directory to where you have downloaded the template:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过管理控制台启动模板的所有步骤之后，我们可以看到，如果我们打算将部署自动化为CI/CD流水线的一部分，那么每次都这样做显然是不实际的。AWS CLI确实有一个`deploy`命令，它允许我们通过一条命令启动一个堆栈。在运行该命令之前，确保你已经从GitHub仓库的`Chapter-7`文件夹中下载了YAML模板。下载后，打开你的终端窗口，并将模板复制或移动到你的工作目录中，或者将工作目录更改为你下载模板的位置：
- en: 'An example of the CLI command to launch a template is shown as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 启动模板的CLI命令示例如下所示：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With this single command, we have replicated all of the steps that we went through
    before. As noted previously, our template should be in an S3 bucket with a random
    name since we uploaded it as part of the creation process, and the CloudFormation
    service stored it on our behalf.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一条命令，我们已经复制了之前经历的所有步骤。正如前面所提到的，我们的模板应该存储在一个随机命名的S3桶中，因为我们在创建过程中上传了它，而CloudFormation服务为我们存储了它。
- en: Using change sets
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用变更集
- en: If your CloudFormation stack needs to be updated, sometimes you may like to
    know and understand how the existing resources currently running will be affected.
    Change sets allow you to preview how changes will impact the currently running
    resources before any changes take place, and then allow you to cancel the update
    if the changes would be detrimental to current resources, or proceed if the change
    would execute as expected.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 CloudFormation 堆栈需要更新，有时你可能希望了解并理解当前正在运行的现有资源会如何受到影响。变更集允许你预览更改如何影响当前运行的资源，在任何更改发生之前，然后如果更改对当前资源有害，你可以取消更新，或者如果更改按预期执行，则可以继续。
- en: Note
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Change sets don't tell you if your CloudFormation will run successfully upon
    execution. They can't foresee account limit updates that you might run into, or
    determine whether you possess the correct IAM permissions to update a resource.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 变更集不能告诉你 CloudFormation 执行时是否会成功运行。它们无法预见你可能遇到的账户限制更新，也无法判断你是否具备更新资源所需的正确 IAM
    权限。
- en: Steps to execute a change set
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行变更集的步骤
- en: 'Let''s look at both the mandatory and optional steps required for executing
    a change set on a stack:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看执行变更集所需的强制性步骤和可选步骤：
- en: '![Figure 7.4 – CloudFormation change sets'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.4 – CloudFormation 变更集'
- en: '](img/Figure_7.4_B17405.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.4_B17405.jpg)'
- en: Figure 7.4 – CloudFormation change sets
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – CloudFormation 变更集
- en: With the basis for how to execute a change set under our belts, we will now
    update our original CloudFormation stack – `SQSqueue` – with a change set.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了如何执行变更集的基础之后，我们将使用变更集来更新原始的 CloudFormation 堆栈——`SQSqueue`。
- en: Using a change set to update our stack
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用变更集更新我们的堆栈
- en: 'If you haven''t already done so, then download the template named `sqs-queues_change_set.yml`
    from the GitHub repository in the `Chapter-7` folder. This is the file that we
    will use to create our change set. Also, make sure that you have your browser
    open to the AWS Management Console and have navigated to the CloudFormation service,
    then proceed with the following steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，那么从 GitHub 仓库的 `Chapter-7` 文件夹中下载名为 `sqs-queues_change_set.yml` 的模板。这就是我们将用来创建变更集的文件。还要确保你已经打开浏览器，进入
    AWS 管理控制台，并导航到 CloudFormation 服务，然后按照以下步骤操作：
- en: From the CloudFormation Stacks page, you should see your `SQSqueue` stack in
    a `CREATE_COMPLETE` state. Click on the stack name to be taken to the page with
    details about the stack. This is where we can perform the change set:![Figure
    7.5 – Our previously created CloudFormation stack
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 CloudFormation 堆栈页面，你应该会看到你的 `SQSqueue` 堆栈处于 `CREATE_COMPLETE` 状态。点击堆栈名称，进入堆栈的详细信息页面。在这里我们可以执行变更集：![图
    7.5 – 我们之前创建的 CloudFormation 堆栈
- en: '](img/Figure_7.5_B17405.jpg)'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.5_B17405.jpg)'
- en: Figure 7.5 – Our previously created CloudFormation stack
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.5 – 我们之前创建的 CloudFormation 堆栈
- en: On the horizontal menu under the stack name, you will see a number of choices,
    including **Change sets** on the very right-hand side. Click on the **Change sets**
    option:![Figure 7.6 – CloudFormation stack menu with the Change sets option highlighted
    on the right
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在堆栈名称下方的横向菜单中，你会看到多个选项，包括最右侧的**变更集**。点击**变更集**选项：![图 7.6 – CloudFormation 堆栈菜单，右侧高亮显示变更集选项
- en: '](img/Figure_7.6_B17405.jpg)'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.6_B17405.jpg)'
- en: Figure 7.6 – CloudFormation stack menu with the Change sets option highlighted
    on the right
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.6 – CloudFormation 堆栈菜单，右侧高亮显示变更集选项
- en: Once in the **Change Sets** section, click on the button labeled **Create change
    set**.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**变更集**部分后，点击标记为**创建变更集**的按钮。
- en: At this point, a new screen will appear with the heading **Prerequisite – Prepare
    template**. You will be presented with three choices. Select the choice in the
    middle that reads **Replace current template**:![Figure 7.7 – CloudFormation change
    sets Prepare template screen
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，将出现一个新屏幕，标题为**先决条件 – 准备模板**。你将看到三个选择。选择中间的选项，标题为**替换当前模板**：![图 7.7 – CloudFormation
    变更集准备模板屏幕
- en: '](img/Figure_7.7_B17405.jpg)'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.7_B17405.jpg)'
- en: Figure 7.7 – CloudFormation change sets Prepare template screen
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.7 – CloudFormation 变更集准备模板屏幕
- en: This will make another set of selections appear underneath the initial set of
    radio buttons. This time instead of uploading our template to S3 prior to creating
    the change set, we will upload our template (`sqs-queues_change_set.yml`) here
    using the `YAML` file that we downloaded previously from the GitHub repository.
    After you have uploaded the file, click the orange button labeled **Next**.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将使另一组选择项出现在初始单选按钮下方。这一次，我们不是在创建变更集之前将模板上传到S3，而是使用我们之前从GitHub仓库下载的`YAML`文件（`sqs-queues_change_set.yml`）在此处上传模板。上传文件后，点击橙色的**下一步**按钮。
- en: The next screen, **Parameters**, should confirm the parameters we entered previously
    when we first created our template. We are not changing any of the parameters
    at this time so just click the orange **Next** button at the bottom of the page.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一屏幕，**参数**，应确认我们在首次创建模板时输入的参数。此时我们不会更改任何参数，因此只需点击页面底部的橙色**下一步**按钮。
- en: On the next screen, **Configure stack options**, we do not make any changes.
    You can scroll down to the bottom of the page and click the orange **Next** button.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏幕，**配置堆栈选项**，我们不进行任何更改。您可以向下滚动到页面底部，然后点击橙色的**下一步**按钮。
- en: Now, finally, on the **Review** page, we will have to check one more option
    at the bottom of the page acknowledging that our new stack is going to create
    an IAM role needed for the Lambda function to be added. Under the **Capabilities**
    heading, click the check box acknowledging that this new template is creating
    IAM permissions. Once you have done this, you can click the orange button labeled
    **Create change set**.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，最终在**审查**页面，我们需要在页面底部勾选一个选项，确认我们的新堆栈将创建一个Lambda函数所需的IAM角色。在**权限**标题下，勾选确认此新模板正在创建IAM权限的复选框。完成后，您可以点击标有**创建变更集**的橙色按钮。
- en: A window should now pop up, giving you the option to name this change set before
    its actual creation. You may name the change set if you like, or just click the
    orange **Create change set** button at the bottom right.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时应该会弹出一个窗口，允许您在实际创建变更集之前为其命名。如果愿意，您可以为变更集命名，或者只需点击右下角的橙色**创建变更集**按钮。
- en: Once the change set has been created, then you should see a status of `CREATE_PENDING`
    as CloudFormation does the calculations of what is actually about to be changed
    in the current stack based on what has been requested by the new template that
    you have created with the change set. Once completed, then the orange **Execute**
    button will appear on the top right-hand menu. Scroll down and look under the
    **Changes** header to see the two changes that will be executed on your stack.
    Once you are satisfied with the changes, scroll back up and click the orange **Execute**
    button:![Figure 7.8 – Changes to be executed on the stack by the change set
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦变更集创建完成，您应该会看到`CREATE_PENDING`状态，因为CloudFormation正在根据您使用变更集创建的新模板计算当前堆栈实际要更改的内容。完成后，橙色的**执行**按钮将出现在右上菜单中。向下滚动并查看**变更**标题下，查看将在堆栈上执行的两个更改。确认更改无误后，向上滚动并点击橙色的**执行**按钮：![图7.8
    – 变更集将在堆栈上执行的更改
- en: '](img/Figure_7.8_B17405.jpg)'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.8_B17405.jpg)'
- en: Figure 7.8 – Changes to be executed on the stack by the change set
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.8 – 变更集将在堆栈上执行的更改
- en: You will now be taken back to the `SQSqueue` stack and see an `UPDATE_IN_PROGRESS`
    status until the update is complete.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您将被带回到`SQSqueue`堆栈，并看到`UPDATE_IN_PROGRESS`状态，直到更新完成。
- en: Just because you have created a change set doesn't mean that you have to execute
    it. You could have multiple change sets sitting in your **Change set** tab waiting
    for execution as you and your team think about which changes should be implemented.
    It's important to note that unless you delete a change set, then anyone with the
    permissions to your stack could execute it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅因为您创建了一个变更集并不意味着您必须执行它。您可以在**变更集**标签中有多个变更集，等待执行，直到您和您的团队决定应该实施哪些更改。值得注意的是，除非您删除变更集，否则任何拥有堆栈权限的人都可以执行它。
- en: At this point, we have updated our original stack to add a Lambda function along
    with the IAM role, which the Lambda function needs in order to operate. Everything
    went smoothly during our operation, but what happens if we have conflicts, missing
    information, or errors in our template? We will find out next as we talk about
    the rollback features of CloudFormation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经更新了原始堆栈，添加了 Lambda 函数以及该 Lambda 函数操作所需的 IAM 角色。我们的操作非常顺利，但如果模板中有冲突、缺失信息或错误会发生什么呢？接下来我们将讨论
    CloudFormation 的回滚功能。
- en: Rollback features of CloudFormation
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CloudFormation 的回滚功能
- en: If the operations fail when creating or updating a stack in CloudFormation,
    then the stack will roll back to its previous state. There is also a feature available
    known as a **rollback trigger**. These triggers allow you set user-defined alarms
    that CloudWatch can monitor and, in the case of failure, roll back the stack.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在创建或更新 CloudFormation 堆栈时操作失败，堆栈将回滚到之前的状态。此外，还有一个叫做 **回滚触发器** 的功能。通过这些触发器，你可以设置用户定义的警报，CloudWatch
    可以监控这些警报，并在发生故障时回滚堆栈。
- en: The monitoring period can be set to last from 0 to 180 minutes while your stack
    is being created or your change set is updating it. We will look at an example
    of creating a change set update next that includes a rollback trigger.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建堆栈或更新更改集时，监控周期可以设置为 0 到 180 分钟。接下来我们将看一个包含回滚触发器的更改集更新示例。
- en: 'We could create a CloudWatch alarm to watch over our stack by using the CLI
    command like the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下类似的 CLI 命令创建一个 CloudWatch 警报来监视我们的堆栈：
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once we''ve created that alarm, we can use the ARN returned back to us for
    use in our rollback trigger. If you need to find the ARN, use the CloudWatch `describe-alarms`
    command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了警报，就可以使用返回的 ARN 在回滚触发器中使用。如果需要查找 ARN，可以使用 CloudWatch 的 `describe-alarms`
    命令：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We need to create a piece of JSON code and push it to a variable in order to
    pass that ARN to our command-line option:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一段 JSON 代码并将其推送到变量中，以便将 ARN 传递给命令行选项：
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will now give us the information that we need in order to create the rollback
    trigger:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供创建回滚触发器所需的信息：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Currently, only a CloudWatch alarm is supported as a monitor for a rollback
    trigger.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，回滚触发器仅支持使用 CloudWatch 警报作为监控工具。
- en: We will cover CloudWatch alarms in greater detail in [*Chapter 15*](B17405_15_Final_JM_ePub.xhtml#_idTextAnchor381),
    *CloudWatch Metrics and Amazon EventBridge.*
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第 15 章*](B17405_15_Final_JM_ePub.xhtml#_idTextAnchor381) 中更详细地讨论 CloudWatch
    警报，*CloudWatch 指标和 Amazon EventBridge*。
- en: Intrinsic functions in CloudFormation
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CloudFormation 中的内置函数
- en: CloudFormation has several functions built into it that work with both JSON
    and YAML templates to expand the power and capabilities of the templates. We have
    the ability to stack or combine intrinsic functions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation 内置了多个函数，这些函数可以与 JSON 和 YAML 模板一起使用，扩展模板的功能和能力。我们可以堆叠或组合内置函数。
- en: Note
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: Intrinsic functions can only be used on certain sections of a CloudFormation
    template. As of the publishing of this book, intrinsic functions can be used in
    resource properties, outputs, metadata attributes, and update policy attributes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 内置函数只能在 CloudFormation 模板的某些部分使用。根据本书出版时的情况，内置函数可以在资源属性、输出、元数据属性和更新策略属性中使用。
- en: 'We will now look at some of the more common intrinsic functions, along with
    some examples of their usage. There are additional functions available for use
    in the YAML templates. In the function headings, the short form, will be shown
    if available after the original code, separated by a pipe:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将看一些常见的内置函数，并提供一些使用示例。YAML 模板中还可以使用其他函数。在函数标题中，如果有短格式，原始代码后面会用管道符号分隔并显示短格式：
- en: '`Fn::FindInMap | !FindInMap`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fn::FindInMap | !FindInMap`'
- en: 'The `FindInMap` function returns a value based on the key in the `Mappings`
    section:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`FindInMap` 函数根据 `Mappings` 部分中的键返回一个值：'
- en: '[PRE6]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`Fn::GetAZs | !GetAZs`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fn::GetAZs | !GetAZs`'
- en: 'The `GetAZs` function will return the list of Availability Zones in a given
    region. This can be especially helpful for creating dynamic templates that move
    from region to region:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GetAZs` 函数将返回给定区域中的可用区列表。这对于创建跨区域动态模板特别有帮助：'
- en: '[PRE7]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Fn::GetAtt`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fn::GetAtt`'
- en: 'The `GetAtt` function is helpful for getting an attribute, especially an ARN,
    from a resource that was created previously in the template. This function in
    particular is one that makes CloudFormation templates especially dynamic:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GetAtt` 函数对于获取资源的属性（特别是 ARN）非常有用，尤其是在模板中之前已创建的资源。这个函数特别适用于使 CloudFormation
    模板具有更高的动态性：'
- en: '[PRE8]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Condition functions
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件函数
- en: The optional conditions section contains statements that define the circumstances
    where resources may or may not be created or configured based on dynamic options.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 可选条件部分包含定义在基于动态选项的情况下，资源是否可以或不可以创建或配置的语句。
- en: 'Scenarios for the use of conditions in CloudFormation templates include the
    following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CloudFormation 模板中使用条件的场景包括以下内容：
- en: You are trying to use the same template for both the DEV and PROD environments
    without having to change anything except for possibly parameter values.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您正在尝试使用相同的模板为 DEV 和 PROD 环境提供支持，而不需要更改任何内容，除了可能的参数值。
- en: You want to specify the number of EBS volumes to mount via a drop-down list.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您希望通过下拉列表指定要挂载的 EBS 卷数量。
- en: You want to create a CloudWatch dashboard or not based on user selection.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您希望根据用户选择来创建或不创建 CloudWatch 仪表板。
- en: Note
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: During a stack update, you cannot update conditions by themselves. You can update
    conditions only when you include changes that add, modify, or delete resources.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在堆栈更新过程中，您不能单独更新条件。您只能在包含添加、修改或删除资源的更改时更新条件。
- en: 'You can use condition functions to help evaluate items such as AWS-provided
    variables or input gathered from parameters and then create additional resources
    if certain conditions apply:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用条件函数帮助评估诸如 AWS 提供的变量或从参数收集的输入项，并在某些条件适用时创建额外的资源：
- en: '`Fn::And`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fn::And`'
- en: This function returns `true` if all the specified conditions passed to it return
    `true`.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果所有传入的指定条件返回`true`，则此函数返回`true`。
- en: '`Fn::Equals`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fn::Equals`'
- en: This function compares two different values and then returns `true` if the values
    are equal.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数比较两个不同的值，并在值相等时返回`true`。
- en: 'In the following example, the template will or won''t create `Public Subnets`
    based on a value passed in the `Parameters` section of the template:'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下示例中，模板将根据在模板的 `Parameters` 部分传递的值，决定是否创建 `Public Subnets`：
- en: '[PRE9]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`Fn::If`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fn::If`'
- en: This returns one value if the specified condition evaluates to `true`, and another
    value if the specified condition evaluates to `false`.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果指定的条件评估结果为`true`，则此函数返回一个值；如果指定的条件评估结果为`false`，则返回另一个值。
- en: '`Fn::Not`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fn::Not`'
- en: This returns `true` for a condition that evaluates to `false`, and returns `false`
    for a condition that evaluates to `true`.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果条件评估结果为`false`，则返回`true`，如果评估结果为`true`，则返回`false`。
- en: '`Fn::Or`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fn::Or`'
- en: This returns `true` if any of the specified conditions evaluate to `true`.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果任何指定条件的评估结果为`true`，则返回`true`。
- en: CloudFormation best practices
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CloudFormation 最佳实践
- en: As you start to work to build out your IaC in CloudFormation templates, there
    are some best practices and recommendations to follow that have been set forth
    by AWS. These tips can help you more effectively organize and plan your resource
    creation, along with minimizing the time that you spend troubleshooting initial
    runs of your templates.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始在 CloudFormation 模板中构建基础设施即代码（IaC）时，AWS 提供了一些最佳实践和建议。这些建议有助于您更有效地组织和规划资源创建，同时最大限度减少在模板初次运行时的故障排除时间。
- en: Don't embed sensitive information in your templates
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要在模板中嵌入敏感信息。
- en: Rather than placing secrets or sensitive information that could be compromised
    directly in a CloudFormation template, *store secrets inside of AWS Secrets Manager*.
    Even better, the best practice is to use a *dynamic reference*. A dynamic reference
    allows you to cite an external value in `Systems Manager` (`SSM`) Parameter Store
    or AWS Secrets Manager. For SSM Parameter Store, it supports both `ssm`, which
    are plaintext values, and `ssm-secure`, which are encrypted values.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与其直接在 CloudFormation 模板中放置可能会泄露的机密信息，不如*将机密存储在 AWS Secrets Manager 中*。更好的做法是使用*动态引用*。动态引用允许您引用`Systems
    Manager`（SSM）参数存储或 AWS Secrets Manager 中的外部值。对于 SSM 参数存储，它支持`ssm`（明文值）和`ssm-secure`（加密值）。
- en: 'So instead of using template-based parameters for the database username and
    password that you create, your RDS resource block can look like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以像这样在 RDS 资源块中使用数据库用户名和密码，而不是使用基于模板的参数：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Use AWS-specific parameter types
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 AWS 特定的参数类型
- en: To make AWS specialized parameter input easier on both yourself and your users,
    especially when asking for items that could need looking up in your account. Rather
    then use a string for the type of parameter you can define the AWS specific type
    of parameter. These could be items such as security group IDs, VPC IDs, or Route53
    HostedZone IDs. A good example of this would be `AWS::EC2::KeyPair::KeyName`,
    which would then provide a dropdown of the EC2 keypairs available.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Make use of parameter constraints
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are not using an AWS-specific parameter and using a string parameter,
    the use of parameter constraints can help catch user mistakes on parameter entry
    before the template even starts to create and then has to take the time to roll
    back. Parameter constraints are constructed like regular expressions and can also
    have a description for the user so that they have a better understanding of what
    needs to be entered.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Understand how to use AWS::CloudFormation::Init to deploy software to EC2 instances
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you launch an EC2 instance from a CloudFormation template, software running
    on that instance can be installed and configured using the `cfn-init` helper script
    and the `AWS::CloudFormation::Init` resource. These helper scripts can be used
    to install not only system scripts but also necessary system packages via the
    OS package manager, such as `apt` or `yum`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Modularize your templates
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Making your templates modular allows you to accomplish a few things at the same
    time. The first and most important is to make your templates reusable. This becomes
    especially relevant as we start talking about nested templates. The second is
    to allow multiple team members to concentrate on the smaller templates where they
    have more subject matter expertise.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Lint templates before attempting to launch
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just like any other form of code, CloudFormation templates should go through
    a verification process to make sure that there are no formatting issues with the
    template before you attempt to launch it. There is a built-in template checker
    right from the AWS CLI that you can use to find any issues that might be present
    in your templates.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: The AWS CloudFormation Linter (`cfn-lint`) is an open source tool that intergrates
    into most IDEs and is a tool that can be run either via the command line, inside
    of the IDE itself, or integrated into a CI/CD pipeline. The tool will validate
    both JSON and YAML templates and includes additional checks for things in line
    with CloudFormation best practices.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Although these best practices don't usually appear in the context of the test
    questions, these are more relevant for day-to-day usage of CloudFormation and
    making you the best DevOps professional that you can be.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Creating nested stacks with dependencies
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you start to organize your templates logically, you will find that breaking
    your larger templates up into smaller, more manageable pieces is a smart strategy.
    It will not only make them easier to work with but also allows for greater reusability
    with each template having a specific purpose, such as creating a VPC with subnets
    or a set of reusable IAM roles. Adding outputs to these smaller templates can
    allow other templates to use the resources other templates have created previously,
    acting like building blocks stacked on top of each other to create a complete
    solution. This also allows multiple team members to work on separate sections
    of the cloud infrastructure as each person can concentrate on their area of expertise.
    If you have a team member whose strength is networking then they can concentrate
    on the VPC and networking pieces of the stacks. If you have another team member
    who has a background in databases, then they can concentrate on the nested piece
    that creates and configures the database(s), including any specialized parameter
    groups for that particular database engine.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Nested stacks all start with a root or parent stack, depicted in *Figure 7.9*
    with the letter **A**. The root stack then has other child stacks as its resources
    instead of other AWS services. We can also see in the diagram that the stack labeled
    **B** is providing outputs that are being consumed by level **C**. The stack on
    level **C** creates another child stack, as well as resources whose outputs are
    consumed by the stack on level **D**:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – CloudFormation nested stacks'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.9_B17405.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.9 – CloudFormation nested stacks
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit that nested stacks can provide is the ability to go beyond the
    200 resource limit for CloudFormation templates.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Nested stacks can be more complex to troubleshoot as a whole. If you run into
    errors while creating and deploying nested CloudFormation stacks, then try deploying
    just the single template that is causing you issues and then update for your changes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Packaging up your nested stack for deployment
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have all your templates ready to upload to S3, then you can package
    them all together using the AWS CLI. Since nested stacks need their child templates
    to be in S3 for deployment, this saves you time in having to upload each template
    individually. It will then generate a new template for us and give us the command
    for deploying the full nested stack using that newly generated template. The generic
    code for creating a CloudFormation package looks like the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will look at this command in greater depth when we go through our exercise
    of creating a nested template with the AWS CLI.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s recap what the `package` command does:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: It creates a ZIP file with all of your child template files and extra code such
    as `lambda` code.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uploads those items into the S3 bucket designated by you.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It generates a new template with your local templates and replaces it with the
    S3 URIs.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a nested stack using the AWS CLI
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following exercise, we will create a nested stack using a set of templates
    that you can find on the GitHub repository under the `Chapter-7/nested` directory.
    Download all of these YAML templates before you begin the following exercise.
    Also, make a note of the S3 bucket that you want to deploy the package to. As
    we noted earlier when we showed the example command, an S3 bucket is necessary
    as part of the CLI command to upload the files:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Items created in the nested stack exercise'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.10_B17405.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.10 – Items created in the nested stack exercise
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram in *Figure 7.10* shows what we are about to package and deploy
    using our nested template:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Open up your terminal so that you have access to your AWS CLI.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now navigate to the folder where you have downloaded all of the files to create
    the nested stack. If you have downloaded the book's entire GitHub repository,
    then the path will be `Chapter-7/nested`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Because the packaging for nested stacks only works one level deep, we will
    have to manually upload our `nested_dynamo.yml` template (make sure that you substitute
    your own bucket name when performing the following command):'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Open the `nested_root.yml` file and edit the default value for the S3 URL for
    the HTTPS value of the bucket where you placed the `nested_dynamo.yml` file.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once in the nested directory, perform the following command:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once completed, the `package` command should tell you that it was successful
    and give you a cut and paste command to run, where you need to substitute the
    stack name at the end of the command:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Successfully packaged artifacts and wrote output template to file `packaged_template.yml`.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Execute the following command to deploy the packaged template:'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run the command to create your nested stack, but be sure to change the stack
    name and to add the flag for `--capability CAPABILITY_IAM`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Log in to the AWS Console and go to the CloudFormation service. At this point,
    you should be able to see both your root stack and the nested stacks that you
    have created. By clicking on the **Resources** tab, you can see all of the resources
    that you just created.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you don't want to incur charges then delete the stack.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using DependsOn to order resources
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although CloudFormation creates the resources in the order you specify in your
    template, it does not wait for the completion of any one resource before starting
    to build the next resource unless specifically instructed. The `DependsOn` construct
    allows you to pause the creation of specific resources until other resources have
    been completed.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of situations in which you would want to invoke `DependsOn`.
    The first set of scenarios involve those resources that need access to the internet,
    and hence they require an internet gateway to be completed before moving forward.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Adding wait conditions to a template
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `WaitCondition` adds a pause to the tasks that your template is performing
    on your stack until a success signal has been received, indicating readiness to
    move on.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a `WaitCondition` is added as a resource to a CloudFormation template,
    you must couple this with a `WaitConditionHandle` resource.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Even though the `DependsOn` construct and `WaitCondition` resource seem similar
    in function, they are different in a few ways. First is the fact that `DependsOn`
    is a much simpler implementation as it doesn't require a helper script. `DependsOn`
    also doesn't check for a success or failure signal for a resource once it has
    been created and therefore only governs the order of items produced in the template.
    A `WaitCondition`, on the other hand, needs to explicitly receive a success signal
    and will make the template (or change set) pause until this signal is received.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Using curl to signal
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using `curl` to signal to the `WaitCondition` that the resource, in most
    cases an EC2 instance, is done with its configuration, then it can be done dynamically.
    The first step is to create the `WaitHandle`, and then to construct the URL that
    the `CloudFormation` will use in the `curl` command. At that point, we are ready
    to call the `curl` command from within the `UserData` section of the template.
    We can see an example of this in an abbreviated template snippet, as shown next:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `WaitCondition` is the signal that is used in concert with one of the few
    helper scripts available in CloudFormation. Next, we will look at the different
    helper scripts available in CloudFormation templates.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Adding a helper script to a CloudFormation template
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In CloudFormation, there are a few different helper scripts, written in Python,
    that allow you to install software and start services when requesting and configuring
    EC2 instances as part of a template:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 7.1 – CloudFormation helper scripts'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '](img/013.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Table 7.1 – CloudFormation helper scripts
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, using these helper scripts provided by CloudFormation can greatly
    simplify EC2 configuration. Next, we will see how to detect drift in CloudFormation
    templates if your infrastructure deviates from your template code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how to detect drift in CloudFormation templates
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CloudFormation templates allow you to create and manage your infrastructure
    and resources as code in the various AWS accounts that you oversee. Following
    this method of provisioning items as code that can be checked in and out of version
    control is a best practice since it is repeatable, rather than trying to build
    and maintain cloud assets by hand.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Can you stop people from altering the assets you have provisioned in this manner?
    Unless you have used IAM policies to prevent groups from modifying any resources
    other than those submitted through CloudFormation templates or via code deployment
    pipelines, then there is a chance that there could be drift in some of the resources
    spun up by your CloudFormation templates.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: When you initiate a check for drift detection, the CloudFormation service compares
    the current stack and the resources that are currently provisioned versus what
    was originally specified in the template used to create or update that particular
    stack. It then reports any differences that it finds.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: With a good understanding of CloudFormation templates under our belt, we will
    now look at a complimentary service – AWS Service Catalog. Service Catalog is
    another tool in the AWS management toolbox that allows your users to quickly and
    easily provision resources that have been pre-created with a set guardrails around
    them.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Managing templates with Service Catalog
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we continue the conversation about CloudFormation templates, we start to
    look at other ways to manage the templates in an organization. The Service Catalog
    product from AWS allows us to use our CloudFormation templates and create a self-service
    portal for users to provision known patterns of items as long as they have been
    given the appropriate access. These templates, which now become products in our
    Service Catalog, can even become parameterized so that our user can choose items
    such as a vetted, predefined set of EC2 instance sizes and AMIs in the case of
    EC2\.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to understand a few concepts regarding Service Catalog. The
    first concept is a product. A **product** is an IT service that you want to make
    available on AWS. This could be something as simple as a single S3 bucket or as
    complex as an EC2 instance backed by an RDS database along with predefined CloudWatch
    alerts. The next concept to understand in Service Catalog is a portfolio. **Portfolios**
    are groupings of specific products along with configuration information. Portfolios
    are also tied to particular user groups, and give those user groups access to
    launch the products.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Looking at *Figure 7.11*, we can see the two different workflows that are available
    in Service Catalog from both an administrator's and user's perspective. The top
    view shows how an administrator would load up a template containing an EMR cluster,
    an S3 bucket, and CloudWatch alarms for repeated use as a product for the data
    users' group.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Any user in the data user''s group can then quickly provision not only the
    EMR cluster but a corresponding S3 bucket along with relevant S3 alarms after
    entering a few pieces of relevant information into the Service Catalog screens:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Service Catalog workflows'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.11_B17405.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.11 – Service Catalog workflows
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Service Catalog also allows you to update the templates containing your products
    and release newer versions with updated features. This can give your users the
    choice of which version to use: a version they are familiar with, or a version
    with newer features.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'There are quite a number of situations where this can become useful:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: When a solutions architect needs to be able to quickly provision a demo environment
    for a customer sales call.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The QA team would like to stand up a QA environment for testing.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a marketing department, where they would like a promotional application to
    run for a specific period of time.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A data scientist who needs a set of specialized software provisioned, such as
    an EMR cluster or a server with R Studio, but doesn't have the background in system
    administration to install and configure all of the necessary software and secure
    it correctly.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access control in Service Catalog is handled via IAM. The Service Catalog administrators
    create IAM roles specific to the products in the catalog so that users have just
    enough access to run the services provisioned by the catalog.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of different types of constraints that you can place on products
    in your Service Catalog in order to apply governance.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: There are template-based constraints that can shrink the number of options available
    to users when launching a product. Examples of this include the sizes of an EC2
    instance or RDS instance or the languages allowed for a Lambda product.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Tag-based constraints either enforce specific tags that need to be filled in
    when launching a product or disallow users to use any additional tagging besides
    those tags that have already been predefined.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: You can specify a particular SNS topic to receive updates about a product using
    notification constraints.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Defining which IAM roles can be used to run a particular product and be controlled
    via a launch constraint. This provides Service Catalog administrators an extra
    set of controls to say which services are allowed to be governed by the Service
    Catalog product.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: We just discovered how Service Catalog can allow even non-developers to quickly
    spin up predefined patterns of AWS infrastructure for users. These users don't
    need to worry about how to configure the underlying resources since all of that
    is handled by the underlying CloudFormation templates.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: We will next examine another way of creating CloudFormation templates that allows
    us much more flexibility then only using JSON or YAML in the Cloud Development
    Kit.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Using the Cloud Development Kit
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Developers are used to creating reusable libraries and using things like loops
    to take care of repetitive tasks. The **Cloud Development Kit** (**CDK**) allows
    those with a programming background to use a variety of languages (TypeScript,
    JavaScript, Python, Java, and C#) to create CloudFormation templates using techniques
    that they know, such as the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Logic (`if` statements, `for` loops)
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object-oriented techniques
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organization via logical modules
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is in contrast to CloudFormation templates, which require you, your developers,
    or DevOps personnel to write them in either JSON or YAML, although both of these
    options are somewhat universal in nature and can be picked up in a short time
    with or without a programming background. CloudFormation templates are also quite
    limiting in the number of programmatic options and logic that you can perform
    while creating your stacks:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – CDK workflow'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.12_B17405.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.12 – CDK workflow
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 7.12*, you can see the workflow of how a developer would create an
    app using the CDK. This app then creates a stack that deploys the CloudFormation
    template to the AWS cloud environment.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Concepts of the AWS CDK
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inside of the AWS CDK, there are three essential components – apps, stacks,
    and constructs – that developers can use to create cloud services.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Apps
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the AWS CDK, you are building an application, which in turn is an app and
    is composed of the CDK `App` class.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Stacks
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Units of deployment in the AWS CDK are stacks, and all resources defined within
    the scope of a stack are provisioned as a single unit. Since CDK stacks are implemented
    as CloudFormation stacks, any boundaries or restrictions that CloudFormation stacks
    need to abide by also are present for CDK stacks.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Constructs
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The building blocks of the AWS CDK are constructs. These can be a single AWS
    resource like a load balancer, or a single component consisting of multiple resources
    such as a VPC and subnets. Constructs create reusable components that can be shared
    like any other piece of code.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of using the AWS CDK
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will examine some of the advantages of using the CDK over normal CloudFormation
    templates.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Faster development process
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the AWS CDK you have the ability to use the languages that you natively
    program in, such as Python, TypeScript, .NET, Go and Java. In using these languages
    you retain the ability to create object, loops, and conditions that you are familiar
    with rather than having to learn domain-specific functions and work-arounds.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Code completion within your IDE
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using popular IDEs such as Visual Studio Code allows for code completion using
    the language of your choice when programming with the AWS CDK.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: The ability to deploy code and IaC synchronously
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the AWS CDK uses the same native language that you write your code in,
    combining pieces of infrastructure along with the code that would run your application
    becomes easy without any context switching.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to create IaC using both CloudFormation templates
    and the CDK. We examined some best practices of template construction and organization.
    We also practiced hands-on implementation of deploying and updating CloudFormation
    templates into stacks using both the AWS Management Console and the CLI.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will begin our examination of some of the AWS code tools
    that are part of the SDLC process, starting with CodeCommit and CodeBuild. We
    will create a code repository and commit to it using CodeCommit and then start
    building out code using AWS CodeBuild. Finally, we will see how we can tie both
    services together by triggering the CodeBuild job from pushes to our CodeCommit
    repository.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Review questions
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the two major components of CloudFormation?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have been contracted by a company to help review and optimize their CI/CD
    processes, especially in the area of IaC. The company currently has a single CloudFormation
    template, which they have developed over time, that is used to create the IAM
    account roles, VPCs, subnets, Lambda functions, CloudWatch alarms, along with
    SNS topics and other resources, including databases and EKS EC2 instances and
    their corresponding AutoScaling groups. How would you go about creating a recommendation
    for optimizing their process?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Check the current template to make sure that it has the correct `DependsOn`
    and `WaitCondition` embedded so that all resources come up without conflicts.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Create a plan on how to break up their large template.
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. Use the CloudFormation `package` command to package all of the templates
    together.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Take the smaller templates and launch with a single `deploy` command.
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After assessing a client's needs for a repeatable three-tier web application,
    you have decided to build a CloudFormation template that you can hand over at
    the end of the engagement. The middleware Linux servers have an elaborate user
    data script that takes a while to run in order to install completely. These servers
    are sitting behind a Network Load Balancer resource and need to be fully operational
    before being added. How can you make sure that the servers are fully operational
    and configured correctly before you attach them to the Network Load Balancer resource?
    (Choose two.)
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Make sure that the Network Load Balancer resource is located directly after
    the middleware servers in the CloudFormation resources section of the template.
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Add a `WaitCondition` that depends on the middleware servers. Once the user
    data finishes, it uses `cfn-signal` to notify that it is ready.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. Launch everything from a nested template where the middleware servers are
    in a template launched from the Load Balancer template.
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Add a `WaitCondition` that depends on the middleware servers. Once the user
    data finishes configuring the middleware servers, it uses a `curl` command to
    notify a pre-signed URL that they are ready.
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You are working at a large enterprise company and have a number of projects
    in the backlog that are waiting to be deployed to different AWS cloud environments.
    In order to minimize the amount of time it takes for each deployment, you want
    to create a reusable set of components that can be easily swapped out based on
    the architecture of each project. There is already a basic CodePipeline service
    instance in place to add the test and deployment steps. Whatever solution you
    choose should be able to be checked into a code version control system and be
    tested easily. How should you organize your resources for optimal reusability?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Use the AWS CDK to create apps made of a shared library of components. Add
    a testing library and then run the tests as a step in CodePipeline before deploying
    to the development environment.
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Create a library of small resource-specific CloudFormation templates that
    can be easily nested and packaged up according to the architecture guidelines.
    Use the `yamllint` and `cfn-lint` commands to lint the CloudFormation templates
    as a test step in CodeBuild to catch any errors.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. Develop a foundation of 5-10 blueprint patterns that all projects fall into.
    Using these blueprints, develop a library of CloudFormation templates with parameters
    and conditions so that they meet the majority of your project's needs. Use the
    `cfn-lint` command to lint the CloudFormation templates as a test step in CodeBuild
    to catch any errors.
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Create CloudFormation templates for each solution that have the necessary
    parameter values and conditions so that they work seamlessly on any Region and
    can be used in any environment (DEV, TEST, and PROD). Upload the templates to
    CodeCommit for version control.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Review answers
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Templates and stacks
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b and d
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
