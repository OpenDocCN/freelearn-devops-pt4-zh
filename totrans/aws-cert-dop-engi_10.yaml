- en: 'Chapter 8: Creating Workloads with CodeCommit and CodeBuild'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS has come up with an admirable set of tools to help developers and organizations
    run their CI/CD operations entirely from the Amazon ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration starts with the process of source code versioning and
    then building and testing your code in a repeatable, automated fashion. Two of
    the tools provided by the **AWS Codes Services Suite**, **CodeCommit** and **CodeBuild**,
    help engineers achieve these goals.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using CodeCommit for code versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up your CodeCommit repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Approvals in CodeCommit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using AWS CodeBuild
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a `buildspec` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we start on this path, a few assumptions are going to be made, especially
    with pursuing the professional DevOps certification. The first is that you have
    a basic knowledge of using the software versioning system known as Git. This basic
    knowledge includes creating a bare repository, creating a branch, making a commit
    to that branch, and then pushing that commit to a remote repository. If you need
    to get up to speed with Git, then using the tutorial *Getting Started with Git
    and AWS CodeCommit* is suggested. You can find it at [https://docs.aws.amazon.com/codecommit/latest/userguide/getting-started.html](https://docs.aws.amazon.com/codecommit/latest/userguide/getting-started.html).
  prefs: []
  type: TYPE_NORMAL
- en: The second assumption is that you already have Git installed on your laptop
    or workstation. Suppose you don't have Git installed yet or cannot access it due
    to a lack of administrative permissions. In that case, a perfect alternative is
    to spin up an Amazon EC2 instance in your AWS account that you can install Git
    on so that you can follow along with the exercises.
  prefs: []
  type: TYPE_NORMAL
- en: If Git is not installed on your local workstation and you either cannot install
    it or would not like to install it, AWS provides the Cloud9 development environment,
    which allows you to create code inside of a browser window.
  prefs: []
  type: TYPE_NORMAL
- en: Using CodeCommit for code versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are plenty of choices regarding where you can store your code, both on-premises
    and within SaaS solutions. Features and values are what tend to drive decisions
    on which product to use. AWS CodeCommit provides both a robust set of features
    and the value of being a pay-per-use service, containing elements such as native
    connectivity to AWS services, along with them complying with multiple assurance
    programs such as SOC2, PCI, HIPAA, and others.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 6*](B17405_06_Final_JM_ePub.xhtml#_idTextAnchor166), *Understanding
    CI/CD and the SDLC*, we discussed the four major phases of the software development
    life cycle: source, build, test, and deploy. The initial phase, source, is what
    we will be concentrating on in this section. As a quick recap, the source phase
    allows you to check your code into a central repository and also allows multiple
    people to collaborate on the same code base.'
  prefs: []
  type: TYPE_NORMAL
- en: What is CodeCommit?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CodeCommit is a secure, highly scalable, managed source control service that
    hosts private Git repositories. This may sound a bit foreign initially, but you
    have probably used a SaaS service to host code already if you have used BitBucket
    or GitHub private repositories.
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental object in CodeCommit is the repository. The repository is where
    users store code and objects of any type and size for their projects. CodeCommit
    also stores and tracks changes that have been made to uploaded files, along with
    changes that have been made to files. You can configure the repository to send
    notifications when events happen, such as branch merges or comments being added
    to code. It also allows users to work on their local systems and then push changes
    to the CodeCommit storage system.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of CodeCommit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As part of the AWS ecosystem, CodeCommit can integrate with services such as
    KMS for encryption, as well as CloudWatch to incorporate metrics and alarms for
    our repositories, and this doesn''t even touch on some of the development tools
    that are tightly integrated with the CodeCommit service. Aside from just being
    tightly coupled with numerous other AWS services, CodeCommit provides many other
    benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: IAM for CodeCommit provides high service availability and durability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CodeCommit repositories are encrypted at rest and in transit, so you know that
    your code is always secure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It scales easily and has no limits on the size of repositories or the types
    and sizes of the files you can store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seamlessly integrates with several AWS services (Lambda, SNS, CodePipeline).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows you to migrate from other remote Git-based repositories easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows you to use the Git tools and commands that you already know.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this overview and the benefits of AWS CodeCommit under our belt, we will
    look at the available access control features before creating our repository and
    our new group specifically for CodeCommit access.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling access to repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we go through the process of creating the CodeCommit repository, we need
    to do a little pre-work as far as permissions are concerned. Up until this point,
    we have been doing most things as an administrative user. We are starting to add
    developers and development teams into the mix, some of which only need access
    to the CodeCommit repositories and no other services. We are going to create a
    new IAM group and then add a developer entity to that group. This will demonstrate
    good GitFlow practices of the developer contributing code and then asking for
    their branch to be merged into the main branch.
  prefs: []
  type: TYPE_NORMAL
- en: This works when the developers are all part of the same account where we are
    creating our CodeCommit repositories. There are other scenarios that we need to
    be aware of as well. For example, what happens when a developer in another account
    needs access to CodeCommit repositories in our account? CodeCommit can provide
    cross-account access to users and roles in another AWS account. This can solve
    the issue of not having to add external developers to your IAM list of users if
    they already have an AWS account.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your CodeCommit repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A CodeCommit repository can be created via the CLI. However, when using the
    AWS management console, there are some additional features, such as the info panel,
    that are only available in that environment.
  prefs: []
  type: TYPE_NORMAL
- en: Before we create the repository, be sure to open your browser to the AWS CodeCommit
    home page, [https://console.aws.amazon.com/codesuite/codecommit/home](https://console.aws.amazon.com/codesuite/codecommit/home),
    and sign in if prompted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have signed in, we can go through the process of creating a repository
    in CodeCommit:'
  prefs: []
  type: TYPE_NORMAL
- en: Once you're on the `CodeCommit` main page for the region you are working in
    (we are doing everything in our examples in the Ohio region/`us-east-2`), click
    on the orange **Create repository** button in the top right-hand corner to start
    the process of creating a new repository:![Figure 8.1 – Create repository button
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.1_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.1 – Create repository button
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the `chapter8` for the name of the repository. If you like, you can add a
    description for the repository, but it is not necessary. You may wish to enable
    the CodeGuru reviewer at this point; however, since this is a new feature, we
    will not be going over this:![Figure 8.2 – New code commit repository settings
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.2_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.2 – New code commit repository settings
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Amazon CodeGuru reviewer is an optional feature and an additional service
    of AWS that, at the time of publishing, only works for the Java and Python languages.
    More languages may be available at a later time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you have created your repository, you will be taken to a screen showing
    the connection steps for connecting to your new repository in several ways. These
    include HTTPS, `SSH`, and the git-remote-connect protocol over HTTPS. Take a moment
    to look over these. We will be using this section more once our developer has
    been created and we are using their set of permissions. Scroll down past the connection
    steps. At the bottom of the page, you will see a button called **Create file**.
    Click this button so that we can set up our main branch:![Figure 8.3 – Creating
    an initial file for our CodeCommit repository
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.3_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.3 – Creating an initial file for our CodeCommit repository
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the `Welcome to my repository`. Once you have done this, in the `sample.txt`.
    You will also have to enter a name and an **Email address** for the commit on
    the web interface, as shown in the following screenshot:![Figure 8.4 – Committing
    the change to CodeCommit via the web interface
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.4_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.4 – Committing the change to CodeCommit via the web interface
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you''ve entered this information, you can press the orange **Commit changes**
    button. From here, you will be taken to the file in the repository; however, it''s
    more important to note that, in the top right-hand corner of the screen, we have
    successfully created the **main** branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.5 – The main branch of our CodeCommit repository'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.5_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – The main branch of our CodeCommit repository
  prefs: []
  type: TYPE_NORMAL
- en: With our repository and main branch now created, we can start creating the permission
    set that our developers will use to push code up to the repository. Depending
    on how your organization is structured, you may give all developers the ability
    to create new repositories and merge pull requests to the main branch.
  prefs: []
  type: TYPE_NORMAL
- en: In our example scenario, as we work through the exercises, we will be separating
    the duties from what a developer can do versus an administrator or DevOps power
    user. It's imperative to think about how to divide responsibilities as you prepare
    for the exam, as well as some of the questions and scenarios that may be presented.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your IAM group for developers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we begin, make sure that you download the files from this book''s GitHub
    repository, from the `Chapter-8` folder. We will start by creating the IAM policy
    for the developers. Once our policy has been uploaded, we will create the developer
    group and then attach our policy to the newly created group:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your terminal so that you have access to your AWS CLI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We want to create a group just for our code commit developers. You may have
    made a developers group previously, but we want to make a new group just for this
    chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that you have created the group, we will attach the policy to it. We will
    need the policy ARN from when we created our `CC_Developers` policy just a few
    moments ago:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have created the `CC_Developers` group, we can create our developer
    and allow them to log in and add their `SSH` key to start using `CodeCommit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating your developer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we are going to create a fictional developer called `Mariel`.
    If you like, you can change the name of the developer from `Mariel` to something
    else. If you haven''t already, download the `change-password.json` file and follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If your terminal isn''t open still, open it back up so that you can perform
    commands in the AWS CLI. Use the `create-user` command from `iam`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once this command has finished running, it should return a `JSON` statement
    that shows, among other things, the User ID, as shown in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With our user created, we can attach them to the `CC_Developers` group and
    allow them to inherit all the group''s permissions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we''ve created our user and attached them to the `CC_Developers` group,
    we will need to create an initial password for the user so that they can log into
    the management console and upload their `SSH` key. It is also a good idea to require
    them to reset their password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we have created an initial password for our user to configure their
    `SSH` key settings in the console and view the CodeCommit branches via the console.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've created our developer using the AWS CLI, we can switch contexts
    and assume the role of the developer as we continue.
  prefs: []
  type: TYPE_NORMAL
- en: Adding your developer's SSH key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have created our developer, we will switch from the CLI and move
    to the `SSH` key pair in our working environment that we can use to authenticate
    ourselves when creating code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: When using a specific repository or set of repositories for an account, client,
    or specific purpose, it's a good idea to create a particular key just for that
    project, account, or client. Using distinct keys is part of an overall risk mitigation
    strategy in case anything were to happen to the servers, SaaS offerings, or your
    workstation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating an `SSH` key pair that's specific for our developer
    to be able to add to the AWS IAM console.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your terminal, use the following command to generate a new key pair file
    for Linux or macOS users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this command will start by asking you a few prompts, the first of which
    will be where you want to save your key. The default should be in your local `.ssh`
    folder, but with an `id_rsa` name. Instead, we will use a custom name for our
    key so that we know it is specifically for our code commit project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After you have chosen where to save you key with its name, then you will be
    presented with a prompt for a `passphrase`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have no requirements for a passphrase, so just hit *Enter* twice to leave
    this blank. At this point, you should see statements saying where your identity
    and public key have been saved, along with something that looks like ASCII art.
  prefs: []
  type: TYPE_NORMAL
- en: You will need to cat out your public key and have that available when we log
    into the AWS console as the developer.
  prefs: []
  type: TYPE_NORMAL
- en: After you have generated your key
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have generated our key, we need to log into the AWS console using
    the developer's username and credentials that we just created (and not the DevOps
    user who has administrator privileges, which is what we have been using up to
    this point.)
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You may want to use a different browser or start an incognito/private session,
    just to be sure that you don't have any lingering cookies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your new browser, log in as the developer user that we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: We will now use the developer account instead of our administrator account.
    Log into your account at [https://aws.amazon.com/](https://aws.amazon.com/) and
    use the developer's name (`mariel`, in our case) and password (`Dev0psPRO`) to
    sign into the AWS Management Console initially.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once signed in, you will be immediately prompted to change your password from
    the initial password that was set to one of your choosing. If you previously put
    a password policy in the **IAM Account** settings, you must adhere to these guidelines
    when changing the password:![Figure 8.6 – Mandatory password change for the developer
    user
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.6_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.6 – Mandatory password change for the developer user
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you have changed the password, you will be brought to the main page of
    the AWS management console. Now, we need to type **IAM** in the search box to
    go to the **IAM service**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have reached the IAM service, it will look as if you don't have permission
    to do anything. However, this is only because the developer role has a limited
    scope of permissions. This user can list users and update information about their
    user. Click on the **Users** menu item on the left-hand menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you're on the user's menu, you will see a list of users. Click on the name
    of the developer that we created (in our case, `mariel`):![Figure 8.7 – List of
    IAM users
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.7_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.7 – List of IAM users
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the **Summary** page for the user, you will be met by a few red boxes, but
    here, we are interested in the **Security credentials** tab. Click on this tab
    so that you can start modifying the **Security credentials** page:![Figure 8.8
    – IAM user summary top menu
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.8_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.8 – IAM user summary top menu
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Scrolling down on the `SSH``SSH``public key` not only available but in your
    clipboard, ready to paste. Press the `SSH` **public key** button to continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the pop-up window appears, paste your public key into the text box and
    then click the blue `SSH``SSH` **key ID** listing. Take note of this as we need
    this ID in just a moment for our local setup:![Figure 8.9 – The SSH key ID is
    given in the IAM console once the SSH public key has been uploaded
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.9_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.9 – The SSH key ID is given in the IAM console once the SSH public
    key has been uploaded
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Back in your workstation, we need to either create a `.ssh/config` file or
    modify the existing `config` file by adding a few lines specific to the code commit.
    Use your editor of choice to create or open `~/.ssh/config` and then add the following
    lines. Be sure to change out the sample user ID for the one that the AWS console
    returned to you after uploading your key. Also, if you created a different name
    for your `SSH` key, you will have to substitute that in the `IdentityFile` line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Going back to the browser and the AWS Management console, we will now switch
    over to the CodeCommit service so that we can get the repository information to
    clone the repository. In the top search box, type `CodeCommit` and then click
    on the icon to be taken to the **CodeCommit** service page.![Figure 8.10 – The
    CodeCommit icon from the search bar in the AWS Management Console
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.10_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.10 – The CodeCommit icon from the search bar in the AWS Management
    Console
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once on the `SSH` link on the right-hand side to copy the **Clone URL** property:![Figure
    8.11 - The CodeCommit repository as it appears to the developer user
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.11_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.11 - The CodeCommit repository as it appears to the developer user
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Switch back to your terminal and navigate to the root of your home folder.
    Then, cut and paste the copied URL after the `git clone` command, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, move to the `chapter8` directory. Now, you are ready to start adding
    some code or objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, we have created an `SSH` key and added that to our development
    user. Then, we updated our local `SSH` config to let CodeCommit know that when
    working with code commit, which user and keypair are connected. Finally, we downloaded
    the repository that the administrative user had created earlier. We are now ready
    to create our developer branch and start pushing up some commits.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a developer branch and pushing commits to that branch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have successfully cloned our repository to our local workstation,
    it's time to create a branch and submit it. All of these actions will happen in
    the directory where you cloned your repository. If you followed the same naming
    convention as in the preceding examples, you should go to your home directory
    and find the `chapter8` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we will do is create a feature branch off of the main
    branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that we're in our branch, we can start adding some files to make the commit.
    There are two sample files (`hello.py` and `loops.py`) in the `Chapter-8` folder
    of the GitHub repository. You can view these files and then cut and paste the
    raw contents into new files of the same name in the `chapter8` CodeCommit repository
    that we have downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we make our commits, we should check the status of our files in our
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After using the `status` command, we should see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to add the two files to the commit. Since they are both of the
    same types, we can use a wildcard in our commit command. As an alternative, you
    can use just a pure wildcard and add all the untracked files to the commit at
    once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we need to commit the files to our feature branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, with the two files committed to the feature branch, it''s time to
    push that feature branch up to CodeCommit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon successfully pushing the new feature branch, you should receive confirmation
    from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have made the commit to our feature branch and pushed it up to the
    CodeCommit repository, it's time to make the merge request. This merge request
    will allow our code to become part of the main branch for everyone else who is
    working off of the same code repository, along with keeping up to date with the
    main branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will go back to the AWS console as our developer user to create the pull
    request. If you still have your developer''s separate session open in a web browser,
    then you can switch back to that browser session; otherwise, log into your account
    at [https://aws.amazon.com/](https://aws.amazon.com/) and then use the developer''s
    username (`mariel`, in our case) and the new password you changed for your developer
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: In the search box at the top, type `CodeCommit` and then click on the **CodeCommit**
    icon to be brought to the **Service** page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see your repository, as shown in *Figure 8.7*. Click on the name
    of the repository (`chapter8`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the top menu, you will see a dropdown that currently says **main**. Click
    on this dropdown and select your branch (**feature1**). Once you've done this,
    the two files that you have uploaded will appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that your branch name is showing in the top menu, you should see a button
    called **Create pull request**. Click on this button to start the merge request:![Figure
    8.12 – The Create pull request button alongside the branch name
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.12_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.12 – The Create pull request button alongside the branch name
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A green box should appear, showing that we don't currently have any conflicts
    between our branch and the main branch. Before you create the merge request, you
    will need to add something to the `Python files`. With the title filled in, click
    on the orange **Create pull request** button at the bottom of the screen:![Figure
    8.13 – The pull request showing that it has no conflicts
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.13_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.13 – The pull request showing that it has no conflicts
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you have created the pull request, you will be taken to a screen where
    you can view the details of the currently opened pull request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have entered the pull request, this is where the developer user
    stops. The IAM policy that we have allocated will not allow them to merge the
    branches, and this is by design.
  prefs: []
  type: TYPE_NORMAL
- en: Next, using our administrator, we will learn how to merge the request into the
    main branch.
  prefs: []
  type: TYPE_NORMAL
- en: Approvals in CodeCommit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As developers update code and then push those updates to the CodeCommit repository,
    especially if they are using their feature branches, there needs to be a process
    for incorporating their changes into the main branch. Let's walk through how to
    take the code that our developer created on their branch and merge it into the
    main branch.
  prefs: []
  type: TYPE_NORMAL
- en: Merging your developer branch with the main branch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, we haven''t enabled any notifications for our repository, but
    in a real-world scenario, this is an excellent way to add notifications for when
    someone has created a pull request. Our developer has created a branch on our
    repository, which is now ready to be merged. As the account user with merge privileges,
    we will log in and merge the feature branch and the main branch:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your console and log into **Amazon Web Console** as the primary administrative
    user that you have been using up to this point, not the developer user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the `CodeCommit` in the top search bar in the middle of the screen.
    Once the **CodeCommit** icon becomes visible, click on it:![Figure 8.14 – Searching
    for CodeCommit in the top search box for services
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.14_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.14 – Searching for CodeCommit in the top search box for services
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once on the main CodeCommit screen, so long as you are in the correct region,
    you should see the repository that we created earlier by the developer user named
    **chapter8**. Click on this repository name to be taken into the repository:![Figure
    8.15 – The chapter8 repository inside of CodeCommit
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.15_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.15 – The chapter8 repository inside of CodeCommit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After clicking the repository's name, a set of menu options will appear on the
    left-hand side of the screen, under **Repositories**. Here, you will find a sub-heading
    called **Pull requests** that will show us any outstanding pull requests, including
    the one that was created by our developer user previously. Click on the **Pull
    requests** menu item to be taken to the pull requests screen:![Figure 8.16 – Pull
    requests on the Repositories menu of CodeCommit
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.16_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.16 – Pull requests on the Repositories menu of CodeCommit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our pull request name should be **Python Files**, predicated by number one.
    **Python Files** was the name that our developer user used when creating the pull
    request originally. We should also see a blue status of **Open** on the right-hand
    side of the pull request name. Click on the pull request's name, **1:Python files**,
    to be taken to the **Merge** screen:![Figure 8.17 – Pull request with status
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.17_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.17 – Pull request with status
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, on the pull requests screen, which will be labeled with **1: Python files**
    at the top of the screen, you should see three colored labels right below the
    heading: **Open** (in blue), **No approval rule** (in dark gray), and **No merge
    conflicts** (in green). The latter is telling us that we can easily merge our
    pull request into the main branch. Do this by clicking on the orange **Merge**
    button at the top right-hand side of the screen:![Figure 8.18 – Notifications
    about the CodeCommit pull request'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.18_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.18 – Notifications about the CodeCommit pull request
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At this point, we will come to the **Merge pull request** screen. This screen
    is all about the merge strategy, but for this exercise, we are going to leave
    the defaults as-is. This includes keeping the box checked at the bottom that will
    delete the branch that is being merged in and using the fast forward merge strategy.
    Click the orange **Merge pull request** button at the bottom right of the page
    to merge the feature branch into the main branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, you should see a notification at the top of the screen in green, telling
    you that your `feature1` branch has been merged into the main branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have just taken a thorough look at the CodeCommit service and looked at
    how to perform commits and merges from the perspective of multiple team members.
    With our source code in order, we will look at an AWS service that can produce
    packages along with test software: AWS CodeBuild.'
  prefs: []
  type: TYPE_NORMAL
- en: Using AWS CodeBuild
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`buildspec` file and the job is initiated, CodeBuild will allocate the specified
    resources.'
  prefs: []
  type: TYPE_NORMAL
- en: This is in contrast to other build systems, where you need to manually provision
    the compute for the workers or perform complex setups to ensure that autoscaling
    environments are available for heavy build and test periods.
  prefs: []
  type: TYPE_NORMAL
- en: You can run AWS CodeBuild as a standalone service, or it can be integrated with
    other services, such as **CodeCommit** and **AWS CodePipeline**, to create a repeatable,
    automated process that is part of your continuous integration life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Features to know about CodeBuild
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the features you should know about CodeBuild:'
  prefs: []
  type: TYPE_NORMAL
- en: '**It''s a fully managed build service**: There is no need to set up, patch,
    or update any servers or software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It scales to meet your needs**: CodeBuild can scale up and down to meet the
    demand you place on it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It''s securely backed by AWS**: With optional encryption powered by KMS,
    along with permissions down to the specific job with IAM, you can feel confident
    in securing your build environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's one of the AWS developer tools that tightly integrates with CodeCommit,
    CodeDeploy, and CodePipeline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CodeBuild integrates natively with **CloudWatch Events** so that failed builds
    and items can be triggered, such as sending SNS messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logs can be set as output to S3 or **CloudWatch Logs**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudWatch metrics and alarms can be used to monitor CodeBuild thresholds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a CodeBuild job
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CodeBuild is very versatile in the tasks it can perform. For our example, we
    will create an `buildspec` file to create a Docker image, and then push that Docker
    image to the ECR:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19 – Layout of what the example CodeBuild job does'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.19_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.19 – Layout of what the example CodeBuild job does
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven''t already downloaded the `Chapter-8` files from this book''s
    GitHub repository, then now is the perfect time since we will be using the `docker`
    directory in our first CodeBuild exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the directory where you have downloaded the `Chapter-8` files.
    Do not go into the `docker` directory, as we will upload all of the files at once
    using a recursive command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we''re going to create our ECR repository so that our container has
    a place to go once it''s been built:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With our ECR repository created, we will open the AWS Console to complete the
    rest of the CodeBuild project. Make sure that you do this using the administrative
    user and not the developer user. Once your AWS console is open, search for `CodeBuild`
    in the top search box and then click on the icon to be taken to the CodeBuild
    service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the CodeBuild service, click the orange button at the top right-hand corner
    that says **Create build project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create our project, we will start with the initial section: `chapter8_docker`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'b. `An example build for chapter 8`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.20 – Project configuration on the CodeBuild Create build project
    page'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_8.20_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.20 – Project configuration on the CodeBuild Create build project page
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we will move to the `devopspro-beyond`. Finally, we will provide the key
    that is asking for the folder that we uploaded the files in. In our case, this
    would be `docker/`. We don't have any versioning on our bucket, so we can leave
    this field blank:![Figure 8.21 – Source declaration in the CodeBuild project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.21_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.21 – Source declaration in the CodeBuild project
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we will be taken to the
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b. `aws/codebuild/standard:5.0`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'e. **Image version**: **Always use the latest version for this runtime version**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'f. **Environment type**: **Linux**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'g. **Service role**: **New service role**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the image in the CodeBuild project, we have specified version 5.0 here.
    However, you may want to look for the latest version available from AWS.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At this point, you can leave the rest of the options as they are, scroll down
    to the bottom of the page, and click on the orange **Create build project** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now be taken to the screen of your build project. At the top, you
    will see a green banner stating that your build project has been created:![Figure
    8.22 – A successful project created in AWS CodeBuild
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.22_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.22 – A successful project created in AWS CodeBuild
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, we can try to run our job and see how it turns out. If you would like to
    run the job and start a build, then click the orange **Start build** button at
    the top right-hand corner of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is just a base project and doesn't have to be the stopping point. We can
    still edit both the job and the `buildspec` file to add enhancements to the job
    if we so wish.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our project created via the console using an S3 bucket as the source,
    we will now take a closer look at the actual file that runs the CodeBuild job:
    the `buildspec` file.'
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the buildspec file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `buildspec` file is what drives the CodeBuild process and has a few strict
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: It must be named `buildspec.yml`, and it can go by no other names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must be in the `root directory` of your source code folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must be in the YAML language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you open the `buildspec` file to examine it after completing the previous
    exercise, then you would notice that it contains three major sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Version**: This tells the CodeBuild service which version of the syntax you
    are using and is one of the few required sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Install`: This is only used for installing packages in the build environment.
    If you need to install a testing framework such as `pytest` or `Mocha`, this is
    the step where you would perform this task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'b. `pre-build`: These are commands that happen before the actual build command
    is run. Pre-build commands can include signing into an `Build`: At this part of
    the phase, these are the commands that are run during the build. These can be
    commands that build the software, create a container, or create commands that
    test the software.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'd. `post-build`: Once the build has been completed, these are any commands
    that are performed afterward, which can include packaging up the software in a
    `.jar` or `.war` file, or creating a Python egg file. It can even involve uploading
    a container to a repository such as ECR or DockerHub.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Artifacts**: This is the build output. This can include the names of the
    files, the actual files themselves, or both. The artifacts phase also allows you
    to keep the directory structure where the files have been created or strip that
    away so that you just have the files themselves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are quite a few other options that are available in the `buildspec` file,
    depending on your use case. You can use environment variables, create reports,
    and even run as a specific user or a Linux operating system. For a complete list
    of options, please reference the AWS build spec documentation available at [https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html](https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html).
  prefs: []
  type: TYPE_NORMAL
- en: We just took a deeper look at constructing `buildspec` files and what components
    they comprise. Next, we will concentrate on the artifacts that CodeBuild produces
    and how to export them and store them elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Storing CodeBuild artifacts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you create a software package, you can have AWS CodeBuild automatically
    save this artifact into an S3 bucket for use during deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Inside of your `buildspec` file, if you are looking to create artifacts, you
    can declare just one artifact, or you can declare multiple artifacts. In the *Creating
    a CodeBuild job* section, the `buildspec` file had one artifact declared at the
    end.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While the name CodeArtifact may lead you to believe that you can automatically
    store CodeBuild artifacts after a build, you can't. CodeArtifact can be used in
    conjunction with CodeBuild by supplying language packages just like a **NuGet**,
    **PyPi**, or **npm server** would do during the build process so that your team
    can have standardized packages and forgo download limits from public servers.
  prefs: []
  type: TYPE_NORMAL
- en: Using CodeBuild to test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the first use of AWS CodeBuild that comes to mind may be creating packages
    for deployment and building Docker containers, this service also can serve a dual
    function in the SDLC process, and that is for testing. CodeBuild allows you to
    run the predefined unit tests and see reports of both a graphical and textual
    nature in the console regarding the results of those tests.
  prefs: []
  type: TYPE_NORMAL
- en: Reports expire after 30 days of creation and once they have expired, you nor
    anyone else with access to the report can view the report. If you need to keep
    the results of a report for more than 30 days, then you have the option to export
    the raw results of the report to an S3 bucket, where they will not expire and
    will only be phased out based on the bucket's life cycle policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'CodeBuild supports the following test report file formats:'
  prefs: []
  type: TYPE_NORMAL
- en: Cucumber JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Junit XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NUnit XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TestNG XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio TRX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying a report group name in your `buildspec` file with information about
    your test cases allows CodeBuild to create a report group for you if one doesn't
    already exist.
  prefs: []
  type: TYPE_NORMAL
- en: Once tests have been created, AWS CodeBuild can show reports on the console,
    providing a quick summary of the status of all of our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering CodeBuild jobs via CodeCommit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AWS CodeCommit can be used as the input source for the build. CodeCommit by
    itself cannot natively signal to CodeBuild that it has received either a new commit
    or a merge into a branch. However, with the help of the Lambda service, you can
    add a trigger that will initiate the CodeBuild job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having an automated process such as this without any manual intervention helps
    teams find bugs, along with deployed software, in a more expedient fashion. Creating
    a trigger that automatically signals the CodeBuild project to kick off the build
    is a great way to add continuous feedback to your **Software Development Life
    Cycle** (**SDLC**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.23 – Triggering a CodeBuild job from CodeCommit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.23_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.23 – Triggering a CodeBuild job from CodeCommit
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at how to start a CodeBuild job using the CodeCommit
    service automatically, we know how to automatically start CodeBuild jobs as soon
    as new code has been successfully merged into the project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, [*Chapter 9*](B17405_09_Final_JM_ePub.xhtml#_idTextAnchor237),
    *Deploying Workloads with CodeDeploy and CodePipeline*, we will learn how the
    CodePipeline service can also be used to start a build process from CodeCommit.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at some of the advanced features of AWS CodeBuild.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced features of AWS CodeBuild
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some of the features we will talk about in this section aren't mandatory for
    the DevOps professional exam. Since this book has *beyond* in its title, the following
    are some helpful features that can make using the service a bit easier. They are
    also good tips that you can share with teammates and clients.
  prefs: []
  type: TYPE_NORMAL
- en: Using AWS Session Manager to help troubleshoot builds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are trying to troubleshoot builds, then rather than looking up a way
    to `ssh` into the AWS-based docker images session manager, AWS Session Manager
    will allow you to jump into the build and try and troubleshoot what is happening.
    You can pause your build by adding `codebuild-breakpoint` to your `buildspec`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once you have finished troubleshooting, you can pass `codebuild-resume` via
    the Command Prompt to pick up where you left off in your `buildspec` file.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how we can get our teams to share code using the
    AWS native source code tool CodeCommit. We also looked at how to package, build,
    and test our software using the CodeBuild tool.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue looking at **AWS Developer Tools**. This
    includes using CodeDeploy to deploy workloads and then tying everything together
    using AWS CodePipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Review questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have been asked to set up a CodeCommit repository for your organization
    for the development team. The developers need the ability to push commits to their
    branches but not merge commits to the main branch, nor push commits to the main
    branch. The project manager also needs to be notified whenever a merge or a commit
    to the main branch occurs. Which combination of steps will safeguard the master
    branch and send the notification in the shortest time possible?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Attach a resource policy to the CodeCommit repository that denies members
    of the IAM developer group actions of pushing commits, merging requests, and adding
    files to the main branch.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Affix an IAM policy to the developer IAM developer group that denies the
    actions of pushing commits, merging requests, and adding files to the main branch.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. Configure AWS CloudTrail to send log events to send logs events to Amazon
    CloudWatch logs. Create a CloudWatch alarm based on a defined metric filter to
    identify CodeCommit Repository events. Use an SNS topic as a target that the project
    manager is subscribed to for the CloudWatch Alarm.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Create an Amazon CloudWatch Events rule that's triggered by a CodeCommit
    Repository State Change event by the main branch. Use an SNS topic that the project
    manager is subscribed to for the target.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: e. Create a Lambda function to check for repository changes that will be sent
    to an SNS topic that the project manager is subscribed to if changes are found.
    Have AWS CloudWatch Events run the Lambda every 15 minutes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You have a CodeCommit repository in your account that your developers have a
    limited set of actions for. Two new developers from a different Organizational
    Unit need to access this CodeCommit repository, but their users are based in a
    different AWS account. What is the most effective way to grant these new developers
    access?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Enable public access for the repository.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Create IAM users for each new developer and then grant them access to the
    repository.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. Create an IAM group for the external developers, add the IAM users, and then
    provide access to the repository.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Create a cross-account role in your account, assign the necessary privileges
    to the role. and then provide the role ARN to the developers so that they can
    assume the role.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A client is looking for a new code versioning service and no longer wants the
    management hassle of running his servers. Currently, his team is small and not
    looking to grow exponentially over the next four quarters, but he is extremely
    concerned about the encryption abilities of any service he considers. What can
    you explain to him regarding AWS CodeCommit's ability to protect objects and code
    with encryption?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. All transmissions are encrypted in transit and can only be done through the
    HTTPS or `SSH` protocols.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Transmissions are encrypted in transit when sent through the `SSH` protocol.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. CodeCommit repositories are automatically encrypted using KMS.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. CodeCommit repositories can be encrypted using KMS.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You are setting up a new build process that is using S3 as the source of the
    code. You want to have unit tests run against the code that you and other developers
    have previously created and placed in a directory called `test/`, which is located
    in the child directory in the main source code directory. You plan to work on
    this build process for 60 days and want to be able to view the historical test
    reports, even from the first build. How can you configure this with native AWS
    services?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. The test reports will be available in the `buildspec` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Export the CodeBuild test data to S3 after every build and use AWS QuickSight
    to create the test reports.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. The test reports will be available in the Reports tab of the CodeBuild section
    of the console if you specify a report section in your `buildspec` file. Create
    a Lambda function that is triggered by CloudWatch events to export the raw data
    from the test reports that will be saved to an S3 bucket and available to be reviewed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. This is not possible with native AWS services.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Review answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: b, d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a, c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
