- en: 'Chapter 9: Deploying Workloads with CodeDeploy and CodePipeline'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Teams are looking for an easy-to-use tool that allows the automation of the
    release process and gives a consistent release process. We will look at incorporating
    **CodePipeline** and the third-party tool Jenkins to automate our deployments'
    release cycle, which can then integrate into **CodeDeploy** for the actual code
    deployments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: About AWS CodePipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a code pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Jenkins to build your workloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About AWS CodeDeploy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases for AWS CodeDeploy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you plan to follow along with the exercises in this chapter, there are some
    dependencies in the previous chapter, [*Chapter 8*](B17405_08_Final_JM_ePub.xhtml#_idTextAnchor212),
    *Creating Workloads with CodeCommit and CodeBuild*. Just as in the real world,
    we are building on what we have previously started in earlier chapters. Hence,
    if you have not created a developer user from the previous chapter, you will need
    to do so with the corresponding **Identity and Access Management** (**IAM**) permissions
    in their group.
  prefs: []
  type: TYPE_NORMAL
- en: About AWS CodePipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS CodePipeline can be thought of as a conductor in an orchestra. Using either
    code or the AWS console, you can put together your software development life cycle
    process in a visual representation that is either fully automated or has manual
    checks along the way for certain stages to be passed. This whole process is then
    laid out visually for your team members (including developers, testers, and others)
    to see which deployments happened and which deployments failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'AWS CodePipeline helps you automate the steps you require to release your software
    and infrastructure changes in a continuous manner, as illustrated in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – CodePipeline and its integration with other AWS developer tools'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.1_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – CodePipeline and its integration with other AWS developer tools
  prefs: []
  type: TYPE_NORMAL
- en: The different AWS developer services, which CodePipeline is one of, are depicted
    in *Figure 9.1* and shown underneath their respected stages in the **Systems Development
    Life Cycle** (**SDLC**).
  prefs: []
  type: TYPE_NORMAL
- en: CodePipeline structure for actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CodePipeline is structured into several different categories that allow either
    native AWS services to act or allow a supported third-party service to be integrated
    and perform the necessary action.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are six valid action categories, as listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Approval
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoke
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of the action categories has its own set of providers that can invoke
    actions or have actions invoked from that resource, as outlined in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 9.1 – CodePipeline source actions and action providers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/014.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9.1 – CodePipeline source actions and action providers
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the action integrations, a few other AWS services integrate
    without any specific action category, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Amazon CloudWatch**: CloudWatch can monitor your resources that are built
    with the pipeline or are being tested and integrated into the pipeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon CloudWatch Events**: CloudWatch Events can detect changes to your
    pipeline as a whole or even at certain stages of your pipeline. CloudWatch Events
    can even listen to other outside services and then trigger a CodePipeline run
    if specific scenarios happen, such as if someone updated a CloudFormation stack.
    This would then create a need for the software to be redeployed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS Cloud9**: Cloud9 is the cloud-based **integrated development environment**
    (**IDE**) that is accessible via a web browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS CloudTrail**: If the CloudTrail service is active for the particular
    region, any **application programming interface** (**API**) actions that happen
    via the AWS console, **software development kits** (**SDKs**), or **command-line
    interface** (**CLI**) are captured and recorded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS KMS**: **Key Management Service** (**KMS**) can be integrated with AWS
    CodePipeline for source S3 buckets and artifacts, which either are encrypted or
    need to be encrypted. Suppose the artifacts are coming from an account other than
    the one where the CodePipeline is being executed. In that case, the key that is
    encrypting the bucket and objects will need to be a customer-managed key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at *Table 9.1*, you can see that there is a combination of both native
    AWS services and specialized third-party partner tools that you may already be
    using to integrate into your code pipeline stages.
  prefs: []
  type: TYPE_NORMAL
- en: We have just looked at the different actions along with their corresponding
    AWS services and third-party services that can help perform those actions. Next,
    we will look at some of the use cases for AWS CodePipeline, including real-world
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases for AWS CodePipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When thinking about what you can do with CodePipeline, there are specific scenarios
    that have already identified that CodePipeline is an optimal fit as a tool. Let's
    take a look at some of these next.
  prefs: []
  type: TYPE_NORMAL
- en: Automation of your build and release process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CodePipeline allows your developers to concentrate on the code they are working
    on and then commit that code to either an Amazon-hosted repository or a third-party
    repository such as GitHub or Bitbucket Cloud. The push of a new code commit by
    a developer can then trigger the build process.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a consistent toolset for developers to use
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most challenging parts of getting a new developer up and productive
    quickly in an organization is the onboarding process. CodePipeline helps with
    this process by presenting a consistent toolset no matter which time zone a team
    member is in or the operating system that they are using.
  prefs: []
  type: TYPE_NORMAL
- en: Using CodePipeline to integrate with third-party providers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose your team currently uses third-party tools such as Jenkins for the code
    build or testing process, BlazeMeter for the load testing process, or StormRunner
    for the testing process. In that case, CodePipeline can help present a unified
    orchestration front for all of these tools.
  prefs: []
  type: TYPE_NORMAL
- en: There can also be a cost-savings aspect in using only one service account called
    from the CodePipeline service rather than each individual or individual team requesting
    their own license.
  prefs: []
  type: TYPE_NORMAL
- en: Continuously deploy your web applications with Elastic Beanstalk and CodePipeline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although Elastic Beanstalk is many times looked upon as a service which helps
    developers who minimal exposure to AWS infrastructure items to get their code
    up and running quickly, those items of code can become successful items in an
    organization. The incorporation of CodePipeline allows to take the reliance away
    from the Elastic Beanstalk CLI or try to track down deployments in the AWS Management
    Console and allow for a more structured and trackable approach.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have examined a few of the various use cases where CodePipeline
    can be used successfully, we can now go on to our hands-on example. This is where
    we will go through the steps of setting up our own AWS CodePipeline that utilizes
    a CodeCommit repository.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a code pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the best ways to get a feel for AWS CodePipeline is to go through the
    exercise of setting up a code pipeline. Many times, it will be those designated
    tools' team members who will set up the pipelines. These **tools** team members
    have a unique set of permissions that differ from that of developers.
  prefs: []
  type: TYPE_NORMAL
- en: We will need to set up our tools team group and assign them the correct permission
    set. After this, we can create a tools team member and associate them with the
    tools team IAM group. Then, we can log in as that tools team member and have them
    build out the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our code base prior to setting up the pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to set up a brand new CodeCommit repository before setting up our
    code pipeline. Creating the repository beforehand will allow us to have a fresh
    set of code to use to run through the steps of our pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `chapter9` section of our GitHub repository, there will be a folder
    named `code`. This folder will hold the source code that we will need to upload
    to the CodeCommit repository we are about to create using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your browser to the AWS CodeCommit home page, [https://console.aws.amazon.com/codesuite/codecommit/home](https://console.aws.amazon.com/codesuite/codecommit/home),
    and sign in if prompted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the orange **Create repository** button on the top right-hand side of
    the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the `chapt9` for the name of the repository. We will add a description that
    this repository is for `CodePipeline` to distinguish it from the `chapt8` repository,
    which we created as a test in the previous chapter, [*Chapter 8*](B17405_08_Final_JM_ePub.xhtml#_idTextAnchor212),
    *Creating Workloads with CodeCommit and CodeBuild*, as illustrated in the following
    screenshot:![Figure 9.2 – CodeCommit repository settings for chapt9 repository
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.2_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.2 – CodeCommit repository settings for chapt9 repository
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the orange **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we have already created a user that can upload files in [*Chapter 8*](B17405_08_Final_JM_ePub.xhtml#_idTextAnchor212),
    *Creating Workloads with CodeCommit and CodeBuild*, simply click on the **Repositories**
    menu item in the left-hand menu, as illustrated in the following screenshot. This
    will bring up the names of all the repositories that we have in CodeCommit and
    will allow us to copy the link we need to clone the repository locally to our
    workstation:![Figure 9.3 – The side menu on CodeCommit with Repositories highlighted
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.3_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.3 – The side menu on CodeCommit with Repositories highlighted
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, click on the link labeled `SSH`, to the right of the `chapt9` repository,
    as illustrated in the following screenshot. This will pop up a small dialog box
    confirming that the link has been copied and you are ready to clone the repository
    to your local workstation:![Figure 9.4 – SSH cloning Uniform Resource Locator
    (URL) copied to clipboard
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.4_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.4 – SSH cloning Uniform Resource Locator (URL) copied to clipboard
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At this point, we are done with the AWS console for the moment, and we will
    move on for the next set of commands to the terminal on your local workstation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, with your terminal open, go to the root of your home directory. In Linux,
    you can get there quickly with the `$cd ~` command. Next, perform the following
    command to clone the repository locally. Now, we can use the URL on our clipboard
    to clone into the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once you have successfully cloned into the repository, then you should get a
    confirmation message stating that you have cloned into an empty repository.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Even though we have an empty repository, we are going to take the example code
    from the GitHub repository in the `/code` directory and then copy (or move it
    if you don't want two copies of the code on your local machine) to this new local
    `CodeCommit` repository so that we can push it up to `CodeCommit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure that you are starting from the directory where you have cloned the
    example code from GitHub, as illustrated in the following code snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you don't want to copy the files via the command line you could also use
    either File Explorer or Finder to make a copy of the files into your new git repository.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have copied the files over to the `CodeCommit` local directory,
    we need to add all of them to the commit. After adding them and the `commit` message,
    we will push the files up to the repository. We can do all of this in just a few
    simple commands. First, we will need to change directories from where we cloned
    the example code to our local `CodeCommit` repository, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we are in our local directory, we can now add all of the files and then
    push them up to the remote `CodeCommit` repository. We do this by using the `git
    add`, `git commit`, and `git push` commands, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, with our sample code ready, we are prepared to move on to the next step,
    which is creating our tools team member. Our tools team member is the person on
    our team who focuses on creating and managing the pipelines and processes more
    than the code itself.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our tools team member
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as we had previously created our development group and member, we will
    need to do the same thing for our tools team member. It is important to separate
    the duties of our team members and give each person only the privileges they need
    to perform their job duties. After creating our tools member, we will then log
    in as that tools teams member and then run the CloudFormation template named `pipeline1.yml`
    as this tools team member to construct the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and set up the group for our tools team member, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up your terminal and type the following commands so that we can create
    our new group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After running the command, you should see a confirmation like the one shown
    next:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Take note of the ARN which is returned for the group name. You will either need
    to save this to a note pad or scroll up to copy and paste this when we attach
    the policy which we create next to this group
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we will need to create our policy using the pre-made policy document
    that you should have downloaded from the GitHub repository in the `Chapter9` folder
    named `IAM_Tools.json`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"Policy": {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"PolicyName": "Tools_Members",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"PolicyId": "ANPAW24Q7QQF6FPOCHV5V",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"Arn": "arn:aws:iam::470066103307:policy/Tools_Members",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"Path": "/",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"DefaultVersionId": "v1",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"AttachmentCount": 0,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"PermissionsBoundaryUsageCount": 0,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"IsAttachable": true,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"CreateDate": "2021-05-16T19:32:41+00:00",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"UpdateDate": "2021-05-16T19:32:41+00:00"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After creating our policy, we will then attach our policy to our group, like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: --policy-arn arn:aws:iam::470066103307:policy/Tools_Members \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --group-name tools
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have created our `tools` group, we can create a user to be part
    of the tools team. This tools team member will be the user that we will use to
    create the actual code pipeline. Let''s go ahead and make our new user, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can take our new user and add them to the `tools` group so that they
    have the group permissions, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And just like the developer user we created in [*Chapter 8*](B17405_08_Final_JM_ePub.xhtml#_idTextAnchor212),
    *Creating Workloads with CodeCommit and CodeBuild*, we will need to set an initial
    password that the tools user will need to reset on the first login, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, we have created our tools user and are ready to log in to the
    AWS console as the tools user and build out our AWS pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our tools user (Peter, in our case) created, we will make a context switch
    from using the AWS CLI to the browser and the management console and act as if
    we were performing these acts as the tools user. Before we start, you need to
    be sure to download the `pipeline1.yml` file from the `Chapter9` folder in the
    GitHub repository for the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up a fresh web browser that doesn''t have cookies or a session
    attached so that we can log in to the AWS console as Peter. You may need to either
    open up an incognito window or a different browser than the one you have been
    using. For example, if you have been running the administrator in Chrome, then
    you would open up a new session in Firefox or Edge using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign in to the AWS console using your account number or account alias and the
    user's name, `peter`, and the `Dev0psPRO` password, as we created previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will instantly be prompted to change the password for the user `peter`.
    Change this password to anything you like, but either write it down or keep it
    something you can remember as you may need to access this user later. The process
    is shown in the following screenshot:![Figure 9.5 – Password change for tools
    user peter
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.5_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.5 – Password change for tools user peter
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you have changed the password, the AWS console will bring you to the main
    console page. Use the top unified search box to search for the **CloudFormation**
    service. Once the CloudFormation service appears, click on the service icon to
    be taken to the main CloudFormation page, as illustrated in the following screenshot:![Figure
    9.6 – CloudFormation service icon
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.6_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.6 – CloudFormation service icon
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once on the main **CloudFormation** service page, click the orange **Create
    stack** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the **Create stack** page, use the following options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. **Prepare stack**—Keep this selected on **Template is ready**
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. **Specify template**—Choose the checkbox that is labeled **Upload a template
    file**
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, click the `pipeline1.yml` file and open this file. Once this file has
    been selected, click the orange **Next** button at the bottom of the screen, as
    illustrated in the following screenshot:![Figure 9.7 – Creating a CodePipeline
    stack
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.7_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.7 – Creating a CodePipeline stack
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you click the `C9-demo` and your email address where you would like to
    receive notifications about the stack. You can leave this blank for the email
    address, or you can put in your own email address. If the branch you created was
    named `main`, then you do not need to make any changes; however, if the branch
    you created was named `master` as in our example, then you will need to change
    the default value in the `master` before moving on or the pipeline will not execute
    right away. Once you have filled in these values, click the orange **Next** button
    at the bottom of the screen, as illustrated in the following screenshot:![Figure
    9.8 – Adding values to the Specify stack details screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.8_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.8 – Adding values to the Specify stack details screen
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the **Configure stack options** screen, we will not be adding any tags. Simply
    go to the bottom of the page and click the orange **Next** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, on the **Review C9-demo** page, scroll down to the bottom of the page and
    check the box in the blue area that acknowledges that this stack will create an
    IAM role under the heading of **Capabilities**. After you have checked the box,
    you can press the orange button that is labeled **Create stack**, as illustrated
    in the following screenshot:![Figure 9.9 – Checking the acknowledgment in the
    Capabilities section on the review
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.9_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.9 – Checking the acknowledgment in the Capabilities section on the
    review
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once pressed, you will be taken to the `CREATE_IN_PROGRESS` until it has finished
    creating our code pipeline. Once the status has been completed, then we can move
    on to the next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the CloudFormation process completes, we will then be able to go back
    up to the unified search and search for the `CodePipeline` service. Once the icon
    for **CodePipeline** appears, as illustrated in the following screenshot, click
    on it to be taken to the current pipelines:![Figure 9.10 – CodePipeline from the
    unified search bar
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.10_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.10 – CodePipeline from the unified search bar
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You should see the pipeline that you just created, named `C9-demo`. Click on
    this name to view the details of the pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can see from the pipeline we created that we now have a pipeline created
    with three stages: **Source**, **Build**, and **Deploy**. There are integrated
    processes including manual approval processes on the deploy stage along with the
    CloudFormation creation..'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you failed to complete the previous exercise of creating the CodeCommit repository
    named `chapt9`, you would run into problems with the pipeline. This `chapt9` repository
    is the code source for our AWS code pipeline. If you named your repository something
    different, you would need to either modify the CloudFormation template or go into
    the AWS console and modify your source stage.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with our AWS code pipeline built, we can move forward with our developer
    testing a commit and seeing the stages of the pipeline in action, just as it would
    work in real life. Before we do that, however, we need to give our developer users
    more IAM permissions since when they were initially created, they only had permissions
    for CodeCommit and to modify their own password.
  prefs: []
  type: TYPE_NORMAL
- en: Updating our developer users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous chapter, [*Chapter 8*](B17405_08_Final_JM_ePub.xhtml#_idTextAnchor212),
    *Creating Workloads with CodeCommit and CodeBuild*, we created a group for developers.
    We gave them a scoped set of permissions that was limited to AWS CodeCommit and
    CodeBuild. Since we are now adding CodePipeline and CodeBuild to the mix, we will
    now have to expand their permissions so that they can use these services as well.
    In the GitHub `Chapter9` repository, there is a file named `IAM_Developers.json`—be
    sure to download this file so that you can update the permissions for your developer.
    While updating the commands, you will need to use your administrative user. We''ll
    proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Before you start to perform these commands, make sure that you have downloaded
    the `IAM_Developers.json` file from the `Chapter9` folder in the GitHub repository
    and are in the same directory where you downloaded the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we need to do is find the ARN of the policy attached to
    our developers. We created this policy in the exercise in [*Chapter 8*](B17405_08_Final_JM_ePub.xhtml#_idTextAnchor212),
    *Creating Workloads with CodeCommit and CodeBuild*. Log in to your terminal and
    run the following command to extract the ARN for the developer group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After we run this command, we should get a return of the current ARN being used
    for our Code Commit developers' group. This ARN is going to be needed in the following
    step so that we can update our policy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After we have the ARN, we can then create a new policy version and set that
    version as `default`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If this is successful, we will be returned a **JavaScript Object Notation**
    (**JSON**) message showing that we are now on the second version of our policy,
    as illustrated in the following code snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Updating our developer user group to allow for CodePipeline access permits the
    developers to see the pipelines previously created when running, along with any
    errors that may have been encountered during individual steps of the pipeline.
    These permissions have been scoped in such a manner so as not to allow developers
    to create or modify any new or existing pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: CodePipeline concepts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several basic concepts and terms to understand when using AWS CodePipeline,
    as depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – CodePipeline transition representation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.11_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.11 – CodePipeline transition representation
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the CodePipeline and stage requirements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you start to build pipelines, there are some rules and requirements that
    should be known as this can help you avoid headaches in trying to debug errors.
    Look through the list stated next for best practices as you build your AWS code
    pipelines along with the knowledge to remember during exam time:'
  prefs: []
  type: TYPE_NORMAL
- en: All stage names in a pipeline must be unique.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only the first stage in a pipeline can contain source actions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pipeline must have at least two stages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All actions within a single stage must be unique.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The input action of a stage must match the output action of the preceding stage
    exactly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output artifact names must be unique to a pipeline. If a stage has an output
    artifact named `TestPackage`, no other stage may have another output artifact
    named `TestPackage` in that pipeline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For all supported action types, the only valid owner strings are `AWS`, `ThirdParty`,
    or `Custom`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other more complex requirements; however, if you understand these
    requirements, then you have a solid foundation for using the CodePipeline service
    along with an understanding of the nuances of stages for the DevOps professional
    exam.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have looked at the stages as a whole in an AWS code pipeline, let''s
    look at one aspect that is not automated: approval actions.'
  prefs: []
  type: TYPE_NORMAL
- en: Approval actions in a code pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a code pipeline, there is an opportunity to pause between stages using approval
    actions. Approval actions allow for the manual review of an action before proceeding
    to the next stage of the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Actions that are approved by the reviewer move on to the next stage of the pipeline.
    If an approval is rejected, then the pipeline does not continue to the next stage.
    You also have 7 days to approve a pipeline action, or it will result in the pipeline
    failing.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few common reasons why you would use approval actions in an AWS
    code pipeline, outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To perform manual **Quality Assurance** (**QA**) testing before moving on to
    the next stage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To allow for a code review or change management review before proceeding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To allow for manual review of a web page before publishing to production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Jenkins to build your workloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The developer tools provided by AWS can give you just about all the functionality
    that you need without any extra configuration or setup. There are instances where
    teams have already built parts of their **Continuous Integration/Continuous Deployment**
    (**CI/CD**) process around existing tooling and may want to retain some of the
    work that they have already poured time and effort into refining.
  prefs: []
  type: TYPE_NORMAL
- en: Teams that use the Jenkins server can be one of those cases. Along with its
    vast ecosystem of plugins, Jenkins can provide an extreme amount of functionality
    in the CI/CD process.
  prefs: []
  type: TYPE_NORMAL
- en: Many teams use Jenkins for the build stage of the CI process since, in Jenkins,
    it can feel easier to build the steps in shell scripts without a need to create
    additional `buildspec` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts Jenkins being used in conjunction with CodePipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Using Jenkins in conjunction with CodePipeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.12_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.12 – Using Jenkins in conjunction with CodePipeline
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins itself has plugins that will work with many of the AWS services, including
    the developers' suite of services.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at the CodePipeline service, including how to incorporate
    third-party tools such as the Jenkins build server, let's look at how we can use
    AWS CodeDeploy to deploy our workloads either by themselves or as part of a pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: About AWS CodeDeploy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS CodeDeploy is a service that assists in automating deployments of application
    code and files to EC2 instances, on-premises servers, Lambda functions, and containers
    running on AWS ECS.
  prefs: []
  type: TYPE_NORMAL
- en: 'CodeDeploy is a service that makes the following things easier:'
  prefs: []
  type: TYPE_NORMAL
- en: Update Lambda functions and create new versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid downtime during application deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swiftly release new features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promptly roll back to a known good version in case of deployment failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AWS CodeDeploy is focused on the following three platforms for deployments:'
  prefs: []
  type: TYPE_NORMAL
- en: EC2/on-premises instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECS containerized applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using these three platforms as a basis, you describe your deployments in a file
    named `appspec`. This file can be written in either JSON or **YAML Ain't Markup
    Language** (**YAML**) format.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple types of files and components that CodeDeploy can distribute,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Executables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multimedia files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a grasp of the basics of CodeDeploy, let's look at the basic
    concepts we need to understand when using the CodeDeploy service.
  prefs: []
  type: TYPE_NORMAL
- en: Basic CodeDeploy concepts to understand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we start to employ the CodeDeploy service, there are some components that
    should be understood first and foremost.
  prefs: []
  type: TYPE_NORMAL
- en: Application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a name that is unique, and CodeDeploy uses it to identify the application
    which you want to deploy. It uses this unique name to make sure that the correct
    version of deployment, deployment group, revision, or rollback is referenced during
    a particular deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Compute platform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the actual platform where CodeDeploy deploys an application. There are
    quite a few choices for CodeDeploy deployments. Deployments can happen to EC2
    instances or on-premises servers as long as they meet operating system requirements.
    These deployments can consist of configuration files, images, and executable files,
    along with other types of files.
  prefs: []
  type: TYPE_NORMAL
- en: CodeDeploy can also be used to update Lambda functions. CodeDeploy also has
    the ability to shift traffic from one version of a Lambda function to a newer
    function in a multitude of deployment options, including **canary**, **linear**,
    and **all-at-once** deployments.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using containers on the ECS platform, then CodeDeploy can be used
    to update the tasks using a **blue/green deployment** strategy by first installing
    a new version of the task set and then shifting the traffic over to the latest
    version of the task set. As with Lambda deployments, these deployments can be
    done in a canary, linear, or all-at-once fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using a set of success or failure criteria along with deployment rules, CodeDeploy
    is guided by a deployment configuration for each deployment. Inside of the deployment
    configuration, especially in the case of EC2 or on-premises deployments, you can
    set the minimum number of healthy instances that need to succeed for the deployment
    to be a success. If you are targeting either a Lambda application or ECS tasks,
    then your deployment configuration can specify how the traffic is routed during
    the deployment. The following deployments are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Canary**: Traffic is shifted in two separate increments, and you have the
    ability to specify the percentage of the traffic shifted initially before the
    rest of the traffic is shifted at a time specified in minutes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linear**: Traffic is shifted in equal increments. You have predefined options
    for percentages that can be shifted and for the intervals between shifts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**All-at-once**: All the traffic is shifted from the original Lambda function
    or ECS task at the same time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Deployment groups pertain to EC2 instances, either individually or in **Auto
    Scaling Groups** (**ASGs**), and are explicitly tagged for targeting a deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment groups can be as straightforward as using a single tag to designate
    the deployment group, or you can become elaborate as using up to 10 different
    tags in a deployment group.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The deployment type is the technique used by CodeDeploy to place the most up-to-date
    version of an application into a deployment group. There are two different types
    of deployment types: **in-place** and **blue/green**.'
  prefs: []
  type: TYPE_NORMAL
- en: With in-place deployments, although possibly more cost-effective, the application
    on the current instances in the deployment group is stopped while the latest version
    of the application is installed. The new version of the application is restarted
    and then validated. In-place deployments are only available for EC2 instances
    or on-premises deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Blue/green deployments provision a new set of resources. This can consist of
    creating a new version of a Lambda function, a new task set in the case of ECS,
    or a whole new instance in the case of EC2\.
  prefs: []
  type: TYPE_NORMAL
- en: Blue/green deployments do not work with on-premises deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Revision
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A revision for an AWS Lambda deployment is either a file in YAML or JSON format
    that states information about the Lambda function to deploy. Revisions for Lambda
    are stored in an S3 bucket.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of an EC2 or on-premises deployment revision, this is not just one
    file but a collection of files that contain the components (such as web pages,
    executable files, source code, and deployment scripts) along with a specification
    for the application, which is then packaged up into archive format. Revisions
    for EC2 or on-premises instances can be stored in an S3 bucket or GitHub repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Target revision
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the most recent version of an application that has been uploaded to
    the code repository, which is going to be targeted for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the CodeDeploy agent file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using CodeDeploy with EC2 instances, an agent file is placed on those instances,
    making it viable for the instance to achieve deployments from the CodeDeploy service.
    A configuration file is also placed on the instance with an agent, and this file
    specifies how the agent will work. These instances not only have to be in the
    AWS cloud but can also be on a specific operating system of an on-premises data
    center.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a glance at the following lists to see which operating systems have been
    tested using the AWS CodeDeploy agent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 9.2 – Tested operating systems to use the AWS CodeDeploy agent'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/021.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9.2 – Tested operating systems to use the AWS CodeDeploy agent
  prefs: []
  type: TYPE_NORMAL
- en: Any EC2 instance that you wish to use with CodeDeploy will also need to have
    a service role attached that gives it enough permissions so that the CodeDeploy
    service can perform its duties.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the appspec file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The application specification file, or `appspec` file, as it is most commonly
    called, is a YAML file in the majority of cases (although it may be formatted
    in JSON format) that has a specific number of sections along with some optional
    sections depending on which type of deployment you are trying to perform.
  prefs: []
  type: TYPE_NORMAL
- en: The `appspec` file details the deployment actions that you want to take during
    the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: There are different types of `appspec` files if you are doing an ECS deployment
    for containers, for EC2, or on-premises instances, and then if you are trying
    to deploy to Lambda instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example `appspec` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Important items to note in our example `appspec` file are the version, the resources,
    and the hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment rollbacks and content redeployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AWS CodeDeploy can roll back a deployment that has either been stopped manually
    or that has failed during the deployment process. Properly speaking, these rollbacks
    are new deployments and receive new deployment **identifiers** (**IDs**). The
    rollbacks do restore previous versions of a set of code. There are two different
    ways that rollbacks can happen, via automated rollbacks or via a manual process.
  prefs: []
  type: TYPE_NORMAL
- en: Automated rollbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your deployment group can be configured to automatically roll back either on
    failure during a deployment or if certain monitoring thresholds are met during
    a deployment. If one of these limits has been set and then triggered during the
    deployment for a case of automated rollback, then the deployment will go back
    to the last known good configuration.
  prefs: []
  type: TYPE_NORMAL
- en: You may also choose to override the automated rollback option if it has previously
    been put in place when starting a new deployment by configuring one of the advanced
    configuration options for the deployment group.
  prefs: []
  type: TYPE_NORMAL
- en: Manual rollbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even if you have not set up your deployment to roll back automatically, using
    AWS CodeDeploy, you can push out a previous version of a deployment. This would
    create a new deployment version. You could do this if your deployment failed or
    if your instances have got into an unknown state, and they might be fixed by pushing
    updates to the application and configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Rollback and redeployment workflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a rollback has been induced either automatically or manually, then CodeDeploy
    will start to try to remove all of the files that were successfully installed
    during the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: The cleanup file, if it exists, is a type of log file that CodeDeploy keeps
    so that it knows which files have been installed and can remove these files before
    starting a new deployment.
  prefs: []
  type: TYPE_NORMAL
- en: During deployment, the CodeDeploy agent will write out the filenames that are
    being deployed so that it has a record in case a rollback is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a rollback, CodeDeploy will refer to the cleanup file so that
    it knows which files to remove. It can then proceed with the previous version
    of the deployment in case of automatic rollback.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing now how deployments and rollbacks work, let's take a look at some of
    the use cases for AWS CodeDeploy.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases for AWS CodeDeploy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have looked at the AWS CodeDeploy service, let's think about some of the
    situations where this service would serve us best.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying application updates to servers in an on-premises data center
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are running a compatible operating system on your on-premises hardware,
    then you use AWS CodeDeploy to coordinate the deployments as well as have a single
    pane of glass to see successes and failures. Installing the AWS CodeDeploy agent
    is a required prerequisite. These operating systems include Windows Server, Ubuntu
    Server, or RHEL.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying application updates to Windows or Linux servers in the AWS cloud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are deploying to an NGINX or Apache server on a Linux EC2 instance or
    an **Internet Information Services** (**IIS**) instance on a Windows server, then
    you can use the CodeDeploy agent to choreograph the placement of files and restart
    any necessary services needed to update files on these instances.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying application updates to multiple regions with one deployment push
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you are looking for a way to build a solution that will create an automated
    **End-to-End** (**E2E**) release flow for deployments in multiple regions, then
    AWS CodeDeploy can help do this with help from AWS CodePipeline. This is especially
    true in the case of trying to keep Lambda deployments in sync for either **High-Availability**
    (**HA**) purposes or a **Disaster Recovery** (**DR**) strategy. In the following
    diagram, you can see CodeDeploy being used to deploy to multiple regions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Using CodePipeline and CodeDeploy to deploy to multiple regions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.13_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.13 – Using CodePipeline and CodeDeploy to deploy to multiple regions
  prefs: []
  type: TYPE_NORMAL
- en: Using S3 as the origin for the source code will kick off the deployment via
    the AWS code pipeline. If the pipeline is successful, then it will move on to
    an invoke stage where a Lambda function will copy the source code to an S3 bucket
    in the replicated region.
  prefs: []
  type: TYPE_NORMAL
- en: This replication of the source code to the S3 bucket in the **B** region will
    start the process again on another pipeline that has been set up in the second
    region.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a new task to ECS in blue/green fashion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CodeDeploy can give you the ability to seamlessly switch between task sets
    that are behind a network or application load balancer. It does this by deploying
    the new version of the task set and then switching the listener to the new version
    at the load balancer level, as illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Blue/green deployment using CodeDeploy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.14_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.14 – Blue/green deployment using CodeDeploy
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We will go more in-depth into blue/green deployments in [*Chapter 13*](B17405_13_Final_JM_ePub.xhtml#_idTextAnchor338),
    *Blue Green Deployments*.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a task to Amazon ECS and using Lambda to validate before switching
    traffic over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the use of CodeDeploy deployment groups, along with the assistance of a
    Lambda function, you can create a test to ensure that your new task is up and
    running successfully. This Lambda function can be specified in the deployment
    `appspec` file, and if the validation fails, then the deployment is stopped and
    rolled back. If the validation succeeds, then the deployment continues.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring CodeDeploy jobs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whether your CodeDeploy jobs are running standalone with the CodeDeploy service
    or as part of a deployment pipeline, monitoring their status and being notified
    promptly when there is a failure can be critical for solving issues in a timely
    fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Partnering CodeDeploy with the monitoring abilities of CloudWatch allows you
    to monitor specific metrics during deployments. Using these metrics, you can create
    CloudWatch alarms. Up to 10 CloudWatch alarms can be associated with a CodeDeploy
    deployment group. Triggering any one of the alarms will cause the deployment to
    stop and the status of the deployment to be reflected as `Stopped`. In order to
    monitor CodeDeploy with the CloudWatch service, you must grant your CodeDeploy
    service role permissions to use the CloudWatch service.
  prefs: []
  type: TYPE_NORMAL
- en: 'CloudWatch events can be used to help not only detect but also react to failures
    of CodeDeploy jobs based on rules that you create. Once these rules are created,
    CloudWatch events will initiate actions on specific targets. The following targets
    will work from CloudWatch events with rules from CodeDeploy jobs:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS **Lambda** functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kinesis streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon **Simple Queue Service** (**SQS**) queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CloudWatch** alarm actions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon **Simple Notification Service** (**SNS**) topics (and notifications)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CodeDeploy monitoring use cases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your team uses Slack as a communication channel, then you can integrate a
    Slack notification via a Lambda function whenever a CodeDeploy deployment fails.
  prefs: []
  type: TYPE_NORMAL
- en: CloudWatch alarm actions can be used to programmatically reboot, stop, or terminate
    EC2 instances if a specific event occurs during deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at the abilities to monitor our CodeDeploy deployments,
    let's recap what we have learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the other pieces of the AWS developer tools we
    are going to cover in depth in this book. We learned about deploying our software
    to different environments, both in the cloud and on-premises, using AWS CodeDeploy.
    We examined how CodeDeploy can be used to not only push out new versions of an
    application but also to control traffic during deployments. We also studied the
    AWS CodePipeline orchestration tool and how it as a service can incorporate not
    only all of the other three services we have been looking at from a development
    perspective but also other third-party partner tools as well.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the AWS OpsWorks service and how this can
    be helpful for managing infrastructure and application services using stacks,
    especially if your team members are well versed in Chef or Puppet.
  prefs: []
  type: TYPE_NORMAL
- en: Review questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the team of developers at a company has made multiple deployments. The
    last deployment with overwrite content failed. You have been tasked with rolling
    back to the previously working version with all the files necessary for the application.
    Which option would you choose to fulfill this requirement in the most expedient
    way possible?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Manually roll back to the last known application version, which will add
    files required for application revision.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Manually roll back to the previous deployment and then manually add files
    for the application revision.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. Automatically roll back to the last known version, which will add files required
    for application revision.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Automatically roll back to the last known application version and manually
    add files for application revision.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You have constructed an AWS code pipeline that carries out a code release process.
    There are two stages to this pipeline: a source stage and a deploy stage. The
    source stage is using the third-party provider GitHub to source the code for the
    deployments. AWS CodeDeploy is being used to deploy the new versions of the application
    to multiple EC2 instances in a target group. The last few deployments have not
    gone successfully, and failures appear during the CodeDeploy stage. You need the
    ability to increase monitoring and notifications for deployments in order to cut
    down your Mean Time to Resolution (MTTR). How can you create notifications as
    soon as an issue is detected?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Set up CloudWatch events for both CodeDeploy and CodePipeline. Use Amazon
    Inspector to create an assessment target to assess code deployment issues and
    create an SNS topic so that you can be notified of deployment issues.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Set up CloudWatch events for both CodeDeploy and CodePipeline. Use an AWS
    Lambda function to help assess code deployment issues and create an SNS topic
    so that you can be notified of deployment issues.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. Set up a new AWS CloudTrail trail for the region that the pipeline is running
    in. Use AWS Config to assess any code deployment issues and create an SNS topic
    so that you can be notified of any deployment issues.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Set up a new AWS CloudTrail to capture API events from CodeDeploy and CodePipeline.
    Use an AWS Lambda function to help assess code deployment issues and create an
    SNS topic so that you can be notified of deployment issues.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Review answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
