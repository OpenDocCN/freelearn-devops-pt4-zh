<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer183">
			<h1 id="_idParaDest-299"><a id="_idTextAnchor307"/>Chapter 12: Lambda Deployments and Versioning</h1>
			<p>As more and more application architectures go serverless and more and more cloud budgets are scrutinized, AWS Lambda becomes more and more of a viable option in both the Developer and Operations professions' tool belts. Knowing how to harness the flexibility and power of Lambda and Step functions is key to success in today's AWS environments.</p>
			<p>In this chapter, we're going to cover the following main topics:  </p>
			<ul>
				<li>AWS Lambda overview</li>
				<li>Lambda functions</li>
				<li>Lambda triggers and event source mappings </li>
				<li>Deploying versions using Lambda</li>
				<li>Working with Lambda layers </li>
				<li>Monitoring Lambda functions</li>
				<li>Optimal Lambda use cases and anti-patterns</li>
				<li>Orchestrating Step Functions with Lambda</li>
			</ul>
			<h1 id="_idParaDest-300"><a id="_idTextAnchor308"/>Technical requirements</h1>
			<p>As in the previous chapters, we will be using the Python programming language to create our Lambda functions. Basic working knowledge of Python is suggested to follow the examples and debug and troubleshoot if necessary.</p>
			<h1 id="_idParaDest-301"><a id="_idTextAnchor309"/>AWS Lambda overview </h1>
			<p>AWS Lambda is a service that allows you to run your code as a function, without the need to stand up any servers or provision or orchestrate containers. It automatically scales to the <a id="_idIndexMarker1098"/>number of requests that it receives. One of the most attractive items about Lambda functions is that they are only charged for the time they run. This means that you can have your platform provisioned in one or multiple regions, waiting for requests, without worrying how much the bill will accumulate from idle resources. </p>
			<p>Lambda lets you concentrate on the code instead of servers as it is a serverless Platform as a Service offering. Being a PaaS also means that you have no access to the underlying compute platform to make adjustments other than those that AWS exposes to you, such as the runtime (programming language) or your environment, the amount of memory that your function needs to use, and the amount of CPU allocate<a id="_idTextAnchor310"/>d: </p>
			<div>
				<div id="_idContainer172" class="IMG---Figure">
					<img src="Images/Figure_12.1_B17405.jpg" alt="Figure 12.1 – Lambda architecture with triggers &#13;&#10;" width="700" height="377"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.1 – Lambda architecture with triggers </p>
			<p>Many Lambda functions are events that are triggered by other AWS services. This is another fact that makes the service so appealing. Lambda functions can be used to do backend processing based on S3 bucket events. Then, you can put them into a decoupled <a id="_idIndexMarker1099"/>architecture <a id="_idIndexMarker1100"/>using a message queue, such as <strong class="bold">Simple Queue Service</strong> or <strong class="bold">Amazon MQ</strong>, for processing by one or more concurrent Lambda functions to put the data into a backend data store. </p>
			<p>The data can then be retrieved using either RESTful calls from a service such as <strong class="bold">API Gateway</strong> by utilizing GraphQL with <strong class="bold">AppSync</strong>. </p>
			<h2 id="_idParaDest-302"><a id="_idTextAnchor311"/>Serverless instead of servers </h2>
			<p>The term <strong class="bold">serverless</strong> should instantly bring a few critical thoughts to mind. In the world of AWS, this boils down to four fundamental principles:</p>
			<ul>
				<li><strong class="bold">There are no servers to provision</strong>: There should be no actual servers or instances to configure or maintain. There should also be no container orchestration needed on your part. </li>
				<li><strong class="bold">The system and architecture scale with usage</strong>: As requests, data, or events come in, the underlying platform and infrastructure should automatically scale out and scale in to meet the necessary demand. </li>
				<li><strong class="bold">You pay for value</strong>: Resources that are sitting idle, waiting to be used, should not incur charges. Charges should only occur when the resources are actively being utilized. </li>
				<li><strong class="bold">The system is built for availability and fault tolerance</strong>: Once you're launching your platform, it should automatically span multiple availability zones, increasing your availability and fault tolerance.</li>
			</ul>
			<p>As you talk to people who have used a serverless platform in the real world, they feel like they have derived numerous benefits from making the switch. One such benefit is <strong class="bold">greater agility</strong> and the ability to move faster since they are not spending as much time setting up and provisioning infrastructure. Separating themselves from dealing with instance and container configuration allows them to <strong class="bold">better focus</strong> on their business and the features that their customers want and find valuable. They also feel as though they have <strong class="bold">increased scale</strong> compared to the previous capacity that customers used to have in their data centers. This is because Lambda will scale up automatically based on the number of invocations to a particular function. </p>
			<h2 id="_idParaDest-303"><a id="_idTextAnchor312"/>Synchronous versus asynchronous invocation</h2>
			<p>When you invoke a Lambda function, it can be done in one of two ways: either synchronously or asynchronously. </p>
			<p>Lambda <a id="_idIndexMarker1101"/>will run the function on a synchronous invocation, wait for the response, and then return the response code with any data included in the function's return call. You can <a id="_idIndexMarker1102"/>use the <strong class="source-inline">invoke</strong> command <a id="_idIndexMarker1103"/>from the AWS CLI to invoke a function synchronously.  </p>
			<p>With asynchronous invocations, you are pushing the event to Lambda but not waiting for an immediate response. Lambda will queue up the events before sending them to the function: </p>
			<div>
				<div id="_idContainer173" class="IMG---Figure">
					<img src="Images/Figure_12.2_B17405.jpg" alt="Figure 12.2 – Asynchronous invocation in Lambda &#13;&#10;" width="518" height="126"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.2 – Asynchronous invocation in Lambda </p>
			<p>Lambda manages the functions event queue and, upon receiving an error, will attempt to retry the event. If it fails, it will try twice more with a longer time in-between each additional attempt. </p>
			<p>Now that we have taken an initial look at how we can invoke a Lambda function, let's take a deeper look at Lambda functions themselves.</p>
			<h1 id="_idParaDest-304"><a id="_idTextAnchor313"/>Lambda functions </h1>
			<p>The code you <a id="_idIndexMarker1104"/>write becomes the function that runs without the need for provisioning or managing any servers. The function itself is the resource and can take in events that have been passed to it, either by you or other AWS services. </p>
			<p>You can use a few different languages that are supported to create your Lambda functions. These <a id="_idIndexMarker1105"/>include Python, Node.js, Ruby, Java, Go, and .NET. You can even create custom runtimes by using containers. </p>
			<h2 id="_idParaDest-305"><a id="_idTextAnchor314"/>The basic concepts of Lambda</h2>
			<p>When you start a <a id="_idIndexMarker1106"/>Lambda function, that process is called <strong class="bold">invoking</strong> the function. Lambda functions <a id="_idIndexMarker1107"/>process events. Events are sent to your functions in a few different ways: you can manually invoke the function, such as with a test event, or you can configure an AWS resource or service to invoke it and start the process. </p>
			<p>Since we're talking about Lambda functions, there are a few key concepts that need to be understood. </p>
			<h3>Function</h3>
			<p>A function is the <a id="_idIndexMarker1108"/>code where you process your events. It is what is invoked when you call the Lambda process, either by an event, schedule, or manually. </p>
			<h3>Qualifier </h3>
			<p>Lambda functions can have versions and aliases. Once a version has been created, it is a fixed version of <a id="_idIndexMarker1109"/>the code and contains a numerical qualifier at the end. Although the <strong class="source-inline">$LATEST</strong> version of your Lambda code is the one that you can constantly be updating, if you wanted to call that version that you snapshotted in time, such as <strong class="source-inline">test-function:1</strong>, you would need to append the version number to the end.  </p>
			<h3>Runtime </h3>
			<p>The runtime in <a id="_idIndexMarker1110"/>Lambda allows you to choose the language, along with the language version, that your function will execute. This runtime is not contained within the function itself; instead, it sits between the Lambda service and the function code. Not only can you use the runtimes that the Lambda service provides, but you can also build your own if there is a language and version that you desire that the service itself does not support. </p>
			<h3>Event </h3>
			<p>An event in Lambda is a JSON document that consists of data for the function to process. Events can <a id="_idIndexMarker1111"/>be simple and single-tiered, as shown in the following example:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "URL": https://packtpub.com</p>
			<p class="source-code">}</p>
			<p>They can be also complex, coming from AWS services with nested keys and values that require complex parsing. These complex events can hold valuable data that can automate processes and make your life, as a DevOps professional, easier if you learn how to harness their power. </p>
			<h2 id="_idParaDest-306"><a id="_idTextAnchor315"/>The Lambda handler</h2>
			<p>A handler can <a id="_idIndexMarker1112"/>be any name, but the default name, especially when creating a function in the AWS Console, is <strong class="source-inline">Lambda_function.Lambda_handler</strong>: </p>
			<p class="source-code">def Lambda_handler(event, context):</p>
			<p class="source-code">  greeting = 'I am a DevOps Pro and my name is {} {}'.format(event['firstname'], event['lastname'])</p>
			<p class="source-code">  print(message)</p>
			<p class="source-code">  return {</p>
			<p class="source-code">    'greeting': greeting</p>
			<p class="source-code">}</p>
			<p>In our example Lambda code, we can see two arguments being passed to the Lambda handler: the event and the context.</p>
			<p>The <strong class="source-inline">event</strong> argument is a JSON formatted document that includes the data for the Lambda function to process. While it is often a dictionary object, it can also be a list, string, integer, or floating-point number. </p>
			<p>Using a combination of the event handler and a parser, you can grab information about which specific resources invoked the Lambda function and then perform the necessary actions from there. By using <strong class="source-inline">returns</strong>, such as the greeting in the simple example shown previously, you can call other methods inside your function based on the information you find. You could <a id="_idIndexMarker1113"/>even have the entire function return a value. This is especially useful in the case of <strong class="bold">Step Functions</strong>, which we will look at later in this chapter. </p>
			<p>The <strong class="source-inline">context</strong> argument is passed to the Lambda function at runtime. This argument contains information regarding the invocation, the runtime environment, and the function itself. </p>
			<h2 id="_idParaDest-307"><a id="_idTextAnchor316"/>Limits of Lambda </h2>
			<p>As you go about creating your Lambda functions, it's helpful to understand some of the constraints <a id="_idIndexMarker1114"/>that the Lambda service has put into place. The minimum amount of memory for a function is 128 MB, while the maximum is 3,008 MB. The longest execution time allowed for a Lambda function is 15 minutes or 900 seconds. You can only have a maximum of 4 KB in environment variables. There is a concurrency limit of 1,000 concurrent executions per function. If you are extracting data or using the <strong class="source-inline">/tmp</strong> disk space, you have a limit of 512 MB. </p>
			<h2 id="_idParaDest-308"><a id="_idTextAnchor317"/>Creating a Lambda function</h2>
			<p>With an understanding of how Lambda functions work, we will now start creating our Lambda function. The function that we will create will take a URL that's been passed to it and then <a id="_idIndexMarker1115"/>count the number of words on the web page. Since we will need external packages, we will need to create a ZIP package first and then upload that to the Lambda service. </p>
			<p>There are times when you can just write a simple function in the AWS Management Console itself using the built-in editor in the Lambda service. This includes the Python language and the <strong class="source-inline">boto</strong> and <strong class="source-inline">botocore</strong> modules, which allow you to take advantage of the Python <strong class="bold">software development kit</strong> (<strong class="bold">SDK</strong>). There are also helpful modules that you would <a id="_idIndexMarker1116"/>not have to download, such as <strong class="source-inline">random</strong> to help you generate random numbers and values, <strong class="source-inline">OS</strong> to allow you to call operating system functionality, and <strong class="source-inline">math</strong>, <strong class="source-inline">gzip</strong>, and <strong class="source-inline">logging</strong>, along with quite a few others. </p>
			<p>Follow these steps to build our Lambda package so that it can be uploaded: </p>
			<ol>
				<li>Let's start by opening our terminal and creating a role for our Lambda function to use. With our terminal open, we will navigate to the beginning of our directory and then create a new directory for our Lambda. Once created, go into that directory:<p class="source-code"><strong class="bold">$ cd ~/</strong></p><p class="source-code"><strong class="bold">$ mkdir my-wc-function</strong></p><p class="source-code"><strong class="bold">$ cd my-wc-function</strong></p></li>
				<li>We will <a id="_idIndexMarker1117"/>use the following JSON saved to a file named <strong class="source-inline">Lambda-role-policy.json</strong>; you can also find this file in the <strong class="source-inline">Chapter-12</strong> folder of the GitHub repository for this book:<p class="source-code"><strong class="bold">{</strong></p><p class="source-code"><strong class="bold">    "Version": "2012-10-17",</strong></p><p class="source-code"><strong class="bold">    "Statement": [</strong></p><p class="source-code"><strong class="bold">        { "Effect": "Allow",</strong></p><p class="source-code"><strong class="bold">          "Principal": {</strong></p><p class="source-code"><strong class="bold">              "Service": "Lambda.amazonaws.com"</strong></p><p class="source-code"><strong class="bold">              }, </strong></p><p class="source-code"><strong class="bold">          "Action": "sts:AssumeRole"</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code"><strong class="bold">    ]</strong></p><p class="source-code"><strong class="bold">}</strong></p></li>
				<li>Use this file in the following command to create the role that our Lambda function will use:<p class="source-code"><strong class="bold">$ aws iam create-role --role-name Lambda-12 --assume-role-policy-document file://Lambda-role-policy.json</strong></p></li>
				<li>This should come back with a JSON return showing the successful creation of the role, similar <a id="_idIndexMarker1118"/>to the following output: <p class="source-code"><strong class="bold">{</strong></p><p class="source-code"><strong class="bold">    "Role": {</strong></p><p class="source-code"><strong class="bold">        "Path": "/",</strong></p><p class="source-code"><strong class="bold">        "RoleName": "Lambda-12",</strong></p><p class="source-code"><strong class="bold">        "RoleId": "AROAW24Q7QQF5NLSQX3L5",</strong></p><p class="source-code"><strong class="bold">        "Arn": "arn:aws:iam::470066103307:role/Lambda-12",</strong></p><p class="source-code"><strong class="bold">        "CreateDate": "2021-06-15T01:06:06+00:00",</strong></p><p class="source-code"><strong class="bold">        "AssumeRolePolicyDocument": {</strong></p><p class="source-code"><strong class="bold">            "Version": "2012-10-17",</strong></p><p class="source-code"><strong class="bold">            "Statement": [</strong></p><p class="source-code"><strong class="bold">                {</strong></p><p class="source-code"><strong class="bold">                    "Effect": "Allow",</strong></p><p class="source-code"><strong class="bold">                    "Principal": {</strong></p><p class="source-code"><strong class="bold">                        "Service": "Lambda.amazonaws.com"</strong></p><p class="source-code"><strong class="bold">                    },</strong></p><p class="source-code"><strong class="bold">                    "Action": "sts:AssumeRole"</strong></p><p class="source-code"><strong class="bold">                }</strong></p><p class="source-code"><strong class="bold">            ]</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code"><strong class="bold">}</strong></p></li>
				<li>Our role has now been created for our Lambda to use; however, it cannot do much since there is currently no policy attached. Instead of writing a custom policy, we will use a predefined AWS policy created for Lambdas: <p class="source-code"><strong class="bold">$ aws iam attach-role-policy --role-name Lambda-12 --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole</strong></p></li>
				<li>With our role created and ready to use, let's remove the current file in the directory <a id="_idIndexMarker1119"/>so that it doesn't get deployed with our <strong class="source-inline">zip</strong> package later. We are going to use the <strong class="source-inline">remove</strong> command for the file. However, if you would like to save it, I would suggest using the <strong class="source-inline">copy</strong> or <strong class="source-inline">move</strong> command to your <strong class="source-inline">/tmp</strong> directory or <strong class="source-inline">Downloads</strong> so that you can access it later:<p class="source-code"><strong class="bold">$ rm Lambda-role-policy.json</strong></p></li>
				<li>Now, we will create a new file called <strong class="source-inline">Lambda_function.py</strong>. In this function, we will cut and paste (or type, if you're brave) the following code. Alternatively, once again, you can find the full file in the <strong class="source-inline">Chapter-12</strong> directory of this book's GitHub repository: <p class="source-code"><strong class="bold">import requests</strong></p><p class="source-code"><strong class="bold">from bs4 import BeautifulSoup</strong></p><p class="source-code"><strong class="bold">from collections import Counter </strong></p><p class="source-code"><strong class="bold">from string import punctuation # already included in Lambda modules </strong></p><p class="source-code"><strong class="bold">def Lambda_handler(event, context):</strong></p><p class="source-code"><strong class="bold"># get the URL from the event </strong></p><p class="source-code"><strong class="bold">  r = requests.get("https://aws.amazon.com/blogs/compute/using-Lambda-layers-to-simplify-your-development-process/") #demo </strong></p><p class="source-code"><strong class="bold">  bs = BeautifulSoup(r.content)</strong></p><p class="source-code"><strong class="bold">  # gather all the words within the paragraphs </strong></p><p class="source-code"><strong class="bold">  p_txt = (''.join(s.findAll(text=True))for s in bs.findAll('p'))</strong></p><p class="source-code"><strong class="bold">  count_p = Counter((x.rstrip(punctuation).lower() for y in p_txt for x in y.split()))</strong></p><p class="source-code"><strong class="bold">  # gather all the text in the divs </strong></p><p class="source-code"><strong class="bold">  d_txt = (''.join(s.findAll(text=True))for s in soup.findAll('div'))</strong></p><p class="source-code"><strong class="bold">  count_div = Counter((x.rstrip(punctuation).lower() for y in d_txt for x in y.split()))</strong></p><p class="source-code"><strong class="bold">  # create a sum total of the words </strong></p><p class="source-code"><strong class="bold">  word_sum = p_txt + d_txt</strong></p><p class="source-code"><strong class="bold">  # return the number of words </strong></p><p class="source-code"><strong class="bold">  return word_sum</strong></p></li>
				<li>Now, the <a id="_idIndexMarker1120"/>directory structure of your <strong class="source-inline">my-wc-function</strong> directory should look like this:<p class="source-code"><strong class="bold">my-wc-function$</strong></p><p class="source-code"><strong class="bold">| Lambda_function.py</strong></p></li>
				<li>At this <a id="_idIndexMarker1121"/>point, we can start installing our dependent modules locally using the <strong class="bold">Python package installer</strong>, <strong class="bold">PIP</strong>, along with an extra flag called <strong class="source-inline">–target</strong>:<p class="source-code"><strong class="bold">:pip install --target ./package requests</strong></p><p class="source-code"><strong class="bold">pip install --target ./package bs4</strong></p></li>
				<li>Now, let's make the deployment package. First, we will navigate into the <strong class="source-inline">package</strong> directory that we just created and then create the initial <strong class="source-inline">zip</strong> file. Take note of the two dots in the <strong class="source-inline">zip</strong> command; these are telling the <strong class="source-inline">zip</strong> file to be created in the directory and not in the <strong class="source-inline">package</strong> directory:<p class="source-code"><strong class="bold">$ cd package</strong></p><p class="source-code"><strong class="bold">$ zip -r ../my-wc-package.zip .</strong></p></li>
				<li>With our initial <strong class="source-inline">zip</strong> file created, we can add our Python file to the <strong class="source-inline">zip</strong> file: <p class="source-code"><strong class="bold">$ cd ../</strong></p><p class="source-code"><strong class="bold">$ zip -g my-wc-package.zip Lambda_function.py</strong></p></li>
				<li>After running this command, you should see that the <strong class="source-inline">Lambda_function.py</strong> file has been added to the previously created <strong class="source-inline">zip</strong> package. </li>
				<li>We now <a id="_idIndexMarker1122"/>have our deployment package created and are ready to move on to the AWS Management Console so that we can upload and test our function. This could all be continued from the CLI, but the console has some features that aren't available from the CLI. </li>
				<li>Open your web browser and navigate to the Lambda service after logging in using your administrative account. You can get to the service directly by going to the <a href="https://console.aws.amazon.com/lambda">https://console.aws.amazon.com/Lambda</a>.</li>
				<li>Find and click on the orange <strong class="bold">Create function</strong> button near the top right-hand side of the main screen. </li>
				<li>Once you're on the <strong class="bold">Create function</strong> screen, make sure that the <strong class="bold">Author from Scratch</strong> value is selected for creating your function. Under the <strong class="bold">Basic Information</strong> section, use the following values:<ul><li><strong class="bold">Function name</strong>: <strong class="source-inline">my-word-count_python</strong>.</li><li><strong class="bold">Runtime</strong>:  <strong class="source-inline">python 3.8</strong>.</li><li><strong class="bold">Permissions</strong>: You will need to click on the <strong class="bold">Change default execution role</strong> to expose the option to use an existing role. Then, you can choose the <strong class="source-inline">Lambda-12</strong> role that we created earlier:</li></ul></li>
			</ol>
			<div>
				<div id="_idContainer174" class="IMG---Figure">
					<img src="Images/Figure_12.3_B17405.jpg" alt="Figure 12.3 – Choosing the existing role we created on the Lambda Create Function screen &#13;&#10;" width="820" height="452"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.3 – Choosing the existing role we created on the Lambda Create Function screen </p>
			<ol>
				<li value="17">Once you have filled in all the values, click on the orange <strong class="bold">Create Function</strong> button. </li>
				<li>Once you <a id="_idIndexMarker1123"/>have created your function, which should take you to the main screen for this Lambda function, we need to upload the ZIP file that we created. So, under the <strong class="bold">Code Source</strong> section on the right-hand side, click on the <strong class="bold">Upload from</strong> button. Once clicked, you will be presented with two options: <strong class="bold">.zip file</strong> or <strong class="bold">Amazon S3 location</strong>. Choose <strong class="bold">.zip file</strong> and then locate <strong class="source-inline">my-wc-package.zip</strong> on your local system. Press the <strong class="bold">Save</strong> button to send the ZIP file and its code to AWS Lambda:  <div id="_idContainer175" class="IMG---Figure"><img src="Images/Figure_12.4_B17405.jpg" alt="Figure 12.4 – Uploading the .zip file we previously created to our Lambda function&#13;&#10;" width="233" height="136"/></div><p class="figure-caption">Figure 12.4 – Uploading the .zip file we previously created to our Lambda function</p></li>
				<li>Once you have uploaded the ZIP file, multiple folders should appear on the left-hand side of the <strong class="bold">Code Source</strong> window. Our function code is available to view if we double-click on the <strong class="source-inline">Lambda_function.py</strong> file.</li>
				<li>To see our new function work, we will need to create a test event. Click on the orange <strong class="bold">Test</strong> button underneath the <strong class="bold">Code Source</strong> heading. This will bring up the dialog to create a test event. We will use the default values for our test event. Set <strong class="bold">Event name</strong> to <strong class="source-inline">Test1</strong> and then click on the orange <strong class="bold">Create</strong> button at the bottom of the dialog. </li>
				<li>With our test event created, we can run the test. Click on the arrow next to the <strong class="bold">Test</strong> button and choose the <strong class="bold">Test1</strong> option when it appears. With the correct test event selected, we can click on the orange <strong class="bold">Test</strong> button once more to start the test. </li>
			</ol>
			<p>After running the test, you should see a count of all the words in our demo URL from the <strong class="bold">Execution result</strong> page.</p>
			<p>This exercise <a id="_idIndexMarker1124"/>took us through creating and testing a Lambda function that had dependencies on third-party libraries from scratch. Next, we will look at triggers and source mappings for our functions so that they can run automatically when specific events occur. </p>
			<h1 id="_idParaDest-309"><a id="_idTextAnchor318"/>Lambda triggers and event source mappings </h1>
			<p>Lambda triggers are <a id="_idIndexMarker1125"/>especially useful for kicking off numerous applications when a piece of data is uploaded to a specific S3 bucket. AWS provides examples of images being uploaded to buckets in many of its talks and presentations. This image <a id="_idIndexMarker1126"/>then triggers a Lambda function, which will resize the image so that it's more compressed and then place it in a folder for GIFs. Many times, this same function will place a pointer for the newly resized image in a DynamoDB table. These resized images are more accessible and quicker for end users to download, and this all happens automatically once a source image has been uploaded: </p>
			<div>
				<div id="_idContainer176" class="IMG---Figure">
					<img src="Images/Figure_12.5_B17405.jpg" alt="Figure 12.5 – The flow of an image being uploaded to an S3 bucket that triggers a lambda function for image resizing" width="634" height="239"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.5 – The flow of an image being uploaded to an S3 bucket that triggers a Lambda function for image resizing</p>
			<p>There are even more things we can do with bucket triggers than just image resizing, especially in an enterprise and DevOps context. Remember that S3 can be used as source code storage since it has versioning capabilities if they've been turned on. Suppose a new <a id="_idIndexMarker1127"/>file has been uploaded to a particular folder with a specific <a id="_idIndexMarker1128"/>file extension (for example, <strong class="source-inline">*.py</strong>). In that case, that upload could kick off our CodePipeline job to build a new container and push that container through as many steps as we have until any manual gates are encountered. </p>
			<p>Now that we've looked at how triggers can invoke Lambda, let's look at how streaming data can be pushed to different queuing services so that Lambda can asynchronously process the data. </p>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor319"/>Looking at event source mappings</h2>
			<p>Since Lambda is an automatically scalable service, it can take the information from certain other <a id="_idIndexMarker1129"/>services that are sending data to it and then process that information. This information may or may not go directly to the Lambda function. These are intermediary services such as message queues, which take the instream of data and then invoke the Lambda function.  </p>
			<h2 id="_idParaDest-311"><a id="_idTextAnchor320"/>Services that Lambda can read from event sources </h2>
			<p>The following services can provide event source mappings for the Lambda service:</p>
			<ul>
				<li>DynamoDB </li>
				<li>Kinesis </li>
				<li>Amazon MQ </li>
				<li>Amazon Managed Streaming for Apache Kafka </li>
				<li>Amazon SQS </li>
			</ul>
			<p>Now that we have seen how Lambda functions can be invoked by different AWS services and even sources, let's learn how to update our functions using versions. </p>
			<h1 id="_idParaDest-312"><a id="_idTextAnchor321"/>Deploying versions using Lambda </h1>
			<p>If you have a known good state for your Lambda function, you can freeze it from future changes by <a id="_idIndexMarker1130"/>publishing a version of the function. Once published, this version will be called and used by users and services independently of any changes or updates made to future versions, including iterations done on the <strong class="source-inline">$Latest</strong> function. </p>
			<p>When you publish a version of a Lambda function, it contains the following information:</p>
			<ul>
				<li>The function code, as well as all the dependencies that are associated with it. </li>
				<li>The Lambda runtime that invokes the function. </li>
				<li>All of the function settings, such as memory, VPC association, and IAM role.</li>
				<li>Any <a id="_idIndexMarker1131"/>environment variables that have been added to the function. </li>
				<li>A unique <strong class="bold">Amazon Resource Name</strong> (<strong class="bold">ARN</strong>), so that the distinct version of the function can be identified:  </li>
			</ul>
			<div>
				<div id="_idContainer177" class="IMG---Figure">
					<img src="Images/Figure_12.6_B17405.jpg" alt="Figure 12.6 – Lambda versions and how they map to aliases&#13;&#10;" width="463" height="132"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.6 – Lambda versions and how they map to aliases</p>
			<p>Versions can be referenced in one of two ways: either with a qualified ARN or with an unqualified ARN. </p>
			<p>A qualified ARN will have a version suffix at the end of the function ARN:</p>
			<p class="source-code">arn:aws:Lambda:us-east-2:470066103307:function:my-word-count_python:5</p>
			<p>An unqualified ARN will not have a suffix at the end of the function ARN:  </p>
			<p class="source-code">arn:aws:Lambda:us-east-2:470066103307:function:my-word-count_python</p>
			<p>Now that we have learned about versions for our Lambda functions, let's look at how we can use aliases in conjunction with our versions. </p>
			<h2 id="_idParaDest-313"><a id="_idTextAnchor322"/>Using aliases in Lambda </h2>
			<p>Aliases allow you to create named pointers to specific versions of your Lambda deployments. This is especially helpful if you have passed the ARN of your Lambda function to a user or other application. </p>
			<p>Unless you <a id="_idIndexMarker1132"/>were in a testing environment, you wouldn't want to pass along the base Lambda ARN since that would point to the <strong class="source-inline">$Latest</strong> version. This <strong class="source-inline">$Latest</strong> version can constantly be changing and be subject to errors and bugs while new features and fixes are being tested and deployed. Instead, by using an alias, you can point users to a specific, stable version of the function and seamlessly transition to a new version of the function once published, tested, and ready for release. </p>
			<h1 id="_idParaDest-314"><a id="_idTextAnchor323"/>Working with Lambda layers </h1>
			<p>A Lambda layer <a id="_idIndexMarker1133"/>is a pre-published collection of code dependencies and libraries. If you find that you (or you, as a team) are using the same snippets of code in multiple functions, you can create a layer to get the benefits of Lambda layers. First, when there is a change to one of the dependencies, you no longer have to update each of the functions; instead, you only maintain a single layer that all the functions can take advantage of and only needs to be maintained one time:</p>
			<div>
				<div id="_idContainer178" class="IMG---Figure">
					<img src="Images/Figure_12.7_B17405.jpg" alt="Figure 12.7 – Lambda functions with and without layers &#13;&#10;" width="810" height="378"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.7 – Lambda functions with and without layers </p>
			<p>Layers are a <a id="_idIndexMarker1134"/>great way to speed up development between teams. Shared functionality such as logging, networking, or even database connectivity can be programmed and packaged into a layer once and then called from individual functions. </p>
			<h2 id="_idParaDest-315"><a id="_idTextAnchor324"/>Adding a Lambda layer to our function </h2>
			<p>We already have a Lambda function from our previous exercise. Now, let's expand the functionality <a id="_idIndexMarker1135"/>of our function by adding a layer that works not only for this particular function, but could also be used across numerous functions in our code base and organization.</p>
			<p>We have gone through the process of adding a layer to our Lambda function. Next, we will learn how to use native AWS to monitor our functions, as well as what metrics are the most effective to monitor. </p>
			<h1 id="_idParaDest-316"><a id="_idTextAnchor325"/>Monitoring Lambda functions </h1>
			<p>Your job is <a id="_idIndexMarker1136"/>not done once you have developed and deployed your Lambda function. To ensure that it is functioning correctly as it runs, specific metrics should be monitored. Fortunately, Lambda integrates with several other AWS services to help you not only monitor your functions but also troubleshoot them when the need arises.</p>
			<p>If you go to the AWS Console in the region where your Lambda function has been deployed, you will find a menu item that you can click on in the vertical menu bar named <strong class="bold">Monitor</strong>:</p>
			<div>
				<div id="_idContainer179" class="IMG---Figure">
					<img src="Images/Figure_12.8_B17405.jpg" alt="Figure 12.8 – The Monitor menu item from the Lambda function console&#13;&#10;" width="708" height="68"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.8 – The Monitor menu item from the Lambda function console</p>
			<p>Once you <a id="_idIndexMarker1137"/>enter the <strong class="bold">Monitor</strong> section of the Lambda console, you are instantly presented with a pre-built dashboard that allows you to see basic but vital metrics graphically for your Lambda function at a glance. The following metrics are presented:</p>
			<ul>
				<li><strong class="bold">Invocations</strong></li>
				<li><strong class="bold">Duration </strong></li>
				<li><strong class="bold">Error count and success rate</strong></li>
				<li><strong class="bold">Throttles </strong></li>
				<li><strong class="bold">Async delivery failure </strong></li>
				<li><strong class="bold">Iterator Age </strong></li>
				<li><strong class="bold">Concurrent Executions </strong></li>
			</ul>
			<p>The default timeframe for the dashboard is 3 hours; however, there are preset iterations from 1 hour to 1 week. You can also select a custom time range for the dashboard to show monitoring. </p>
			<p>Another extremely handy feature regarding the <strong class="bold">Monitoring</strong> section in the AWS Management Console is that it has buttons that allow you to jump right to either CloudWatch Logs for the function, X-Ray traces for the function using ServiceLens, or look at Lambda Insights via CloudWatch if you have enabled this extra feature. </p>
			<h2 id="_idParaDest-317"><a id="_idTextAnchor326"/>Using X-Ray to help troubleshoot your functions </h2>
			<p>When you try to troubleshoot an application, especially to find where bottlenecks are occurring <a id="_idIndexMarker1138"/>during the execution of that application or the other services that it's calling, you may need more information than your current metrics and logs are providing you with. This is when the AWS service can become especially helpful. </p>
			<p>X-Ray collects data about your application's requests and then provides you with detailed information, including a step-by-step timing of each process. Lambda runs the X-Ray daemon any time a function is invoked. This X-Ray daemon listens for traffic on UDP port <strong class="source-inline">2000</strong> and gathers the segment data. That segmented data is then relayed to the X-Ray API for presentation.  </p>
			<p class="callout-heading">Note</p>
			<p class="callout">We will look at the X-Ray service and how it can be used to monitor and watch Lambda functions in more detail in <a href="B17405_14_Final_JM_ePub.xhtml#_idTextAnchor366"><em class="italic">Chapter 14</em></a>, <em class="italic">CloudWatch and X-Ray's Role in DevOps</em>. </p>
			<p>Now that we have looked at how to monitor our Lambda functions, we will look at both the optimal use cases and the anti-patterns for AWS Lambda. </p>
			<h1 id="_idParaDest-318"><a id="_idTextAnchor327"/>Optimal Lambda use cases and anti-patterns </h1>
			<p>Now that we've looked at the AWS Lambda function as code service in detail, let's look at when <a id="_idIndexMarker1139"/>it is best used and where Lambda is not the best choice. This is essential information to understand both as an AWS professional and while <a id="_idIndexMarker1140"/>pursuing your AWS DevOps professional certification. </p>
			<p>The Lambda service from AWS is very flexible, affordable, and interacts with a vast number of AWS services. It also allows you to write your code in many different languages that you feel comfortable with and use them as your runtime environment. </p>
			<p>So, let's move on and look at some of the scenarios where Lambda would serve us best. </p>
			<h2 id="_idParaDest-319"><a id="_idTextAnchor328"/>AWS Lambda optimal use cases</h2>
			<p>As more and <a id="_idIndexMarker1141"/>more teams start to look at serverless solutions and patterns, let's look at where using the Lambda service makes sense. </p>
			<h3>You want to concentrate on the code and not the underlying infrastructure </h3>
			<p>If you or your team wants to concentrate on the features and code base instead of provisioning <a id="_idIndexMarker1142"/>and patching servers, serverless Lambda functions are an excellent choice. You concentrate on the code and <a id="_idIndexMarker1143"/>simply choose your runtime, amount of memory, how long the function is allowed to run, along with a few other options, and the Lambda service takes care of the rest. This includes scaling to meet demand and managing any underlying hardware. </p>
			<p>In return for just focusing on the code, you do give up a few things. You can no longer log into the underlying compute instances, which, in reality, are containers, to check processes or gather and watch logs as they are being generated. Instead, you need to add either logging statements or a logging library so that you can debug your code using CloudWatch Logs. </p>
			<h3>You need a cost-effective solution </h3>
			<p>Cost optimization is one of the five original service pillars that we spoke about in <a href="B17405_01_Final_JM_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Amazon Web Service Pillars</em>. Organizations are constantly looking at how to make <a id="_idIndexMarker1144"/>their solutions more cost-effective, and using Lambda is usually a great way to do that. There are no idle charges for the Lambda service since the charges are calculated on a pay-per-use basis. The service also has a perpetual free tier of one million invocations per month.</p>
			<p>One of the ways that this becomes especially useful is if you're crafting your DevOps pipeline to deploy to both your primary region and your secondary (or disaster recovery) region during each deployment without the worry of incurring extra costs. There would be no charge for the secondary deployment since it would not be invoked unless a regional or service failure occurred in the primary region. If there was an issue, however, you will be steps ahead of others since you would not need to stand up any infrastructure or resources. Instead, all you would need to do would be repoint to which region's Lambdas were being invoked. </p>
			<h2 id="_idParaDest-320"><a id="_idTextAnchor329"/>Lambda anti-patterns</h2>
			<p>Since we just <a id="_idIndexMarker1145"/>looked at where Lambda was the best choice for our platform, we will also look at where Lambda does not make the most sense. </p>
			<h3>You don't want to update the runtime once the application has been developed</h3>
			<p>With the AWS Lambda service, a specific number of runtimes are supported. The use of these <a id="_idIndexMarker1146"/>languages and versions are not set in stone, however. As language versions are deprecated due to lack of support, AWS will no longer support these runtimes, nor will they allow any new Lambda functions to be deployed using these runtimes. </p>
			<p>Many times, the fix can be as easy as switching the runtime version in the Lambda console from the previous version to the new supported version of the runtime. If there are dependent packages, libraries, or modules of the older version of the runtime, then updates and replacements might need to be found. This can be a problem if the original developers or contractors are no longer around. </p>
			<h3>You need to call an asynchronous call from your function </h3>
			<p>When you need to call an outside service such as an external API to perform your task, this <a id="_idIndexMarker1147"/>is an asynchronous call. This can be done successfully with Lambda. However, the call it makes to the initial service may not always return an immediate response. Having the function wait for the response from the service is not an optimal pattern since the Lambda service is billed based on the number of resources consumed. </p>
			<p>Now that we have looked at when to use and not to use Lambda functions, next, we will learn how to orchestrate multiple Lambda functions together using Step Functions.</p>
			<h1 id="_idParaDest-321"><a id="_idTextAnchor330"/>Orchestrating Step Functions with Lambda </h1>
			<p>There may <a id="_idIndexMarker1148"/>be times when you need to <a id="_idIndexMarker1149"/>coordinate multiple Lambda functions together to perform a larger task. Step Functions can make decisions based on input received in the state machine, run steps in parallel, and even be connected to other services such as SNS to request human input for tasks. </p>
			<p>Step <a id="_idIndexMarker1150"/>Functions also create a visual workflow <a id="_idIndexMarker1151"/>that allows you to see the individual steps in the process. As the Step Functions run, you can see the success or failure of your state machine. </p>
			<h2 id="_idParaDest-322"><a id="_idTextAnchor331"/>Understanding state machines inside of Step Functions </h2>
			<p>The state machine is the orchestration feature of the Step Function. It defines the order in which <a id="_idIndexMarker1152"/>the steps are run, along with any data that's been received from previous states and passed out to be used by other states. </p>
			<p>State machine <a id="_idIndexMarker1153"/>commands are always written in JSON format. Even if you have written your CloudFormation template in YAML format, you will still need to create your state machine and its various states in JSON format. </p>
			<p>The following is an example of a state machine:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "Comment": "A Sample State Machine",</p>
			<p class="source-code">  "StartAt": "StepOne",</p>
			<p class="source-code">  "States": {</p>
			<p class="source-code">    "StepOne": {</p>
			<p class="source-code">      "Type": "Pass",</p>
			<p class="source-code">      "Result": "Hello World!",</p>
			<p class="source-code">      "End": true</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Now that we understand what state machines are and how they differ from Step Functions, let's look at how Step Functions work. </p>
			<h2 id="_idParaDest-323"><a id="_idTextAnchor332"/>How do Step Functions work?</h2>
			<p>Step Functions <a id="_idIndexMarker1154"/>work by using a three-step process:</p>
			<ol>
				<li value="1">Define the steps in your application. </li>
				<li>Verify any state changes. </li>
				<li>Run your application and scale it if needed. <p class="callout-heading">Note</p><p class="callout">Did you know that, unlike a Lambda function, you cannot trigger a Step Function from an <strong class="source-inline">S3</strong> bucket event? Instead, you need to have the bucket event call a separate Lambda function that can then invoke the Step Function. </p></li>
			</ol>
			<p>Now that we know the basics of how Step Functions work, let's take a closer look at the different states available in Step Functions. </p>
			<h2 id="_idParaDest-324"><a id="_idTextAnchor333"/>States available in Step Functions</h2>
			<p>As you <a id="_idIndexMarker1155"/>start to configure the states for your step functions, you begin to create a <strong class="bold">state machine</strong>. You do this by using the <strong class="bold">Amazon States Language</strong>, which is a JSON-based language for defining the different states in your state machine. There are states that can do things, transitional states, and then states that stop when the task fails or succeeds:</p>
			<div>
				<div id="_idContainer180" class="IMG---Figure">
					<img src="Images/Figure_12.9_B17405.jpg" alt="Figure 12.9 – The different states that are available in Step Functions &#13;&#10;" width="459" height="271"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.9 – The different states that are available in Step Functions </p>
			<p>Let's take a closer look at each of these states and what functions they perform. </p>
			<h3>Task state </h3>
			<p>When you <a id="_idIndexMarker1156"/>create a single unit of work that is to be executed <a id="_idIndexMarker1157"/>by a state machine, then you are creating a <strong class="source-inline">task</strong> state. The <strong class="source-inline">task</strong> state is where you can invoke Lambda functions. </p>
			<h3>Choice state </h3>
			<p>The <strong class="source-inline">choice</strong> state allows the state machine to choose between different branches to follow based <a id="_idIndexMarker1158"/>on logical evaluations. You provide a <a id="_idIndexMarker1159"/>set of choice rules, which are rules that evaluate either input or output variables. Based on if the values render as true or not, the next step in the state machine is defined. </p>
			<p>Although a default choice is not required, it is recommended just in case none of your choices match any of the logic. Otherwise, your state machine will stop and error out. </p>
			<h3>Parallel state </h3>
			<p>As the <a id="_idIndexMarker1160"/>name implies, a <strong class="source-inline">parallel</strong> state can be used to create multiple branches of a state machine that execute at the same time. This can significantly speed up the execution time for tasks that are not dependent on each other. </p>
			<h3>Fail state </h3>
			<p>A <strong class="source-inline">fail</strong> state will <a id="_idIndexMarker1161"/>stop the execution of your state machine but optionally give you the ability to enter either a <strong class="source-inline">Cause</strong> in a field, an <strong class="source-inline">Error</strong> in a field, or both. These fields can be especially useful when you're trying to debug larger and more complex state machines, and rather than hard-coding in an error code, it is better to pass on some of the information from the system. </p>
			<h3>Succeed state </h3>
			<p>The <strong class="source-inline">Succeed</strong> state is <a id="_idIndexMarker1162"/>a termination state and has no next field. </p>
			<h3>Wait state</h3>
			<p>If you need <a id="_idIndexMarker1163"/>to put a pause in your Step Function, then you can add a <strong class="source-inline">wait</strong> state. The <strong class="source-inline">wait</strong> state can be defined by the number of seconds to pause or by a timestamp on when to resume. </p>
			<h2 id="_idParaDest-325"><a id="_idTextAnchor334"/>Creating a Step Function</h2>
			<p>One of the best ways to understand step functions is to create one and then watch it execute. We <a id="_idIndexMarker1164"/>have created a <strong class="bold">CloudFormation</strong> template that will quickly spin up a Step Function state machine. This template also uses an <strong class="source-inline">S3</strong> bucket, which <a id="_idIndexMarker1165"/>is used to store the Lambda functions that have been invoked by the Step Function. If you completed the initial Lambda function exercise, you will already have the Lambda in ZIP format, ready to upload to this new bucket. The template file can be found in this book's GitHub repository, in the <strong class="source-inline">Chapter-12</strong> folder, called <strong class="source-inline">step_function.yml</strong>:</p>
			<ol>
				<li value="1">Before we run the template, we need to upload the <strong class="source-inline">my-wc-package.zip</strong> file. This can be the <strong class="source-inline">S3</strong> bucket that we have been using up to this point. We will do this on the command line using the S3 copy command. Make sure that you are in the same directory where you have the ZIP file, or that you have moved the ZIP file to your current working directory: <p class="source-code"><strong class="bold">$aws s3 cp my-wc-package.zip s3://devopspro-beyond/</strong></p></li>
				<li>Open your terminal and go to the directory where you have downloaded the CloudFormation template from the <strong class="source-inline">Chapter-12</strong> folder. Use the following CLI command to create the Step Function from the <strong class="source-inline">step_function.yml</strong> template. We will need to know the bucket that we uploaded the files to so that we can pass that in as a parameter. We will also name our stack <strong class="source-inline">stepTest</strong>:<p class="source-code"><strong class="bold">$aws cloudformation create-stack --stack-name stepTest --template-body file://step_function.yml --parameters ParameterKey=LambdaFunctionBucket,ParameterValue=devopspro-beyond --capabilities CAPABILITY_IAM</strong></p></li>
				<li>With the Step Function and Lambda function in place, we will log into the AWS Management Console using our administrative user. Once logged in, navigate to the <strong class="bold">Step Function</strong> service. </li>
				<li>Once on the <strong class="bold">Step Functions service</strong> page, you should see a state machine named <strong class="bold">Chapter-Twelve</strong>. Click on the name of the state machine to be taken to it: <div id="_idContainer181" class="IMG---Figure"><img src="Images/Figure_12.10_B17405.jpg" alt="Figure 12.10 – The Chapter-Twelve state machine created &#13;&#10;" width="413" height="242"/></div><p class="figure-caption">Figure 12.10 – The Chapter-Twelve state machine created </p></li>
				<li>Now, on <a id="_idIndexMarker1166"/>the <strong class="bold">Chapter-Twelve</strong> state machine, click on the <strong class="bold">Start execution</strong> button. This will open up a dialog box where you can name the execution. Just leave the default values as-is and click the orange <strong class="bold">Start Execution</strong> button at the bottom of the dialog window. </li>
				<li>Once you start the execution, you should see the mapping of the state machine and the flow of the steps. You can click on any individual step to see both the input and output values:</li>
			</ol>
			<div>
				<div id="_idContainer182" class="IMG---Figure">
					<img src="Images/Figure_12.11_B17405.jpg" alt="Figure 12.11 – The graphical view of the state machine, as generated by AWS&#13;&#10;" width="522" height="426"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.11 – The graphical view of the state machine, as generated by AWS</p>
			<p>With that, you <a id="_idIndexMarker1167"/>have gone through not only the process of creating a Step Function but also incorporating the Lambda function we created earlier into our state machine. Now, let's quickly recap what we learned in this chapter. </p>
			<h1 id="_idParaDest-326"><a id="_idTextAnchor335"/>Summary</h1>
			<p>In this chapter, we learned about the Lambda service and how it is used in serverless architectures. We looked at the different components of the Lambda function, from its events to its runtimes. We looked at the different ways that Lambda can be invoked and even used to build a function from scratch. After that, we learned how Step Functions can be used to orchestrate multiple Lambda functions. </p>
			<p>In the next chapter, we will do a deep dive into Blue/Green deployments, along with their variations. We will also talk about how they play an important role in the DevOps process since this can be brought up in a variety of ways in different testing questions. </p>
			<h1 id="_idParaDest-327"><a id="_idTextAnchor336"/>Questions </h1>
			<ol>
				<li value="1">A developer on your team has created a Lambda function that is triggered by an S3 bucket event. The function is supposed to be invoked when an object is placed in the bucket. However, the function is not working correctly. This issue needs to be debugged and fixed. How can this be accomplished simply and quickly by the developer?<p>a. Use the Lambda Monitoring Console to help debug the issue. </p><p>b. Use AWS CloudTrail Logs. </p><p>c. Open an AWS support case, noting both the ARN of the Lambda function and the S3 bucket.</p><p>d. Use AWS CloudWatch Logs. </p></li>
				<li>You have been asked to help construct a serverless application using AWS Lambda. The application needs to be monitored; however, the company does not want to bring in any third-party services for monitoring. Although logging and tracking functions that call other functions can be tricky, what services from AWS can help you perform this task? (Choose 3) <p>a. AWS CloudTrail</p><p>b. AWS CloudWatch</p><p>c. AWS Inspector</p><p>d. AWS X-Ray</p></li>
				<li>You have been brought into a company to help with their serverless architecture. They currently have an architecture that has multiple Lambda functions. These functions are invoking other functions and are acting as a state machine. The company has used older obsolete coding patterns to coordinate the state machine and is finding that the code is difficult to repair when it breaks. What service could you suggest to them that will help refactor their application and manage the state machine?<p>a. AWS Data Pipeline </p><p>b. AWS Step Functions </p><p>c. AWS Cognito</p><p>d. AWS Beanstalk</p></li>
			</ol>
			<h1 id="_idParaDest-328"><a id="_idTextAnchor337"/>Answers </h1>
			<ol>
				<li value="1">d</li>
				<li>a, b, d </li>
				<li>c</li>
			</ol>
		</div>
	</div></body></html>