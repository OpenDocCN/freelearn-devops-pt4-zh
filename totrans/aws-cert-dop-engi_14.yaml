- en: 'Chapter 12: Lambda Deployments and Versioning'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As more and more application architectures go serverless and more and more cloud
    budgets are scrutinized, AWS Lambda becomes more and more of a viable option in
    both the Developer and Operations professions' tool belts. Knowing how to harness
    the flexibility and power of Lambda and Step functions is key to success in today's
    AWS environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS Lambda overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda triggers and event source mappings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying versions using Lambda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Lambda layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring Lambda functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimal Lambda use cases and anti-patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orchestrating Step Functions with Lambda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in the previous chapters, we will be using the Python programming language
    to create our Lambda functions. Basic working knowledge of Python is suggested
    to follow the examples and debug and troubleshoot if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Lambda overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS Lambda is a service that allows you to run your code as a function, without
    the need to stand up any servers or provision or orchestrate containers. It automatically
    scales to the number of requests that it receives. One of the most attractive
    items about Lambda functions is that they are only charged for the time they run.
    This means that you can have your platform provisioned in one or multiple regions,
    waiting for requests, without worrying how much the bill will accumulate from
    idle resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lambda lets you concentrate on the code instead of servers as it is a serverless
    Platform as a Service offering. Being a PaaS also means that you have no access
    to the underlying compute platform to make adjustments other than those that AWS
    exposes to you, such as the runtime (programming language) or your environment,
    the amount of memory that your function needs to use, and the amount of CPU allocated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Lambda architecture with triggers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.1_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.1 – Lambda architecture with triggers
  prefs: []
  type: TYPE_NORMAL
- en: Many Lambda functions are events that are triggered by other AWS services. This
    is another fact that makes the service so appealing. Lambda functions can be used
    to do backend processing based on S3 bucket events. Then, you can put them into
    a decoupled architecture using a message queue, such as **Simple Queue Service**
    or **Amazon MQ**, for processing by one or more concurrent Lambda functions to
    put the data into a backend data store.
  prefs: []
  type: TYPE_NORMAL
- en: The data can then be retrieved using either RESTful calls from a service such
    as **API Gateway** by utilizing GraphQL with **AppSync**.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless instead of servers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The term **serverless** should instantly bring a few critical thoughts to mind.
    In the world of AWS, this boils down to four fundamental principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**There are no servers to provision**: There should be no actual servers or
    instances to configure or maintain. There should also be no container orchestration
    needed on your part.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The system and architecture scale with usage**: As requests, data, or events
    come in, the underlying platform and infrastructure should automatically scale
    out and scale in to meet the necessary demand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**You pay for value**: Resources that are sitting idle, waiting to be used,
    should not incur charges. Charges should only occur when the resources are actively
    being utilized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The system is built for availability and fault tolerance**: Once you''re
    launching your platform, it should automatically span multiple availability zones,
    increasing your availability and fault tolerance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you talk to people who have used a serverless platform in the real world,
    they feel like they have derived numerous benefits from making the switch. One
    such benefit is **greater agility** and the ability to move faster since they
    are not spending as much time setting up and provisioning infrastructure. Separating
    themselves from dealing with instance and container configuration allows them
    to **better focus** on their business and the features that their customers want
    and find valuable. They also feel as though they have **increased scale** compared
    to the previous capacity that customers used to have in their data centers. This
    is because Lambda will scale up automatically based on the number of invocations
    to a particular function.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous versus asynchronous invocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you invoke a Lambda function, it can be done in one of two ways: either
    synchronously or asynchronously.'
  prefs: []
  type: TYPE_NORMAL
- en: Lambda will run the function on a synchronous invocation, wait for the response,
    and then return the response code with any data included in the function's return
    call. You can use the `invoke` command from the AWS CLI to invoke a function synchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'With asynchronous invocations, you are pushing the event to Lambda but not
    waiting for an immediate response. Lambda will queue up the events before sending
    them to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Asynchronous invocation in Lambda'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.2_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.2 – Asynchronous invocation in Lambda
  prefs: []
  type: TYPE_NORMAL
- en: Lambda manages the functions event queue and, upon receiving an error, will
    attempt to retry the event. If it fails, it will try twice more with a longer
    time in-between each additional attempt.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have taken an initial look at how we can invoke a Lambda function,
    let's take a deeper look at Lambda functions themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code you write becomes the function that runs without the need for provisioning
    or managing any servers. The function itself is the resource and can take in events
    that have been passed to it, either by you or other AWS services.
  prefs: []
  type: TYPE_NORMAL
- en: You can use a few different languages that are supported to create your Lambda
    functions. These include Python, Node.js, Ruby, Java, Go, and .NET. You can even
    create custom runtimes by using containers.
  prefs: []
  type: TYPE_NORMAL
- en: The basic concepts of Lambda
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you start a Lambda function, that process is called **invoking** the function.
    Lambda functions process events. Events are sent to your functions in a few different
    ways: you can manually invoke the function, such as with a test event, or you
    can configure an AWS resource or service to invoke it and start the process.'
  prefs: []
  type: TYPE_NORMAL
- en: Since we're talking about Lambda functions, there are a few key concepts that
    need to be understood.
  prefs: []
  type: TYPE_NORMAL
- en: Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A function is the code where you process your events. It is what is invoked
    when you call the Lambda process, either by an event, schedule, or manually.
  prefs: []
  type: TYPE_NORMAL
- en: Qualifier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lambda functions can have versions and aliases. Once a version has been created,
    it is a fixed version of the code and contains a numerical qualifier at the end.
    Although the `$LATEST` version of your Lambda code is the one that you can constantly
    be updating, if you wanted to call that version that you snapshotted in time,
    such as `test-function:1`, you would need to append the version number to the
    end.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The runtime in Lambda allows you to choose the language, along with the language
    version, that your function will execute. This runtime is not contained within
    the function itself; instead, it sits between the Lambda service and the function
    code. Not only can you use the runtimes that the Lambda service provides, but
    you can also build your own if there is a language and version that you desire
    that the service itself does not support.
  prefs: []
  type: TYPE_NORMAL
- en: Event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An event in Lambda is a JSON document that consists of data for the function
    to process. Events can be simple and single-tiered, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: They can be also complex, coming from AWS services with nested keys and values
    that require complex parsing. These complex events can hold valuable data that
    can automate processes and make your life, as a DevOps professional, easier if
    you learn how to harness their power.
  prefs: []
  type: TYPE_NORMAL
- en: The Lambda handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A handler can be any name, but the default name, especially when creating a
    function in the AWS Console, is `Lambda_function.Lambda_handler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example Lambda code, we can see two arguments being passed to the Lambda
    handler: the event and the context.'
  prefs: []
  type: TYPE_NORMAL
- en: The `event` argument is a JSON formatted document that includes the data for
    the Lambda function to process. While it is often a dictionary object, it can
    also be a list, string, integer, or floating-point number.
  prefs: []
  type: TYPE_NORMAL
- en: Using a combination of the event handler and a parser, you can grab information
    about which specific resources invoked the Lambda function and then perform the
    necessary actions from there. By using `returns`, such as the greeting in the
    simple example shown previously, you can call other methods inside your function
    based on the information you find. You could even have the entire function return
    a value. This is especially useful in the case of **Step Functions**, which we
    will look at later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `context` argument is passed to the Lambda function at runtime. This argument
    contains information regarding the invocation, the runtime environment, and the
    function itself.
  prefs: []
  type: TYPE_NORMAL
- en: Limits of Lambda
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you go about creating your Lambda functions, it's helpful to understand some
    of the constraints that the Lambda service has put into place. The minimum amount
    of memory for a function is 128 MB, while the maximum is 3,008 MB. The longest
    execution time allowed for a Lambda function is 15 minutes or 900 seconds. You
    can only have a maximum of 4 KB in environment variables. There is a concurrency
    limit of 1,000 concurrent executions per function. If you are extracting data
    or using the `/tmp` disk space, you have a limit of 512 MB.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Lambda function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With an understanding of how Lambda functions work, we will now start creating
    our Lambda function. The function that we will create will take a URL that's been
    passed to it and then count the number of words on the web page. Since we will
    need external packages, we will need to create a ZIP package first and then upload
    that to the Lambda service.
  prefs: []
  type: TYPE_NORMAL
- en: There are times when you can just write a simple function in the AWS Management
    Console itself using the built-in editor in the Lambda service. This includes
    the Python language and the `boto` and `botocore` modules, which allow you to
    take advantage of the Python `random` to help you generate random numbers and
    values, `OS` to allow you to call operating system functionality, and `math`,
    `gzip`, and `logging`, along with quite a few others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to build our Lambda package so that it can be uploaded:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by opening our terminal and creating a role for our Lambda function
    to use. With our terminal open, we will navigate to the beginning of our directory
    and then create a new directory for our Lambda. Once created, go into that directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will use the following JSON saved to a file named `Lambda-role-policy.json`;
    you can also find this file in the `Chapter-12` folder of the GitHub repository
    for this book:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use this file in the following command to create the role that our Lambda function
    will use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should come back with a JSON return showing the successful creation of
    the role, similar to the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our role has now been created for our Lambda to use; however, it cannot do
    much since there is currently no policy attached. Instead of writing a custom
    policy, we will use a predefined AWS policy created for Lambdas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With our role created and ready to use, let''s remove the current file in the
    directory so that it doesn''t get deployed with our `zip` package later. We are
    going to use the `remove` command for the file. However, if you would like to
    save it, I would suggest using the `copy` or `move` command to your `/tmp` directory
    or `Downloads` so that you can access it later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will create a new file called `Lambda_function.py`. In this function,
    we will cut and paste (or type, if you''re brave) the following code. Alternatively,
    once again, you can find the full file in the `Chapter-12` directory of this book''s
    GitHub repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, the directory structure of your `my-wc-function` directory should look
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, we can start installing our dependent modules locally using
    the `–target`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s make the deployment package. First, we will navigate into the `package`
    directory that we just created and then create the initial `zip` file. Take note
    of the two dots in the `zip` command; these are telling the `zip` file to be created
    in the directory and not in the `package` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With our initial `zip` file created, we can add our Python file to the `zip`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After running this command, you should see that the `Lambda_function.py` file
    has been added to the previously created `zip` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have our deployment package created and are ready to move on to the AWS
    Management Console so that we can upload and test our function. This could all
    be continued from the CLI, but the console has some features that aren't available
    from the CLI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your web browser and navigate to the Lambda service after logging in using
    your administrative account. You can get to the service directly by going to the
    [https://console.aws.amazon.com/Lambda](https://console.aws.amazon.com/lambda).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find and click on the orange **Create function** button near the top right-hand
    side of the main screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you're on the `my-word-count_python`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`python 3.8`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Lambda-12` role that we created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Choosing the existing role we created on the Lambda Create
    Function screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.3_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.3 – Choosing the existing role we created on the Lambda Create Function
    screen
  prefs: []
  type: TYPE_NORMAL
- en: Once you have filled in all the values, click on the orange **Create Function**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have created your function, which should take you to the main screen
    for this Lambda function, we need to upload the ZIP file that we created. So,
    under the `my-wc-package.zip` on your local system. Press the **Save** button
    to send the ZIP file and its code to AWS Lambda:![Figure 12.4 – Uploading the
    .zip file we previously created to our Lambda function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_12.4_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 12.4 – Uploading the .zip file we previously created to our Lambda function
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you have uploaded the ZIP file, multiple folders should appear on the left-hand
    side of the `Lambda_function.py` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To see our new function work, we will need to create a test event. Click on
    the orange `Test1` and then click on the orange **Create** button at the bottom
    of the dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our test event created, we can run the test. Click on the arrow next to
    the **Test** button and choose the **Test1** option when it appears. With the
    correct test event selected, we can click on the orange **Test** button once more
    to start the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After running the test, you should see a count of all the words in our demo
    URL from the **Execution result** page.
  prefs: []
  type: TYPE_NORMAL
- en: This exercise took us through creating and testing a Lambda function that had
    dependencies on third-party libraries from scratch. Next, we will look at triggers
    and source mappings for our functions so that they can run automatically when
    specific events occur.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda triggers and event source mappings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lambda triggers are especially useful for kicking off numerous applications
    when a piece of data is uploaded to a specific S3 bucket. AWS provides examples
    of images being uploaded to buckets in many of its talks and presentations. This
    image then triggers a Lambda function, which will resize the image so that it''s
    more compressed and then place it in a folder for GIFs. Many times, this same
    function will place a pointer for the newly resized image in a DynamoDB table.
    These resized images are more accessible and quicker for end users to download,
    and this all happens automatically once a source image has been uploaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – The flow of an image being uploaded to an S3 bucket that triggers
    a lambda function for image resizing](img/Figure_12.5_B17405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – The flow of an image being uploaded to an S3 bucket that triggers
    a Lambda function for image resizing
  prefs: []
  type: TYPE_NORMAL
- en: There are even more things we can do with bucket triggers than just image resizing,
    especially in an enterprise and DevOps context. Remember that S3 can be used as
    source code storage since it has versioning capabilities if they've been turned
    on. Suppose a new file has been uploaded to a particular folder with a specific
    file extension (for example, `*.py`). In that case, that upload could kick off
    our CodePipeline job to build a new container and push that container through
    as many steps as we have until any manual gates are encountered.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've looked at how triggers can invoke Lambda, let's look at how streaming
    data can be pushed to different queuing services so that Lambda can asynchronously
    process the data.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at event source mappings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Lambda is an automatically scalable service, it can take the information
    from certain other services that are sending data to it and then process that
    information. This information may or may not go directly to the Lambda function.
    These are intermediary services such as message queues, which take the instream
    of data and then invoke the Lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: Services that Lambda can read from event sources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following services can provide event source mappings for the Lambda service:'
  prefs: []
  type: TYPE_NORMAL
- en: DynamoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kinesis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon MQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon Managed Streaming for Apache Kafka
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon SQS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have seen how Lambda functions can be invoked by different AWS services
    and even sources, let's learn how to update our functions using versions.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying versions using Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have a known good state for your Lambda function, you can freeze it from
    future changes by publishing a version of the function. Once published, this version
    will be called and used by users and services independently of any changes or
    updates made to future versions, including iterations done on the `$Latest` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you publish a version of a Lambda function, it contains the following
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: The function code, as well as all the dependencies that are associated with
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Lambda runtime that invokes the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the function settings, such as memory, VPC association, and IAM role.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any environment variables that have been added to the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A unique **Amazon Resource Name** (**ARN**), so that the distinct version of
    the function can be identified:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Lambda versions and how they map to aliases'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.6_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.6 – Lambda versions and how they map to aliases
  prefs: []
  type: TYPE_NORMAL
- en: 'Versions can be referenced in one of two ways: either with a qualified ARN
    or with an unqualified ARN.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A qualified ARN will have a version suffix at the end of the function ARN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'An unqualified ARN will not have a suffix at the end of the function ARN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have learned about versions for our Lambda functions, let's look
    at how we can use aliases in conjunction with our versions.
  prefs: []
  type: TYPE_NORMAL
- en: Using aliases in Lambda
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Aliases allow you to create named pointers to specific versions of your Lambda
    deployments. This is especially helpful if you have passed the ARN of your Lambda
    function to a user or other application.
  prefs: []
  type: TYPE_NORMAL
- en: Unless you were in a testing environment, you wouldn't want to pass along the
    base Lambda ARN since that would point to the `$Latest` version. This `$Latest`
    version can constantly be changing and be subject to errors and bugs while new
    features and fixes are being tested and deployed. Instead, by using an alias,
    you can point users to a specific, stable version of the function and seamlessly
    transition to a new version of the function once published, tested, and ready
    for release.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Lambda layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Lambda layer is a pre-published collection of code dependencies and libraries.
    If you find that you (or you, as a team) are using the same snippets of code in
    multiple functions, you can create a layer to get the benefits of Lambda layers.
    First, when there is a change to one of the dependencies, you no longer have to
    update each of the functions; instead, you only maintain a single layer that all
    the functions can take advantage of and only needs to be maintained one time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – Lambda functions with and without layers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.7_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.7 – Lambda functions with and without layers
  prefs: []
  type: TYPE_NORMAL
- en: Layers are a great way to speed up development between teams. Shared functionality
    such as logging, networking, or even database connectivity can be programmed and
    packaged into a layer once and then called from individual functions.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Lambda layer to our function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already have a Lambda function from our previous exercise. Now, let's expand
    the functionality of our function by adding a layer that works not only for this
    particular function, but could also be used across numerous functions in our code
    base and organization.
  prefs: []
  type: TYPE_NORMAL
- en: We have gone through the process of adding a layer to our Lambda function. Next,
    we will learn how to use native AWS to monitor our functions, as well as what
    metrics are the most effective to monitor.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring Lambda functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your job is not done once you have developed and deployed your Lambda function.
    To ensure that it is functioning correctly as it runs, specific metrics should
    be monitored. Fortunately, Lambda integrates with several other AWS services to
    help you not only monitor your functions but also troubleshoot them when the need
    arises.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go to the AWS Console in the region where your Lambda function has been
    deployed, you will find a menu item that you can click on in the vertical menu
    bar named **Monitor**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – The Monitor menu item from the Lambda function console'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.8_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.8 – The Monitor menu item from the Lambda function console
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you enter the **Monitor** section of the Lambda console, you are instantly
    presented with a pre-built dashboard that allows you to see basic but vital metrics
    graphically for your Lambda function at a glance. The following metrics are presented:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Invocations**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Duration**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error count and success rate**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Throttles**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Async delivery failure**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iterator Age**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrent Executions**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default timeframe for the dashboard is 3 hours; however, there are preset
    iterations from 1 hour to 1 week. You can also select a custom time range for
    the dashboard to show monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Another extremely handy feature regarding the **Monitoring** section in the
    AWS Management Console is that it has buttons that allow you to jump right to
    either CloudWatch Logs for the function, X-Ray traces for the function using ServiceLens,
    or look at Lambda Insights via CloudWatch if you have enabled this extra feature.
  prefs: []
  type: TYPE_NORMAL
- en: Using X-Ray to help troubleshoot your functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you try to troubleshoot an application, especially to find where bottlenecks
    are occurring during the execution of that application or the other services that
    it's calling, you may need more information than your current metrics and logs
    are providing you with. This is when the AWS service can become especially helpful.
  prefs: []
  type: TYPE_NORMAL
- en: X-Ray collects data about your application's requests and then provides you
    with detailed information, including a step-by-step timing of each process. Lambda
    runs the X-Ray daemon any time a function is invoked. This X-Ray daemon listens
    for traffic on UDP port `2000` and gathers the segment data. That segmented data
    is then relayed to the X-Ray API for presentation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We will look at the X-Ray service and how it can be used to monitor and watch
    Lambda functions in more detail in [*Chapter 14*](B17405_14_Final_JM_ePub.xhtml#_idTextAnchor366),
    *CloudWatch and X-Ray's Role in DevOps*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at how to monitor our Lambda functions, we will look
    at both the optimal use cases and the anti-patterns for AWS Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Optimal Lambda use cases and anti-patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've looked at the AWS Lambda function as code service in detail,
    let's look at when it is best used and where Lambda is not the best choice. This
    is essential information to understand both as an AWS professional and while pursuing
    your AWS DevOps professional certification.
  prefs: []
  type: TYPE_NORMAL
- en: The Lambda service from AWS is very flexible, affordable, and interacts with
    a vast number of AWS services. It also allows you to write your code in many different
    languages that you feel comfortable with and use them as your runtime environment.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's move on and look at some of the scenarios where Lambda would serve
    us best.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Lambda optimal use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As more and more teams start to look at serverless solutions and patterns, let's
    look at where using the Lambda service makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: You want to concentrate on the code and not the underlying infrastructure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you or your team wants to concentrate on the features and code base instead
    of provisioning and patching servers, serverless Lambda functions are an excellent
    choice. You concentrate on the code and simply choose your runtime, amount of
    memory, how long the function is allowed to run, along with a few other options,
    and the Lambda service takes care of the rest. This includes scaling to meet demand
    and managing any underlying hardware.
  prefs: []
  type: TYPE_NORMAL
- en: In return for just focusing on the code, you do give up a few things. You can
    no longer log into the underlying compute instances, which, in reality, are containers,
    to check processes or gather and watch logs as they are being generated. Instead,
    you need to add either logging statements or a logging library so that you can
    debug your code using CloudWatch Logs.
  prefs: []
  type: TYPE_NORMAL
- en: You need a cost-effective solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cost optimization is one of the five original service pillars that we spoke
    about in [*Chapter 1*](B17405_01_Final_JM_ePub.xhtml#_idTextAnchor015), *Amazon
    Web Service Pillars*. Organizations are constantly looking at how to make their
    solutions more cost-effective, and using Lambda is usually a great way to do that.
    There are no idle charges for the Lambda service since the charges are calculated
    on a pay-per-use basis. The service also has a perpetual free tier of one million
    invocations per month.
  prefs: []
  type: TYPE_NORMAL
- en: One of the ways that this becomes especially useful is if you're crafting your
    DevOps pipeline to deploy to both your primary region and your secondary (or disaster
    recovery) region during each deployment without the worry of incurring extra costs.
    There would be no charge for the secondary deployment since it would not be invoked
    unless a regional or service failure occurred in the primary region. If there
    was an issue, however, you will be steps ahead of others since you would not need
    to stand up any infrastructure or resources. Instead, all you would need to do
    would be repoint to which region's Lambdas were being invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda anti-patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we just looked at where Lambda was the best choice for our platform, we
    will also look at where Lambda does not make the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: You don't want to update the runtime once the application has been developed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the AWS Lambda service, a specific number of runtimes are supported. The
    use of these languages and versions are not set in stone, however. As language
    versions are deprecated due to lack of support, AWS will no longer support these
    runtimes, nor will they allow any new Lambda functions to be deployed using these
    runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: Many times, the fix can be as easy as switching the runtime version in the Lambda
    console from the previous version to the new supported version of the runtime.
    If there are dependent packages, libraries, or modules of the older version of
    the runtime, then updates and replacements might need to be found. This can be
    a problem if the original developers or contractors are no longer around.
  prefs: []
  type: TYPE_NORMAL
- en: You need to call an asynchronous call from your function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you need to call an outside service such as an external API to perform
    your task, this is an asynchronous call. This can be done successfully with Lambda.
    However, the call it makes to the initial service may not always return an immediate
    response. Having the function wait for the response from the service is not an
    optimal pattern since the Lambda service is billed based on the number of resources
    consumed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at when to use and not to use Lambda functions, next,
    we will learn how to orchestrate multiple Lambda functions together using Step
    Functions.
  prefs: []
  type: TYPE_NORMAL
- en: Orchestrating Step Functions with Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There may be times when you need to coordinate multiple Lambda functions together
    to perform a larger task. Step Functions can make decisions based on input received
    in the state machine, run steps in parallel, and even be connected to other services
    such as SNS to request human input for tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Step Functions also create a visual workflow that allows you to see the individual
    steps in the process. As the Step Functions run, you can see the success or failure
    of your state machine.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding state machines inside of Step Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The state machine is the orchestration feature of the Step Function. It defines
    the order in which the steps are run, along with any data that's been received
    from previous states and passed out to be used by other states.
  prefs: []
  type: TYPE_NORMAL
- en: State machine commands are always written in JSON format. Even if you have written
    your CloudFormation template in YAML format, you will still need to create your
    state machine and its various states in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a state machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now that we understand what state machines are and how they differ from Step
    Functions, let's look at how Step Functions work.
  prefs: []
  type: TYPE_NORMAL
- en: How do Step Functions work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Step Functions work by using a three-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the steps in your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify any state changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run your application and scale it if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Did you know that, unlike a Lambda function, you cannot trigger a Step Function
    from an `S3` bucket event? Instead, you need to have the bucket event call a separate
    Lambda function that can then invoke the Step Function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we know the basics of how Step Functions work, let's take a closer
    look at the different states available in Step Functions.
  prefs: []
  type: TYPE_NORMAL
- en: States available in Step Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you start to configure the states for your step functions, you begin to
    create a **state machine**. You do this by using the **Amazon States Language**,
    which is a JSON-based language for defining the different states in your state
    machine. There are states that can do things, transitional states, and then states
    that stop when the task fails or succeeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9 – The different states that are available in Step Functions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.9_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.9 – The different states that are available in Step Functions
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a closer look at each of these states and what functions they perform.
  prefs: []
  type: TYPE_NORMAL
- en: Task state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you create a single unit of work that is to be executed by a state machine,
    then you are creating a `task` state. The `task` state is where you can invoke
    Lambda functions.
  prefs: []
  type: TYPE_NORMAL
- en: Choice state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `choice` state allows the state machine to choose between different branches
    to follow based on logical evaluations. You provide a set of choice rules, which
    are rules that evaluate either input or output variables. Based on if the values
    render as true or not, the next step in the state machine is defined.
  prefs: []
  type: TYPE_NORMAL
- en: Although a default choice is not required, it is recommended just in case none
    of your choices match any of the logic. Otherwise, your state machine will stop
    and error out.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the name implies, a `parallel` state can be used to create multiple branches
    of a state machine that execute at the same time. This can significantly speed
    up the execution time for tasks that are not dependent on each other.
  prefs: []
  type: TYPE_NORMAL
- en: Fail state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `fail` state will stop the execution of your state machine but optionally
    give you the ability to enter either a `Cause` in a field, an `Error` in a field,
    or both. These fields can be especially useful when you're trying to debug larger
    and more complex state machines, and rather than hard-coding in an error code,
    it is better to pass on some of the information from the system.
  prefs: []
  type: TYPE_NORMAL
- en: Succeed state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Succeed` state is a termination state and has no next field.
  prefs: []
  type: TYPE_NORMAL
- en: Wait state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need to put a pause in your Step Function, then you can add a `wait`
    state. The `wait` state can be defined by the number of seconds to pause or by
    a timestamp on when to resume.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Step Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the best ways to understand step functions is to create one and then
    watch it execute. We have created a `S3` bucket, which is used to store the Lambda
    functions that have been invoked by the Step Function. If you completed the initial
    Lambda function exercise, you will already have the Lambda in ZIP format, ready
    to upload to this new bucket. The template file can be found in this book''s GitHub
    repository, in the `Chapter-12` folder, called `step_function.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we run the template, we need to upload the `my-wc-package.zip` file.
    This can be the `S3` bucket that we have been using up to this point. We will
    do this on the command line using the S3 copy command. Make sure that you are
    in the same directory where you have the ZIP file, or that you have moved the
    ZIP file to your current working directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open your terminal and go to the directory where you have downloaded the CloudFormation
    template from the `Chapter-12` folder. Use the following CLI command to create
    the Step Function from the `step_function.yml` template. We will need to know
    the bucket that we uploaded the files to so that we can pass that in as a parameter.
    We will also name our stack `stepTest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the Step Function and Lambda function in place, we will log into the AWS
    Management Console using our administrative user. Once logged in, navigate to
    the **Step Function** service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once on the **Step Functions service** page, you should see a state machine
    named **Chapter-Twelve**. Click on the name of the state machine to be taken to
    it:![Figure 12.10 – The Chapter-Twelve state machine created
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_12.10_B17405.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 12.10 – The Chapter-Twelve state machine created
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, on the **Chapter-Twelve** state machine, click on the **Start execution**
    button. This will open up a dialog box where you can name the execution. Just
    leave the default values as-is and click the orange **Start Execution** button
    at the bottom of the dialog window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you start the execution, you should see the mapping of the state machine
    and the flow of the steps. You can click on any individual step to see both the
    input and output values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.11 – The graphical view of the state machine, as generated by AWS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.11_B17405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.11 – The graphical view of the state machine, as generated by AWS
  prefs: []
  type: TYPE_NORMAL
- en: With that, you have gone through not only the process of creating a Step Function
    but also incorporating the Lambda function we created earlier into our state machine.
    Now, let's quickly recap what we learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the Lambda service and how it is used in serverless
    architectures. We looked at the different components of the Lambda function, from
    its events to its runtimes. We looked at the different ways that Lambda can be
    invoked and even used to build a function from scratch. After that, we learned
    how Step Functions can be used to orchestrate multiple Lambda functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will do a deep dive into Blue/Green deployments, along
    with their variations. We will also talk about how they play an important role
    in the DevOps process since this can be brought up in a variety of ways in different
    testing questions.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A developer on your team has created a Lambda function that is triggered by
    an S3 bucket event. The function is supposed to be invoked when an object is placed
    in the bucket. However, the function is not working correctly. This issue needs
    to be debugged and fixed. How can this be accomplished simply and quickly by the
    developer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Use the Lambda Monitoring Console to help debug the issue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Use AWS CloudTrail Logs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. Open an AWS support case, noting both the ARN of the Lambda function and
    the S3 bucket.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Use AWS CloudWatch Logs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You have been asked to help construct a serverless application using AWS Lambda.
    The application needs to be monitored; however, the company does not want to bring
    in any third-party services for monitoring. Although logging and tracking functions
    that call other functions can be tricky, what services from AWS can help you perform
    this task? (Choose 3)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. AWS CloudTrail
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. AWS CloudWatch
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. AWS Inspector
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. AWS X-Ray
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You have been brought into a company to help with their serverless architecture.
    They currently have an architecture that has multiple Lambda functions. These
    functions are invoking other functions and are acting as a state machine. The
    company has used older obsolete coding patterns to coordinate the state machine
    and is finding that the code is difficult to repair when it breaks. What service
    could you suggest to them that will help refactor their application and manage
    the state machine?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. AWS Data Pipeline
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. AWS Step Functions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. AWS Cognito
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. AWS Beanstalk
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a, b, d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
