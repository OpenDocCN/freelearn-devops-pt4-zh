<html><head></head><body>
		<div>
			<div id="_idContainer059" class="Content">
			</div>
		</div>
		<div id="_idContainer060" class="Content">
			<h1 id="_idParaDest-97">4. <a id="_idTextAnchor099"/>Automating architecture on Azure</h1>
		</div>
		<div id="_idContainer096" class="Content">
			<p>Every organization wants to reduce manual effort and error in their pursuits, and automation plays an important role in bringing about predictability, standardization, and consistency in both building a product and in operations. Automation has been the focus of almost every <strong class="bold">Chief information officer</strong> (<strong class="bold">CIO</strong>) and digital officer to ensure that their systems are highly available, scalable, reliable, and able to cater to the needs of their customers.</p>
			<p>Automation became more prominent with the advent of the cloud because new resources can be provisioned on the fly without the procurement of hardware resources. Hence, cloud companies want automation in almost all of their activities to reduce misuse, errors, governance, maintenance, and administration.</p>
			<p>In this chapter, we will evaluate Azure Automation as a major service that provides automation capabilities, along with its differentiating capabilities compared to other apparently similar-looking services. This chapter will cover the following:</p>
			<ul>
				<li>The Azure Automation landscape</li>
				<li>The Azure Automation service</li>
				<li>Resources for Azure Automation services</li>
				<li>Writing Azure Automation runbooks</li>
				<li>Webhooks</li>
				<li>Hybrid Workers</li>
			</ul>
			<p>Let's get started with Azure Automation, a cloud service for process automation.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor100"/>Automation</h2>
			<p>Automation is needed for the provisioning, operations, management, and deprovisioning of IT resources within an organization. <em class="italics">Figure 4.1</em> gives you a closer look at what each of these use cases represents:</p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/B15432_04_01.jpg" alt="Automation use cases, including provisioning, operation, management, and deprovisioning."/>
				</div>
			</div>
			<h6>Figure 4.1: Use cases of automation</h6>
			<p>Before the advent of the cloud, IT resources were primarily on-premises, and manual processes were often used for these activities. However, since cloud adoption has increased, automation has found increased focus and attention. The primary reason is that cloud technology's agility and flexibility provide an opportunity to provision, deprovision, and manage these resources on the fly in a tiny fraction of the time it used to take. Along with this flexibility and agility come the requirements to be more predictable and consistent with the cloud because it has become easy for organizations to create resources.</p>
			<p>Microsoft has a great tool for IT automation known as System Center Orchestrator. It is a great tool for automation for on-premises and cloud environments, but it is a product and not a service. It should be licensed and deployed on servers, and then runbooks can be executed to effect changes on cloud and on-premises environments.</p>
			<p>Microsoft realized that an automation solution was required that could be provided to customers as a service rather than bought and deployed as a product. Enter Azure Automation.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor101"/>Azure Automation</h2>
			<p>Azure provides a service called <strong class="bold">Azure Automation</strong>, which is an essential service for the automation of processes, activities, and tasks not only on Azure but also on-premises as well. Using Azure Automation, organizations can automate their processes and tasks related to processing, tear-down, operations, and the management of their resources across the cloud, IT environments, platforms, and languages. In <em class="italics">Figure 4.2</em>, we can see some features of Azure Automation:</p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/B15432_04_02.jpg" alt="Azure Automation features, including Cross-cloud, Cross-environment, Cross-platform, and cross-language."/>
				</div>
			</div>
			<h6>Figure 4.2: Features of Azure Automation</h6>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor102"/>Azure Automation architecture</h2>
			<p>Azure Automation comprises multiple components, and each of these components is completely decoupled from the others. Most of the integration happens at the data store level, and no components talk to each other directly.</p>
			<p>When an Automation account is created on Azure, it is managed by a management service. The management service is a single point of contact for all activities within Azure Automation. All requests from the portal, including saving, publishing, and creating runbooks, to execution, stopping, suspending, starting, and testing are sent to the automation management service and the service writes the request data to its data store. It also creates a job record in the data store and, based on the status of the runbook workers, assigns it to a worker.</p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/Figure_4.3.jpg" alt="Azure Automation architecture, showing how the Azure portal works with the Automation Management Service, Runbook Workers, and the Data Store for Runbook execution, Job creation, assignment, and execution."/>
				</div>
			</div>
			<h6>Figure 4.3: Azure Automation architecture</h6>
			<p>The worker keeps polling the database for any new jobs assigned to it. Once it finds a job assignment, it fetches the job information and starts executing the job using its execution engine. The results are written back to the database, read by the management service, and displayed back on the Azure portal.</p>
			<p>The Hybrid Workers that we will read about later in this chapter are also runbook workers, although they're not shown in <em class="italics">Figure 4.3</em>.</p>
			<p>The first step in getting started with Azure Automation is to create a new account. Once the account is created, all other artifacts are created within the account.</p>
			<p>The account acts as the main top-level resource that can be managed using Azure resource groups and its own control plane.</p>
			<p>The account should be created within a region, and all automation within this account gets executed on servers in that region.</p>
			<p>It is important to choose the region wisely, preferably close to other Azure resources that the Automation account integrates or manages, to reduce the network traffic and latency between the regions.</p>
			<p>The Automation account also supports a couple of <strong class="bold">Run As</strong> accounts, which can be created from the Automation account. As these Run As accounts are analogous to a service account, we mostly create them to execute actions. Even though we generally say Run As account, there are two types of Run As account: one is called the Azure Classic Run As account, and the other one is simply the Run As account, and both of them are used to connect to Azure subscriptions. The Azure Classic Run As account is for connecting to Azure using the <strong class="bold">Azure Service Management</strong> API, and the Run As account is for connecting to Azure using the <strong class="bold">Azure Resource Management</strong> (<strong class="bold">ARM</strong>) API.</p>
			<p>Both of these accounts use certificates to authenticate with Azure. These accounts can be created while creating the Automation account, or you can opt to create them at a later stage from the Azure portal.</p>
			<p>It is recommended to create these Run As accounts later instead of creating them while creating the Automation account because if they are created while setting up the Automation account, Automation will generate the certificates and service principals behind the scenes with the default configuration. If more control and custom configuration is needed for these Run As accounts, such as using an existing certificate or service principal, then the Run As accounts should be created after the Automation account.</p>
			<p>Once the Automation account is created, it provides a dashboard through which multiple automation scenarios can be enabled.</p>
			<p>Some of the important scenarios that can be enabled using an Automation account are related to:</p>
			<ul>
				<li>Process automation</li>
				<li>Configuration management</li>
				<li>Update management</li>
			</ul>
			<p>Automation is about writing scripts that are reusable and generic so that they can be reused in multiple scenarios. For example, an automation script should be generic enough to start and stop any VM in any resource group in any subscription and management group. Hardcoding VM server information, along with resource group, subscription, and management group names, will result in the creation of multiple similar scripts, and any change in one will undoubtedly result in changing all the scripts. It is better to create a single script for this purpose by using scripting parameters and variables, and you should ensure that the values are supplied by the executor for these artifacts.</p>
			<p>Let's take a closer look at each of the aforementioned scenarios.</p>
			<h3 id="_idParaDest-101"><a id="_idTextAnchor103"/>Process automation</h3>
			<p>Process automation refers to the development of scripts that reflect real-world processes. Process automation comprises multiple activities, where each activity performs a discrete task. Together, these activities form a complete process. The activities might be executed on the basis of whether the previous activity executed successfully or not.</p>
			<p>There are some requirements that any process automation requires from the infrastructure it is executed on. Some of them are as follows:</p>
			<ul>
				<li>The ability to create workflows</li>
				<li>The ability to execute for a long duration</li>
				<li>The ability to save the execution state when the workflow is not complete, which is also known as checkpointing and hydration</li>
				<li>The ability to resume from the last saved state instead of starting from the beginning</li>
			</ul>
			<p>The next scenario we are going to explore is configuration management.</p>
			<h3 id="_idParaDest-102"><a id="_idTextAnchor104"/>Configuration management</h3>
			<p>Configuration management refers to the process of managing the system configuration throughout its life cycle. Azure Automation State Configuration is the Azure configuration management service that allows users to write, manage, and compile PowerShell DSC configuration for cloud nodes and on-premises datacenters.</p>
			<p>Azure Automation State Configuration lets us manage Azure VMs, Azure Classic VMs, and physical machines or VMs (Windows/Linux) on-premises, and it also provides support for VMs in other cloud providers.</p>
			<p>One of the biggest advantages of Azure Automation State Configuration is it provides scalability. We can manage thousands of machines from a single central management interface. We can assign configurations to machines with ease and verify whether they are compliant with the desired configuration.</p>
			<p>Another advantage is that Azure Automation can be used as a repository to store your <strong class="bold">Desired State Configuration</strong> (<strong class="bold">DSC</strong>) configurations, and at the time of need they can be used.</p>
			<p>In the next section, we will be talking about update management.</p>
			<h3 id="_idParaDest-103"><a id="_idTextAnchor105"/>Update management</h3>
			<p>As you already know, update management is the responsibility of the customer to manage updates and patches when it comes to IaaS. The Update Management feature of Azure Automation can be used to automate or manage updates and patches for your Azure VMs. There are multiple methods by which you can enable Update Management on your Azure VM:</p>
			<ul>
				<li>From your Automation account</li>
				<li>By browsing the Azure portal</li>
				<li>From a runbook</li>
				<li>From an Azure VM</li>
			</ul>
			<p>Enabling it from an Azure VM is the easiest method. However, if you have a large number of VMs and need to enable Update Management, then you have to consider a scalable solution such as a runbook or from an Automation account.</p>
			<p>Now that you are clear about the scenarios, let's explore the concepts related to Azure Automation.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor106"/>Concepts related to Azure Automation</h2>
			<p>You now know that Azure Automation requires an account, which is called an Azure Automation account. Before we dive deeper, let's examine the concepts related to Azure Automation. Understanding the meaning of each of these terms is very important, as we are going to use these terms throughout this chapter. Let's start with runbook.</p>
			<h3 id="_idParaDest-105"><a id="_idTextAnchor107"/>Runbook </h3>
			<p>An Azure Automation runbook is a collection of scripting statements representing a single step in process automation or a complete process automation. It is possible to invoke other runbooks from a parent runbook, and these runbooks can be authored in multiple scripting languages. The languages that support authoring runbooks are as follows:</p>
			<ul>
				<li>PowerShell</li>
				<li>Python 2 (at the time of writing)</li>
				<li>PowerShell workflows</li>
				<li>Graphical PowerShell</li>
				<li>Graphical PowerShell workflows</li>
			</ul>
			<p>Creating an Automation account is very easy and can be done from the Azure portal. In the <strong class="bold">All Services</strong> blade, you can find <strong class="bold">Automation Account</strong>, or you can search for it in the Azure portal. As mentioned before, during creation you will get an option to create a Run As account. <em class="italics">Figure 4.4</em> shows the inputs required to create an Automation account:</p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/Figure_4.4.jpg" alt="Creating an Automation account in the ‘Add Automation Account’ pane and providing the details for the Automation account Name, Subscription, Resource group, and Location."/>
				</div>
			</div>
			<h6>Figure 4.4: Creating an Automation account</h6>
			<h3 id="_idParaDest-106"><a id="_idTextAnchor108"/>Run As accounts</h3>
			<p>Azure Automation accounts, by default, do not have access to any resources included in any Azure subscription, including the subscription in which they are hosted. An account needs access to an Azure subscription and its resources in order to manage them. A Run As account is one way to provide access to subscriptions and the resources within them.</p>
			<p>This is an optional exercise. There can be at most one Run As account for each classic and resource manager-based subscription; however, an Automation account might need to connect to numerous subscriptions. In such cases, it is advisable to create shared resources for each of the subscriptions and use them in runbooks.</p>
			<p>After creating the Automation account, navigate to the <strong class="bold">Run as accounts</strong> view on the portal and you will see that two types of accounts can be created. In <em class="italics">Figure 4.5</em>, you can see that the option to create an <strong class="bold">Azure Run As Account</strong> and an <strong class="bold">Azure Classic Run As Account</strong> is available in the <strong class="bold">Run as accounts</strong> blade:</p>
			<p>  </p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/Figure_4.5.jpg" alt="Clicking on the left-hand navigation to get into the ‘Run as accounts’ view and then creating a Run As account."/>
				</div>
			</div>
			<h6>Figure 4.5: Azure Run As Account options</h6>
			<p>These Run As accounts can be created using the Azure portal, PowerShell, and the CLI. For information about creating these accounts using PowerShell,  visit <a href="https://docs.microsoft.com/azure/automation/manage-runas-account">https://docs.microsoft.com/azure/automation/manage-runas-account</a>.</p>
			<p>In the case of the ARM Run As account, this script creates a new Azure AD service principal and a new certificate and provides contributor RBAC permissions to the newly created service principal on the subscription.</p>
			<h3 id="_idParaDest-107"><a id="_idTextAnchor109"/>Jobs </h3>
			<p>The submission of a job request is not linked directly to the execution of the job request because of Azure Automation's decoupled architecture. The linkage between them is indirect using a data store. When a request to execute a runbook is received by Automation, it creates a new record in its database with all the relevant information. There is another service running on multiple servers, known as Hybrid Runbook Worker, within Azure, which looks for any new entries added to the database for the execution of a runbook. Once it sees a new record, it locks the record so that no other service can read it and then executes the runbook.</p>
			<h3 id="_idParaDest-108"><a id="_idTextAnchor110"/>Assets</h3>
			<p>Azure Automation assets refer to shared artifacts that can be used across runbooks. They are shown in <em class="italics">Figure 4.6</em>:</p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/Figure_4.6.jpg" alt="The Shared artifacts in Azure Automationare listed under ‘Shared Resources’ as Credentials, Connections, Certificates, and Variables."/>
				</div>
			</div>
			<h6>Figure 4.6: Shared artifacts in Azure Automation</h6>
			<h3 id="_idParaDest-109"><a id="_idTextAnchor111"/>Credentials</h3>
			<p>Credentials refers to the secrets, such as the username/password combination, that can be used to connect to other integration services that need authentication. These credentials can be used within runbooks using the <strong class="inline">Get-AutomationPSCredential</strong> PowerShell cmdlet along with its associated name:</p>
			<p class="snippet">$myCredential = Get-AutomationPSCredential -Name 'MyCredential'</p>
			<p>The Python syntax requires that we import the <strong class="inline">automationassets</strong> module and use the <strong class="inline">get_automation_credential</strong> function along with the associated credential name:</p>
			<p class="snippet">import automationassets</p>
			<p class="snippet">cred = automationassets.get_automation_credential("credtest")</p>
			<h3 id="_idParaDest-110"><a id="_idTextAnchor112"/>Certificates</h3>
			<p>Certificates refers to the X.509 certificate that can be purchased from certificate authorities or can be self-signed. Certificates are used for identification purposes in Azure Automation. Every certificate has a pair of keys known as private/public keys. The private key is used for creating a certificate asset in Azure Automation, and the public key should be available in the target service. Using the private key, the Automation account can create a digital signature and append it to the request before sending it to the target service. The target service can fetch the details (the hash) from the digital signature using the already available public key and ascertain the identity of the sender of the request.</p>
			<p>Certificate assets store certificate information and keys in Azure Automation. These certificates can be used directly within runbooks, and they are also used by the connection's assets. The next section shows the way to consume certificates in a connection asset. The Azure service principal connection asset uses a certificate thumbprint to identify the certificate it wants to use, while other types of connection use the name of the certificate asset to access the certificate.</p>
			<p>A certificate asset can be created by providing a name and uploading a certificate. It is possible to upload public certificates (<strong class="inline">.cer</strong> files) as well as private certificates (<strong class="inline">.pfx</strong> files). The private part of the certificate also has a password that should be used before accessing the certificate.</p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/Figure_4.7.jpg" alt="Navigating to the Certificates blade and then selecting the ‘Add a certificate button’, which opens the ‘Add a certificate’ pane. Here, we add the certificate details."/>
				</div>
			</div>
			<p> </p>
			<h6>Figure 4.7: Adding a certificate to Azure Automation</h6>
			<p>Creating a certificate involves providing a name and a description, uploading the certificate, providing a password (in the case of <strong class="inline">.pfx</strong> files), and informing the user whether the certificate is exportable or not.</p>
			<p>There should be a certificate available before this certificate asset can be created. Certificates can be purchased from certificate authorities or can be generated. Generated certificates are known as self-signed certificates. It is always a good practice to use certificates from certificate authorities for important environments such as production environments. It is fine to use self-signing certificates for development purposes.</p>
			<p>To generate a self-signed certificate using PowerShell, use this command:</p>
			<p class="snippet">$cert = New-SelfSignedCertificate -CertStoreLocation "Cert:\CurrentUser\my" -KeySpec KeyExchange -Subject "cn=azureforarchitects"</p>
			<p>This will create a new certificate in the current user certificate store in your personal folder. Since this certificate also needs to be uploaded to the Azure Automation certificate asset, it should be exported to the local file system, as shown in <em class="italics">Figure 4.8</em>:</p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/Figure_4.8.jpg" alt="Exporting the certificate to the local filesystem using the ‘Certificate Export Wizard’."/>
				</div>
			</div>
			<h6>Figure 4.8: Exporting the certificate</h6>
			<p>When exporting the certificate, the private key should also be exported, so <strong class="bold">Yes, export the private key</strong> should be selected.</p>
			<p>Select the <strong class="bold">Personal Information Exchange</strong> option, and the rest of the values should remain as the defaults.</p>
			<p>Provide a password and the filename <strong class="inline">C:\azureforarchitects.pfx</strong>, and the export should be successful.</p>
			<p>Connecting to Azure can be done in multiple ways. However, the most secure is by way of a certificate. A service principal is created on Azure using the certificate. The service principal can be authenticated against using the certificate. The private key of the certificate is with the user and the public part is with Azure. In the next section, a service principal will be created using the certificate created in this section.</p>
			<h3 id="_idParaDest-111"><a id="_idTextAnchor113"/>Creating a service principal using certificate credentials</h3>
			<p>A service principal can be created using the Azure portal, Azure CLI, or Azure PowerShell. The script for creating a service principal using Azure PowerShell is available in this section.</p>
			<p>After logging into Azure, the certificate created in the previous section is converted into base64 encoding. A new service principal, <strong class="inline">azureforarchitects</strong>, is created, and the certificate credential is associated with the newly created service principal. Finally, the new service principal is provided contributor role-based access control permissions on the subscription:</p>
			<p class="snippet">Login-AzAccount</p>
			<p class="snippet">$certKey = [system.Convert]::ToBase64String($cert.GetRawCertData())</p>
			<p class="snippet">$sp =  New-AzADServicePrincipal -DisplayName "azureforarchitects"</p>
			<p class="snippet">New-AzADSpCredential -ObjectId $sp.Id -CertValue $certKey -StartDate $cert.NotBefore -EndDate $cert.NotAfter</p>
			<p class="snippet">New-AzRoleAssignment -RoleDefinitionName contributor -ServicePrincipalName $sp.ApplicationId </p>
			<p class="snippet">Get-AzADServicePrincipal -ObjectId $sp.Id</p>
			<p class="snippet">$cert.Thumbprint</p>
			<p class="snippet">Get-AzSubscription  </p>
			<p>To create a connection asset, the application ID can be obtained using the <strong class="inline">Get-AzADServicePrincipal</strong> cmdlet, and the result is shown in <em class="italics">Figure 4.9</em>:</p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/Figure_4.9.jpg" alt="The output of the Get-AzADServicePrincipal command, which displays the service principal name, Application ID, Object ID, and so on."/>
				</div>
			</div>
			<h6>Figure 4.9: Checking the service principal</h6>
			<p>The certificate thumbprint can be obtained using the certificate reference along with <strong class="inline">SubscriptionId</strong>, which can be obtained using the <strong class="inline">Get-AzSubscription</strong> cmdlet.</p>
			<h3 id="_idParaDest-112"><a id="_idTextAnchor114"/>Connections</h3>
			<p>Connection assets are used for creating connection information to external services. In this regard, even Azure is considered as an external service. Connection assets hold all the necessary information needed for successfully connecting to a service. There are three connection types provided out of the box by Azure Automation:</p>
			<ul>
				<li>Azure  </li>
				<li>Azure classic certificate</li>
				<li>Azure service principal</li>
			</ul>
			<p>It is a good practice to use Azure service principal to connect to Azure Resource Manager resources and to use the Azure classic certificate for Azure classic resources. It is important to note that Azure Automation does not provide any connection type to connect to Azure using credentials such as a username and password.</p>
			<p>Azure and Azure classic certificates are similar in nature. They both help us connect to Azure Service management API-based resources. In fact, Azure Automation creates an Azure classic certificate connection while creating a Classic Run As account.</p>
			<p>Azure service principal is used internally by Run As accounts to connect to Azure Resource Manager-based resources.</p>
			<p>A new connection asset of type <strong class="bold">AzureServicePrincipal</strong> is shown in <em class="italics">Figure 4.10</em>. It needs:</p>
			<ul>
				<li>The name of the connection. It is mandatory to provide a name.</li>
				<li>A description of the connection. This value is optional.</li>
				<li>Select an appropriate <strong class="bold">Type</strong>. It is mandatory to select an option; <strong class="inline">AzureServicePrincipal</strong> is selected for creating a connection asset for all purposes in this chapter.</li>
				<li><strong class="bold">ApplicationId</strong>, also known as <strong class="inline">clientid</strong>, is the application ID generated during the creation of a service principal. The next section shows the process of creating a service principal using Azure PowerShell. It is mandatory to provide an application ID.</li>
				<li><strong class="bold">TenantId</strong> is the unique identifier of the tenant. This information is available from the Azure portal or by using the <strong class="inline">Get-AzSubscription</strong> cmdlet. It is mandatory to provide a tenant identifier.</li>
				<li><strong class="bold">CertificateThumbprint</strong> is the certificate identifier. This certificate should already be uploaded to Azure Automation using the certificate asset. It is mandatory to provide a certificate thumbprint.</li>
				<li><strong class="bold">SubscriptionId</strong> is the identifier of the subscription. It is mandatory to provide a subscription ID.</li>
			</ul>
			<p>You can add a new connection using the <strong class="bold">Connections</strong> blade in the Automation account, as shown in <em class="italics">Figure 4.10</em>:</p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/Figure_4.10.jpg" alt="Navigating to the Connections blade and selecting the ‘Add a connection’ button and then adding the connection details."/>
				</div>
			</div>
			<h6>Figure 4.10: Adding a new connection to the Automation Account</h6>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor115"/>Runbook authoring and execution</h2>
			<p>Azure Automation allows the creation of automation scripts known as runbooks. Multiple runbooks can be created using the Azure portal or PowerShell ISE. They can also be imported from <strong class="bold">Runbook Gallery</strong>. The gallery can be searched for specific functionality, and the entire code is displayed within the runbook.</p>
			<p>A runbook can accept parameter values just like a normal PowerShell script. The next example takes a single parameter named <strong class="inline">connectionName</strong> of type <strong class="inline">string</strong>. It is mandatory to supply a value for this parameter when executing this runbook:</p>
			<p class="snippet">param(</p>
			<p class="snippet">    [parameter(mandatory=$true)]</p>
			<p class="snippet">    [string] $connectionName</p>
			<p class="snippet">)</p>
			<p class="snippet">$connection = Get-AutomationConnection  -name $connectionName  </p>
			<p class="snippet">$subscriptionid = $connection.subscriptionid</p>
			<p class="snippet">$tenantid = $connection.tenantid</p>
			<p class="snippet">$applicationid = $connection.applicationid</p>
			<p class="snippet">$cretThumbprint = $connection.CertificateThumbprint</p>
			<p class="snippet">Login-AzureRMAccount -CertificateThumbprint $cretThumbprint -ApplicationId $applicationid -ServicePrincipal -Tenant $tenantid  </p>
			<p class="snippet">Get-AzureRMVM</p>
			<p>The runbook uses the <strong class="inline">Get-AutomationConnection</strong> cmdlet to reference the shared connection asset. The name of the asset is contained within the parameter value. Once the reference to the connection asset has been made, the values from the connection reference are populated into the <strong class="inline">$connection</strong> variable, and subsequently, they are assigned to multiple other variables.</p>
			<p>The <strong class="inline">Login-AzureRMAccount</strong> cmdlet authenticates with Azure, and it supplies the values obtained from the connection object. It uses the service principal created earlier in this chapter for authentication.</p>
			<p>Finally, the runbook invokes the <strong class="inline">Get-AzureRMVm</strong> cmdlet to list all the VMs in the subscription.</p>
			<p>By default, Azure Automation still provides <strong class="inline">AzureRM</strong> modules for working with Azure. It does not install <strong class="inline">Az</strong> modules by default. Later we will install an <strong class="inline">Az</strong> module manually in the Azure Automation account and use cmdlets in runbooks.</p>
			<h3 id="_idParaDest-114"><a id="_idTextAnchor116"/>Parent and child runbooks</h3>
			<p>Runbooks have a life cycle, from being authored to being executed. These life cycles can be divided into authoring status and execution status.</p>
			<p>The authoring life cycle is shown in <em class="italics">Figure 4.11</em>.</p>
			<p>When a new runbook is created, it has the <strong class="bold">New</strong> status and as it is edited and saved multiple times, it takes the <strong class="bold">In edit</strong> status, and finally, when it is published, the status changes to <strong class="bold">Published</strong>. It is also possible to edit a published runbook, and in that case, it goes back to the <strong class="bold">In edit</strong> status.</p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/Figure_4.11.jpg" alt="A flow diagram showing the authoring life cycle with three stages—New, In edit, and Published."/>
				</div>
			</div>
			<h6>Figure 4.11: Authoring life cycle</h6>
			<p>The execution life cycle is described next.</p>
			<p>The life cycle starts with the beginning of a runbook execution request. A runbook can be executed in multiple ways:</p>
			<ul>
				<li>Manually from the Azure portal</li>
				<li>By using a parent runbook as a child runbook</li>
				<li>By means of a webhook</li>
			</ul>
			<p>It does not matter how a runbook is initiated; the life cycle remains the same. A request to execute the runbook is received by the Automation engine. The Automation engine creates a job and assigns it to a runbook worker. Currently, the runbook has a status of <strong class="bold">Queued</strong>.</p>
			<p>There are multiple runbook workers, and the chosen one picks up the job request and changes the status to <strong class="bold">Starting</strong>. At this stage, if there are any scripting and parsing issues in the script, the status changes to <strong class="bold">Failed</strong> and the execution is halted.</p>
			<p>Once the runbook execution is started by the worker, the status is changed to <strong class="bold">Running</strong>. The runbook can have multiple different statuses once it is running.</p>
			<p>The runbook will change its status to <strong class="bold">Completed</strong> if the execution happens without any unhandled and terminating exceptions.</p>
			<p>The running runbook can be manually stopped by the user, and it will have the <strong class="bold">Stopped</strong> status.</p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/Figure_4.12.jpg" alt="A block diagram displaying the execution life cycle for runbooks."/>
				</div>
			</div>
			<h6>Figure 4.12: The execution life cycle for runbooks</h6>
			<p>The user can also suspend and resume the execution of the runbook.</p>
			<h3 id="_idParaDest-115"><a id="_idTextAnchor117"/>Creating a runbook</h3>
			<p>A runbook can be created from the Azure portal by going to the <strong class="bold">Runbook</strong> menu item in the left navigation pane. A runbook has a name and type. The type determines the scripting language used for creating the runbook. We have already discussed the possible languages, and in this chapter, PowerShell will be used primarily for all examples.</p>
			<p>Creating a PowerShell runbook is exactly the same as creating a PowerShell script. It can declare and accept multiple parameters—the parameters can have attributes such as data types, which are mandatory (just like any PowerShell parameter attributes). It can invoke PowerShell cmdlets whose modules are available and already loaded and declared, and it can invoke functions and return output.</p>
			<p>A runbook can also invoke another runbook. It can invoke a child runbook inline within the original process and context or in a separate process and context.</p>
			<p>Invoking a runbook inline is similar to invoking a PowerShell script. The next example invokes a child runbook using the inline approach:</p>
			<p class="snippet">.\ConnectAzure.ps1 -connectionName "azureforarchitectsconnection"</p>
			<p class="snippet">Get-AzSqlServer</p>
			<p>In the preceding code, we saw how the <strong class="inline">ConnectAzure</strong> runbook accepts a parameter named <strong class="inline">connectionName</strong> and an appropriate value is supplied to it. This runbook creates a connection to Azure after authenticating with it using a service principal. Check out the syntax for invoking the child runbook. It is very similar to invoking a general PowerShell script along with parameters.</p>
			<p>The next line of code, <strong class="inline">Get-AzVm</strong>, fetches the relevant information from Azure and lists the VM details. You will notice that although the authentication happens within a child runbook, the <strong class="inline">Get-AzVm</strong> cmdlet succeeds and lists all the VMs in the subscription because the child runbook executes in the same job as that of the parent runbook, and they share the context.</p>
			<p>Alternatively, a child runbook can be invoked using the <strong class="inline">Start-AzurermAutomationRunbook</strong> cmdlet provided by Azure Automation. This cmdlet accepts the name of the Automation account, the resource group name, and the name of the runbook along with parameters, as mentioned here:</p>
			<p class="snippet">$params = @{"connectionName"="azureforarchitectsconnection"}</p>
			<p class="snippet">$job = Start-AzurermAutomationRunbook '</p>
			<p class="snippet">    –AutomationAccountName 'bookaccount' '</p>
			<p class="snippet">    –Name 'ConnectAzure' '</p>
			<p class="snippet">    -ResourceGroupName 'automationrg' -parameters $params</p>
			<p class="snippet">if($job -ne $null) {</p>
			<p class="snippet">    Start-Sleep -s 100</p>
			<p class="snippet">    $job = Get-AzureAutomationJob -Id $job.Id -AutomationAccountName 'bookaccount'</p>
			<p class="snippet">    if ($job.Status -match "Completed") {</p>
			<p class="snippet">        $jobout = Get-AzureAutomationJobOutput '</p>
			<p class="snippet">                                    -Id $job.Id '</p>
			<p class="snippet">                                    -AutomationAccountName 'bookaccount' '</p>
			<p class="snippet">                                    -Stream Output</p>
			<p class="snippet">                    if ($jobout) {Write-Output $jobout.Text}</p>
			<p class="snippet">    }</p>
			<p class="snippet">}</p>
			<p>Using this approach creates a new job that's different from the parent job, and they run in different contexts.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor118"/>Using Az modules</h2>
			<p>So far, all examples have used <strong class="inline">AzureRM</strong> modules. The previously shown runbooks will be re-written to use cmdlets from the <strong class="inline">Az</strong> module.</p>
			<p>As mentioned before, <strong class="inline">Az</strong> modules are not installed by default. They can be installed using the <strong class="bold">Modules gallery</strong> menu item in Azure Automation.</p>
			<p>Search for <strong class="inline">Az</strong> in the gallery and the results will show multiple modules related to it. If the <strong class="inline">Az</strong> module is selected to be imported and installed, it will throw an error saying that its dependent modules are not installed and that they should be installed before installing the current module. The module can be found on the <strong class="bold">Modules gallery</strong> blade by searching for <strong class="inline">Az</strong>, as shown in <em class="italics">Figure 4.13</em>:</p>
			<p>  </p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/Figure_4.13.jpg" alt="Searching the Az module on the Modules gallery blade."/>
				</div>
			</div>
			<h6>Figure 4.13: Finding the Az module on the Modules gallery blade</h6>
			<p>Instead of selecting the <strong class="inline">Az</strong> module, select <strong class="bold">Az.Accounts</strong> and import the module by following the wizard, as shown in <em class="italics">Figure 4.14</em>:</p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/Figure_4.14.jpg" alt="Importing the Az.Accounts module."/>
				</div>
			</div>
			<h6>Figure 4.14: Importing the Az.Accounts module</h6>
			<p>After installing <strong class="inline">Az.Accounts</strong>, the <strong class="inline">Az.Resources</strong> module can be imported. Azure virtual machine-related cmdlets are available in the <strong class="inline">Az.Compute</strong> module, and it can also be imported using the same method as we used to import <strong class="inline">Az.Accounts</strong>.</p>
			<p>Once these modules are imported, the runbooks can use the cmdlets provided by these modules. The previously shown <strong class="inline">ConnectAzure</strong> runbook has been modified to use the <strong class="inline">Az</strong> module:</p>
			<p class="snippet">param(</p>
			<p class="snippet">    [parameter(mandatory=$true)]</p>
			<p class="snippet">    [string] $connectionName</p>
			<p class="snippet">)</p>
			<p class="snippet">$connection = Get-AutomationConnection  -name $connectionName  </p>
			<p class="snippet">$subscriptionid = $connection.subscriptionid</p>
			<p class="snippet">$tenantid = $connection.tenantid</p>
			<p class="snippet">$applicationid = $connection.applicationid</p>
			<p class="snippet">$cretThumbprint = $connection.CertificateThumbprint</p>
			<p class="snippet">Login-AzAccount -CertificateThumbprint $cretThumbprint -ApplicationId $applicationid -ServicePrincipal -Tenant $tenantid  -SubscriptionId  $subscriptionid </p>
			<p class="snippet">Get-AzVm</p>
			<p>The last two lines of the code are important. They are using <strong class="inline">Az</strong> cmdlets instead of <strong class="inline">AzureRM</strong> cmdlets.</p>
			<p>Executing this runbook will give results similar to this:</p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/Figure_4.15.jpg" alt="Output showing that the Az.Accounts module successfully imported and the status is displayed as completed."/>
				</div>
			</div>
			<h6>Figure 4.15: The Az.Accounts module successfully imported</h6>
			<p>In the next section, we will work with webhooks.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor119"/>Webhooks</h2>
			<p>Webhooks became famous after the advent of REST endpoints and JSON data payloads. Webhooks are an important concept and architectural decision in the extensibility of any application. Webhooks are placeholders that are left within special areas of an application so that the user of the application can fill those placeholders with endpoint URLs containing custom logic. The application will invoke the endpoint URL, automatically passing in the necessary parameters, and then execute the login available therein.</p>
			<p>Azure Automation runbooks can be invoked manually from the Azure portal. They can also be invoked using PowerShell cmdlets and the Azure CLI. There are SDKs available in multiple languages that are capable of invoking runbooks.</p>
			<p>Webhooks are one of the most powerful ways to invoke a runbook. It is important to note that runbooks containing the main logic should never be exposed directly as a webhook. They should be called using a parent runbook, and the parent runbook should be exposed as a webhook. The parent runbook should ensure that appropriate checks are made before invoking the main child runbook.</p>
			<p>The first step in creating a webhook is to author a runbook normally, as done previously. After a runbook has been authored, it will be exposed as a webhook.</p>
			<p>A new PowerShell-based runbook named <strong class="inline">exposedrunbook</strong> is created. This runbook takes a single parameter, <strong class="inline">$WebhookData</strong>, of the object type. It should be named <strong class="inline">verbatim</strong>. This object is created by the Azure Automation runtime and is supplied to the runbook. The Azure Automation runtime constructs this object after obtaining the HTTP request header values and body content and fills in the <strong class="inline">RequestHeader</strong> and <strong class="inline">RequestBody</strong> properties of this object:</p>
			<p class="snippet">param(</p>
			<p class="snippet">    [parameter(mandatory=$true)]</p>
			<p class="snippet">    [object] $WebhookData</p>
			<p class="snippet">)</p>
			<p class="snippet">$webhookname = $WebhookData.WebhookName</p>
			<p class="snippet">$headers = $WebhookData.RequestHeader</p>
			<p class="snippet">$body = $WebhookData.RequestBody</p>
			<p class="snippet">Write-output "webhook header data"</p>
			<p class="snippet">Write-Output $webhookname</p>
			<p class="snippet">Write-output $headers.message</p>
			<p class="snippet">Write-output $headers.subject</p>
			<p class="snippet"> $connectionname = (ConvertFrom-Json -InputObject $body)</p>
			<p class="snippet">./connectAzure.ps1 -connectionName  $connectionname[0].name</p>
			<p>The three important properties of this object are <strong class="inline">WebhookName</strong>, <strong class="inline">RequestHeader</strong>, and <strong class="inline">RequestBody</strong>. The values are retrieved from these properties and sent to the output stream by the runbook.</p>
			<p>The header and body content can be anything that the user supplies when invoking the webhook. These values get filled up into the respective properties and become available within the runbook. In the previous example, there are two headers set by the caller, namely <strong class="inline">message</strong> and <strong class="inline">status</strong> header. The caller will also supply the name of the shared connection to be used as part of the body content.</p>
			<p>After the runbook is created, it should be published before a webhook can be created. After publishing the runbook, clicking on the <strong class="bold">Webhook</strong> menu at the top starts the process of creating a new webhook for the runbook, as shown in <em class="italics">Figure 4.16</em>:</p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/Figure_4.16.jpg" alt="Navigating to the Webhook menu and creating a new webhook."/>
				</div>
			</div>
			<h6>Figure 4.16: Creating a webhook</h6>
			<p>A name for the webhook should be provided. This value is available within the runbook using the <strong class="inline">WebhookData</strong> parameter with the <strong class="inline">WebhookName</strong> property name.</p>
			<p>The webhook can be in the <strong class="inline">enabled</strong> or <strong class="inline">disabled</strong> state, and it can expire at a given date and time. It also generates a URL that is unique for this webhook and runbook. This URL should be provided to anyone who wishes to invoke the webhook.</p>
			<h3 id="_idParaDest-118"><a id="_idTextAnchor120"/>Invoking a webhook</h3>
			<p>Webhooks are invoked as HTTP requests using the <strong class="inline">POST</strong> method. When a webhook is invoked, the HTTP request lands up with Azure Automation to start a runbook. It creates the <strong class="inline">WebHookData</strong> object, filling it with the incoming HTTP header and body data, and creates a job to be picked up by a runbook worker. This call uses the webhook URL generated in the previous step.</p>
			<p>The webhook can be invoked using Postman, by any code having the capability of calling a <strong class="inline">REST</strong> endpoint using the <strong class="inline">POST</strong> method. In the next example, PowerShell will be used to invoke the webhook:</p>
			<p class="snippet">$uri = "https://s16events.azure-automation.net/webhooks?token=rp0w93L60fAPYZQ4vryxl%2baN%2bS1Hz4F3qVdUaKUDzgM%3d"</p>
			<p class="snippet">$connection  = @(</p>
			<p class="snippet">            @{  name="azureforarchitectsconnection"}</p>
			<p class="snippet">           </p>
			<p class="snippet">        )</p>
			<p class="snippet">$body = ConvertTo-Json -InputObject $ connection  </p>
			<p class="snippet">$header = @{ subject="VMS specific to Ritesh";message="Get all virtual machine details"}</p>
			<p class="snippet">        </p>
			<p class="snippet">$response = Invoke-WebRequest -Method Post -Uri $uri -Body $body -Headers $header</p>
			<p class="snippet">$jobid = (ConvertFrom-Json ($response.Content)).jobids[0] </p>
			<p>The PowerShell code declares the URL for the webhook and constructs the body in JSON format, with <strong class="inline">name</strong> set to <strong class="inline">azureforarchitectsconnection</strong> and a header with two header name-value pairs – <strong class="inline">subject</strong> and <strong class="inline">message</strong>. Both the header and body data can be retrieved in the runbook using the <strong class="inline">WebhookData</strong> parameter.</p>
			<p>The <strong class="inline">invoke-webrequest</strong> cmdlet raises the request on the previously mentioned endpoint using the <strong class="inline">POST</strong> method, supplying both the header and the body.</p>
			<p>The request is asynchronous in nature, and instead of the actual runbook output, the job identifier is returned as an HTTP response. It is also available within the response content. The job is shown in <em class="italics">Figure 4.17</em>:</p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/Figure_4.17.jpg" alt="The job details displayed in the portal with the Id, Status, and the job name."/>
				</div>
			</div>
			<h6>Figure 4.17: Checking the job</h6>
			<p>Clicking on <strong class="inline">WEBHOOKDATA</strong> shows the values that arrived in the runbook automation service in the HTTP request:</p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/Figure_4.18.jpg" alt="The values from WEBHOOKDATA, which is arrived in the runbook automation service in the HTTP request (here, displaying the name ‘azureforarchitectsconnection’)."/>
				</div>
			</div>
			<h6>Figure 4.18: Verifying the output</h6>
			<p>Clicking on the output menu shows the list of VMs and SQL Server in the subscription.</p>
			<p>The next important concepts in Azure Automation are Azure Monitor and Hybrid Workers, and the next sections will explain them in detail.</p>
			<h3 id="_idParaDest-119"><a id="_idTextAnchor121"/>Invoking a runbook from Azure Monitor</h3>
			<p>Azure Automation runbooks can be invoked as responses to alerts generated within Azure. Azure Monitor is the central service that manages logs and metrics across resources and resource groups in a subscription. You can use Azure Monitor to create new alert rules and definitions that, when triggered, can execute Azure Automation runbooks. They can invoke an Azure Automation runbook in its default form or a webhook that in turn can execute its associated runbook. This integration between Azure Monitor and the ability to invoke runbooks opens numerous automation opportunities to autocorrect the environment, scale up and down compute resources, or take corrective actions without any manual intervention.</p>
			<p>Azure alerts can be created and configured in individual resources and resource levels, but it is always a good practice to centralize alert definitions for easy and better maintenance and administration.</p>
			<p>Let's go through the process of associating a runbook with an alert and invoking the runbook as part of the alert being raised.</p>
			<p>The first step is to create a new alert, as shown in <em class="italics">Figure 4.19</em>:</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/Figure_4.19.jpg" alt="Selecting the ‘Alerts’ option from the left-hand navigation and clicking on the ‘New alert rule’ button."/>
				</div>
			</div>
			<p> </p>
			<h6>Figure 4.19: Creating an alert rule</h6>
			<p>Select a resource that should be monitored and evaluated for alert generation. A resource group has been selected from the list, and it automatically enables all resources within the resource group. It is possible to remove the resource selections from the resource group:</p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/Figure_4.20.jpg" alt="Selecting the checkboxesfor the scope of the alert from the available resources."/>
				</div>
			</div>
			<h6>Figure 4.20: Selecting the scope of the alert</h6>
			<p>Configure the condition and rules that should get evaluated. Select the <strong class="bold">Power Off Virtual Machine</strong> signal name after selecting <strong class="bold">Activity Log</strong> as the <strong class="bold">Signal type</strong>:</p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/Figure_4.21.jpg" alt="Selecting the signal name in the ‘Configure signal logic’ pane."/>
				</div>
			</div>
			<h6>Figure 4.21: Selecting the signal type</h6>
			<p>The resultant window will allow you to configure the <strong class="bold">Alert logic/condition</strong>. Select <strong class="inline">critical</strong> for <strong class="bold">Event Level</strong>, and set <strong class="bold">Status</strong> to <strong class="inline">Succeeded</strong>:</p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/Figure_4.22.jpg" alt="Setting up the alert logic by configuring the values for the option—event level, status, and event initiated by."/>
				</div>
			</div>
			<h6>Figure 4.22: Setting up the alert logic</h6>
			<p>After determining the alert condition comes the most important configuration, which configures the response to the alert by invoking a runbook. We can use <strong class="bold">Action groups</strong> to configure the response to an alert. It provides numerous options to invoke an Azure function, webhook, or Azure Automation runbook, as well as to send emails and SMS.</p>
			<p>Create an action group by providing a name, a short name, its hosting subscription, a resource group, and an <strong class="bold">Action name</strong>. Corresponding to <strong class="bold">Action name</strong> select the <strong class="inline">Automation Runbook</strong> option as <strong class="bold">Action Type</strong>:</p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/Figure_4.23.jpg" alt="Configuring the action group by providing the action name and action type."/>
				</div>
			</div>
			<h6>Figure 4.23 Configuring the a<a id="_idTextAnchor122"/>ction group</h6>
			<p>Selecting an automation runbook will open another blade for selecting an appropriate Azure Automation account and runbook. Several runbooks are available out of the box, and one of them has been used here:</p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/Figure_4.24.jpg" alt="Using the ‘ConfigureRunbook‘ pane to create arunbook."/>
				</div>
			</div>
			<h6>Figure 4.24 Creating the runbook</h6>
			<p>Finally, provide a name and hosting resource group to create a new alert.</p>
			<p>If the VM is deallocated manually, the alert condition gets satisfied and it will raise an alert:</p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/Figure_4.25.jpg" alt="Testing the alerts by providing a name and hosting resource group to create a new alert."/>
				</div>
			</div>
			<h6>Figure 4.25 Testing alerts</h6>
			<p>If you check the details of the VM after a few seconds, you should see that the VM is being deleted:</p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/Figure_4.26.jpg" alt="The details of the VM displayed in the portal, showing the status ‘Deleting’."/>
				</div>
			</div>
			<h6>Figure 4.26 Verifying the results</h6>
			<h3 id="_idParaDest-120"><a id="_idTextAnchor123"/>Hybrid Workers</h3>
			<p>So far, all the execution of runbooks has primarily been on infrastructure provided by Azure. The runbook workers are Azure compute resources that are provisioned by Azure with appropriate modules and assets deployed in them. Any execution of runbooks happens on this compute. However, it is possible for users to bring their own compute and execute the runbook on this user-provided compute rather than on default Azure compute.</p>
			<p>This has multiple advantages. The first and foremost is that the entire execution and its logs are owned by the user with Azure having no visibility of it. Second, the user-provided compute could be on any cloud, as well as on-premises.</p>
			<p><strong class="bold">Adding a Hybrid Worker involves multiple steps</strong></p>
			<ul>
				<li>First and foremost, an agent needs to be installed on the user-provided compute. Microsoft provides a script that can download and configure the agent automatically. This script is available from <a href="https://www.powershellgallery.com/packages/New-OnPremiseHybridWorker/1.6">https://www.powershellgallery.com/packages/New-OnPremiseHybridWorker/1.6</a>.<p>The script can also be executed from PowerShell ISE as an administrator from within the server that should be part of the Hybrid Worker using the following command:</p><p class="snippet">Install-Script -Name New-OnPremiseHybridWorker -verbose</p></li>
				<li>After the script is installed, it can be executed along with parameters related to the Azure Automation account details. A name is also provided for the Hybrid Worker. If the name does not exist already, it will be created; if it exists, the server will be added to the existing Hybrid Worker. It is possible to have multiple servers within a single Hybrid Worker, and it is possible to have multiple Hybrid Workers as well:<p class="snippet">New-OnPremiseHybridWorker.ps1 -AutomationAccountName bookaccount -AAResourceGroupName automationrg '</p><p class="snippet">-HybridGroupName "localrunbookexecutionengine" '</p><p class="snippet">-SubscriptionID xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx  </p></li>
				<li>Once the execution finishes, navigating back to the portal will show an entry for a Hybrid Worker, as shown in <em class="italics">Figure 4.27</em>:<div id="_idContainer087" class="IMG---Figure"><img src="image/Figure_4.27.jpg" alt="An entry for a Hybrid Worker displayed in the portal."/></div></li>
			</ul>
			<h6>Figure 4.27: Checking user Hybrid Worker groups</h6>
			<ul>
				<li>If, at this time, an Azure runbook is executed that has a dependency on the <strong class="inline">Az</strong> module and a custom certificate uploaded to the certificate asset, it will fail with errors related to the <strong class="inline">Az</strong> module and the certificate not being found:<div id="_idContainer088" class="IMG---Figure"><img src="image/Figure_4.28.jpg" alt="The Errors tab in the lower pane, displaying the error details on running the Azure runbook."/></div></li>
			</ul>
			<h6>Figure 4.28: Checking errors</h6>
			<ul>
				<li>Install the <strong class="inline">Az</strong> module using the following command on the server:<p class="snippet">Install-module -name Az -AllowClobber -verbose</p><p>It is also important to have the <strong class="inline">.pfx</strong> certificate available on this server. The previously exported certificate should be copied to the server and installed manually.</p></li>
				<li>After installation of the <strong class="inline">Az</strong> module and certificate, re-executing the runbook on the Hybrid Worker is shown in <em class="italics">Figure 4.29</em>, and it should show the list of VMs in the subscription:<div id="_idContainer089" class="IMG---Figure"><img src="image/Figure_4.29.jpg" alt="In the ‘Start Runbook’ pane, adding the connection name as ‘azureforarchitectsconnection’, running settings as Hybrid Workers, and the Hybrid Worker group as ‘localrunbookexecutionengine’."/></div></li>
			</ul>
			<h6>Figure 4.29: Setting up a runbook to run on a Hybrid Worker </h6>
			<p>When we discussed different scenarios, we talked about configuration management. In the next section, we will be discussing configuration management with Azure Automation in more detail.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor124"/>Azure Automation State Configuration</h2>
			<p>Azure Automation provides a <strong class="bold">Desired State Configuration</strong> (<strong class="bold">DSC</strong>) pull server along with every Azure Automation account. The pull server can hold configuration scripts that can be pulled by servers across clouds and on-premises. This means that Azure Automation can be used to configure any server hosted anywhere in the world.</p>
			<p>The DSC needs a local agent on these servers, also known as a <strong class="bold">local configuration manager</strong> (<strong class="bold">LCM</strong>). It should be configured with the Azure Automation DSC pull server so it can download the required configuration and autoconfigure the server.</p>
			<p>The autoconfiguration can be scheduled to be periodic (by default it is half an hour), and if the agent finds any deviation in the server configuration compared to the one available in the DSC script, it will autocorrect and bring back the server to the desired and expected state.</p>
			<p>In this section, we will configure one server hosted on Azure, and the process will remain the same irrespective of whether the server is on a cloud or on-premises.</p>
			<p>The first step is to create a DSC configuration. A sample configuration is shown here, and complex configurations can be authored similarly:</p>
			<p class="snippet">configuration ensureiis {</p>
			<p class="snippet">import-dscresource -modulename psdesiredstateconfiguration</p>
			<p class="snippet">    </p>
			<p class="snippet">node localhost {        </p>
			<p class="snippet">        WindowsFeature iis {</p>
			<p class="snippet">            Name = "web-server"</p>
			<p class="snippet">            Ensure = "Present"</p>
			<p class="snippet">             </p>
			<p class="snippet">        }</p>
			<p class="snippet">    }</p>
			<p class="snippet">}</p>
			<p>The configuration is quite simple. It imports the <strong class="inline">PSDesiredStateConfiguration</strong> base DSC module and declares a single-node configuration. This configuration is not associated with any specific node and can be used to configure any server. The configuration is supposed to configure an IIS web server and ensure that it is present on any server to which it is applied.</p>
			<p>This configuration is not yet available on the Azure Automation DSC pull server, and so the first step is to import the configuration into the pull server. This can be done using the Automation account <strong class="inline">Import-AzAutomationDscConfiguration</strong> cmdlet, as shown next:</p>
			<p class="snippet">Import-AzAutomationDscConfiguration -SourcePath "C:\Ritesh\ensureiis.ps1" -AutomationAccountName bookaccount -ResourceGroupName automationrg -Force -Published</p>
			<p>There are a few important things to note here. The name of the configuration should match the filename, and it must only contain alphanumeric characters and underscores. A good naming convention is to use verb/noun combinations. The cmdlets need the path of the configuration file and the Azure Automation account details to import the configuration script.</p>
			<p>At this stage, the configuration is visible on the portal:</p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/Figure_4.30.jpg" alt="From the left-hand navigation, selecting the option ‘State Configuration (DSC)’ and then moving to the ‘Configurations’ tab to view the configuration details."/>
				</div>
			</div>
			<h6>Figure 4.30: Adding configuration</h6>
			<p>Once the configuration script is imported, it is compiled and stored within the DSC pull server using the <strong class="inline">Start-AzAutomationDscCompilationJob</strong> cmdlet, as shown next:</p>
			<p class="snippet">Start-AzAutomationDscCompilationJob -ConfigurationName 'ensureiis' -ResourceGroupName 'automationrg' -AutomationAccountName 'bookaccount'</p>
			<p>The name of the configuration should match the one that was recently uploaded, and the compiled configuration should be available now on the <strong class="bold">Compiled configurations</strong> tab, as shown in <em class="italics">Figure 4.31</em>:</p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/Figure_4.31.jpg" alt="Moving to the “Compiled Configurations’ tab to view the list of compiled configurations."/>
				</div>
			</div>
			<h6>Figure 4.31: Listing compiled configurations</h6>
			<p>It is important to note that the <strong class="bold">Node Count</strong> in <em class="italics">Figure 4.31</em> is <strong class="inline">0</strong>. It means that a node configuration called <strong class="inline">ensureiss.localhost</strong> exists but it is not assigned to any node. The next step is to assign the configuration to the node.</p>
			<p>By now, we have a compiled DSC configuration available on the DSC pull server, but there are no nodes to manage. The next step is to onboard the VMs and associate them with the DSC pull server. This is done using the <strong class="inline">Register-AzAutomationDscNode</strong> cmdlet:</p>
			<p class="snippet">Register-AzAutomationDscNode -ResourceGroupName 'automationrg' -AutomationAccountName 'bookaccount' -AzureVMLocation "west Europe" -AzureVMResourceGroup 'spark' -AzureVMName 'spark' -ConfigurationModeFrequencyMins 30 -ConfigurationMode 'ApplyAndAutoCorrect' </p>
			<p>This cmdlet takes the name of the resource group for both the VM and the Azure Automation account. It also configures the configuration mode and the <strong class="inline">configurationModeFrequencyMins</strong> property of the local configuration manager of the VM. This configuration will check and autocorrect any deviation from the configuration applied to it every 30 minutes.</p>
			<p>If <strong class="inline">VMresourcegroup</strong> is not specified, the cmdlet tries to find the VM in the same resource group as the Azure Automation account, and if the VM location value is not provided, it tries to find the VM in the Azure Automation region. It is always better to provide values for them. Notice that this command can only be used for Azure VMs as it asks for <strong class="inline">AzureVMname</strong> explicitly. For servers on other clouds and on-premises, use the <strong class="inline">Get-AzAutomationDscOnboardingMetaconfig</strong> cmdlet.</p>
			<p>Now, a new node configuration entry can also be found in the portal, as shown in <em class="italics">Figure 4.32</em>:</p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/Figure_4.32.jpg" alt="The Azure portal displaying a new node configuration entry and verifying the node status."/>
				</div>
			</div>
			<h6>Figure 4.32: Verifying node status</h6>
			<p>The node information can be obtained as follows:</p>
			<p class="snippet">$node = Get-AzAutomationDscNode -ResourceGroupName 'automationrg' -AutomationAccountName 'bookaccount' -Name 'spark' </p>
			<p>And a configuration can be assigned to the node:</p>
			<p class="snippet">Set-AzAutomationDscNode -ResourceGroupName 'automationrg' -AutomationAccountName 'bookaccount' -NodeConfigurationName 'ensureiis.localhost' -NodeId $node.Id </p>
			<p>Once the compilation is complete, it can be assigned to the nodes. The initial status is <strong class="bold">Pending</strong>, as shown in <em class="italics">Figure 4.33</em>:</p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/Figure_4.33.jpg" alt="The initial status of the node being displayed as ‘Pending’."/>
				</div>
			</div>
			<h6>Figure 4.33: Verifying node status</h6>
			<p>After a few minutes, the configuration is applied to the node, the node becomes <strong class="bold">Compliant</strong>, and the status becomes <strong class="bold">Completed</strong>:</p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/Figure_4.34.jpg" alt="The Azure portal showing the changed status as ‘Completed’ and the node as ‘Compliant’."/>
				</div>
			</div>
			<h6>Figure 4.34: Verifying if the node is compliant</h6>
			<p>Later, logging into the server and checking if the web server (IIS) is installed confirms that it is installed, as you can see in <em class="italics">Figure 4.35</em>:</p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/Figure_4.35.jpg" alt="The output of the Get-WindowsFeature –Name web-server command, displaying the name of the web server and the install state."/>
				</div>
			</div>
			<h6>Figure 4.35: Checking whether the desired state has been achieved</h6>
			<p>In the next section, Azure Automation pricing will be discussed.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor125"/>Azure Automation pricing</h2>
			<p>There is no cost for Azure Automation if no runbooks are executed on it. The cost of Azure Automation is charged per minute for execution of runbook jobs. This means that if the total number of runbook execution minutes is 10,000, the cost of Azure Automation would be $0.002 per minute multiplied by 9,500, as the first 500 minutes are free.</p>
			<p>There are other costs involved in Azure Automation depending on features consumed. For example, a DSC pull server does not cost anything within Azure Automation; neither does onboarding Azure VMs on to the pull server. However, if non-Azure servers are onboarded, typically from other clouds or on-premises, then the first five servers are free and anything on top of that costs $6 per server per month in the West US region.</p>
			<p>Pricing may vary from region to region, and it's always a good practice to verify the pricing on the official pricing page: <a href="https://azure.microsoft.com/pricing/details/automation">https://azure.microsoft.com/pricing/details/automation</a>.</p>
			<p>You might ask, why do we need an Automation account when we can deploy serverless applications via Azure Functions? In the next section, we will explore the key differences between Azure Automation and serverless automation.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor126"/>Comparison with serverless automation</h2>
			<p>Azure Automation and Azure serverless technologies, especially Azure Functions, are quite similar and overlap in terms of functionality. However, these are separate services with different capabilities and pricing.</p>
			<p>It is important to understand that Azure Automation is a complete suite for process automation and configuration management, while Azure Functions is meant for implementing business functionality.</p>
			<p>Azure Automation is used for automating the processes of provisioning, deprovisioning, management, and operations of infrastructure and configuration management thereafter. On the other hand, Azure Functions is meant for the creation of services, implementing functionality that can be part of microservices and other APIs.</p>
			<p>Azure Automation is not meant for unlimited scale, and the load is expected to be moderate, while Azure Functions can handle unlimited traffic and scale automatically.</p>
			<p>There are a host of shared assets, such as connections, variables, and modules, that can be reused across runbooks in Azure Automation; however, there is no out-of-the-box shared concept in Azure Functions.</p>
			<p>Azure Automation can manage intermediate state by way of checkpointing and continue from the last saved state, while Azure functions are generally stateless and do not maintain any state.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor127"/>Summary</h2>
			<p>Azure Automation is an important service within Azure and the only service for process automation and configuration management. This chapter covered a lot of important concepts related to Azure Automation and process automation, including shared assets such as connection, certificates, and modules.</p>
			<p>It covered the creation of runbooks, including invoking runbooks in different ways, such as parent-child relationships, webhooks, and using the portal. The chapter also discussed the architecture and life cycle of runbooks.</p>
			<p>We also looked at the usage of Hybrid Workers and, toward the end of the chapter, explored configuration management using a DSC pull server and a local configuration manager. Finally, we made comparisons with other technologies, such as Azure Functions. </p>
			<p>In the next chapter, we will explore designing policies, locks, and tags for Azure deployments.</p>
		</div>
	</body></html>