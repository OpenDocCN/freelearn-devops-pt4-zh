- en: 10\. Serverless in Azure – Working with Azure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about various big data solutions available
    on Azure. In this chapter, you will learn how serverless technology can help you
    deal with a large amount of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Serverless is one of the hottest buzzwords in technology these days, and everyone
    wants to ride this bandwagon. Serverless brings a lot of advantages in overall
    computing, software development processes, infrastructure, and technical implementation.
    There is a lot going on in the industry: at one end of the spectrum is **Infrastructure
    as a Service (IaaS)**, and at the other is serverless. In between the two are
    **Platform as a Service (PaaS)** and containers. I have met many developers and
    it seems to me that there is some confusion among them about IaaS, PaaS, containers,
    and serverless computing. Also, there is much confusion about use cases, applicability,
    architecture, and implementation for the serverless paradigm. Serverless is a
    new paradigm that is changing not only technology but also the culture and processes
    within organizations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin this chapter by introducing serverless, and will cover the following
    topics as we progress:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions as a Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Durable Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Event Grid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serverless
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Serverless refers to a deployment model in which users are responsible for only
    their application code and configuration. In serverless computing, customers do
    not have to bother about bringing their own underlying platform and infrastructure
    and, instead, can concentrate on solving their business problems.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless does not mean that there are no servers. Code and configuration will
    always need compute, storage, and networks to run. However, from the customer's
    perspective, there is no visibility of such compute, storage, and networks. They
    do not care about the underlying platform and infrastructure. They do not need
    to manage or monitor infrastructure and the platform. Serverless provides an environment
    that can scale up and down, in and out, automatically, without the customer even
    knowing about it. All operations related to platforms and infrastructures happen
    behind the scenes and are executed by the cloud provider. Customers are provided
    with performance-related **service-level agreements (SLAs)** and Azure ensures
    that it meets those SLAs irrespective of the total demand.
  prefs: []
  type: TYPE_NORMAL
- en: Customers are required to only bring in their code; it is the responsibility
    of the cloud provider to provide the infrastructure and platform needed to run
    the code. Let's go ahead and dive into the various advantages of Azure Functions.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of Azure Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Serverless computing is a relatively new paradigm that helps organizations convert
    large functionalities into smaller, discrete, on-demand functions that can be
    invoked and executed through automated triggers and scheduled jobs. They are also
    known as **Functions as a Service (FaaS)**, in which organizations can focus on
    their domain challenges instead of the underlying infrastructure and platform.
    FaaS also helps in devolving solution architectures into smaller, reusable functions,
    thereby increasing return on investment.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a plethora of serverless compute platforms available. Some of the
    important ones are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS Lambda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IBM OpenWhisk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iron.io
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Cloud Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In fact, every few days it feels like there is a new platform/framework being
    introduced, and it is becoming increasingly difficult for enterprises to decide
    on the framework that works best for them. Azure provides a rich serverless environment
    known as Azure Functions, and what follows are some of the features that it supports:'
  prefs: []
  type: TYPE_NORMAL
- en: Numerous ways to invoke a function—manually, on a schedule, or based on an event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numerous types of binding support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to run functions synchronously as well as asynchronously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to execute functions based on multiple types of triggers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to run both long- and short-duration functions. However, large and
    long-running functions are not recommended as they may lead to unexpected timeouts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to use proxy features for different function architectures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple usage models including consumption, as well as the App Service model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to author functions using multiple languages, such as JavaScript,
    Python, and C#.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization based on OAuth.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Durable Functions extension helps in writing stateful functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple authentication options, including Azure AD, Facebook, Twitter, and
    other identity providers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to easily configure inbound and outbound parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio integration for authoring Azure functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Massive parallelism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at FaaS and what roles it plays in serverless architecture.
  prefs: []
  type: TYPE_NORMAL
- en: FaaS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Azure provides FaaS. These are serverless implementations from Azure. With Azure
    Functions, code can be written in any language the user is comfortable with and
    Azure Functions will provide a runtime to execute it. Based on the language chosen,
    an appropriate platform is provided for users to bring their own code. Functions
    are a unit of deployment and can automatically be scaled out and in. When dealing
    with functions, users cannot view the underlying virtual machines and platform,
    but Azure Functions provides a small window to view them via the **Kudu Console**.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main components of Azure Functions:'
  prefs: []
  type: TYPE_NORMAL
- en: The Azure Functions runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Functions binding and triggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's learn about these components in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The Azure Functions runtime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The core of Azure Functions is its runtime. The precursor to Azure Functions
    was Azure WebJobs. The code for Azure WebJobs also forms the core for Azure Functions.
    There are additional features and extensions added to Azure WebJobs to create
    Azure Functions. The Azure Functions runtime is the magic that makes functions
    work. Azure Functions is hosted within Azure App Service. Azure App Service loads
    the Azure runtime and either waits for an external event or a manual activity
    to occur. On arrival of a request or the occurrence of a trigger, App Service
    loads the incoming payload, reads the function's `function.json` file to find
    the function's bindings and trigger, maps the incoming data to incoming parameters,
    and invokes the function with parameter values. Once the function completes its
    execution, the value is again passed back to the Azure Functions runtime by way
    of an outgoing parameter defined as a binding in the `function.json` file. The
    function runtime returns the values to the caller. The Azure Functions runtime
    acts as the glue that enables the entire performance of functions.
  prefs: []
  type: TYPE_NORMAL
- en: The current Azure runtime version is ~3\. It is based on the .NET Core 3.1 framework.
    Prior to this, version ~2 was based on the .NET Core 2.2 framework. The first
    version, ~1, was based on the .NET 4.7 framework.
  prefs: []
  type: TYPE_NORMAL
- en: There were substantial changes from version 1 to 2 because of changes in the
    underlying framework itself. However, there are very few breaking changes from
    version 2 to 3 and most functions written in version 2 would continue to run on
    version 3 as well. However, it is recommended that adequate testing is done after
    migrating from version 2 to 3\. There were also breaking changes from version
    1 to 2 with regard to triggers and bindings. Triggers and bindings are now available
    as extensions, with each one in a different assembly in versions 2 and 3.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions bindings and triggers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the Azure Functions runtime is the brain of Azure Functions, then Azure Functions
    bindings and triggers are its heart. Azure Functions promote loose coupling and
    high cohesion between services using triggers and bindings. Applications written
    targeting non-serverless environments implement code using imperative syntax for
    incoming and outgoing parameters and return values. Azure Functions uses a declarative
    mechanism to invoke functions using triggers and configures the flow of data using
    bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Binding refers to the process of creating a connection between the incoming
    data and the Azure function along with mapping the data types. The connection
    could be in a single direction from the runtime to Azure Functions and vice versa
    or could be multi-directional—the binding can transmit data between the Azure
    runtime and Azure Functions in both directions. Azure Functions defines bindings
    declaratively.
  prefs: []
  type: TYPE_NORMAL
- en: Triggers are a special type of binding through which functions can be invoked
    based on external events. Apart from invoking a function, triggers also pass the
    incoming data, payload, and metadata to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bindings are defined in the `function.json` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a trigger is declared that invokes the function whenever there
    is a new item in the storage queue. The type is `queueTrigger`, the direction
    is inbound, `queueName` is `checkout-items`, and details about the target storage
    account connection and table name are also shown. All these values are important
    for the functioning of this binding. The `checkOut` name can be used within the
    function's code as a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, a binding for the return value is declared. Here, the return value
    is named `Orders` and the data is the output from Azure Functions. The binding
    writes the return data into Azure Table Storage using the connection string provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both bindings and triggers can be modified and authored using the `function.json` file
    is updated. The `checkOut` trigger is declared as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Modifying triggers through the Integrate tab of Azure Functions](img/B15432_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: The Triggers section of the Integrate tab'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The **Orders** output is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding output details for the storage account through the Integrate tab](img/B15432_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Adding output details for the storage account'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The authors of Azure functions do not need to write any plumbing code to get
    data from multiple sources. They just decide the type of data expected from the
    Azure runtime. This is shown in the next code segment. Notice that the checkout
    is available as a string to the function. Multiple data types can be used as binding
    for functions. For example, a queue binding can provide the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A plain old CLR (Common Language Runtime) object (POCO)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A byte
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CloudQueueMessage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The author of the function can use any one of these data types, and the Azure
    Functions runtime will ensure that a proper object is sent to the function as
    a parameter. The following is a code snippet for accepting string data and the
    Functions runtime will encapsulate incoming data into a `string` data type before
    invoking the function. If the runtime is unable to cast the incoming data to a
    string, it will generate an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is also important to know that, in *Figure 10.2*, the storage account names
    are `AzureWebJobsStorage` and `AzureWebJobsDashboard`. Both of these are keys
    defined in the `appSettings` section and contain storage account connection strings.
    These storage accounts are used internally by Azure Functions to maintain its
    state and the status of function execution.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on Azure bindings and triggers, refer to [https://docs.microsoft.com/azure/azure-functions/functions-bindings-storage-queue](https://docs.microsoft.com/azure/azure-functions/functions-bindings-storage-queue).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a fair understanding of Azure bindings and triggers, let's
    check out the various configuration options offered by Azure Functions.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Azure Functions provides configuration options at multiple levels. It provides
    configuration for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The platform itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions App Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These settings affect every function contained by them. More information about
    these settings are available at [https://docs.microsoft.com/azure/azure-functions/functions-how-to-use-azure-function-app-settings](https://docs.microsoft.com/azure/azure-functions/functions-how-to-use-azure-function-app-settings).
  prefs: []
  type: TYPE_NORMAL
- en: '**Platform configuration**'
  prefs: []
  type: TYPE_NORMAL
- en: Azure functions are hosted within Azure App Service, so they get all of its
    features. Diagnostic and monitoring logs can be configured easily using platform
    features. Furthermore, App Service provides options for assigning SSL certificates,
    using a custom domain, authentication, and authorization as part of its networking
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Although customers are not concerned about the infrastructure, operating system,
    file system, or platform on which functions actually execute, Azure Functions
    provides the necessary tooling to peek within the underlying system and make changes.
    The in-portal console and the Kudu Console are the tools used for this purpose.
    They provide a rich editor to author Azure functions and edit their configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure Functions, just like App Service, lets you store the configuration information
    within the `web.config` application settings section, which can be read on demand.
    Some of the platform features of function apps are shown in *Figure 10.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Platform features of the function app](img/B15432_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Platform features of a function app'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: These platform features can be used to configure authentication, custom domains,
    SSL, and so on. Also, the **Platform Features** tab provides an overview of the
    development tools that can be used with the function app. In the next section,
    we will take a look at the function app settings that are available in the platform
    features.
  prefs: []
  type: TYPE_NORMAL
- en: '**App Service function settings**'
  prefs: []
  type: TYPE_NORMAL
- en: 'These settings affect all functions. Application settings can be managed here.
    Proxies in Azure Functions can be enabled and disabled. We will discuss proxies
    later in this chapter. They also help in changing the edit mode of a function
    application and the deployment to slots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the function app’s settings](img/B15432_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Function app settings'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Budget is a very important aspect of the success of any project. Let's explore
    the various plans offered for Azure Functions.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions cost plans
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Azure Functions is based on the Azure App Service and provides a pocket-friendly
    model for users. There are three cost models.
  prefs: []
  type: TYPE_NORMAL
- en: '**A consumption plan**'
  prefs: []
  type: TYPE_NORMAL
- en: This is based on the per-second consumption and execution of functions. This
    plan calculates the cost based on the compute usage during the actual consumption
    and execution of the function. If a function is not executed, there is no cost
    associated with it. However, it does not mean that performance is compromised
    in this plan. Azure functions will automatically scale out and in based on demand,
    to ensure basic minimum performance levels are maintained. A function execution
    is allowed 10 minutes for completion.
  prefs: []
  type: TYPE_NORMAL
- en: One of the major drawbacks of this plan is that if there is no consumption of
    functions for a few seconds, the function might get cold and the next request
    that comes up might face a short delay in getting a response as the function is
    idle. This phenomenon is called a cold start. However, there are workarounds that
    can keep functions warm even when there are no legitimate requests. This can be
    done by writing a scheduled function that keeps invoking the target function to
    keep it warm.
  prefs: []
  type: TYPE_NORMAL
- en: '**A premium plan**'
  prefs: []
  type: TYPE_NORMAL
- en: This is a relatively new plan and provides lots of benefits compared to both
    App Service and a consumption plan. In this plan, there are no cold starts for
    Azure functions. Functions can be associated with a private network and customers
    can choose their own virtual machine sizes for executing functions. It provides
    numerous out-of-the-box facilities that were not possible previously with the
    other two types of plans.
  prefs: []
  type: TYPE_NORMAL
- en: '**An App Service plan**'
  prefs: []
  type: TYPE_NORMAL
- en: This plan provides functions with completely dedicated virtual machines in the
    backend, and so the cost is directly proportional to the cost of the virtual machine
    and its size. There is a fixed cost associated with this plan, even if functions
    are not invoked. Function code can run for as long as necessary. Although there
    is no time restriction, the default limit is set to 30 minutes. This can be changed
    by changing the value in the `hosts.json` file. Within the App Service plan, the
    function runtime goes idle if not used for a few minutes and can be activated
    only using an HTTP trigger. There is an **Always On** setting that can be used
    to prevent the function runtime from going idle. Scaling is either manual or based
    on autoscale settings.
  prefs: []
  type: TYPE_NORMAL
- en: Along with the flexible pricing option, Azure also offers various hosting options
    for architecture deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions destination hosts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Azure Functions runtime can be hosted on Windows as well as on Linux hosts.
    PowerShell Core, Node.js, Java, Python, and .NET Core-based functions can run
    on both Windows as well as Linux operating systems. It is important to know which
    type of underlying operating system is required for the functions because this
    configuration setting is tied to the function app and in turn to all functions
    that are contained in it.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it is possible to run functions within Docker containers. This is because
    Azure provides Docker images that have a pre-built function runtime installed
    in them and functions can be hosted using such images. Now, Docker images can
    be used to create containers within Kubernetes Pods and hosted on Azure Kubernetes
    Service, Azure Container Instances, or on unmanaged Kubernetes clusters. These
    images can be stored within Docker Hub, Azure Container Registry, or any other
    global as well as private image repositories.
  prefs: []
  type: TYPE_NORMAL
- en: To have a clearer understanding, let's look into some of the most prominent
    use cases for Azure Functions.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions use cases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Azure Functions has many implementations. Let's have a look at some of these
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementing microservices**'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions helps in breaking down large applications into smaller, discrete
    functional code units. Each unit is treated independently of others and evolves
    in its own life cycle. Each such code unit has its own compute, hardware, and
    monitoring requirements. Each function can be connected to all other functions.
    These units are woven together by orchestrators to build complete functionality.
    For example, in an e-commerce application, there can be individual functions (code
    units), each responsible for listing catalogs, recommendations, categories, subcategories,
    shopping carts, checkouts, payment types, payment gateways, shipping addresses,
    billing addresses, taxes, shipping charges, cancellations, returns, emails, SMS,
    and so on. Some of these functions are brought together to create use cases for
    e-commerce applications, such as product browsing and checkout flow.
  prefs: []
  type: TYPE_NORMAL
- en: '**Integration between multiple endpoints**'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions can build overall application functionality by integrating multiple
    functions. The integration can be based on the triggering of events or it could
    be on a push basis. This helps in decomposing large monolithic applications into
    small components.
  prefs: []
  type: TYPE_NORMAL
- en: '**Data processing**'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions can be used for processing incoming data in batches. It can
    help in processing data in multiple formats, such as XML, CSV, JSON, and TXT.
    It can also run conversion, enrichment, cleaning, and filtering algorithms. In
    fact, multiple functions can be used, each doing either conversion or enrichment,
    cleaning or filtering. Azure Functions can also be used to incorporate advanced
    cognitive services, such as **optical character recognition (OCR)**, computer
    vision, and image manipulation and conversion. This is ideal if you want to process
    API responses and convert them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Integrating legacy applications**'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions can help in integrating legacy applications with newer protocols
    and modern applications. Legacy applications might not be using industry-standard protocols
    and formats. Azure Functions can act as a proxy for these legacy applications,
    accepting requests from users or other applications, converting the data into
    a format understood by a legacy application, and talking to it on protocols it
    understands. This opens a world of opportunity for integrating and bringing old
    and legacy applications into the mainstream portfolio.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scheduled jobs**'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions can be used to execute continuously or periodically for certain
    application functions. These application functions can perform tasks such as periodically
    taking backups, restoring, running batch jobs, exporting and importing data, and
    bulk emailing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Communication gateways**'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions can be used in communication gateways when using notification
    hubs, SMS, email, and so on. For example, you can use Azure Functions to send
    a push notification to Android and iOS devices using Azure Notification Hubs.
  prefs: []
  type: TYPE_NORMAL
- en: Azure functions are available in different types, which must be selected based
    on their relationship to optimizing workloads. Let's have a closer look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Types of Azure functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Azure functions can be categorized into three different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**On-demand functions**: These are functions that are executed when they are explicitly called
    or invoked. Examples of such functions include HTTP-based functions and webhooks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scheduled functions**: These functions are like timer jobs and execute functions on fixed
    intervals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event-based functions**: These functions are executed based on external events.
    For example, uploading a new file to Azure Blob storage generates an event that
    could start the execution of Azure functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following section, you will learn how to create an event-driven function
    that will be connected to an Azure Storage account.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an event-driven function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, an Azure function will be authored and connected to an Azure
    Storage account. The Storage account has a container for holding all Blob files.
    The name of the Storage account is **incomingfiles** and the container is **orders**,
    as shown in *Figure 10.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Storage account and container used for the Azure function](img/B15432_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Storage account details'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Perform the following steps to create a new Azure function from the Azure portal:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **+** button beside the **Functions** menu on the left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **In-Portal** from the resultant screen and click on the **Continue**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Azure Blob Storage trigger**, as shown in *Figure 10.6*:![Creating
    an Azure Blob Storage trigger function](img/B15432_10_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.6: Selecting Azure Blob Storage trigger'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Right now, this Azure function does not have connectivity to the Storage account.
    Azure functions need connection information for the Storage account, and that
    is available from the **Access keys** tab in the Storage account. The same information
    can be obtained using the Azure Functions editor environment. In fact, that environment
    allows the creation of a new Storage account from the same editor environment.
  prefs: []
  type: TYPE_NORMAL
- en: The Azure Blob Storage trigger can be added using the **New** button beside
    the **Storage account connection** input type. It allows the selection of an existing
    Storage account or the creation of a new Storage account. Since I already have
    a couple of Storage accounts, I am reusing them, but you should create a separate
    Azure Storage account. Selecting a Storage account will update the settings in
    the **appSettings** section with the connection string added to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that a container already exists within the Blob service of the target
    Azure Storage account. The path input refers to the path to the container. In
    this case, the **orders** container already exists within the Storage account.
    The **Create** button shown here will provision the new function monitoring the
    Storage account container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a function for monitoring a Storage account container](img/B15432_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: Creating a function that monitors the Storage account container'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The code for the `storagerelatedfunctions` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The bindings are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, uploading any blob file to the `orders` container should trigger the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Initiating a trigger through a blob file](img/B15432_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: C# Blob trigger function processed blob'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the next section, we will dive into Azure Function Proxies, which will help
    you to efficiently handle the requests and responses of your APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Function Proxies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Azure Function Proxies is a relatively new addition to Azure Functions. Function
    Proxies helps in hiding the details of Azure functions and exposing completely
    different endpoints to customers. Function Proxies can receive requests on endpoints,
    modify the content, body, headers, and URL of the request by changing the values,
    and augment them with additional data and pass it internally to Azure functions.
    Once they get a response from these functions, they can again convert, override,
    and augment the response and send it back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: It also helps in invoking different functions for CRUD (create, read, delete,
    and update) operations using different headers, thereby breaking large functions
    into smaller ones. It provides a level of security by not exposing the original
    function endpoint and also helps in changing the internal function implementation
    and endpoints without impacting its caller. Function Proxies helps by providing
    clients with a single function URL and then invoking multiple Azure functions
    in the backend to complete workflows. More information about Azure Function Proxies
    can be found at [https://docs.microsoft.com/azure/azure-functions/functions-proxies](https://docs.microsoft.com/azure/azure-functions/functions-proxies).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will cover Durable Functions in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Durable Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Durable Functions is one of the latest additions to Azure Functions. It allows
    architects to write stateful workflows in an Orchestrator function, which is a
    new function type. As a developer, you can choose to code it or use any form of
    IDE. Some advantages of using Durable Functions are:'
  prefs: []
  type: TYPE_NORMAL
- en: Function output can be saved to local variables and you can call other functions
    synchronously and asynchronously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The state is preserved for you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the basic mechanism for invoking Durable Functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The basic mechanism for invoking Durable Functions](img/B15432_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: Mechanism for invoking Durable Functions'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Azure Durable Functions can be invoked by any trigger provided by Azure Functions.
    These triggers include HTTP, Blob storage, Table Storage, Service Bus queues,
    and more. They can be triggered manually by someone with access to them, or by
    an application. *Figure 10.9* shows a couple of triggers as an example. These
    are also known as starter Durable Functions. The starter durable functions invoke
    the **durable orchestrator trigger**, which contains the main logic for orchestration,
    and orchestrates the invocation of activity functions.
  prefs: []
  type: TYPE_NORMAL
- en: The code written within the durable orchestrator must be deterministic. This
    means that no matter the number of times the code is executed, the values returned
    by it should remain the same. The Orchestrator function is a long-running function
    by nature. This means it can be hydrated, state-serialized, and it goes to sleep
    after it calls a durable activity function. This is because it does not know when
    the durable activity function will complete and does not want to wait for it.
    When the durable activity function finishes its execution, the Orchestrator function
    is executed again. The function execution starts from the top and executes until
    it either calls another durable activity function or finishes the execution of
    the function. It has to re-execute the lines of code that it already executed
    earlier and should get the same results that it got earlier. Note that the code
    written within the durable orchestrator must be deterministic. This means that
    no matter the number of times the code is executed, the values returned by it
    should remain the same.
  prefs: []
  type: TYPE_NORMAL
- en: Let me explain this with the help of an example. If we use a general .NET Core
    datetime class and return the current date time, it will result in a new value
    every time we execute the function. The Durable Functions context object provides
    `CurrentUtcDateTime`, which will return the same datetime value during re-execution
    that it returned the first time.
  prefs: []
  type: TYPE_NORMAL
- en: These orchestration functions can also wait for external events and enable scenarios
    related to human hand-off. This concept will be explained later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'These activity functions can be called with or without a retry mechanism. Durable
    Functions can help to solve many challenges and provides features to write functions
    that can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Execute long-running functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintain state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute child functions in parallel or sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recover from failure easily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orchestrate the execution of functions in a workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you have a fair understanding of the inner workings of a durable function,
    let's explore how to create a durable function in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Steps for creating a durable function using Visual Studio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are the steps to create a durable function:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the Azure portal and click on **Resource groups** in the left menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **+Add** button in the top menu to create a new resource group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the resource group information on the resultant form and click on the
    **Create** button, as shown here:![Creating a resource group for creating a Durable
    Function](img/B15432_10_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.10: Creating a resource group'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Navigate to the newly created resource group and add a new function app by clicking
    on the `function app` in the resultant search box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Function App** and click on the **Create** button. Fill in the resultant
    function app form and click on the **Create** button. You can also reuse the function
    app we created earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the function app is created, we will get into our local development environment
    with visual studio 2019 installed on it. We will get started with Visual Studio
    and create a new project of type `Azure functions`, provide it with a name, and
    select **Azure Functions v3** (**.NET core**) for **Function runtime**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the project is created, we need to add the `DurableTask` NuGet package
    to the project for working with Durable Functions. The version used at the time
    of writing this chapter is 2.2.2:![Adding a DurableTask NuGet package for the
    project](img/B15432_10_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.11: Adding a DurableTask NuGet package'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Now, we can code our durable functions within Visual Studio. Add a new function,
    provide it with a name, and select the **Durable Functions Orchestration** trigger
    type:![Adding a Durable Functions Orchestration trigger](img/B15432_10_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.12: Selecting a Durable Functions Orchestration trigger'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Visual Studio generates the boilerplate code for Durable Functions, and we are
    going to use it to learn about Durable Functions. Durable Functions activities
    are functions that are invoked by the main Orchestrator function. There is generally
    one main Orchestrator function and multiple Durable Functions activities. Once
    the extension is installed, provide a name for the function and write code that
    does something useful, such as sending an email or an SMS, connecting to external
    systems and executing logic, or executing services using their endpoints, such
    as cognitive services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Visual Studio generates three sets of functions in a single line of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`BlobTrigger`, a `ServiceBus` queue, or a trigger-based function.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RunOrchestrator**: This is the main durable orchestration function. It is
    responsible for accepting parameters from the starter function and in turn, invokes
    multiple durable task functions. Each durable task function is responsible for
    a functionality and these durable tasks can be invoked either in parallel or in
    sequence depending on the need.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SayHello**: This is the durable task function that is invoked from the durable
    function orchestrator to do a particular job.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for the starter function (`HttpStart`) is shown next. This function
    has a trigger of type HTTP and it accepts an additional binding of type `DurableClient`.
    This `DurableClient` object helps in invoking the Orchestrator function:![Code
    for the HttpStart starter function](img/B15432_10_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.13: Code for the starter function'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: The code for the Orchestrator function (`RunOrchestrator`) is shown next. This
    function has a trigger of type `OrchestrationTrigger` and accepts a parameter
    of type `IDurableOrchestrationContext`. This context object helps in invoking
    durable tasks:![Code for the orchestrator trigger function](img/B15432_10_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.14: Code for orchestrator trigger function'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: The code for the durable task function (`HelloFunction`) is shown next. This
    function has a trigger of type `ActivityTrigger` and accepts a parameter that
    can be any type needed for it to execute its functionality. It has a return value
    of type `string` and the function is responsible for returning a string value
    to the orchestration function:![Code for the durable task function](img/B15432_10_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.15: Code for the durable task function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Next, we can execute the function locally, which will start a storage emulator
    if one''s not already started, and will provide a URL for the HTTP trigger function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Executing a function to start the storage emulator and provide a URL for
    the HTTP trigger function](img/B15432_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.16: Starting the storage emulator'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We are going to invoke this URL using a tool known as **Postman** (this can
    be downloaded from [https://www.getpostman.com/](https://www.getpostman.com/)).
    We just need to copy the URL and execute it in Postman. This activity is shown
    in *Figure 10.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Invoking URLs using Postman](img/B15432_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.17: Invoking URLs using Postman'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Notice that five URLs are generated when you start the orchestrator:'
  prefs: []
  type: TYPE_NORMAL
- en: The `statusQueryGetUri` URL is used to find the current status of the orchestrator.
    Clicking this URL on Postman opens a new tab, and if we execute this request,
    it shows the status of the workflow:![The current status of the orchestrator](img/B15432_10_18.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 10.18: Current status of the orchestrator'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `terminatePostUri` URL is used for stopping an already running Orchestrator
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sendEventPostUri` URL is used to post an event to a suspended durable function.
    Durable functions can be suspended if they are waiting for an external event.
    This URL is used in those cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `purgeHistoryDeleteUri` URL is used to delete the history maintained by
    Durable Functions for a particular invocation from its Table Storage account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that you know how to work with Durable Functions using Visual Studio, let''s
    cover another aspect of Azure functions: chaining them together.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a connected architecture with functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A connected architecture with functions refers to creating multiple functions,
    whereby the output of one function triggers another function and provides data
    for the next function to execute its logic. In this section, we will continue
    with the previous scenario of the Storage account. In this case, the output of
    the function being triggered using Azure Storage Blob files will write the size
    of the file to Azure Cosmos DB.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration of Cosmos DB is shown next. By default, there are no collections
    created in Cosmos DB.
  prefs: []
  type: TYPE_NORMAL
- en: 'A collection will automatically be created when creating a function that will
    be triggered when Cosmos DB gets any data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an Azure Cosmos DB account](img/B15432_10_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.19: Creating an Azure Cosmos DB account'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let's follow the below steps to retrieve data for the next function from the
    output of one function.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new database, `testdb`, within Cosmos DB, and create a new collection
    named `testcollection` within it. You need both the database and the collection
    name when configuring Azure functions: ![Creating a new database within a container](img/B15432_10_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.20: Adding a container'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Create a new function that will have a Blob Storage trigger and output CosmosDB
    binding. The value returned from the function will be the size of the data for
    the uploaded file. This returned value will be written to Cosmos DB. The output
    binding will write to the Cosmos DB collection. Navigate to the **Integrate**
    tab and click on the **New Output** button below the **Outputs** label and select
    **Azure Cosmos DB**:![Binding output to Azure Cosmos DB](img/B15432_10_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.21: Binding output to Azure Cosmos DB'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Provide the appropriate names for the database and collection (check the checkbox
    to create the collection if it does not exist), click on the **New** button to
    select your newly created Azure Cosmos DB, and leave the parameter name as **outputDocument**:![Selecting
    an Azure Cosmos DB account as output](img/B15432_10_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.22: Newly created Azure Cosmos DB'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Modify the function as shown in *Figure 10.23*:![Modifying the function](img/B15432_10_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.23: Modifying the function'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Now, uploading a new file to the orders collection in the Azure Storage account
    will execute a function that will write to the Azure Cosmos DB collection. Another
    function can be written with the newly created Azure Cosmos DB account as a trigger
    binding. It will provide the size of files and the function can act on it. This
    is shown here:![Creating a trigger binding function](img/B15432_10_24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.24: Writing a trigger binding function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This section covered how the output of one function can be used to retrieve
    data for the next function. In the next section, you will learn about how to enable
    serverless eventing by understanding about Azure Event Grid.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Event Grid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Azure Event Grid is a relatively new service. It has also been referred to as
    a serverless eventing platform. It helps with the creation of applications based
    on events (also known as **event-driven design**). It is important to understand
    what events are and how we dealt with them prior to Event Grid. An event is something
    that happened – that is, an activity that changed the state of a subject. When
    a subject undergoes a change in its state, it generally raises an event.
  prefs: []
  type: TYPE_NORMAL
- en: Events typically follow the publish/subscribe pattern (also popularly known
    as the **pub/sub pattern**), in which a subject raises an event due to its state
    change, and that event can then be subscribed to by multiple interested parties,
    also known as **subscribers**. The job of the event is to notify the subscribers
    of such changes and also provide them with data as part of its context. The subscribers
    can take whatever action they deem necessary, which varies from subscriber to
    subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to Event Grid, there was no service that could be described as a real-time
    event platform. There were separate services, and each provided its own mechanism
    for handling events.
  prefs: []
  type: TYPE_NORMAL
- en: For example, Log Analytics, also known as **Operations Management Suite** (**OMS**),
    provides an infrastructure for capturing environment logs and telemetry on which
    alerts can be generated. These alerts can be used to execute a runbook, a webhook,
    or a function. This is near to real time, but they are not completely real time.
    Moreover, it was quite cumbersome to trap individual logs and act on them. Similarly,
    there is Application Insights, which provides similar features to Log Analytics
    but for applications instead.
  prefs: []
  type: TYPE_NORMAL
- en: There are other logs, such as activity logs and diagnostic logs, but again,
    they rely on similar principles as other log-related features. Solutions are deployed
    on multiple resource groups in multiple regions, and events raised from any of
    these should be available to the resources that are deployed elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Event Grid removes all barriers, and as a result, events can be generated by
    most resources (they are increasingly becoming available), and even custom events
    can be generated. These events can then be subscribed to by any resource, in any
    region, and in any resource group within the subscription.
  prefs: []
  type: TYPE_NORMAL
- en: Event Grid is already laid down as part of the Azure infrastructure, along with
    data centers and networks. Events raised in one region can easily be subscribed
    to by resources in other regions, and since these networks are connected, it is
    extremely efficient for the delivery of events to subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: Event Grid
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Event Grid lets you create applications with event-based architecture. There
    are publishers of events and there are consumers of events; however, there can
    be multiple subscribers for the same event.
  prefs: []
  type: TYPE_NORMAL
- en: The publisher of an event can be an Azure resource, such as Blob storage, **Internet
    of Things** (**IoT**) hubs, and many others. These publishers are also known as
    event sources. These publishers use out-of-the-box Azure topics to send their
    events to Event Grid. There is no need to configure either the resource or the
    topic. The events raised by Azure resources are already using topics internally
    to send their events to Event Grid. Once the event reaches the grid, it can be
    consumed by the subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The subscribers, or consumers, are resources who are interested in events and
    want to execute an action based on these events. These subscribers provide an
    event handler when they subscribe to the topic. The event handlers can be Azure
    functions, custom webhooks, logic apps, or other resources. Both the event sources
    and subscribers that execute event handlers are shown in *Figure 10.25*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Event Grid architecture](img/B15432_10_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.25: The Event Grid architecture'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When an event reaches a topic, multiple event handlers can be executed simultaneously,
    each taking its own action.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to raise a custom event and send a custom topic to Event
    Grid. Event Grid provides features for creating custom topics, and these topics
    are automatically attached to Event Grid. These topics know the storage for Event
    Grid and automatically send their messages to it. Custom topics have two important
    properties, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**An endpoint**: This is the endpoint of the topic. Publishers and event sources
    use this endpoint to send and publish their events to Event Grid. In other words,
    topics are recognized using their endpoints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keys**: Custom topics provide a couple of keys. These keys enable security
    for the consumption of the endpoint. Only publishers with these keys can send
    and publish their messages to Event Grid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each event has an event type and it is recognized by it. For example, Blob storage
    provides event types, such as `blobAdded` and `blobDeleted`. Custom topics can
    be used to send a custom-defined event, such as a custom event of the `KeyVaultSecretExpired` type.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, subscribers have the ability to accept all messages or only
    get events based on filters. These filters can be based on the event type or other
    properties within the event payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each event has at least the following five properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: This is the unique identifier for the event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eventType`: This is the event type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eventTime`: This is the date and time when the event was raised.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subject`: This is a short description of the event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data`: This is a dictionary object and contains either resource-specific data
    or any custom data (for custom topics).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currently, Event Grid's functionalities are not available with all resources;
    however, Azure is continually adding more and more resources with Event Grid functionality.
  prefs: []
  type: TYPE_NORMAL
- en: To find out more about the resources that can raise events related to Event
    Grid and handlers that can handle these events, please go to [https://docs.microsoft.com/azure/event-grid/overview](https://docs.microsoft.com/azure/event-grid/overview).
  prefs: []
  type: TYPE_NORMAL
- en: Resource events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, the following steps are provided to create a solution in which
    events that are raised by Blob storage are published to Event Grid and ultimately
    routed to an Azure function:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the Azure portal using the appropriate credentials and create a new
    Storage account in an existing or a new resource group. The Storage account should
    be either **StorageV2** or **Blob storage**. As demonstrated in *Figure 10.26*,
    Event Grid will not work with **StorageV1**:![Creating a storage account of the
    StorageV2 type](img/B15432_10_26.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.26: Creating a new storage account'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Create a new function app or reuse an existing function app to create an Azure
    function. The Azure function will be hosted within the function app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new function using the **Azure Event Grid trigger** template. Install
    the **Microsoft.Azure.WebJobs.Extensions.EventGrid** extension if it's not already
    installed, as shown in *Figure 10.27*:![Installing extensions for Azure Event
    Grid trigger](img/B15432_10_27.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.27: Installing extensions for an Azure Event Grid trigger'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Name the `StorageEventHandler` function and create it. The following default
    generated code will be used as the event handler:![Code for the event handler](img/B15432_10_28.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.28: Event handler code'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: The subscription to Storage events can be configured either from the Azure Functions
    **user interface (UI)** by clicking on **Add Event Grid subscription**, or from
    the storage account itself.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the **Add Event Grid subscription** link in the Azure Functions UI
    to add a subscription to the events raised by the storage account created in the
    previous step. Provide a meaningful name for the subscription, and then choose
    **Event Schema** followed by **Event Grid Schema**. Set **Topic Types** as **Storage
    Accounts**, set an appropriate **Subscription**, and the resource group containing
    the storage account:![Creating an Event Grid subscription](img/B15432_10_29.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.29: Creating an Event Grid subscription'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Ensure that the **Subscribe to all event types** checkbox is checked and click
    on the **Create** button (it should be enabled as soon as a storage account is
    selected).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we now navigate to the storage account in the Azure portal and click on the **Events**
    link in the left-hand menu, the subscription for the storage account should be
    visible:![List of event subscriptions](img/B15432_10_30.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.30: Event subscription list'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Upload a file to the Blob storage after creating a container, and the Azure
    function should be executed. The upload action will trigger a new event of the `blobAdded` type
    and send it to the Event Grid topic for storage accounts. As shown in *Figure
    10.31*, the subscription is already set to get all the events from this topic,
    and the function gets executed as part of the event handler:![Using a blob file
    to trigger a new event](img/B15432_10_31.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.31: Triggering a new event'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this section, you learned how events raised by Blob storage can be routed
    to an Azure function. In the next section, you will learn how to leverage custom
    events.
  prefs: []
  type: TYPE_NORMAL
- en: Custom events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this example, instead of using out-of-box resources to generate events,
    custom events will be used. We will use PowerShell to create this solution and
    reuse the same Azure function that was created in the last exercise as the handler:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in and connect to your Azure subscription of choice using `Login-AzAccount`
    and `Set-AzContext cmdlet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is to create a new Event Grid topic in Azure in a resource group.
    The `New-AzEventGridTopic` cmdlet is used to create a new topic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the topic is created, its endpoint URL and key should be retrieved as
    they are needed to send and publish the event to it. The `Get-AzEventGridTopic`
    and `Get-AzEventGridTopicKey` cmdlets are used to retrieve these values. Note
    that `Key1` is retrieved to connect to the endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A new hash table is created with all five important Event Grid event properties.
    A new `id` property is generated for the ID, the `subject` property is set to
    `Key vault` `Asset Expiry`, `eventType` is set to `Certificate Expiry`, `eventTime` is
    set to the current time, and `data` contains information regarding the certificate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since Event Grid data should be published in the form of a JSON array, the
    payload is converted in the JSON array. The `"["`,`"]"` square brackets represent
    a JSON array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The event will be published using the HTTP protocol, and the appropriate header
    information has to be added to the request. The request is sent using the application/JSON
    content type and the key belonging to the topic is assigned to the `aeg-sas-key`
    header. It is mandatory to name the header and key set to `aeg-sas-key`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A new subscription is created to the custom topic with a name, the resource
    group containing the topic, the topic name, the webhook endpoint, and the actual
    endpoint that acts as the event handler. The event handler in this case is the
    Azure function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The URL of the Azure function is available from the **Integrate** tab, as shown
    in *Figure 10.31*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Event Grid Subscription URL in the Integrate tab](img/B15432_10_32.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.32: Event Grid Subscription URL in the Integrate tab'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'By now, both the subscriber (event handler) and the publisher have been configured.
    The next step is to send and publish an event to the custom topic. The event data
    was already created in the previous step and, by using the `Invoke-WebRequest`
    cmdlet, the request is sent to the endpoint along with the body and the header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The API call will trigger the event and the Event Grid will message the endpoint
    we configured, which is the function app. With this activity, we are winding up
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The evolution of functions from traditional methods has led to the design of
    the loosely coupled, independently evolving, self-reliant serverless architecture
    that was only a concept in earlier days. Functions are a unit of deployment and
    provide an environment that does not need to be managed by the user at all. All
    they have to care about is the code written for the functionality. Azure provides
    a mature platform for hosting functions and integrating them seamlessly, based
    on events or on demand. Nearly every resource in Azure can participate in an architecture
    composed of Azure functions. The future is functions, as more and more organizations
    want to stay away from managing infrastructures and platforms. They want to offload
    this to cloud providers. Azure Functions is an essential feature to master for
    every architect dealing with Azure.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter went into the details of Azure Functions, Functions as a Service,
    Durable Functions, and Event Grid. The next chapter will focus on Azure Logic
    Apps, and we will build a complete end-to-end solution combining multiple serverless
    services along with other Azure services, such as Azure Key Vault and Azure Automation.
  prefs: []
  type: TYPE_NORMAL
