- en: 11\. Azure solutions using Azure Logic Apps, Event Grid, and Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter continues from the previous chapter and will go into further depth
    about serverless services available within Azure. In the previous chapter, you
    learned in detail about Azure Functions, functions as a service, Durable Functions,
    and Event Grid. Going forward, this chapter will focus on understanding Logic
    Apps and then move on to creating a complete end-to-end serverless solution that
    combines multiple serverless and other kinds of services, such as Key Vault and
    Azure Automation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will further explore Azure services by covering the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Logic Apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an end-to-end solution using serverless technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Logic Apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Logic Apps is a serverless workflow offering from Azure. It has all the features
    of serverless technologies, such as consumption-based costing and unlimited scalability.
    Logic Apps helps us to build a business process and workflow solution with ease
    using the Azure portal. It provides a drag-and-drop UI to create and configure
    workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Using Logic Apps is the preferred way to integrate services and data, create
    business projects, and create a complete flow of logic. There are several important
    concepts that should be understood before building a logic app.
  prefs: []
  type: TYPE_NORMAL
- en: Activities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An activity is a single unit of work. Examples of activities include converting
    XML to JSON, reading blobs from Azure Storage, and writing to a Cosmos DB document
    collection. Logic Apps provides a workflow definition consisting of multiple co-related
    activities in a sequence. There are two types of activity in Logic Apps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Trigger**: A trigger refers to the initiation of an activity. All logic apps
    have a single trigger that forms the first activity. It is the trigger that creates
    an instance of the logic app and starts the execution. Examples of triggers are
    the arrival of Event Grid messages, an email, an HTTP request, or a schedule.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions:** Any activity that is not a trigger is a step activity, and each
    of them is responsible to perform one task. Steps are connected to each other
    in a workflow. Each step will have an action that needs to be completed before
    going to the next step.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Connectors are Azure resources that help connect a logic app to external services.
    These services can be in the cloud or on-premises. For example, there is a connector
    for connecting logic apps to Event Grid. Similarly, there is another connector
    to connect to Office 365 Exchange. Almost all types of connectors are available
    in Logic Apps, and they can be used to connect to services. Connectors contain
    connection information and also logic to connect to external services using this
    connection information.
  prefs: []
  type: TYPE_NORMAL
- en: The entire list of connectors is available at [https://docs.microsoft.com/connectors](https://docs.microsoft.com/connectors).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know about connectors, you need to understand how they can be aligned
    in a step-by-step manner to make the workflow work as expected. In the next section,
    we will be focusing on the workings of a logic app.
  prefs: []
  type: TYPE_NORMAL
- en: The workings of a logic app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create a Logic Apps workflow that gets triggered when an email account
    receives an email. It replies to the sender with a default email and performs
    sentiment analysis on the content of the email. For sentiment analysis, the Text
    Analytics resource from Cognitive Services should be provisioned before creating
    the logic app:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the Azure portal, log in to your account, and create a **Text Analytics**
    resource in a resource group. Text Analytics is part of Cognitive Services and
    has features such as sentiment analysis, key phrase extraction, and language detection.
    You can find the service in the Azure portal, as shown in *Figure 11.1*:![Entering
    the keywords ‘Text Analytics’ in the search box of the Azure portal to find the
    Text Analytics service.](img/Figure_11.1.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.1: Navigating to the Text Analytics service from the Azure portal'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Provide the **Name**, **Location**, **Subscription**, **Resource group**, and
    **Pricing tier** values. We'll be using the free tier (F0 tier) of this service
    for this demo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the resource is provisioned, navigate to the **Overview** page, and copy
    the endpoint URL. Store it in a temporary location. This value will be required
    when configuring the logic app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the **Keys** page and copy the value from **Key 1** and store it
    in a temporary location. This value will be needed when configuring the logic
    app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to create a logic app. To create a logic app, navigate to the
    resource group in the Azure portal in which the logic app should be created. Search
    for Logic App and create it by providing **Name**, **Location**, **Resource group**,
    and **Subscription** values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the logic app has been created, navigate to the resource, click on **Logic
    app designer** in the left-hand menu, and then select the **When a new email is
    received in Outlook.com** template to create a new workflow. The template provides
    a head start by adding boilerplate triggers and activities. This will add an Office
    365 Outlook trigger automatically to the workflow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Sign in** button on the trigger; it will open a new Internet
    Explorer window. Then, sign in to your account. After successfully signing in,
    a new Office 365 mail connector will be created, containing the connection information
    to the account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Continue** button and configure the trigger with a 3-minute poll
    frequency, as shown in *Figure 11.2*:![Configuring the trigger with a 3-minute
    poll frequency by setting Interval as ‘3’ and Frequency as minute.](img/Figure_11.2.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.2: Configuring the trigger with a 3-minute poll frequency'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Click on `variable` in the search bar. Then, select the **Initialize variable**
    action, as demonstrated in *Figure 11.3*:![In the ‘Choose an action’ pane, entering
    the keyword ‘variable’ and then selecting the Initialize variable action.](img/Figure_11.3.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.3: Adding the Initialize variable action'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Next, configure the variable action. When the **Value** box is clicked on, a
    pop-up window appears that shows **Dynamic content** and **Expression**. Dynamic
    content refers to properties that are available to the current action and are
    filled with runtime values from previous actions and triggers. Variables help
    in keeping workflows generic. From this window, select **Body** from **Dynamic
    content**:![In the ‘Initialize variable’ pane, adding the name as emailContent,
    the type as string, and the value as Body.](img/Figure_11.4.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.4: Configuring the variable action'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Add another action by clicking on `outlook` in the search bar, and then selecting
    the **Reply to email** action:![Searching with the keyword ‘Outlook’ in the searchbox
    of the ‘Choose an action’ pane and then adding the action ‘Reply to email’.](img/Figure_11.5.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.5: Adding the Reply to email action'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Configure the new action. Ensure that **Message Id** is set with the dynamic
    content, **Message Id**, and then type the reply in the **Comment** box that you'd
    like to send to the recipient:![Configuring the Reply to email action by adding
    the Message id, the comment “Thanks for your email. We will get back to you”,
    and the Reply All option as ‘Yes’.](img/Figure_11.6.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.6: Configuring the Reply to email action'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Add another action, type `text analytics` in the search bar, and then select
    **Detect Sentiment (preview)**:![Adding the Detect Sentiment (preview) action.](img/Figure_11.7.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.7: Adding the Detect Sentiment (preview) action'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Configure the sentiment action as shown in *Figure 11.8*—both the endpoint and
    key values should be used here. Now click on the **Create** button, as demonstrated
    in *Figure 11.8*:![Configuring the sentiment action by providing the Connection
    name as EmailAnalysis, and entering the account key and the Site URL.](img/Figure_11.8.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.8: Configuring the Detect Sentiment (preview) action'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Provide the text to the action by adding dynamic content and selecting the previously
    created variable, **emailContent**. Then, click on **Show advanced options** and
    select **en** for **Language**:![In the ‘Detect Sentiment(preview) pane, setting
    text field as emailContent and Language as en.](img/Figure_11.9.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.9: Selecting the language for the sentiment action'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Next, add a new action by selecting **Outlook**, and then select **Send an email**.
    This action sends the original recipient the email content with the sentiment
    score in its subject. It should be configured as shown in *Figure 11.10*. If the
    score is not visible in the dynamic content window, click on the **See more**
    link beside it:![Configuring the Send an email action and setting Body as emailCOntent,
    Subject as Score, and To as ‘To’ from (Outlook).](img/Figure_11.10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.10: Adding the Send an email action'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Save the logic app, navigate back to the overview page, and click on **Run trigger**.
    The trigger will check for new emails every 3 minutes, reply to the senders, perform
    sentiment analysis, and send an email to the original recipient. A sample email
    with negative connotations is sent to the given email ID:![A sample email with
    negative connotations, sent to the given email ID.](img/Figure_11.11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.11: Sample email'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: After a few seconds, the logic app executes, and the sender gets the following
    reply:![The autogenerated reply from the logic app with the text specified in
    the ‘Reply to email’ action.](img/Figure_11.12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.12: Reply email to the original sender'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: The original recipient gets an email with the sentiment score and the original
    email text, as shown in *Figure 11.13*:![An HTML view of the email message with
    the sentiment score and the original email text.](img/Figure_11.13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.13: HTML view of the email message'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From the activity, we were able to understand the workings of a logic app. The
    app was triggered when an email was received in the inbox of the user and the
    process followed the sequence of steps that were given in the logic app. In the
    next section, you will learn how to create an end-to-end solution using serverless
    technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an end-to-end solution using serverless technologies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will create an end-to-end solution comprising serverless
    technologies that we discussed in the previous sections. The following example
    will give you an idea of how workflows can be intelligently implemented to avoid
    management overhead. In the next activity, we will create a workflow to notify
    the users when the keys, secrets, and certificates get stored in Azure Key Vault.
    We will take this as a problem statement, figure out a solution, architect the
    solution, and implement it.
  prefs: []
  type: TYPE_NORMAL
- en: The problem statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The problem that we are going to solve here is that users and organizations
    are not notified regarding the expiration of secrets in their key vault, and applications
    stop working when they expire. Users are complaining that Azure does not provide
    the infrastructure to monitor Key Vault secrets, keys, and certificates.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The solution to this problem is to combine multiple Azure services and integrate
    them so that users can be proactively notified of the expiration of secrets. The
    solution will send notifications using two channels—email and SMS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Azure services used to create this solution include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Key Vault
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Active Directory** (**Azure AD**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Event Grid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logic Apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SendGrid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Twilio SMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you know the services that will be used as part of the solution, let's
    go ahead and create an architecture for this solution.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we explored the list of services that will be used
    in the solution. If we want to implement the solution, the services should be
    laid out in the proper order. The architecture will help us to develop the workflow
    and take a step closer to the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The architecture of the solution comprises multiple services, as shown in *Figure
    11.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An architectural diagram of solution services such as PowerShell Runbook,
    Event Grid, Key Vault, Logic Apps, and so on, showing the flow of messages between
    the services.](img/Figure_11.14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.14: Solution architecture'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let's go through each of these services and understand their roles and the functionality
    that they provide in the overall solution.
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Automation**'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Automation provides runbooks, and these runbooks can be executed to run
    logic using PowerShell, Python, and other scripting languages. Scripts can be
    executed either on-premises or in the cloud, which provides rich infrastructure
    and facilities to create scripts. These kinds of scripts are known as **runbooks**.
    Typically, runbooks implement a scenario such as stopping or starting a virtual
    machine, or creating and configuring storage accounts. It is quite easy to connect
    to the Azure environment from runbooks with the help of assets such as variables,
    certificates, and connections.
  prefs: []
  type: TYPE_NORMAL
- en: In the current solution, we want to connect to Azure Key Vault, read all the
    secrets and keys stored within it, and fetch their expiry dates. These expiry
    dates should be compared with today's date and, if the expiry date is within a
    month, the runbook should raise a custom event on Event Grid using an Event Grid
    custom topic.
  prefs: []
  type: TYPE_NORMAL
- en: An Azure Automation runbook using a PowerShell script will be implemented to
    achieve this. Along with the runbook, a scheduler will also be created that will
    execute the runbook once a day at 12.00 AM.
  prefs: []
  type: TYPE_NORMAL
- en: '**A custom Azure Event Grid topic**'
  prefs: []
  type: TYPE_NORMAL
- en: Once the runbook identifies that a secret or key is going to expire within a
    month, it will raise a new custom event and publish it to the custom topic created
    specifically for this purpose. Again, we will go into the details of the implementation
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Logic Apps**'
  prefs: []
  type: TYPE_NORMAL
- en: A logic app is a serverless service that provides workflow capabilities. Our
    logic app will be configured to be triggered as and when an event is published
    on the custom Event Grid topic. After it is triggered, it will invoke the workflow
    and execute all the activities in it one after another. Generally, there are multiple
    activities, but for the purpose of this example, we will invoke one Azure function
    that will send both email and SMS messages. In a full-blown implementation, these
    notification functions should be implemented separately in separate Azure functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Functions**'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions is used to notify users and stakeholders about the expiration
    of secrets and keys using email and SMS. SendGrid is used to send emails, while
    Twilio is used to send SMS messages from Azure Functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will take a look at the prerequisites before implementing
    the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will need an Azure subscription with contributor rights at the very least.
    As we are only deploying services to Azure and no external services are deployed,
    the subscription is the only prerequisite. Let's go ahead and implement the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A key vault should already exist. If not, one should be created.
  prefs: []
  type: TYPE_NORMAL
- en: This step should be performed if a new Azure Key Vault instance needs to be
    provisioned. Azure provides multiple ways in which to provision resources. Prominent
    among them are Azure PowerShell and the Azure CLI. The Azure CLI is a command-line
    interface that works across platforms. The first task will be to provision a key
    vault in Azure. In this implementation, we will use Azure PowerShell to provision
    the key vault.
  prefs: []
  type: TYPE_NORMAL
- en: Before Azure PowerShell can be used to create a key vault, it is important to
    log into Azure so that subsequent commands can be executed successfully to create
    the key vault.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1: Provisioning an Azure Key Vault instance**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to prepare the environment for the sample. This involves
    logging into the Azure portal, selecting an appropriate subscription, and then
    creating a new Azure resource group and a new Azure Key Vault resource:'
  prefs: []
  type: TYPE_NORMAL
- en: Execute the `Connect-AzAccount` command to log into Azure. It will prompt for
    credentials in a new window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After a successful login, if there are multiple subscriptions available for
    the login ID provided, they will all be listed. It is important to select an appropriate
    subscription—this can be done by executing the `Set-AzContext` cmdlet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new resource group in your preferred location. In this case, the name
    of the resource group is `IntegrationDemo` and it is created in the `West Europe`
    region:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new Azure Key Vault resource—the name of the vault, in this case,
    is `keyvaultbook`, and it is enabled for deployment, template deployment, disk
    encryption, soft delete, and purge protection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Please note that the key vault name needs to be unique. You may not be able
    to use the same name for two key vaults. The preceding command, when executed
    successfully, will create a new Azure Key Vault resource. The next step is to
    provide access to a service principal on the key vault.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2: Creating a service principal**'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using an individual account to connect to Azure, Azure provides service
    principals, which are, in essence, service accounts that can be used to connect
    to Azure Resource Manager and run activities. Adding a user to an Azure directory/tenant
    makes them available everywhere, including in all resource groups and resources,
    due to the nature of security inheritance in Azure. Access must be explicitly
    revoked from resource groups for users if they are not allowed to access them.
    Service principals help by assigning granular access and control to resource groups
    and resources, and, if required, they can be given access to the subscription
    scope. They can also be assigned granular permissions, such as reader, contributor,
    or owner permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, service principals should be the preferred mechanism to consume Azure
    services. They can be configured either with a password or with a certificate
    key. Service principals can be created using the `New-AzAdServicePrinicipal` command,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The important configuration values are the scope and role. The scope determines
    the access area for the service application—it is currently shown at the subscription
    level. Valid values for scope are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The role provides permissions to the assigned scope. The valid values are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Owner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contributor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource-specific permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the preceding command, owner permissions have been provided to the newly
    created service principal.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use certificates if needed. For simplicity, we will proceed with
    the password.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the service principal we created, the secret will be hidden. To find out
    the secret, you can try the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`$UnsecureSecret` will have your secret key.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with the service principal, an Application Directory application will
    be created. The application acts as the global representation of our application
    across directories and the principal is like a local representation of the application.
    We can create multiple principals using the same application in a different directory.
    We can get the details of the application created using the `Get-AzAdApplication`
    command. We will save the output of this command to a variable, `$app`, as we
    will need this later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have now created a service principal using a secret; another secure way of
    creating one is using certificates. In the next section, we will create a service
    principal using certificates.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3: Creating a service principal using certificates**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a service principal using certificates, the following steps should
    be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create a self-signed certificate or purchase a certificate**: A self-signed
    certificate is used to create this example end-to-end application. For real-life
    deployments, a valid certificate should be purchased from a certificate authority.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create a self-signed certificate, the following command can be run. The
    self-signed certificate is exportable and stored in a personal folder on the local
    machine—it also has an expiry date:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Get-Item` cmdlet reads the certificate from the certificate store and stores
    it in the `$cert1` variable. The `Export-PfxCertificate` cmdlet actually exports
    the certificate in the certificate store to the filesystem. In this case, it is
    in the `C:\book` folder.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`X509Certificate2` is created to hold the certificate in memory, and the data
    is converted to a Base64 string using the `System.Convert` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will be using this same principal to connect to Azure from the Azure Automation
    account. It is important that the application ID, tenant ID, subscription ID,
    and certificate thumbprint values are stored in a temporary location so that they
    can be used to configure subsequent resources:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have our service principal ready. The key vault we created doesn't have an
    access policy set, which means no user or application will be able to access the
    vault. In the next step, we will grant permissions to the Application Directory
    application we created to access the key vault.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 4: Creating a key vault policy**'
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, we have created the service principal and the key vault. However,
    the service principal still does not have access to the key vault. This service
    principal will be used to query and list all the secrets, keys, and certificates
    from the key vault, and it should have the necessary permissions to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide the newly created service principal permission to access the key
    vault, we will go back to the Azure PowerShell console and execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: Set-AzKeyVaultAccessPolicy -VaultName keyvaultbook -ResourceGroupName IntegrationDemo
    -ObjectId $ServicePrincipal.Id -PermissionsToKeys get,list,create -PermissionsToCertificates
    get,list,import -PermissionsToSecrets get,list -Verbose
  prefs: []
  type: TYPE_NORMAL
- en: 'Referring to the previous command block, take a look at the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Set-AzKeyVaultAccessPolicy` provides access permissions to users, groups,
    and service principals. It accepts the key vault name and the service principal
    object ID. This object is different from the application ID. The output of the
    service principal contains an `Id` property, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![The output displaying the details of the service principal, such as Service
    principal name, Application ID, Object Type, and so on.](img/Figure_11.15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.15: Finding the object ID of the service principal'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`PermissionsToKeys` provides access to keys in the key vault, and the `get`,
    `list`, and `create` permissions are provided to this service principal. There
    is no write or update permission provided to this principal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PermissionsToSecrets` provides access to secrets in the key vault, and the `get`
    and `list` permissions are provided to this service principal. There is no write
    or update permission provided to this principal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PermissionsToCertificates` provides access to secrets in the key vault, and
    `get`, `import`, and `list` permissions are provided to this service principal.
    There is no write or update permission provided to this principal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, we have configured the service principal to work with the Azure
    key vault. The next part of the solution is to create an Automation account.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 5: Creating an Automation account**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like before, we will be using Azure PowerShell to create a new Azure Automation
    account within a resource group. Before creating a resource group and an Automation
    account, a connection to Azure should be established. However, this time, use
    the credentials for the service principal to connect to Azure. The steps are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command to connect to Azure using the service application is as follows.
    The value is taken from the variables that we initialized in the previous steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure that you have access by checking `Get-AzContext` as shown here. Make
    a note of the subscription ID as it will be needed in subsequent commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After connecting to Azure, a new resource containing the resources for the
    solution and a new Azure Automation account should be created. You are naming
    the resource group `VaultMonitoring`, and creating it in the `West Europe` region.
    You will be creating the remainder of the resources in this resource group as
    well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create three automation variables. The values for these, that is, the
    subscription ID, tenant ID, and application ID, should already be available using
    the previous steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now it''s time to upload a certificate, which will be used to connect to Azure
    from Azure Automation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next step is to install PowerShell modules related to Key Vault and Event
    Grid in the Azure Automation account, as these modules are not installed by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Azure portal, navigate to the already-created `VaultMonitoring` resource
    group by clicking on **Resource Groups** in the left-hand menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the already-provisioned Azure Automation account, `Az.profile` module,
    and so we have to install it before the Event Grid module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on `Az.profile` in the search box, as shown in *Figure 11.16*:![Searching
    for the Az.profile module in the Browser Gallery.](img/Figure_11.16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.16: The Az.Profile module in the module gallery'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: From the search results, select `Az.Profile` and click on the **Import** button
    in the top menu. Finally, click on the **OK** button. This step takes a few seconds
    to complete. After a few seconds, the module should be installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The status of the installation can be checked from the **Module** menu item.
    *Figure 11.17* demonstrates how we can import a module:![The Az.Profile pane displaying
    the status of the module](img/Figure_11.17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.17: Az.Profile module status'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Perform *steps 9*, *10*, and *11* again in order to import and install the `Az.EventGrid`
    module. If you are warned to install any dependencies before proceeding, go ahead
    and install the dependencies first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform *steps 9*, *10*, and *11* again in order to import and install the `Az.KeyVault`
    module. If you are warned to install any dependencies before proceeding, go ahead
    and install the dependency first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we have imported the necessary modules, let's go ahead and create the
    Event Grid topic.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 6: Creating an Event Grid topic**'
  prefs: []
  type: TYPE_NORMAL
- en: If you recall the architecture that we used, we need an Event Grid topic. Let's
    create one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command that''s used to create an Event Grid topic using PowerShell is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The process of creating an Event Grid topic using the Azure portal is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Azure portal, navigate to the already-created `Vaultmonitoring` resource
    group by clicking on **Resource Groups** in the left-hand menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on the `Event Grid Topic` in the search box. Select it and then
    click on the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in the appropriate values in the resultant form by providing a name, selecting
    a subscription, and selecting the newly created resource group, the location,
    and the event schema.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we already discussed, the Event Grid topic provides an endpoint where the
    source will send the data. Since we have our topic ready, let's prepare the source
    Automation account.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 7: Setting up the runbook**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This step will focus on creating an Azure Automation account and PowerShell
    runbooks that will contain the core logic of reading Azure key vaults and retrieving
    secrets stored within them. The steps required for configuring Azure Automation
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Vaultmonitoring` resource group by clicking on **Resource Groups** in the
    left-hand menu.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the already-provisioned Azure Automation account, `MonitoringKeyVault`.
    Then, click on **Runbooks** in the left-hand menu, and click on **+Add a Runbook**
    from the top menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Create a new Runbook** and provide a name. Let's call this runbook
    **CheckExpiredAssets**, and then set **Runbook type** to **PowerShell**:![Creating
    a Runbook and giving the Runbook name as CheckExpiredAssets, and Runbook type
    as PowerShell.](img/Figure_11.18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.18: Creating a runbook'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: '`AutomationCertifcate`. The values are retrieved from these stores and are
    assigned to the variables, as shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next code within the runbook helps to log into Azure using the service
    principal with values from the variables declared previously. Also, the code selects
    an appropriate subscription. The code is shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since Azure Event Grid was provisioned in *step 6* of this section, its endpoint
    and keys are retrieved using the `Get-AzEventGridTopic` and `Get-AzEventGridTopicKey`
    cmdlets.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Azure Event Grid generates two keys—a primary and a secondary. The first key
    reference is taken as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, all key vaults that were provisioned within the subscription are retrieved
    using iteration. While looping, all secrets are retrieved using the `Get-AzKeyVaultSecret`
    cmdlet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The expiry date of each secret is compared to the current date, and if the difference
    is less than a month, it generates an Event Grid event and publishes it using
    the `invoke-webrequest` command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The same steps are executed for certificates stored within the key vault. The
    cmdlet used to retrieve all the certificates is `Get-AzKeyVaultCertificate`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The event that is published to Event Grid should be in the JSON array. The generated
    message is converted to JSON using the `ConvertTo-Json` cmdlet and then converted
    to an array by adding `[` and `]` as a prefix and suffix.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to connect to Azure Event Grid and publish the event, the sender should
    supply the key in its header. The request will fail if this data is missing in
    the request payload:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Publish the runbook by clicking on the **Publish** button, as shown in *Figure
    11.19*:![The Runbook is published and the script is displayed on the screen in
    the portal.](img/Figure_11.19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.19: Publishing the runbook'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Scheduler**: Create an Azure Automation scheduler asset to execute this runbook
    once every day at 12.00 AM. Click on **Schedules** from the left-hand menu of
    Azure Automation and click on **+Add a schedule** in the top menu.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide scheduling information in the resulting form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This should conclude the configuration of the Azure Automation account.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 8: Working with SendGrid**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this step, we will be creating a new SendGrid resource. The SendGrid resource
    is used to send emails from the application without needing to install a **Simple
    Mail Transfer Protocol (SMTP)** server. It provides a REST API and a C# **Software
    Development Kit (SDK)**, by means of which it is quite easy to send bulk emails.
    In the current solution, Azure Functions will be used to invoke the SendGrid APIs
    to send emails, and so this resource needs to be provisioned. This resource has
    separate costing and is not covered as part of the Azure cost—there is a free
    tier available that can be used for sending emails:'
  prefs: []
  type: TYPE_NORMAL
- en: A `SendGrid` resource is created just like any other Azure resource. Search
    for `sendgrid`, and we will get **SendGrid Email Delivery** in the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the resource and click on the **Create** button to open its configuration
    form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select an appropriate pricing tier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the appropriate contact details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tick the **Terms of use** check box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Complete the form and then click on the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the resource is provisioned, click on the **Manage** button in the top
    menu—this will open the SendGrid website. The website may request email configuration.
    Then, select **API Keys** from the **Settings** section and click on the **Create
    API Key** button:![The API Keys window displaying the message “Get started creating
    API Keys”.](img/Figure_11.20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.20: Creating API keys for SendGrid'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: From the resulting window, select **Full Access** and click on the **Create
    & View** button. This will create the key for the SendGrid resource; keep a note
    of this key, as it will be used with the Azure Functions configuration for SendGrid:![The
    ‘Create API Key’ pane displaying the option for API key permissions as Full Access,
    Restricted Access, and Billing Access; of which we select the Full Access option.](img/Figure_11.21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.21: Setting up the access level in the SendGrid portal'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that we have configured access levels for SendGrid, let's configure another
    third-party service, which is called Twilio.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 9: Getting started with Twilio**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this step, we will be creating a new Twilio account. Twilio is used for
    sending bulk SMS messages. To create an account with Twilio, navigate to [twilio.com](http://twilio.com)
    and create a new account. After successfully creating an account, a mobile number
    is generated that can be used to send SMS messages to receivers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Choosing the first Twilio number.](img/Figure_11.22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.22: Choosing a Twilio number'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The Twilio account provides both production and test keys. Copy the test key
    and token to a temporary location, such as Notepad, as they will be required later
    within Azure Functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Twilio account dashboard displaying project info such as Trial Balance,
    Trial number, Account SID, and Auth token.](img/Figure_11.23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.23: Setting up Twilio'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We have SendGrid and Twilio in place for the notification service; however,
    we need something that can take the event and notify the users. Here comes the
    role of a function app. In the next section, we will be creating a function app
    that will help with sending SMS and emails.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 10: Setting up a function app**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this step, we will be creating a new function app responsible for sending
    emails and SMS notifications. The purpose of the function app within the solution
    is to send notification messages to users regarding the expiry of secrets in the
    key vault. A single function will be responsible for sending both emails and SMS
    messages—note that this could have been divided into two separate functions. The
    first step is to create a new function app and host a function within it:'
  prefs: []
  type: TYPE_NORMAL
- en: As we have done before, navigate to your resource group, click on the `function
    app` resource. Then, click on the **Create** button to get the **Function App**
    form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in the **Function App** form and click on the **Create** button. The name
    of the function app must be unique across Azure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the function app is provisioned, create a new function called `SMSandEMailFunction`
    by clicking on the **+** button next to the **Functions** item in the left-hand
    menu. Then, select **In-portal** from the central dashboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `SMSandEMailFunction`. Then, click on the **Create** button—the **Authorization
    level** option can be any value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove the default code, replace it with the code shown in the following listing,
    and then click on the **Save** button in the top menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click on the function app name in the left-hand menu and click again on the
    **Application settings** link in the main window:![Navigating to the NotificationFunctionAppBook
    pane and then selecting the Application settings option.](img/Figure_11.24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.24: Navigating to Application settings'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Navigate to the `adminPhone` and `servicePhone` should already be configured
    on the Twilio website. `servicePhone` is the phone number generated by Twilio
    that is used for sending SMS messages, and `adminPhone` is the phone number of
    the administrator to whom the SMS should be sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also note that Twilio expects the destination phone number to be in a particular
    format depending on the country (for India, the format is `+91 xxxxx xxxxx`).
    Note the spaces and country code in the number.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We also need to add the keys for both SendGrid and Twilio within the application
    settings. These settings are mentioned in the following list. You may already
    have these values handy because of activities performed in earlier steps:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The value of `SendGridAPIKeyAsAppSetting` is the key for SendGrid.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TwilioAccountSid` is the system identifier for the Twilio account. This value
    was already copied and stored in a temporary location in *Step 9: Getting started
    with Twilio*.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TwilioAuthToken` is the token for the Twilio account. This value was already
    copied and stored in a temporary place in an earlier step.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Save the settings by clicking on the **Save** button in the top menu:![The App
    settings pane displaying the App setting name and the value for it.](img/Figure_11.25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.25: Configuring application settings'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Click on the **Integrate** link in the left-hand menu just below the name of
    the function, and click on **+ New Output**. This is to add an output for the
    SendGrid service:![Adding output to the function app.](img/Figure_11.26.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.26: Adding an output to the function app'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Next, select **SendGrid**; it might ask you to install the SendGrid extension.
    Install the extension, which will take a couple of minutes:![Configuring the function
    app by selecting the SendGrid option.](img/Figure_11.27.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.27: Configuring a function app'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: After installing the extension, the output configuration form appears. The important
    configuration items in this form are **Message parameter name** and **SendGrid
    API Key App Setting**. Leave the default value for **Message parameter name**
    and click on the drop-down list to select **SendGridAPIKeyAsAppSetting** as the
    API app setting key. This was already configured in a previous step within the
    app settings configuration. The form should be configured as shown in *Figure
    11.28*, and then you need to click on the **Save** button:![Setting up the SendGrid
    output by adding values in fields such as Message parameter name, To address,
    From address, and so on.](img/Figure_11.28.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.28: Setting up SendGrid'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Click on **+ New Output** again; this is to add an output for the Twilio service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, select **Twilio SMS**. It might ask you to install the Twilio SMS extension.
    Install the extension, which will take a couple of minutes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After installing the extension, the output configuration form appears. The important
    configuration items in this form are `sms`. This is done because the `message`
    parameter is already used for the SendGrid service parameter. Ensure that the
    value of `TwilioAccountSid` and that the value of **Auth Token setting** is **TwilioAuthToken**.
    These values were already configured in a previous step of the app settings configuration.
    The form should be configured as shown in *Figure 11.29*, and then you should
    click on **Save**:![Setting up Twilio SMS output.](img/Figure_11.29.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.29: Setting up Twilio SMS output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Our SendGrid and Twilio accounts are ready. Now it's time to use the connectors
    and add them to the logic app. In the next part, we will create the logic app
    and will use connectors to work with the resources we have created so far.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 11: Creating a logic app**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this step, we will be creating a new logic app workflow. We have authored
    an Azure Automation runbook that queries all the secrets in all key vaults and
    publishes an event if it finds any of them expiring within a month. The logic
    app''s workflow acts as a subscriber to these events:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step within the **Logic App** menu is to create a logic app workflow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in the resultant form after clicking on the **Create** button. We are provisioning
    the logic app in the same resource group as the other resources for this solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the logic app is provisioned, it opens the designer window. Select **Blank
    Logic App** from the **Templates** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the resultant window, add a trigger that can subscribe to Event Grid. Logic
    Apps provides a trigger for Event Grid, and you can search for this to see whether
    it's available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, select the **When a resource event occurs (preview)** trigger:![In the
    Azure Event Grid pane, selecting a trigger from the Event Grid.](img/Figure_11.30.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.30: Selecting a trigger from Event Grid'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: In the resultant window, select **Connect with Service Principal**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Provide the service principal details, including the application ID (**Client
    ID**), tenant ID, and password. This trigger does not accept a service principal
    that authenticates with the certificate—it accepts a service principal only with
    a password. Create a new service principal at this stage that authenticates with
    a password (the steps for creating a service principal based on password authentication
    were covered earlier, in *step 2*) and use the details of the newly created service
    principal for Azure Event Grid configuration, as shown in *Figure 11.31*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Adding the service principal details for the connection, such as Connection
    Name, Client ID, Client Secret, and Tenant.](img/Figure_11.31.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.31: Providing the service principal details for connection'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Select the subscription. Based on the scope of the service principal, this will
    get auto-filled. Select **Microsoft.EventGrid.Topics** as the **Resource Type**
    value and set the name of the custom topic as **ExpiredAssetsKeyVaultEvents**:![On
    the ‘When a resource event occurs (preview)’ pane, adding Event Grid trigger details
    such as Subscription, Resource type, Resource Name, and so on.](img/Figure_11.32.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.32: Providing Event Grid trigger details'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: The previous step will create a connector, and the connection information can
    be changed by clicking on **Change connection**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final configuration of the Event Grid trigger should be similar to *Figure
    11.33*:![The ‘When a resource event occurs (preview)’ pane displaying the final
    overview of the Event Grid trigger.](img/Figure_11.33.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.33: Event Grid trigger overview'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Add a new **Parse JSON** activity after the Event Grid trigger—this activity
    needs the JSON schema. Generally, the schema is not available, but this activity
    helps generate the schema if valid JSON is provided to it:![The Parse JSON activity
    showing the Content as Data object and the schema as JSON script.](img/Figure_11.34.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.34: Parse JSON activity'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Click on **Use sample payload to generate schema** and provide the following
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A question might arise here regarding the sample payload. At this stage, how
    do you calculate the payload that''s generated by the Event Grid publisher? The
    answer to this lies in the fact that this sample payload is exactly the same as
    is used in the data element in the Azure Automation runbook. You can take a look
    at that code snippet again:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The **Content** box should contain dynamic content coming out from the previous
    trigger, as demonstrated in *Figure 11.35*:![Providing dynamic content to the
    Parse JSON activity.](img/Figure_11.35.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.35: Providing dynamic content to the Parse JSON activity'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Add another **Azure Functions** action after **Parse JSON**, and then select
    **Choose an Azure function**. Select the Azure function apps called **NotificationFunctionAppBook**
    and **SMSAndEmailFunction**, which were created earlier:![In the Choose action
    pane, entering the keywords ‘Azure function’ in the search box and then selecting
    the Azure Functions action.](img/Figure_11.36.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.36: Adding an Azure Functions action'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Click on the **Request Body** text area and fill it with the following code.
    This is done to convert the data into JSON before sending it to the Azure function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Place the cursor after the `":"` in the preceding code and click on **Add dynamic
    content | Body** from the previous activity:![Converting data to JSON before sending
    it to an Azure function.](img/Figure_11.37.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.37: Converting data to JSON before sending it to an Azure function'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Save the entire logic app; it should look as follows:![The Logic App workflow
    displayed in the widget, showing the action flow from when the resource event
    occured, to the Parse JSON action, and finally, reaching the SMSandEmailFunction
    action.](img/Figure_11.38.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.38: Logic app workflow'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Once you save the logic app, your solution is ready to be tested. If you don't
    have any keys or secrets, try adding them with an expiry date so that you can
    confirm whether your solution is working.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Upload some secrets and certificates that have expiry dates to Azure Key Vault
    and execute the Azure Automation runbook. The runbook is scheduled to run on a
    schedule. Additionally, the runbook will publish events to Event Grid. The logic
    app should be enabled, and it will pick the event and finally invoke the Azure
    function to send email and SMS notifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The email should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A widget showing that the email has been received regarding the expiring
    keys and the header reads “Key Vault Assets Expiring Soon…”](img/Figure_11.39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.39: Email received regarding the expiring keys'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this exercise, we had a problem, we architected a solution, and we implemented
    it. This is exactly what happens in the role of an architect. Customers will have
    specific requirements and, based on those, you must develop a solution. On that
    note, we are concluding this chapter. Let's do a quick recap of what we have discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter introduced Logic Apps and demonstrated a complete end-to-end solution
    using multiple Azure services. The chapter focused heavily on creating an architecture
    that integrated multiple Azure services to create an end-to-end solution. The
    services used in the solution were Azure Automation, Azure Logic Apps, Azure Event
    Grid, Azure Functions, SendGrid, and Twilio. These services were implemented through
    the Azure portal and PowerShell using service principals as service accounts.
    The chapter also showed a number of ways of creating service principals with password
    and certificate authentication.
  prefs: []
  type: TYPE_NORMAL
- en: A solution to a problem can be found in multiple ways. You could use an Outlook
    trigger in a logic app instead of SendGrid. There will be many solutions to a
    problem—the one to go with depends on what approach you are taking. The more familiar
    you are with the services, the greater the number of options you will have. In
    the next chapter, you will learn about the importance of events in both Azure
    and Azure application architecture.
  prefs: []
  type: TYPE_NORMAL
