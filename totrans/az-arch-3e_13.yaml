- en: 13\. Integrating Azure DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about big data eventing and its relationship
    with Azure's Event Hubs and Stream Analytics services. Software development is
    a complex undertaking comprising multiple processes and tools, and involving people
    from different departments. They all need to come together and work in a cohesive
    manner. With so many variables, the risks are high when you are delivering to
    end customers. One small omission or misconfiguration might lead to the application
    coming crashing down. This chapter is about adopting and implementing practices
    that reduce this risk considerably and ensure that high-quality software can be
    delivered to the customer over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before getting into the details of DevOps, here is a list of the problems faced
    by software companies that DevOps addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: Rigid organizations that don't welcome change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time-consuming processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolated teams working in silos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monolithic design and big bang deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manual execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lack of innovation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevOps practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevOps preparation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevOps for PaaS solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevOps for virtual machine-based (IaaS) solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevOps for container-based (IaaS) solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure DevOps and Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure tools for DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's currently no industry-wide consensus regarding the definition of DevOps.
    Organizations have formulated their own definition of DevOps and tried to implement it.
    They have their own perspective and think they've implemented DevOps once they
    implement automation and configuration management, and use Agile processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on my experience working on DevOps projects in industry, I have defined
    DevOps as the following: DevOps is about the delivery mechanism of software systems.
    It''s about bringing people together, making them collaborate and communicate,
    working together toward a common goal and vision. It''s about taking joint responsibility,
    accountability, and ownership. It''s about implementing processes that foster
    collaboration and a service mindset. It enables delivery mechanisms that bring
    agility and flexibility to the organization. Contrary to popular belief, DevOps
    isn''t about tools, technology, and automation. These are enablers that help with
    collaboration, the implementation of Agile processes, and faster and better delivery
    to the customer.'
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple definitions available on the internet for DevOps, and they
    aren't wrong. DevOps doesn't provide a framework or methodology. It's a set of
    principles and practices that, when employed within an organization, engagement,
    or project, achieve the goal and vision of both DevOps and the organization. These
    principles and practices don't mandate any specific processes, tools and technologies,
    or environments. DevOps provides guidance that can be implemented through any
    tool, technology, or process, although some of the technology and processes might
    be more applicable than others to achieve the vision of DevOps' principles and
    practices.
  prefs: []
  type: TYPE_NORMAL
- en: Although DevOps practices can be implemented in any organization that provides
    services and products to customers, going forward in this book, we'll look at
    DevOps from the perspective of software development and the operations department
    of any organization.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is DevOps? DevOps is defined as a set of principles and practices bringing
    all teams, including developers and operations, together from the start of the
    project for faster, quicker, and more efficient end-to-end delivery of value to
    the end customer again and again, in a consistent and predictable manner, reducing
    time to market, thereby gaining a competitive advantage.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding definition of DevOps doesn't indicate or refer to any specific
    processes, tools, or technology. It doesn't prescribe any methodology or environment.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of implementing DevOps principles and practices in any organization
    is to ensure that the demands of stakeholders (including customers) and expectations
    are met efficiently and effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Customer demands and expectations are met when the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: The customer gets the features they want
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The customer gets the features they want when they want them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The customer gets faster updates on features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The quality of delivery is high
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an organization can meet these expectations, customers are happy and remain
    loyal. This, in turn, increases the market competitiveness of the organization,
    which results in a bigger brand and market valuation. It has a direct impact on
    the top and bottom lines of the organization. The organization can invest further
    in innovation and customer feedback, bringing about continuous changes to its
    systems and services in order to stay relevant.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of DevOps principles and practices in any organization is
    guided by its surrounding ecosystem. This ecosystem is made up of the industry
    and domains the organization belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: 'DevOps is based on a set of principles and practices. We''ll look into the
    details of these principles and practices later in this chapter. The core principles
    of DevOps are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Agility**: Being Agile increases the overall flexibility to changes and ensures
    that adaptability increases to every changing environment and being productive.
    Agile processes have a shorter work duration and it''s easy to find issues earlier
    in the development life cycle rather than much later, thereby reducing the technical
    debt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automation**: The adoption of tools and automation increases the overall
    efficiency and predictability of the process and end product. It helps in doing
    things faster and in an easier and cheaper manner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collaboration**: Collaboration refers to a common repository, the rotation
    of work responsibilities, the sharing of data and information, and other aspects
    that improve the productivity of each member of the team, thereby supporting the
    overall effective delivery of the product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feedback**: This refers to quick and early feedback loops between multiple
    teams about things that work and things that don''t work. It helps teams to prioritize
    issues and fix them in subsequent releases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The core DevOps practices are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Continuous integration**: This refers to the process of validating and verifying
    the quality and correctness of the code pushed within the repository by developers.
    It can be scheduled, manual, or continuous. Continuous means that the process
    will check for various quality attributes each time a developer pushes the code,
    while scheduled means on a given time schedule, the checks will be conducted.
    Manual refers to manual execution by an administrator or developer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration management**: This is an important facet of DevOps and provides
    guidance for configuring infrastructure and applications either by pulling configurations
    from configuration management servers or by pushing these configurations on a
    schedule. Configuration management should bring back the environment to the expected
    desired state every time it gets executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous delivery**: Continuous delivery refers to the state of readiness
    of an application to be able to be deployed in any existing, as well as a new,
    environment. It is generally executed by means of a release definition in lower
    environments like development and testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous deployment**: Continuous deployment refers to the ability to deploy
    the environment and application in production automatically. It is generally executed
    by means of a release definition in the production environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous learning**: This refers to the process of understanding the issues
    faced by operations and customers and ensuring that they get communicated to development
    and testing teams such that they can fix those issues in subsequent releases to
    improve the overall health and usability of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The essence of DevOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DevOps is not a new paradigm; however, it's gaining a lot of popularity and
    traction. Its adoption is at its highest level, and more and more companies are
    undertaking this journey. I purposely mentioned DevOps as a journey because there
    are different levels of maturity within DevOps. While successfully implementing
    continuous deployment and delivery are considered the highest level of maturity
    in this journey, adopting source code control and Agile software development are
    considered the first step in the DevOps journey.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first things DevOps talks about is breaking down the barriers between
    the development and the operations teams. It brings about close collaboration
    between multiple teams. It's about breaking the mindset that the developer is
    responsible for writing the code only and passing it on to operations for deployment
    once it's tested. It's also about breaking the mindset that operations have no
    role to play in development activities. Operations should influence the planning
    of the product and should be aware of the features coming up as releases. They
    should also continually provide feedback to the developers on operational issues
    such that they can be fixed in subsequent releases. They should influence the
    design of the system to improve the operational working of the system. Similarly,
    developers should help the operations team to deploy the system and solve incidents
    when they arise.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of DevOps talks about faster and more efficient end-to-end delivery
    of systems to stakeholders. It doesn't talk about how fast or efficient the delivery
    should be. It should be fast enough for the organization's domain, industry, customer
    segmentation, and needs. For some organizations, quarterly releases are good enough,
    while for others it could be weekly. Both are valid from a DevOps point of view,
    and these organizations can deploy relevant processes and technologies to achieve
    their target release deadlines. DevOps doesn't mandate any specific time frame
    for **continuous integration/continuous deployment** (**CI/CD**). Organizations
    should identify the best implementation of DevOps principles and practices based
    on their overall project, engagement, and organizational vision.
  prefs: []
  type: TYPE_NORMAL
- en: The definition also talks about end-to-end delivery. This means that everything
    from the planning and delivery of the system through to the services and operations
    should be part of DevOps adoption. Processes should allow greater flexibility,
    modularity, and agility in the application development life cycle. While organizations
    are free to use the best fitting process—Waterfall, Agile, Scrum, or another—typically,
    organizations tend to favor Agile processes with iteration-based delivery. This
    allows faster delivery in smaller units, which are far more testable and manageable
    compared to a large delivery.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps repeatedly talks about end customers in a consistent and predictable
    manner. This means that organizations should continually deliver to customers
    with newer and upgraded features using automation. We can't achieve consistency
    and predictability without the use of automation. Manual work should be non-existent
    to ensure a high level of consistency and predictability. Automation should also
    be end-to-end, to avoid failures. This also indicates that the system design should
    be modular, allowing faster delivery on systems that are reliable, available,
    and scalable. Testing plays a big role in consistent and predictable delivery.
  prefs: []
  type: TYPE_NORMAL
- en: The end result of implementing these practices and principles is that the organization
    is able to meet the expectations and demands of customers. The organization is
    able to grow faster than the competition, and further increase the quality and
    capability of their product and services through continuous innovation and improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the idea behind DevOps, it's time to look into core
    DevOps practices.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'DevOps consists of multiple practices, each providing a distinct functionality
    to the overall process. The following diagram shows the relationship between them.
    Configuration management, continuous integration, and continuous deployment form
    the core practices that enable DevOps. When we deliver software services that
    combine these three services, we achieve continuous delivery. Continuous delivery
    is the capability and level of maturity of an organization that''s dependent on
    the maturity of configuration management, continuous integration, and continuous
    deployment. Continuous feedback, at all stages, forms the feedback loop that helps
    to provide superior services to customers. It runs across all DevOps practices.
    Let''s deep dive into each of these capabilities and DevOps practices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![DevOps capabilities and practices](img/B15432_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: DevOps practices'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Configuration management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Business applications and services need an environment in which they can be
    deployed. Typically, the environment is an infrastructure composed of multiple
    servers, computers, network, storage, containers, and many more services working
    together such that business applications can be deployed on top of them. Business applications are
    decomposed into multiple services running on multiple servers, either on-premises
    or on the cloud, and each service has its own configuration along with requirements
    related to the infrastructure's configuration. In short, both the infrastructure
    and the application are needed to deliver systems to customers, and both of them
    have their own configuration. If the configuration drifts, the application might
    not work as expected, leading to downtime and failure. Moreover, as the **Application
    Lifecycle Management** (**ALM**) process dictates the use of multiple stages and
    environments, an application would be deployed to multiple environments with different
    configurations. The application would be deployed to the development environment
    for developers to see the result of their work. It would then be deployed to multiple
    test environments with different configurations for functional tests, load and
    stress tests, performance tests, integration tests, and more; it would also be
    deployed to the preproduction environment to conduct user-acceptance tests, and
    finally into the production environment. It's important that an application can
    be deployed to multiple environments without undertaking any manual changes to
    its configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration management provides a set of processes and tools and they help
    to ensure that each environment and application gets its own configuration. Configuration
    management tracks configuration items, and anything that changes from environment
    to environment should be treated as a configuration item. Configuration management
    also defines the relationships between configuration items and how changes in
    one configuration item will impact other configuration items.
  prefs: []
  type: TYPE_NORMAL
- en: '**Usage of configuration management**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuration management helps in the following places:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Infrastructure as Code**: When the process of provisioning infrastructure
    and its configuration is represented through code, and the same code goes through
    the application life cycle process, it''s known as **Infrastructure as Code** (**IaC**).
    IaC helps to automate the provisioning and configuration of infrastructure. It
    also represents the entire infrastructure in code that can be stored in a repository
    and version-controlled. This allows users to employ the previous environment''s
    configurations when needed. It also enables the provisioning of an environment
    multiple times in a consistent and predictable manner. All environments provisioned
    in this way are consistent and equal in all ALM stages. There are many tools that
    help in achieving IaC, including ARM templates, Ansible, and Terraform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`webdeploy` package on a server, deploying a SQL server schema and data (`bacpac`)
    on another server, and changing the SQL connection string on the web server to
    represent the appropriate SQL server. Configuration management stores values for
    the application''s configuration for each environment on which it is deployed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The configuration applied should also be monitored. The expected and desired
    configuration should be consistently maintained. Any drift from this expected
    and desired configuration would render the application unavailable. Configuration
    management is also capable of finding the drift and re-configuring the application
    and environment to its desired state.
  prefs: []
  type: TYPE_NORMAL
- en: With automated configuration management in place, nobody on the team has to
    deploy and configure environments and applications in production. The operations
    team isn't reliant on the development team or long deployment documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect of configuration management is source code control. Business
    applications and services comprise code and other artifacts. Multiple team members
    work on the same files. The source code should always be up to date and should
    be accessible by only authenticated team members. The code and other artifacts
    by themselves are configuration items. Source control helps in collaboration and
    communication within the team since everybody is aware of what everyone else is
    doing and conflicts are resolved at an early stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuration management can be broadly divided into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the virtual machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outside the virtual machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration management tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The tools available for configuration management inside the virtual machine
    are discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: '**Desired State Configuration**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Desired State Configuration** (**DSC**) is a configuration-management platform from
    Microsoft, built as an extension to PowerShell. DSC was originally launched as
    part of **Windows Management Framework** (**WMF**) 4.0\. It''s available as part
    of WMF 4.0 and 5.0 for all Windows Server operating systems before Windows 2008
    R2\. WMF 5.1 is available out of the box on Windows Server 2016/2019 and Windows
    10.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chef, Puppet, and Ansible**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from DSC, there''s a host of configuration-management tools, such as
    Chef, Puppet, and Ansible, supported by Azure. Details about these tools aren''t covered in this book.
    Read more about them here: [https://docs.microsoft.com/azure/virtual-machines/windows/infrastructure-automation](https://docs.microsoft.com/azure/virtual-machines/windows/infrastructure-automation).'
  prefs: []
  type: TYPE_NORMAL
- en: The tools available for configuration management outside of a virtual machine
    are mentioned next.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARM templates**'
  prefs: []
  type: TYPE_NORMAL
- en: ARM templates are the primary means of provisioning resources in ARM. ARM templates
    provide a declarative model through which resources and their configuration, scripts,
    and extensions are specified. ARM templates are based on **JavaScript Object Notation** (**JSON**)
    format. It uses JSON syntax and conventions to declare and configure resources.
    JSON files are text-based, user friendly, and easily readable. They can be stored
    in a source code repository and have version control on them. They are also a
    means to represent infrastructure as code that can be used to provision resources
    in Azure resource groups over and over again, predictably, consistently, and uniformly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Templates provide the flexibility to be generic and modular in their design
    and implementation. Templates give us the ability to accept parameters from users,
    declare internal variables, help define dependencies between resources, link resources
    within the same or different resource groups, and execute other templates. They
    also provide scripting language-type expressions and functions that make them
    dynamic and customizable at runtime. There are two chapters dedicated to ARM templates
    in this book: *Chapters 15, Cross Subscription Deployments Using ARM Templates*,
    and *Chapter 16, ARM Templates Modular Design and Implementation*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to focus on the next important DevOps principle: continuous
    integration.'
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Multiple developers write code that's eventually stored in a common repository.
    The code is normally checked in or pushed to the repository when the developers
    have finished developing their features. This can happen in a day or might take
    days or weeks. Some of the developers might be working on the same feature, and
    they might also follow the same practices of pushing/checking in code in days
    or weeks. This can create issues with the quality of the code. One of the tenets
    of DevOps is to fail fast. Developers should check in/push their code to the repository
    often and compile the code to check whether they've introduced bugs and that the
    code is compatible with the code written by their colleagues. If a developer doesn't
    follow this practice, the code on their machine will grow too large and will be
    difficult to integrate with other code. Moreover, if the compile fails, it's difficult
    and time-consuming to fix the issues that arise.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code integration**'
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration solves these kinds of challenges. Continuous integration
    helps in compiling and validating the code pushed/checked in by a developer by
    taking it through a series of validation steps. Continuous integration creates
    a process flow that consists of multiple steps. Continuous integration is composed
    of continuous automated builds and continuous automated tests. Normally, the first
    step is compiling the code. After the successful compilation, each step is responsible
    for validating the code from a specific perspective. For example, unit tests can
    be executed on the compiled code, and then code coverage can be executed to check
    which code paths are executed by unit tests. These could reveal whether comprehensive
    unit tests are written or whether there's scope to add further unit tests. The
    end result of continuous integration is deployment packages that can be used by
    continuous deployment to deploy them to multiple environments.
  prefs: []
  type: TYPE_NORMAL
- en: '**Frequent code push**'
  prefs: []
  type: TYPE_NORMAL
- en: Developers are encouraged to check in their code multiple times a day, instead
    of doing so after days or weeks. Continuous integration initiates the execution
    of the entire pipeline as soon as the code is checked in or pushed. If compilation
    succeeds, code tests, and other activities that are part of the pipeline, are
    executed without error; the code is deployed to a test environment and integration
    tests are executed on it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Increased productivity**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuous integration increases developer productivity. They don''t have to
    manually compile their code, run multiple types of tests one after another, and
    then create packages out of it. It also reduces the risk of getting bugs introduced
    in the code and the code doesn''t get stale. It provides early feedback to the
    developers about the quality of their code. Overall, the quality of deliverables
    is high and they are delivered faster by adopting continuous integration practices.
    A sample continuous integration pipeline is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A sample Continuous Integration pipeline](img/B15432_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: Continuous integration pipeline'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Build automation**'
  prefs: []
  type: TYPE_NORMAL
- en: Build automation consists of multiple tasks executing in sequence. Generally,
    the first task is responsible for fetching the latest source code from the repository.
    The source code might comprise multiple projects and files. They are compiled
    to generate artifacts, such as executables, dynamic link libraries, and assemblies.
    Successful build automation reflects that there are no compile-time errors in
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: There could be more steps to build automation, depending on the nature and type
    of the project.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test automation**'
  prefs: []
  type: TYPE_NORMAL
- en: Test automation consists of tasks that are responsible for validating different
    aspects of code. These tasks are related to testing code from a different perspective
    and are executed in sequence. Generally, the first step is to run a series of
    unit tests on the code. Unit testing refers to the process of testing the smallest
    denomination of a feature by validating its behavior in isolation from other features.
    It can be automated or manual; however, the preference is toward automated unit
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage is another type of automated testing that can be executed on code
    to find out how much of the code is executed when running unit tests. It's generally
    represented as a percentage and refers to how much code is testable through unit
    testing. If the code coverage isn't close to 100%, it's either because the developer
    hasn't written unit tests for that behavior or the uncovered code isn't required
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: The successful execution of test automation, resulting in no significant code
    failure, should start executing the packaging tasks. There could be more steps
    to test automation depending on the nature and type of the project.
  prefs: []
  type: TYPE_NORMAL
- en: '**Packaging**'
  prefs: []
  type: TYPE_NORMAL
- en: Packaging refers to the process of generating deployable artifacts, such as
    `MSI`, `NuGet`, and `webdeploy` packages, and database packages; versioning them;
    and then storing them in a location such that they can be consumed by other pipelines
    and processes.
  prefs: []
  type: TYPE_NORMAL
- en: Once the process of continuous integration completes, the process of continuous
    deployment starts, and that will be the focus of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous deployment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By the time the process reaches continuous deployment, continuous integration
    has ensured that we have fully working bits of an application that can now be
    taken through different continuous deployment activities. Continuous deployment
    refers to the capability of deploying business applications and services to preproduction
    and production environments through automation. For example, continuous deployment
    could provision and configure the preproduction environment, deploy applications
    to it, and configure the applications. After conducting multiple validations,
    such as functional tests and performance tests on the preproduction environment,
    the production environment is provisioned, configured, and the application is
    deployed through automation. There are no manual steps in the deployment process.
    Every deployment task is automated. Continuous deployment can provision the environment
    and deploy the application from scratch, while it can just deploy delta changes
    to an existing environment if the environment already exists.
  prefs: []
  type: TYPE_NORMAL
- en: All environments are provisioned through automation using IaC. This ensures
    that all environments, whether development, test, preproduction, or production,
    are the same. Similarly, the application is deployed through automation, ensuring
    that it's also deployed uniformly across all environments. The configuration across
    these environments could be different for the application.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous deployment is generally integrated with continuous integration. When
    continuous integration has done its work, by generating the final deployable packages,
    continuous deployment kicks in and starts its own pipeline. This pipeline is called
    the release pipeline. The release pipeline consists of multiple environments,
    with each environment consisting of tasks responsible for provisioning the environment,
    configuring the environment, deploying applications, configuring applications,
    executing operational validation on environments, and testing the application
    on multiple environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Employing continuous deployment provides immense benefits. There is a high
    level of confidence in the overall deployment process, which helps with faster
    and risk-free releases on production. The chances of anything going wrong decrease
    drastically. The team will be less stressed, and rollback to the previous working
    environment is possible if there are issues with the current release:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A standard Continuous Deployment pipeline](img/B15432_13_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.3: Continuous deployment pipeline'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Although every system demands its own configuration of the release pipeline,
    an example of continuous deployment is shown in the preceding diagram. It's important
    to note that, generally, provisioning and configuring multiple environments is
    part of the release pipeline, and approvals should be sought before moving to
    the next environment. The approval process might be manual or automated, depending
    on the maturity of the organization.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look into aspects related to the test environment.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test environment deployment**'
  prefs: []
  type: TYPE_NORMAL
- en: The release pipeline starts once the drop is available from continuous integration
    and the first step it should take is to get all the artifacts from the drop. After
    this, the release pipeline might create a completely new bare-metal test environment
    or reuse an existing one. This is again dependent on the type of project and the
    nature of the testing planned to be executed in this environment. The environment
    is provisioned and configured. The application artifacts are deployed and configured.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test automation**'
  prefs: []
  type: TYPE_NORMAL
- en: After deploying an application, a series of tests can be performed on the environment.
    One of the tests executed here is a functional test. Functional tests are primarily
    aimed at validating the feature completeness and functionality of the application.
    These tests are written from requirements gathered from the customer. Another
    set of tests that can be executed is related to the scalability and availability
    of the application. This typically includes load tests, stress tests, and performance
    tests. It should also include an operational validation of the infrastructure
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: '**Staging environment deployment**'
  prefs: []
  type: TYPE_NORMAL
- en: This is very similar to the test environment deployment, the only difference
    being that the configuration values for the environment and application would
    be different.
  prefs: []
  type: TYPE_NORMAL
- en: '**Acceptance tests**'
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance tests are generally conducted by application stakeholders, and these
    can be manual or automated. This step is a validation from the customer's point
    of view about the correctness and completeness of the application's functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '**Deployment to production**'
  prefs: []
  type: TYPE_NORMAL
- en: Once the customer gives their approval, the same steps as that of the test and
    staging environment deployment are executed, the only difference being that the
    configuration values for the environment and application are specific to the production
    environment. A validation is conducted after deployment to ensure that the application
    is running according to expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery is an important DevOps principle and closely resembles continuous
    deployment; however, there are a few differences. In the next section, we will
    look into continuous delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Continuous delivery and continuous deployment might sound similar to you; however,
    they aren't the same. While continuous deployment talks about deployment to multiple
    environments and finally to the production environment through automation, continuous
    delivery is the ability to generate application packages that are readily deployable
    in any environment. To generate artifacts that are readily deployable, continuous
    integration should be used to generate the application artifacts; a new or existing
    environment should be used to deploy these artifacts and conduct functional tests,
    performance tests, and user-acceptance tests through automation. Once these activities
    are successfully executed without any errors, the application package is considered
    readily deployable. Continuous delivery includes continuous integration and deployment
    to an environment for final validations. It helps get feedback more quickly from
    both the operations and the end user. This feedback can then be used to implement
    subsequent iterations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look into continuous learning.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous learning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With all the previously mentioned DevOps practices, it's possible to create
    great business applications and deploy them automatically to the production environment;
    however, the benefits of DevOps won't last for long if continuous improvement
    and feedback principles are not in place. It's of the utmost importance that real-time
    feedback about the application behavior is passed on as feedback to the development
    team from both end users and the operations team.
  prefs: []
  type: TYPE_NORMAL
- en: Feedback should be passed to the teams, providing relevant information about
    what's going well and what isn't.
  prefs: []
  type: TYPE_NORMAL
- en: An application's architecture and design should be built with monitoring, auditing,
    and telemetry in mind. The operations team should collect telemetry information
    from the production environment, capturing any bugs and issues, and pass it on
    to the development team so that it can be fixed for subsequent releases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuous learning helps to make the application robust and resilient to failure.
    It helps in making sure that the application is meeting consumer requirements.
    *Figure 13.4* shows the feedback loop that should be implemented between different
    teams:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Monitoring and feedback practices in DevOps](img/B15432_13_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.4: Feedback loop'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: After going through the important practices related to DevOps, now it's time
    to get into tools and services that make these possible.
  prefs: []
  type: TYPE_NORMAL
- en: Azure DevOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at another top-of-the-line online service that enables continuous
    integration, continuous deployment, and continuous delivery seamlessly: Azure
    DevOps. In fact, it would be more appropriate to call it a suite of services available
    under a single name. Azure DevOps is a PaaS provided by Microsoft and hosted on
    the cloud. The same service is available as **Team Foundation Services** (**TFS**)
    on-premises. All examples shown in this book use Azure DevOps.'
  prefs: []
  type: TYPE_NORMAL
- en: According to Microsoft, Azure DevOps is a cloud-based collaboration platform
    that helps teams to share code, track work, and ship software. Azure DevOps is
    a new name; earlier, it was known as **Visual Studio Team Services** (**VSTS**). Azure
    DevOps is an enterprise software-development tool and service that enables organizations
    to provide automation facilities to their end-to-end application life cycle management
    process, from planning to deploying applications, and getting real-time feedback
    from software systems. This increases the maturity and capability of an organization
    to deliver high-quality software systems to their customers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Successful software delivery involves efficiently bringing numerous processes
    and activities together. These include executing and implementing various Agile
    processes, increasing collaboration among teams, the seamless and automatic transition
    of artifacts from one phase of the ALM to another phase, and deployments to multiple
    environments. It''s important to track and report on these activities to measure
    and improve delivery processes. Azure DevOps makes this simple and easy. It provides
    a whole suite of services that enables the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Collaboration among every team member by providing a single interface for the
    entire application life cycle management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaboration among development teams using source-code-management services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaboration among test teams using test-management services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic validation of code and packaging through continuous integration using
    build-management services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic validation of application functionality, deployment, and configuration
    of multiple environments through continuous deployment and delivery using release-management
    services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking and work-item management using work-management services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table shows all the services available to a typical project from
    the **Azure DevOps** left navigation bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A list of Azure DevOps services](img/Table_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 13.1: A list of Azure DevOps services'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'An organization in Azure DevOps serves as a security boundary and logical container
    that provides all the services that are needed to implement a DevOps strategy.
    Azure DevOps allows the creation of multiple projects within a single organization.
    By default, a repository is created with the creation of a project; however, Azure
    DevOps allows the creation of additional repositories within a single project.
    The relationship between an **Azure DevOps Organization**, **Projects**, and a **Repository** is
    shown in *Figure 13.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Projects and repositories in a DevOps implementation](img/B15432_13_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.5: Relationship between Azure DevOps Organization, Projects, and
    Repository'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Azure DevOps provides two types of repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Team Foundation Version Control (TFVC)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also provides the flexibility to choose between the Git or TFVC source-control
    repository. There can be a combination of TFS and TFVC repositories available
    within a single project.
  prefs: []
  type: TYPE_NORMAL
- en: TFVC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TFVC is the traditional and centralized way of implementing version control,
    where there's a central repository and developers work on it directly in connected
    mode to check in their changes. If the central repository is offline or unavailable,
    developers can't check in their code and have to wait for it to be online and
    available. Other developers can see only the checked-in code. Developers can group
    multiple changes into a single changeset for checking in code changes that are
    logically grouped to form a single change. TFVC locks the code files that are
    undergoing edits. Other developers can read a locked file, but they can't edit
    it. They must wait for the prior edit to complete and release the lock before
    they can edit. The history of check-ins and changes is maintained on the central
    repository, while the developers have the working copy of the files but not the
    history.
  prefs: []
  type: TYPE_NORMAL
- en: TFVC works very well with large teams that are working on the same projects.
    This enables control over the source code at a central location. It also works
    best for long-duration projects since the history can be managed at a central
    location. TFVC has no issues working with large and binary files.
  prefs: []
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Git, on the other hand, is a modern, distributed way of implementing version
    control, where developers can work on their own local copies of code and history in
    offline mode. Developers can work offline on their local clone of code. Each developer
    has a local copy of code and its entire history, and they work on their changes
    with this local repository. They can commit their code to the local repository.
    They can connect to the central repository for the synchronization of their local
    repository on a per-need basis. This allows every developer to work on any file
    since they would be working on their local copy. Branching in Git doesn't create
    another copy of the original code and is extremely fast to create.
  prefs: []
  type: TYPE_NORMAL
- en: Git works well with both small and large teams. Branching and merging is a breeze
    with the advanced options that Git has.
  prefs: []
  type: TYPE_NORMAL
- en: Git is the recommended way of using source control because of the rich functionality
    it provides. We'll use Git as the repository for our sample application in this
    book. In the next section, we will have a detailed overview of implementing automation
    through DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for DevOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Going forward, our focus will be on process and deployment automation using
    different patterns in Azure. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: DevOps for IaaS solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevOps for PaaS solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevOps for container-based solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, there are shared services that aren't unique to any one application.
    These services are consumed by multiple applications from different environments,
    such as development, testing, and production. The life cycle of these shared services
    is different for each application. Therefore, they have different version-control
    repositories, a different code base, and build and release management. They have
    their own cycle of plan, design, build, test, and release.
  prefs: []
  type: TYPE_NORMAL
- en: The resources that are part of this group are provisioned using ARM templates,
    PowerShell, and DSC configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The overall flow for building these common components is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flow for building common components in a DevOps project](img/B15432_13_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.6: Overall flow for building common components'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The release process is shown in *Figure 13.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A standard DevOps release process](img/B15432_13_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.7: Release process'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: On the DevOps journey, it's important to understand and provision the common
    components and services before starting any software engagement, product, or service.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in getting started with Azure DevOps is to provision an organization.
  prefs: []
  type: TYPE_NORMAL
- en: Azure DevOps organizations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A version-control system is needed to collaborate at the code level. Azure DevOps
    provides both centralized and decentralized versions of control systems. Azure
    DevOps also provides orchestration services for building and executing build and
    release pipelines. It's a mature platform that organizes all DevOps-related version
    control and builds and releases work-item-related artifacts. After an organization
    is provisioned in Azure DevOps, an Azure DevOps project should be created to hold
    all project-related artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: An Azure DevOps organization can be provisioned by visiting [https://dev.azure.com](https://dev.azure.com).
  prefs: []
  type: TYPE_NORMAL
- en: An Azure DevOps organization is the top-level administrative and management
    boundary that provides security, access, and collaboration between team members
    belonging to an organization. There can be multiple projects within an organization
    and each project comprises multiple teams.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning Azure Key Vault
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It isn't advisable to store secrets, certificates, credentials, or other sensitive
    information in code configuration files, databases, or any other general storage
    system. It's advised to store this important data in a vault that's specifically
    designed for storing secrets and credentials. Azure Key Vault provides such a
    service. Azure Key Vault is available as a resource and service from Azure. Now,
    let's move on to exploring the storage options for configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning a configuration-management server/service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A configuration-management server/service that provides storage for configurations
    and applies those configurations to different environments is always a good strategy
    for automating deployments. DSC on custom virtual machines and DSC from Azure
    Automation, Chef, Puppet, and Ansible are some options and can be used on Azure
    seamlessly for both Windows as well as Linux environments. This book uses DSC
    as a configuration-management tool for all purposes, and it provides a pull server
    that holds all configuration documents (MOF files) for the sample application.
    It also maintains the database of all virtual machines and containers that are
    configured and registered with the pull server to pull configuration documents
    from it. The local configuration manager on these targets virtual machines, and
    containers periodically check the availability of new configurations as well as
    drifts in the current configuration and report back to the pull server. It also
    has built-in reporting capabilities that provide information about nodes that
    are compliant, as well as those that are non-compliant, within a virtual machine.
    A pull server is a general web application that hosts the DSC pull server endpoint.
    In the next topic, we will discuss a technique to monitor processes in real time
    with Log Analytics.
  prefs: []
  type: TYPE_NORMAL
- en: Log Analytics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Log Analytics is an audit and monitoring service provided by Azure to get real-time
    information about all changes, drifts, and events occurring within virtual machines
    and containers. It provides a centralized workspace and dashboard for IT administrators
    for viewing, searching, and conducting drill-down searches on all changes, drifts,
    and events that occur on these virtual machines. It also provides agents that
    are deployed on target virtual machines and containers. Once deployed, these agents
    start sending all changes, events, and drifts to the centralized workspace. Let's
    check out the storage options for deploying multiple applications.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Storage accounts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Azure Storage is a service provided by Azure to store files as blobs. All scripts
    and code for automating the provisioning, deployment, and configuration of the
    infrastructure and sample application are stored in the Azure DevOps Git repository
    and are packaged and deployed in an Azure Storage account. Azure provides PowerShell
    script-extension resources that can automatically download DSC and PowerShell
    scripts and execute them on virtual machines during the execution of ARM templates.
    This storage acts as common storage across all deployments for multiple applications.
    Storing scripts and templates in a Storage account ensures that they can be used
    across projects irrespective of projects in Azure DevOps. Let's move on to exploring
    the importance of images in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Docker and OS images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both virtual machine and container images should be built as part of the common
    services build-and-release pipeline. Tools such as Packer and Docker Build can
    be used to generate these images.
  prefs: []
  type: TYPE_NORMAL
- en: Management tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All management tools, such as Kubernetes, DC/OS, Docker Swarm, and ITIL tools,
    should be provisioned before building and deploying the solution.
  prefs: []
  type: TYPE_NORMAL
- en: We'll conclude this section on DevOps preparation with management tools. There
    are multiple choices for each activity within a DevOps ecosystem and we should
    enable them as part of the DevOps journey—it should not be an afterthought, but
    rather part of DevOps planning.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps for PaaS solutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The typical architecture for Azure PaaS app services is based on *Figure 13.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A typical Azure PaaS App Service architecture](img/B15432_13_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.8: A typical Azure PaaS app service architecture'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The architecture shows some of the important components—such as Azure SQL,
    Storage accounts, and the version control system—that participate in the Azure
    App Service-based cloud solution architecture. These artifacts should be created
    using ARM templates. These ARM templates should be part of the overall configuration
    management strategy. It can have its own build and release management pipelines,
    similar to the one shown in *Figure 13.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Choosing deployment options for the sample app service](img/B15432_13_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.9: Choosing deployment options for the app service'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that we have explored the various deployment source options, let's go ahead
    and dive into understanding how to deploy cloud solutions on Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Azure App Service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Azure App Service provides managed hosting services for cloud solutions. It's
    a fully-managed platform that provisions and deploys cloud solutions. Azure App
    Service takes away the burden of creating and managing infrastructure and provides
    minimum **service-level agreements** (**SLAs**) for hosting your cloud solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment slots
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Azure App Service provides deployment slots that make deployment to them seamless
    and easy. There are multiple slots, and swapping between slots is done at a DNS
    level. It means anything in the production slot can be swapped with a staging
    slot by just swapping the DNS entries. This helps in deploying the custom cloud
    solution to staging and, after all checks and tests, they can be swapped to production
    if found satisfactory. However, in the event of any issue in production after
    swapping, the previous good values from the production environment can be reinstated
    by swapping again. Let's move on to understanding Azure's database offering and
    some of its key features.
  prefs: []
  type: TYPE_NORMAL
- en: Azure SQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Azure SQL is a SQL PaaS service provided by Azure to host databases. Azure provides a
    secure platform to host databases and takes complete ownership to manage the availability,
    reliability, and scalability of the service. With Azure SQL, there's no need to
    provision custom virtual machines, deploy a SQL server, and configure it. Instead,
    the Azure team does this behind the scenes and manages it on your behalf. It also
    provides a firewall service that enables security; only an IP address allowed
    by the firewall can connect the server and access the database. The virtual machines
    provisioned to host web applications have distinct public IP addresses assigned
    to them and they're added to Azure SQL firewall rules dynamically. Azure SQL Server
    and its database is created upon executing the ARM template. Next, we will cover
    build and release pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: The build and release pipelines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, a new build pipeline is created that compiles and validates
    an ASP.NET MVC application, and then generates packages for deployment. After
    package generation, a release definition ensures that deployment to the first
    environment happens in an App Service and Azure SQL as part of continuous deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to author build and release pipelines:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the classic editor
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using YAML files
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: YAML files provide more flexibility for authoring build and release pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The project structure of the sample application is shown in *Figure 13.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project structure of a sample application](img/B15432_13_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.10: Project structure of a sample application'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In this project, there''s an ASP.NET MVC application—the main application—and
    it consists of application pages. Web Deploy packages will be generated out of
    this project from build pipelines and they will eventually be on Web Apps. There
    are other projects that are also part of the solution, as mentioned next:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit test project**: Code for unit-testing the ASP.NET MVC application. Assemblies
    from this project will be generated and executed in the build execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DacPac` files will be generated out of this project using the build definition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure resource group project**: ARM templates and parameter code to provision
    the entire Azure environment on which the ASP.NET MVC application and the SQL
    tables are created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The build pipeline is shown in *Figure 13.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Build pipeline of the ASP.NET MVC application](img/B15432_13_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.11: Build pipeline of the ASP.NET MVC application'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The configuration of each task is shown in *Table 13.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuration of the build pipeline tasks](img/13.2_29.jpg)![Configuration
    of the build pipeline tasks](img/13.2_30.jpg)![Configuration of the build pipeline
    tasks](img/13.2_31.jpg)![Configuration of the build pipeline tasks](img/13.2_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 13.2: Configuration of the build pipeline tasks'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The build pipeline is configured to execute automatically as part of continuous
    integration, as shown in *Figure 13.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling continuous integration in the build pipeline](img/B15432_13_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.12: Enabling continuous integration in the build pipeline'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The release definition consists of multiple environments, such as development,
    testing, **System Integration Testing** (**SIT**), **User Acceptance Testing**
    (**UAT**), preproduction, and production. The tasks are pretty similar in each
    environment, with the addition of tasks specific to that environment. For example,
    a test environment has additional tasks related to the UI, and functional and
    integration testing, compared to a development environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The release definition for such an application is shown in *Figure 13.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stages in the release definition of the ASP.NET-CI application](img/B15432_13_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.13: Release definition'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The release tasks for a single environment are shown in *Figure 13.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Release tasks for a single environment](img/B15432_13_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.14: Release tasks for a single environment'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The configuration for each of the tasks is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuration of the release pipeline tasks](img/13.3_34.jpg)![Configuration
    of the release pipeline tasks](img/13.3_35.jpg)![Configuration of the release
    pipeline tasks](img/13.3_36.jpg)![Configuration of the release pipeline tasks](img/13.3_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 13.3: Configuration of the release pipeline tasks'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this section, you saw ways to configure build and release pipelines in Azure
    DevOps. In the next section onward, the focus will be on different architectures,
    such as IaaS, containers, and different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps for IaaS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IaaS involves the management and administration of base infrastructure and applications
    together and there are multiple resources and components that need to be provisioned,
    configured, and deployed on multiple environments. It is important to understand
    the architecture before going ahead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The typical architecture for an IaaS virtual machine-based solution is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Architecture for an IaaS virtual machine-based solution](img/B15432_13_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.15: Architecture for an IaaS virtual machine-based solution'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Each of the components listed in the architecture is discussed from the next
    section onward.
  prefs: []
  type: TYPE_NORMAL
- en: Azure virtual machines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Azure virtual machines that host web applications, application servers, databases,
    and other services are provisioned using ARM templates. They're attached to a
    virtual network and have a private IP address from the same network. The public
    IP for virtual machines is optional since they're attached to a public load balancer.
    Operational Insights agents are installed on virtual machines to monitor the virtual
    machines. PowerShell scripts are also executed on these virtual machines, downloaded
    from a Storage account available in another resource group to open relevant firewall
    ports, download appropriate packages, and install local certificates to secure
    access through PowerShell. The web application is configured to run on the provided
    port on these virtual machines. The port number for the web application and all
    its configuration is pulled from the DSC pull server and dynamically assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Azure public load balancers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A public load balancer is attached to some of the virtual machines for sending
    requests to them in a round-robin fashion. This is generally needed for front-end
    web applications and APIs. A public IP address and DNS name can be assigned to
    a load balancer such that it can serve internet requests. It accepts HTTP web requests on
    a different port and routes them to the virtual machines. It also probes certain
    ports on HTTP protocols with some provided application paths. **Network Address
    Translation** (**NAT**) rules can also be applied such that they can be used to
    log into the virtual machines using remote desktops.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative resource to the Azure public Load Balancer is the Azure Application
    Gateway. Application gateways are layer-7 load balancers and provide features
    such as SSL termination, session affinity, and URL-based routing. Let's discuss
    the build pipeline in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The build pipeline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A typical build pipeline for an IaaS virtual machine-based solution is shown
    next. A release pipeline starts when a developer pushes their code to the repository.
    The build pipeline starts automatically as part of continuous integration. It
    compiles and builds the code, executes unit tests on it, checks code quality,
    and generates documentation from code comments. It deploys the new binaries into
    the development environment (note that the development environment is not newly
    created), changes configuration, executes integration tests, and generates build
    labels for easy identification. It then drops the generated artifacts into a location
    accessible by the release pipeline. If there are issues during the execution of
    any step in this pipeline, this is communicated to the developer as part of the
    build pipeline feedback so that they can rework and resubmit their changes. The
    build pipeline should fail or pass based on the severity of issues found, and
    that varies from organization to organization. A typical build pipeline is shown
    in *Figure 13.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A typical IaaS build pipeline](img/B15432_13_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.16: A typical IaaS build pipeline'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Similar to the build pipeline, let's learn about the implementation of a release
    pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: The release pipeline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A typical release pipeline for an IaaS virtual machine-based deployment is shown
    next. A release pipeline starts after the completion of the build pipeline. The
    first step in the release pipeline is to gather the artifacts generated by the
    build pipeline. They are generally deployable assemblies, binaries, and configuration
    documents. The release pipeline executes and creates or updates the first environment,
    which generally is a test environment. It uses ARM templates to provision all
    IaaS and PaaS services and resources on Azure and configures them as well. They
    also help in executing scripts and DSC configuration after virtual machines are
    created as post-creation steps. This helps to configure the environment within
    the virtual machine and the operating system. At this stage, application binaries
    from the build pipeline are deployed and configured. Different automated tests
    are performed to check the solution and, if found satisfactory, the pipeline moves
    the deployment to the next environment after obtaining the necessary approvals.
    The same steps are executed in the next environment, including the production
    environment. Finally, the operational validation tests are executed in production
    to ensure that the application is working as expected and there are no deviations.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, if there are any issues or bugs, they should be rectified and
    the entire cycle should be repeated; however, if this doesn''t happen within a
    stipulated time frame, the last-known snapshot should be restored in the production
    environment to minimize downtime. A typical release pipeline is shown in *Figure
    13.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A typical IaaS release pipeline](img/B15432_13_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.17: A typical IaaS release pipeline'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This section concludes the DevOps process for IaaS solutions and the next chapter
    will focus on containers on virtual machines. Please note that containers can
    also run on PaaS like App Service and Azure Functions.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps with containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a typical architecture, container runtimes are deployed on virtual machines
    and containers are run within them. The typical architecture for IaaS container-based
    solutions is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![IaaS container-based solution architecture](img/B15432_13_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.18: Architecture for IaaS container-based solutions'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: These containers are managed by container orchestrators such as Kubernetes.
    Monitoring services are provided by Log Analytics and all secrets and keys are
    stored in Azure Key Vault. There is also a pull server, which could be on a virtual
    machine or Azure Automation, providing configuration information to the virtual
    machines.
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Containers are a virtualization technology; however, they don't virtualize physical
    servers. Instead, containers are an operating system-level virtualization. This
    means that containers share the operating system kernel provided by their host
    among themselves and with the host. Running multiple containers on a host (physical
    or virtual) shares the host operating system kernel. There's a single operating
    system kernel provided by the host and used by all containers running on top of
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Containers are also completely isolated from their host and other containers,
    much like a virtual machine. Containers use operating system namespaces, control
    groups on Linux, to provide the perception of a new operating system environment,
    and use specific operating system virtualization techniques on Windows. Each container
    gets its own copy of the operating system resources.
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker provides management features to containers. It comprises two executables:'
  prefs: []
  type: TYPE_NORMAL
- en: The Docker daemon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Docker client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Docker daemon is the workhorse for managing containers. It's a management
    service that's responsible for managing all activities on the host related to
    containers. The Docker client interacts with the Docker daemon and is responsible
    for capturing inputs and sending them to the Docker daemon. The Docker daemon
    provides the runtime; libraries; graph drivers; the engines to create, manage,
    and monitor containers; and images on the host server. It can also create custom
    images that are used for building and shipping applications to multiple environments.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Dockerfile**'
  prefs: []
  type: TYPE_NORMAL
- en: The `Dockerfile` is the primary building block for creating container images.
    It's a simple text-based human-readable file without an extension and is even
    named `Dockerfile`. Although there's a mechanism to name it differently, generally
    it is named `Dockerfile`. The Dockerfile contains instructions to create a custom
    image using a base image. These instructions are executed sequentially from top
    to bottom by the Docker daemon. The instructions refer to the command and its
    parameters, such as `COPY`, `ADD`, `RUN`, and `ENTRYPOINT`. The Dockerfile enables
    IaC practices by converting the application deployment and configuration into
    instructions that can be versioned and stored in a source code repository. Let's
    check out the build steps in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: The build pipeline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There's no difference, from the build perspective, between the container and
    a virtual-machine-based solution. The build step remains the same. A typical release
    pipeline for an IaaS container-based deployment is shown next.
  prefs: []
  type: TYPE_NORMAL
- en: The release pipeline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The only difference between a typical release pipeline for an IaaS container-based
    deployment and the release pipeline is the container-image management and the
    creation of containers using Dockerfile and Docker Compose. Advanced container-management
    utilities, such as Docker Swarm, DC/OS, and Kubernetes, can also be deployed and
    configured as part of release management. However, note that these container management
    tools should be part of the shared services release pipeline, as discussed earlier.
    *Figure 13.19* shows a typical release pipeline for a container-based solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A typical container-based release pipeline](img/B15432_13_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.19: Container-based release pipeline'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The focus of the next section is integration with other toolsets, such as Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: Azure DevOps and Jenkins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Azure DevOps is an open platform orchestrator that integrates with other orchestrator
    tools seamlessly. It provides all the necessary infrastructure and features that
    integrate well with Jenkins, as well. Organizations with well-established CI/CD
    pipelines built on Jenkins can reuse them with the advanced but simple features
    of Azure DevOps to orchestrate them.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins can be used as a repository and can execute CI/CD pipelines in Azure
    DevOps, while it's also possible to have a repository in Azure DevOps and execute
    CI/CD pipelines in Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Jenkins configuration can be added in Azure DevOps as service hooks, and
    whenever any code change is committed to the Azure DevOps repository, it can trigger
    pipelines in Jenkins. *Figure 13.20* shows the configuration of Jenkins from the
    Azure DevOps service hook configuration section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jenkins configuration as service hooks in Azure DevOps](img/B15432_13_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.20: Configuration of Jenkins'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There are multiple triggers that execute the pipelines in Jenkins; one of them
    is **Code pushed**, as shown in *Figure 13.21*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Executing a Jenkins pipeline through a code-pushed trigger](img/B15432_13_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.21: Code pushed trigger executed'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It's also possible to deploy to Azure VM and execute Azure DevOps release pipelines,
    as explained here: [https://docs.microsoft.com/azure/virtual-machines/linux/tutorial-build-deploy-jenkins](https://docs.microsoft.com/azure/virtual-machines/linux/tutorial-build-deploy-jenkins).
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins should already be deployed before using it in any scenario. The deployment
    process on Linux can be found at [https://docs.microsoft.com/azure/virtual-machines/linux/tutorial-jenkins-github-docker-cicd](https://docs.microsoft.com/azure/virtual-machines/linux/tutorial-jenkins-github-docker-cicd).
  prefs: []
  type: TYPE_NORMAL
- en: The next section will be more focused on tools and services related to configuration
    management. Azure automation provides DSC-related services such as the pull server.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Automation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Azure Automation is Microsoft''s platform for all automation implementation
    with regard to cloud, on-premises, and hybrid deployments. Azure Automation is
    a mature automation platform that provides rich capabilities in terms of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining assets, such as variables, connections, credentials, certificates,
    and modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing runbooks using Python, PowerShell scripts, and PowerShell workflows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing UIs to create runbooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the full runbook life cycle, including building, testing, and publishing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling runbooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to run runbooks anywhere—on cloud or on-premises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DSC as a configuration-management platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing and configuring environments—Windows and Linux, applications, and deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to extend Azure Automation by importing custom modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Automation provides a DSC pull server that helps to create a centralized
    configuration management server that consists of configurations for nodes/virtual
    machines and their constituents.
  prefs: []
  type: TYPE_NORMAL
- en: It implements the hub and spoke pattern wherein nodes can connect to the DSC
    pull server and download configurations assigned to them, and reconfigure themselves
    to reflect their desired state. Any changes or deviations within these nodes are
    autocorrected by DSC agents the next time they run. This ensures that administrators
    don't need to actively monitor the environment to find any deviations.
  prefs: []
  type: TYPE_NORMAL
- en: DSC provides a declarative language in which you define the intent and configuration,
    but not how to run and apply those configurations. These configurations are based
    on the PowerShell language and ease the process of configuration management.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll look into a simple implementation of using Azure Automation
    DSC to configure a virtual machine to install and configure the web server (IIS)
    and create an `index.htm` file that informs users that the website is under maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will learn how to provision an Azure Automation account.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning an Azure Automation account
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a new Azure Automation account from the Azure portal or PowerShell within
    an existing or new resource group. You may notice in *Figure 13.22* that Azure
    Automation provides menu items for DSC:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The state configuration menu in Azure Automation](img/B15432_13_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.22: DSC in an Azure Automation account'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'It provides the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DSC nodes**: These list all the virtual machines and containers that are
    enlisted with the current Azure Automation DSC pull server. These virtual machines
    and containers are managed using configurations from the current DSC pull server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DSC configurations**: These list all the raw PowerShell configurations imported
    and uploaded to the DSC pull server. They are in human-readable format and aren''t
    in a compiled state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DSC node configurations**: These list all compiles of DSC configurations
    available on the pull server to be assigned to nodes—virtual machines and containers.
    A DSC configuration produces MOF files after compilations and they''re eventually
    used to configure nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After provisioning an Azure Automation account, we can create a sample DSC configuration,
    as shown in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a DSC configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step is to write a DSC configuration using any PowerShell editor to
    reflect the intent of the configuration. For this sample, a single configuration, `ConfigureSiteOnIIS`,
    is created. It imports the base DSC module, `PSDesiredStateConfiguration`, which
    consists of resources used within the configuration. It also declares a node web
    server. When this configuration is uploaded and compiled, it will generate a DSC
    configuration named `ConfigureSiteOnIISwebserver`. This configuration can then be
    applied to nodes.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration consists of a few resources. These resources configure the
    target node. The resources install a web server, ASP.NET, and framework, and create
    an `index.htm` file within the `inetpub\wwwroot` directory with content to show
    that the site is under maintenance. For more information about writing DSC configuration,
    refer to [https://docs.microsoft.com/powershell/scripting/dsc/getting-started/wingettingstarted?view=powershell-7](https://docs.microsoft.com/powershell/scripting/dsc/getting-started/wingettingstarted?view=powershell-7).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next code listing shows the entire configuration described in the previous
    paragraph. This configuration will be uploaded to the Azure Automation account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After creating a sample DSC configuration, it should be imported within Azure
    Automation as shown in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the DSC configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The DSC configuration still isn''t known to Azure Automation. It''s available
    on some local machines. It should be uploaded to Azure Automation DSC configurations.
    Azure Automation provides the `Import-AzureRMAutomationDscConfiguration` cmdlet
    to import the configuration to Azure Automation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The commands will import the configuration within Azure Automation. After importing,
    the DSC configuration should be compiled so that it can be assigned to servers
    for compliance checks and autoremediation.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling the DSC configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After the DSC configuration is available in Azure Automation, it can be asked
    to compile. Azure Automation provides another cmdlet for this. Use the `Start-AzureRmAutomationDscCompilationJob` cmdlet
    to compile the imported configuration. The configuration name should match the
    name of the uploaded configuration. Compilation creates an MOF file named after
    the configuration and node name together, which in this case is the `ConfigureSiteOnIIS` web
    server. The execution of the command is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now you have accomplished DSC node configuration. In the next section, you will
    learn to assign configurations to nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning configurations to nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The compiled DSC configurations can be applied to nodes. Use `Register-AzureRmAutomationDscNode` to
    assign the configuration to a node. The `NodeConfigurationName` parameter identifies
    the configuration name that should be applied to the node. This is a powerful
    cmdlet that can also configure the DSC agent, which is `localconfigurationmanager`,
    on nodes before they can download configurations and apply them. There are multiple `localconfigurationmanager` parameters
    that can be configured—details are available at [https://devblogs.microsoft.com/powershell/understanding-meta-configuration-in-windows-powershell-desired-state-configuration](https://devblogs.microsoft.com/powershell/understanding-meta-configuration-in-windows-powershell-desired-state-configuration).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s heck out the configuration below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can test whether the configuration has been applied to the servers by
    browsing the newly deployed website using a browser. After the testing has completed
    successfully, let's move on to validating the connections.
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If appropriate, network security groups and firewalls are opened and enabled
    for port 80, and a public IP is assigned to the virtual machine. The default website
    can be browsed using the IP address. Otherwise, log into the virtual machine that's
    used to apply the DSC configuration and navigate to `http://localhost`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should show the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating the connection through Localhost](img/B15432_13_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.23: Localhost'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This is the power of configuration management: without writing any significant
    code, authoring a configuration once can be applied multiple times to the same
    and multiple servers, and you can be assured that they will run in the desired
    state without any manual intervention. In the next section, we will check out
    the various tools available for Azure DevOps.'
  prefs: []
  type: TYPE_NORMAL
- en: Tools for DevOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned before, Azure is a rich and mature platform that supports the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple choices of languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple choices of operating systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple choices of tools and utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple patterns for deploying solutions (such as virtual machines, app services,
    containers, and microservices)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With so many options and choices, Azure offers the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Open cloud**: It is open to open source, Microsoft, and non-Microsoft products,
    tools, and services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexible cloud**: It is easy enough for both end users and developers to
    use it with their existing skills and knowledge.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unified management**: It provides seamless monitoring and management features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All the services and capabilities mentioned here are important for the successful
    implementation of DevOps. *Figure 13.24* shows the open source tools and utilities
    that can be used for different phases of managing the application life cycle and
    DevOps in general:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Open source tools and utilities for managing the application lifecycle](img/B15432_13_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.24: Open source tools and utilities'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '*Figure 13.24* shows the Microsoft tools and utilities that can be used for
    different phases of managing the application life cycle and DevOps in general.
    Again, this is just a small representation of all the tools and utilities—there
    are many more options available, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Azure DevOps build orchestration for constructing a build pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Test Manager and Pester for testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DSC, PowerShell, and ARM templates for deployment or configuration management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log Analytics, Application Insights, and **System Center Operations Manager** (**SCOM**)
    for alerting and monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure DevOps and System Center Service Manager for managing processes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Microsoft tools and utilities for managing the application lifecycle](img/B15432_13_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.25: Microsoft tools and utilities'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are many tools available for each of the DevOps practices and in this
    section, you saw some of the tools and the way to configure them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DevOps is gaining a lot of traction and momentum in the industry. Most organizations
    have realized its benefits and are looking to implement DevOps. This is happening
    while most of them are moving to the cloud. Azure, as a cloud platform, provides
    rich and mature DevOps services, making it easy for organizations to implement
    DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we discussed DevOps along with its core practices, such as
    configuration management, continuous integration, continuous delivery, and deployment.
    We also discussed different cloud solutions based on PaaS, a virtual machine IaaS,
    and a container IaaS, along with their respective Azure resources, the build and
    release pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration management was also explained in the chapter, along with DSC services
    from Azure Automation and using pull servers to configure virtual machines automatically.
    Finally, we covered Azure's openness and flexibility regarding the choice of languages,
    tools, and operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go through the details of Kubernetes and its components
    and interactions, in addition to application design and deployment considerations
    on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
