<html><head></head><body>
		<div>
			<div id="_idContainer402" class="Content">
			</div>
		</div>
		<div id="_idContainer403" class="Content">
			<h1 id="_idParaDest-380">16. <a id="_idTextAnchor396"/>ARM template modular design and implementation</h1>
		</div>
		<div id="_idContainer408" class="Content">
			<p>We know that there are multiple ways to author an <strong class="bold">Azure Resource Manager</strong> (<strong class="bold">ARM</strong>) template. It is quite easy to author one that provisions all of the necessary resources in Azure using Visual Studio and Visual Studio Code. A single ARM template can consist of all the required resources for a solution on Azure. This single ARM template could be as small as a few resources, or it could be a larger one consisting of many resources.</p>
			<p>While authoring a single template consisting of all resources is quite tempting, it is advisable to plan an ARM template implementation divided into multiple smaller ARM templates beforehand, so that future troubles related to them can be avoided.</p>
			<p>In this chapter, we will look at how to write ARM templates in a modular way so that they can evolve over a period of time with minimal involvement in terms of changes and effort in testing and deployment.</p>
			<p>However, before writing modular templates, it is best to understand the problems solved by writing them in a modular fashion.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Problems with a single template</li>
				<li>Understanding nested and linked deployment</li>
				<li>Linked templates</li>
				<li>Nested templates</li>
				<li>Free-flow configurations</li>
				<li>Known configurations</li>
			</ul>
			<p>Now, let's explore the aforementioned topics in detail, which will help you to write modular templates using industry best practices.</p>
			<h2 id="_idParaDest-381"><a id="_idTextAnchor397"/>Problems with the single template approach</h2>
			<p>On the surface, it might not sound like a single large template consisting of all resources will have problems, but there are issues that could arise in the future. Let's discuss the issues that might arise when using single large templates.</p>
			<h3 id="_idParaDest-382"><a id="_idTextAnchor398"/>Reduced flexibility in changing templates</h3>
			<p>Using a single large template with all resources makes it difficult to change it in the future. With all dependencies, parameters, and variables in a single template, changing the template can take a considerable amount of time compared to smaller templates. The change could have an impact on other sections of the template, which might go unnoticed, as well as introducing bugs.</p>
			<h3 id="_idParaDest-383"><a id="_idTextAnchor399"/>Troubleshooting large templates</h3>
			<p>Large templates are difficult to troubleshoot. This is a known fact. The larger the number of resources in a template, the more difficult it is to troubleshoot the template. A template deploys all the resources in it, and finding a bug involves deploying the template quite often. Developers would have reduced productivity while waiting for the completion of template deployment.</p>
			<p>Also, deploying a single template is more time-consuming than deploying smaller templates. Developers have to wait for resources containing errors to be deployed before taking any action.</p>
			<h3 id="_idParaDest-384"><a id="_idTextAnchor400"/>Dependency abuse</h3>
			<p>The dependencies between resources also tend to become more complex in larger templates. It is quite easy to abuse the usage of the <strong class="inline">dependsOn</strong> feature in ARM templates because of the way they work. Every resource in a template can refer to all its prior resources rather than building a tree of dependencies. ARM templates do not complain if a single resource is dependent on all other resources in the ARM template, even though those other resources might have inter-dependencies within themselves. This makes changing ARM templates bug prone and, at times, it is not even possible to change them.</p>
			<h3 id="_idParaDest-385"><a id="_idTextAnchor401"/>Reduced agility</h3>
			<p>Generally, there are multiple teams in a project, with each owning their own resources in Azure. These teams will find it difficult to work with a single ARM template because a single developer should be updating them. Updating a single template with multiple teams might induce conflict and difficult-to-solve merges. Having multiple smaller templates can enable each team to author their own piece of an ARM template.</p>
			<h3 id="_idParaDest-386"><a id="_idTextAnchor402"/>No reusability</h3>
			<p>If you have a single template, then that's all that you have, and using this template means deploying all resources. There is no possibility, out of the box, to select individual resources without some maneuvering, such as adding conditional resources. A single large template loses reusability because you take all the resources or none of them.</p>
			<p>Knowing that single large templates have so many issues, it is good practice to author modular templates so that we get benefits such as the following:</p>
			<ul>
				<li>Multiple teams can work on their templates in isolation.</li>
				<li>Templates can be reused across projects and solutions.</li>
				<li>Templates are easy to debug and troubleshoot.</li>
			</ul>
			<p>Now that we have covered some of the issues with single large templates, in the next section, we will consider the crux of modular templates and how they may help developers to implement efficient deployments.</p>
			<h2 id="_idParaDest-387"><a id="_idTextAnchor403"/>Understanding the Single Responsibility Principle</h2>
			<p>The <strong class="bold">Single Responsibility Principle</strong> is one of the core principles of the SOLID design principles. It states that a class or code segment should be responsible for a single function and that it should own that functionality completely. The code should change or evolve only if there is a functional change or bug in the current functionality and not otherwise. This code should not change because of changes in some other component or code that is not part of the current component.</p>
			<p>Applying the same principle to ARM templates helps us to create templates that have the sole responsibility of deploying a single resource or functionality instead of deploying all resources and a complete solution.</p>
			<p>Using this principle will help you create multiple templates, each responsible for a single resource or a smaller group of resources rather than all resources.</p>
			<h3 id="_idParaDest-388"><a id="_idTextAnchor404"/>Faster troubleshooting and debugging</h3>
			<p>Each template deployment is a distinct activity within Azure and is a separate instance consisting of inputs, outputs, and logs. When multiple templates are deployed for deploying a solution, each template deployment has separate log entries along with its input and output descriptions. It is much easier to isolate bugs and troubleshoot issues using these independent logs from multiple deployments compared to a single large template.</p>
			<h3 id="_idParaDest-389"><a id="_idTextAnchor405"/>Modular templates</h3>
			<p>When a single large template is decomposed into multiple templates where each smaller template takes care of its own resources, and those resources are solely owned, maintained, and are the responsibility of the template containing it, we can say we have modular templates. Each template within these templates follows the Single Responsibility Principle.</p>
			<p>Before learning how to divide a large template into multiple smaller reusable templates, it is important to understand the technology behind creating smaller templates and how to compose them to deploy complete solutions.</p>
			<h3 id="_idParaDest-390"><a id="_idTextAnchor406"/>Deployment resources</h3>
			<p>ARM provides a facility to link templates. Although we have already gone through linked templates in detail, I will mention it here to help you understand how linking templates helps us achieve modularity, composition, and reusability.</p>
			<p>ARM templates provide specialized resources known as <strong class="bold">deployments</strong>, which are available from the <strong class="inline">Microsoft.Resources</strong> namespace. A deployment resource in an ARM template looks very similar to the code segment that follows:</p>
			<p class="snippet">"resources": [  {      "apiVersion": "2019-10-01",      "name": "linkedTemplate",      "type": "Microsoft.Resources/deployments",      "properties": {          "mode": "Incremental",          &lt;nested-template-or-external-template&gt;      }  }]</p>
			<p>This template is self-explanatory, and the two most important configurations in the template resource are the type and the properties. The type here refers to the deployment resource rather than any specific Azure resource (storage, virtual machine, and so on) and the properties specify the deployment configuration, including a linked template deployment or a nested template deployment.</p>
			<p>However, what does the deployment resource do? The job of a deployment resource is to deploy another template. Another template could be an external template in a separate ARM template file, or it could be a nested template. It means that it is possible to invoke other templates from a template, just like a function call.</p>
			<p>There can be nested levels of deployments in ARM templates. What this means is that a single template can call another template, and the called template can call another template, and this can go on for five levels of nested callings:</p>
			<div>
				<div id="_idContainer404" class="IMG---Figure">
					<img src="image/Figure_16.1.jpg" alt="A graphical representation illustrating the nested calling in ARM templates where the Master template calls an intermediate template, which in turn calls individual templates."/>
				</div>
			</div>
			<h6>Figure 16.1: Template decomposition into smaller templates</h6>
			<p>Now that we understand that large templates can be modular with separate resources in separate templates, we need to link and bring them together to deploy resources on Azure. Linked and nested templates are ways to compose multiple templates together.</p>
			<h2 id="_idParaDest-391"><a id="_idTextAnchor407"/>Linked templates</h2>
			<p>Linked templates are templates that invoke external templates. External templates are stored in different ARM template files. An example of linked templates follows:</p>
			<p class="snippet">"resources": [  {     "apiVersion": "2019-10-01",     "name": "linkedTemplate",     "type": "Microsoft.Resources/deployments",     "properties": {       "mode": "Incremental",       "templateLink": {         "uri":"https://mystorageaccount.blob.core.windows.net/AzureTemplates/newStorageAccount.json",          "contentVersion":"1.0.0.0"       },       "parametersLink": {         "uri":"https://mystorageaccount.blob.core.windows.net/AzureTemplates/newStorageAccount.parameters.json",          "contentVersion":"1.0.0.0"       }     }  }]</p>
			<p>Important additional properties in this template compared to the previous template are <strong class="inline">templateLink</strong> and <strong class="inline">parametersLink</strong>. Now, <strong class="inline">templateLink</strong> refers to the actual URL of the location of the external template file, and <strong class="inline">parametersLink</strong> is the URL location for the corresponding <strong class="inline">parameters</strong> file. It is important to note that the caller template should have access rights to the location of the called template. For example, if the external templates are stored in Azure Blob storage, which is protected by keys, then the appropriate <strong class="bold">Secure Access Signature</strong> (<strong class="bold">SAS</strong>) keys must be available to the caller template to be able to access the linked templates.</p>
			<p>It is also possible to provide explicit inline parameters instead of the <strong class="inline">parametersLink</strong> value, as shown here:</p>
			<p class="snippet">"resources": [  {     "apiVersion": "2019-10-01",     "name": "linkedTemplate",     "type": "Microsoft.Resources/deployments",     "properties": {       "mode": "Incremental",       "templateLink": {         "uri":"https://mystorageaccount.blob.core.windows.net/AzureTemplates/newStorageAccount.json",          "contentVersion":"1.0.0.0"       },       "parameters": {          "StorageAccountName":{"value": "                              [parameters('StorageAccountName')]"}        }     }  }]</p>
			<p>You now have a good understanding of linked templates. A closely related topic is nested templates, which the next section will discuss in detail.</p>
			<h2 id="_idParaDest-392"><a id="_idTextAnchor408"/>Nested templates</h2>
			<p>Nested templates are a relatively new feature in ARM templates compared to external linked templates.</p>
			<p>Nested templates do not define resources in external files. The resources are defined within the caller template itself and within the deployment resource, as shown here:</p>
			<p class="snippet">"resources": [  {    "apiVersion": "2019-10-01",    "name": "nestedTemplate",    "type": "Microsoft.Resources/deployments",    "properties": {      "mode": "Incremental",      "template": {        "$schema": "https://schema.management.azure.com/schemas/2015-              01-01/deploymentTemplate.json#",        "contentVersion": "1.0.0.0",        "resources": [          {            "type": "Microsoft.Storage/storageAccounts",            "name": "[variables('storageName')]",            "apiVersion": "2019-04-01",            "location": "West US",            "properties": {              "accountType": "Standard_LRS"            }          }        ]      }    }  }]</p>
			<p>In this code segment, we can see that the storage account resource is nested within the original template as part of the deployments resource. Instead of using the <strong class="inline">templateLink</strong> and <strong class="inline">parametersLink</strong> attributes, a <strong class="inline">resources</strong> array is used to create multiple resources as part of a single deployment. The advantage of using a nested deployment is that resources within a parent can be used to reconfigure them by using their names. Usually, a resource with a name can exist only once within a template. Nested templates allow us to use them within the same template and ensure that all templates are self-sufficient rather than being stored separately, and they may or may not be accessible to those external files.</p>
			<p>Now that we understand the technology behind modular ARM templates, how should we divide a large template into smaller templates?</p>
			<p>There are multiple ways a large template can be decomposed into smaller templates. Microsoft recommends the following pattern for the decomposition of ARM templates:</p>
			<div>
				<div id="_idContainer405" class="IMG---Figure">
					<img src="image/Figure_16.2.jpg" alt="A flow diagram illustrating the decompositionofARMtemplates."/>
				</div>
			</div>
			<h6>Figure 16.2: Template decomposition strategy</h6>
			<p>When we decompose a large template into smaller templates, there is always the main template, which is used for deploying the solution. This main or master template internally invokes other nested or linked templates and they, in turn, invoke other templates, and finally, the templates containing Azure resources are deployed.</p>
			<p>The main template can invoke a known configuration resource template, which, in turn, will invoke templates comprising Azure resources. The known configuration resource template is specific to a project or solution and it does not have many reusable factors associated with it. The member resource templates are reusable templates invoked by the known configuration resource template.</p>
			<p>Optionally, the master template can invoke shared resource templates and other resource templates if they exist.</p>
			<p>It is important to understand known configurations. Templates can be authored as known configurations or as free-flow configurations.</p>
			<h2 id="_idParaDest-393"><a id="_idTextAnchor409"/>Free-flow configurations</h2>
			<p>ARM templates can be authored as generic templates where most, if not all, of the values assigned to variables are obtained as parameters. This allows the person using the template to pass any value they deem necessary to deploy resources in Azure. For example, the person deploying the template could choose a virtual machine of any size, any number of virtual machines, and any configuration for its storage and networks. This is known as free-flow configuration, where most of the configuration is allowed and the templates come from the user instead of being declared within the template.</p>
			<p>There are challenges with this kind of configuration. The biggest one is that not all configurations are supported in every Azure region and datacenter in Azure. The templates will fail to create resources if those resources are not allowed to be created in specific locations or regions. Another issue with free-flow configuration is that users can provide any value they deem necessary and a template will honor them, thereby increasing both the cost and deployment footprint even though they are not completely required.</p>
			<h2 id="_idParaDest-394"><a id="_idTextAnchor410"/>Known configurations</h2>
			<p>Known configurations, on the other hand, are specific pre-determined configurations for deploying an environment using ARM templates. These pre-determined configurations are known as <strong class="bold">T-shirt sizing configurations</strong>. Similar to the way a T-shirt is available in a pre-determined configuration such as small, medium, and large, ARM templates can be pre-configured to deploy a small, medium, or large environment depending on the requirements. This means that users cannot determine any random custom size for the environment, but they can choose from various provided options, and ARM templates executed during runtime will ensure that an appropriate configuration of the environment is provided.</p>
			<p>So, the first step in creating a modular ARM template is deciding on the known configurations for an environment.</p>
			<p>As an example, here is the configuration of a datacenter deployment on Azure:</p>
			<div>
				<div id="_idContainer406" class="IMG---Figure">
					<img src="image/Chapter_16_Table.jpg" alt="Configuration of a datacenter deployment on Azure"/>
				</div>
			</div>
			<h6>Table 16.1: Configuration of a datacenter deployment on Azure</h6>
			<p>Now that we know the configurations, we can create modular ARM templates.</p>
			<p>There are two ways to write modular ARM templates:</p>
			<ul>
				<li><strong class="bold">Composed templates</strong>: Composed templates link to other templates. Examples of composed templates are master and intermediate templates.</li>
				<li><strong class="bold">Leaf-level templates</strong>: Leaf-level templates are templates that contain a single Azure resource.</li>
			</ul>
			<p>ARM templates can be divided into modular templates based on the following:</p>
			<ul>
				<li>Technology</li>
				<li>Functionality</li>
			</ul>
			<p>An ideal way to decide on the modular method to author an ARM template is as follows:</p>
			<ul>
				<li>Define resource- or leaf-level templates consisting of single resources. In the upcoming diagram, the extreme right templates are leaf-level templates. Within the diagram, virtual machines, virtual network, storage, and others in the same column represent leaf-level templates.</li>
				<li>Compose environment-specific templates using leaf-level templates. These environment-specific templates provide an Azure environment, such as a SQL Server environment, an App Service environment, or a datacenter environment. Let's drill down a bit more into this topic. Let's take the example of an Azure SQL environment. To create an Azure SQL environment, multiple resources are needed. At a bare minimum, a logical SQL Server, a SQL database, and a few SQL firewall resources should be provisioned. All these resources are defined in individual templates at the leaf level. These resources can be composed together in a single template that has the capability to create an Azure SQL environment. Anybody wanting to create an SQL environment can use this composed template. <em class="italics">Figure 16.3</em> has <strong class="bold">Data center</strong>, <strong class="bold">Messaging</strong>, and <strong class="bold">App Service</strong> as environment-specific templates.</li>
				<li>Create templates with higher abstraction composing multiple environment-specific templates into solutions. These templates are composed of environment-specific templates that were created in the previous step. For example, to create an e-commerce inventory solution that needs an App Service environment and a SQL environment, two environment templates, App Service and SQL Server, can be composed together. <em class="italics">Figure 16.3</em> has <strong class="bold">Functional 1</strong> and <strong class="bold">Functional 2</strong> templates, which are composed of child templates.</li>
				<li>Finally, a master template should be created, which should be composed of multiple templates where each template is capable of deploying a solution. </li>
			</ul>
			<p>The preceding steps for creating a modular designed template can be easily understood by means of <em class="italics">Figure 16.3</em>:</p>
			<div>
				<div id="_idContainer407" class="IMG---Figure">
					<img src="image/Figure_16.3.jpg" alt="A diagram illustrating the creation of amodulardesignedtemplate with the help of template and resource mapping."/>
				</div>
			</div>
			<h6>Figure 16.3: Template and resource mapping</h6>
			<p>Now, let's implement a part of the functionality shown in the previous diagram. In this implementation, we will provide a virtual machine with a script extension using a modular approach. The custom script extension deploys Docker binaries and prepares a container environment on a Windows Server 2016 virtual machine.</p>
			<p>Now, we are going to create a solution using ARM templates using a modular approach. As mentioned before, the first step is to create individual resource templates. These individual resource templates will be used to compose additional templates capable of creating an environment. These templates will be needed to create a virtual machine. All ARM templates shown here are available in the accompanying chapter code. The names and code of these templates are as follows:</p>
			<ul>
				<li><strong class="inline">Storage.json</strong></li>
				<li><strong class="inline">virtualNetwork.json</strong></li>
				<li><strong class="inline">PublicIPAddress.json</strong></li>
				<li><strong class="inline">NIC.json</strong></li>
				<li><strong class="inline">VirtualMachine.json</strong></li>
				<li><strong class="inline">CustomScriptExtension.json</strong></li>
			</ul>
			<p>First, let's look at the code for the <strong class="inline">Storage.json</strong> template. This template provides a storage account, which every virtual machine needs for storing its OS and data disk files:</p>
			<p class="snippet"> {    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",    "contentVersion": "1.0.0.0",  "parameters": {    "storageAccountName": {      "type": "string",      "minLength": 1     },    "storageType": {      "type": "string",      "minLength": 1     },   ...  "outputs": {    "resourceDetails": {      "type": "object",      "value": "[reference(parameters('storageAccountName'))]"    }  }}</p>
			<p>Next, let's look at the code for the public IP address template. A virtual machine that should be accessible over the internet needs a public IP address resource assigned to its network interface card. Although exposing a virtual machine to the internet is optional, this resource might get used for creating a virtual machine. The following code is available in the <strong class="inline">PublicIPAddress.json</strong> file:</p>
			<p class="snippet">{    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",    "contentVersion": "1.0.0.0",  "parameters": {    "publicIPAddressName": {      "type": "string",      "minLength": 1     },    "publicIPAddressType": {      "type": "string",      "minLength": 1    ...      }    }  ],  "outputs": {    "resourceDetails": {      "type": "object",      "value": "[reference(parameters('publicIPAddressName'))]"    }  }}</p>
			<p>Next, let's look at the code for the virtual network. Virtual machines on Azure need a virtual network for communication. This template will be used to create a virtual network on Azure with a pre-defined address range and subnets. The following code is available in the <strong class="inline">virtualNetwork.json</strong> file:</p>
			<p class="snippet">{    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",    "contentVersion": "1.0.0.0",  "parameters": {    "virtualNetworkName": {      "type": "string",      "minLength": 1  ...    },    "subnetPrefix": {      "type": "string",      "minLength": 1     },    "resourceLocation": {      "type": "string",      "minLength": 1     } ...        "subnets": [          {            "name": "[parameters('subnetName')]",            "properties": {              "addressPrefix": "[parameters('subnetPrefix')]"            }          }        ]      }    }  ],  "outputs": {    "resourceDetails": {      "type": "object",      "value": "[reference(parameters('virtualNetworkName'))]"    }  }}</p>
			<p>Next, let's look at the code for the network interface card. A virtual network card is needed by a virtual machine to connect to a virtual network and to accept and send requests to and from the internet. The following code is available in the <strong class="inline">NIC.json</strong> file:</p>
			<p class="snippet">{    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",    "contentVersion": "1.0.0.0",  "parameters": {    "nicName": {      "type": "string",      "minLength": 1     },    "publicIpReference": {      "type": "string",      "minLength": 1  ...[resourceId(subscription().subscriptionId,resourceGroup().name, 'Microsoft.Network/publicIPAddresses', parameters('publicIpReference'))]",    "vnetRef": "[resourceId(subscription().subscriptionId,resourceGroup().name, 'Microsoft.Network/virtualNetworks', parameters('virtualNetworkReference'))]",    "subnet1Ref": "[concat(variables('vnetRef'),'/subnets/', parameters('subnetReference'))]"  }, ...                "id": "[variables('subnet1Ref')]"              }            }          }        ]      }    }  ],  "outputs": {    "resourceDetails": {      "type": "object",      "value": "[reference(parameters('nicName'))]"    }  }}</p>
			<p>Next, let's look at the code for creating a virtual machine. Each virtual machine is a resource in Azure, and note that this template has no reference to storage, network, public IP addresses, or other resources created earlier. This reference and composition will happen later in this section using another template. The following code is available in the <strong class="inline">VirtualMachine.json</strong> file:</p>
			<p class="snippet">{  "$schema": "https://schema.management.azure.com/schemas/2015-01 01/deploymentTemplate.json#",  "contentVersion": "1.0.0.0",  "parameters": {    "vmName": {      "type": "string",      "minLength": 1    ...    },    "imageOffer": {      "type": "string",      "minLength": 1     },    "windowsOSVersion": {      "type": "string",      "minLength": 1     },   ...  "outputs": {    "resourceDetails": {      "type": "object",      "value": "[reference(parameters('vmName'))]"    }  }</p>
			<p class="snippet">}</p>
			<p>Next, let's look at the code for creating a custom script extension. This resource executes a PowerShell script on a virtual machine after it is provisioned. This resource provides an opportunity to execute post-provisioning tasks in Azure Virtual Machines. The following code is available in the <strong class="inline">CustomScriptExtension.json</strong> file:</p>
			<p class="snippet">{    "$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",    "contentVersion": "1.0.0.0",    "parameters": {      "VMName": {        "type": "string",        "defaultValue": "sqldock",        "metadata": {...            "commandToExecute": "[concat('powershell -ExecutionPolicy Unrestricted -file docker.ps1')]"          },          "protectedSettings": {          }        }      }    ],    "outputs": {    }}</p>
			<p>Next, we'll look at the custom script extension PowerShell code that prepares the Docker environment. Please note that a virtual machine reboot might happen while executing the PowerShell script, depending on whether the Windows containers feature is already installed or not. The following script installs the NuGet package, the <strong class="inline">DockerMsftProvider</strong> provider, and the Docker executable. The <strong class="inline">docker.ps1</strong> file is available with the accompanying chapter code:</p>
			<p class="snippet">## docker.ps1 #Install-PackageProvider -Name Nuget -Force -ForceBootstrap -Confirm:$false Install-Module -Name DockerMsftProvider -Repository PSGallery -Force -Confirm:$false -verboseInstall-Package -Name docker -ProviderName DockerMsftProvider -Force -ForceBootstrap -Confirm:$false</p>
			<p>All the previously seen linked templates should be uploaded to a container within an Azure Blob storage account. This container can have a private access policy applied, as you saw in the previous chapter; however, for this example, we will set the access policy as <strong class="inline">container</strong>. This means these linked templates can be accessed without an SAS token. </p>
			<p>Finally, let's focus on writing the master template. Within the master template, all the linked templates are composed together to create a solution—to deploy a virtual machine and execute a script within it. The same approach can be used for creating other solutions, such as providing a datacenter consisting of multiple inter-connected virtual machines. The following code is available in the <strong class="inline">Master.json</strong> file:</p>
			<p class="snippet">{    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",    "contentVersion": "1.0.0.0",  "parameters": {    "storageAccountName": {      "type": "string",      "minLength": 1    ...    },    "subnetName": {      "type": "string",      "minLength": 1     },    "subnetPrefix": {      "type": "string",      "minLength": 1   ...    "windowsOSVersion": {      "type": "string",      "minLength": 1     },    "vhdStorageName": {      "type": "string",      "minLength": 1     },    "vhdStorageContainerName": {      "type": "string",      "minLength": 1    ...[concat('https://',parameters('storageAccountName'),'armtfiles.blob.core.windows.net/',variables('containerName'),'/Storage.json')]",          "contentVersion": "1.0.0.0"        },        "parameters": {          "storageAccountName": {            "value": "[parameters('storageAccountName')]"          },          "storageType": {            "value": "[parameters('storageType')]"          },          "resourceLocation": {            "value": "[resourceGroup().location]"      ...  "outputs": {    "resourceDetails": {      "type": "object",      "value": "[reference('GetVM').outputs.resourceDetails.value]" } }}</p>
			<p>The master templates invoke the external templates and also co-ordinate inter-dependencies among them.</p>
			<p>The external templates should be available in a well-known location so that the master template can access and invoke them. In this example, the external templates are stored in the Azure Blob storage container and this information was passed to the ARM template by means of parameters.</p>
			<p>The external templates in Azure Blob storage could be access-protected by setting up access policies. The command used to deploy the master template is shown next. It might look like a complex command, but a majority of the values are used as parameters. You are advised to change the values of these parameters before running it. The linked templates have been uploaded to a storage account named <strong class="inline">st02gvwldcxm5suwe</strong> within the <strong class="inline">armtemplates</strong> container. The resource group should be created if it does not currently exist. The first command is used to create a new resource group in the <strong class="inline">West Europe</strong> region:</p>
			<p class="snippet">New-AzResourceGroup -Name "testvmrg" -Location "West Europe" -Verbose</p>
			<p>The rest of the parameter values are needed to configure each resource. The storage account name and the <strong class="inline">dnsNameForPublicIP</strong> value should be unique within Azure:</p>
			<p class="snippet">New-AzResourceGroupDeployment -Name "testdeploy1" -ResourceGroupName testvmrg -Mode Incremental -TemplateFile "C:\chapter 05\Master.json" -storageAccountName "st02gvwldcxm5suwe" -storageType "Standard_LRS" -publicIPAddressName "uniipaddname" -publicIPAddressType "Dynamic" -dnsNameForPublicIP "azureforarchitectsbook" -virtualNetworkName vnetwork01 -addressPrefix "10.0.1.0/16" -subnetName "subnet01" -subnetPrefix "10.0.1.0/24" -nicName nic02 -vmSize "Standard_DS1" -adminUsername "sysadmin" -adminPassword $(ConvertTo-SecureString -String sysadmin@123 -AsPlainText -Force) -vhdStorageName oddnewuniqueacc -vhdStorageContainerName vhds -OSDiskName mynewvm -vmName vm10 -windowsOSVersion 2012-R2-Datacenter -imagePublisher MicrosoftWindowsServer -imageOffer WindowsServer -containerName armtemplates -Verbose</p>
			<p>In this section, we covered best practices for decomposing large templates into smaller reusable templates and combining them together at runtime to deploy complete solutions on Azure. As we progress through the book, we will modify the ARM template step by step until we have explored its core parts. We used Azure PowerShell cmdlets to initiate the deployment of templates on Azure. </p>
			<p>Let's move on to the topic of <strong class="inline">copy</strong> and <strong class="inline">copyIndex</strong>. </p>
			<h2 id="_idParaDest-395"><a id="_idTextAnchor411"/>Understanding copy and copyIndex</h2>
			<p>There are many times when multiple instances of a particular resource or a group of resources are needed. For example, you may need to provision 10 virtual machines of the same type. In such cases, it is not prudent to deploy templates 10 times to create these instances. A better alternate approach is to use the <strong class="inline">copy</strong> and <strong class="inline">copyIndex</strong> features of ARM templates.</p>
			<p><strong class="inline">copy</strong> is an attribute of every resource definition. This means it can be used to create multiple instances of any resource type.</p>
			<p>Let's understand this with the help of an example of creating multiple storage accounts within a single ARM template deployment.</p>
			<p>The next code snippet creates 10 storage accounts serially. They could have been created in parallel by using <strong class="inline">Parallel</strong> instead of <strong class="inline">Serial</strong> for the <strong class="inline">mode</strong> property:</p>
			<p class="snippet">"resources": [</p>
			<p class="snippet">      {</p>
			<p class="snippet">          "apiVersion": "2019-06-01",</p>
			<p class="snippet">          "type": "Microsoft.Storage/storageAccounts",</p>
			<p class="snippet">          "location": "[resourceGroup().location]",</p>
			<p class="snippet">          "name": "[concat(variables('storageAccountName'), copyIndex())]",</p>
			<p class="snippet">          "tags":{</p>
			<p class="snippet">              "displayName": "[variables('storageAccountName')]"</p>
			<p class="snippet">          },</p>
			<p class="snippet">          "sku":{</p>
			<p class="snippet">              "name":"Premium_ZRS"</p>
			<p class="snippet">          },</p>
			<p class="snippet">          "kind": "StorageV2",</p>
			<p class="snippet">          "copy":{</p>
			<p class="snippet">              "name": "storageInstances",</p>
			<p class="snippet">              "count": 10,</p>
			<p class="snippet">              "mode": "Serial"</p>
			<p class="snippet">          }        </p>
			<p class="snippet">      }  </p>
			<p class="snippet">    ],</p>
			<p>In the preceding code, <strong class="inline">copy</strong> has been used to provision 10 instances of the storage account serially, that is, one after another. The storage account names must be unique for all 10 instances, and <strong class="inline">copyIndex</strong> has been used to make them unique by concatenating the original storage name with the index value. The value returned by the <strong class="inline">copyIndex</strong> function changes in every iteration; it will start at 0 and go on for 10 iterations. This means it will return <strong class="inline">9</strong> for the last iteration.</p>
			<p>Now that we have learned how to create multiple instances of an ARM template, let's dive into securing these templates from known vulnerabilities.</p>
			<h2 id="_idParaDest-396"><a id="_idTextAnchor412"/>Securing ARM templates</h2>
			<p>Another important aspect related to creating enterprise ARM templates is securing them appropriately. ARM templates contain the resource configuration and vital information about infrastructure, and so they should not be compromised or accessible to unauthorized people.</p>
			<p>The first step in securing ARM templates is storing them in storage accounts and stopping any anonymous access to the storage account container. Moreover, SAS tokens should be generated for storage accounts and used in ARM templates to consume linked templates. This will ensure that only the holders of SAS tokens can access the templates. Moreover, these SAS tokens should be stored in Azure Key Vault instead of being hardcoded into ARM templates. This will ensure that even the people responsible for deployment do not have access to the SAS token.</p>
			<p>Another step in securing ARM templates is ensuring that any sensitive information and secrets, such as database connection strings, Azure subscription and tenant identifiers, service principal identifiers, IP addresses, and so on, should not be hardcoded in ARM templates. They should all be parameterized, and the values should be fetched at runtime from Azure Key Vault. However, before using this approach, it is important that these secrets are stored in Key Vault prior to executing any ARM templates.</p>
			<p>The following code shows one of the ways that values can be extracted from Azure Key Vault at runtime using the parameters file:</p>
			<p class="snippet">{    "$schema": https://schema.management.azure.com/schemas/2016-01-01/deploymentParameters.json#,    "contentVersion": "1.0.0.0",    "parameters": {        "storageAccountName": {            "reference": {                "keyVault": {                    "id": "/subscriptions/--subscription id --/resourceGroups/rgname/providers/Microsoft.KeyVault/vaults/keyvaultbook"),                "secretName": "StorageAccountName"                }            }        }    }}</p>
			<p>In this code listing, a parameter is defined that references Azure Key Vault to fetch values at runtime during deployment. The Azure Key Vault identifier and the secret name have been provided as input values.</p>
			<p>Now that you have learned how to secure ARM templates, let's take a look at identifying the various dependencies between them and how we can enable communication between multiple templates.</p>
			<h2 id="_idParaDest-397"><a id="_idTextAnchor413"/>Using outputs between ARM templates</h2>
			<p>One of the important aspects that can easily be overlooked while using linked templates is that there might be resource dependencies within linked templates. For example, a SQL Server resource might be in a linked template that is different to that of a virtual machine resource. If we want to open the SQL Server firewall for the virtual machine IP address, then we should be able to dynamically pass this information to the SQL Server firewall resource after provisioning the virtual machine.</p>
			<p>This could be done using the simple method of referring to the IP address resource using the <strong class="inline">REFERENCES</strong> function if the SQL Server and virtual machine resources are in the same template.</p>
			<p>It becomes slightly more complex in the case of linked templates if we want to share runtime property values from one resource to another when they are in different templates.</p>
			<p>ARM templates provide an <strong class="inline">outputs</strong> configuration, which is responsible for generating outputs from the current template deployment and returning them to the user. For example, we might output a complete object, as shown in the following code listing, using the <strong class="inline">reference</strong> function, or we might just output an IP address as a string value:</p>
			<p class="snippet">"outputs": {</p>
			<p class="snippet">    "storageAccountDetails": {</p>
			<p class="snippet">        "type": "object",</p>
			<p class="snippet">        "value": "[reference(resourceid             ('Microsoft.Storage/storageAccounts',             variables('storageAccountName')))]",</p>
			<p class="snippet">    "virtualMachineIPAddress": {</p>
			<p class="snippet">        "type": "string",</p>
			<p class="snippet">        "value": "[reference(variables             ('publicIPAddressName')).properties.ipAddress]"</p>
			<p class="snippet">        }</p>
			<p class="snippet">    }</p>
			<p class="snippet">}</p>
			<p>Parameters within a linked template can be utilized by the master template. When a linked template is called, the output is available to the master template that can be supplied as a parameter to the next linked or nested template. This way, it is possible to send the runtime configuration values of resources from one template to another.</p>
			<p>The code in the master template would be similar to what's shown here; this is the code that's used to call the first template:</p>
			<p class="snippet">{    "type": "Microsoft.Resources/deployments",     "apiVersion": "2017-05-10",     "name": "createvm",     "resoureceGroup": "myrg",     "dependsOn": [        "allResourceGroups"    ],    "properties":{        "mode": "Incremental",        "templateLink":{            "uri": "[variables(                'templateRefSharedServicesTemplateUri')]",            "contentVersion": "1.0.0.0"        },        "parameters": {            "VMName": {                "value": "[variables('VmName')]"            }        }    }}</p>
			<p>The preceding code snippet from the master template is calling a nested template responsible for provisioning a virtual machine. The nested template has an output section that provides the IP address of the virtual machine. The master template will have another deployment resource in its template that will take the output value and send it as a parameter to the next nested template, passing the IP address at runtime. This is shown in the following code:</p>
			<p class="snippet">{    "type": "Microsoft,Resources/deployments",    "apiVersion": "2017-05-10",    "name": "createSQLServer",    "resourceGroup": "myrg",    "dependsOn": [        "createvm"    ],    "properties": {        "mode": "Incremental",        "templateLink": {            "uri": "[variables('templateRefsql')]",            "contentVersion": "1.0.0.0"        },        "parameters": {            "VMName": {                "value": "[reference ('createvm').outputs.virtualMachineIPAddress.value]"            }        }    }}</p>
			<p>In the preceding code listing, a nested template is being invoked and a parameter is being passed to it. The value of the parameter is derived from the previous linked template's output, which is named <strong class="inline">virtualMachineIPAddress</strong>. Now, the nested template will get the IP address of the virtual machine dynamically and it can use it as a whitelisted IP address.</p>
			<p>Using this approach, we can pa<a id="_idTextAnchor414"/>ss runtime values from one nested template to another. </p>
			<h2 id="_idParaDest-398"><a id="_idTextAnchor415"/>Summary</h2>
			<p>ARM templates are the preferred means of provisioning resources in Azure. They are idempotent in nature, bringing consistency, predictability, and reusability to environment creation. In this chapter, we looked at how to create a modular ARM template. It is important for teams to spend quality time designing ARM templates in an appropriate way, so that multiple teams can work on them together. They are highly reusable and require minimal changes to evolve. In this chapter, we learned how to create templates that are secure by design, how to provision multiple resource instances in a single deployment, and how to pass outputs from one nested template to another using the outputs section of ARM templates.</p>
			<p>The next chapter will move on to a different and very popular strand of technology known as serverless within Azure. Azure Functions is one of the major serverless resources of Azure, and this will be covered in complete depth, including Durable Functions.</p>
		</div>
	</body></html>