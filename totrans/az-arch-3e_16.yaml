- en: 16\. ARM template modular design and implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that there are multiple ways to author an **Azure Resource Manager**
    (**ARM**) template. It is quite easy to author one that provisions all of the
    necessary resources in Azure using Visual Studio and Visual Studio Code. A single
    ARM template can consist of all the required resources for a solution on Azure.
    This single ARM template could be as small as a few resources, or it could be
    a larger one consisting of many resources.
  prefs: []
  type: TYPE_NORMAL
- en: While authoring a single template consisting of all resources is quite tempting,
    it is advisable to plan an ARM template implementation divided into multiple smaller
    ARM templates beforehand, so that future troubles related to them can be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at how to write ARM templates in a modular way
    so that they can evolve over a period of time with minimal involvement in terms
    of changes and effort in testing and deployment.
  prefs: []
  type: TYPE_NORMAL
- en: However, before writing modular templates, it is best to understand the problems
    solved by writing them in a modular fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Problems with a single template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding nested and linked deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linked templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Free-flow configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Known configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's explore the aforementioned topics in detail, which will help you
    to write modular templates using industry best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Problems with the single template approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the surface, it might not sound like a single large template consisting of
    all resources will have problems, but there are issues that could arise in the
    future. Let's discuss the issues that might arise when using single large templates.
  prefs: []
  type: TYPE_NORMAL
- en: Reduced flexibility in changing templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using a single large template with all resources makes it difficult to change
    it in the future. With all dependencies, parameters, and variables in a single
    template, changing the template can take a considerable amount of time compared
    to smaller templates. The change could have an impact on other sections of the
    template, which might go unnoticed, as well as introducing bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting large templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Large templates are difficult to troubleshoot. This is a known fact. The larger
    the number of resources in a template, the more difficult it is to troubleshoot
    the template. A template deploys all the resources in it, and finding a bug involves
    deploying the template quite often. Developers would have reduced productivity
    while waiting for the completion of template deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Also, deploying a single template is more time-consuming than deploying smaller
    templates. Developers have to wait for resources containing errors to be deployed
    before taking any action.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency abuse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The dependencies between resources also tend to become more complex in larger
    templates. It is quite easy to abuse the usage of the `dependsOn` feature in ARM
    templates because of the way they work. Every resource in a template can refer
    to all its prior resources rather than building a tree of dependencies. ARM templates
    do not complain if a single resource is dependent on all other resources in the
    ARM template, even though those other resources might have inter-dependencies
    within themselves. This makes changing ARM templates bug prone and, at times,
    it is not even possible to change them.
  prefs: []
  type: TYPE_NORMAL
- en: Reduced agility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generally, there are multiple teams in a project, with each owning their own
    resources in Azure. These teams will find it difficult to work with a single ARM
    template because a single developer should be updating them. Updating a single
    template with multiple teams might induce conflict and difficult-to-solve merges.
    Having multiple smaller templates can enable each team to author their own piece
    of an ARM template.
  prefs: []
  type: TYPE_NORMAL
- en: No reusability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have a single template, then that's all that you have, and using this
    template means deploying all resources. There is no possibility, out of the box,
    to select individual resources without some maneuvering, such as adding conditional
    resources. A single large template loses reusability because you take all the
    resources or none of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing that single large templates have so many issues, it is good practice
    to author modular templates so that we get benefits such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple teams can work on their templates in isolation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates can be reused across projects and solutions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates are easy to debug and troubleshoot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have covered some of the issues with single large templates, in
    the next section, we will consider the crux of modular templates and how they
    may help developers to implement efficient deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Single Responsibility Principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Single Responsibility Principle** is one of the core principles of the
    SOLID design principles. It states that a class or code segment should be responsible
    for a single function and that it should own that functionality completely. The
    code should change or evolve only if there is a functional change or bug in the
    current functionality and not otherwise. This code should not change because of
    changes in some other component or code that is not part of the current component.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the same principle to ARM templates helps us to create templates that
    have the sole responsibility of deploying a single resource or functionality instead
    of deploying all resources and a complete solution.
  prefs: []
  type: TYPE_NORMAL
- en: Using this principle will help you create multiple templates, each responsible
    for a single resource or a smaller group of resources rather than all resources.
  prefs: []
  type: TYPE_NORMAL
- en: Faster troubleshooting and debugging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each template deployment is a distinct activity within Azure and is a separate
    instance consisting of inputs, outputs, and logs. When multiple templates are
    deployed for deploying a solution, each template deployment has separate log entries
    along with its input and output descriptions. It is much easier to isolate bugs
    and troubleshoot issues using these independent logs from multiple deployments
    compared to a single large template.
  prefs: []
  type: TYPE_NORMAL
- en: Modular templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a single large template is decomposed into multiple templates where each
    smaller template takes care of its own resources, and those resources are solely
    owned, maintained, and are the responsibility of the template containing it, we
    can say we have modular templates. Each template within these templates follows
    the Single Responsibility Principle.
  prefs: []
  type: TYPE_NORMAL
- en: Before learning how to divide a large template into multiple smaller reusable
    templates, it is important to understand the technology behind creating smaller
    templates and how to compose them to deploy complete solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ARM provides a facility to link templates. Although we have already gone through
    linked templates in detail, I will mention it here to help you understand how
    linking templates helps us achieve modularity, composition, and reusability.
  prefs: []
  type: TYPE_NORMAL
- en: 'ARM templates provide specialized resources known as `Microsoft.Resources`
    namespace. A deployment resource in an ARM template looks very similar to the
    code segment that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This template is self-explanatory, and the two most important configurations
    in the template resource are the type and the properties. The type here refers
    to the deployment resource rather than any specific Azure resource (storage, virtual
    machine, and so on) and the properties specify the deployment configuration, including
    a linked template deployment or a nested template deployment.
  prefs: []
  type: TYPE_NORMAL
- en: However, what does the deployment resource do? The job of a deployment resource
    is to deploy another template. Another template could be an external template
    in a separate ARM template file, or it could be a nested template. It means that
    it is possible to invoke other templates from a template, just like a function
    call.
  prefs: []
  type: TYPE_NORMAL
- en: 'There can be nested levels of deployments in ARM templates. What this means
    is that a single template can call another template, and the called template can
    call another template, and this can go on for five levels of nested callings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A graphical representation illustrating the nested calling in ARM templates
    where the Master template calls an intermediate template, which in turn calls
    individual templates.](img/Figure_16.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.1: Template decomposition into smaller templates'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that we understand that large templates can be modular with separate resources
    in separate templates, we need to link and bring them together to deploy resources
    on Azure. Linked and nested templates are ways to compose multiple templates together.
  prefs: []
  type: TYPE_NORMAL
- en: Linked templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Linked templates are templates that invoke external templates. External templates
    are stored in different ARM template files. An example of linked templates follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Important additional properties in this template compared to the previous template
    are `templateLink` and `parametersLink`. Now, `templateLink` refers to the actual
    URL of the location of the external template file, and `parametersLink` is the
    URL location for the corresponding `parameters` file. It is important to note
    that the caller template should have access rights to the location of the called
    template. For example, if the external templates are stored in Azure Blob storage,
    which is protected by keys, then the appropriate **Secure Access Signature** (**SAS**)
    keys must be available to the caller template to be able to access the linked
    templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to provide explicit inline parameters instead of the `parametersLink`
    value, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You now have a good understanding of linked templates. A closely related topic
    is nested templates, which the next section will discuss in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Nested templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nested templates are a relatively new feature in ARM templates compared to external
    linked templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nested templates do not define resources in external files. The resources are
    defined within the caller template itself and within the deployment resource,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this code segment, we can see that the storage account resource is nested
    within the original template as part of the deployments resource. Instead of using
    the `templateLink` and `parametersLink` attributes, a `resources` array is used
    to create multiple resources as part of a single deployment. The advantage of
    using a nested deployment is that resources within a parent can be used to reconfigure
    them by using their names. Usually, a resource with a name can exist only once
    within a template. Nested templates allow us to use them within the same template
    and ensure that all templates are self-sufficient rather than being stored separately,
    and they may or may not be accessible to those external files.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the technology behind modular ARM templates, how should
    we divide a large template into smaller templates?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple ways a large template can be decomposed into smaller templates.
    Microsoft recommends the following pattern for the decomposition of ARM templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A flow diagram illustrating the decompositionofARMtemplates.](img/Figure_16.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.2: Template decomposition strategy'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When we decompose a large template into smaller templates, there is always the
    main template, which is used for deploying the solution. This main or master template
    internally invokes other nested or linked templates and they, in turn, invoke
    other templates, and finally, the templates containing Azure resources are deployed.
  prefs: []
  type: TYPE_NORMAL
- en: The main template can invoke a known configuration resource template, which,
    in turn, will invoke templates comprising Azure resources. The known configuration
    resource template is specific to a project or solution and it does not have many
    reusable factors associated with it. The member resource templates are reusable
    templates invoked by the known configuration resource template.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, the master template can invoke shared resource templates and other
    resource templates if they exist.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand known configurations. Templates can be authored
    as known configurations or as free-flow configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Free-flow configurations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ARM templates can be authored as generic templates where most, if not all, of
    the values assigned to variables are obtained as parameters. This allows the person
    using the template to pass any value they deem necessary to deploy resources in
    Azure. For example, the person deploying the template could choose a virtual machine
    of any size, any number of virtual machines, and any configuration for its storage
    and networks. This is known as free-flow configuration, where most of the configuration
    is allowed and the templates come from the user instead of being declared within
    the template.
  prefs: []
  type: TYPE_NORMAL
- en: There are challenges with this kind of configuration. The biggest one is that
    not all configurations are supported in every Azure region and datacenter in Azure.
    The templates will fail to create resources if those resources are not allowed
    to be created in specific locations or regions. Another issue with free-flow configuration
    is that users can provide any value they deem necessary and a template will honor
    them, thereby increasing both the cost and deployment footprint even though they
    are not completely required.
  prefs: []
  type: TYPE_NORMAL
- en: Known configurations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Known configurations, on the other hand, are specific pre-determined configurations
    for deploying an environment using ARM templates. These pre-determined configurations
    are known as **T-shirt sizing configurations**. Similar to the way a T-shirt is
    available in a pre-determined configuration such as small, medium, and large,
    ARM templates can be pre-configured to deploy a small, medium, or large environment
    depending on the requirements. This means that users cannot determine any random
    custom size for the environment, but they can choose from various provided options,
    and ARM templates executed during runtime will ensure that an appropriate configuration
    of the environment is provided.
  prefs: []
  type: TYPE_NORMAL
- en: So, the first step in creating a modular ARM template is deciding on the known
    configurations for an environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, here is the configuration of a datacenter deployment on Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuration of a datacenter deployment on Azure](img/Chapter_16_Table.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 16.1: Configuration of a datacenter deployment on Azure'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that we know the configurations, we can create modular ARM templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to write modular ARM templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Composed templates**: Composed templates link to other templates. Examples
    of composed templates are master and intermediate templates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leaf-level templates**: Leaf-level templates are templates that contain a
    single Azure resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ARM templates can be divided into modular templates based on the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Technology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An ideal way to decide on the modular method to author an ARM template is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Define resource- or leaf-level templates consisting of single resources. In
    the upcoming diagram, the extreme right templates are leaf-level templates. Within
    the diagram, virtual machines, virtual network, storage, and others in the same
    column represent leaf-level templates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compose environment-specific templates using leaf-level templates. These environment-specific
    templates provide an Azure environment, such as a SQL Server environment, an App
    Service environment, or a datacenter environment. Let's drill down a bit more
    into this topic. Let's take the example of an Azure SQL environment. To create
    an Azure SQL environment, multiple resources are needed. At a bare minimum, a
    logical SQL Server, a SQL database, and a few SQL firewall resources should be
    provisioned. All these resources are defined in individual templates at the leaf
    level. These resources can be composed together in a single template that has
    the capability to create an Azure SQL environment. Anybody wanting to create an
    SQL environment can use this composed template. *Figure 16.3* has **Data center**,
    **Messaging**, and **App Service** as environment-specific templates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create templates with higher abstraction composing multiple environment-specific
    templates into solutions. These templates are composed of environment-specific
    templates that were created in the previous step. For example, to create an e-commerce
    inventory solution that needs an App Service environment and a SQL environment,
    two environment templates, App Service and SQL Server, can be composed together.
    *Figure 16.3* has **Functional 1** and **Functional 2** templates, which are composed
    of child templates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, a master template should be created, which should be composed of multiple
    templates where each template is capable of deploying a solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding steps for creating a modular designed template can be easily
    understood by means of *Figure 16.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram illustrating the creation of amodulardesignedtemplate with the
    help of template and resource mapping.](img/Figure_16.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.3: Template and resource mapping'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now, let's implement a part of the functionality shown in the previous diagram.
    In this implementation, we will provide a virtual machine with a script extension
    using a modular approach. The custom script extension deploys Docker binaries
    and prepares a container environment on a Windows Server 2016 virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to create a solution using ARM templates using a modular
    approach. As mentioned before, the first step is to create individual resource
    templates. These individual resource templates will be used to compose additional
    templates capable of creating an environment. These templates will be needed to
    create a virtual machine. All ARM templates shown here are available in the accompanying
    chapter code. The names and code of these templates are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Storage.json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`virtualNetwork.json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PublicIPAddress.json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NIC.json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VirtualMachine.json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CustomScriptExtension.json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, let''s look at the code for the `Storage.json` template. This template
    provides a storage account, which every virtual machine needs for storing its
    OS and data disk files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s look at the code for the public IP address template. A virtual
    machine that should be accessible over the internet needs a public IP address
    resource assigned to its network interface card. Although exposing a virtual machine
    to the internet is optional, this resource might get used for creating a virtual
    machine. The following code is available in the `PublicIPAddress.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s look at the code for the virtual network. Virtual machines on
    Azure need a virtual network for communication. This template will be used to
    create a virtual network on Azure with a pre-defined address range and subnets.
    The following code is available in the `virtualNetwork.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s look at the code for the network interface card. A virtual network
    card is needed by a virtual machine to connect to a virtual network and to accept
    and send requests to and from the internet. The following code is available in
    the `NIC.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s look at the code for creating a virtual machine. Each virtual
    machine is a resource in Azure, and note that this template has no reference to
    storage, network, public IP addresses, or other resources created earlier. This
    reference and composition will happen later in this section using another template.
    The following code is available in the `VirtualMachine.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s look at the code for creating a custom script extension. This
    resource executes a PowerShell script on a virtual machine after it is provisioned.
    This resource provides an opportunity to execute post-provisioning tasks in Azure
    Virtual Machines. The following code is available in the `CustomScriptExtension.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll look at the custom script extension PowerShell code that prepares
    the Docker environment. Please note that a virtual machine reboot might happen
    while executing the PowerShell script, depending on whether the Windows containers
    feature is already installed or not. The following script installs the NuGet package,
    the `DockerMsftProvider` provider, and the Docker executable. The `docker.ps1`
    file is available with the accompanying chapter code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: All the previously seen linked templates should be uploaded to a container within
    an Azure Blob storage account. This container can have a private access policy
    applied, as you saw in the previous chapter; however, for this example, we will
    set the access policy as `container`. This means these linked templates can be
    accessed without an SAS token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s focus on writing the master template. Within the master template,
    all the linked templates are composed together to create a solutionâ€”to deploy
    a virtual machine and execute a script within it. The same approach can be used
    for creating other solutions, such as providing a datacenter consisting of multiple
    inter-connected virtual machines. The following code is available in the `Master.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The master templates invoke the external templates and also co-ordinate inter-dependencies
    among them.
  prefs: []
  type: TYPE_NORMAL
- en: The external templates should be available in a well-known location so that
    the master template can access and invoke them. In this example, the external
    templates are stored in the Azure Blob storage container and this information
    was passed to the ARM template by means of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The external templates in Azure Blob storage could be access-protected by setting
    up access policies. The command used to deploy the master template is shown next.
    It might look like a complex command, but a majority of the values are used as
    parameters. You are advised to change the values of these parameters before running
    it. The linked templates have been uploaded to a storage account named `st02gvwldcxm5suwe`
    within the `armtemplates` container. The resource group should be created if it
    does not currently exist. The first command is used to create a new resource group
    in the `West Europe` region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the parameter values are needed to configure each resource. The
    storage account name and the `dnsNameForPublicIP` value should be unique within
    Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we covered best practices for decomposing large templates into
    smaller reusable templates and combining them together at runtime to deploy complete
    solutions on Azure. As we progress through the book, we will modify the ARM template
    step by step until we have explored its core parts. We used Azure PowerShell cmdlets
    to initiate the deployment of templates on Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the topic of `copy` and `copyIndex`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding copy and copyIndex
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many times when multiple instances of a particular resource or a group
    of resources are needed. For example, you may need to provision 10 virtual machines
    of the same type. In such cases, it is not prudent to deploy templates 10 times
    to create these instances. A better alternate approach is to use the `copy` and
    `copyIndex` features of ARM templates.
  prefs: []
  type: TYPE_NORMAL
- en: '`copy` is an attribute of every resource definition. This means it can be used
    to create multiple instances of any resource type.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand this with the help of an example of creating multiple storage
    accounts within a single ARM template deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next code snippet creates 10 storage accounts serially. They could have
    been created in parallel by using `Parallel` instead of `Serial` for the `mode`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `copy` has been used to provision 10 instances of the
    storage account serially, that is, one after another. The storage account names
    must be unique for all 10 instances, and `copyIndex` has been used to make them
    unique by concatenating the original storage name with the index value. The value
    returned by the `copyIndex` function changes in every iteration; it will start
    at 0 and go on for 10 iterations. This means it will return `9` for the last iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to create multiple instances of an ARM template,
    let's dive into securing these templates from known vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Securing ARM templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another important aspect related to creating enterprise ARM templates is securing
    them appropriately. ARM templates contain the resource configuration and vital
    information about infrastructure, and so they should not be compromised or accessible
    to unauthorized people.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in securing ARM templates is storing them in storage accounts
    and stopping any anonymous access to the storage account container. Moreover,
    SAS tokens should be generated for storage accounts and used in ARM templates
    to consume linked templates. This will ensure that only the holders of SAS tokens
    can access the templates. Moreover, these SAS tokens should be stored in Azure
    Key Vault instead of being hardcoded into ARM templates. This will ensure that
    even the people responsible for deployment do not have access to the SAS token.
  prefs: []
  type: TYPE_NORMAL
- en: Another step in securing ARM templates is ensuring that any sensitive information
    and secrets, such as database connection strings, Azure subscription and tenant
    identifiers, service principal identifiers, IP addresses, and so on, should not
    be hardcoded in ARM templates. They should all be parameterized, and the values
    should be fetched at runtime from Azure Key Vault. However, before using this
    approach, it is important that these secrets are stored in Key Vault prior to
    executing any ARM templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows one of the ways that values can be extracted from
    Azure Key Vault at runtime using the parameters file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this code listing, a parameter is defined that references Azure Key Vault
    to fetch values at runtime during deployment. The Azure Key Vault identifier and
    the secret name have been provided as input values.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned how to secure ARM templates, let's take a look at
    identifying the various dependencies between them and how we can enable communication
    between multiple templates.
  prefs: []
  type: TYPE_NORMAL
- en: Using outputs between ARM templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the important aspects that can easily be overlooked while using linked
    templates is that there might be resource dependencies within linked templates.
    For example, a SQL Server resource might be in a linked template that is different
    to that of a virtual machine resource. If we want to open the SQL Server firewall
    for the virtual machine IP address, then we should be able to dynamically pass
    this information to the SQL Server firewall resource after provisioning the virtual
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: This could be done using the simple method of referring to the IP address resource
    using the `REFERENCES` function if the SQL Server and virtual machine resources
    are in the same template.
  prefs: []
  type: TYPE_NORMAL
- en: It becomes slightly more complex in the case of linked templates if we want
    to share runtime property values from one resource to another when they are in
    different templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'ARM templates provide an `outputs` configuration, which is responsible for
    generating outputs from the current template deployment and returning them to
    the user. For example, we might output a complete object, as shown in the following
    code listing, using the `reference` function, or we might just output an IP address
    as a string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Parameters within a linked template can be utilized by the master template.
    When a linked template is called, the output is available to the master template
    that can be supplied as a parameter to the next linked or nested template. This
    way, it is possible to send the runtime configuration values of resources from
    one template to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in the master template would be similar to what''s shown here; this
    is the code that''s used to call the first template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet from the master template is calling a nested template
    responsible for provisioning a virtual machine. The nested template has an output
    section that provides the IP address of the virtual machine. The master template
    will have another deployment resource in its template that will take the output
    value and send it as a parameter to the next nested template, passing the IP address
    at runtime. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code listing, a nested template is being invoked and a parameter
    is being passed to it. The value of the parameter is derived from the previous
    linked template's output, which is named `virtualMachineIPAddress`. Now, the nested
    template will get the IP address of the virtual machine dynamically and it can
    use it as a whitelisted IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Using this approach, we can pass runtime values from one nested template to
    another.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ARM templates are the preferred means of provisioning resources in Azure. They
    are idempotent in nature, bringing consistency, predictability, and reusability
    to environment creation. In this chapter, we looked at how to create a modular
    ARM template. It is important for teams to spend quality time designing ARM templates
    in an appropriate way, so that multiple teams can work on them together. They
    are highly reusable and require minimal changes to evolve. In this chapter, we
    learned how to create templates that are secure by design, how to provision multiple
    resource instances in a single deployment, and how to pass outputs from one nested
    template to another using the outputs section of ARM templates.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will move on to a different and very popular strand of technology
    known as serverless within Azure. Azure Functions is one of the major serverless
    resources of Azure, and this will be covered in complete depth, including Durable
    Functions.
  prefs: []
  type: TYPE_NORMAL
