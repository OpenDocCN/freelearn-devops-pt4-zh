- en: 16\. ARM template modular design and implementation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16. ARM模板的模块化设计与实现
- en: We know that there are multiple ways to author an **Azure Resource Manager**
    (**ARM**) template. It is quite easy to author one that provisions all of the
    necessary resources in Azure using Visual Studio and Visual Studio Code. A single
    ARM template can consist of all the required resources for a solution on Azure.
    This single ARM template could be as small as a few resources, or it could be
    a larger one consisting of many resources.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，有多种方法可以编写**Azure资源管理器**（**ARM**）模板。使用Visual Studio和Visual Studio Code编写一个能够在Azure中配置所有必要资源的模板是相当容易的。一个单独的ARM模板可以包含Azure上解决方案所需的所有资源。这个单一的ARM模板可以小到仅几个资源，或者大到包含许多资源的模板。
- en: While authoring a single template consisting of all resources is quite tempting,
    it is advisable to plan an ARM template implementation divided into multiple smaller
    ARM templates beforehand, so that future troubles related to them can be avoided.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管编写一个包含所有资源的单一模板非常具有诱惑力，但建议事先规划将ARM模板实现分成多个较小的ARM模板，以便避免未来与之相关的麻烦。
- en: In this chapter, we will look at how to write ARM templates in a modular way
    so that they can evolve over a period of time with minimal involvement in terms
    of changes and effort in testing and deployment.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何以模块化的方式编写ARM模板，以便它们能够随着时间的推移不断演进，且在变更、测试和部署时所需的参与和努力最小化。
- en: However, before writing modular templates, it is best to understand the problems
    solved by writing them in a modular fashion.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在编写模块化模板之前，最好先了解通过模块化编写模板所解决的问题。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下话题：
- en: Problems with a single template
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单模板的问题
- en: Understanding nested and linked deployment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解嵌套和链接部署
- en: Linked templates
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接模板
- en: Nested templates
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套模板
- en: Free-flow configurations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自由流配置
- en: Known configurations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已知配置
- en: Now, let's explore the aforementioned topics in detail, which will help you
    to write modular templates using industry best practices.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细探讨上述话题，这将帮助您使用行业最佳实践编写模块化模板。
- en: Problems with the single template approach
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单模板方法的问题
- en: On the surface, it might not sound like a single large template consisting of
    all resources will have problems, but there are issues that could arise in the
    future. Let's discuss the issues that might arise when using single large templates.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，单个包含所有资源的大模板似乎不会有什么问题，但将来可能会出现一些问题。让我们讨论使用单个大模板时可能会遇到的问题。
- en: Reduced flexibility in changing templates
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改模板时灵活性降低
- en: Using a single large template with all resources makes it difficult to change
    it in the future. With all dependencies, parameters, and variables in a single
    template, changing the template can take a considerable amount of time compared
    to smaller templates. The change could have an impact on other sections of the
    template, which might go unnoticed, as well as introducing bugs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包含所有资源的单个大模板使得将来进行更改变得困难。将所有依赖项、参数和变量都放在一个模板中，与较小的模板相比，更改模板可能需要花费大量时间。这些更改可能会影响模板的其他部分，且可能会被忽视，甚至引入错误。
- en: Troubleshooting large templates
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排查大模板问题
- en: Large templates are difficult to troubleshoot. This is a known fact. The larger
    the number of resources in a template, the more difficult it is to troubleshoot
    the template. A template deploys all the resources in it, and finding a bug involves
    deploying the template quite often. Developers would have reduced productivity
    while waiting for the completion of template deployment.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 大模板难以排查。这是一个已知的事实。模板中的资源数量越多，排查模板的问题就越困难。一个模板部署了所有资源，找到错误通常需要反复部署模板。开发人员在等待模板部署完成时会降低生产力。
- en: Also, deploying a single template is more time-consuming than deploying smaller
    templates. Developers have to wait for resources containing errors to be deployed
    before taking any action.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，部署单个模板比部署较小的模板更加耗时。开发人员必须等待包含错误的资源部署完成后，才能采取任何行动。
- en: Dependency abuse
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖滥用
- en: The dependencies between resources also tend to become more complex in larger
    templates. It is quite easy to abuse the usage of the `dependsOn` feature in ARM
    templates because of the way they work. Every resource in a template can refer
    to all its prior resources rather than building a tree of dependencies. ARM templates
    do not complain if a single resource is dependent on all other resources in the
    ARM template, even though those other resources might have inter-dependencies
    within themselves. This makes changing ARM templates bug prone and, at times,
    it is not even possible to change them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在较大的模板中，资源之间的依赖关系也往往变得更加复杂。由于 ARM 模板的工作方式，滥用 `dependsOn` 功能是很容易的。模板中的每个资源可以引用它之前的所有资源，而不是构建依赖关系树。ARM
    模板在一个资源依赖于所有其他资源时并不会报错，尽管这些其他资源之间可能有相互依赖关系。这使得更改 ARM 模板容易引入 bug，有时甚至无法进行更改。
- en: Reduced agility
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 降低敏捷性
- en: Generally, there are multiple teams in a project, with each owning their own
    resources in Azure. These teams will find it difficult to work with a single ARM
    template because a single developer should be updating them. Updating a single
    template with multiple teams might induce conflict and difficult-to-solve merges.
    Having multiple smaller templates can enable each team to author their own piece
    of an ARM template.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个项目中有多个团队，每个团队负责其在 Azure 中的资源。这些团队会发现很难使用单一 ARM 模板，因为应该由单个开发人员来更新这些模板。多个团队同时更新一个模板可能会导致冲突和难以解决的合并问题。拥有多个小模板可以使每个团队独立编写自己的
    ARM 模板部分。
- en: No reusability
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无法重用
- en: If you have a single template, then that's all that you have, and using this
    template means deploying all resources. There is no possibility, out of the box,
    to select individual resources without some maneuvering, such as adding conditional
    resources. A single large template loses reusability because you take all the
    resources or none of them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只有一个模板，那么你只能使用这个模板，并且使用这个模板意味着部署所有资源。没有办法直接选择单个资源，除非进行一些额外操作，比如添加条件资源。单一的大模板失去了重用性，因为你只能选择所有资源或没有资源。
- en: 'Knowing that single large templates have so many issues, it is good practice
    to author modular templates so that we get benefits such as the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 了解单一大模板存在的诸多问题后，编写模块化模板是一种好习惯，这样我们可以获得以下好处：
- en: Multiple teams can work on their templates in isolation.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个团队可以在隔离的环境中独立工作各自的模板。
- en: Templates can be reused across projects and solutions.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板可以跨项目和解决方案重复使用。
- en: Templates are easy to debug and troubleshoot.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板易于调试和故障排除。
- en: Now that we have covered some of the issues with single large templates, in
    the next section, we will consider the crux of modular templates and how they
    may help developers to implement efficient deployments.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了单一大模板的一些问题，接下来我们将探讨模块化模板的核心，并且它们如何帮助开发人员实现高效部署。
- en: Understanding the Single Responsibility Principle
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解单一职责原则
- en: The **Single Responsibility Principle** is one of the core principles of the
    SOLID design principles. It states that a class or code segment should be responsible
    for a single function and that it should own that functionality completely. The
    code should change or evolve only if there is a functional change or bug in the
    current functionality and not otherwise. This code should not change because of
    changes in some other component or code that is not part of the current component.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**单一职责原则**是 SOLID 设计原则中的核心原则之一。它指出，一个类或代码段应该只负责单一功能，并且应完全拥有该功能。代码只有在当前功能发生功能变化或出现
    bug 时才应发生更改或演变，而不是因为与当前组件无关的其他组件或代码的变化而改变。'
- en: Applying the same principle to ARM templates helps us to create templates that
    have the sole responsibility of deploying a single resource or functionality instead
    of deploying all resources and a complete solution.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将相同的原则应用于 ARM 模板有助于我们创建仅负责部署单一资源或功能的模板，而不是部署所有资源和完整解决方案。
- en: Using this principle will help you create multiple templates, each responsible
    for a single resource or a smaller group of resources rather than all resources.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这一原则将帮助你创建多个模板，每个模板负责一个单一资源或一小部分资源，而不是所有资源。
- en: Faster troubleshooting and debugging
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更快的故障排除和调试
- en: Each template deployment is a distinct activity within Azure and is a separate
    instance consisting of inputs, outputs, and logs. When multiple templates are
    deployed for deploying a solution, each template deployment has separate log entries
    along with its input and output descriptions. It is much easier to isolate bugs
    and troubleshoot issues using these independent logs from multiple deployments
    compared to a single large template.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模板的部署在 Azure 中都是一个独立的活动，是由输入、输出和日志组成的单独实例。当多个模板被部署来实现一个解决方案时，每个模板的部署都有独立的日志条目以及其输入和输出描述。与单个大型模板相比，使用来自多个部署的独立日志来隔离错误和排除故障要容易得多。
- en: Modular templates
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块化模板
- en: When a single large template is decomposed into multiple templates where each
    smaller template takes care of its own resources, and those resources are solely
    owned, maintained, and are the responsibility of the template containing it, we
    can say we have modular templates. Each template within these templates follows
    the Single Responsibility Principle.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个单一的大型模板被拆解成多个模板，每个小模板负责自己的资源，而这些资源仅由包含它的模板拥有、维护并负责时，我们可以说这是模块化模板。每个模板都遵循单一职责原则。
- en: Before learning how to divide a large template into multiple smaller reusable
    templates, it is important to understand the technology behind creating smaller
    templates and how to compose them to deploy complete solutions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何将一个大型模板拆分为多个小型可重用模板之前，理解创建小型模板背后的技术以及如何组合它们来部署完整解决方案是非常重要的。
- en: Deployment resources
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署资源
- en: ARM provides a facility to link templates. Although we have already gone through
    linked templates in detail, I will mention it here to help you understand how
    linking templates helps us achieve modularity, composition, and reusability.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 提供了一种链接模板的功能。尽管我们已经详细讲解了链接模板，但我还是在这里提一下，以帮助你理解链接模板如何帮助我们实现模块化、组合和重用。
- en: 'ARM templates provide specialized resources known as `Microsoft.Resources`
    namespace. A deployment resource in an ARM template looks very similar to the
    code segment that follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 模板提供了专门的资源，称为 `Microsoft.Resources` 命名空间。ARM 模板中的部署资源看起来非常类似于以下的代码片段：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This template is self-explanatory, and the two most important configurations
    in the template resource are the type and the properties. The type here refers
    to the deployment resource rather than any specific Azure resource (storage, virtual
    machine, and so on) and the properties specify the deployment configuration, including
    a linked template deployment or a nested template deployment.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板不言自明，模板资源中最重要的两个配置项是类型和属性。这里的类型指的是部署资源，而不是任何特定的 Azure 资源（如存储、虚拟机等），属性则指定了部署配置，包括链接模板部署或嵌套模板部署。
- en: However, what does the deployment resource do? The job of a deployment resource
    is to deploy another template. Another template could be an external template
    in a separate ARM template file, or it could be a nested template. It means that
    it is possible to invoke other templates from a template, just like a function
    call.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，部署资源的作用是什么呢？部署资源的工作是部署另一个模板。另一个模板可以是一个独立的外部模板，位于一个单独的 ARM 模板文件中，也可以是一个嵌套模板。这意味着可以像函数调用一样，从一个模板中调用其他模板。
- en: 'There can be nested levels of deployments in ARM templates. What this means
    is that a single template can call another template, and the called template can
    call another template, and this can go on for five levels of nested callings:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 模板中可以有嵌套级别的部署。这意味着一个模板可以调用另一个模板，而被调用的模板又可以调用另一个模板，这样的嵌套调用最多可以有五个级别：
- en: '![A graphical representation illustrating the nested calling in ARM templates
    where the Master template calls an intermediate template, which in turn calls
    individual templates.](img/Figure_16.1.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![一张图示说明了 ARM 模板中的嵌套调用，其中主模板调用一个中间模板，而该中间模板又调用各个单独的模板。](img/Figure_16.1.jpg)'
- en: 'Figure 16.1: Template decomposition into smaller templates'
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16.1：模板拆分成更小的模板
- en: Now that we understand that large templates can be modular with separate resources
    in separate templates, we need to link and bring them together to deploy resources
    on Azure. Linked and nested templates are ways to compose multiple templates together.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了大型模板可以通过将资源分布在不同的模板中实现模块化，我们需要将它们链接在一起，以便在 Azure 上部署资源。链接模板和嵌套模板是将多个模板组合在一起的方式。
- en: Linked templates
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接模板
- en: 'Linked templates are templates that invoke external templates. External templates
    are stored in different ARM template files. An example of linked templates follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 链接模板是调用外部模板的模板。外部模板存储在不同的ARM模板文件中。以下是链接模板的示例：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Important additional properties in this template compared to the previous template
    are `templateLink` and `parametersLink`. Now, `templateLink` refers to the actual
    URL of the location of the external template file, and `parametersLink` is the
    URL location for the corresponding `parameters` file. It is important to note
    that the caller template should have access rights to the location of the called
    template. For example, if the external templates are stored in Azure Blob storage,
    which is protected by keys, then the appropriate **Secure Access Signature** (**SAS**)
    keys must be available to the caller template to be able to access the linked
    templates.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 相较于前一个模板，这个模板中重要的额外属性是`templateLink`和`parametersLink`。现在，`templateLink`指向外部模板文件的实际URL，而`parametersLink`是相应`parameters`文件的URL位置。需要注意的是，调用模板应该有访问被调用模板位置的权限。例如，如果外部模板存储在Azure
    Blob存储中，并且该存储受到密钥保护，则调用模板必须能够使用适当的**安全访问签名**（**SAS**）密钥才能访问链接的模板。
- en: 'It is also possible to provide explicit inline parameters instead of the `parametersLink`
    value, as shown here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以提供显式的内联参数，而不是`parametersLink`值，如下所示：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You now have a good understanding of linked templates. A closely related topic
    is nested templates, which the next section will discuss in detail.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对链接模板有了较好的理解。一个紧密相关的话题是嵌套模板，下一节将详细讨论这一点。
- en: Nested templates
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套模板
- en: Nested templates are a relatively new feature in ARM templates compared to external
    linked templates.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 相较于外部链接模板，嵌套模板是ARM模板中的一个相对较新的功能。
- en: 'Nested templates do not define resources in external files. The resources are
    defined within the caller template itself and within the deployment resource,
    as shown here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套模板不会在外部文件中定义资源。资源是在调用模板本身和部署资源中定义的，如下所示：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this code segment, we can see that the storage account resource is nested
    within the original template as part of the deployments resource. Instead of using
    the `templateLink` and `parametersLink` attributes, a `resources` array is used
    to create multiple resources as part of a single deployment. The advantage of
    using a nested deployment is that resources within a parent can be used to reconfigure
    them by using their names. Usually, a resource with a name can exist only once
    within a template. Nested templates allow us to use them within the same template
    and ensure that all templates are self-sufficient rather than being stored separately,
    and they may or may not be accessible to those external files.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码段中，我们可以看到存储账户资源被嵌套在原始模板内，作为部署资源的一部分。与使用`templateLink`和`parametersLink`属性不同，这里使用`resources`数组作为单个部署的一部分来创建多个资源。使用嵌套部署的优势是，可以通过使用资源的名称来重新配置父级内的资源。通常，一个带有名称的资源在模板中只能存在一次。嵌套模板允许我们在同一个模板内使用它们，并确保所有模板都是自给自足的，而不是分别存储，并且这些模板可能或可能无法访问外部文件。
- en: Now that we understand the technology behind modular ARM templates, how should
    we divide a large template into smaller templates?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了模块化ARM模板背后的技术，应该如何将一个大型模板分解为更小的模板呢？
- en: 'There are multiple ways a large template can be decomposed into smaller templates.
    Microsoft recommends the following pattern for the decomposition of ARM templates:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式可以将一个大型模板分解成更小的模板。微软推荐以下模式用于ARM模板的分解：
- en: '![A flow diagram illustrating the decompositionofARMtemplates.](img/Figure_16.2.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![一个流程图，说明了ARM模板的分解。](img/Figure_16.2.jpg)'
- en: 'Figure 16.2: Template decomposition strategy'
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图16.2：模板分解策略
- en: When we decompose a large template into smaller templates, there is always the
    main template, which is used for deploying the solution. This main or master template
    internally invokes other nested or linked templates and they, in turn, invoke
    other templates, and finally, the templates containing Azure resources are deployed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将一个大型模板分解成更小的模板时，总是会有一个主模板，用于部署解决方案。这个主模板或母模板内部调用其他嵌套或链接的模板，这些模板又会调用其他模板，最终，包含Azure资源的模板会被部署。
- en: The main template can invoke a known configuration resource template, which,
    in turn, will invoke templates comprising Azure resources. The known configuration
    resource template is specific to a project or solution and it does not have many
    reusable factors associated with it. The member resource templates are reusable
    templates invoked by the known configuration resource template.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 主模板可以调用已知配置资源模板，后者又会调用包含 Azure 资源的模板。已知配置资源模板是特定于项目或解决方案的，且与之相关的可重用因素较少。成员资源模板是由已知配置资源模板调用的可重用模板。
- en: Optionally, the master template can invoke shared resource templates and other
    resource templates if they exist.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，主模板可以调用共享资源模板和其他资源模板（如果它们存在）。
- en: It is important to understand known configurations. Templates can be authored
    as known configurations or as free-flow configurations.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 理解已知配置非常重要。模板可以作为已知配置或自由流配置来编写。
- en: Free-flow configurations
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自由流配置
- en: ARM templates can be authored as generic templates where most, if not all, of
    the values assigned to variables are obtained as parameters. This allows the person
    using the template to pass any value they deem necessary to deploy resources in
    Azure. For example, the person deploying the template could choose a virtual machine
    of any size, any number of virtual machines, and any configuration for its storage
    and networks. This is known as free-flow configuration, where most of the configuration
    is allowed and the templates come from the user instead of being declared within
    the template.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 模板可以作为通用模板进行编写，其中大多数（如果不是全部）分配给变量的值都作为参数获取。这允许使用该模板的人传递他们认为必要的任何值来在 Azure
    中部署资源。例如，部署模板的人可以选择任何大小的虚拟机、任何数量的虚拟机以及任何存储和网络配置。这被称为自由流配置，其中大多数配置是允许的，模板中的配置来自用户，而不是声明在模板内部。
- en: There are challenges with this kind of configuration. The biggest one is that
    not all configurations are supported in every Azure region and datacenter in Azure.
    The templates will fail to create resources if those resources are not allowed
    to be created in specific locations or regions. Another issue with free-flow configuration
    is that users can provide any value they deem necessary and a template will honor
    them, thereby increasing both the cost and deployment footprint even though they
    are not completely required.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种配置方式有其挑战性。最大的问题是，并非所有配置都能在每个 Azure 区域和数据中心中得到支持。如果某些资源不允许在特定位置或区域创建，那么模板将无法创建这些资源。自由流配置的另一个问题是，用户可以提供他们认为必要的任何值，模板会尊重这些值，从而增加了成本和部署的负担，即使这些值并不是完全必需的。
- en: Known configurations
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知配置
- en: Known configurations, on the other hand, are specific pre-determined configurations
    for deploying an environment using ARM templates. These pre-determined configurations
    are known as **T-shirt sizing configurations**. Similar to the way a T-shirt is
    available in a pre-determined configuration such as small, medium, and large,
    ARM templates can be pre-configured to deploy a small, medium, or large environment
    depending on the requirements. This means that users cannot determine any random
    custom size for the environment, but they can choose from various provided options,
    and ARM templates executed during runtime will ensure that an appropriate configuration
    of the environment is provided.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，已知配置是通过 ARM 模板部署环境的特定预设配置。这些预设配置被称为**T恤尺码配置**。类似于 T 恤有小号、中号和大号等预设尺码，ARM
    模板也可以预配置为部署小型、中型或大型环境，具体取决于需求。这意味着用户不能为环境选择任何随机的自定义尺寸，但可以从提供的选项中进行选择，并且在运行时执行的
    ARM 模板将确保提供合适的环境配置。
- en: So, the first step in creating a modular ARM template is deciding on the known
    configurations for an environment.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，创建模块化 ARM 模板的第一步是决定环境的已知配置。
- en: 'As an example, here is the configuration of a datacenter deployment on Azure:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是 Azure 上数据中心部署的配置：
- en: '![Configuration of a datacenter deployment on Azure](img/Chapter_16_Table.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Azure 上数据中心部署的配置](img/Chapter_16_Table.jpg)'
- en: 'Table 16.1: Configuration of a datacenter deployment on Azure'
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 表 16.1：Azure 上数据中心部署的配置
- en: Now that we know the configurations, we can create modular ARM templates.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了这些配置，就可以创建模块化 ARM 模板了。
- en: 'There are two ways to write modular ARM templates:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 编写模块化 ARM 模板有两种方法：
- en: '**Composed templates**: Composed templates link to other templates. Examples
    of composed templates are master and intermediate templates.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合模板**：组合模板链接到其他模板。组合模板的示例包括主模板和中间模板。'
- en: '**Leaf-level templates**: Leaf-level templates are templates that contain a
    single Azure resource.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**叶级模板**：叶级模板是包含单一Azure资源的模板。'
- en: 'ARM templates can be divided into modular templates based on the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ARM模板可以根据以下内容分为模块化模板：
- en: Technology
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术
- en: Functionality
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能
- en: 'An ideal way to decide on the modular method to author an ARM template is as
    follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 决定如何编写ARM模板的模块化方法的理想方式如下：
- en: Define resource- or leaf-level templates consisting of single resources. In
    the upcoming diagram, the extreme right templates are leaf-level templates. Within
    the diagram, virtual machines, virtual network, storage, and others in the same
    column represent leaf-level templates.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义资源级或叶级模板，这些模板由单一资源组成。在接下来的图示中，最右侧的模板是叶级模板。在图中，虚拟机、虚拟网络、存储等位于同一列中，表示叶级模板。
- en: Compose environment-specific templates using leaf-level templates. These environment-specific
    templates provide an Azure environment, such as a SQL Server environment, an App
    Service environment, or a datacenter environment. Let's drill down a bit more
    into this topic. Let's take the example of an Azure SQL environment. To create
    an Azure SQL environment, multiple resources are needed. At a bare minimum, a
    logical SQL Server, a SQL database, and a few SQL firewall resources should be
    provisioned. All these resources are defined in individual templates at the leaf
    level. These resources can be composed together in a single template that has
    the capability to create an Azure SQL environment. Anybody wanting to create an
    SQL environment can use this composed template. *Figure 16.3* has **Data center**,
    **Messaging**, and **App Service** as environment-specific templates.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用叶级模板组合特定于环境的模板。这些特定于环境的模板提供了一个Azure环境，例如SQL Server环境、App Service环境或数据中心环境。我们进一步探讨一下这个话题。以Azure
    SQL环境为例。要创建一个Azure SQL环境，需要多个资源。至少需要一个逻辑SQL Server，一个SQL数据库和一些SQL防火墙资源。所有这些资源都在叶级模板中定义。这些资源可以组合在一起，形成一个单一的模板，从而能够创建Azure
    SQL环境。任何想要创建SQL环境的人都可以使用这个组合模板。*图16.3*中有**数据中心**、**消息传递**和**App Service**作为特定于环境的模板。
- en: Create templates with higher abstraction composing multiple environment-specific
    templates into solutions. These templates are composed of environment-specific
    templates that were created in the previous step. For example, to create an e-commerce
    inventory solution that needs an App Service environment and a SQL environment,
    two environment templates, App Service and SQL Server, can be composed together.
    *Figure 16.3* has **Functional 1** and **Functional 2** templates, which are composed
    of child templates.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有更高抽象层次的模板，将多个特定于环境的模板组合成解决方案。这些模板是由前一步创建的特定于环境的模板组成的。例如，要创建一个需要App Service环境和SQL环境的电子商务库存解决方案，可以将两个环境模板——App
    Service和SQL Server组合在一起。*图16.3*中包含了**功能1**和**功能2**模板，这些模板是由子模板组成的。
- en: Finally, a master template should be created, which should be composed of multiple
    templates where each template is capable of deploying a solution.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，应该创建一个主模板，它由多个模板组成，每个模板都能够部署一个解决方案。
- en: 'The preceding steps for creating a modular designed template can be easily
    understood by means of *Figure 16.3*:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 上述创建模块化设计模板的步骤，可以通过*图16.3*轻松理解：
- en: '![A diagram illustrating the creation of amodulardesignedtemplate with the
    help of template and resource mapping.](img/Figure_16.3.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![一个展示如何通过模板和资源映射来创建模块化设计模板的示意图。](img/Figure_16.3.jpg)'
- en: 'Figure 16.3: Template and resource mapping'
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图16.3：模板和资源映射
- en: Now, let's implement a part of the functionality shown in the previous diagram.
    In this implementation, we will provide a virtual machine with a script extension
    using a modular approach. The custom script extension deploys Docker binaries
    and prepares a container environment on a Windows Server 2016 virtual machine.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现上图所示的部分功能。在此实现中，我们将通过模块化的方法为虚拟机提供脚本扩展。自定义脚本扩展部署Docker二进制文件，并在Windows
    Server 2016虚拟机上准备一个容器环境。
- en: 'Now, we are going to create a solution using ARM templates using a modular
    approach. As mentioned before, the first step is to create individual resource
    templates. These individual resource templates will be used to compose additional
    templates capable of creating an environment. These templates will be needed to
    create a virtual machine. All ARM templates shown here are available in the accompanying
    chapter code. The names and code of these templates are as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用模块化方法通过 ARM 模板创建一个解决方案。如前所述，第一步是创建单独的资源模板。这些单独的资源模板将用于组合成能够创建环境的其他模板。这些模板将用于创建虚拟机。所有此处展示的
    ARM 模板都可以在随书章节代码中找到。这些模板的名称和代码如下：
- en: '`Storage.json`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Storage.json`'
- en: '`virtualNetwork.json`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virtualNetwork.json`'
- en: '`PublicIPAddress.json`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PublicIPAddress.json`'
- en: '`NIC.json`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NIC.json`'
- en: '`VirtualMachine.json`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VirtualMachine.json`'
- en: '`CustomScriptExtension.json`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CustomScriptExtension.json`'
- en: 'First, let''s look at the code for the `Storage.json` template. This template
    provides a storage account, which every virtual machine needs for storing its
    OS and data disk files:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看 `Storage.json` 模板的代码。此模板提供了一个存储帐户，每个虚拟机都需要它来存储操作系统和数据磁盘文件：
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, let''s look at the code for the public IP address template. A virtual
    machine that should be accessible over the internet needs a public IP address
    resource assigned to its network interface card. Although exposing a virtual machine
    to the internet is optional, this resource might get used for creating a virtual
    machine. The following code is available in the `PublicIPAddress.json` file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看公共 IP 地址模板的代码。一个需要通过互联网访问的虚拟机需要将公共 IP 地址资源分配给其网络接口卡。尽管将虚拟机暴露到互联网是可选的，但该资源可能会在创建虚拟机时使用。以下代码位于
    `PublicIPAddress.json` 文件中：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, let''s look at the code for the virtual network. Virtual machines on
    Azure need a virtual network for communication. This template will be used to
    create a virtual network on Azure with a pre-defined address range and subnets.
    The following code is available in the `virtualNetwork.json` file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看虚拟网络的代码。Azure 上的虚拟机需要虚拟网络进行通信。此模板将用于在 Azure 上创建一个虚拟网络，具有预定义的地址范围和子网。以下代码位于
    `virtualNetwork.json` 文件中：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, let''s look at the code for the network interface card. A virtual network
    card is needed by a virtual machine to connect to a virtual network and to accept
    and send requests to and from the internet. The following code is available in
    the `NIC.json` file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看网络接口卡的代码。虚拟机需要一个虚拟网络卡来连接虚拟网络，并接收和发送来自互联网的请求。以下代码位于 `NIC.json` 文件中：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, let''s look at the code for creating a virtual machine. Each virtual
    machine is a resource in Azure, and note that this template has no reference to
    storage, network, public IP addresses, or other resources created earlier. This
    reference and composition will happen later in this section using another template.
    The following code is available in the `VirtualMachine.json` file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看创建虚拟机的代码。每个虚拟机都是 Azure 中的一个资源，并且请注意，此模板与存储、网络、公共 IP 地址或之前创建的其他资源没有关联。这个引用和组合将在本节稍后通过另一个模板完成。以下代码位于
    `VirtualMachine.json` 文件中：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, let''s look at the code for creating a custom script extension. This
    resource executes a PowerShell script on a virtual machine after it is provisioned.
    This resource provides an opportunity to execute post-provisioning tasks in Azure
    Virtual Machines. The following code is available in the `CustomScriptExtension.json`
    file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看创建自定义脚本扩展的代码。此资源在虚拟机配置后执行 PowerShell 脚本。此资源提供了在 Azure 虚拟机中执行后配置任务的机会。以下代码位于
    `CustomScriptExtension.json` 文件中：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we''ll look at the custom script extension PowerShell code that prepares
    the Docker environment. Please note that a virtual machine reboot might happen
    while executing the PowerShell script, depending on whether the Windows containers
    feature is already installed or not. The following script installs the NuGet package,
    the `DockerMsftProvider` provider, and the Docker executable. The `docker.ps1`
    file is available with the accompanying chapter code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看准备 Docker 环境的自定义脚本扩展 PowerShell 代码。请注意，在执行 PowerShell 脚本时，可能会发生虚拟机重启，具体取决于
    Windows 容器功能是否已经安装。以下脚本安装了 NuGet 包、`DockerMsftProvider` 提供程序和 Docker 可执行文件。`docker.ps1`
    文件随章节代码提供：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: All the previously seen linked templates should be uploaded to a container within
    an Azure Blob storage account. This container can have a private access policy
    applied, as you saw in the previous chapter; however, for this example, we will
    set the access policy as `container`. This means these linked templates can be
    accessed without an SAS token.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所有之前看到的链接模板应上传到 Azure Blob 存储帐户中的一个容器内。该容器可以应用私有访问策略，正如你在上一章中看到的那样；然而，在此示例中，我们将访问策略设置为
    `container`。这意味着这些链接模板可以在没有 SAS 令牌的情况下访问。
- en: 'Finally, let''s focus on writing the master template. Within the master template,
    all the linked templates are composed together to create a solution—to deploy
    a virtual machine and execute a script within it. The same approach can be used
    for creating other solutions, such as providing a datacenter consisting of multiple
    inter-connected virtual machines. The following code is available in the `Master.json`
    file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们集中讨论编写主模板。在主模板中，所有的链接模板将被组合在一起，创建一个解决方案——部署虚拟机并在其中执行脚本。相同的方法也可以用于创建其他解决方案，比如提供一个由多个相互连接的虚拟机组成的数据中心。以下代码可以在
    `Master.json` 文件中找到：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The master templates invoke the external templates and also co-ordinate inter-dependencies
    among them.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 主模板调用外部模板，并协调它们之间的相互依赖关系。
- en: The external templates should be available in a well-known location so that
    the master template can access and invoke them. In this example, the external
    templates are stored in the Azure Blob storage container and this information
    was passed to the ARM template by means of parameters.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 外部模板应存放在一个众所周知的位置，以便主模板可以访问并调用它们。在此示例中，外部模板存储在 Azure Blob 存储容器中，并通过参数将此信息传递给
    ARM 模板。
- en: 'The external templates in Azure Blob storage could be access-protected by setting
    up access policies. The command used to deploy the master template is shown next.
    It might look like a complex command, but a majority of the values are used as
    parameters. You are advised to change the values of these parameters before running
    it. The linked templates have been uploaded to a storage account named `st02gvwldcxm5suwe`
    within the `armtemplates` container. The resource group should be created if it
    does not currently exist. The first command is used to create a new resource group
    in the `West Europe` region:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在 Azure Blob 存储中的外部模板可以通过设置访问策略来进行访问保护。用于部署主模板的命令如下所示。它可能看起来是一个复杂的命令，但大多数值是作为参数使用的。在运行命令之前，建议你更改这些参数的值。已将链接模板上传到名为
    `st02gvwldcxm5suwe` 的存储帐户中的 `armtemplates` 容器。如果资源组当前不存在，应先创建资源组。第一个命令用于在 `West
    Europe` 区域创建一个新的资源组：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The rest of the parameter values are needed to configure each resource. The
    storage account name and the `dnsNameForPublicIP` value should be unique within
    Azure:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的参数值是配置每个资源所需的。存储帐户名称和 `dnsNameForPublicIP` 值在 Azure 中应是唯一的：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this section, we covered best practices for decomposing large templates into
    smaller reusable templates and combining them together at runtime to deploy complete
    solutions on Azure. As we progress through the book, we will modify the ARM template
    step by step until we have explored its core parts. We used Azure PowerShell cmdlets
    to initiate the deployment of templates on Azure.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中，我们介绍了将大型模板拆分为较小的可重用模板的最佳实践，并在运行时将它们组合在一起，以便在 Azure 上部署完整的解决方案。在书中的后续章节中，我们将逐步修改
    ARM 模板，直到探索其核心部分。我们使用了 Azure PowerShell cmdlet 来启动模板在 Azure 上的部署。
- en: Let's move on to the topic of `copy` and `copyIndex`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论 `copy` 和 `copyIndex` 的话题。
- en: Understanding copy and copyIndex
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 `copy` 和 `copyIndex`
- en: There are many times when multiple instances of a particular resource or a group
    of resources are needed. For example, you may need to provision 10 virtual machines
    of the same type. In such cases, it is not prudent to deploy templates 10 times
    to create these instances. A better alternate approach is to use the `copy` and
    `copyIndex` features of ARM templates.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况下需要多个实例的特定资源或资源组。例如，你可能需要配置 10 个相同类型的虚拟机。在这种情况下，反复部署模板来创建这些实例并不可取。更好的替代方法是使用
    ARM 模板中的 `copy` 和 `copyIndex` 功能。
- en: '`copy` is an attribute of every resource definition. This means it can be used
    to create multiple instances of any resource type.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy` 是每个资源定义的一个属性。这意味着它可以用于创建某种资源类型的多个实例。'
- en: Let's understand this with the help of an example of creating multiple storage
    accounts within a single ARM template deployment.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个在单个 ARM 模板部署中创建多个存储帐户的示例来理解这一点。
- en: 'The next code snippet creates 10 storage accounts serially. They could have
    been created in parallel by using `Parallel` instead of `Serial` for the `mode`
    property:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码片段按顺序创建了 10 个存储帐户。它们本可以通过将 `mode` 属性设置为 `Parallel` 来并行创建，而不是 `Serial`：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, `copy` has been used to provision 10 instances of the
    storage account serially, that is, one after another. The storage account names
    must be unique for all 10 instances, and `copyIndex` has been used to make them
    unique by concatenating the original storage name with the index value. The value
    returned by the `copyIndex` function changes in every iteration; it will start
    at 0 and go on for 10 iterations. This means it will return `9` for the last iteration.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`copy` 用于按顺序创建 10 个存储帐户实例，即一个接一个地创建。所有 10 个实例的存储帐户名称必须是唯一的，`copyIndex`
    被用来通过将原始存储名称与索引值连接起来使它们唯一。`copyIndex` 函数返回的值在每次迭代时都会变化；它从 0 开始，并持续 10 次迭代。这意味着它在最后一次迭代时会返回
    `9`。
- en: Now that we have learned how to create multiple instances of an ARM template,
    let's dive into securing these templates from known vulnerabilities.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何创建多个 ARM 模板实例，接下来我们将深入探讨如何保护这些模板免受已知的安全漏洞。
- en: Securing ARM templates
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护 ARM 模板
- en: Another important aspect related to creating enterprise ARM templates is securing
    them appropriately. ARM templates contain the resource configuration and vital
    information about infrastructure, and so they should not be compromised or accessible
    to unauthorized people.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 与创建企业 ARM 模板相关的另一个重要方面是对其进行适当的安全保护。ARM 模板包含资源配置和基础设施的关键信息，因此它们不应被破坏或被未经授权的人访问。
- en: The first step in securing ARM templates is storing them in storage accounts
    and stopping any anonymous access to the storage account container. Moreover,
    SAS tokens should be generated for storage accounts and used in ARM templates
    to consume linked templates. This will ensure that only the holders of SAS tokens
    can access the templates. Moreover, these SAS tokens should be stored in Azure
    Key Vault instead of being hardcoded into ARM templates. This will ensure that
    even the people responsible for deployment do not have access to the SAS token.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 保护 ARM 模板的第一步是将它们存储在存储帐户中，并停止对存储帐户容器的任何匿名访问。此外，应该为存储帐户生成 SAS 令牌，并在 ARM 模板中使用这些令牌来调用链接的模板。这将确保只有持有
    SAS 令牌的人才能访问这些模板。此外，这些 SAS 令牌应该存储在 Azure Key Vault 中，而不是硬编码到 ARM 模板中。这样可以确保即使是负责部署的人也无法访问
    SAS 令牌。
- en: Another step in securing ARM templates is ensuring that any sensitive information
    and secrets, such as database connection strings, Azure subscription and tenant
    identifiers, service principal identifiers, IP addresses, and so on, should not
    be hardcoded in ARM templates. They should all be parameterized, and the values
    should be fetched at runtime from Azure Key Vault. However, before using this
    approach, it is important that these secrets are stored in Key Vault prior to
    executing any ARM templates.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 保护 ARM 模板的另一个步骤是确保任何敏感信息和机密，如数据库连接字符串、Azure 订阅和租户标识符、服务主体标识符、IP 地址等，不应硬编码到 ARM
    模板中。它们应全部作为参数，并且值应在运行时从 Azure Key Vault 中提取。然而，在使用这种方法之前，确保这些机密已经在 Key Vault 中存储好，是非常重要的。
- en: 'The following code shows one of the ways that values can be extracted from
    Azure Key Vault at runtime using the parameters file:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了在运行时使用参数文件从 Azure Key Vault 中提取值的方式之一：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this code listing, a parameter is defined that references Azure Key Vault
    to fetch values at runtime during deployment. The Azure Key Vault identifier and
    the secret name have been provided as input values.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，定义了一个参数，用于引用 Azure Key Vault，以便在部署过程中运行时获取值。Azure Key Vault 的标识符和秘密名称已作为输入值提供。
- en: Now that you have learned how to secure ARM templates, let's take a look at
    identifying the various dependencies between them and how we can enable communication
    between multiple templates.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何保护 ARM 模板，接下来我们来看看如何识别它们之间的各种依赖关系，以及如何启用多个模板之间的通信。
- en: Using outputs between ARM templates
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 ARM 模板之间使用输出
- en: One of the important aspects that can easily be overlooked while using linked
    templates is that there might be resource dependencies within linked templates.
    For example, a SQL Server resource might be in a linked template that is different
    to that of a virtual machine resource. If we want to open the SQL Server firewall
    for the virtual machine IP address, then we should be able to dynamically pass
    this information to the SQL Server firewall resource after provisioning the virtual
    machine.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用链接模板时，一个容易被忽视的重要方面是可能会存在资源依赖性。例如，SQL Server资源可能位于与虚拟机资源不同的链接模板中。如果我们希望为虚拟机IP地址打开SQL
    Server防火墙，那么在配置虚拟机后，我们应该能够将此信息动态传递给SQL Server防火墙资源。
- en: This could be done using the simple method of referring to the IP address resource
    using the `REFERENCES` function if the SQL Server and virtual machine resources
    are in the same template.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果SQL Server和虚拟机资源在同一个模板中，可以通过使用`REFERENCES`函数简单地引用IP地址资源来实现此功能。
- en: It becomes slightly more complex in the case of linked templates if we want
    to share runtime property values from one resource to another when they are in
    different templates.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望在不同模板之间共享运行时属性值，那么在链接模板的情况下，情况会稍微复杂一些。
- en: 'ARM templates provide an `outputs` configuration, which is responsible for
    generating outputs from the current template deployment and returning them to
    the user. For example, we might output a complete object, as shown in the following
    code listing, using the `reference` function, or we might just output an IP address
    as a string value:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ARM模板提供了`outputs`配置，它负责从当前模板部署生成输出并将其返回给用户。例如，我们可以使用`reference`函数输出一个完整的对象，如下所示，或者我们也可以仅输出一个IP地址作为字符串值：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Parameters within a linked template can be utilized by the master template.
    When a linked template is called, the output is available to the master template
    that can be supplied as a parameter to the next linked or nested template. This
    way, it is possible to send the runtime configuration values of resources from
    one template to another.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 链接模板中的参数可以被主模板利用。当调用链接模板时，输出将可供主模板使用，并可以作为参数传递给下一个链接模板或嵌套模板。通过这种方式，能够将资源的运行时配置值从一个模板传递到另一个模板。
- en: 'The code in the master template would be similar to what''s shown here; this
    is the code that''s used to call the first template:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 主模板中的代码将类似于这里所展示的代码；这是用于调用第一个模板的代码：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code snippet from the master template is calling a nested template
    responsible for provisioning a virtual machine. The nested template has an output
    section that provides the IP address of the virtual machine. The master template
    will have another deployment resource in its template that will take the output
    value and send it as a parameter to the next nested template, passing the IP address
    at runtime. This is shown in the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段来自主模板，它调用了一个负责配置虚拟机的嵌套模板。该嵌套模板有一个输出部分，提供虚拟机的IP地址。主模板将在其模板中包含另一个部署资源，该资源将获取输出值并在运行时将其作为参数传递给下一个嵌套模板，从而传递IP地址。如下所示：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code listing, a nested template is being invoked and a parameter
    is being passed to it. The value of the parameter is derived from the previous
    linked template's output, which is named `virtualMachineIPAddress`. Now, the nested
    template will get the IP address of the virtual machine dynamically and it can
    use it as a whitelisted IP address.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码列表中，调用了一个嵌套模板，并且一个参数被传递给它。这个参数的值来自前一个链接模板的输出，该输出被命名为`virtualMachineIPAddress`。现在，嵌套模板将动态获取虚拟机的IP地址，并可以将其用作白名单中的IP地址。
- en: Using this approach, we can pass runtime values from one nested template to
    another.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以将运行时值从一个嵌套模板传递到另一个嵌套模板。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: ARM templates are the preferred means of provisioning resources in Azure. They
    are idempotent in nature, bringing consistency, predictability, and reusability
    to environment creation. In this chapter, we looked at how to create a modular
    ARM template. It is important for teams to spend quality time designing ARM templates
    in an appropriate way, so that multiple teams can work on them together. They
    are highly reusable and require minimal changes to evolve. In this chapter, we
    learned how to create templates that are secure by design, how to provision multiple
    resource instances in a single deployment, and how to pass outputs from one nested
    template to another using the outputs section of ARM templates.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 模板是 Azure 中首选的资源配置方式。它们具有幂等性，为环境创建带来了一致性、可预测性和可重用性。在本章中，我们探讨了如何创建一个模块化的
    ARM 模板。对于团队来说，花时间以适当的方式设计 ARM 模板非常重要，这样多个团队可以共同协作。ARM 模板具有高度的可重用性，并且只需最小的修改即可发展。在本章中，我们学习了如何创建具有安全设计的模板，如何在单次部署中配置多个资源实例，以及如何通过
    ARM 模板的 outputs 部分将输出从一个嵌套模板传递到另一个模板。
- en: The next chapter will move on to a different and very popular strand of technology
    known as serverless within Azure. Azure Functions is one of the major serverless
    resources of Azure, and this will be covered in complete depth, including Durable
    Functions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将转向 Azure 中另一种非常流行的技术——无服务器架构。Azure Functions 是 Azure 的主要无服务器资源之一，接下来我们将对其进行深入探讨，包括
    Durable Functions（持久化函数）。
