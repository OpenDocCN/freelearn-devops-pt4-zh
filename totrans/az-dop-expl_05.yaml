- en: 'Chapter 3:'
  prefs: []
  type: TYPE_NORMAL
- en: Source Control Management with Azure DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Source control management** **(SCM)** is a vital part of every company that
    develops software professionally, but also for every developer that wants to have
    a safe way to store and manage their code.'
  prefs: []
  type: TYPE_NORMAL
- en: When working in teams, it's absolutely necessary to have a safe central repository
    where all your code is stored. It's also necessary to have a system that guarantees
    that the code is safely shared between developers and that every modification
    is inspected and merged without raising conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn how Azure DevOps can help with managing source
    code professionally and securely. In this chapter, we''ll cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding source control management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branching strategies overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling source control with Azure DevOps and Repos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work with commits, pushes, and branches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with pull requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling a pull request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to tag a particular code release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned about all the concepts you
    can use to apply SCM techniques to your team using Azure DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow this chapter, you need to have an active Azure DevOps organization
    and Visual Studio or Visual Studio Code installed on your development machine.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SCM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Source control (or version control) is a software practice used to track and
    manage changes in source code. This is an extremely important practice because
    it permits to maintain a single source of code across different developers and
    helps with collaborating on a single software project (where different developers
    works on the same code base).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCM** is an essential practice in any DevOps process. To adopt a source control
    policy, you should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Select a source control management system to adopt (for example, install Git
    on a server or use a cloud-based SCM such as Azure DevOps Repos or GitHub)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store your code base in a repository managed by your source control management
    system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clone the repository locally for development by taking the latest code version
    (pull) stored in the central repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commit and push your released code to the central repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use different copies of the repository for developing in a parallel way (branches)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An SCM flow can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Source control management flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.01_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Source control management flow
  prefs: []
  type: TYPE_NORMAL
- en: Git is absolutely one of the most popular SCM systems on the market. Git was
    created in 2005 by Linus Torvalds to aid in Linux kernel development. Git is free,
    open source, and entirely file-based, so no additional software is required to
    handle SCM except the Git engine itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Git has a workflow that can be summarized as follows (and that can be represented
    using the previous diagram):'
  prefs: []
  type: TYPE_NORMAL
- en: You create a repository for your project on your Git hosting system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You copy (or clone) the repository to your local development machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You create a new file in your local repository and then you save the changes
    locally (stage and commit).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You push the changes to the remote repository (push).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You pull the changes from the remote repository to the local one (to align your
    code with the remote repository if other developers have made modifications).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You merge the changes with your local repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When using Git as an SCM system, you need to memorize some key concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Snapshots** are the way Git keeps track of your code history. A snapshot
    essentially records what all your files look like at a given point in time. You
    decide when to take a snapshot and of what files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Commit** is the act of creating a snapshot. In a project, you create different
    commits. A commit contains three sets of information:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: -- Details on how the files has changed from the previous version
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: -- A reference to the parent commit (previously occurred commit)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: -- A hash code name
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Repositories** are collections of all the necessary files and their history.
    A repository can be on a local machine or on a remote server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloning** is the act of copying a repository from a remote server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pulling** is the process of downloading commits that don''t exist on your
    machine from a remote repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pushing** is the process of adding your local changes to a remote repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`master`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A Git flow is composed of the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Git flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.02_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Git flow
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how a commit flow occurs with Git. To create a commit on Git,
    you make some changes to your files and then you use the `git add` command to
    put these files into the staging environment. After that, you use the `git commit`
    command to create a new commit. This flow can be represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Git commit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.03_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Git commit
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, these are some Git commands you can use to activate the previously
    described SCM process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone a remote repository locally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Work on your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save your work locally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check if there are any updates from the remote server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save your work to the remote server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To work with branches, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new branch and switch to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Work on the new features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save your work locally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save your work to the remote server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Switch to the branch where you want to merge your work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Merge `branch1` into the `master` branch and save it to the remote server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once you've mastered these commands, you'll be ready to start using Git. In
    the next section, we'll provides an overview of branches and the possible branching
    strategies you can use.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring branching strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A branch is a version of your code stored in an SCM system. When using SCM with
    Git, choosing the best branching strategy to adopt for your team is crucial because
    it helps you have a reliable code base and fast delivery.
  prefs: []
  type: TYPE_NORMAL
- en: 'With SCM, if you''re not using branching, you always have a single version
    of your code (`master` branch) and you always commit to this branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – One flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.04_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – One flow
  prefs: []
  type: TYPE_NORMAL
- en: This "one flow" way of work is not recommended because it cannot guarantee that
    the `master` branch is stable, especially if you have more than one developer
    working on the same code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different branching workflows (strategies) that you can adopt for
    your team, and the recommendation that normally I suggest is to start simple.
    With Git, there are three main branching strategies that you can adopt:'
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitLab Flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git Flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we'll explore each of these strategies.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**GitHub Flow** is one of the most widely used branching strategies and is
    quite simple to adopt.'
  prefs: []
  type: TYPE_NORMAL
- en: 'According to this workflow, you start from a `master` branch (which always
    contains the deployable code). When you start developing a new feature, you create
    a new branch and you commit regularly to this new branch. When the development
    work has been completed, you create a pull request to merge the secondary branch
    with the `master` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – GitHub Flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.05_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – GitHub Flow
  prefs: []
  type: TYPE_NORMAL
- en: This workflow is simple to adopt and good if you need to maintain a single version
    of your code in production. The only disadvantages are that you need to carefully
    check what you commit to the `master` branch. This is not recommended if you need
    to have multiple versions of your application in production.
  prefs: []
  type: TYPE_NORMAL
- en: GitLab Flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**GitLab Flow** is another popular branching strategy that''s widely used,
    especially when you need to support multiple environments (such as production,
    staging, development, and so on) in your SCM process. The following diagram represents
    this flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – GitLab Flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.06_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – GitLab Flow
  prefs: []
  type: TYPE_NORMAL
- en: 'According to this workflow, you should have at least three branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Master**: This is everyone''s local version of the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Staging**: This is the branch where the *master* branch is branched into
    for testing purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Production**: This is the released production code (where *staging* is merged).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is useful if you want to maintain a stable production release, work separately
    on new features that can be moved to a testing environment (in order to be tested),
    and then merge that environment into the production release when testing has been
    completed.
  prefs: []
  type: TYPE_NORMAL
- en: Git Flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Git Flow** is a workflow that''s used when you have a scheduled release cycle.
    The following diagram represents this flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Git Flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.07_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – Git Flow
  prefs: []
  type: TYPE_NORMAL
- en: According to this workflow, you have a **master** branch and a **develop** branch
    that are always live, and then some other branches that are not always live (can
    be deleted). The **master** branch contains the released code, while the **develop**
    branch contains the code that you're working on.
  prefs: []
  type: TYPE_NORMAL
- en: Every time you add a new feature to your code base, you create a **feature**
    branch, starting from the **develop** branch, and then you merge the **feature**
    branch into **develop** when the implementation is finished. Here, you never merge
    into the **master** branch.
  prefs: []
  type: TYPE_NORMAL
- en: When you need to release a set of features, you create a release branch, starting
    from the **develop** branch. Code in the **release** branch must be tested (maybe
    with bug fixes merged in) and then when you're ready to release the code, you
    merge the **release** branch into the **master** branch and then into the **develop**
    branch.
  prefs: []
  type: TYPE_NORMAL
- en: If a serious bug occurs in production, this flow says that you can create a
    **fix** branch from the **master**, fix the bug, and then merge this branch into
    **master** again directly. You can also merge it into the **release** branch if
    it's present, or into **develop** otherwise. If you have merged the code into
    the **release** branch, the **develop** branch will have the fix when you merge
    the **release** branch.
  prefs: []
  type: TYPE_NORMAL
- en: Handling source control with Azure DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Azure DevOps** supports the following source control management types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Git**: This is a distributed version control system and is the default version
    control provider in Azure DevOps when you create a new project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Team Foundation Version Control (TFVC)**: This is a centralized version control
    system where developers have only one version of a file locally, data is stored
    on a server, and branches are created on the server (path-based).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first step when working with Azure DevOps is to create a new project inside
    your organization. When you create a new project with Azure DevOps, you''re prompted
    to choose the version control system you want to use (shown in the red box in
    the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Create new project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.08_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – Create new project
  prefs: []
  type: TYPE_NORMAL
- en: By clicking the **OK** button, the new project will be created in your Azure
    DevOps organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the project has been provisioned, you can manage your repositories by
    going to the **Repos** hub on the left bar in Azure DevOps (see the following
    screenshot). This is where your files will be stored and where you can start creating
    repositories and managing branches, pull requests, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Repos'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.09_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – Repos
  prefs: []
  type: TYPE_NORMAL
- en: Starting from **Repos**, every developer can clone a repository locally and
    work directly from Visual Studio or Visual Studio Code while being connected to
    Azure DevOps in order to push code modifications, pull and create branches, make
    commits, and start pull requests.
  prefs: []
  type: TYPE_NORMAL
- en: When you start a new project from scratch, Azure DevOps creates an empty repository
    for you. You can load your code into this repository manually (via upload) or
    you can clone from a remote repository (for example, GitHub) to Azure DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a single project, you can create different repositories and each can have
    its own set of permissions, branches, and commits. To create a new repository,
    just select the **Repos** hub and click on **New repository**, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – New repository'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.10_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – New repository
  prefs: []
  type: TYPE_NORMAL
- en: A repository can be renamed or deleted easily from Azure DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to create a new project in Azure DevOps and
    how to create code repositories for your project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll learn how to manage a complete source code management
    flow with Azure DevOps, from cloning a remote repository to committing code on
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning a remote repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To show you how to work with a code repository in Azure DevOps, I will start
    from a project where I have my web application source code stored in a Git repository
    in Azure DevOps. The following screenshot shows the code hosted remotely in the
    **master** branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Master branch'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.11_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – Master branch
  prefs: []
  type: TYPE_NORMAL
- en: 'Every developer that must work with this code has to clone this repository
    locally. To do that, you can click on the **Clone** button, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Cloning the repository'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.12_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – Cloning the repository
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, you''ll see a window that shows you the clone repository''s URL.
    You can clone this repository by using the `git clone <Repository URL>` command
    or directly in Visual Studio or Visual Studio Code by using one of the options
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Cloning options'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.13_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – Cloning options
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I''m cloning the project to Visual Studio Code. Azure DevOps prompts
    me to select a folder where I will save the project (local folder on your development
    machine), then opens Visual Studio Code and starts cloning the remote repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Cloning in Visual Studio Code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.14_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.14 – Cloning in Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: 'In Visual Studio Code, you can also clone a repository by going to the Command
    Palette (*Ctrl* + *Shift* + *P*), selecting the `Git:Clone` command, and then
    pasting the repository URL into the URL window that will be prompted to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – The Git:Clone command'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.15_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15 – The Git:Clone command
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the cloning process has finished, you will have a local copy of the `master`
    branch of the remote repository in the selected folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – Local copy of the remote repository'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.16_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.16 – Local copy of the remote repository
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to work with remote repositories on Azure DevOps with Visual Studio
    Code more efficiently, I recommend that you install an extension (from the Visual
    Studio Code Marketplace) called **Azure Repos**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – Azure Repos extension'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.17_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.17 – Azure Repos extension
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Azure Repos has been installed, if you go to the Command Palette and search
    for the word `teams`, you will see a new set of available commands to interact
    with in Azure DevOps, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18 – Azure Repos commands'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.18_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.18 – Azure Repos commands
  prefs: []
  type: TYPE_NORMAL
- en: We'll use some of these commands later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll learn how to import a GitHub repository into Azure
    DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Importing a GitHub repository into Azure DevOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With Azure DevOps, you can also import a GitHub repository inside **Repos**.
    If you select an empty repository that you''ve created in an Azure DevOps project,
    you''ll have the option to import a repository, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.19 – Import a repository'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.19_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.19 – Import a repository
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can select the GitHub repository to import (by entering the source
    type and the GitHub repository''s cloning URL):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.20 – Import a Git repository'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.20_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.20 – Import a Git repository
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click the **Import** button, the remote GitHub repository import process
    will start and you will see an image showing its progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.21 – Processing the import repository request'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.21_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.21 – Processing the import repository request
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the import process has finished, you''ll have the code available in Azure
    Repos. Please remember that when importing a repository from GitHub, the history
    and revision information is also imported into Azure DevOps for complete traceability:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.22 – History of the imported repository'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.22_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.22 – History of the imported repository
  prefs: []
  type: TYPE_NORMAL
- en: Working with commits, pushes, and branches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you've cloned the remote repository to your local Git repository, you can
    start coding (create new files or modify new files).
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time you create or change a file, Git records the changes in the local
    repository. You''ll see the Visual Studio Code source control icon start signaling
    that a file has been modified. In the following screenshot, for example, I''ve
    added a comment to a file in my project. After saving this file, the Git engine
    says that I have an uncommitted file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.23 – Uncommitted file alert'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.23_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.23 – Uncommitted file alert
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on the **Source Control** icon in the left bar, you will see the
    uncommitted file. From here, you can select the changes that you want to commit
    and stage them. Every commit is done locally. You can stage a modification by
    clicking the **+** icon and then perform a commit of all your staged files by
    clicking the **Commit** button in the top toolbar. Every commit must have a message
    that explains the reason for this commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.24 – Commit message'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.24_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.24 – Commit message
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the files are locally committed into your local `master` branch (although
    it''s not recommended to do this, as explained later). To sync these modifications
    to the online repository in Azure DevOps, you can click the **Synchronize Changes**
    button on the bottom bar in Visual Studio Code (this visually indicates that you
    have some modifications that must be pushed online), as highlighted in red in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.25 – Modifications to be pushed online'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.25_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.25 – Modifications to be pushed online
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can select the `Git` `:` `push` command from the command
    bar, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.26 – The Git:Push command'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.26_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.26 – The Git:Push command
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all the code modifications have been pushed online to the `master` branch.
    If you go to Azure DevOps in the **Repos** hub and select the **Commits** menu,
    you will see the history of every commit for the selected branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.27 – Commit history'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.27_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.27 – Commit history
  prefs: []
  type: TYPE_NORMAL
- en: In this way, we're directly working on the `master` branch. This is not how
    you work in a real team of developers because if every developer commits directly
    to the `master` branch, you cannot guarantee that this branch will be always stable.
    The best way to work is by using the previously explained GitHub Flow. So, you
    should create a new branch, work on this newly created branch, and only when the
    work is finished should you create a `pull` request to merge your branch to the
    `master` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a new branch in Azure DevOps or directly from Visual Studio
    Code. To create a new branch, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From Azure DevOps, select **Branches** and then click on **New branch**:![Figure
    3.28 – New branch
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.28_B16392.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.28 – New branch
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, provide a branch name. You need to select the branch that your new branch
    will be created from, as shown in the following screenshot:![Figure 3.29 – Create
    a branch
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.29_B16392.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.29 – Create a branch
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To create a new branch directly from Visual Studio Code, just click on the
    branch name on the bottom bar and select **Create new branch…**:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.30 – Create new branch… option in Visual Studio Code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_3.30_B16392.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.30 – Create new branch… option in Visual Studio Code
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, select the name for the new branch (here, it's called `development`):![Figure
    1.31 – Assigning a branch name
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.31_B16392.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 1.31 – Assigning a branch name
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With that, the branch will be created in your local repository and Visual Studio
    Code will automatically start working on it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.32 – Working on the new branch'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_3.32_B16392.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.32 – Working on the new branch
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, you can work on your code (maybe for developing a new set of features)
    and make commits on this new branch without affecting the `master` branch (it
    will continue to have the actually released version of your code base).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As an example, here, I have added a new modification to the `MedicineController.cs`
    file. I can stage and commit the modification on the `development` branch locally:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.33 – Staging changes'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_3.33_B16392.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.33 – Staging changes
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, I can push these modifications to the remote repository on Azure DevOps.
    When pushed online, if this is the first time the **development** branch is being
    created, you will receive a message that looks as follows:![Figure 3.34 – Automatic
    branch creation and publishing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.34_B16392.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.34 – Automatic branch creation and publishing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When finished, the **development** branch will be created on the remote repository
    and your code will be pushed online:![Figure 3.35 – Branch created on the remote
    repository
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.35_B16392.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.35 – Branch created on the remote repository
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you go to the **Commits** section in the **Repos** hub in Azure DevOps,
    you will see the history of your commits. By selecting a specific commit, you
    can view the file changes that were made (by comparing the previous version to
    the current version after the specific commit):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.36 – Details of a commit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.36_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.36 – Details of a commit
  prefs: []
  type: TYPE_NORMAL
- en: 'This action can also be done directly from Visual Studio Code with the `Team:View
    History` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.37 – The Team:View History command from Visual Studio Code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.37_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.37 – The Team:View History command from Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: 'A branch can be deleted (manually or automatically after a pull request), restored
    from accidental deletion, and also be locked (in order to be placed in a read-only
    state or to avoid new commits on this branch affecting a merging that is in place).
    To lock a particular branch, just select the branch from Azure DevOps and then,
    from the menu, select the **Lock** option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.38 – Locking a branch'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.38_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.38 – Locking a branch
  prefs: []
  type: TYPE_NORMAL
- en: To unlock a locked branch, just select the **Unlock** action. It's important
    to note that locking a branch does not prevent cloning or fetching this branch
    locally.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting branches with policies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with different developers and when using branches, it is extremely
    important to protect the critical branches you have in your repository (such as
    the `master` branch) with rules that can guarantee that the branch will always
    be in a healthy state.
  prefs: []
  type: TYPE_NORMAL
- en: For this scope, Azure DevOps permits you to specify a set of policies for your
    critical branches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Branch policies in Azure DevOps permit you to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Limit the contributors to a specific branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify who can create branches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify a set of naming conventions for branches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically include code reviewers for every code change in the branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforce the use of pull requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start a build pipeline before committing the code to the branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To specify the branch policies for a particular branch, go to the **Branch**
    section in Azure DevOps, select your branch, and then select the **Branch policies**
    menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.39 – Branch policies'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.39_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.39 – Branch policies
  prefs: []
  type: TYPE_NORMAL
- en: Here, you have a set of options that you can set to control your selected branch.
    We'll look at each of these options in detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Require a minimum number of reviewers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This option allows you to specify the number of reviewers that can approve
    a code modification. If any reviewer rejects the code changes, the modifications
    are not approved, and the code changes are discarded. If you select **Allow completion
    even if some reviewers vote to wait or reject**, then the pull request can be
    completed. The **Requestors can approve their own changes** option enables the
    creator of a pull request to approve its own code changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.40 – Require a minimum number of reviewers option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.40_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.40 – Require a minimum number of reviewers option
  prefs: []
  type: TYPE_NORMAL
- en: Check for linked work items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This option allows you to require the associations of work items to a specific
    pull request for the complete traceability of activities and tasks. This is useful
    if you''re using the project planning features (as shown in [*Chapter 2*](B16392_02_Final_JM_ePub.xhtml#_idTextAnchor059)*,
    Managing Projects with Azure DevOps Boards*, of this book):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.41 – Check for linked work items option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.41_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.41 – Check for linked work items option
  prefs: []
  type: TYPE_NORMAL
- en: Check for comment resolution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This option allows you to specify a rule where all comments must be resolved
    so that the pull request can be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.42 – Check for comment resolution option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.42_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.42 – Check for comment resolution option
  prefs: []
  type: TYPE_NORMAL
- en: Limit merge types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This option allows you to enforce a branch strategy when a pull request is
    completed. The available options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic merge (no fast-forward)**: This option merges the commit history of
    the source branch and creates a merge commit in the target branch. The complete
    non-linear history of commits that occurs during development is preserved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Squash merge**: This creates a single commit in the target branch by compressing
    the source branch commits (linear history).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`master` branch. Each commit on the pull request is merged into the target
    branch individually (linear history).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rebase with merge commit**: This creates a semi-linear history by replacing
    the source branch commits in the target branch and then creating a merge commit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these options can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.43 – Limit merge types option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.43_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.43 – Limit merge types option
  prefs: []
  type: TYPE_NORMAL
- en: Build validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This section allows you to specify a set of rules for building your code before
    the pull request can be completed (useful for catching problems early). Upon clicking
    **Add build policy**, a new panel appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.44 – Add build policy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.44_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.44 – Add build policy
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can specify what build pipeline definition you wish to apply and if
    it must be triggered automatically when the branch is updated or manually. We'll
    talk about build pipelines in detail in [*Chapter 4*](B16392_04_Final_JM_ePub.xhtml#_idTextAnchor096)*,
    Understanding Azure DevOps Pipelines*.
  prefs: []
  type: TYPE_NORMAL
- en: Require approval from additional services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This option allows you to connect external services (via Azure DevOps pull
    request APIs) in order to participate in the pull request flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.45 – Add status policy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.45_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.45 – Add status policy
  prefs: []
  type: TYPE_NORMAL
- en: Automatically include code reviewers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This policy allows you to include specific users or groups in the code review
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.46 – Add automatic reviewers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.46_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.46 – Add automatic reviewers
  prefs: []
  type: TYPE_NORMAL
- en: Cross-repo policies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of defining a policy for each branch you create manually, Azure DevOps
    allows you to define cross-repository policies (which will be automatically applied
    to all the branches that you create for your project).
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a policy that will be valid for each repository you''ll create, you
    need to go to **Project settings** and then select **Cross-repo policies**, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.47 – Cross-repo policies'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.47_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.47 – Cross-repo policies
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, you can add a branch protection policy and select one of these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`master` branch of each repo).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protect current and future branches matching a specified pattern**. Here,
    you can define a pattern for filtering branches and the policy will be applied
    to all the branches that apply to this pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, if you want to define a policy that will be automatically applied
    to all the branches you create for your project, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.48 – Add branch protection'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.48_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.48 – Add branch protection
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, here, we have selected the *** key as a pattern to identify
    all the branches in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Working with pull requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Pull requests** allow you to notify your team members that a new implementation
    has been completed and must be merged with a specified branch. By using pull requests,
    members of your team can review your code (by stepping through files and see the
    modifications that a particular commit introduces), provide review comments on
    minor issues, and approve or reject those modifications. This is the recommended
    practice to use when using source control management with Azure DevOps.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view the incoming pull requests for a specific repository on Azure
    DevOps by selecting the **Pull requests** menu from the **Repos** hub, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.49 – Pull requests view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.49_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.49 – Pull requests view
  prefs: []
  type: TYPE_NORMAL
- en: You can also filter this list to view only your pull requests or only the **Active**,
    **Completed**, or **Abandoned** pull requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'A pull request can be created in different ways, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Manually from the Azure DevOps pull request page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From a work item linked to a branch (the **Development** tab)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you push an update to a feature branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From Visual Studio Code or Visual Studio directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the Azure DevOps Services CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we'll learn how to start pull requests in each of
    these situations.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a pull request from the Azure DevOps pull request page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can create a new pull request directly from the Azure DevOps **Pull requests**
    menu (in the **Repos** hub). From here, just click on the **New pull request**
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.50 – New pull request'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.50_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.50 – New pull request
  prefs: []
  type: TYPE_NORMAL
- en: You can now enter details about the pull request you wish to create (we'll look
    at this later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a pull request from a work item
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the **Backlogs** view of your team''s work items, you can select a work
    item with a linked branch (a work item with a commit associated with a branch),
    go to the **Development** area of the selected work item, and create a **Create
    pull request** action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.51 – Creating a pull request from a work item'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.51_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.51 – Creating a pull request from a work item
  prefs: []
  type: TYPE_NORMAL
- en: Creating a pull request after pushing a branch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you commit code to a `development` (secondary) branch to Azure DevOps,
    you''re automatically prompted to create a pull request (you can see this prompt
    by going to the **Files** or **Pull requests** menu in the **Repos** hub). As
    you may recall, I previously committed a new code into a branch called **development**
    to Azure DevOps. Now, if we go to the **Files** | **History** section, we will
    see that there''s a prompt for creating a new pull request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.52 – Creating a pull request after a commit on a branch'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.52_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.52 – Creating a pull request after a commit on a branch
  prefs: []
  type: TYPE_NORMAL
- en: Creating a pull request from Visual Studio Code or Visual Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can start a pull request directly from Visual Studio Code or Visual Studio
    from where your project has been loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start a pull request from Visual Studio Code, launch the `Team:Create pull
    request` command from the Command Palette (*Ctrl* + *Shift* + *P*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.53 – Creating a pull request from Visual Studio Code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.53_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.53 – Creating a pull request from Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: This will prompt you to open Azure DevOps. After confirming this, the pull request
    window will open.
  prefs: []
  type: TYPE_NORMAL
- en: 'From Visual Studio, select the **Team Explorer** panel. From here, you can
    click on **Pull Requests** to start a pull request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.54 – Creating a pull request from Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.54_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.54 – Creating a pull request from Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: Handling a pull request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the different ways to handle a pull request that we''ve described converge
    to a unique point: in Azure DevOps, the **Pull requests** window opens, and you
    need to fill in the details of your pull request activity. As an example, this
    is the pull request that we started after the previous commit on the **development**
    branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.55 – New pull request window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.55_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.55 – New pull request window
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can immediately see that the pull request merges a branch into another
    branch (in my case, **development** will be merged into **master**). You need
    to provide a title and a description of this pull request (that clearly describes
    the changes and the implementations you made in the merge), as well as attach
    links and add team members (users or groups) that will be responsible for reviewing
    this pull request. You can also include work items (this option will be automatically
    included if you completed a commit attached to a work item previously).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Files** section, you can see what this pull request will do in the
    destination branch (for every file). As an example, this is what my pull request
    shows me:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.56 – Code modifications view in a pull request'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.56_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.56 – Code modifications view in a pull request
  prefs: []
  type: TYPE_NORMAL
- en: On the left, you can see that the file committed in the `master` branch, while
    on the right, you can see the same file after the merging phase (with the details
    of every modification applied).
  prefs: []
  type: TYPE_NORMAL
- en: If you've specified some reviewers, they will see the details of the code modifications,
    which means they can add comments and interact with the developers.
  prefs: []
  type: TYPE_NORMAL
- en: To create the pull request process, simply click the **Create** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the pull request has been created, you can complete the pull request by
    clicking on the **Complete** button in the top-right corner of the pull request
    window (you can do this after the optional approval phase and after passing the
    branch rules):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.57 – Completing a pull request'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.57_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.57 – Completing a pull request
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Complete** the pull request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mark as draft**: This is like a "work in progress". If a pull request is
    marked as a draft, required reviewers are not automatically added, voting is not
    permitted, and build policies (if activated) are not automatically executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abandon**: The pull request will be closed, and your code will not be merged.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you click on **Complete**, you''ll be prompted to fill in the **Complete
    pull request** window, which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.58 – Complete pull request'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.58_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.58 – Complete pull request
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can insert a title and a description for the merge operation, select
    the merge type to apply, and select the post-completion operation to apply (if
    the associated work items should be marked as completed after merging and if the
    source branch must be deleted after the merge operation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the type of merge operation to apply, you can choose from the following
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Merge (no fast-forward)**: Non-linear history preserving all commits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Squash commit**: Linear history with only a single commit on the target'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rebase and fast-forward**: Rebase source commits on a target and fast-forward'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Semi-linear merge**: Rebase source commits on a target and create a two-parent
    merge'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure DevOps gives you a nice animated graph to show the final result of the
    merge. To complete the pull request, click on **Complete merge**. You need to
    resolve any merge conflicts if something happens. With this, the merging phase
    starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.59 – Completing the pull request.](img/Figure_3.59_B16392.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.59 – Completing the pull request.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have an automatic build policy on the target branch (the `master` branch
    here), the build pipeline is executed and then the merge operation is completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.60 – Pull request completed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.60_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.60 – Pull request completed
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll learn how to use tags on branches to immediately
    identify the status of the code inside the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Tagging a release
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Git Tags** are references that point to specific points in the **Git** history.
    **Tags** are used in Azure DevOps for marking a particular release (or branch)
    with an identifier that will be shared internally in your team to identify, for
    example, the "version" of your code base.'
  prefs: []
  type: TYPE_NORMAL
- en: As an example, in the previous section, we merged the `development` branch into
    the `master` branch by using a `master` branch contains our latest release of
    the code, which we're now ready to share internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use tags for your branches, in the **Repos** hub in Azure DevOps, go to
    the **Tags** menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.61 – Tags'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.61_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.61 – Tags
  prefs: []
  type: TYPE_NORMAL
- en: From here, you can create a tag for this release by going to **Tags** and clicking
    on **New Tag**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you''re prompted to insert a tag name (an identifier that cannot contain
    spaces), provide a description for this tag, and select the branch that the tag
    will be applied to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.62 – Create a tag'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.62_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.62 – Create a tag
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on **Create**, the tag will be applied to your branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.63 – Tag applied to a branch'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.63_B16392.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.63 – Tag applied to a branch
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to handle source control management with Azure
    DevOps and why it's so important when working in teams when developing code.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at the basic concepts of source control management and Git, the possible
    strategies to apply when merging code, how to use Azure DevOps to apply SCM, and
    how to handle repositories, commits, branches, and pull requests from Azure DevOps
    and development tools such as Visual Studio Code and Visual Studio. We also learned
    how to apply better policies to control the source code releases in order to improve
    the SCM life cycle, how to protect branches and how to use tags for a branch.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn how to create build pipelines with Azure DevOps
    for implementing CI/CD practices.
  prefs: []
  type: TYPE_NORMAL
