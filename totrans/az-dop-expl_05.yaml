- en: 'Chapter 3:'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: Source Control Management with Azure DevOps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Source control management** **(SCM)** is a vital part of every company that
    develops software professionally, but also for every developer that wants to have
    a safe way to store and manage their code.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: When working in teams, it's absolutely necessary to have a safe central repository
    where all your code is stored. It's also necessary to have a system that guarantees
    that the code is safely shared between developers and that every modification
    is inspected and merged without raising conflicts.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn how Azure DevOps can help with managing source
    code professionally and securely. In this chapter, we''ll cover the following
    topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Understanding source control management
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branching strategies overview
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling source control with Azure DevOps and Repos
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work with commits, pushes, and branches
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with pull requests
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling a pull request
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to tag a particular code release
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned about all the concepts you
    can use to apply SCM techniques to your team using Azure DevOps.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow this chapter, you need to have an active Azure DevOps organization
    and Visual Studio or Visual Studio Code installed on your development machine.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SCM
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Source control (or version control) is a software practice used to track and
    manage changes in source code. This is an extremely important practice because
    it permits to maintain a single source of code across different developers and
    helps with collaborating on a single software project (where different developers
    works on the same code base).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '**SCM** is an essential practice in any DevOps process. To adopt a source control
    policy, you should do the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Select a source control management system to adopt (for example, install Git
    on a server or use a cloud-based SCM such as Azure DevOps Repos or GitHub)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store your code base in a repository managed by your source control management
    system
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clone the repository locally for development by taking the latest code version
    (pull) stored in the central repository
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commit and push your released code to the central repository
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use different copies of the repository for developing in a parallel way (branches)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An SCM flow can be seen in the following diagram:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Source control management flow'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.01_B16392.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Source control management flow
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Git is absolutely one of the most popular SCM systems on the market. Git was
    created in 2005 by Linus Torvalds to aid in Linux kernel development. Git is free,
    open source, and entirely file-based, so no additional software is required to
    handle SCM except the Git engine itself.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Git has a workflow that can be summarized as follows (and that can be represented
    using the previous diagram):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: You create a repository for your project on your Git hosting system.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You copy (or clone) the repository to your local development machine.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You create a new file in your local repository and then you save the changes
    locally (stage and commit).
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在本地仓库中创建一个新文件，然后将更改保存在本地（暂存并提交）。
- en: You push the changes to the remote repository (push).
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将更改推送到远程仓库（push）。
- en: You pull the changes from the remote repository to the local one (to align your
    code with the remote repository if other developers have made modifications).
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你从远程仓库拉取更改到本地仓库（以便将代码与远程仓库同步，如果其他开发者做了修改的话）。
- en: You merge the changes with your local repository.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将更改与本地仓库合并。
- en: 'When using Git as an SCM system, you need to memorize some key concepts:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Git 作为 SCM 系统时，你需要记住一些关键概念：
- en: '**Snapshots** are the way Git keeps track of your code history. A snapshot
    essentially records what all your files look like at a given point in time. You
    decide when to take a snapshot and of what files.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快照**是 Git 用来跟踪代码历史的方式。快照本质上记录了在某一时刻所有文件的样子。你决定何时以及对哪些文件进行快照。'
- en: '**Commit** is the act of creating a snapshot. In a project, you create different
    commits. A commit contains three sets of information:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提交**是创建快照的行为。在一个项目中，你会创建不同的提交。一个提交包含三组信息：'
- en: -- Details on how the files has changed from the previous version
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: -- 详细描述文件如何从之前的版本发生变化
- en: -- A reference to the parent commit (previously occurred commit)
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: -- 指向父提交的引用（之前发生的提交）
- en: -- A hash code name
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: -- 一个哈希代码名称
- en: '**Repositories** are collections of all the necessary files and their history.
    A repository can be on a local machine or on a remote server.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仓库**是所有必要文件及其历史记录的集合。仓库可以位于本地计算机或远程服务器上。'
- en: '**Cloning** is the act of copying a repository from a remote server.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**克隆**是从远程服务器复制仓库的操作。'
- en: '**Pulling** is the process of downloading commits that don''t exist on your
    machine from a remote repository.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拉取**是从远程仓库下载本地没有的提交的过程。'
- en: '**Pushing** is the process of adding your local changes to a remote repository.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推送**是将本地更改添加到远程仓库的过程。'
- en: '`master`.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`master`。'
- en: 'A Git flow is composed of the following actions:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Git 流程由以下操作组成：
- en: '![Figure 3.2 – Git flow'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.2 – Git 流程'
- en: '](img/Figure_3.02_B16392.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.02_B16392.jpg)'
- en: Figure 3.2 – Git flow
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – Git 流程
- en: 'Let''s look at how a commit flow occurs with Git. To create a commit on Git,
    you make some changes to your files and then you use the `git add` command to
    put these files into the staging environment. After that, you use the `git commit`
    command to create a new commit. This flow can be represented as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 Git 中如何发生提交流。要在 Git 上创建一个提交，你需要对文件进行一些更改，然后使用 `git add` 命令将这些文件放入暂存环境。之后，使用
    `git commit` 命令创建一个新的提交。这个流程可以表示如下：
- en: '![Figure 3.3 – Git commit'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.3 – Git 提交'
- en: '](img/Figure_3.03_B16392.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.03_B16392.jpg)'
- en: Figure 3.3 – Git commit
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – Git 提交
- en: 'As an example, these are some Git commands you can use to activate the previously
    described SCM process:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，这里是一些你可以使用的 Git 命令来激活前述 SCM 流程：
- en: 'Clone a remote repository locally:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆远程仓库到本地：
- en: '[PRE0]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Work on your project.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续进行项目开发。
- en: 'Save your work locally:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将工作保存在本地：
- en: '[PRE1]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Check if there are any updates from the remote server:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查远程服务器是否有更新：
- en: '[PRE2]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Save your work to the remote server:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将工作保存到远程服务器：
- en: '[PRE3]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To work with branches, follow these steps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分支时，请遵循以下步骤：
- en: 'Create a new branch and switch to it:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新分支并切换到该分支：
- en: '[PRE4]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Work on the new features.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发新功能。
- en: 'Save your work locally:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将工作保存在本地：
- en: '[PRE5]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Save your work to the remote server:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将工作保存到远程服务器：
- en: '[PRE6]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Switch to the branch where you want to merge your work:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到你想要合并工作的分支：
- en: '[PRE7]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Merge `branch1` into the `master` branch and save it to the remote server:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `branch1` 合并到 `master` 分支并将其保存到远程服务器：
- en: '[PRE8]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once you've mastered these commands, you'll be ready to start using Git. In
    the next section, we'll provides an overview of branches and the possible branching
    strategies you can use.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你掌握了这些命令，你就可以开始使用 Git。在接下来的部分中，我们将概述分支和你可以使用的分支策略。
- en: Exploring branching strategies
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索分支策略
- en: A branch is a version of your code stored in an SCM system. When using SCM with
    Git, choosing the best branching strategy to adopt for your team is crucial because
    it helps you have a reliable code base and fast delivery.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 分支是存储在 SCM 系统中的代码版本。在使用 Git 的 SCM 系统时，选择最适合你团队的分支策略至关重要，因为它有助于你保持可靠的代码库和快速交付。
- en: 'With SCM, if you''re not using branching, you always have a single version
    of your code (`master` branch) and you always commit to this branch:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用SCM时，如果你没有使用分支管理，你将始终只有一个版本的代码（`master`分支），并且你总是向这个分支提交代码：
- en: '![Figure 3.4 – One flow'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 – 单一工作流'
- en: '](img/Figure_3.04_B16392.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.04_B16392.jpg)'
- en: Figure 3.4 – One flow
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 单一工作流
- en: This "one flow" way of work is not recommended because it cannot guarantee that
    the `master` branch is stable, especially if you have more than one developer
    working on the same code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“单一工作流”方式不推荐使用，因为它无法保证`master`分支的稳定性，特别是当多个开发人员在同一代码上工作时。
- en: 'There are different branching workflows (strategies) that you can adopt for
    your team, and the recommendation that normally I suggest is to start simple.
    With Git, there are three main branching strategies that you can adopt:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的分支工作流（策略），你可以为团队选择采用，通常我建议从简单的策略开始。在Git中，你可以采用三种主要的分支策略：
- en: GitHub Flow
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub流
- en: GitLab Flow
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitLab Flow
- en: Git Flow
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git Flow
- en: In the following sections, we'll explore each of these strategies.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨这些策略的每一个。
- en: GitHub Flow
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub流
- en: '**GitHub Flow** is one of the most widely used branching strategies and is
    quite simple to adopt.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**GitHub Flow** 是最广泛使用的分支策略之一，并且相对容易采用。'
- en: 'According to this workflow, you start from a `master` branch (which always
    contains the deployable code). When you start developing a new feature, you create
    a new branch and you commit regularly to this new branch. When the development
    work has been completed, you create a pull request to merge the secondary branch
    with the `master` branch:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 根据此工作流程，你从`master`分支开始（该分支始终包含可部署的代码）。当你开始开发新功能时，你会创建一个新的分支，并定期向此分支提交代码。当开发工作完成时，你会创建一个pull请求，将该子分支与`master`分支合并：
- en: '![Figure 3.5 – GitHub Flow'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.5 – GitHub Flow'
- en: '](img/Figure_3.05_B16392.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.05_B16392.jpg)'
- en: Figure 3.5 – GitHub Flow
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – GitHub Flow
- en: This workflow is simple to adopt and good if you need to maintain a single version
    of your code in production. The only disadvantages are that you need to carefully
    check what you commit to the `master` branch. This is not recommended if you need
    to have multiple versions of your application in production.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工作流简单易于采用，适用于你需要在生产环境中维护单一版本的代码。唯一的缺点是你需要仔细检查提交到`master`分支的内容。如果你需要在生产环境中维护多个版本的应用程序，通常不推荐使用这种方式。
- en: GitLab Flow
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitLab流
- en: '**GitLab Flow** is another popular branching strategy that''s widely used,
    especially when you need to support multiple environments (such as production,
    staging, development, and so on) in your SCM process. The following diagram represents
    this flow:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**GitLab Flow** 是另一种流行的分支策略，广泛应用，尤其是在你需要支持多个环境（例如生产、预发布、开发等）时，特别适用于SCM流程。以下图示表示该工作流：'
- en: '![Figure 3.6 – GitLab Flow'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.6 – GitLab Flow'
- en: '](img/Figure_3.06_B16392.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.06_B16392.jpg)'
- en: Figure 3.6 – GitLab Flow
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – GitLab Flow
- en: 'According to this workflow, you should have at least three branches:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 根据此工作流程，你应该至少有三个分支：
- en: '**Master**: This is everyone''s local version of the code.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主分支**：这是每个人的本地版本代码。'
- en: '**Staging**: This is the branch where the *master* branch is branched into
    for testing purposes.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预发布**：这是用于测试目的的分支，*master*分支会被分叉到这里。'
- en: '**Production**: This is the released production code (where *staging* is merged).'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产**：这是已发布的生产代码（*预发布*已经合并到这里）。'
- en: This is useful if you want to maintain a stable production release, work separately
    on new features that can be moved to a testing environment (in order to be tested),
    and then merge that environment into the production release when testing has been
    completed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想保持稳定的生产发布，并分别在新功能上工作（这些功能可以移至测试环境进行测试），然后在测试完成后将该环境合并到生产发布中，这种工作流非常有用。
- en: Git Flow
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git Flow
- en: '**Git Flow** is a workflow that''s used when you have a scheduled release cycle.
    The following diagram represents this flow:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**Git Flow** 是一种用于有定期发布周期的工作流。以下图示表示该工作流：'
- en: '![Figure 3.7 – Git Flow'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.7 – Git Flow'
- en: '](img/Figure_3.07_B16392.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.07_B16392.jpg)'
- en: Figure 3.7 – Git Flow
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – Git Flow
- en: According to this workflow, you have a **master** branch and a **develop** branch
    that are always live, and then some other branches that are not always live (can
    be deleted). The **master** branch contains the released code, while the **develop**
    branch contains the code that you're working on.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 根据此工作流程，你有一个**master**分支和一个**develop**分支，它们始终处于活动状态，另外一些分支并非总是处于活动状态（可以删除）。**master**分支包含已发布的代码，而**develop**分支包含你正在开发的代码。
- en: Every time you add a new feature to your code base, you create a **feature**
    branch, starting from the **develop** branch, and then you merge the **feature**
    branch into **develop** when the implementation is finished. Here, you never merge
    into the **master** branch.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每次向你的代码库添加新功能时，你会从**develop**分支创建一个**feature**分支，然后当实现完成时，将**feature**分支合并到**develop**。在这里，你永远不会合并到**master**分支。
- en: When you need to release a set of features, you create a release branch, starting
    from the **develop** branch. Code in the **release** branch must be tested (maybe
    with bug fixes merged in) and then when you're ready to release the code, you
    merge the **release** branch into the **master** branch and then into the **develop**
    branch.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要发布一组功能时，你会从**develop**分支创建一个发布分支。**release**分支中的代码必须经过测试（可能包含合并的 bug 修复），当你准备好发布代码时，你将**release**分支合并到**master**分支，然后再合并到**develop**分支。
- en: If a serious bug occurs in production, this flow says that you can create a
    **fix** branch from the **master**, fix the bug, and then merge this branch into
    **master** again directly. You can also merge it into the **release** branch if
    it's present, or into **develop** otherwise. If you have merged the code into
    the **release** branch, the **develop** branch will have the fix when you merge
    the **release** branch.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在生产中出现严重 bug，此流程建议你可以从**master**分支创建一个**fix**分支，修复 bug，然后直接将此分支合并回**master**。如果存在**release**分支，你也可以将其合并到**release**分支，否则合并到**develop**分支。如果你将代码合并到**release**分支，当你将**release**分支合并回**develop**分支时，**develop**分支将包含修复。
- en: Handling source control with Azure DevOps
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 Azure DevOps 中的源代码控制
- en: '**Azure DevOps** supports the following source control management types:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**Azure DevOps** 支持以下源代码管理类型：'
- en: '**Git**: This is a distributed version control system and is the default version
    control provider in Azure DevOps when you create a new project.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Git**：这是一个分布式版本控制系统，在创建新项目时是 Azure DevOps 的默认版本控制提供程序。'
- en: '**Team Foundation Version Control (TFVC)**: This is a centralized version control
    system where developers have only one version of a file locally, data is stored
    on a server, and branches are created on the server (path-based).'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Team Foundation Version Control (TFVC)**：这是一个集中式版本控制系统，在这里开发者本地只有一个文件版本，数据存储在服务器上，并且分支是在服务器上创建的（基于路径）。'
- en: 'The first step when working with Azure DevOps is to create a new project inside
    your organization. When you create a new project with Azure DevOps, you''re prompted
    to choose the version control system you want to use (shown in the red box in
    the following screenshot):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Azure DevOps 的第一步是在你的组织内创建一个新项目。当你使用 Azure DevOps 创建新项目时，系统会提示你选择要使用的版本控制系统（如下截图中的红框所示）：
- en: '![Figure 3.8 – Create new project'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.8 – 创建新项目'
- en: '](img/Figure_3.08_B16392.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.08_B16392.jpg](img/Figure_3.08_B16392.jpg)'
- en: Figure 3.8 – Create new project
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 创建新项目
- en: By clicking the **OK** button, the new project will be created in your Azure
    DevOps organization.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**按钮，新项目将在你的 Azure DevOps 组织中创建。
- en: 'Once the project has been provisioned, you can manage your repositories by
    going to the **Repos** hub on the left bar in Azure DevOps (see the following
    screenshot). This is where your files will be stored and where you can start creating
    repositories and managing branches, pull requests, and so on:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 项目创建完成后，你可以通过进入 Azure DevOps 左侧导航栏中的**仓库**中心来管理你的存储库（见下面的截图）。这里是你的文件存储位置，你可以开始创建存储库并管理分支、拉取请求等等：
- en: '![Figure 3.9 – Repos'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.9 – Repos'
- en: '](img/Figure_3.09_B16392.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.09_B16392.jpg](img/Figure_3.09_B16392.jpg)'
- en: Figure 3.9 – Repos
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 仓库
- en: Starting from **Repos**, every developer can clone a repository locally and
    work directly from Visual Studio or Visual Studio Code while being connected to
    Azure DevOps in order to push code modifications, pull and create branches, make
    commits, and start pull requests.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从**仓库**开始，每个开发者都可以在本地克隆存储库，并直接从 Visual Studio 或 Visual Studio Code 进行工作，同时连接到
    Azure DevOps，以便推送代码修改、拉取和创建分支、进行提交，并发起拉取请求。
- en: When you start a new project from scratch, Azure DevOps creates an empty repository
    for you. You can load your code into this repository manually (via upload) or
    you can clone from a remote repository (for example, GitHub) to Azure DevOps.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从头开始启动一个新项目时，Azure DevOps 会为你创建一个空的存储库。你可以手动将代码加载到这个存储库中（通过上传），或者你可以从远程存储库（例如
    GitHub）克隆到 Azure DevOps。
- en: 'In a single project, you can create different repositories and each can have
    its own set of permissions, branches, and commits. To create a new repository,
    just select the **Repos** hub and click on **New repository**, as shown in the
    following screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – New repository'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.10_B16392.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – New repository
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: A repository can be renamed or deleted easily from Azure DevOps.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to create a new project in Azure DevOps and
    how to create code repositories for your project.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll learn how to manage a complete source code management
    flow with Azure DevOps, from cloning a remote repository to committing code on
    it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Cloning a remote repository
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To show you how to work with a code repository in Azure DevOps, I will start
    from a project where I have my web application source code stored in a Git repository
    in Azure DevOps. The following screenshot shows the code hosted remotely in the
    **master** branch:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Master branch'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.11_B16392.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – Master branch
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Every developer that must work with this code has to clone this repository
    locally. To do that, you can click on the **Clone** button, as shown in the following
    screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Cloning the repository'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.12_B16392.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – Cloning the repository
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, you''ll see a window that shows you the clone repository''s URL.
    You can clone this repository by using the `git clone <Repository URL>` command
    or directly in Visual Studio or Visual Studio Code by using one of the options
    shown in the following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Cloning options'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.13_B16392.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – Cloning options
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I''m cloning the project to Visual Studio Code. Azure DevOps prompts
    me to select a folder where I will save the project (local folder on your development
    machine), then opens Visual Studio Code and starts cloning the remote repository:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Cloning in Visual Studio Code'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.14_B16392.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.14 – Cloning in Visual Studio Code
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'In Visual Studio Code, you can also clone a repository by going to the Command
    Palette (*Ctrl* + *Shift* + *P*), selecting the `Git:Clone` command, and then
    pasting the repository URL into the URL window that will be prompted to you:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – The Git:Clone command'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.15_B16392.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15 – The Git:Clone command
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the cloning process has finished, you will have a local copy of the `master`
    branch of the remote repository in the selected folder:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – Local copy of the remote repository'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.16_B16392.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.16 – Local copy of the remote repository
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to work with remote repositories on Azure DevOps with Visual Studio
    Code more efficiently, I recommend that you install an extension (from the Visual
    Studio Code Marketplace) called **Azure Repos**:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – Azure Repos extension'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.17_B16392.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.17 – Azure Repos extension
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Azure Repos has been installed, if you go to the Command Palette and search
    for the word `teams`, you will see a new set of available commands to interact
    with in Azure DevOps, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Azure Repos 安装完成，如果你进入命令面板并搜索 `teams`，你将看到一组新的可用命令来与 Azure DevOps 进行交互，如下所示：
- en: '![Figure 3.18 – Azure Repos commands'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.18 – Azure Repos 命令'
- en: '](img/Figure_3.18_B16392.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.18_B16392.jpg)'
- en: Figure 3.18 – Azure Repos commands
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.18 – Azure Repos 命令
- en: We'll use some of these commands later in this chapter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后续部分，我们将使用其中的一些命令。
- en: In the next section, we'll learn how to import a GitHub repository into Azure
    DevOps.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何将 GitHub 仓库导入到 Azure DevOps。
- en: Importing a GitHub repository into Azure DevOps
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 GitHub 仓库导入到 Azure DevOps
- en: 'With Azure DevOps, you can also import a GitHub repository inside **Repos**.
    If you select an empty repository that you''ve created in an Azure DevOps project,
    you''ll have the option to import a repository, as shown in the following screenshot:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Azure DevOps，你还可以在 **Repos** 中导入 GitHub 仓库。如果你选择了一个在 Azure DevOps 项目中创建的空仓库，你将可以看到导入仓库的选项，如以下截图所示：
- en: '![Figure 1.19 – Import a repository'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.19 – 导入一个仓库'
- en: '](img/Figure_3.19_B16392.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.19_B16392.jpg)'
- en: Figure 1.19 – Import a repository
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.19 – 导入一个仓库
- en: 'Here, you can select the GitHub repository to import (by entering the source
    type and the GitHub repository''s cloning URL):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以选择要导入的 GitHub 仓库（通过输入源类型和 GitHub 仓库的克隆 URL）：
- en: '![Figure 1.20 – Import a Git repository'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.20 – 导入 Git 仓库'
- en: '](img/Figure_3.20_B16392.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.20_B16392.jpg)'
- en: Figure 1.20 – Import a Git repository
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.20 – 导入 Git 仓库
- en: 'When you click the **Import** button, the remote GitHub repository import process
    will start and you will see an image showing its progress:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击 **导入** 按钮时，远程 GitHub 仓库的导入过程将开始，你将看到显示进度的图像：
- en: '![Figure 3.21 – Processing the import repository request'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.21 – 正在处理导入仓库请求'
- en: '](img/Figure_3.21_B16392.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.21_B16392.jpg)'
- en: Figure 3.21 – Processing the import repository request
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.21 – 正在处理导入仓库请求
- en: 'Once the import process has finished, you''ll have the code available in Azure
    Repos. Please remember that when importing a repository from GitHub, the history
    and revision information is also imported into Azure DevOps for complete traceability:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦导入过程完成，你将在 Azure Repos 中获得代码。请记住，当从 GitHub 导入仓库时，历史记录和修订信息也会被导入到 Azure DevOps
    中，以实现完整的可追溯性：
- en: '![Figure 3.22 – History of the imported repository'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.22 – 导入的仓库历史'
- en: '](img/Figure_3.22_B16392.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.22_B16392.jpg)'
- en: Figure 3.22 – History of the imported repository
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.22 – 导入的仓库历史
- en: Working with commits, pushes, and branches
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用提交、推送和分支
- en: Once you've cloned the remote repository to your local Git repository, you can
    start coding (create new files or modify new files).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将远程仓库克隆到本地 Git 仓库，你就可以开始编码（创建新文件或修改现有文件）。
- en: 'Every time you create or change a file, Git records the changes in the local
    repository. You''ll see the Visual Studio Code source control icon start signaling
    that a file has been modified. In the following screenshot, for example, I''ve
    added a comment to a file in my project. After saving this file, the Git engine
    says that I have an uncommitted file:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你创建或修改一个文件时，Git 会记录本地仓库中的更改。你会看到 Visual Studio Code 的源代码控制图标开始提示文件已被修改。例如，在下面的截图中，我向项目中的一个文件添加了评论。保存文件后，Git
    引擎会提示我有一个未提交的文件：
- en: '![Figure 3.23 – Uncommitted file alert'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.23 – 未提交文件警告'
- en: '](img/Figure_3.23_B16392.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.23_B16392.jpg)'
- en: Figure 3.23 – Uncommitted file alert
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.23 – 未提交文件警告
- en: 'If you click on the **Source Control** icon in the left bar, you will see the
    uncommitted file. From here, you can select the changes that you want to commit
    and stage them. Every commit is done locally. You can stage a modification by
    clicking the **+** icon and then perform a commit of all your staged files by
    clicking the **Commit** button in the top toolbar. Every commit must have a message
    that explains the reason for this commit:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击左侧栏中的 **源代码控制** 图标，你将看到未提交的文件。在这里，你可以选择你想提交的更改并将其暂存。每次提交都是在本地进行的。你可以通过点击
    **+** 图标来暂存修改，然后通过点击顶部工具栏中的 **提交** 按钮来提交所有暂存的文件。每次提交都必须有一条信息，解释这次提交的原因：
- en: '![Figure 3.24 – Commit message'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.24 – 提交信息'
- en: '](img/Figure_3.24_B16392.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.24_B16392.jpg)'
- en: Figure 3.24 – Commit message
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.24 – 提交信息
- en: 'Now, the files are locally committed into your local `master` branch (although
    it''s not recommended to do this, as explained later). To sync these modifications
    to the online repository in Azure DevOps, you can click the **Synchronize Changes**
    button on the bottom bar in Visual Studio Code (this visually indicates that you
    have some modifications that must be pushed online), as highlighted in red in
    the following screenshot:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，文件已经本地提交到你的本地 `master` 分支（虽然不推荐这样做，稍后会解释）。要将这些修改同步到 Azure DevOps 中的线上仓库，你可以点击
    Visual Studio Code 底部栏上的 **Synchronize Changes** 按钮（这会以红色高亮显示，表明你有需要推送到线上的修改），如下图所示：
- en: '![Figure 3.25 – Modifications to be pushed online'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.25 – 需要推送到线上修改'
- en: '](img/Figure_3.25_B16392.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.25_B16392.jpg)'
- en: Figure 3.25 – Modifications to be pushed online
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.25 – 需要推送到线上修改
- en: 'Alternatively, you can select the `Git` `:` `push` command from the command
    bar, as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以从命令栏选择 `Git` `:` `push` 命令，如下所示：
- en: '![Figure 3.26 – The Git:Push command'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.26 – Git:Push 命令'
- en: '](img/Figure_3.26_B16392.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.26_B16392.jpg)'
- en: Figure 3.26 – The Git:Push command
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.26 – Git:Push 命令
- en: 'Now, all the code modifications have been pushed online to the `master` branch.
    If you go to Azure DevOps in the **Repos** hub and select the **Commits** menu,
    you will see the history of every commit for the selected branch:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有代码修改都已经推送到 `master` 分支。如果你进入 Azure DevOps 的 **Repos** 中心并选择 **Commits**
    菜单，你将看到所选分支的每一次提交历史：
- en: '![Figure 3.27 – Commit history'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.27 – 提交历史'
- en: '](img/Figure_3.27_B16392.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.27_B16392.jpg)'
- en: Figure 3.27 – Commit history
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.27 – 提交历史
- en: In this way, we're directly working on the `master` branch. This is not how
    you work in a real team of developers because if every developer commits directly
    to the `master` branch, you cannot guarantee that this branch will be always stable.
    The best way to work is by using the previously explained GitHub Flow. So, you
    should create a new branch, work on this newly created branch, and only when the
    work is finished should you create a `pull` request to merge your branch to the
    `master` branch.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们直接在 `master` 分支上工作。这不是实际开发团队中常用的工作方式，因为如果每个开发者都直接提交到 `master` 分支，就无法保证该分支始终稳定。最好的做法是使用之前提到的
    GitHub Flow。因此，你应该创建一个新分支，在这个新分支上工作，只有在工作完成后，才创建一个 `pull` 请求将分支合并到 `master` 分支。
- en: 'You can create a new branch in Azure DevOps or directly from Visual Studio
    Code. To create a new branch, follow these steps:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Azure DevOps 中或直接在 Visual Studio Code 中创建新分支。创建新分支的步骤如下：
- en: From Azure DevOps, select **Branches** and then click on **New branch**:![Figure
    3.28 – New branch
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Azure DevOps 中选择 **Branches**，然后点击 **New branch**：![图 3.28 – 新分支
- en: '](img/Figure_3.28_B16392.jpg)'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_3.28_B16392.jpg)'
- en: Figure 3.28 – New branch
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.28 – 新分支
- en: Then, provide a branch name. You need to select the branch that your new branch
    will be created from, as shown in the following screenshot:![Figure 3.29 – Create
    a branch
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，提供一个分支名称。你需要选择新分支将从哪个分支创建，如下图所示：![图 3.29 – 创建分支
- en: '](img/Figure_3.29_B16392.jpg)'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_3.29_B16392.jpg)'
- en: Figure 3.29 – Create a branch
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.29 – 创建分支
- en: 'To create a new branch directly from Visual Studio Code, just click on the
    branch name on the bottom bar and select **Create new branch…**:'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要直接从 Visual Studio Code 创建新分支，只需点击底部栏上的分支名称，然后选择 **Create new branch…**：
- en: '![Figure 3.30 – Create new branch… option in Visual Studio Code'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.30 – 在 Visual Studio Code 中创建新分支…选项'
- en: '](img/Figure_3.30_B16392.jpg)'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_3.30_B16392.jpg)'
- en: Figure 3.30 – Create new branch… option in Visual Studio Code
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.30 – 在 Visual Studio Code 中创建新分支…选项
- en: Now, select the name for the new branch (here, it's called `development`):![Figure
    1.31 – Assigning a branch name
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择新分支的名称（这里称为 `development`）：![图 1.31 – 分配分支名称
- en: '](img/Figure_3.31_B16392.jpg)'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_3.31_B16392.jpg)'
- en: Figure 1.31 – Assigning a branch name
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.31 – 分配分支名称
- en: 'With that, the branch will be created in your local repository and Visual Studio
    Code will automatically start working on it:'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样，分支将被创建在本地仓库中，Visual Studio Code 将自动开始在该分支上工作：
- en: '![Figure 3.32 – Working on the new branch'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.32 – 在新分支上工作'
- en: '](img/Figure_3.32_B16392.jpg)'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_3.32_B16392.jpg)'
- en: Figure 3.32 – Working on the new branch
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.32 – 在新分支上工作
- en: Now, you can work on your code (maybe for developing a new set of features)
    and make commits on this new branch without affecting the `master` branch (it
    will continue to have the actually released version of your code base).
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以在此新分支上继续进行代码开发（可能是为了开发一组新的功能），并进行提交，而不会影响 `master` 分支（它将继续保持代码库的实际发布版本）。
- en: 'As an example, here, I have added a new modification to the `MedicineController.cs`
    file. I can stage and commit the modification on the `development` branch locally:'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，在这里，我已向 `MedicineController.cs` 文件添加了一个新的修改。我可以在本地对 `development` 分支进行暂存和提交此修改：
- en: '![Figure 3.33 – Staging changes'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.33 – 暂存更改'
- en: '](img/Figure_3.33_B16392.jpg)'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_3.33_B16392.jpg)'
- en: Figure 3.33 – Staging changes
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.33 – 暂存更改
- en: Then, I can push these modifications to the remote repository on Azure DevOps.
    When pushed online, if this is the first time the **development** branch is being
    created, you will receive a message that looks as follows:![Figure 3.34 – Automatic
    branch creation and publishing
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我可以将这些修改推送到 Azure DevOps 上的远程仓库。当在线推送时，如果这是第一次创建 **development** 分支，您将收到如下消息：![图
    3.34 – 自动分支创建和发布
- en: '](img/Figure_3.34_B16392.jpg)'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_3.34_B16392.jpg)'
- en: Figure 3.34 – Automatic branch creation and publishing
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.34 – 自动分支创建和发布
- en: When finished, the **development** branch will be created on the remote repository
    and your code will be pushed online:![Figure 3.35 – Branch created on the remote
    repository
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，**development** 分支将在远程仓库中创建，并且您的代码将被推送到线上：![图 3.35 – 在远程仓库上创建的分支
- en: '](img/Figure_3.35_B16392.jpg)'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_3.35_B16392.jpg)'
- en: Figure 3.35 – Branch created on the remote repository
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.35 – 在远程仓库上创建的分支
- en: 'If you go to the **Commits** section in the **Repos** hub in Azure DevOps,
    you will see the history of your commits. By selecting a specific commit, you
    can view the file changes that were made (by comparing the previous version to
    the current version after the specific commit):'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在 Azure DevOps 中的 **Repos** 中进入 **Commits** 部分，您将看到提交历史记录。通过选择特定的提交，您可以查看所做的文件更改（通过将之前的版本与该提交后的当前版本进行比较）：
- en: '![Figure 3.36 – Details of a commit'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.36 – 提交的详细信息'
- en: '](img/Figure_3.36_B16392.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.36_B16392.jpg)'
- en: Figure 3.36 – Details of a commit
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.36 – 提交的详细信息
- en: 'This action can also be done directly from Visual Studio Code with the `Team:View
    History` command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作也可以通过 Visual Studio Code 中的 `Team:View History` 命令直接完成：
- en: '![Figure 3.37 – The Team:View History command from Visual Studio Code'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.37 – 来自 Visual Studio Code 的 Team:View History 命令'
- en: '](img/Figure_3.37_B16392.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.37_B16392.jpg)'
- en: Figure 3.37 – The Team:View History command from Visual Studio Code
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.37 – 来自 Visual Studio Code 的 Team:View History 命令
- en: 'A branch can be deleted (manually or automatically after a pull request), restored
    from accidental deletion, and also be locked (in order to be placed in a read-only
    state or to avoid new commits on this branch affecting a merging that is in place).
    To lock a particular branch, just select the branch from Azure DevOps and then,
    from the menu, select the **Lock** option:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 分支可以被删除（手动删除或在拉取请求后自动删除）、从意外删除中恢复，还可以被锁定（使其进入只读状态，或防止此分支上的新提交影响当前合并）。要锁定特定分支，只需在
    Azure DevOps 中选择该分支，然后从菜单中选择 **Lock** 选项：
- en: '![Figure 3.38 – Locking a branch'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.38 – 锁定分支'
- en: '](img/Figure_3.38_B16392.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.38_B16392.jpg)'
- en: Figure 3.38 – Locking a branch
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.38 – 锁定分支
- en: To unlock a locked branch, just select the **Unlock** action. It's important
    to note that locking a branch does not prevent cloning or fetching this branch
    locally.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要解锁已锁定的分支，只需选择 **Unlock** 操作。需要注意的是，锁定分支并不妨碍克隆或拉取此分支到本地。
- en: Protecting branches with policies
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过策略保护分支
- en: When working with different developers and when using branches, it is extremely
    important to protect the critical branches you have in your repository (such as
    the `master` branch) with rules that can guarantee that the branch will always
    be in a healthy state.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在与不同的开发人员协作并使用分支时，保护仓库中关键的分支（例如 `master` 分支）非常重要，可以通过规则确保这些分支始终保持健康状态。
- en: For this scope, Azure DevOps permits you to specify a set of policies for your
    critical branches.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个范围，Azure DevOps 允许您为关键分支指定一组策略。
- en: 'Branch policies in Azure DevOps permit you to do the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Azure DevOps 中的分支策略允许您执行以下操作：
- en: Limit the contributors to a specific branch
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制特定分支的贡献者
- en: Specify who can create branches
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定谁可以创建分支
- en: Specify a set of naming conventions for branches
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为分支指定一组命名约定
- en: Automatically include code reviewers for every code change in the branch
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动为分支中的每个代码更改包括代码审阅者
- en: Enforce the use of pull requests
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制使用拉取请求
- en: Start a build pipeline before committing the code to the branch
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在提交代码到分支之前启动构建管道
- en: 'To specify the branch policies for a particular branch, go to the **Branch**
    section in Azure DevOps, select your branch, and then select the **Branch policies**
    menu:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要为特定分支指定分支策略，请转到 Azure DevOps 中的**分支**部分，选择您的分支，然后选择**分支策略**菜单：
- en: '![Figure 3.39 – Branch policies'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.39 – 分支策略'
- en: '](img/Figure_3.39_B16392.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.39_B16392.jpg)'
- en: Figure 3.39 – Branch policies
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.39 – 分支策略
- en: Here, you have a set of options that you can set to control your selected branch.
    We'll look at each of these options in detail in the following sections.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以设置一组选项来控制所选分支。我们将在以下部分详细查看这些选项。
- en: Require a minimum number of reviewers
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 要求最少审阅者数量
- en: 'This option allows you to specify the number of reviewers that can approve
    a code modification. If any reviewer rejects the code changes, the modifications
    are not approved, and the code changes are discarded. If you select **Allow completion
    even if some reviewers vote to wait or reject**, then the pull request can be
    completed. The **Requestors can approve their own changes** option enables the
    creator of a pull request to approve its own code changes:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 该选项允许您指定可以批准代码修改的审阅者数量。如果任何审阅者拒绝代码更改，则修改不会被批准，且代码更改会被丢弃。如果选择**允许即使一些审阅者选择等待或拒绝也可以完成**，那么拉取请求可以完成。**请求者可以批准自己的更改**选项允许拉取请求的创建者批准自己的代码更改：
- en: '![Figure 3.40 – Require a minimum number of reviewers option'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.40 – 要求最少审阅者数量选项'
- en: '](img/Figure_3.40_B16392.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.40_B16392.jpg)'
- en: Figure 3.40 – Require a minimum number of reviewers option
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.40 – 要求最少审阅者数量选项
- en: Check for linked work items
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查关联的工作项
- en: 'This option allows you to require the associations of work items to a specific
    pull request for the complete traceability of activities and tasks. This is useful
    if you''re using the project planning features (as shown in [*Chapter 2*](B16392_02_Final_JM_ePub.xhtml#_idTextAnchor059)*,
    Managing Projects with Azure DevOps Boards*, of this book):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 该选项允许您要求将工作项与特定拉取请求关联，以便实现活动和任务的完整可追溯性。如果您使用的是项目规划功能（如本书中的[*第 2 章*](B16392_02_Final_JM_ePub.xhtml#_idTextAnchor059)《使用
    Azure DevOps Boards 管理项目》所示），这将非常有用：
- en: '![Figure 3.41 – Check for linked work items option'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.41 – 检查关联的工作项选项'
- en: '](img/Figure_3.41_B16392.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.41_B16392.jpg)'
- en: Figure 3.41 – Check for linked work items option
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.41 – 检查关联的工作项选项
- en: Check for comment resolution
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查评论解决情况
- en: 'This option allows you to specify a rule where all comments must be resolved
    so that the pull request can be performed:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 该选项允许您指定一条规则，要求所有评论必须解决，才能执行拉取请求：
- en: '![Figure 3.42 – Check for comment resolution option'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.42 – 检查评论解决选项'
- en: '](img/Figure_3.42_B16392.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.42_B16392.jpg)'
- en: Figure 3.42 – Check for comment resolution option
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.42 – 检查评论解决选项
- en: Limit merge types
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制合并类型
- en: 'This option allows you to enforce a branch strategy when a pull request is
    completed. The available options are as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 该选项允许您在完成拉取请求时强制执行分支策略。可用的选项如下：
- en: '**Basic merge (no fast-forward)**: This option merges the commit history of
    the source branch and creates a merge commit in the target branch. The complete
    non-linear history of commits that occurs during development is preserved.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本合并（无快速转发）**：此选项合并源分支的提交历史，并在目标分支中创建一个合并提交。开发过程中发生的完整非线性提交历史将被保留。'
- en: '**Squash merge**: This creates a single commit in the target branch by compressing
    the source branch commits (linear history).'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Squash合并**：通过压缩源分支的提交（线性历史），在目标分支中创建一个单一提交。'
- en: '`master` branch. Each commit on the pull request is merged into the target
    branch individually (linear history).'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`master` 分支。拉取请求中的每个提交都将单独合并到目标分支中（线性历史）。'
- en: '**Rebase with merge commit**: This creates a semi-linear history by replacing
    the source branch commits in the target branch and then creating a merge commit.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用合并提交的变基**：通过将源分支的提交替换为目标分支中的提交，然后创建合并提交，从而创建半线性历史。'
- en: 'All these options can be seen in the following screenshot:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些选项可以在以下屏幕截图中查看：
- en: '![Figure 3.43 – Limit merge types option'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.43 – 限制合并类型选项'
- en: '](img/Figure_3.43_B16392.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.43_B16392.jpg)'
- en: Figure 3.43 – Limit merge types option
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.43 – 限制合并类型选项
- en: Build validation
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建验证
- en: 'This section allows you to specify a set of rules for building your code before
    the pull request can be completed (useful for catching problems early). Upon clicking
    **Add build policy**, a new panel appears:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 本节允许您为构建代码指定一组规则，在拉取请求完成之前（有助于及早发现问题）。点击 **添加构建策略** 后，将出现一个新面板：
- en: '![Figure 3.44 – Add build policy'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.44 – 添加构建策略'
- en: '](img/Figure_3.44_B16392.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.44_B16392.jpg)'
- en: Figure 3.44 – Add build policy
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.44 – 添加构建策略
- en: Here, you can specify what build pipeline definition you wish to apply and if
    it must be triggered automatically when the branch is updated or manually. We'll
    talk about build pipelines in detail in [*Chapter 4*](B16392_04_Final_JM_ePub.xhtml#_idTextAnchor096)*,
    Understanding Azure DevOps Pipelines*.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以指定要应用的构建管道定义，以及它是否必须在分支更新时自动触发，或者手动触发。我们将在 [*第 4 章*](B16392_04_Final_JM_ePub.xhtml#_idTextAnchor096)*，理解
    Azure DevOps Pipelines* 中详细讨论构建管道。
- en: Require approval from additional services
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 需要额外服务的批准
- en: 'This option allows you to connect external services (via Azure DevOps pull
    request APIs) in order to participate in the pull request flow:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 该选项允许您连接外部服务（通过 Azure DevOps 拉取请求 API），以便参与拉取请求流程：
- en: '![Figure 3.45 – Add status policy'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.45 – 添加状态策略'
- en: '](img/Figure_3.45_B16392.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.45_B16392.jpg)'
- en: Figure 3.45 – Add status policy
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.45 – 添加状态策略
- en: Automatically include code reviewers
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动包含代码审查者
- en: 'This policy allows you to include specific users or groups in the code review
    process:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 此策略允许您将特定用户或组包含在代码审查过程中：
- en: '![Figure 3.46 – Add automatic reviewers'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.46 – 添加自动审查者'
- en: '](img/Figure_3.46_B16392.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.46_B16392.jpg)'
- en: Figure 3.46 – Add automatic reviewers
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.46 – 添加自动审查者
- en: Cross-repo policies
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨仓库策略
- en: Instead of defining a policy for each branch you create manually, Azure DevOps
    allows you to define cross-repository policies (which will be automatically applied
    to all the branches that you create for your project).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 不必为每个您手动创建的分支定义一个策略，Azure DevOps 允许您定义跨仓库策略（这些策略将自动应用于您为项目创建的所有分支）。
- en: 'To define a policy that will be valid for each repository you''ll create, you
    need to go to **Project settings** and then select **Cross-repo policies**, as
    shown in the following screenshot:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个适用于您将创建的每个仓库的策略，您需要进入 **项目设置**，然后选择 **跨仓库策略**，如下面的截图所示：
- en: '![Figure 3.47 – Cross-repo policies'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.47 – 跨仓库策略'
- en: '](img/Figure_3.47_B16392.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.47_B16392.jpg)'
- en: Figure 3.47 – Cross-repo policies
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.47 – 跨仓库策略
- en: 'From here, you can add a branch protection policy and select one of these options:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以添加一个分支保护策略并选择以下选项之一：
- en: '`master` branch of each repo).'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`master` 分支的每个仓库）。'
- en: '**Protect current and future branches matching a specified pattern**. Here,
    you can define a pattern for filtering branches and the policy will be applied
    to all the branches that apply to this pattern.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保护当前和未来匹配指定模式的分支**。在这里，您可以定义一个过滤分支的模式，策略将应用于所有符合该模式的分支。'
- en: 'As an example, if you want to define a policy that will be automatically applied
    to all the branches you create for your project, do the following:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，如果您想定义一个策略，该策略将自动应用于您为项目创建的所有分支，请按以下步骤操作：
- en: '![Figure 3.48 – Add branch protection'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.48 – 添加分支保护'
- en: '](img/Figure_3.48_B16392.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.48_B16392.jpg)'
- en: Figure 3.48 – Add branch protection
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.48 – 添加分支保护
- en: As you can see, here, we have selected the *** key as a pattern to identify
    all the branches in our project.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这里，我们选择了 *** key 作为模式来识别我们项目中的所有分支。
- en: Working with pull requests
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用拉取请求
- en: '**Pull requests** allow you to notify your team members that a new implementation
    has been completed and must be merged with a specified branch. By using pull requests,
    members of your team can review your code (by stepping through files and see the
    modifications that a particular commit introduces), provide review comments on
    minor issues, and approve or reject those modifications. This is the recommended
    practice to use when using source control management with Azure DevOps.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**拉取请求** 允许您通知团队成员，表明一个新实现已完成并必须与指定的分支合并。通过使用拉取请求，团队成员可以审查您的代码（逐步查看文件并查看特定提交所做的修改），对小问题提供审查评论，并批准或拒绝这些修改。这是使用
    Azure DevOps 进行源代码管理时推荐的做法。'
- en: 'You can view the incoming pull requests for a specific repository on Azure
    DevOps by selecting the **Pull requests** menu from the **Repos** hub, as shown
    in the following screenshot:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过选择 **Repos** 中心的 **拉取请求** 菜单，查看 Azure DevOps 中特定仓库的所有传入拉取请求，如下图所示：
- en: '![Figure 3.49 – Pull requests view'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.49 – 拉取请求视图'
- en: '](img/Figure_3.49_B16392.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.49_B16392.jpg)'
- en: Figure 3.49 – Pull requests view
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.49 – 拉取请求视图
- en: You can also filter this list to view only your pull requests or only the **Active**,
    **Completed**, or **Abandoned** pull requests.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以筛选此列表，仅查看你的拉取请求，或仅查看 **Active**、**Completed** 或 **Abandoned** 状态的拉取请求。
- en: 'A pull request can be created in different ways, as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取请求可以通过以下几种方式创建：
- en: Manually from the Azure DevOps pull request page
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动从 Azure DevOps 拉取请求页面创建
- en: From a work item linked to a branch (the **Development** tab)
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从与分支关联的工作项（**开发**标签）
- en: When you push an update to a feature branch
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你向功能分支推送更新时
- en: From Visual Studio Code or Visual Studio directly
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Visual Studio Code 或 Visual Studio 直接启动
- en: From the Azure DevOps Services CLI
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Azure DevOps Services CLI 启动
- en: In the following sections, we'll learn how to start pull requests in each of
    these situations.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习如何在这些情况下启动拉取请求。
- en: Creating a pull request from the Azure DevOps pull request page
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Azure DevOps 拉取请求页面创建拉取请求
- en: 'You can create a new pull request directly from the Azure DevOps **Pull requests**
    menu (in the **Repos** hub). From here, just click on the **New pull request**
    button:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接从 Azure DevOps **拉取请求**菜单（位于 **Repos** 中心）创建一个新的拉取请求。在这里，只需点击 **新建拉取请求**
    按钮：
- en: '![Figure 3.50 – New pull request'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.50 – 新建拉取请求'
- en: '](img/Figure_3.50_B16392.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.50_B16392.jpg)'
- en: Figure 3.50 – New pull request
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.50 – 新建拉取请求
- en: You can now enter details about the pull request you wish to create (we'll look
    at this later in this chapter).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以输入关于你希望创建的拉取请求的详细信息（我们将在本章后面讨论这一部分）。
- en: Creating a pull request from a work item
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从工作项创建拉取请求
- en: 'From the **Backlogs** view of your team''s work items, you can select a work
    item with a linked branch (a work item with a commit associated with a branch),
    go to the **Development** area of the selected work item, and create a **Create
    pull request** action:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在你团队的工作项 **待办事项** 视图中，你可以选择一个与分支关联的工作项（一个与分支提交关联的工作项），进入所选工作项的 **开发** 区域，并创建一个
    **创建拉取请求** 操作：
- en: '![Figure 3.51 – Creating a pull request from a work item'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.51 – 从工作项创建拉取请求'
- en: '](img/Figure_3.51_B16392.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.51_B16392.jpg)'
- en: Figure 3.51 – Creating a pull request from a work item
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.51 – 从工作项创建拉取请求
- en: Creating a pull request after pushing a branch
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在推送分支后创建拉取请求
- en: 'When you commit code to a `development` (secondary) branch to Azure DevOps,
    you''re automatically prompted to create a pull request (you can see this prompt
    by going to the **Files** or **Pull requests** menu in the **Repos** hub). As
    you may recall, I previously committed a new code into a branch called **development**
    to Azure DevOps. Now, if we go to the **Files** | **History** section, we will
    see that there''s a prompt for creating a new pull request:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将代码提交到 Azure DevOps 的 `development`（次级）分支时，系统会自动提示你创建一个拉取请求（你可以通过转到 **文件**
    或 **拉取请求** 菜单，在 **Repos** 中心查看此提示）。如你所知，我之前将新代码提交到了名为 **development** 的分支。现在，如果我们进入
    **文件** | **历史记录** 部分，我们会看到创建新拉取请求的提示：
- en: '![Figure 3.52 – Creating a pull request after a commit on a branch'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.52 – 在分支上提交后创建拉取请求'
- en: '](img/Figure_3.52_B16392.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.52_B16392.jpg)'
- en: Figure 3.52 – Creating a pull request after a commit on a branch
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.52 – 在分支上提交后创建拉取请求
- en: Creating a pull request from Visual Studio Code or Visual Studio
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Visual Studio Code 或 Visual Studio 创建拉取请求
- en: You can start a pull request directly from Visual Studio Code or Visual Studio
    from where your project has been loaded.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接从 Visual Studio Code 或 Visual Studio 启动拉取请求，只要你的项目已经加载。
- en: 'To start a pull request from Visual Studio Code, launch the `Team:Create pull
    request` command from the Command Palette (*Ctrl* + *Shift* + *P*):'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Visual Studio Code 启动拉取请求，请从命令面板中启动 `Team:Create pull request` 命令（*Ctrl*
    + *Shift* + *P*）：
- en: '![Figure 3.53 – Creating a pull request from Visual Studio Code'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.53 – 从 Visual Studio Code 创建拉取请求'
- en: '](img/Figure_3.53_B16392.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.53_B16392.jpg)'
- en: Figure 3.53 – Creating a pull request from Visual Studio Code
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.53 – 从 Visual Studio Code 创建拉取请求
- en: This will prompt you to open Azure DevOps. After confirming this, the pull request
    window will open.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提示你打开 Azure DevOps。确认后，拉取请求窗口将会打开。
- en: 'From Visual Studio, select the **Team Explorer** panel. From here, you can
    click on **Pull Requests** to start a pull request:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.54 – Creating a pull request from Visual Studio'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.54_B16392.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.54 – Creating a pull request from Visual Studio
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Handling a pull request
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the different ways to handle a pull request that we''ve described converge
    to a unique point: in Azure DevOps, the **Pull requests** window opens, and you
    need to fill in the details of your pull request activity. As an example, this
    is the pull request that we started after the previous commit on the **development**
    branch:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.55 – New pull request window'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.55_B16392.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.55 – New pull request window
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can immediately see that the pull request merges a branch into another
    branch (in my case, **development** will be merged into **master**). You need
    to provide a title and a description of this pull request (that clearly describes
    the changes and the implementations you made in the merge), as well as attach
    links and add team members (users or groups) that will be responsible for reviewing
    this pull request. You can also include work items (this option will be automatically
    included if you completed a commit attached to a work item previously).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Files** section, you can see what this pull request will do in the
    destination branch (for every file). As an example, this is what my pull request
    shows me:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.56 – Code modifications view in a pull request'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.56_B16392.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.56 – Code modifications view in a pull request
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: On the left, you can see that the file committed in the `master` branch, while
    on the right, you can see the same file after the merging phase (with the details
    of every modification applied).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: If you've specified some reviewers, they will see the details of the code modifications,
    which means they can add comments and interact with the developers.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: To create the pull request process, simply click the **Create** button.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the pull request has been created, you can complete the pull request by
    clicking on the **Complete** button in the top-right corner of the pull request
    window (you can do this after the optional approval phase and after passing the
    branch rules):'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.57 – Completing a pull request'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.57_B16392.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.57 – Completing a pull request
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, you can do the following:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '**Complete** the pull request.'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mark as draft**: This is like a "work in progress". If a pull request is
    marked as a draft, required reviewers are not automatically added, voting is not
    permitted, and build policies (if activated) are not automatically executed.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abandon**: The pull request will be closed, and your code will not be merged.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you click on **Complete**, you''ll be prompted to fill in the **Complete
    pull request** window, which looks as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.58 – Complete pull request'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.58_B16392.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.58 – Complete pull request
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can insert a title and a description for the merge operation, select
    the merge type to apply, and select the post-completion operation to apply (if
    the associated work items should be marked as completed after merging and if the
    source branch must be deleted after the merge operation).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the type of merge operation to apply, you can choose from the following
    options:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '**Merge (no fast-forward)**: Non-linear history preserving all commits'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Squash commit**: Linear history with only a single commit on the target'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rebase and fast-forward**: Rebase source commits on a target and fast-forward'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Semi-linear merge**: Rebase source commits on a target and create a two-parent
    merge'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure DevOps gives you a nice animated graph to show the final result of the
    merge. To complete the pull request, click on **Complete merge**. You need to
    resolve any merge conflicts if something happens. With this, the merging phase
    starts:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.59 – Completing the pull request.](img/Figure_3.59_B16392.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
- en: Figure 3.59 – Completing the pull request.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have an automatic build policy on the target branch (the `master` branch
    here), the build pipeline is executed and then the merge operation is completed:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.60 – Pull request completed'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.60_B16392.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.60 – Pull request completed
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll learn how to use tags on branches to immediately
    identify the status of the code inside the repository.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Tagging a release
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Git Tags** are references that point to specific points in the **Git** history.
    **Tags** are used in Azure DevOps for marking a particular release (or branch)
    with an identifier that will be shared internally in your team to identify, for
    example, the "version" of your code base.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: As an example, in the previous section, we merged the `development` branch into
    the `master` branch by using a `master` branch contains our latest release of
    the code, which we're now ready to share internally.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'To use tags for your branches, in the **Repos** hub in Azure DevOps, go to
    the **Tags** menu:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.61 – Tags'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.61_B16392.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.61 – Tags
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: From here, you can create a tag for this release by going to **Tags** and clicking
    on **New Tag**.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you''re prompted to insert a tag name (an identifier that cannot contain
    spaces), provide a description for this tag, and select the branch that the tag
    will be applied to:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.62 – Create a tag'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.62_B16392.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.62 – Create a tag
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on **Create**, the tag will be applied to your branch:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.63 – Tag applied to a branch'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.63_B16392.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.63 – Tag applied to a branch
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to handle source control management with Azure
    DevOps and why it's so important when working in teams when developing code.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: We looked at the basic concepts of source control management and Git, the possible
    strategies to apply when merging code, how to use Azure DevOps to apply SCM, and
    how to handle repositories, commits, branches, and pull requests from Azure DevOps
    and development tools such as Visual Studio Code and Visual Studio. We also learned
    how to apply better policies to control the source code releases in order to improve
    the SCM life cycle, how to protect branches and how to use tags for a branch.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了源代码管理和 Git 的基本概念，合并代码时可能应用的策略，如何使用 Azure DevOps 来应用 SCM，以及如何通过 Azure DevOps
    和开发工具（如 Visual Studio Code 和 Visual Studio）来处理仓库、提交、分支和拉取请求。我们还学习了如何应用更好的策略来控制源代码发布，以便改进
    SCM 生命周期，如何保护分支，以及如何为分支使用标签。
- en: In the next chapter, we'll learn how to create build pipelines with Azure DevOps
    for implementing CI/CD practices.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习如何使用 Azure DevOps 创建构建管道，以实施 CI/CD 实践。
