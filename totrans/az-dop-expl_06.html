<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer172">&#13;
			<p id="_idParaDest-86" class="chapter-number"><a id="_idTextAnchor096"/>Chapter 4: </p>&#13;
			<h1 id="_idParaDest-87"><a id="_idTextAnchor097"/>Understanding Azure DevOps Pipelines</h1>&#13;
			<p>When adopting <strong class="bold">Azure DevOps</strong> in your organization, one of the main important decisions you must make is how to define the <strong class="bold">pipeline</strong> of your development process. A pipeline is a company-defined model that describes the steps and actions that a code base must support, from building to the final release phase. It's a key part of any DevOps architecture.</p>&#13;
			<p>In this chapter, we'll learn how to define and use pipelines with Azure DevOps for building code. </p>&#13;
			<p>We will cover the following topics:</p>&#13;
			<ul>&#13;
				<li>Implementing a CI/CD process</li>&#13;
				<li>An overview of Azure Pipelines</li>&#13;
				<li>Creating and using build agents</li>&#13;
				<li>Overview of the YAML format</li>&#13;
				<li>Creating a CI/CD pipeline with Azure DevOps</li>&#13;
				<li>Retention of builds</li>&#13;
				<li>Multi-stage pipeline</li>&#13;
				<li>Build pipeline with GitHub repositories</li>&#13;
				<li>Using container jobs in Azure Pipelines</li>&#13;
				<li>Let's get started!</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-88"><a id="_idTextAnchor098"/>Technical requirements</h1>&#13;
			<p>To follow this chapter, you need to have the following:</p>&#13;
			<ul>&#13;
				<li>A valid organization in Azure DevOps</li>&#13;
				<li>An Azure subscription where you can create an Azure VM or a local machine on one of these environments so that you can install the build agent software</li>&#13;
				<li>Visual Studio or Visual Studio Code as your development environment</li>&#13;
				<li>Access to the following GitHub repository for cloning the project: <a href="https://github.com/Microsoft/PartsUnlimited">https://github.com/Microsoft/PartsUnlimited</a></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-89"><a id="_idTextAnchor099"/>Implementing a CI/CD process</h1>&#13;
			<p>When adopting <a id="_idIndexMarker229"/>DevOps in a company, implementing the right DevOps tools with the right DevOps processes is essential and crucial. One of the fundamental flows in a DevOps implementation is the <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) and <strong class="bold">continuous delivery</strong> (<strong class="bold">CD</strong>) process, which can help developers build, test, and distribute a code base in a quicker, structured, and safer way.</p>&#13;
			<p><strong class="bold">CI</strong> is a software <a id="_idIndexMarker230"/>engineering practice where developers in a team integrate code modifications in a central repository a few times in a day. When a code modification integrated into a particular branch (normally with a pull request, as explained in the previous chapter), a new build is triggered in order to check the code and detect integration bugs quickly. Also, automatic tests (if available) are executed during this phase to check for breakages.</p>&#13;
			<p><strong class="bold">CD</strong> is the process that <a id="_idIndexMarker231"/>comes after the CI process. In this process, the output of the CI phase is packaged and delivered to the production stage without bugs. This is extremely helpful so that we always have a master branch that is tested, consistent, and ready to be deployed.</p>&#13;
			<p>In DevOps, you can also have a <strong class="bold">continuous deployment</strong> process<a id="_idIndexMarker232"/> in place, where you can automate the deployment of your code modifications to the final production environments without manual intervention.</p>&#13;
			<p>The typical DevOps CI/CD loop is represented in the following famous "loop" diagram:</p>&#13;
			<div>&#13;
				<div id="_idContainer114" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_001.jpg" alt="Figure 4.1 – DevOps CI/CD loop&#13;&#10;" width="1217" height="603"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.1 – DevOps CI/CD loop</p>&#13;
			<p>A typical CI/CD pipeline implementation contains the following stages:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">Commit stage</strong>: Here, new<a id="_idIndexMarker233"/> code modifications are integrated into the code base and a set of unit tests are performed in order to check code integrity and quality.</li>&#13;
				<li><strong class="bold">Build stage</strong>: Here, the code is <a id="_idIndexMarker234"/>automatically built and then the final results of the build process (artifacts) are pushed to the final registry.</li>&#13;
				<li><strong class="bold">Test stage</strong>: The build code will be deployed to<a id="_idIndexMarker235"/> preproduction, where<a id="_idIndexMarker236"/> the final testing will be performed and then go to production deployment. Here, the code is tested by adopting alpha and beta deployments. The alpha deployment stage is where developers check the performance of their new builds and the interactions between builds. In the Beta deployment stage, developers execute manual testing in order to double-check whether the application is working correctly.</li>&#13;
				<li><strong class="bold">Production deployment stage</strong>: This is where<a id="_idIndexMarker237"/> the final application, after successfully passing all the testing requirements, goes live to the production stage.</li>&#13;
			</ul>&#13;
			<p>There are lots of benefits of implementing a CI/CD process in your organizations. The main benefits are as follows:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">Improved code quality and early bug detection</strong>: By adopting automated tests, you can discover bugs <a id="_idIndexMarker238"/>and issues at an early stage and fix them accordingly.</li>&#13;
				<li><strong class="bold">Complete traceability</strong>: The whole <a id="_idIndexMarker239"/>build, test, and deployment process is tracked and can be analyzed later. This guarantees that you can inspect which changes in a particular build are included and the impact that they can have on the final tests or release.</li>&#13;
				<li><strong class="bold">Faster testing and release phases</strong>: Automating building and testing of your code base on every new commit (or before a release).</li>&#13;
			</ul>&#13;
			<p>In the next section, we'll provide an overview of the service offered by the Azure platform for implementing CI/CD: Azure Pipelines.</p>&#13;
			<h1 id="_idParaDest-90"><a id="_idTextAnchor100"/>Overview of Azure Pipelines</h1>&#13;
			<p><strong class="bold">Azure Pipelines</strong> is a cloud service <a id="_idIndexMarker240"/>offered by the Azure platform that allows you to automate the building, testing, and releasing phases of your development life cycle (CI/CD). Azure Pipelines works with any language or platform, it's integrated in Azure DevOps, and you can build your code on Windows, Linux, or macOS machines.</p>&#13;
			<p>Azure Pipelines is free for public projects, while for private projects, you have up to 1,800 minutes' (30 hours) worth of pipelines for free each month. More information about pricing can be found here:</p>&#13;
			<p><a href="https://azure.microsoft.com/en-us/pricing/details/devops/azure-devops-services/">https://azure.microsoft.com/en-us/pricing/details/devops/azure-devops-services/</a></p>&#13;
			<p>Some important feature of Azure Pipelines can <a id="_idIndexMarker241"/>be summarized as follows:</p>&#13;
			<ul>&#13;
				<li>It's platform and language independent, which means you can build code on every platform using the code base you want.</li>&#13;
				<li>It can be integrated with different types of repositories (Azure Repos, GitHub, GitHub Enterprise, BitBucket, and so on).</li>&#13;
				<li>Lots of extensions (standard and community-driven) are available for building your code and for handling custom tasks.</li>&#13;
				<li>Allows you to deploy your code to different cloud vendors.</li>&#13;
				<li>You can work with containerized applications such as Docker, Azure Container Registry, or Kubernetes.</li>&#13;
			</ul>&#13;
			<p>To use Azure Pipelines, you need the <a id="_idIndexMarker242"/>following:</p>&#13;
			<ul>&#13;
				<li>An organization in Azure DevOps, where you can create public or private projects</li>&#13;
				<li>A source code stored in a version control system (such as Azure DevOps Repos or GitHub)</li>&#13;
			</ul>&#13;
			<p>Azure Pipelines works with the following schema:</p>&#13;
			<div>&#13;
				<div id="_idContainer115" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_002.jpg" alt="Figure 4.2 – Azure Pipelines schema&#13;&#10;" width="824" height="315"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.2 – Azure Pipelines schema</p>&#13;
			<p>When your code is committed to a particular<a id="_idIndexMarker243"/> branch inside a repository, the <strong class="bold">build pipeline</strong> engine starts, build <a id="_idIndexMarker244"/>and test tasks are executed, and if all is successfully completed, your app is built and you have the final output (artifact). You can <a id="_idIndexMarker245"/>also create a <strong class="bold">release pipeline</strong> that takes the output of your build and releases it to the target environment (staging or production).</p>&#13;
			<p>To start using Azure <a id="_idIndexMarker246"/>Pipelines, you need to create a <strong class="bold">pipeline</strong>. A pipeline in Azure DevOps can be created in the following two ways:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">Using the Classic interface</strong>: This allows you to select some<a id="_idIndexMarker247"/> tasks visually from a list of possible tasks. You only need to fill in the parameters for these tasks.</li>&#13;
				<li><strong class="bold">Using a scripting language called YAML</strong>: The pipeline<a id="_idIndexMarker248"/> can be defined by creating a YAML file inside your repository with all the needed steps.</li>&#13;
			</ul>&#13;
			<p>Using the classic interface can be easier initially, but remember that many features are only available on YAML pipelines. A YAML pipeline definition is a file, and this can be versioned and controlled just like any other file inside a repository. You can easily move the pipeline definition between projects (this is not possible with the Classic interface).</p>&#13;
			<p>An Azure Pipeline can be <a id="_idIndexMarker249"/>represented as follows (courtesy of Microsoft):</p>&#13;
			<div>&#13;
				<div id="_idContainer116" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_003.jpg" alt="Figure 4.3 – Representation of an Azure Pipeline &#13;&#10;" width="979" height="333"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.3 – Representation of an Azure Pipeline </p>&#13;
			<p>A pipeline starts<a id="_idIndexMarker250"/> from a <strong class="bold">trigger</strong> (a manual trigger, a push inside a repository, a pull request, or a schedule). A pipeline is normally composed of one or more <strong class="bold">stages</strong> (logical separation of concerns in a pipeline, such as building, testing, deployment, and so on; they can run in parallel), and each stage contains one or more <strong class="bold">jobs</strong> (a set of steps that can also run in parallel). Every pipeline contains at least one stage if you don't explicitly create it. Each job<a id="_idIndexMarker251"/> runs on an <strong class="bold">agent</strong> (service or piece of software that <a id="_idIndexMarker252"/>executes the job). Every step is composed of a <strong class="bold">task</strong> that performs some action on your code (sequentially). The final output of a pipeline is an <strong class="bold">artifact</strong> (collection of files or<a id="_idIndexMarker253"/> packages published by the build).</p>&#13;
			<p>When creating a pipeline, you need to define a set of jobs and tasks for automating your builds (or multi-phased builds). You have native support for testing integration, release gates, automatic reporting, and so on.</p>&#13;
			<p>When defining multiple jobs within a pipeline, these jobs<a id="_idIndexMarker254"/> are executed in parallel. A <a id="_idIndexMarker255"/>pipeline that contains multiple jobs is called a <strong class="bold">fan-out</strong> scenario:</p>&#13;
			<div>&#13;
				<div id="_idContainer117" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_004.jpg" alt="Figure 4.4 – Fan-out pipeline&#13;&#10;" width="669" height="569"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.4 – Fan-out pipeline</p>&#13;
			<p>A pipeline with multiple jobs in a single stage<a id="_idIndexMarker256"/> can be represented<a id="_idIndexMarker257"/> as follows:</p>&#13;
			<p class="source-code">pool:</p>&#13;
			<p class="source-code">  vmImage: <strong class="bold">'ubuntu-latest'</strong></p>&#13;
			<p class="source-code">jobs:</p>&#13;
			<p class="source-code">- job: <strong class="bold">job1</strong></p>&#13;
			<p class="source-code">  steps:</p>&#13;
			<p class="source-code">  - bash: <strong class="bold">echo "Hello!"</strong></p>&#13;
			<p class="source-code">  - bash: <strong class="bold">echo "I'm job 1"</strong></p>&#13;
			<p class="source-code">- job: <strong class="bold">job2</strong></p>&#13;
			<p class="source-code">  steps:</p>&#13;
			<p class="source-code">  - bash: <strong class="bold">echo "Hello again…"</strong></p>&#13;
			<p class="source-code">  - bash: <strong class="bold">echo "I'm job 2"</strong></p>&#13;
			<p>If you're using stages when defining <a id="_idIndexMarker258"/>your pipeline, this is what is called a<a id="_idIndexMarker259"/> fan-out/fan-in scenario:</p>&#13;
			<div>&#13;
				<div id="_idContainer118" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_005.jpg" alt="Figure 4.5 – Fan-out pipeline&#13;&#10;" width="1441" height="527"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.5 – Fan-out pipeline</p>&#13;
			<p>Here, each stage is a fan-in operation, where all the jobs in the stage (which can consist of multiple tasks that run in sequence) must be finished before the next stage can be triggered (only one stage can be executing at a time). We'll talk about multi-stage pipelines later in this chapter.</p>&#13;
			<h1 id="_idParaDest-91"><a id="_idTextAnchor101"/>Understanding build agents</h1>&#13;
			<p>To build and deploy your <a id="_idIndexMarker260"/>code using Azure Pipelines, you need at least one agent. An agent is a service that runs the jobs defined in your pipeline. The execution of these jobs can occur directly on the agent's host machine or in containers.</p>&#13;
			<p>When defining agents for your pipeline, you have essentially two types of possible agents:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">Microsoft-hosted agents</strong>: This is a <a id="_idIndexMarker261"/>service totally managed by<a id="_idIndexMarker262"/> Microsoft and it's cleared on every execution of the pipeline (on each pipeline execution, you have a fresh new environment). </li>&#13;
				<li><strong class="bold">Self-hosted agents</strong>: This is a service that<a id="_idIndexMarker263"/> you need to set up and manage by yourself. This can be a custom virtual machine on Azure or a<a id="_idIndexMarker264"/> custom on-premise machine inside your infrastructure. In a self-hosted agent, you can install all the software you need for your builds, and this is persisted on every pipeline execution. A self-hosted agent can be on Windows, Linux, macOS, or in a Docker container.</li>&#13;
			</ul>&#13;
			<h2 id="_idParaDest-92"><a id="_idTextAnchor102"/>Microsoft-hosted agents</h2>&#13;
			<p>Microsoft-hosted agents is the<a id="_idIndexMarker265"/> simplest way to define an agent for your pipeline. Azure Pipelines provides a Microsoft-hosed agent pool by default called <strong class="bold">Azure Pipelines</strong>:</p>&#13;
			<div>&#13;
				<div id="_idContainer119" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_006.jpg" alt="Figure 4.6 – Azure Pipelines default agent pool&#13;&#10;" width="783" height="250"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.6 – Azure Pipelines default agent pool</p>&#13;
			<p>By selecting this agent pool, you can create different virtual machine types for executing your pipeline. At the time of writing, the available standard agent types are as follows:</p>&#13;
			<div>&#13;
				<div id="_idContainer120" class="IMG---Figure">&#13;
					<img src="Images/Table_1.1.jpg" alt="Table 1.1&#13;&#10;" width="1315" height="633"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Table 1.1</p>&#13;
			<p>Each of these images has its<a id="_idIndexMarker266"/> own set of software automatically installed. You can install additional tools by using the pre-defined Tool Installer task in your pipeline definition. More information can be found here:</p>&#13;
			<p>https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/?view=azure-devops#tool.</p>&#13;
			<p>When you create a pipeline using a Microsoft-hosted agent, you just need to specify the name of the virtual machine image to use for your agent from the preceding table. As an example, this is the definition of a hosted agent that's using Windows Server 2019 with a Visual Studio 2019 image:</p>&#13;
			<p class="source-code">- job: Windows</p>&#13;
			<p class="source-code">  pool:</p>&#13;
			<p class="source-code">    vmImage: 'windows-latest'</p>&#13;
			<p>When using a Microsoft-hosted <a id="_idIndexMarker267"/>agent, you need to remember the following:</p>&#13;
			<ul>&#13;
				<li>You cannot sign in on the agent machine.</li>&#13;
				<li>The agent runs on a Standard DS2v2 Azure Virtual Machine and you cannot increase that capacity.</li>&#13;
				<li>It runs as an administrator user on the Windows platform and as a <em class="italic">passwordless sudo</em> user on the Linux platform.</li>&#13;
				<li>For public projects, you have 10 free Microsoft-hosted parallel jobs that can run for up to 360 minutes each time, with no overall time limit per month.</li>&#13;
				<li>For private projects, you have one free parallel job that can run for up to 60 minutes each time, with the maximum being 1,800 minutes (30 hours) per month. If you need more capacity, you can pay for additional parallel jobs. By doing this, you can run each job for up to 360 minutes.</li>&#13;
				<li>The Microsoft-hosted agent runs in the same Azure geography as your Azure DevOps organization, but it's not guaranteed that it will run in the same region too (an Azure geography contains one or more regions).</li>&#13;
			</ul>&#13;
			<h2 id="_idParaDest-93"><a id="_idTextAnchor103"/>Self-hosted agents</h2>&#13;
			<p>While Microsoft-hosted agents are a<a id="_idIndexMarker268"/> SaaS service, self-hosted agents are private agents that you can configure as per your needs by using Azure virtual machines or directly using your on-premise infrastructure. You are responsible for providing all the necessary software and tools to execute your pipeline and you're responsible for maintaining and upgrading your agent.</p>&#13;
			<p>A self-hosted agent can be installed on the following platforms:</p>&#13;
			<ul>&#13;
				<li>Windows</li>&#13;
				<li>Linux</li>&#13;
				<li>macOS</li>&#13;
				<li>Docker</li>&#13;
			</ul>&#13;
			<p>Creating a self-hosted agent involves<a id="_idIndexMarker269"/> completing the following activities:</p>&#13;
			<ul>&#13;
				<li>Prepare the environment</li>&#13;
				<li>Prepare permissions on Azure DevOps</li>&#13;
				<li>Download and configure the agent</li>&#13;
				<li>Start the agent</li>&#13;
			</ul>&#13;
			<p>These steps are similar for all the environments. Next, we'll learn how to create a self-hosted Windows agent.</p>&#13;
			<h3>Creating a self-hosted Windows agent</h3>&#13;
			<p>A self-hosted Windows agent is used to build and <a id="_idIndexMarker270"/>deploy applications built on top of Microsoft's platforms (such as .NET applications, Azure cloud apps, and so on) but also for other types of platforms, such as Java and Android apps.</p>&#13;
			<p>The first step to perform when creating an agent is to register the agent in your Azure DevOps organization. To do so, you need to sign into your DevOps organization as an administrator and from the <strong class="bold">User Settings</strong> menu, click on <strong class="bold">Personal access tokens</strong>:</p>&#13;
			<div>&#13;
				<div id="_idContainer121" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_007.jpg" alt="Figure 4.7 – Personal access tokens&#13;&#10;" width="553" height="627"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.7 – Personal access tokens</p>&#13;
			<p>Here, you can create a new<a id="_idIndexMarker271"/> personal access token for your organization with an expiration date and with full access or with a custom defined access level (if you select the custom defined scope, you need to select the permission you want for each scope). To see the complete list of available scopes, click on the <strong class="bold">Show all scopes</strong> link at the bottom of this window:</p>&#13;
			<div>&#13;
				<div id="_idContainer122" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_008.jpg" alt="Figure 4.8 – Create a new personal access token&#13;&#10;" width="870" height="1027"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.8 – Create a new personal access token</p>&#13;
			<p>Please check<a id="_idIndexMarker272"/> that the <strong class="bold">Agent Pools</strong> scope has the <strong class="bold">Read &amp; manage</strong> permission enabled.</p>&#13;
			<p>When finished, click on <strong class="bold">Create</strong> and then copy the generated token before closing the window (it will only be shown once).</p>&#13;
			<p class="callout-heading">Important Note</p>&#13;
			<p class="callout">The user that you will be using for the agent must be a user with permissions to register the agent. You can check this by going to <strong class="bold">Organization Settings </strong>| <strong class="bold">Agent pools</strong>, selecting the <strong class="bold">Default</strong> pool, and clicking on <strong class="bold">Security</strong>.</p>&#13;
			<p>Now, you need to download the agent<a id="_idIndexMarker273"/> software and configure it. From <strong class="bold">Organization Settings </strong>| <strong class="bold">Agent Pools</strong>, select the <strong class="bold">Default</strong> pool and from the <strong class="bold">Agents</strong> tab, click on <strong class="bold">New agent</strong>:</p>&#13;
			<div>&#13;
				<div id="_idContainer123" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_009.jpg" alt="Figure 4.9 – Creating a new agent&#13;&#10;" width="959" height="767"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.9 – Creating a new agent</p>&#13;
			<p>The <strong class="bold">Get the agent</strong> window will open. Select <strong class="bold">Windows</strong> as the target platform, select <strong class="bold">x64</strong> or <strong class="bold">x86</strong> as your target agent platform (machine) accordingly, and then click on the <strong class="bold">Download </strong>button:</p>&#13;
			<div>&#13;
				<div id="_idContainer124" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_010.jpg" alt="Figure 4.10 – Agent software download page&#13;&#10;" width="932" height="974"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.10 – Agent software download page</p>&#13;
			<p>This procedure will download a package (normally called <strong class="source-inline">vsts-agent-win-x64-2.166.4.zip</strong>). You need to <a id="_idIndexMarker274"/>run this package (<strong class="source-inline">config.cmd</strong>) on the agent machine (an Azure VM or your on-premise server, which will act as an agent for your builds):</p>&#13;
			<div>&#13;
				<div id="_idContainer125" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_011.jpg" alt="Figure 4.11 – Agent software package&#13;&#10;" width="814" height="291"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.11 – Agent software package</p>&#13;
			<p>The setup will ask you for<a id="_idIndexMarker275"/> the following:</p>&#13;
			<ul>&#13;
				<li>The URL of your <a id="_idIndexMarker276"/>Azure DevOps organization (<a href="https://dev.azure.com/">https://dev.azure.com/</a>{your-organization})</li>&#13;
				<li>The personal access token to use (created previously)</li>&#13;
			</ul>&#13;
			<p>When running the agent (interactively or as a service), it's recommended to run it as a service if you want to automate builds.</p>&#13;
			<p>After inserting these parameters, the setup registers the agent:</p>&#13;
			<div>&#13;
				<div id="_idContainer126" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_012.jpg" alt="Figure 4.12 – Agent registration&#13;&#10;" width="659" height="84"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.12 – Agent registration</p>&#13;
			<p>To register the agent, you need to insert the agent pool, the agent name, and the work folder (you can leave the default value as-is).</p>&#13;
			<p>Finally, you need to decide whether your agent must be executed <em class="italic">interactively</em> or <em class="italic">as a service</em>. As we mentioned previously, running the agent as a service is recommended, but in many cases, the interactive option can be helpful because it gives you a console where you can see the status and running UI tests.</p>&#13;
			<p>In both cases, please be aware of the user account you select for running the agent. The default account is the built-in Network Service user, but this user normally doesn't have all the needed permissions on local folders. Using an administrator account can help you solve a lot of problems.</p>&#13;
			<p>If the setup has been completed successfully, you should see a service running on your agent machine and a new agent that <a id="_idIndexMarker277"/>pops up on your agent pool in Azure DevOps:</p>&#13;
			<div>&#13;
				<div id="_idContainer127" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_013.jpg" alt="4.13 – New agent created&#13;&#10;" width="961" height="250"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">4.13 – New agent created</p>&#13;
			<p>If you select the agent and then go to the <strong class="bold">Capabilities</strong> section, you will be able to see all its capabilities (OS version, OS architecture, computer name, software installed, and so on):</p>&#13;
			<div>&#13;
				<div id="_idContainer128" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_014.jpg" alt="Figure 4.14 – Agent capabilities&#13;&#10;" width="1233" height="852"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.14 – Agent capabilities</p>&#13;
			<p>The agent's capabilities can be automatically discovered by the agent software or added by you (user-defined capabilities) if you click on the <strong class="bold">Add a new capability</strong> action. Capabilities are used by the pipeline engine to redirect a particular build to the correct agent according to the<a id="_idIndexMarker278"/> required capabilities for the pipeline (demands).</p>&#13;
			<p>When the agent is online, it's ready to accept your code build, which should be queued.</p>&#13;
			<p>Remember that you can also install multiple agents on the same machine (for example, if you want the possibility to execute core pipelines or handle jobs in parallel), but this scenario is only recommended if the agents will not share resources.</p>&#13;
			<h2 id="_idParaDest-94"><a id="_idTextAnchor104"/>When to use a Microsoft-hosted or a self-hosted agent</h2>&#13;
			<p>Microsoft-hosted agents <a id="_idIndexMarker279"/>are normally useful when you have a standard code base and you don't need particular software or environment configuration<a id="_idIndexMarker280"/> to build your code. If you're in this scenario, using a Microsoft-hosted agent is recommended because you don't have to worry about creating environments. As an example, if you need to build an Azure Function project, normally, you don't have the need to install custom software on the build agent and the Microsoft-hosted agent can work perfectly.</p>&#13;
			<p>Self-hosted agents are the way to go when you need a particular environment configuration, when you need a particular piece of software or tools installed on the agent, and when you need more power for your builds. Self-hosted agents are also the way to go when you need to preserve the environment between each run of your builds. A self-hosted agent is normally the right choice when you need to have better control of your agent or you wish to deploy your build to on-premise environments (not accessible externally). It also normally allows you to save money.</p>&#13;
			<p>Now that we've discussed about the possible build agents that you can use for your build pipelines, in the next section, we'll provide an overview of YAML, the scripting language that allows you to define a pipeline.</p>&#13;
			<h1 id="_idParaDest-95"><a id="_idTextAnchor105"/>Overview of the YAML language</h1>&#13;
			<p><strong class="bold">YAML</strong>, an acronym for <strong class="bold">Y<a id="_idTextAnchor106"/>AML Ain't Markup Language</strong>, is a human-readable scripting language used for data serialization and normally used for handling configurations definitions for<a id="_idIndexMarker281"/> applications. It can be considered a superset of JSON.</p>&#13;
			<p>YAML uses indentation for handling the structure of the object's definitions, and it's insensitive to quotation marks and braces. It's simply a data representation language and is not used for executing commands.</p>&#13;
			<p>With Azure DevOps, YAML is extremely important because it allows you to define a pipeline by using a script definition instead of a graphical interface (that cannot be ported between projects).</p>&#13;
			<p>The official YAML website can be found here:</p>&#13;
			<p><a href="http://yaml.org/">http://yaml.org/</a></p>&#13;
			<p>A YAML structure <a id="_idIndexMarker282"/>is based on key-value<a id="_idIndexMarker283"/> elements:</p>&#13;
			<p><strong class="source-inline">Key: Value   # This is a comment</strong></p>&#13;
			<p>In the following sections, we'll learn how to define objects in YAML.</p>&#13;
			<h2 id="_idParaDest-96"><a id="_idTextAnchor107"/>Scalars</h2>&#13;
			<p>As an example, the following<a id="_idIndexMarker284"/> are scalar variables that have been defined in YAML:</p>&#13;
			<p class="source-code">Number: 1975 quotedText: "some text description"notQuotedtext: strings can be also without quotes boolean: true nullKeyValue: null</p>&#13;
			<p>You can also define multi-line keys by using <strong class="source-inline">?</strong>, followed by a space, as follows:</p>&#13;
			<p class="source-code">? |</p>&#13;
			<p class="source-code">  This is a key</p>&#13;
			<p class="source-code">  that has multiple lines</p>&#13;
			<p class="source-code">: and this is its value</p>&#13;
			<h2 id="_idParaDest-97"><a id="_idTextAnchor108"/>Collections and lists</h2>&#13;
			<p>This is a YAML <a id="_idIndexMarker285"/>definition for a collection <a id="_idIndexMarker286"/>object:</p>&#13;
			<p class="source-code">Cars:</p>&#13;
			<p class="source-code">   - Fiat</p>&#13;
			<p class="source-code">   - Mercedes</p>&#13;
			<p class="source-code">   - BMW</p>&#13;
			<p>You can also define nested collections:</p>&#13;
			<p class="source-code">- Drivers:</p>&#13;
			<p class="source-code">      name: Stefano Demiliani</p>&#13;
			<p class="source-code">      age: 45</p>&#13;
			<p class="source-code">      Driving license type:</p>&#13;
			<p class="source-code">          - type: full car license</p>&#13;
			<p class="source-code">            license id: ABC12345</p>&#13;
			<p class="source-code">            expiry date: 2025-12-31</p>&#13;
			<h2 id="_idParaDest-98"><a id="_idTextAnchor109"/>Dictionaries</h2>&#13;
			<p>You can define a <strong class="source-inline">Dictionary</strong> object by <a id="_idIndexMarker287"/>using YAML in the following way:</p>&#13;
			<p class="source-code">CarDetails:</p>&#13;
			<p class="source-code">     make: Mercedes</p>&#13;
			<p class="source-code">     model: GLC220</p>&#13;
			<p class="source-code">     fuel: Gasoline</p>&#13;
			<h2 id="_idParaDest-99"><a id="_idTextAnchor110"/>Document structure</h2>&#13;
			<p>YAML uses three dashes, <strong class="source-inline">---</strong>, to separate <a id="_idIndexMarker288"/>directives from document content and to identify the start of a document. As an example, the following YAML defines two documents in a single file:</p>&#13;
			<p class="source-code">---# Products purchased</p>&#13;
			<p class="source-code">- item    : Surface Book 2</p>&#13;
			<p class="source-code">  quantity: 1</p>&#13;
			<p class="source-code">- item    : Surface Pro 7</p>&#13;
			<p class="source-code">  quantity: 3</p>&#13;
			<p class="source-code">- item    : Arc Mouse</p>&#13;
			<p class="source-code">  quantity: 1</p>&#13;
			<p class="source-code"># Product out of stock</p>&#13;
			<p class="source-code">---</p>&#13;
			<p class="source-code">- item    : Surface 4</p>&#13;
			<p class="source-code">- item    : Microsoft Trackball</p>&#13;
			<h2 id="_idParaDest-100"><a id="_idTextAnchor111"/>Complex object definition</h2>&#13;
			<p>As an example of<a id="_idIndexMarker289"/> how to define a complex object in YAML, the following is the representation used for an <strong class="source-inline">Invoice</strong> object:</p>&#13;
			<p class="source-code">--- </p>&#13;
			<p class="source-code">invoice: 20-198754</p>&#13;
			<p class="source-code">date   : 2020-05-27</p>&#13;
			<p class="source-code">bill-to: C002456</p>&#13;
			<p class="source-code">    Name  : Stefano Demiliani</p>&#13;
			<p class="source-code">    address:</p>&#13;
			<p class="source-code">        lines: </p>&#13;
			<p class="source-code">            Viale Pasubio, 21</p>&#13;
			<p class="source-code">            c/o Microsoft House</p>&#13;
			<p class="source-code">        city    : Milan</p>&#13;
			<p class="source-code">        state   : MI</p>&#13;
			<p class="source-code">        postal  : 20154</p>&#13;
			<p class="source-code">ship-to: C002456</p>&#13;
			<p class="source-code">product:</p>&#13;
			<p class="source-code">    - itemNo      : ITEM001</p>&#13;
			<p class="source-code">      quantity    : 1</p>&#13;
			<p class="source-code">      description : Surface Book 2</p>&#13;
			<p class="source-code">      price       : 1850.00</p>&#13;
			<p class="source-code">    - sku         : ITEM002</p>&#13;
			<p class="source-code">      quantity    : 2</p>&#13;
			<p class="source-code">      description : Arc Mouse</p>&#13;
			<p class="source-code">      price       : 65.00</p>&#13;
			<p class="source-code">tax  : 80.50</p>&#13;
			<p class="source-code">total: 1995.50</p>&#13;
			<p class="source-code">comments:</p>&#13;
			<p class="source-code">    Please deliver on office hours.</p>&#13;
			<p class="source-code">    Leave on the reception.</p>&#13;
			<p>Now that we've provided a <a id="_idIndexMarker290"/>quick overview of the YAML syntax, in the next section, we'll learn how to create a build pipeline with Azure DevOps.</p>&#13;
			<h1 id="_idParaDest-101"><a id="_idTextAnchor112"/>Creating a build pipeline with Azure DevOps</h1>&#13;
			<p>Having a build <a id="_idIndexMarker291"/>pipeline in place is a fundamental step<a id="_idIndexMarker292"/> if you want to implement<a id="_idIndexMarker293"/> continuous integration for your code (having your code automatically built and tested on every commit).</p>&#13;
			<p>The prerequisite to creating a build pipeline with Azure DevOps is obviously to have some code stored inside a repository.</p>&#13;
			<p>To create a build pipeline with <a id="_idIndexMarker294"/>Azure DevOps, you need to go to the <strong class="bold">Pipelines</strong> hub and select the <strong class="bold">Pipelines</strong> action:</p>&#13;
			<div>&#13;
				<div id="_idContainer129" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_015.jpg" alt="Figure 4.15 – Build pipeline creation&#13;&#10;" width="1058" height="977"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.15 – Build pipeline creation</p>&#13;
			<p>From here, you can create a new build pipeline by selecting the <strong class="bold">New pipeline</strong> button. When pressed, you will see the following screen, which asks you for a code repository:</p>&#13;
			<div>&#13;
				<div id="_idContainer130" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_016.jpg" alt="Figure 4.16 – Selecting a repository&#13;&#10;" width="973" height="847"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.16 – Selecting a repository</p>&#13;
			<p>This screen is <a id="_idIndexMarker295"/>extremely important. From here, you can start creating a build pipeline in two possible ways (described previously):</p>&#13;
			<ol>&#13;
				<li>Using a YAML file to create your pipeline definition. This is what happens when you select the repository in this window.</li>&#13;
				<li>Using the classic editor (graphical user interface). This is what happens when you click on the <strong class="bold">Use the classic editor</strong> link at the bottom of this page.</li>&#13;
			</ol>&#13;
			<p>In the next section, we'll learn how to create a build pipeline by using these two methods.</p>&#13;
			<h2 id="_idParaDest-102"><a id="_idTextAnchor113"/>Pipeline definition with the classic editor</h2>&#13;
			<p>The classic editor permits <a id="_idIndexMarker296"/>you to define a build pipeline for your project graphically by selecting pre-defined actions. As we mentioned previously, a pipeline definition created in this way is not under source control.</p>&#13;
			<p>When you click on the <strong class="bold">Use the classic editor</strong> link, you need to select the repository where your code is stored (<strong class="bold">Azure Repos Git</strong>, <strong class="bold">GitHub</strong>, <strong class="bold">GitHub Enterprise Server</strong>, <strong class="bold">Subversion</strong>, <strong class="bold">TFVC</strong>, <strong class="bold">Bitbucket Cloud</strong>, or <strong class="bold">Other Git</strong>) and the branch that the build pipeline will be connected to:</p>&#13;
			<div>&#13;
				<div id="_idContainer131" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_017.jpg" alt="Figure 4.17 – Classic editor pipeline definition&#13;&#10;" width="1155" height="1121"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.17 – Classic editor pipeline definition</p>&#13;
			<p>Then, you need to choose a template for the kind of app you're building. You have a set of predefined templates to<a id="_idIndexMarker297"/> choose from (that you can customize later), but you can also start from an empty template:</p>&#13;
			<div>&#13;
				<div id="_idContainer132" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_018.jpg" alt="Figure 4.18 – Pipeline template selection&#13;&#10;" width="962" height="1037"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.18 – Pipeline template selection</p>&#13;
			<p>If predefined templates<a id="_idIndexMarker298"/> fit your needs, you can start by using them; otherwise, it's recommended to create a custom pipeline by selecting the actions you need.</p>&#13;
			<p>Here, my application that's stored in the Azure DevOps project repository is an ASP.NET web application (an e-commerce website project called <strong class="source-inline">PartsUnlimited</strong>; you can find the public repository at the following URL: <a href="https://github.com/Microsoft/PartsUnlimited">https://github.com/Microsoft/PartsUnlimited</a>), so I've selected the ASP.NET template.</p>&#13;
			<p>When selected, this is the pipeline<a id="_idIndexMarker299"/> template that will be created for you automatically:</p>&#13;
			<div>&#13;
				<div id="_idContainer133" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_019.jpg" alt="Figure 4.19 – Pipeline created from a template&#13;&#10;" width="901" height="954"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.19 – Pipeline created from a template</p>&#13;
			<p>Let's check every section of the pipeline in detail.</p>&#13;
			<p>The pipeline (here, this is called <strong class="source-inline">PartsUnlimited-demo-pipeline</strong>) runs on a Microsoft-hosted agent (Azure Pipelines agent pool) based on the <strong class="bold">vs2017-win2016</strong> template (Windows Server 2016 with Visual Studio 2017), as shown in the following screenshot:</p>&#13;
			<div>&#13;
				<div id="_idContainer134" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_020.jpg" alt="Figure 4.20 – Agent specification on the pipeline &#13;&#10;" width="1035" height="739"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.20 – Agent specification on the pipeline </p>&#13;
			<p>The agent job starts<a id="_idIndexMarker300"/> by installing the NuGet package manager and restoring the required packages for building the project in the selected repository. For these actions, the pipeline definition contains the tasks that you can see in the following screenshot:</p>&#13;
			<div>&#13;
				<div id="_idContainer135" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_021.jpg" alt="Figure 4.21 – NuGet tasks&#13;&#10;" width="1166" height="921"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.21 – NuGet tasks</p>&#13;
			<p>Then, there's a task for<a id="_idIndexMarker301"/> building the solution:</p>&#13;
			<div>&#13;
				<div id="_idContainer136" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_022.jpg" alt="Figure 4.22 – Build solution task&#13;&#10;" width="1215" height="905"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.22 – Build solution task</p>&#13;
			<p>There's also a task for<a id="_idIndexMarker302"/> testing the solution and publishing the test results:</p>&#13;
			<div>&#13;
				<div id="_idContainer137" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_023.jpg" alt="Figure 4.23 – Test Assemblies task&#13;&#10;" width="1025" height="937"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.23 – Test Assemblies task</p>&#13;
			<p>The last steps are for publishing<a id="_idIndexMarker303"/> the sources of the build process as artifacts (output of the build):</p>&#13;
			<div>&#13;
				<div id="_idContainer138" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_024.jpg" alt="Figure 4.24 – Publishing tasks&#13;&#10;" width="1061" height="715"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.24 – Publishing tasks</p>&#13;
			<p>If you select the <strong class="bold">Variables</strong> tab, you will see<a id="_idIndexMarker304"/> that there are some parameters that are used during the build process. Here, you can create your own variables to use inside the pipeline if needed:</p>&#13;
			<div>&#13;
				<div id="_idContainer139" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_025.jpg" alt="Figure 4.25 – Pipeline variables&#13;&#10;" width="1236" height="552"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.25 – Pipeline variables</p>&#13;
			<p>The next section is called <strong class="bold">Triggers</strong>. Here, you can define what triggers start your pipeline. By default, no triggers are<a id="_idIndexMarker305"/> published initially, but here, you can enable CI to automatically start your pipeline on every commit on the selected branch:</p>&#13;
			<div>&#13;
				<div id="_idContainer140" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_026.jpg" alt="Figure 4.26 – Pipeline triggers&#13;&#10;" width="1191" height="544"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.26 – Pipeline triggers</p>&#13;
			<p class="callout-heading">Important Note</p>&#13;
			<p class="callout">Enabling CI is a recommended practice if you want every piece of code that's committed on a branch (for example, on the <strong class="bold">master</strong> branch) to always be tested and safely controlled. In this way, you can be assured that the code is always working as expected.</p>&#13;
			<p>In the <strong class="bold">Option</strong> tab, you can set some <a id="_idIndexMarker306"/>options related to your build definition. For example, here, you can create links to all the work items so that they're linked to associated changes when a build completes successfully, create work items on failure of a build, set the status badge for your pipeline, specify timeouts, and so on:</p>&#13;
			<div>&#13;
				<div id="_idContainer141" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_027.jpg" alt="Figure 4.27 – Pipeline options&#13;&#10;" width="1143" height="914"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.27 – Pipeline options</p>&#13;
			<p>The <strong class="bold">Retention</strong> tab, on the <a id="_idIndexMarker307"/>other hand, is used for configuring the retention policy for this specific pipeline (how many days to keep artifacts for, the number of days to keep runs and pull requests for, and so on). Doing this will override the general retention settings. We'll talk about them later in the <em class="italic">Retention of builds</em> section.</p>&#13;
			<p>Once you've finished defining the pipeline, you can click <strong class="bold">Save &amp; queue</strong> to save your definition. By clicking on <strong class="bold">Save and run</strong>, the pipeline will be placed in a queue and wait for an agent:</p>&#13;
			<div>&#13;
				<div id="_idContainer142" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_028.jpg" alt="Figure 4.28 – Run pipeline&#13;&#10;" width="632" height="755"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.28 – Run pipeline</p>&#13;
			<p>When the agent is found, the <a id="_idIndexMarker308"/>pipeline is executed and your code is built:</p>&#13;
			<div>&#13;
				<div id="_idContainer143" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_029.jpg" alt="Figure 4.29 – Pipeline execution starting&#13;&#10;" width="614" height="216"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.29 – Pipeline execution starting</p>&#13;
			<p>You can follow the <a id="_idIndexMarker309"/>execution of each step of the pipeline and see the related logs. If the pipeline ends successfully, you can view a summary of its execution:</p>&#13;
			<div>&#13;
				<div id="_idContainer144" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_030.jpg" alt="Figure 4.30 – Pipeline – final result&#13;&#10;" width="640" height="219"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.30 – Pipeline – final result</p>&#13;
			<p>You can also select the <strong class="bold">Tests</strong> tab to review the test execution status:</p>&#13;
			<div>&#13;
				<div id="_idContainer145" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_031.jpg" alt="Figure 4.31 – Pipeline tests result&#13;&#10;" width="634" height="323"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.31 – Pipeline tests result</p>&#13;
			<p>In the next section, we'll learn how to create a<a id="_idIndexMarker310"/> YAML pipeline for this application.</p>&#13;
			<h2 id="_idParaDest-103"><a id="_idTextAnchor114"/>YAML pipeline definition</h2>&#13;
			<p>As previously explained, when <a id="_idIndexMarker311"/>you start creating a build pipeline with Azure DevOps, the wizard creates a YAML-based pipeline by default.</p>&#13;
			<p>To start creating a YAML pipeline, go to the <strong class="bold">Pipeline</strong> section in Azure DevOps and click on <strong class="bold">New Pipeline</strong>. </p>&#13;
			<p>Here, instead of selecting the classic editor (as we did in the previous section), just select the type of repository where your code is located (<strong class="bold">Azure Repos Git</strong>, <strong class="bold">GitHub</strong>, <strong class="bold">BitBucket</strong>, and so on):</p>&#13;
			<div>&#13;
				<div id="_idContainer146" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_032.jpg" alt="Figure 4.32 – YAML pipeline definition&#13;&#10;" width="1061" height="963"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.32 – YAML pipeline definition</p>&#13;
			<p>Then, select your<a id="_idIndexMarker312"/> repository from the available repositories list:</p>&#13;
			<div>&#13;
				<div id="_idContainer147" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_033.jpg" alt="Figure 4.33 – YAML pipeline – repository selection&#13;&#10;" width="1045" height="379"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.33 – YAML pipeline – repository selection</p>&#13;
			<p>The system now analyzes your<a id="_idIndexMarker313"/> repository and proposes a set of available templates according to the code stored in the repository itself. You can start from a blank YAML template or you can select a template. Here, I'm selecting the ASP.NET template:</p>&#13;
			<div>&#13;
				<div id="_idContainer148" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_034.jpg" alt="Figure 4.34 – YAML pipeline – template selection&#13;&#10;" width="1237" height="1343"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.34 – YAML pipeline – template selection</p>&#13;
			<p>The system <a id="_idIndexMarker314"/>creates a YAML file (called <strong class="source-inline">azure-pipelines.yml</strong>), as shown in the following screenshot:</p>&#13;
			<div>&#13;
				<div id="_idContainer149" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_035.jpg" alt="Figure 4.35 – YAML pipeline definition&#13;&#10;" width="970" height="937"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.35 – YAML pipeline definition</p>&#13;
			<p>The generated YAML <a id="_idIndexMarker315"/>definition contains a set of tasks, just like in the previous example, but here, these tasks are in their YAML definition. The complete generated file is as follows:</p>&#13;
			<p class="source-code"># ASP.NET</p>&#13;
			<p class="source-code"># Build and test ASP.NET projects.</p>&#13;
			<p class="source-code"># Add steps that publish symbols, save build artifacts, deploy, and more:</p>&#13;
			<p class="source-code"># https://docs.microsoft.com/azure/devops/pipelines/apps/aspnet/build-aspnet-4</p>&#13;
			<p class="source-code">trigger:</p>&#13;
			<p class="source-code">- master</p>&#13;
			<p class="source-code">pool:</p>&#13;
			<p class="source-code">  vmImage: 'windows-latest'</p>&#13;
			<p class="source-code">variables:</p>&#13;
			<p class="source-code">  solution: '**/*.sln'</p>&#13;
			<p class="source-code">  buildPlatform: 'Any CPU'</p>&#13;
			<p class="source-code">  buildConfiguration: 'Release'</p>&#13;
			<p class="source-code">steps:</p>&#13;
			<p class="source-code">- task: NuGetToolInstaller@1</p>&#13;
			<p class="source-code">- task: NuGetCommand@2</p>&#13;
			<p class="source-code">  inputs:</p>&#13;
			<p class="source-code">    restoreSolution: '$(solution)'</p>&#13;
			<p class="source-code">- task: VSBuild@1</p>&#13;
			<p class="source-code">  inputs:</p>&#13;
			<p class="source-code">    solution: '$(solution)'</p>&#13;
			<p class="source-code">    msbuildArgs: '/p:DeployOnBuild=true /p:WebPublishMethod=Package /p:PackageAsSingleFile=true /p:SkipInvalidConfigurations=true /p:PackageLocation="$(build.artifactStagingDirectory)"'</p>&#13;
			<p class="source-code">    platform: '$(buildPlatform)'</p>&#13;
			<p class="source-code">    configuration: '$(buildConfiguration)'</p>&#13;
			<p class="source-code">- task: VSTest@2</p>&#13;
			<p class="source-code">  inputs:</p>&#13;
			<p class="source-code">    platform: '$(buildPlatform)'</p>&#13;
			<p class="source-code">    configuration: '$(buildConfiguration)'</p>&#13;
			<p class="source-code">Here I add two more tasks for publishing the symbols and the final artifacts of the pipeline:</p>&#13;
			<p class="source-code">task: PublishSymbols@2</p>&#13;
			<p class="source-code">  displayName: 'Publish symbols path'</p>&#13;
			<p class="source-code">  inputs:</p>&#13;
			<p class="source-code">    SearchPattern: '**\bin\**\*.pdb'</p>&#13;
			<p class="source-code">    PublishSymbols: false</p>&#13;
			<p class="source-code">  continueOnError: true</p>&#13;
			<p class="source-code">- task: PublishBuildArtifacts@1</p>&#13;
			<p class="source-code">  displayName: 'Publish Artifact'</p>&#13;
			<p class="source-code">  inputs:</p>&#13;
			<p class="source-code">    PathtoPublish: '$(build.artifactstagingdirectory)'</p>&#13;
			<p class="source-code">    ArtifactName: '$(Parameters.ArtifactName)'</p>&#13;
			<p class="source-code">  condition: succeededOrFailed()</p>&#13;
			<p>As you can see, the YAML file contains the trigger that starts the pipeline (here, this is a commit on the master branch), the agent pool to use, the pipeline variables, and the sequence of each task<a id="_idIndexMarker316"/> to execute (with its specific parameters).</p>&#13;
			<p>Click on Save and run as shown in the previous screenshot to queue the pipeline and have it executed. The following screenshot shows the executed YAML pipeline.</p>&#13;
			<div>&#13;
				<div id="_idContainer150" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_036.jpg" alt="Figure 4.36 – YAML pipeline executed&#13;&#10;" width="680" height="191"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.36 – YAML pipeline executed</p>&#13;
			<p>To add new tasks, it's useful to use the assistant tool on the right of the editor frame. It allows you to have a <strong class="bold">Tasks</strong> list where you can search for a task, fill in the necessary parameters, and then have the final YAML definition:</p>&#13;
			<div>&#13;
				<div id="_idContainer151" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_037.jpg" alt="Figure 4.37 – YAML pipeline task selection&#13;&#10;" width="923" height="597"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 4.37 – YAML pipeline task selection</p>&#13;
			<p>When you choose to create<a id="_idIndexMarker317"/> a pipeline with YAML, Azure DevOps creates a file that's stored in the same repository that your code is stored in:</p>&#13;
			<div>&#13;
				<div id="_idContainer152" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_038.jpg" alt="Figure 4.38 – YAML pipeline file created&#13;&#10;" width="1120" height="463"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.38 – YAML pipeline file created</p>&#13;
			<p>This file is under source control and versioned on every modification.</p>&#13;
			<p>For a complete<a id="_idIndexMarker318"/> reference to the YAML schema for a pipeline, I suggest following this link:</p>&#13;
			<p><a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devops&amp;tabs=schema%2Cparameter-schema.">https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devops&amp;tabs=schema%2Cparameter-schema</a></p>&#13;
			<h1 id="_idParaDest-104"><a id="_idTextAnchor115"/>Retention of builds</h1>&#13;
			<p>When you run a pipeline, Azure<a id="_idIndexMarker319"/> DevOps logs each step's execution and stores the final artifacts and tests for each run.</p>&#13;
			<p>Azure DevOps has a default retention policy for pipeline execution of 30 days. You can change these default values by going to <strong class="bold">Project settings</strong> | <strong class="bold">Pipelines</strong> | <strong class="bold">Settings</strong>:</p>&#13;
			<div>&#13;
				<div id="_idContainer153" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_039.jpg" alt="Figure 4.39 – Pipeline retention policy&#13;&#10;" width="1226" height="986"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.39 – Pipeline retention policy</p>&#13;
			<p>You can also use the <strong class="bold">Copy files</strong> task to store<a id="_idIndexMarker320"/> your build and artifacts data in external storage so that you can preserve them for longer than what's specified in the retention policy:</p>&#13;
			<div>&#13;
				<div id="_idContainer154" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_040.jpg" alt="Figure 4.40 – Copy files task&#13;&#10;" width="622" height="565"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.40 – Copy files task</p>&#13;
			<p>The YAML definition for this task is<a id="_idIndexMarker321"/> as follows:</p>&#13;
			<p class="source-code">- task: CopyFiles@2</p>&#13;
			<p class="source-code">  displayName: 'Copy files to shared network'</p>&#13;
			<p class="source-code">  inputs:</p>&#13;
			<p class="source-code">    SourceFolder: '$(Build.SourcesDirectory)'</p>&#13;
			<p class="source-code">    Contents: '**'</p>&#13;
			<p class="source-code">    TargetFolder: '\\networkserver\storage\$(Build.BuildNumber)'</p>&#13;
			<p class="callout-heading">Important Note</p>&#13;
			<p class="callout">Remember that any data saved as artifacts with the <strong class="bold">Publish Build Artifacts</strong> task is periodically deleted.</p>&#13;
			<p>More<a id="_idIndexMarker322"/> information <a id="_idIndexMarker323"/>about the <strong class="bold">Copy files</strong> task can be found here:</p>&#13;
			<p><a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/utility/copy-files?view=azure-devops&amp;tabs=yaml">https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/utility/copy-files?view=azure-devops&amp;tabs=yaml</a>.</p>&#13;
			<h1 id="_idParaDest-105"><a id="_idTextAnchor116"/>Multi-stage pipeline</h1>&#13;
			<p>As we explained previously, you can organize the jobs in your pipeline into <strong class="source-inline">stages</strong>. <strong class="source-inline">Stages</strong> are logical boundaries inside a pipeline flow (units of works that you can assign to an agent) that allow you to isolate the work, pause the pipeline, and execute checks or other actions. By default, every pipeline is composed of one stage, but you can create more than one and arrange those<a id="_idIndexMarker324"/> stages into a dependency graph. </p>&#13;
			<p>The basic YAML definition of a multi-stage pipeline is as follows:</p>&#13;
			<p class="source-code">stages:  </p>&#13;
			<p class="source-code">	- stage: Build  </p>&#13;
			<p class="source-code">	  jobs:  </p>&#13;
			<p class="source-code">	  - job: BuildJob  </p>&#13;
			<p class="source-code">	    steps:  </p>&#13;
			<p class="source-code">	    - script: echo Build!  </p>&#13;
			<p class="source-code">	- stage: Test  </p>&#13;
			<p class="source-code">	  jobs:  </p>&#13;
			<p class="source-code">	  - job: TestOne  </p>&#13;
			<p class="source-code">	    steps:  </p>&#13;
			<p class="source-code">	    - script: echo Test 1  </p>&#13;
			<p class="source-code">	  - job: TestTwo </p>&#13;
			<p class="source-code">	    steps:  </p>&#13;
			<p class="source-code">	    - script: echo Test 2  </p>&#13;
			<p class="source-code">	- stage: Deploy  </p>&#13;
			<p class="source-code">	  jobs:  </p>&#13;
			<p class="source-code">	  - job: Deploy  </p>&#13;
			<p class="source-code">	    steps:  </p>&#13;
			<p class="source-code">	    - script: echo Deployment</p>&#13;
			<p>As an example of how to<a id="_idIndexMarker325"/> create a multi-stage pipeline with YAML, let's look at a pipeline that builds code in your repository (with .NET Core SDK) and publishes the artifacts as NuGet packages. The pipeline definition is as follows. The pipeline uses the <strong class="source-inline">stages</strong> keyword to identify that this is a multi-stage pipeline.</p>&#13;
			<p>In the first stage definition (<strong class="source-inline">Build</strong>), we have the tasks for building the code:</p>&#13;
			<p class="source-code">trigger:</p>&#13;
			<p class="source-code">	- master</p>&#13;
			<p class="source-code">	stages:</p>&#13;
			<p class="source-code">	- stage: 'Build'</p>&#13;
			<p class="source-code">	  variables:</p>&#13;
			<p class="source-code">	    buildConfiguration: 'Release'</p>&#13;
			<p class="source-code">	  jobs:</p>&#13;
			<p class="source-code">	  - job:</p>&#13;
			<p class="source-code">	    pool:</p>&#13;
			<p class="source-code">	      vmImage: 'ubuntu-latest'</p>&#13;
			<p class="source-code">	    workspace:</p>&#13;
			<p class="source-code">	      clean: all</p>&#13;
			<p class="source-code">	    steps:</p>&#13;
			<p class="source-code">	    - task: UseDotNet@2</p>&#13;
			<p class="source-code">	      displayName: 'Use .NET Core SDK'</p>&#13;
			<p class="source-code">	      inputs:</p>&#13;
			<p class="source-code">	        packageType: sdk</p>&#13;
			<p class="source-code">	        version: 2.2.x</p>&#13;
			<p class="source-code">	        installationPath: $(Agent.ToolsDirectory)/dotnet</p>&#13;
			<p class="source-code">	    </p>&#13;
			<p class="source-code">	    - task: DotNetCoreCLI@2</p>&#13;
			<p class="source-code">	      displayName: "NuGet Restore"</p>&#13;
			<p class="source-code">	      inputs:</p>&#13;
			<p class="source-code">	        command: restore</p>&#13;
			<p class="source-code">	        projects: '**/*.csproj'</p>&#13;
			<p class="source-code">	    - task: DotNetCoreCLI@2</p>&#13;
			<p class="source-code">	      displayName: "Build Solution"</p>&#13;
			<p class="source-code">	      inputs:</p>&#13;
			<p class="source-code">	        command: build</p>&#13;
			<p class="source-code">	        projects: '**/*.csproj'</p>&#13;
			<p class="source-code">	        arguments: '--configuration (buildConfiguration)'</p>&#13;
			<p>Here, we installed the .NET Core SDK by<a id="_idIndexMarker326"/> using the <strong class="bold">UseDotnet</strong> standard task template that's available in Azure DevOps (more information can be found here: <a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/tool/dotnet-core-tool-installer?view=azure-devops)">https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/tool/dotnet-core-tool-installer?view=azure-devops)</a>. After that, we restored the required NuGet packages and built the solution.</p>&#13;
			<p>Now, we have the task of creating the release version of the NuGet package. This package is saved in the packages/release folder of the artifact staging directory. Here, we will use <strong class="source-inline">nobuild = true</strong> because in this task, we do not have to rebuild the solution again (no more compilation):</p>&#13;
			<p class="source-code">    - task: DotNetCoreCLI@2</p>&#13;
			<p class="source-code">      displayName: 'Create NuGet Package - Release Version'</p>&#13;
			<p class="source-code">      inputs:</p>&#13;
			<p class="source-code">        command: pack</p>&#13;
			<p class="source-code">        packDirectory: '$(Build.ArtifactStagingDirectory)/packages/releases'</p>&#13;
			<p class="source-code">        arguments: '--configuration $(buildConfiguration)'</p>&#13;
			<p class="source-code">        nobuild: true</p>&#13;
			<p>As the next step, we have<a id="_idIndexMarker327"/> the task of creating the prerelease version of the NuGet package. In this task, we're using the <strong class="source-inline">buildProperties</strong> option to add the build number to the package version (for example, if the package version is 2.0.0.0 and the build number is 20200521.1, the package version will be 2.0.0.0.20200521.1). Here, a build of the package is mandatory (for retrieving the build ID):</p>&#13;
			<p class="source-code">    - task: DotNetCoreCLI@2</p>&#13;
			<p class="source-code">      displayName: 'Create NuGet Package - Prerelease Version'</p>&#13;
			<p class="source-code">      inputs:</p>&#13;
			<p class="source-code">        command: pack</p>&#13;
			<p class="source-code">        buildProperties: 'VersionSuffix="$(Build.BuildNumber)"'</p>&#13;
			<p class="source-code">        packDirectory: '$(Build.ArtifactStagingDirectory)/packages/prereleases'</p>&#13;
			<p class="source-code">        arguments: '--configuration $(buildConfiguration)'</p>&#13;
			<p>The next task publishes the package as an artifact:</p>&#13;
			<p class="source-code">    - publish: '$(Build.ArtifactStagingDirectory)/packages'</p>&#13;
			<p class="source-code">      artifact: 'packages'</p>&#13;
			<p>Next, we need to define the second stage, called <strong class="source-inline">PublishPrereleaseNuGetPackage</strong>. Here, we skip<a id="_idIndexMarker328"/> the checkout of the repository and the download step downloads the <strong class="source-inline">packages</strong> artifact that we published in the previous build stage. Then, the <strong class="source-inline">NuGetCommand</strong> task publishes the prerelease package to an internal feed in Azure DevOps called <strong class="source-inline">Test</strong>:</p>&#13;
			<p class="source-code">- stage: 'PublishPrereleaseNuGetPackage'</p>&#13;
			<p class="source-code">  displayName: 'Publish Prerelease NuGet Package'</p>&#13;
			<p class="source-code">  dependsOn: 'Build'</p>&#13;
			<p class="source-code">  condition: succeeded()</p>&#13;
			<p class="source-code">  jobs:</p>&#13;
			<p class="source-code">  - job:</p>&#13;
			<p class="source-code">    pool:</p>&#13;
			<p class="source-code">      vmImage: 'ubuntu-latest'</p>&#13;
			<p class="source-code">    steps:</p>&#13;
			<p class="source-code">    - checkout: none</p>&#13;
			<p class="source-code">    - download: current</p>&#13;
			<p class="source-code">      artifact: 'packages'</p>&#13;
			<p class="source-code">    - task: NuGetCommand@2</p>&#13;
			<p class="source-code">      displayName: 'Push NuGet Package'</p>&#13;
			<p class="source-code">      inputs:</p>&#13;
			<p class="source-code">        command: 'push'</p>&#13;
			<p class="source-code">        packagesToPush: '$(Pipeline.Workspace)/packages/prereleases/*.nupkg'</p>&#13;
			<p class="source-code">        nuGetFeedType: 'internal'</p>&#13;
			<p class="source-code">        publishVstsFeed: 'Test'</p>&#13;
			<p>Now, we have to define the third stage, called <strong class="source-inline">PublishReleaseNuGetPackage</strong>, which creates the release <a id="_idIndexMarker329"/>version of our package for NuGet:</p>&#13;
			<p class="source-code">- stage: 'PublishReleaseNuGetPackage'</p>&#13;
			<p class="source-code">  displayName: 'Publish Release NuGet Package'</p>&#13;
			<p class="source-code">  dependsOn: 'PublishPrereleaseNuGetPackage'</p>&#13;
			<p class="source-code">  condition: succeeded()</p>&#13;
			<p class="source-code">  jobs:</p>&#13;
			<p class="source-code">  - deployment:</p>&#13;
			<p class="source-code">    pool:</p>&#13;
			<p class="source-code">      vmImage: 'ubuntu-latest'</p>&#13;
			<p class="source-code">    environment: 'nuget-org'</p>&#13;
			<p class="source-code">    strategy:</p>&#13;
			<p class="source-code">     runOnce:</p>&#13;
			<p class="source-code">       deploy:</p>&#13;
			<p class="source-code">         steps:</p>&#13;
			<p class="source-code">         - task: NuGetCommand@2</p>&#13;
			<p class="source-code">           displayName: 'Push NuGet Package'</p>&#13;
			<p class="source-code">           inputs:</p>&#13;
			<p class="source-code">             command: 'push'</p>&#13;
			<p class="source-code">             packagesToPush: '$(Pipeline.Workspace)/packages/releases/*.nupkg'</p>&#13;
			<p class="source-code">             nuGetFeedType: 'external'</p>&#13;
			<p class="source-code">             publishFeedCredentials: 'NuGet'</p>&#13;
			<p>This stage uses a deployment job to publish the package to the configured environment (here, this is called <strong class="source-inline">nuget-org</strong>). An environment is a collection of resources inside a pipeline.</p>&#13;
			<p>In the <strong class="source-inline">NuGetCommand</strong> task, we<a id="_idIndexMarker330"/> specify the package to push and that the feed where we're pushing the package to is external (<strong class="source-inline">nuGetFeedType</strong>). The feed is retrieved by using the <strong class="source-inline">publishFeedCredentials</strong> property, set to the name of the service connection we created.</p>&#13;
			<p>For this stage, we have created a new environment:</p>&#13;
			<div>&#13;
				<div id="_idContainer155" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_041.jpg" alt="Figure 4.41 – Creating a new environment&#13;&#10;" width="870" height="550"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.41 – Creating a new environment</p>&#13;
			<p>Once the environment has been created, in order to publish it to NuGet, you need to create a new service connection by going to <strong class="bold">Project Settings </strong>| <strong class="bold">Service Connections </strong>| <strong class="bold">Create Service Connection</strong>, selecting <strong class="bold">NuGet</strong> from the list of available service connection types, and then configuring the connections according to your NuGet account:</p>&#13;
			<div>&#13;
				<div id="_idContainer156" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_042.jpg" alt="Figure 4.42 – New NuGet service connection&#13;&#10;" width="634" height="932"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.42 – New NuGet service connection</p>&#13;
			<p>With that, we have created a multi-stage build pipeline. When the pipeline is executed and all the stages terminate <a id="_idIndexMarker331"/>successfully, you will see a results diagram that looks as follows:</p>&#13;
			<div>&#13;
				<div id="_idContainer157" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_043.jpg" alt="Figure 4.43 – Multi-stage build pipeline executed&#13;&#10;" width="827" height="192"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.43 – Multi-stage build pipeline executed</p>&#13;
			<p>Now that we have understood what a multi-stage pipeline is, we'll create some pipelines with GitHub repositories in the next section.</p>&#13;
			<h1 id="_idParaDest-106"><a id="_idTextAnchor117"/>Building a pipeline with GitHub repositories</h1>&#13;
			<p>GitHub is one of the most<a id="_idIndexMarker332"/> popular platforms for source control management and often, it's quite common to have scenarios where the<a id="_idIndexMarker333"/> code is stored inside a GitHub repository and you want to use Azure DevOps for managing CI/CD.</p>&#13;
			<p>By using <a id="_idIndexMarker334"/>Azure DevOps and the Azure Pipeline service, you can also create pipelines for a repository stored on GitHub, thus triggering a build pipeline on every commit in a branch inside the GitHub repository. We will do this by following these steps:</p>&#13;
			<ol>&#13;
				<li value="1">To use Azure Pipelines to build your GitHub repository, you need to add the <strong class="bold">Azure DevOps</strong> extension to your GitHub account. From your GitHub page, select the <strong class="bold">Marketplace</strong> link from the top bar and search for <strong class="source-inline">Azure Pipelines</strong>. Select the <strong class="bold">Azure Pipelines</strong> extension and click on <strong class="bold">Set up a plan</strong>, as shown in the following screenshot:<div id="_idContainer158" class="IMG---Figure"><img src="Images/B16392_04_044.jpg" alt="Figure 4.44 – Azure Pipelines on GitHub – setup&#13;&#10;" width="1253" height="481"/></div><p class="figure-caption">Figure 4.44 – Azure Pipelines on GitHub – setup</p></li>&#13;
				<li>Select the <strong class="bold">Free</strong> plan, click the <strong class="bold">Install it for free</strong> button, and then click <strong class="bold">Complete order and begin installation</strong>.</li>&#13;
				<li>Now, the Azure <a id="_idIndexMarker335"/>Pipelines installation will ask you if this app should be available for all your repositories or only for selected repositories. Select the desired option and click on <strong class="bold">Install</strong>:<div id="_idContainer159" class="IMG---Figure"><img src="Images/B16392_04_045.jpg" alt="Figure 4.45 – Azure Pipelines on GitHub – installation &#13;&#10;" width="820" height="1041"/></div><p class="figure-caption">Figure 4.45 – Azure Pipelines on GitHub – installation </p></li>&#13;
				<li>You will now be <a id="_idIndexMarker336"/>redirected to Azure DevOps, where you can create a new project (or select an existing one) for handling the build process. Here, I'm going to create a new project:<div id="_idContainer160" class="IMG---Figure"><img src="Images/B16392_04_046.jpg" alt="Figure 4.46 – Setting up your Azure Pipelines project" width="628" height="797"/></div><p class="figure-caption">Figure 4.46 – Setting up your Azure Pipelines project</p></li>&#13;
				<li>Now, you<a id="_idIndexMarker337"/> need to authorize Azure Pipelines so<a id="_idIndexMarker338"/> that it can access your GitHub account:<div id="_idContainer161" class="IMG---Figure"><img src="Images/B16392_04_047.jpg" alt="Figure 4.47 – Authorizing Azure Pipelines to access GitHub&#13;&#10;" width="838" height="995"/></div><p class="figure-caption">Figure 4.47 – Authorizing Azure Pipelines to access GitHub</p><p>When the necessary <a id="_idIndexMarker339"/>authorization is given, the project will be created for you on Azure DevOps<a id="_idIndexMarker340"/> and the pipeline creation<a id="_idIndexMarker341"/> process will start. You'll be immediately prompted to select a GitHub repository for the build from the list of available GitHub repositories in your account:</p><div id="_idContainer162" class="IMG---Figure"><img src="Images/B16392_04_048.jpg" alt="Figure 4.48 – Selecting a GitHub repository&#13;&#10;" width="716" height="828"/></div><p class="figure-caption">Figure 4.48 – Selecting a GitHub repository</p></li>&#13;
				<li>Here, I'm selecting a repository where I have an Azure Function project. As you can see, Azure Pipelines has recognized my project and proposed a set of available templates for<a id="_idIndexMarker342"/> the pipeline (but you can also start from a blank template or from a YAML file that you have in any branch of the repository). Here, I will select <strong class="bold">.NET Core Function App to Windows on Azure</strong>:<div id="_idContainer163" class="IMG---Figure"><img src="Images/B16392_04_049.jpg" alt="Figure 4.49 – Configuring the pipeline&#13;&#10;" width="788" height="826"/></div><p class="figure-caption">Figure 4.49 – Configuring the pipeline</p><p>A multi-stage <a id="_idIndexMarker343"/>YAML pipeline (Build and Deploy stages) will be<a id="_idIndexMarker344"/> created for you and<a id="_idIndexMarker345"/> saved as a YAML file (<strong class="source-inline">azure-pipelines.yml</strong>) inside your GitHub repository:</p><div id="_idContainer164" class="IMG---Figure"><img src="Images/B16392_04_050.jpg" alt="Figure 4.50 – multi.stage YAML pipeline definition&#13;&#10;" width="988" height="851"/></div><p class="figure-caption">Figure 4.50 – multi.stage YAML pipeline definition</p><p>This pipeline is triggered on every commit <a id="_idIndexMarker346"/>on the master branch.</p></li>&#13;
				<li>Click the <strong class="bold">Save and run</strong> button. Here, the pipeline will be queued and waiting for an agent, then<a id="_idIndexMarker347"/> executed.<p>Every time you commit<a id="_idIndexMarker348"/> code inside your GitHub repository, the build pipeline on Azure DevOps will be triggered automatically.</p><p>If you're building a public repository on GitHub, it's quite useful to show all your users that the code inside this repository has been checked and tested with a build pipeline. Then, you can show the result of the build. You can do that by placing a badge in your repository.</p><p>A badge is a dynamically generated image that reflects the status of a build (never built, success, or fail) and it's hosted on Azure DevOps.</p></li>&#13;
				<li>To do so, select your <a id="_idIndexMarker349"/>pipeline in Azure DevOps, click on the<a id="_idIndexMarker350"/> three dots on the right, and select <strong class="bold">Status badge</strong>:<div id="_idContainer165" class="IMG---Figure"><img src="Images/B16392_04_051.jpg" alt="Figure 4.51 – Status badge definition&#13;&#10;" width="1038" height="332"/></div><p class="figure-caption">Figure 4.51 – Status badge definition</p></li>&#13;
				<li>From here, you can<a id="_idIndexMarker351"/> copy the <strong class="bold">Sample markdown</strong> string and place it in the <strong class="source-inline">Readme.md</strong> file on your GitHub repository:</li>&#13;
			</ol>&#13;
			<div>&#13;
				<div id="_idContainer166" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_052.jpg" alt="Figure 4.52 – Build status badge markdown&#13;&#10;" width="1197" height="394"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.52 – Build status badge markdown</p>&#13;
			<p>Every time a user accesses your repository, they will be able to see the status of the latest build via <a id="_idIndexMarker352"/>a graphical badge:</p>&#13;
			<div>&#13;
				<div id="_idContainer167" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_053.jpg" alt="Figure 4.53 – Build pipeline Status badge&#13;&#10;" width="345" height="127"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.53 – Build pipeline Status badge</p>&#13;
			<p>Next, let's look at how<a id="_idIndexMarker353"/> to execute jobs in <a id="_idIndexMarker354"/>parallel.</p>&#13;
			<h2 id="_idParaDest-107"><a id="_idTextAnchor118"/>Executing jobs in parallel in an Azure Pipeline</h2>&#13;
			<p>Within an Azure Pipeline, you<a id="_idIndexMarker355"/> can also execute jobs in parallel. Each job can be independent of other jobs and can also be executed on a different agent. This will allow you to speed up your<a id="_idIndexMarker356"/> build time and improve your pipeline's performance.</p>&#13;
			<p>As an example of how to handle parallel jobs in a pipeline, consider a simple pipeline where you have to execute three PowerShell scripts called <strong class="bold">Task 1</strong>, <strong class="bold">Task 2</strong>, and <strong class="bold">Final Task</strong>. <strong class="bold">Task 1</strong> and <strong class="bold">Task 2</strong> can be executed in parallel, while <strong class="bold">Final Task</strong> can only be executed when the previous two tasks are completed.</p>&#13;
			<p>When you start creating a new pipeline (I'm using the classic editor here for simplicity), Azure DevOps creates an agent job (here, this is called <strong class="bold">Agent Job 1</strong>). You can add your task to this agent. By selecting the agent job, you can specify the agent pool where this task runs. Here, I want this task to be executed on a Microsoft-hosted agent pool:</p>&#13;
			<div>&#13;
				<div id="_idContainer168" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_054.jpg" alt="Figure 4.54 – Agent specification&#13;&#10;" width="988" height="410"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.54 – Agent specification</p>&#13;
			<p>Then, to add a<a id="_idIndexMarker357"/> new agent pool to your pipeline (for executing the other task independently), click the<a id="_idIndexMarker358"/> three dots beside the pipeline and select <strong class="bold">Add an agent job</strong>:</p>&#13;
			<div>&#13;
				<div id="_idContainer169" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_055.jpg" alt="Figure 4.55 – Add an agent job&#13;&#10;" width="1344" height="548"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.55 – Add an agent job</p>&#13;
			<p>Now, we'll add a second agent job (here, this is called <strong class="bold">Agent job 2</strong>) that runs on a self-hosted agent. This job will execute the <strong class="bold">Task 2</strong> PowerShell script:</p>&#13;
			<div>&#13;
				<div id="_idContainer170" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_056.jpg" alt="Figure 4.56 – Agent selection&#13;&#10;" width="1016" height="424"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.56 – Agent selection</p>&#13;
			<p>Finally, we'll add a new<a id="_idIndexMarker359"/> agent job (here, this is <a id="_idIndexMarker360"/>called <strong class="bold">Agent Job 3)</strong> to execute the <strong class="bold">Final Task</strong> that will run on a Microsoft-hosted agent. However, this job has dependencies from <strong class="bold">Agent Job 1</strong> and <strong class="bold">Agent Job 2</strong>:</p>&#13;
			<div>&#13;
				<div id="_idContainer171" class="IMG---Figure">&#13;
					<img src="Images/B16392_04_057.jpg" alt="Figure 4.57 – Agent job dependencies&#13;&#10;" width="1031" height="848"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.57 – Agent job dependencies</p>&#13;
			<p>In this way, the first two <a id="_idIndexMarker361"/>tasks start in parallel and the final job will wait until the two previous tasks are executed.</p>&#13;
			<p>For more<a id="_idIndexMarker362"/> information about parallel jobs in an Azure pipeline, I recommend that you check out this page:</p>&#13;
			<p><a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/process/phases?view=azure-devops&amp;tabs=yaml">https://docs.microsoft.com/en-us/azure/devops/pipelines/process/phases?view=azure-devops&amp;tabs=yaml</a></p>&#13;
			<h2 id="_idParaDest-108"><a id="_idTextAnchor119"/>Agents on Azure Container Instances</h2>&#13;
			<p>If standard Microsoft-hosted<a id="_idIndexMarker363"/> agents don't fit your needs (requirements, performance, and so on), there's also the possibility to create a self-hosted agent for Azure DevOps that runs inside a Docker container on the <strong class="bold">Azure Container Instances</strong> (<strong class="bold">ACI</strong>) service.</p>&#13;
			<p>You can create a<a id="_idIndexMarker364"/> build agent running on Azure Container Instances by using a custom image or by reusing one of Microsoft's available images.pipe</p>&#13;
			<p>To create a build agent running on ACI, you need to create a <strong class="bold">personal access token</strong> for your Azure DevOps organization. To do so, from your Azure DevOps organization home page, open the user settings (top-right corner) and select <strong class="bold">Personal access tokens</strong>.</p>&#13;
			<p>When you have the personal access token for your agent, you can create an agent on ACI by executing the following command from the Azure CLI (after connecting to your Azure subscription):</p>&#13;
			<p class="source-code">az container create -g RESOURCE_GROUP_NAME -n CONTAINER_NAME --image mcr.microsoft.com/azure-pipelines/vsts-agent --cpu 1 --memory 7 --environment-variables VSTS_ACCOUNT=AZURE_DEVOPS_ACCOUNT_NAME VSTS_TOKEN=PERSONAL_ACCESS_TOKEN VSTS_AGENT=AGENT_NAME VSTS_POOL=Default</p>&#13;
			<p>Here, we have the following:</p>&#13;
			<ul>&#13;
				<li><strong class="source-inline">RESOURCE_GROUP_NAME</strong> is the name of your resource group in Azure where this resource will be created.</li>&#13;
				<li><strong class="source-inline">CONTAINER_NAME</strong> is the name of the ACI container.</li>&#13;
				<li><strong class="source-inline">AZURE_DEVOPS_ACCOUNT_NAME</strong> is the name of your Azure DevOps account.</li>&#13;
				<li><strong class="source-inline">PERSONAL_ACCESS_TOKEN</strong> is the personal access token you created previously.</li>&#13;
				<li><strong class="source-inline">AGENT_NAME</strong> is the name of the build agent that you want to create. This will be displayed on Azure DevOps.</li>&#13;
			</ul>&#13;
			<p>In this command, there are also other two important parameters:</p>&#13;
			<ul>&#13;
				<li><strong class="source-inline">--image</strong> is used to select the name of the Azure Pipelines image for creating your agent, as described here: <a href="https://hub.docker.com/_/microsoft-azure-pipelines-vsts-agent">https://hub.docker.com/_/microsoft-azure-pipelines-vsts-agent</a>.</li>&#13;
				<li><strong class="source-inline">VSTS_POOL</strong> is used to select the agent pool for your build agent.</li>&#13;
			</ul>&#13;
			<p>Remember that you can start and <a id="_idIndexMarker365"/>stop an ACI instance<a id="_idIndexMarker366"/> by using the <strong class="source-inline">az container stop</strong> and <strong class="source-inline">az container start</strong> commands. This can help you save money.</p>&#13;
			<h1 id="_idParaDest-109"><a id="_idTextAnchor120"/>Using container jobs in Azure Pipelines</h1>&#13;
			<p>In this chapter, we<a id="_idIndexMarker367"/> saw that when you create a pipeline, you define jobs, and that when the pipeline is executed, these jobs runs on the host <a id="_idIndexMarker368"/>machine where the agent is installed.</p>&#13;
			<p>If you're using Windows or Linux agents, you can also run a job inside a container (in an isolated way from the host). To run a job inside a container, you need to have Docker installed on the agent and your pipeline must have permission to access the Docker daemon. If you're using Microsoft-hosted agents, running jobs in containers is actually supported on the <strong class="source-inline">windows-2019</strong> and <strong class="source-inline">ubuntu-16.04</strong> pool images.</p>&#13;
			<p>As an example, this is a YAML definition for using a container job in a Windows pipeline:</p>&#13;
			<p class="source-code">pool:</p>&#13;
			<p class="source-code">  vmImage: 'windows-2019'</p>&#13;
			<p class="source-code">container: mcr.microsoft.com/windows/servercore:ltsc2019</p>&#13;
			<p class="source-code">steps:</p>&#13;
			<p class="source-code">- script: date /t</p>&#13;
			<p class="source-code">  displayName: Gets the current date</p>&#13;
			<p class="source-code">- script: dir  </p>&#13;
			<p class="source-code">  workingDirectory: $(Agent.BuildiDirectory)</p>&#13;
			<p class="source-code">  displayName: list the content of a folder</p>&#13;
			<p>As we mentioned previously, to run a job inside a Windows container, you need to use the <strong class="source-inline">windows-2019</strong> image<a id="_idIndexMarker369"/> pool. It's required that the kernel version of the host and the container match, so here, we're using the <strong class="source-inline">ltsc2019</strong> tag to retrieve the container's image.</p>&#13;
			<p>For a Linux-based pipeline, you<a id="_idIndexMarker370"/> need to use the <strong class="source-inline">ubuntu-16.04</strong> image:</p>&#13;
			<p class="source-code">pool:</p>&#13;
			<p class="source-code">  vmImage: 'ubuntu-16.04'</p>&#13;
			<p class="source-code">container: ubuntu:16.04</p>&#13;
			<p class="source-code">steps:</p>&#13;
			<p class="source-code">- script: printenv</p>&#13;
			<p>As you can see, the pipeline creates a container based on the selected image and runs the command (steps) inside that container.</p>&#13;
			<h1 id="_idParaDest-110"><a id="_idTextAnchor121"/>Summary</h1>&#13;
			<p>In this chapter, we provided an overview of the Azure Pipelines service and we saw how to implement a CI/CD process by using Azure DevOps. We also saw how to create a pipeline for code hosted in a repository by using the graphical interface and by using YAML, as well as how to use and create build agents. We then looked at how to create a build pipeline by using the classic editor and by using a YAML definition. We also saw an example of a multi-stage pipeline and how to use Azure DevOps pipelines to build code inside a GitHub repository, before looking at how to use parallel tasks in a build pipeline to improve build performance. Finally, we learned how to create a build agent on Azure Container Instances and how to use a container's jobs.</p>&#13;
			<p>In the next chapter, we'll learn how to execut<a id="_idTextAnchor122"/>e quality tests for our code base in a build pipeline.</p>&#13;
		</div>&#13;
	</div></body></html>