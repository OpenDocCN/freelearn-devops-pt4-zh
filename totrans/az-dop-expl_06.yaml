- en: 'Chapter 4:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Azure DevOps Pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When adopting **Azure DevOps** in your organization, one of the main important
    decisions you must make is how to define the **pipeline** of your development
    process. A pipeline is a company-defined model that describes the steps and actions
    that a code base must support, from building to the final release phase. It's
    a key part of any DevOps architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll learn how to define and use pipelines with Azure DevOps
    for building code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a CI/CD process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of Azure Pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using build agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of the YAML format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a CI/CD pipeline with Azure DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retention of builds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-stage pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build pipeline with GitHub repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using container jobs in Azure Pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow this chapter, you need to have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A valid organization in Azure DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Azure subscription where you can create an Azure VM or a local machine on
    one of these environments so that you can install the build agent software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio or Visual Studio Code as your development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Access to the following GitHub repository for cloning the project: [https://github.com/Microsoft/PartsUnlimited](https://github.com/Microsoft/PartsUnlimited)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a CI/CD process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When adopting DevOps in a company, implementing the right DevOps tools with
    the right DevOps processes is essential and crucial. One of the fundamental flows
    in a DevOps implementation is the **continuous integration** (**CI**) and **continuous
    delivery** (**CD**) process, which can help developers build, test, and distribute
    a code base in a quicker, structured, and safer way.
  prefs: []
  type: TYPE_NORMAL
- en: '**CI** is a software engineering practice where developers in a team integrate
    code modifications in a central repository a few times in a day. When a code modification
    integrated into a particular branch (normally with a pull request, as explained
    in the previous chapter), a new build is triggered in order to check the code
    and detect integration bugs quickly. Also, automatic tests (if available) are
    executed during this phase to check for breakages.'
  prefs: []
  type: TYPE_NORMAL
- en: '**CD** is the process that comes after the CI process. In this process, the
    output of the CI phase is packaged and delivered to the production stage without
    bugs. This is extremely helpful so that we always have a master branch that is
    tested, consistent, and ready to be deployed.'
  prefs: []
  type: TYPE_NORMAL
- en: In DevOps, you can also have a **continuous deployment** process in place, where
    you can automate the deployment of your code modifications to the final production
    environments without manual intervention.
  prefs: []
  type: TYPE_NORMAL
- en: 'The typical DevOps CI/CD loop is represented in the following famous "loop"
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – DevOps CI/CD loop'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – DevOps CI/CD loop
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical CI/CD pipeline implementation contains the following stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Commit stage**: Here, new code modifications are integrated into the code
    base and a set of unit tests are performed in order to check code integrity and
    quality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build stage**: Here, the code is automatically built and then the final results
    of the build process (artifacts) are pushed to the final registry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test stage**: The build code will be deployed to preproduction, where the
    final testing will be performed and then go to production deployment. Here, the
    code is tested by adopting alpha and beta deployments. The alpha deployment stage
    is where developers check the performance of their new builds and the interactions
    between builds. In the Beta deployment stage, developers execute manual testing
    in order to double-check whether the application is working correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Production deployment stage**: This is where the final application, after
    successfully passing all the testing requirements, goes live to the production
    stage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are lots of benefits of implementing a CI/CD process in your organizations.
    The main benefits are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Improved code quality and early bug detection**: By adopting automated tests,
    you can discover bugs and issues at an early stage and fix them accordingly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complete traceability**: The whole build, test, and deployment process is
    tracked and can be analyzed later. This guarantees that you can inspect which
    changes in a particular build are included and the impact that they can have on
    the final tests or release.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Faster testing and release phases**: Automating building and testing of your
    code base on every new commit (or before a release).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the next section, we''ll provide an overview of the service offered by the
    Azure platform for implementing CI/CD: Azure Pipelines.'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of Azure Pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Azure Pipelines** is a cloud service offered by the Azure platform that allows
    you to automate the building, testing, and releasing phases of your development
    life cycle (CI/CD). Azure Pipelines works with any language or platform, it''s
    integrated in Azure DevOps, and you can build your code on Windows, Linux, or
    macOS machines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure Pipelines is free for public projects, while for private projects, you
    have up to 1,800 minutes'' (30 hours) worth of pipelines for free each month.
    More information about pricing can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://azure.microsoft.com/en-us/pricing/details/devops/azure-devops-services/](https://azure.microsoft.com/en-us/pricing/details/devops/azure-devops-services/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some important feature of Azure Pipelines can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It's platform and language independent, which means you can build code on every
    platform using the code base you want.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be integrated with different types of repositories (Azure Repos, GitHub,
    GitHub Enterprise, BitBucket, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lots of extensions (standard and community-driven) are available for building
    your code and for handling custom tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows you to deploy your code to different cloud vendors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can work with containerized applications such as Docker, Azure Container
    Registry, or Kubernetes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use Azure Pipelines, you need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An organization in Azure DevOps, where you can create public or private projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A source code stored in a version control system (such as Azure DevOps Repos
    or GitHub)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Pipelines works with the following schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Azure Pipelines schema'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – Azure Pipelines schema
  prefs: []
  type: TYPE_NORMAL
- en: When your code is committed to a particular branch inside a repository, the
    **build pipeline** engine starts, build and test tasks are executed, and if all
    is successfully completed, your app is built and you have the final output (artifact).
    You can also create a **release pipeline** that takes the output of your build
    and releases it to the target environment (staging or production).
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using Azure Pipelines, you need to create a **pipeline**. A pipeline
    in Azure DevOps can be created in the following two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the Classic interface**: This allows you to select some tasks visually
    from a list of possible tasks. You only need to fill in the parameters for these
    tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using a scripting language called YAML**: The pipeline can be defined by
    creating a YAML file inside your repository with all the needed steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the classic interface can be easier initially, but remember that many
    features are only available on YAML pipelines. A YAML pipeline definition is a
    file, and this can be versioned and controlled just like any other file inside
    a repository. You can easily move the pipeline definition between projects (this
    is not possible with the Classic interface).
  prefs: []
  type: TYPE_NORMAL
- en: 'An Azure Pipeline can be represented as follows (courtesy of Microsoft):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Representation of an Azure Pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – Representation of an Azure Pipeline
  prefs: []
  type: TYPE_NORMAL
- en: A pipeline starts from a **trigger** (a manual trigger, a push inside a repository,
    a pull request, or a schedule). A pipeline is normally composed of one or more
    **stages** (logical separation of concerns in a pipeline, such as building, testing,
    deployment, and so on; they can run in parallel), and each stage contains one
    or more **jobs** (a set of steps that can also run in parallel). Every pipeline
    contains at least one stage if you don't explicitly create it. Each job runs on
    an **agent** (service or piece of software that executes the job). Every step
    is composed of a **task** that performs some action on your code (sequentially).
    The final output of a pipeline is an **artifact** (collection of files or packages
    published by the build).
  prefs: []
  type: TYPE_NORMAL
- en: When creating a pipeline, you need to define a set of jobs and tasks for automating
    your builds (or multi-phased builds). You have native support for testing integration,
    release gates, automatic reporting, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'When defining multiple jobs within a pipeline, these jobs are executed in parallel.
    A pipeline that contains multiple jobs is called a **fan-out** scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Fan-out pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Fan-out pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'A pipeline with multiple jobs in a single stage can be represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re using stages when defining your pipeline, this is what is called
    a fan-out/fan-in scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Fan-out pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – Fan-out pipeline
  prefs: []
  type: TYPE_NORMAL
- en: Here, each stage is a fan-in operation, where all the jobs in the stage (which
    can consist of multiple tasks that run in sequence) must be finished before the
    next stage can be triggered (only one stage can be executing at a time). We'll
    talk about multi-stage pipelines later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding build agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build and deploy your code using Azure Pipelines, you need at least one agent.
    An agent is a service that runs the jobs defined in your pipeline. The execution
    of these jobs can occur directly on the agent's host machine or in containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When defining agents for your pipeline, you have essentially two types of possible
    agents:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Microsoft-hosted agents**: This is a service totally managed by Microsoft
    and it''s cleared on every execution of the pipeline (on each pipeline execution,
    you have a fresh new environment).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Self-hosted agents**: This is a service that you need to set up and manage
    by yourself. This can be a custom virtual machine on Azure or a custom on-premise
    machine inside your infrastructure. In a self-hosted agent, you can install all
    the software you need for your builds, and this is persisted on every pipeline
    execution. A self-hosted agent can be on Windows, Linux, macOS, or in a Docker
    container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft-hosted agents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Microsoft-hosted agents is the simplest way to define an agent for your pipeline.
    Azure Pipelines provides a Microsoft-hosed agent pool by default called **Azure
    Pipelines**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Azure Pipelines default agent pool'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – Azure Pipelines default agent pool
  prefs: []
  type: TYPE_NORMAL
- en: 'By selecting this agent pool, you can create different virtual machine types
    for executing your pipeline. At the time of writing, the available standard agent
    types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 1.1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_1.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 1.1
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these images has its own set of software automatically installed. You
    can install additional tools by using the pre-defined Tool Installer task in your
    pipeline definition. More information can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/?view=azure-devops#tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create a pipeline using a Microsoft-hosted agent, you just need to
    specify the name of the virtual machine image to use for your agent from the preceding
    table. As an example, this is the definition of a hosted agent that''s using Windows
    Server 2019 with a Visual Studio 2019 image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When using a Microsoft-hosted agent, you need to remember the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You cannot sign in on the agent machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The agent runs on a Standard DS2v2 Azure Virtual Machine and you cannot increase
    that capacity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It runs as an administrator user on the Windows platform and as a *passwordless
    sudo* user on the Linux platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For public projects, you have 10 free Microsoft-hosted parallel jobs that can
    run for up to 360 minutes each time, with no overall time limit per month.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For private projects, you have one free parallel job that can run for up to
    60 minutes each time, with the maximum being 1,800 minutes (30 hours) per month.
    If you need more capacity, you can pay for additional parallel jobs. By doing
    this, you can run each job for up to 360 minutes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Microsoft-hosted agent runs in the same Azure geography as your Azure DevOps
    organization, but it's not guaranteed that it will run in the same region too
    (an Azure geography contains one or more regions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-hosted agents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While Microsoft-hosted agents are a SaaS service, self-hosted agents are private
    agents that you can configure as per your needs by using Azure virtual machines
    or directly using your on-premise infrastructure. You are responsible for providing
    all the necessary software and tools to execute your pipeline and you're responsible
    for maintaining and upgrading your agent.
  prefs: []
  type: TYPE_NORMAL
- en: 'A self-hosted agent can be installed on the following platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating a self-hosted agent involves completing the following activities:'
  prefs: []
  type: TYPE_NORMAL
- en: Prepare the environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prepare permissions on Azure DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download and configure the agent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start the agent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These steps are similar for all the environments. Next, we'll learn how to create
    a self-hosted Windows agent.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a self-hosted Windows agent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A self-hosted Windows agent is used to build and deploy applications built on
    top of Microsoft's platforms (such as .NET applications, Azure cloud apps, and
    so on) but also for other types of platforms, such as Java and Android apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step to perform when creating an agent is to register the agent in
    your Azure DevOps organization. To do so, you need to sign into your DevOps organization
    as an administrator and from the **User Settings** menu, click on **Personal access
    tokens**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Personal access tokens'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 – Personal access tokens
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can create a new personal access token for your organization with
    an expiration date and with full access or with a custom defined access level
    (if you select the custom defined scope, you need to select the permission you
    want for each scope). To see the complete list of available scopes, click on the
    **Show all scopes** link at the bottom of this window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Create a new personal access token'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8 – Create a new personal access token
  prefs: []
  type: TYPE_NORMAL
- en: Please check that the **Agent Pools** scope has the **Read & manage** permission
    enabled.
  prefs: []
  type: TYPE_NORMAL
- en: When finished, click on **Create** and then copy the generated token before
    closing the window (it will only be shown once).
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The user that you will be using for the agent must be a user with permissions
    to register the agent. You can check this by going to **Organization Settings**
    | **Agent pools**, selecting the **Default** pool, and clicking on **Security**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you need to download the agent software and configure it. From **Organization
    Settings** | **Agent Pools**, select the **Default** pool and from the **Agents**
    tab, click on **New agent**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Creating a new agent'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_009.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9 – Creating a new agent
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Get the agent** window will open. Select **Windows** as the target platform,
    select **x64** or **x86** as your target agent platform (machine) accordingly,
    and then click on the **Download** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Agent software download page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_010.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.10 – Agent software download page
  prefs: []
  type: TYPE_NORMAL
- en: 'This procedure will download a package (normally called `vsts-agent-win-x64-2.166.4.zip`).
    You need to run this package (`config.cmd`) on the agent machine (an Azure VM
    or your on-premise server, which will act as an agent for your builds):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Agent software package'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.11 – Agent software package
  prefs: []
  type: TYPE_NORMAL
- en: 'The setup will ask you for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The URL of your Azure DevOps organization ([https://dev.azure.com/](https://dev.azure.com/){your-organization})
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The personal access token to use (created previously)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When running the agent (interactively or as a service), it's recommended to
    run it as a service if you want to automate builds.
  prefs: []
  type: TYPE_NORMAL
- en: 'After inserting these parameters, the setup registers the agent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Agent registration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_012.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.12 – Agent registration
  prefs: []
  type: TYPE_NORMAL
- en: To register the agent, you need to insert the agent pool, the agent name, and
    the work folder (you can leave the default value as-is).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you need to decide whether your agent must be executed *interactively* or *as
    a service*. As we mentioned previously, running the agent as a service is recommended,
    but in many cases, the interactive option can be helpful because it gives you
    a console where you can see the status and running UI tests.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, please be aware of the user account you select for running the
    agent. The default account is the built-in Network Service user, but this user
    normally doesn't have all the needed permissions on local folders. Using an administrator
    account can help you solve a lot of problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the setup has been completed successfully, you should see a service running
    on your agent machine and a new agent that pops up on your agent pool in Azure
    DevOps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![4.13 – New agent created'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_013.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 4.13 – New agent created
  prefs: []
  type: TYPE_NORMAL
- en: 'If you select the agent and then go to the **Capabilities** section, you will
    be able to see all its capabilities (OS version, OS architecture, computer name,
    software installed, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – Agent capabilities'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_014.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.14 – Agent capabilities
  prefs: []
  type: TYPE_NORMAL
- en: The agent's capabilities can be automatically discovered by the agent software
    or added by you (user-defined capabilities) if you click on the **Add a new capability**
    action. Capabilities are used by the pipeline engine to redirect a particular
    build to the correct agent according to the required capabilities for the pipeline
    (demands).
  prefs: []
  type: TYPE_NORMAL
- en: When the agent is online, it's ready to accept your code build, which should
    be queued.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you can also install multiple agents on the same machine (for
    example, if you want the possibility to execute core pipelines or handle jobs
    in parallel), but this scenario is only recommended if the agents will not share
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: When to use a Microsoft-hosted or a self-hosted agent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microsoft-hosted agents are normally useful when you have a standard code base
    and you don't need particular software or environment configuration to build your
    code. If you're in this scenario, using a Microsoft-hosted agent is recommended
    because you don't have to worry about creating environments. As an example, if
    you need to build an Azure Function project, normally, you don't have the need
    to install custom software on the build agent and the Microsoft-hosted agent can
    work perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: Self-hosted agents are the way to go when you need a particular environment
    configuration, when you need a particular piece of software or tools installed
    on the agent, and when you need more power for your builds. Self-hosted agents
    are also the way to go when you need to preserve the environment between each
    run of your builds. A self-hosted agent is normally the right choice when you
    need to have better control of your agent or you wish to deploy your build to
    on-premise environments (not accessible externally). It also normally allows you
    to save money.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've discussed about the possible build agents that you can use for
    your build pipelines, in the next section, we'll provide an overview of YAML,
    the scripting language that allows you to define a pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the YAML language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**YAML**, an acronym for **YAML Ain''t Markup Language**, is a human-readable
    scripting language used for data serialization and normally used for handling
    configurations definitions for applications. It can be considered a superset of
    JSON.'
  prefs: []
  type: TYPE_NORMAL
- en: YAML uses indentation for handling the structure of the object's definitions,
    and it's insensitive to quotation marks and braces. It's simply a data representation
    language and is not used for executing commands.
  prefs: []
  type: TYPE_NORMAL
- en: With Azure DevOps, YAML is extremely important because it allows you to define
    a pipeline by using a script definition instead of a graphical interface (that
    cannot be ported between projects).
  prefs: []
  type: TYPE_NORMAL
- en: 'The official YAML website can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://yaml.org/](http://yaml.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'A YAML structure is based on key-value elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Key: Value # This is a comment`'
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we'll learn how to define objects in YAML.
  prefs: []
  type: TYPE_NORMAL
- en: Scalars
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an example, the following are scalar variables that have been defined in
    YAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also define multi-line keys by using `?`, followed by a space, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Collections and lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a YAML definition for a collection object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also define nested collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can define a `Dictionary` object by using YAML in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Document structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'YAML uses three dashes, `---`, to separate directives from document content
    and to identify the start of a document. As an example, the following YAML defines
    two documents in a single file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Complex object definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an example of how to define a complex object in YAML, the following is the
    representation used for an `Invoice` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've provided a quick overview of the YAML syntax, in the next section,
    we'll learn how to create a build pipeline with Azure DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a build pipeline with Azure DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a build pipeline in place is a fundamental step if you want to implement
    continuous integration for your code (having your code automatically built and
    tested on every commit).
  prefs: []
  type: TYPE_NORMAL
- en: The prerequisite to creating a build pipeline with Azure DevOps is obviously
    to have some code stored inside a repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a build pipeline with Azure DevOps, you need to go to the **Pipelines**
    hub and select the **Pipelines** action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – Build pipeline creation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_015.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.15 – Build pipeline creation
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, you can create a new build pipeline by selecting the **New pipeline**
    button. When pressed, you will see the following screen, which asks you for a
    code repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Selecting a repository'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_016.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.16 – Selecting a repository
  prefs: []
  type: TYPE_NORMAL
- en: 'This screen is extremely important. From here, you can start creating a build
    pipeline in two possible ways (described previously):'
  prefs: []
  type: TYPE_NORMAL
- en: Using a YAML file to create your pipeline definition. This is what happens when
    you select the repository in this window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the classic editor (graphical user interface). This is what happens when
    you click on the **Use the classic editor** link at the bottom of this page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next section, we'll learn how to create a build pipeline by using these
    two methods.
  prefs: []
  type: TYPE_NORMAL
- en: Pipeline definition with the classic editor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The classic editor permits you to define a build pipeline for your project graphically
    by selecting pre-defined actions. As we mentioned previously, a pipeline definition
    created in this way is not under source control.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on the **Use the classic editor** link, you need to select the
    repository where your code is stored (**Azure Repos Git**, **GitHub**, **GitHub
    Enterprise Server**, **Subversion**, **TFVC**, **Bitbucket Cloud**, or **Other
    Git**) and the branch that the build pipeline will be connected to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17 – Classic editor pipeline definition'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_017.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.17 – Classic editor pipeline definition
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you need to choose a template for the kind of app you''re building. You
    have a set of predefined templates to choose from (that you can customize later),
    but you can also start from an empty template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18 – Pipeline template selection'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_018.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.18 – Pipeline template selection
  prefs: []
  type: TYPE_NORMAL
- en: If predefined templates fit your needs, you can start by using them; otherwise,
    it's recommended to create a custom pipeline by selecting the actions you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, my application that''s stored in the Azure DevOps project repository
    is an ASP.NET web application (an e-commerce website project called `PartsUnlimited`;
    you can find the public repository at the following URL: [https://github.com/Microsoft/PartsUnlimited](https://github.com/Microsoft/PartsUnlimited)),
    so I''ve selected the ASP.NET template.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When selected, this is the pipeline template that will be created for you automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19 – Pipeline created from a template'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_019.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.19 – Pipeline created from a template
  prefs: []
  type: TYPE_NORMAL
- en: Let's check every section of the pipeline in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pipeline (here, this is called `PartsUnlimited-demo-pipeline`) runs on
    a Microsoft-hosted agent (Azure Pipelines agent pool) based on the **vs2017-win2016**
    template (Windows Server 2016 with Visual Studio 2017), as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.20 – Agent specification on the pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_020.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.20 – Agent specification on the pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'The agent job starts by installing the NuGet package manager and restoring
    the required packages for building the project in the selected repository. For
    these actions, the pipeline definition contains the tasks that you can see in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.21 – NuGet tasks'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_021.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.21 – NuGet tasks
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, there''s a task for building the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.22 – Build solution task'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_022.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.22 – Build solution task
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s also a task for testing the solution and publishing the test results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.23 – Test Assemblies task'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_023.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.23 – Test Assemblies task
  prefs: []
  type: TYPE_NORMAL
- en: 'The last steps are for publishing the sources of the build process as artifacts
    (output of the build):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.24 – Publishing tasks'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_024.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.24 – Publishing tasks
  prefs: []
  type: TYPE_NORMAL
- en: 'If you select the **Variables** tab, you will see that there are some parameters
    that are used during the build process. Here, you can create your own variables
    to use inside the pipeline if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.25 – Pipeline variables'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_025.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.25 – Pipeline variables
  prefs: []
  type: TYPE_NORMAL
- en: 'The next section is called **Triggers**. Here, you can define what triggers
    start your pipeline. By default, no triggers are published initially, but here,
    you can enable CI to automatically start your pipeline on every commit on the
    selected branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.26 – Pipeline triggers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_026.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.26 – Pipeline triggers
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Enabling CI is a recommended practice if you want every piece of code that's
    committed on a branch (for example, on the **master** branch) to always be tested
    and safely controlled. In this way, you can be assured that the code is always
    working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Option** tab, you can set some options related to your build definition.
    For example, here, you can create links to all the work items so that they''re
    linked to associated changes when a build completes successfully, create work
    items on failure of a build, set the status badge for your pipeline, specify timeouts,
    and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.27 – Pipeline options'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_027.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.27 – Pipeline options
  prefs: []
  type: TYPE_NORMAL
- en: The **Retention** tab, on the other hand, is used for configuring the retention
    policy for this specific pipeline (how many days to keep artifacts for, the number
    of days to keep runs and pull requests for, and so on). Doing this will override
    the general retention settings. We'll talk about them later in the *Retention
    of builds* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve finished defining the pipeline, you can click **Save & queue**
    to save your definition. By clicking on **Save and run**, the pipeline will be
    placed in a queue and wait for an agent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.28 – Run pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_028.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.28 – Run pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'When the agent is found, the pipeline is executed and your code is built:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.29 – Pipeline execution starting'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_029.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.29 – Pipeline execution starting
  prefs: []
  type: TYPE_NORMAL
- en: 'You can follow the execution of each step of the pipeline and see the related
    logs. If the pipeline ends successfully, you can view a summary of its execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.30 – Pipeline – final result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_030.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.30 – Pipeline – final result
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also select the **Tests** tab to review the test execution status:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.31 – Pipeline tests result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_031.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.31 – Pipeline tests result
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll learn how to create a YAML pipeline for this application.
  prefs: []
  type: TYPE_NORMAL
- en: YAML pipeline definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As previously explained, when you start creating a build pipeline with Azure
    DevOps, the wizard creates a YAML-based pipeline by default.
  prefs: []
  type: TYPE_NORMAL
- en: To start creating a YAML pipeline, go to the **Pipeline** section in Azure DevOps
    and click on **New Pipeline**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, instead of selecting the classic editor (as we did in the previous section),
    just select the type of repository where your code is located (**Azure Repos Git**,
    **GitHub**, **BitBucket**, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.32 – YAML pipeline definition'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_032.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.32 – YAML pipeline definition
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, select your repository from the available repositories list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.33 – YAML pipeline – repository selection'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_033.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.33 – YAML pipeline – repository selection
  prefs: []
  type: TYPE_NORMAL
- en: 'The system now analyzes your repository and proposes a set of available templates
    according to the code stored in the repository itself. You can start from a blank
    YAML template or you can select a template. Here, I''m selecting the ASP.NET template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.34 – YAML pipeline – template selection'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_034.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.34 – YAML pipeline – template selection
  prefs: []
  type: TYPE_NORMAL
- en: 'The system creates a YAML file (called `azure-pipelines.yml`), as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.35 – YAML pipeline definition'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_035.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.35 – YAML pipeline definition
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated YAML definition contains a set of tasks, just like in the previous
    example, but here, these tasks are in their YAML definition. The complete generated
    file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the YAML file contains the trigger that starts the pipeline
    (here, this is a commit on the master branch), the agent pool to use, the pipeline
    variables, and the sequence of each task to execute (with its specific parameters).
  prefs: []
  type: TYPE_NORMAL
- en: Click on Save and run as shown in the previous screenshot to queue the pipeline
    and have it executed. The following screenshot shows the executed YAML pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.36 – YAML pipeline executed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_036.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.36 – YAML pipeline executed
  prefs: []
  type: TYPE_NORMAL
- en: 'To add new tasks, it''s useful to use the assistant tool on the right of the
    editor frame. It allows you to have a **Tasks** list where you can search for
    a task, fill in the necessary parameters, and then have the final YAML definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.37 – YAML pipeline task selection'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_037.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.37 – YAML pipeline task selection
  prefs: []
  type: TYPE_NORMAL
- en: 'When you choose to create a pipeline with YAML, Azure DevOps creates a file
    that''s stored in the same repository that your code is stored in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.38 – YAML pipeline file created'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_038.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.38 – YAML pipeline file created
  prefs: []
  type: TYPE_NORMAL
- en: This file is under source control and versioned on every modification.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a complete reference to the YAML schema for a pipeline, I suggest following
    this link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devops&tabs=schema%2Cparameter-schema](https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devops&tabs=schema%2Cparameter-schema.)'
  prefs: []
  type: TYPE_NORMAL
- en: Retention of builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you run a pipeline, Azure DevOps logs each step's execution and stores
    the final artifacts and tests for each run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure DevOps has a default retention policy for pipeline execution of 30 days.
    You can change these default values by going to **Project settings** | **Pipelines**
    | **Settings**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.39 – Pipeline retention policy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_039.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.39 – Pipeline retention policy
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the **Copy files** task to store your build and artifacts
    data in external storage so that you can preserve them for longer than what''s
    specified in the retention policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.40 – Copy files task'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_040.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.40 – Copy files task
  prefs: []
  type: TYPE_NORMAL
- en: 'The YAML definition for this task is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that any data saved as artifacts with the **Publish Build Artifacts**
    task is periodically deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'More information about the **Copy files** task can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/utility/copy-files?view=azure-devops&tabs=yaml](https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/utility/copy-files?view=azure-devops&tabs=yaml).'
  prefs: []
  type: TYPE_NORMAL
- en: Multi-stage pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we explained previously, you can organize the jobs in your pipeline into
    `stages`. `Stages` are logical boundaries inside a pipeline flow (units of works
    that you can assign to an agent) that allow you to isolate the work, pause the
    pipeline, and execute checks or other actions. By default, every pipeline is composed
    of one stage, but you can create more than one and arrange those stages into a
    dependency graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic YAML definition of a multi-stage pipeline is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: As an example of how to create a multi-stage pipeline with YAML, let's look
    at a pipeline that builds code in your repository (with .NET Core SDK) and publishes
    the artifacts as NuGet packages. The pipeline definition is as follows. The pipeline
    uses the `stages` keyword to identify that this is a multi-stage pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first stage definition (`Build`), we have the tasks for building the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we installed the .NET Core SDK by using the **UseDotnet** standard task
    template that''s available in Azure DevOps (more information can be found here:
    [https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/tool/dotnet-core-tool-installer?view=azure-devops)](https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/tool/dotnet-core-tool-installer?view=azure-devops)).
    After that, we restored the required NuGet packages and built the solution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have the task of creating the release version of the NuGet package.
    This package is saved in the packages/release folder of the artifact staging directory.
    Here, we will use `nobuild = true` because in this task, we do not have to rebuild
    the solution again (no more compilation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'As the next step, we have the task of creating the prerelease version of the
    NuGet package. In this task, we''re using the `buildProperties` option to add
    the build number to the package version (for example, if the package version is
    2.0.0.0 and the build number is 20200521.1, the package version will be 2.0.0.0.20200521.1).
    Here, a build of the package is mandatory (for retrieving the build ID):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'The next task publishes the package as an artifact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to define the second stage, called `PublishPrereleaseNuGetPackage`.
    Here, we skip the checkout of the repository and the download step downloads the
    `packages` artifact that we published in the previous build stage. Then, the `NuGetCommand`
    task publishes the prerelease package to an internal feed in Azure DevOps called
    `Test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to define the third stage, called `PublishReleaseNuGetPackage`,
    which creates the release version of our package for NuGet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: This stage uses a deployment job to publish the package to the configured environment
    (here, this is called `nuget-org`). An environment is a collection of resources
    inside a pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: In the `NuGetCommand` task, we specify the package to push and that the feed
    where we're pushing the package to is external (`nuGetFeedType`). The feed is
    retrieved by using the `publishFeedCredentials` property, set to the name of the
    service connection we created.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this stage, we have created a new environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.41 – Creating a new environment'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_041.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.41 – Creating a new environment
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the environment has been created, in order to publish it to NuGet, you
    need to create a new service connection by going to **Project Settings** | **Service
    Connections** | **Create Service Connection**, selecting **NuGet** from the list
    of available service connection types, and then configuring the connections according
    to your NuGet account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.42 – New NuGet service connection'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_042.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.42 – New NuGet service connection
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, we have created a multi-stage build pipeline. When the pipeline
    is executed and all the stages terminate successfully, you will see a results
    diagram that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.43 – Multi-stage build pipeline executed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_043.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.43 – Multi-stage build pipeline executed
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have understood what a multi-stage pipeline is, we'll create some
    pipelines with GitHub repositories in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Building a pipeline with GitHub repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitHub is one of the most popular platforms for source control management and
    often, it's quite common to have scenarios where the code is stored inside a GitHub
    repository and you want to use Azure DevOps for managing CI/CD.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using Azure DevOps and the Azure Pipeline service, you can also create pipelines
    for a repository stored on GitHub, thus triggering a build pipeline on every commit
    in a branch inside the GitHub repository. We will do this by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: To use Azure Pipelines to build your GitHub repository, you need to add the
    `Azure Pipelines`. Select the **Azure Pipelines** extension and click on **Set
    up a plan**, as shown in the following screenshot:![Figure 4.44 – Azure Pipelines
    on GitHub – setup
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16392_04_044.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.44 – Azure Pipelines on GitHub – setup
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the **Free** plan, click the **Install it for free** button, and then
    click **Complete order and begin installation**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the Azure Pipelines installation will ask you if this app should be available
    for all your repositories or only for selected repositories. Select the desired
    option and click on **Install**:![Figure 4.45 – Azure Pipelines on GitHub – installation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16392_04_045.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.45 – Azure Pipelines on GitHub – installation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You will now be redirected to Azure DevOps, where you can create a new project
    (or select an existing one) for handling the build process. Here, I'm going to
    create a new project:![Figure 4.46 – Setting up your Azure Pipelines project](img/B16392_04_046.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.46 – Setting up your Azure Pipelines project
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, you need to authorize Azure Pipelines so that it can access your GitHub
    account:![Figure 4.47 – Authorizing Azure Pipelines to access GitHub
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16392_04_047.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.47 – Authorizing Azure Pipelines to access GitHub
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When the necessary authorization is given, the project will be created for
    you on Azure DevOps and the pipeline creation process will start. You''ll be immediately
    prompted to select a GitHub repository for the build from the list of available
    GitHub repositories in your account:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.48 – Selecting a GitHub repository'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16392_04_048.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.48 – Selecting a GitHub repository
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, I'm selecting a repository where I have an Azure Function project. As
    you can see, Azure Pipelines has recognized my project and proposed a set of available
    templates for the pipeline (but you can also start from a blank template or from
    a YAML file that you have in any branch of the repository). Here, I will select
    `azure-pipelines.yml`) inside your GitHub repository:![Figure 4.50 – multi.stage
    YAML pipeline definition
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16392_04_050.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.50 – multi.stage YAML pipeline definition
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This pipeline is triggered on every commit on the master branch.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the **Save and run** button. Here, the pipeline will be queued and waiting
    for an agent, then executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every time you commit code inside your GitHub repository, the build pipeline
    on Azure DevOps will be triggered automatically.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you're building a public repository on GitHub, it's quite useful to show
    all your users that the code inside this repository has been checked and tested
    with a build pipeline. Then, you can show the result of the build. You can do
    that by placing a badge in your repository.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A badge is a dynamically generated image that reflects the status of a build
    (never built, success, or fail) and it's hosted on Azure DevOps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To do so, select your pipeline in Azure DevOps, click on the three dots on the
    right, and select **Status badge**:![Figure 4.51 – Status badge definition
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16392_04_051.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.51 – Status badge definition
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'From here, you can copy the `Readme.md` file on your GitHub repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.52 – Build status badge markdown'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_052.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.52 – Build status badge markdown
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time a user accesses your repository, they will be able to see the status
    of the latest build via a graphical badge:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.53 – Build pipeline Status badge'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_053.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.53 – Build pipeline Status badge
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's look at how to execute jobs in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Executing jobs in parallel in an Azure Pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within an Azure Pipeline, you can also execute jobs in parallel. Each job can
    be independent of other jobs and can also be executed on a different agent. This
    will allow you to speed up your build time and improve your pipeline's performance.
  prefs: []
  type: TYPE_NORMAL
- en: As an example of how to handle parallel jobs in a pipeline, consider a simple
    pipeline where you have to execute three PowerShell scripts called **Task 1**,
    **Task 2**, and **Final Task**. **Task 1** and **Task 2** can be executed in parallel,
    while **Final Task** can only be executed when the previous two tasks are completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you start creating a new pipeline (I''m using the classic editor here
    for simplicity), Azure DevOps creates an agent job (here, this is called **Agent
    Job 1**). You can add your task to this agent. By selecting the agent job, you
    can specify the agent pool where this task runs. Here, I want this task to be
    executed on a Microsoft-hosted agent pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.54 – Agent specification'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_054.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.54 – Agent specification
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to add a new agent pool to your pipeline (for executing the other task
    independently), click the three dots beside the pipeline and select **Add an agent
    job**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.55 – Add an agent job'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_055.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.55 – Add an agent job
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll add a second agent job (here, this is called **Agent job 2**) that
    runs on a self-hosted agent. This job will execute the **Task 2** PowerShell script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.56 – Agent selection'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_056.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.56 – Agent selection
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll add a new agent job (here, this is called **Agent Job 3)**
    to execute the **Final Task** that will run on a Microsoft-hosted agent. However,
    this job has dependencies from **Agent Job 1** and **Agent Job 2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.57 – Agent job dependencies'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_04_057.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.57 – Agent job dependencies
  prefs: []
  type: TYPE_NORMAL
- en: In this way, the first two tasks start in parallel and the final job will wait
    until the two previous tasks are executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about parallel jobs in an Azure pipeline, I recommend
    that you check out this page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/devops/pipelines/process/phases?view=azure-devops&tabs=yaml](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/phases?view=azure-devops&tabs=yaml)'
  prefs: []
  type: TYPE_NORMAL
- en: Agents on Azure Container Instances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If standard Microsoft-hosted agents don't fit your needs (requirements, performance,
    and so on), there's also the possibility to create a self-hosted agent for Azure
    DevOps that runs inside a Docker container on the **Azure Container Instances**
    (**ACI**) service.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a build agent running on Azure Container Instances by using a
    custom image or by reusing one of Microsoft's available images.pipe
  prefs: []
  type: TYPE_NORMAL
- en: To create a build agent running on ACI, you need to create a **personal access
    token** for your Azure DevOps organization. To do so, from your Azure DevOps organization
    home page, open the user settings (top-right corner) and select **Personal access
    tokens**.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have the personal access token for your agent, you can create an agent
    on ACI by executing the following command from the Azure CLI (after connecting
    to your Azure subscription):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RESOURCE_GROUP_NAME` is the name of your resource group in Azure where this
    resource will be created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONTAINER_NAME` is the name of the ACI container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AZURE_DEVOPS_ACCOUNT_NAME` is the name of your Azure DevOps account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PERSONAL_ACCESS_TOKEN` is the personal access token you created previously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AGENT_NAME` is the name of the build agent that you want to create. This will
    be displayed on Azure DevOps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this command, there are also other two important parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--image` is used to select the name of the Azure Pipelines image for creating
    your agent, as described here: [https://hub.docker.com/_/microsoft-azure-pipelines-vsts-agent](https://hub.docker.com/_/microsoft-azure-pipelines-vsts-agent).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VSTS_POOL` is used to select the agent pool for your build agent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that you can start and stop an ACI instance by using the `az container
    stop` and `az container start` commands. This can help you save money.
  prefs: []
  type: TYPE_NORMAL
- en: Using container jobs in Azure Pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw that when you create a pipeline, you define jobs, and
    that when the pipeline is executed, these jobs runs on the host machine where
    the agent is installed.
  prefs: []
  type: TYPE_NORMAL
- en: If you're using Windows or Linux agents, you can also run a job inside a container
    (in an isolated way from the host). To run a job inside a container, you need
    to have Docker installed on the agent and your pipeline must have permission to
    access the Docker daemon. If you're using Microsoft-hosted agents, running jobs
    in containers is actually supported on the `windows-2019` and `ubuntu-16.04` pool
    images.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, this is a YAML definition for using a container job in a Windows
    pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned previously, to run a job inside a Windows container, you need
    to use the `windows-2019` image pool. It's required that the kernel version of
    the host and the container match, so here, we're using the `ltsc2019` tag to retrieve
    the container's image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a Linux-based pipeline, you need to use the `ubuntu-16.04` image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the pipeline creates a container based on the selected image
    and runs the command (steps) inside that container.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we provided an overview of the Azure Pipelines service and
    we saw how to implement a CI/CD process by using Azure DevOps. We also saw how
    to create a pipeline for code hosted in a repository by using the graphical interface
    and by using YAML, as well as how to use and create build agents. We then looked
    at how to create a build pipeline by using the classic editor and by using a YAML
    definition. We also saw an example of a multi-stage pipeline and how to use Azure
    DevOps pipelines to build code inside a GitHub repository, before looking at how
    to use parallel tasks in a build pipeline to improve build performance. Finally,
    we learned how to create a build agent on Azure Container Instances and how to
    use a container's jobs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn how to execute quality tests for our code base
    in a build pipeline.
  prefs: []
  type: TYPE_NORMAL
