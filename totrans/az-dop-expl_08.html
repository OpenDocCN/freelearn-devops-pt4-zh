<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer199">&#13;
			<p id="_idParaDest-111" class="chapter-number"><a id="_idTextAnchor123"/>Chapter 5:</p>&#13;
			<h1 id="_idParaDest-112"><a id="_idTextAnchor124"/>Running Quality Tests in a Build Pipeline</h1>&#13;
			<p>In the previous chapter, we introduced Azure Pipelines and learned how to implement a CI/CD process using Azure DevOps, GitHub, and containers.</p>&#13;
			<p>In this chapter, we are going to cover how to run quality tests in a build pipeline. We will begin by explaining what the benefits of automatic testing are. Then, we will look at how to run unit tests in a build pipeline, how to perform code coverage testing, and how to view the test results. Finally, we will cover how to use Feature Flags to test code in production.</p>&#13;
			<p>The following topics will be covered in this chapter:</p>&#13;
			<ul>&#13;
				<li>Benefits of automatic testing </li>&#13;
				<li>Introduction to unit testing</li>&#13;
				<li>Running unit tests in a build pipeline </li>&#13;
				<li>Introduction to code coverage testing</li>&#13;
				<li>Performing code coverage testing</li>&#13;
				<li>Assigning test results to work items</li>&#13;
				<li>Introduction to Feature Flags</li>&#13;
				<li>Using Feature Flags to test in production </li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-113"><a id="_idTextAnchor125"/>Technical requirements</h1>&#13;
			<p>To follow this chapter, you need to have an active Azure DevOps organization. The organization that will be used in this chapter is called the Parts Unlimited organization. It was created in <a href="B16392_01_Final_JM_ePub.xhtml#_idTextAnchor027"><em class="italic">Chapter 1</em></a><em class="italic">, Azure DevOps Overview</em>. You also need to have Visual Studio 2019 installed, which can be downloaded from <a href="https://visualstudio.microsoft.com/downloads/">https://visualstudio.microsoft.com/downloads/</a>. For the latest demo, you will need Visual Studio Code with the C# extension installed and the .NET Core SDK, version 3.1 or later.</p>&#13;
			<p>The source code for our sample application can be downloaded from the following link:</p>&#13;
			<p><a href="https://github.com/PacktPublishing/Learning-Azure-DevOps---B16392/tree/master/Chapter%205/RazorFeatureFlags">https://github.com/PacktPublishing/Learning-Azure-DevOps---B16392/tree/master/Chapter%205/RazorFeatureFlags</a></p>&#13;
			<h1 id="_idParaDest-114"><a id="_idTextAnchor126"/>Benefits of automatic testing</h1>&#13;
			<p>After adding a new<a id="_idIndexMarker371"/> feature to your application, you want to know if it will work correctly, given all the possible interactions. You also don't want to break any other features with this new functionality and want to know if the code is easily understood by others, as well as being maintainable. </p>&#13;
			<p>All of this can be tested manually. But as the project and code base grows over time, testing all these features manually can become repetitive and error-prone. This is where automatic testing comes in.</p>&#13;
			<p>There has always been a great deal of controversy around automatic testing. Many people believe that testing is too expensive to create and maintain. This is indeed true when tests are created badly. But when automatic tests are created properly, it will absolutely lower the amount of time and costs compared to frequent manual testing or releasing poor-quality software. Using automatic testing, your project will benefit from the ability to release software more frequently. It can be reused and run repeatedly, delivering faster results and feedback to the team. The earlier a bug is detected, the more cost-effective it is to fix it. </p>&#13;
			<p>In conjunction with CI, where the code is automatically pushed into production, automatic testing will protect teams from releasing bugs into their software. However, there is a trade-off. Developers need to dedicate more time to writing and maintaining test code. However, by investing this extra time, the outcome will be higher quality code, and code that has been proven to function completely as expected. </p>&#13;
			<p>There are different types of automated testing you can perform; for instance, you can run regression, acceptance, and security tests. In this chapter, we are going to focus on <strong class="bold">development testing</strong>, which<a id="_idIndexMarker372"/> is also used in CI and can be done directly from the build pipeline. </p>&#13;
			<p>Visual Studio and Azure <a id="_idIndexMarker373"/>DevOps both offer features for testing. They are test framework-agnostic, so you can plug in your own framework and bring third-party tools as well. You can easily add test adapters in order to run the tests and explore the results. This can make testing part of your daily software build process.</p>&#13;
			<p>In the upcoming sections, we will cover unit testing and code coverage testing, which is part of development testing. First, we will describe how to run an automatic unit test from a build pipeline, and then how to perform code coverage and UI tests from a build pipeline. </p>&#13;
			<h1 id="_idParaDest-115"><a id="_idTextAnchor127"/>Introduction to unit testing</h1>&#13;
			<p>With <a id="_idIndexMarker374"/>unit testing, you break up code into small pieces, called units, that can be tested independently from each other. These units can consist of classes, methods, or single lines of code. The smaller the better works best here. This will give you a better view of how your code is performing and allows tests to be run fast.</p>&#13;
			<p>In most cases, unit tests are written by the developer that writes the code. There are two different ways of writing unit tests: before you write the actual production code, or after. Most programmers write it afterwards, which is the traditional way of doing things, but if you are using <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>), you will typically write them beforehand. Unit testing<a id="_idIndexMarker375"/> will also make code documentation easier. It encourages better coding practices and you can leave code pieces to describe the code's functionality behind. Here, you will focus more on updating a system of checks. </p>&#13;
			<p>In the next section, we are going to cover how to run unit tests in a build pipeline.</p>&#13;
			<h1 id="_idParaDest-116"><a id="_idTextAnchor128"/>Running unit tests in a build pipeline </h1>&#13;
			<p>Our <strong class="bold">Parts Unlimited</strong> test <a id="_idIndexMarker376"/>project already has unit tests created. So, this<a id="_idIndexMarker377"/> is a good pick for this demo. First, we are going to look at the application and the tests that are created. Therefore, we have to clone the repository to our local filesystem and open the solution in Visual Studio. </p>&#13;
			<h2 id="_idParaDest-117"><a id="_idTextAnchor129"/>Downloading the source code</h2>&#13;
			<p>We are going to create<a id="_idIndexMarker378"/> unit tests for the web application for Parts Unlimited. First, we need to clone the repository from Azure DevOps to our filesystem. This will allow us to add the unit tests to it using Visual Studio Code. Therefore, we must take the following steps:</p>&#13;
			<ol>&#13;
				<li>Open a web browser and navigate to <a href="https://dev.azure.com/">https://dev.azure.com/</a>.</li>&#13;
				<li>Log in with your Microsoft account and select the <strong class="bold">Parts.Unlimited</strong> project. Then, from the left menu, select <strong class="bold">Repos</strong>. This will let you navigate to the source code of the project. </li>&#13;
				<li>From the top-right menu, select <strong class="bold">Clone</strong>:<div id="_idContainer173" class="IMG---Figure"><img src="Images/B16392_05_001.jpg" alt="Figure 5.1 – Search result&#13;&#10;"/></div><p class="figure-caption">Figure 5.1 – Search result</p></li>&#13;
				<li>On the next screen, make sure that <strong class="bold">Clone in Visual Studio</strong> is selected and click the button shown as follows:<div id="_idContainer174" class="IMG---Figure"><img src="Images/B16392_05_002.jpg" alt="Figure 5.2 – Clone repository&#13;&#10;"/></div><p class="figure-caption">Figure 5.2 – Clone repository</p></li>&#13;
				<li>Now, Visual Studio <a id="_idIndexMarker379"/>will open. From here, we will take a brief look at the test classes that are already in the project. For this, open the <strong class="bold">Solution Explorer</strong> window and navigate to <strong class="bold">test</strong> &gt; <strong class="bold">PartsUnlimited.UnitTests</strong>:<div id="_idContainer175" class="IMG---Figure"><img src="Images/B16392_05_003.jpg" alt="Figure 5.3 – Unit test project&#13;&#10;"/></div><p class="figure-caption">Figure 5.3 – Unit test project</p></li>&#13;
				<li>There are different test projects available in this project. Take some time to become familiar with what is actually being tested. The default testing framework for Visual Studio is being used here, which is <strong class="bold">MS Test</strong>.</li>&#13;
				<li>From Visual Studio, you will be able to build and run the application. To do this, press <em class="italic">F5</em>. Alternatively, from <a id="_idIndexMarker380"/>the top menu, select <strong class="bold">Debug</strong> &gt; <strong class="bold">Start Debugging</strong>:<p class="figure-caption">&#13;
</p><div id="_idContainer176" class="IMG---Figure"><img src="Images/B16392_05_004.jpg" alt="Figure 5.4 – Unit test project&#13;&#10;"/></div><p class="figure-caption">Figure 5.4 – Unit test project</p></li>&#13;
				<li>Once the project has been built, the website will look as follows:<div id="_idContainer177" class="IMG---Figure"><img src="Images/B16392_05_005.jpg" alt="Figure 5.5 – Sample website&#13;&#10;"/></div><p class="figure-caption">Figure 5.5 – Sample website</p></li>&#13;
				<li>Go back to Visual<a id="_idIndexMarker381"/> Studio and stop the debugger. </li>&#13;
			</ol>&#13;
			<p>Now that everything is working, we can start creating a build pipeline, which includes running the unit test projects.</p>&#13;
			<h2 id="_idParaDest-118"><a id="_idTextAnchor130"/>Creating the pipeline</h2>&#13;
			<p>To create<a id="_idIndexMarker382"/> the pipeline, we need to go back to Azure DevOps. From there, follow these steps:</p>&#13;
			<ol>&#13;
				<li value="1">From the left-hand menu, select <strong class="bold">Pipelines</strong>.</li>&#13;
				<li>At the top-right of the screen, find and click <strong class="bold">New pipeline</strong>:<div id="_idContainer178" class="IMG---Figure"><img src="Images/B16392_05_006.jpg" alt="Figure 5.6 – Creating a new pipeline&#13;&#10;"/></div><p class="figure-caption">Figure 5.6 – Creating a new pipeline</p></li>&#13;
				<li>The wizard for<a id="_idIndexMarker383"/> creating a build pipeline will appear. On the first screen, select <strong class="bold">Use the classic editor</strong> to create a pipeline using the designer:<div id="_idContainer179" class="IMG---Figure"><img src="Images/B16392_05_007.jpg" alt="Figure 5.7 – Use the classic designer option&#13;&#10;"/></div><p class="figure-caption">&#13;
Figure 5.7 – Use the classic designer option</p></li>&#13;
				<li>On the next <a id="_idIndexMarker384"/>screen, make sure that <strong class="bold">Azure Repos Git</strong> is selected. Keep the default settings as they are and click <strong class="bold">Continue</strong>:<div id="_idContainer180" class="IMG---Figure"><img src="Images/B16392_05_008.jpg" alt="Figure 5.8 – Pipeline source settings&#13;&#10;"/></div><p class="figure-caption">&#13;
Figure 5.8 – Pipeline source settings</p></li>&#13;
				<li>Next, we need to<a id="_idIndexMarker385"/> select a template. Select <strong class="bold">ASP.NET</strong> from the overview and click <strong class="bold">Apply</strong>:<div id="_idContainer181" class="IMG---Figure"><img src="Images/B16392_05_009.jpg" alt="Figure 5.9 – Selecting the ASP.NET template&#13;&#10;"/></div><p class="figure-caption">&#13;
Figure 5.9 – Selecting the ASP.NET template</p></li>&#13;
				<li>With that, the <a id="_idIndexMarker386"/>pipeline will be created. Various tasks are added to the pipeline by default. We are going to use these tasks here. For this demo, we are going to focus on the <strong class="bold">Test Assemblies</strong> task. Click on this task and make sure that version <strong class="bold">2</strong> is selected. Under <strong class="bold">Test selection</strong>, you will see the following settings:<div id="_idContainer182" class="IMG---Figure"><img src="Images/B16392_05_010.jpg" alt="Figure 5.10 – Test selection settings&#13;&#10;"/></div><p class="figure-caption">Figure 5.10 – Test selection settings</p></li>&#13;
				<li>By default, <strong class="bold">Test assemblies</strong> will be selected under <strong class="bold">Select tests using</strong>. Keep that selected. Since we <a id="_idIndexMarker387"/>want to run our unit tests automatically, this is the option we need to choose. Unit tests are usually stored inside an assembly. </li>&#13;
				<li>Also, by default, there are some assemblies already filled in. You can make changes to them if needed. For this demo, we will keep the default settings as they are because the task looks for assemblies in different folders that have <strong class="source-inline">test</strong> in them. Our test project is called <strong class="bold">PartsUnlimited.UnitTests</strong>, so this will be picked up by the task. </li>&#13;
				<li>The search folder is the folder that's used to search for test assemblies. In this case, this is the default working directory. </li>&#13;
				<li>The <strong class="bold">test results</strong> folder <a id="_idIndexMarker388"/>is where test results are stored. The results directory will always be cleaned before the tests are run. </li>&#13;
				<li>We are now ready to run the test. Click on <strong class="bold">Save &amp; queue</strong> from the top menu and then again on the <strong class="bold">Save &amp; queue</strong> sub-menu item to execute the build pipeline:<div id="_idContainer183" class="IMG---Figure"><img src="Images/B16392_05_011.jpg" alt="Figure 5.11 – Executing the build pipeline&#13;&#10;"/></div><p class="figure-caption">Figure 5.11 – Executing the build pipeline</p></li>&#13;
				<li>The wizard for running<a id="_idIndexMarker389"/> the pipeline will open. Here, you can specify a comment and then select an <strong class="bold">Agent Pool</strong>, <strong class="bold">Agent Specification</strong>, and which <strong class="bold">Branch/tag</strong> you would like to use:<div id="_idContainer184" class="IMG---Figure"><img src="Images/B16392_05_012.jpg" alt="Figure 5.12 – Parameters for running a pipeline&#13;&#10;"/></div><p class="figure-caption">Figure 5.12 – Parameters for running a pipeline</p></li>&#13;
				<li>Click <strong class="bold">Save and run</strong> to queue the pipeline. <p>The overview page of the job will be displayed, which is where you can view the status of the execution:</p><div id="_idContainer185" class="IMG---Figure"><img src="Images/B16392_05_013.jpg" alt="Figure 5.13 – Overview of our jobs&#13;&#10;"/></div><p class="figure-caption">Figure 5.13 – Overview of our jobs</p></li>&#13;
				<li>After a couple of<a id="_idIndexMarker390"/> minutes, the pipeline will have completed. From the right-top menu, under <strong class="bold">Tests and coverage</strong>, you will be able to see the pass percentage for the tests for this build. You can click on this to navigate to the test results (alternatively, you can navigate to it by clicking <strong class="bold">Tests</strong> from the top-left menu:<div id="_idContainer186" class="IMG---Figure"><img src="Images/B16392_05_014.jpg" alt="Figure 5.14 – Tests overview&#13;&#10;"/></div><p class="figure-caption">Figure 5.14 – Tests overview</p></li>&#13;
				<li>On the <strong class="bold">Tests</strong> screen, you<a id="_idIndexMarker391"/> will see the number of tests you have, as well as the tests that passed and failed. You can also see the duration of the run from here.</li>&#13;
				<li>At the bottom of the screen, you can filter by specific tests. For instance, you can filter for tests that have been <strong class="bold">Passed</strong>, <strong class="bold">Failed</strong>, and <strong class="bold">Aborted</strong>:</li>&#13;
			</ol>&#13;
			<div>&#13;
				<div id="_idContainer187" class="IMG---Figure">&#13;
					<img src="Images/B16392_05_015.jpg" alt="Figure 5.15 – Test results in more detail&#13;&#10;"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 5.15 – Test results in more detail</p>&#13;
			<p>In this demonstration, we <a id="_idIndexMarker392"/>have created a build pipeline that includes automatic unit testing for our source code. In the next section, we are going to look at code coverage testing.</p>&#13;
			<h1 id="_idParaDest-119"><a id="_idTextAnchor131"/>Introduction to code coverage testing</h1>&#13;
			<p>With code coverage testing, you can measure what source code for an application is going to be tested. Code <a id="_idIndexMarker393"/>coverage testing measures how many lines, blocks, and classes are executed while automated tests, such as unit tests, are running. </p>&#13;
			<p>The more code that's tested, the more confident teams can be about their code changes. By reviewing the outcome of the code coverage tests, teams can identify what code is not covered by these tests. This information is very helpful as it reduces test debt over time.</p>&#13;
			<p>Azure DevOps supports code coverage testing from the build pipeline. The <strong class="bold">Test Assemblies</strong> task allows us to collect code coverage testing results. There is also a separate task, called <strong class="bold">Publish Code Coverage Results</strong>, that can also publish these results. This task offers out-of-the-box support for popular coverage results formats such as Cobertura and JaCoCo.</p>&#13;
			<p class="callout-heading">Important Note</p>&#13;
			<p class="callout">Cobertura and JaCoCo are both Java tools that calculate the percentage of code that's accessed by tests. For more information <a id="_idIndexMarker394"/>about Cobertura, you can refer to <a href="https://cobertura.github.io/cobertura/">https://cobertura.github.io/cobertura/</a>. For more information <a id="_idIndexMarker395"/>about JaCoCo, you can refer to <a href="https://www.eclemma.org/jacoco/">https://www.eclemma.org/jacoco/</a>. </p>&#13;
			<p>In the next section, we are going to look how to perform code coverage testing by using Azure DevOps. </p>&#13;
			<h1 id="_idParaDest-120"><a id="_idTextAnchor132"/>Performing code coverage testing</h1>&#13;
			<p>To perform code<a id="_idIndexMarker396"/> coverage testing, we need to open the build pipeline that we created in the previous demo. Let's get started:</p>&#13;
			<ol>&#13;
				<li value="1">With the build pipeline open, select the <strong class="bold">Edit</strong> button in the right-hand corner:<div id="_idContainer188" class="IMG---Figure"><img src="Images/B16392_05_016.jpg" alt="Figure 5.16 – Editing the pipeline from the previous demo&#13;&#10;"/></div><p class="figure-caption">Figure 5.16 – Editing the pipeline from the previous demo</p></li>&#13;
				<li>Navigate to the <strong class="bold">Test Assemblies</strong> task to open the settings.<p>Under <strong class="bold">Execution</strong> settings, check the <strong class="bold">Code coverage enabled</strong> box:</p><div id="_idContainer189" class="IMG---Figure"><img src="Images/B16392_05_017.jpg" alt="Figure 5.17 – Enabling code coverage testing&#13;&#10;"/></div><p class="figure-caption">Figure 5.17 – Enabling code coverage testing</p></li>&#13;
				<li>Now, <strong class="bold">Save and queue</strong> the build, specify a save comment, and wait until the pipeline is <a id="_idIndexMarker397"/>fully executed. The Visual Studio Test task creates an artifact that contains <strong class="source-inline">.coverage</strong> files that can be downloaded and used for further analysis in Visual Studio.</li>&#13;
				<li>After executing the pipeline, on the overview page of the build, select <strong class="bold">Code Coverage</strong> from the top menu and click on <strong class="bold">Download code coverage results</strong>. A file with the <strong class="source-inline">.coverage</strong> extension will be downloaded to your local filesystem.</li>&#13;
				<li>Double-click the <a id="_idIndexMarker398"/>downloaded file so that it opens in Visual Studio. From here, you can drill down into the different classes and methods to get an overview of the test results:</li>&#13;
			</ol>&#13;
			<div>&#13;
				<div id="_idContainer190" class="IMG---Figure">&#13;
					<img src="Images/B16392_05_018.jpg" alt="Figure 5.18 – Code coverage testing results in Visual Studio"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 5.18 – Code coverage testing results in Visual Studio</p>&#13;
			<p>In this <a id="_idIndexMarker399"/>demonstration, we enabled code coverage testing from our build pipeline. In the next section, we are going to assign these test results to the User Stories.</p>&#13;
			<h1 id="_idParaDest-121"><a id="_idTextAnchor133"/>Assigning test results to work items</h1>&#13;
			<p>Once the test has <a id="_idIndexMarker400"/>run automatically and the build process has<a id="_idIndexMarker401"/> finished, you can assign the results to work items that have been added to the backlog and sprint. For this, you must perform the following steps:</p>&#13;
			<ol>&#13;
				<li value="1">Go back to the build pipeline and select the pipeline that ran last. Click <strong class="bold">Test</strong> from the top menu.</li>&#13;
				<li>For the results table, make sure that <strong class="bold">Passed</strong> is selected and that <strong class="bold">Failed</strong> and <strong class="bold">Aborted</strong> have been deselected:<div id="_idContainer191" class="IMG---Figure"><img src="Images/B16392_05_019.jpg" alt="Figure 5.19 – Selecting all the passed tests&#13;&#10;"/></div><p class="figure-caption">Figure 5.19 – Selecting all the passed tests</p></li>&#13;
				<li>Then, select a <a id="_idIndexMarker402"/>couple of tests. After doing this, from<a id="_idIndexMarker403"/> the top menu, click <strong class="bold">Link</strong>:<div id="_idContainer192" class="IMG---Figure"><img src="Images/B16392_05_020.jpg" alt="Figure 5.20 – Linking the items&#13;&#10;"/></div><p class="figure-caption">Figure 5.20 – Linking the items</p></li>&#13;
				<li>Search for <strong class="source-inline">As a tester</strong> and select the work item that is displayed as a search result:<div id="_idContainer193" class="IMG---Figure"><img src="Images/B16392_05_021.jpg" alt="Figure 5.21 – Selecting the work item&#13;&#10;"/></div><p class="figure-caption">Figure 5.21 – Selecting the work item</p></li>&#13;
				<li>Click <strong class="bold">Associate</strong> to link the work item to the test result. </li>&#13;
				<li>Now, click on one of<a id="_idIndexMarker404"/> the test results that's linked to the <a id="_idIndexMarker405"/>work item. This will show the details for this item. From here, you can click on <strong class="bold">work items</strong> from the top menu. This will display the work item that we linked in the previous step:<div id="_idContainer194" class="IMG---Figure"><img src="Images/B16392_05_022.jpg" alt="Figure 5.22 – Linked work item&#13;&#10;"/></div><p class="figure-caption">&#13;
Figure 5.22 – Linked work item</p></li>&#13;
				<li>By clicking <a id="_idIndexMarker406"/>on that work item, you can look at its<a id="_idIndexMarker407"/> details.</li>&#13;
			</ol>&#13;
			<p>In this demonstration, we covered how to link test results to work items. In the next section, we are going to cover how to use Feature Flags to test in production.</p>&#13;
			<h1 id="_idParaDest-122"><a id="_idTextAnchor134"/>Introduction to Feature Flags</h1>&#13;
			<p>You can use a Feature Flag<a id="_idIndexMarker408"/> to turn features in your code, such as specific methods or sections in your code, on or off. This can be extremely helpful when you want to hide (disable) and expose (enable) features in a solution. Features that are not complete and ready for release yet can be hidden or exposed in the solution. This allows us to test code in production for a subset of users. You can enable the code for a subset of users, for instance, based on the login name of the user and let them test the features before releasing them to others. However, there is a drawback to Feature Flags: they introduce more complexity in your code, so it is better to constrain the number of toggles in your application. </p>&#13;
			<p>The recommended approach when creating Feature Flags is to keep them outside the application. For instance, a web or app configuration file is a good place to add Feature Flags because you can change them easily, without the need to redeploy the application again. </p>&#13;
			<p>In the next section, we are going to implement a Feature Flag in a .NET Core solution. </p>&#13;
			<h1 id="_idParaDest-123"><a id="_idTextAnchor135"/>Using Feature Flags to test in production</h1>&#13;
			<p>In this demonstration, we are <a id="_idIndexMarker409"/>going to create a new .NET Core application in Visual Studio Code. Then, we are going to implement a Feature Flag for this application. </p>&#13;
			<p>We are going to add a very basic Feature Flag that changes the welcome message from <em class="italic">Welcome</em> to <em class="italic">Welcome to Learn Azure DevOps</em>. This is only going to be tested by a subset of users. Therefore, we need to open <strong class="bold">Visual Studio Code</strong> and create a new <strong class="source-inline">Razor</strong> application with .NET Core. I have created a new folder on my local filesystem called <strong class="source-inline">FeatureFlags</strong> for this. Open this folder in Visual Studio Code. Check the next section for the detailed steps.</p>&#13;
			<h2 id="_idParaDest-124"><a id="_idTextAnchor136"/>Creating a new .NET Core application</h2>&#13;
			<p>To create a <a id="_idIndexMarker410"/>new .NET Core application, follow these steps:</p>&#13;
			<ol>&#13;
				<li value="1">With <strong class="bold">Visual Studio Code</strong> open, click on <strong class="bold">Terminal</strong> &gt; <strong class="bold">New terminal</strong> from the top menu.</li>&#13;
				<li>In the Terminal, add the following line of code to create a new project:<p class="source-code"><strong class="bold">dotnet new webapp -o RazorFeatureFlags</strong></p><p class="source-code"><strong class="bold">code -r RazorFeatureFlags</strong></p></li>&#13;
				<li>The newly created project will now open. Open the Terminal once more and add the following line of code to test the project:<p class="source-code"><strong class="bold">dotnet run</strong></p><p>The output of running this code will look as follows:</p><div id="_idContainer195" class="IMG---Figure"><img src="Images/B16392_05_023.jpg" alt="Figure 5.23 – Output in the Terminal&#13;&#10;"/></div><p class="figure-caption">Figure 5.23 – Output in the Terminal</p></li>&#13;
				<li>Navigate to the .NET Core application by clicking on one of the localhost URLs in the Terminal output. You will then see the following:<div id="_idContainer196" class="IMG---Figure"><img src="Images/B16392_05_024.jpg" alt="Figure 5.24 – Running the new project&#13;&#10;"/></div><p class="figure-caption">Figure 5.24 – Running the new project</p></li>&#13;
				<li>The next<a id="_idIndexMarker411"/> step is to add the <strong class="source-inline">Microsoft.FeatureManagement</strong> NuGet package to the project. Therefore, add the following line of code to the Terminal:<p class="source-code"><strong class="bold">dotnet add package Microsoft.FeatureManagement </strong></p></li>&#13;
				<li>Once the package has been installed, open the <strong class="source-inline">Program.cs</strong> class and add the following <strong class="source-inline">using</strong> statement:<p class="source-code"><strong class="bold">using Microsoft.FeatureManagement;</strong></p></li>&#13;
				<li>Now, open the <strong class="source-inline">appsettings.json</strong> file. We are going create a <strong class="source-inline">FeatureManagement</strong> section in this file. Replace the code inside the file with the following:<p class="source-code"><strong class="bold">  {</strong></p><p class="source-code"><strong class="bold">  'Logging': {</strong></p><p class="source-code"><strong class="bold">    'LogLevel': {</strong></p><p class="source-code"><strong class="bold">      'Default': 'Information',</strong></p><p class="source-code"><strong class="bold">      'Microsoft': 'Warning',</strong></p><p class="source-code"><strong class="bold">      'Microsoft.Hosting.Lifetime': 'Information'</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code"><strong class="bold">  },</strong></p><p class="source-code"><strong class="bold">  'FeatureManagement': {</strong></p><p class="source-code"><strong class="bold">    'ChangeBanner': false</strong></p><p class="source-code"><strong class="bold">  },  </strong></p><p class="source-code"><strong class="bold">  'AllowedHosts': '*'</strong></p><p class="source-code"><strong class="bold">}</strong></p></li>&#13;
				<li>Then, open<a id="_idIndexMarker412"/> the <strong class="source-inline">Startup.cs</strong> class. Here, add the <strong class="source-inline">using</strong> statement again and add the following to the <strong class="source-inline">ConfigureServices</strong> method:<p class="source-code"><strong class="bold">public void ConfigureServices(IServiceCollection services)</strong></p><p class="source-code"><strong class="bold">    {</strong></p><p class="source-code"><strong class="bold">        //...</strong></p><p class="source-code"><strong class="bold">        services.AddFeatureManagement();</strong></p><p class="source-code"><strong class="bold">    }</strong></p></li>&#13;
				<li>Now, we can inject this into a controller, for instance. Open the code behind the home page<a id="_idIndexMarker413"/> of the application, which can be found in the <strong class="source-inline">Index.cshtml.cs</strong> file, and add the <strong class="source-inline">using</strong> statement again. Then, replace the <strong class="source-inline">IndexModel</strong> class with the following code:<p class="source-code">public class IndexModel : PageModel</p><p class="source-code">    {</p><p class="source-code">     private readonly IFeatureManager _featureManager;</p><p class="source-code">     public IndexModel(IFeatureManager featureManager)</p><p class="source-code">     {</p><p class="source-code">        _featureManager = featureManager;</p><p class="source-code">     }</p><p class="source-code">     public static string WelcomeMessage { get; set; }</p><p class="source-code">     public async Task OnGetAsync() </p><p class="source-code">     {</p><p class="source-code">        WelcomeMessage = await _featureManager.IsEnabledAsync('ChangeBanner') ? 'Welcome to Learn Azure DevOps' : 'Welcome';</p><p class="source-code"><a id="_idTextAnchor137"/>     }</p><p class="source-code">    }</p><p class="source-code">}</p></li>&#13;
				<li>The <strong class="source-inline">Index.cshtml.cs</strong> class will look as follows:<div id="_idContainer197" class="IMG---Figure"><img src="Images/B16392_05_025.jpg" alt="Figure 5.25 – Overview of the Index.cshtml.cs file&#13;&#10;"/></div><p class="figure-caption">Figure 5.25 – Overview of the Index.cshtml.cs file</p></li>&#13;
				<li>Finally, open<a id="_idIndexMarker414"/> the <strong class="source-inline">Index.cshtml</strong> file and replace the code inside it with the following:<p class="source-code">&lt;div class='text-center'&gt;</p><p class="source-code">    &lt;h1 class='display-4'&gt;@IndexModel.WelcomeMessage&lt;/h1&gt;</p><p class="source-code">    &lt;p&gt;Learn about &lt;a href='https://docs.microsoft.com/aspnet/core'&gt;building Web apps with ASP.NET Core&lt;/a&gt;.&lt;/p&gt;</p><p class="source-code">&lt;/div</p></li>&#13;
				<li>This will inject the welcome message into the web page. </li>&#13;
				<li>Build and run the code by opening a new Terminal window and adding the following line of code to the Terminal:<p class="source-code"><strong class="bold">dotnet run</strong></p></li>&#13;
				<li>Let the application <a id="_idIndexMarker415"/>open in the browser and open the <strong class="source-inline">appsettings.json </strong>file again in Visual Studio Code. Change the <strong class="source-inline">ChangeBanner</strong> Feature Flag to <strong class="bold">true</strong> and reload the website in your browser by pressing <em class="italic">F5</em>. This will result in the following output:</li>&#13;
			</ol>&#13;
			<div>&#13;
				<div id="_idContainer198" class="IMG---Figure">&#13;
					<img src="Images/B16392_05_026.jpg" alt="Figure 5.26 – Welcome message changed based on the Feature Flag provided&#13;&#10;"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 5.26 – Welcome message changed based on the Feature Flag provided</p>&#13;
			<p>In this demonstration, we added some Feature Flags to our application using the <strong class="source-inline">Featuremanagement</strong> NuGet package of Microsoft. Using these Feature Flags, we changed the welcome message for the home page of the application. This concludes this chapter.</p>&#13;
			<h1 id="_idParaDest-125"><a id="_idTextAnchor138"/>Summary</h1>&#13;
			<p>In this chapter, we covered how to run quality tests in a build pipeline in more depth. With this, you can now run unit tests from the build pipeline and execute coverage tests from Azure DevOps. Lastly, we covered how to create Future Flags inside an application that you can use in your future projects as well.</p>&#13;
			<p>In the next chapter, we are going to focus on how to host build agents in Azure Pipelines.</p>&#13;
			<h1 id="_idParaDest-126"><a id="_idTextAnchor139"/>Further reading</h1>&#13;
			<p>Check out the following links for more information about the topics that were covered in this chapter:</p>&#13;
			<ul>&#13;
				<li>Unit test basics: <a href="https://docs.microsoft.com/en-us/visualstudio/test/unit-test-basics?view=vs-2019">https://docs.microsoft.com/en-us/visualstudio/test/unit-test-basics?view=vs-2019</a></li>&#13;
				<li>Run quality tests in your build pipeline by using Azure Pipelines: <a href="https://docs.microsoft.com/en-us/learn/modules/run-quality-tests-build-pipeline/">https://docs.microsoft.com/en-us/learn/modules/run-quality-tests-build-pipeline/</a></li>&#13;
				<li>Explore how to progressively expose your features in production for some or all users: <a href="https://docs.microsoft.com/en-us/azure/devops/migrate/phase-features-with-feature-flags?view=azure-devops">https://docs.microsoft.com/en-us/azure/devops/migrate/phase-features-with-feature-flags?view=azure-devops</a></li>&#13;
			</ul>&#13;
		</div>&#13;
	</div></body></html>