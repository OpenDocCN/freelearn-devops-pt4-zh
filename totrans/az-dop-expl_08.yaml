- en: 'Chapter 5:'
  prefs: []
  type: TYPE_NORMAL
- en: Running Quality Tests in a Build Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced Azure Pipelines and learned how to implement
    a CI/CD process using Azure DevOps, GitHub, and containers.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to cover how to run quality tests in a build pipeline.
    We will begin by explaining what the benefits of automatic testing are. Then,
    we will look at how to run unit tests in a build pipeline, how to perform code
    coverage testing, and how to view the test results. Finally, we will cover how
    to use Feature Flags to test code in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of automatic testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running unit tests in a build pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to code coverage testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing code coverage testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning test results to work items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Feature Flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Feature Flags to test in production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow this chapter, you need to have an active Azure DevOps organization.
    The organization that will be used in this chapter is called the Parts Unlimited
    organization. It was created in [*Chapter 1*](B16392_01_Final_JM_ePub.xhtml#_idTextAnchor027)*,
    Azure DevOps Overview*. You also need to have Visual Studio 2019 installed, which
    can be downloaded from [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
    For the latest demo, you will need Visual Studio Code with the C# extension installed
    and the .NET Core SDK, version 3.1 or later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for our sample application can be downloaded from the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Learning-Azure-DevOps---B16392/tree/master/Chapter%205/RazorFeatureFlags](https://github.com/PacktPublishing/Learning-Azure-DevOps---B16392/tree/master/Chapter%205/RazorFeatureFlags)'
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of automatic testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After adding a new feature to your application, you want to know if it will
    work correctly, given all the possible interactions. You also don't want to break
    any other features with this new functionality and want to know if the code is
    easily understood by others, as well as being maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: All of this can be tested manually. But as the project and code base grows over
    time, testing all these features manually can become repetitive and error-prone.
    This is where automatic testing comes in.
  prefs: []
  type: TYPE_NORMAL
- en: There has always been a great deal of controversy around automatic testing.
    Many people believe that testing is too expensive to create and maintain. This
    is indeed true when tests are created badly. But when automatic tests are created
    properly, it will absolutely lower the amount of time and costs compared to frequent
    manual testing or releasing poor-quality software. Using automatic testing, your
    project will benefit from the ability to release software more frequently. It
    can be reused and run repeatedly, delivering faster results and feedback to the
    team. The earlier a bug is detected, the more cost-effective it is to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: In conjunction with CI, where the code is automatically pushed into production,
    automatic testing will protect teams from releasing bugs into their software.
    However, there is a trade-off. Developers need to dedicate more time to writing
    and maintaining test code. However, by investing this extra time, the outcome
    will be higher quality code, and code that has been proven to function completely
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: There are different types of automated testing you can perform; for instance,
    you can run regression, acceptance, and security tests. In this chapter, we are
    going to focus on **development testing**, which is also used in CI and can be
    done directly from the build pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio and Azure DevOps both offer features for testing. They are test
    framework-agnostic, so you can plug in your own framework and bring third-party
    tools as well. You can easily add test adapters in order to run the tests and
    explore the results. This can make testing part of your daily software build process.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we will cover unit testing and code coverage testing,
    which is part of development testing. First, we will describe how to run an automatic
    unit test from a build pipeline, and then how to perform code coverage and UI
    tests from a build pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With unit testing, you break up code into small pieces, called units, that can
    be tested independently from each other. These units can consist of classes, methods,
    or single lines of code. The smaller the better works best here. This will give
    you a better view of how your code is performing and allows tests to be run fast.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most cases, unit tests are written by the developer that writes the code.
    There are two different ways of writing unit tests: before you write the actual
    production code, or after. Most programmers write it afterwards, which is the
    traditional way of doing things, but if you are using **test-driven development**
    (**TDD**), you will typically write them beforehand. Unit testing will also make
    code documentation easier. It encourages better coding practices and you can leave
    code pieces to describe the code''s functionality behind. Here, you will focus
    more on updating a system of checks.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to cover how to run unit tests in a build
    pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Running unit tests in a build pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our **Parts Unlimited** test project already has unit tests created. So, this
    is a good pick for this demo. First, we are going to look at the application and
    the tests that are created. Therefore, we have to clone the repository to our
    local filesystem and open the solution in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the source code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to create unit tests for the web application for Parts Unlimited.
    First, we need to clone the repository from Azure DevOps to our filesystem. This
    will allow us to add the unit tests to it using Visual Studio Code. Therefore,
    we must take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a web browser and navigate to [https://dev.azure.com/](https://dev.azure.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in with your Microsoft account and select the **Parts.Unlimited** project.
    Then, from the left menu, select **Repos**. This will let you navigate to the
    source code of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the top-right menu, select **Clone**:![Figure 5.1 – Search result
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16392_05_001.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.1 – Search result
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the next screen, make sure that **Clone in Visual Studio** is selected and
    click the button shown as follows:![Figure 5.2 – Clone repository
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16392_05_002.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.2 – Clone repository
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, Visual Studio will open. From here, we will take a brief look at the test
    classes that are already in the project. For this, open the **Solution Explorer**
    window and navigate to **test** > **PartsUnlimited.UnitTests**:![Figure 5.3 –
    Unit test project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16392_05_003.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.3 – Unit test project
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are different test projects available in this project. Take some time
    to become familiar with what is actually being tested. The default testing framework
    for Visual Studio is being used here, which is **MS Test**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From Visual Studio, you will be able to build and run the application. To do
    this, press *F5*. Alternatively, from the top menu, select **Debug** > **Start
    Debugging**:![Figure 5.4 – Unit test project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16392_05_004.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.4 – Unit test project
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the project has been built, the website will look as follows:![Figure 5.5
    – Sample website
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16392_05_005.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.5 – Sample website
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Go back to Visual Studio and stop the debugger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that everything is working, we can start creating a build pipeline, which
    includes running the unit test projects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create the pipeline, we need to go back to Azure DevOps. From there, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the left-hand menu, select **Pipelines**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top-right of the screen, find and click **New pipeline**:![Figure 5.6
    – Creating a new pipeline
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16392_05_006.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.6 – Creating a new pipeline
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The wizard for creating a build pipeline will appear. On the first screen, select
    **Use the classic editor** to create a pipeline using the designer:![Figure 5.7
    – Use the classic designer option
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16392_05_007.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.7 – Use the classic designer option
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the next screen, make sure that **Azure Repos Git** is selected. Keep the
    default settings as they are and click **Continue**:![Figure 5.8 – Pipeline source
    settings
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16392_05_008.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.8 – Pipeline source settings
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we need to select a template. Select **ASP.NET** from the overview and
    click **Apply**:![Figure 5.9 – Selecting the ASP.NET template
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16392_05_009.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.9 – Selecting the ASP.NET template
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With that, the pipeline will be created. Various tasks are added to the pipeline
    by default. We are going to use these tasks here. For this demo, we are going
    to focus on the **Test Assemblies** task. Click on this task and make sure that
    version **2** is selected. Under **Test selection**, you will see the following
    settings:![Figure 5.10 – Test selection settings
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16392_05_010.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.10 – Test selection settings
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By default, **Test assemblies** will be selected under **Select tests using**.
    Keep that selected. Since we want to run our unit tests automatically, this is
    the option we need to choose. Unit tests are usually stored inside an assembly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, by default, there are some assemblies already filled in. You can make
    changes to them if needed. For this demo, we will keep the default settings as
    they are because the task looks for assemblies in different folders that have
    `test` in them. Our test project is called **PartsUnlimited.UnitTests**, so this
    will be picked up by the task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The search folder is the folder that's used to search for test assemblies. In
    this case, this is the default working directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **test results** folder is where test results are stored. The results directory
    will always be cleaned before the tests are run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are now ready to run the test. Click on **Save & queue** from the top menu
    and then again on the **Save & queue** sub-menu item to execute the build pipeline:![Figure
    5.11 – Executing the build pipeline
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16392_05_011.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.11 – Executing the build pipeline
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The wizard for running the pipeline will open. Here, you can specify a comment
    and then select an **Agent Pool**, **Agent Specification**, and which **Branch/tag**
    you would like to use:![Figure 5.12 – Parameters for running a pipeline
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16392_05_012.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.12 – Parameters for running a pipeline
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click **Save and run** to queue the pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The overview page of the job will be displayed, which is where you can view
    the status of the execution:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Overview of our jobs'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16392_05_013.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.13 – Overview of our jobs
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After a couple of minutes, the pipeline will have completed. From the right-top
    menu, under **Tests and coverage**, you will be able to see the pass percentage
    for the tests for this build. You can click on this to navigate to the test results
    (alternatively, you can navigate to it by clicking **Tests** from the top-left
    menu:![Figure 5.14 – Tests overview
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16392_05_014.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.14 – Tests overview
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the **Tests** screen, you will see the number of tests you have, as well
    as the tests that passed and failed. You can also see the duration of the run
    from here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the bottom of the screen, you can filter by specific tests. For instance,
    you can filter for tests that have been **Passed**, **Failed**, and **Aborted**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.15 – Test results in more detail'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_05_015.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.15 – Test results in more detail
  prefs: []
  type: TYPE_NORMAL
- en: In this demonstration, we have created a build pipeline that includes automatic
    unit testing for our source code. In the next section, we are going to look at
    code coverage testing.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to code coverage testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With code coverage testing, you can measure what source code for an application
    is going to be tested. Code coverage testing measures how many lines, blocks,
    and classes are executed while automated tests, such as unit tests, are running.
  prefs: []
  type: TYPE_NORMAL
- en: The more code that's tested, the more confident teams can be about their code
    changes. By reviewing the outcome of the code coverage tests, teams can identify
    what code is not covered by these tests. This information is very helpful as it
    reduces test debt over time.
  prefs: []
  type: TYPE_NORMAL
- en: Azure DevOps supports code coverage testing from the build pipeline. The **Test
    Assemblies** task allows us to collect code coverage testing results. There is
    also a separate task, called **Publish Code Coverage Results**, that can also
    publish these results. This task offers out-of-the-box support for popular coverage
    results formats such as Cobertura and JaCoCo.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Cobertura and JaCoCo are both Java tools that calculate the percentage of code
    that's accessed by tests. For more information about Cobertura, you can refer
    to [https://cobertura.github.io/cobertura/](https://cobertura.github.io/cobertura/).
    For more information about JaCoCo, you can refer to [https://www.eclemma.org/jacoco/](https://www.eclemma.org/jacoco/).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to look how to perform code coverage testing
    by using Azure DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Performing code coverage testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To perform code coverage testing, we need to open the build pipeline that we
    created in the previous demo. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: With the build pipeline open, select the **Edit** button in the right-hand corner:![Figure
    5.16 – Editing the pipeline from the previous demo
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16392_05_016.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.16 – Editing the pipeline from the previous demo
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigate to the **Test Assemblies** task to open the settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under **Execution** settings, check the **Code coverage enabled** box:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.17 – Enabling code coverage testing'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16392_05_017.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.17 – Enabling code coverage testing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, `.coverage` files that can be downloaded and used for further analysis
    in Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After executing the pipeline, on the overview page of the build, select `.coverage`
    extension will be downloaded to your local filesystem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Double-click the downloaded file so that it opens in Visual Studio. From here,
    you can drill down into the different classes and methods to get an overview of
    the test results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.18 – Code coverage testing results in Visual Studio](img/B16392_05_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 – Code coverage testing results in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: In this demonstration, we enabled code coverage testing from our build pipeline.
    In the next section, we are going to assign these test results to the User Stories.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning test results to work items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the test has run automatically and the build process has finished, you
    can assign the results to work items that have been added to the backlog and sprint.
    For this, you must perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go back to the build pipeline and select the pipeline that ran last. Click **Test**
    from the top menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the results table, make sure that **Passed** is selected and that **Failed**
    and **Aborted** have been deselected:![Figure 5.19 – Selecting all the passed
    tests
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16392_05_019.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.19 – Selecting all the passed tests
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, select a couple of tests. After doing this, from the top menu, click **Link**:![Figure
    5.20 – Linking the items
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16392_05_020.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.20 – Linking the items
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Search for `As a tester` and select the work item that is displayed as a search
    result:![Figure 5.21 – Selecting the work item
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16392_05_021.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.21 – Selecting the work item
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click **Associate** to link the work item to the test result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, click on one of the test results that's linked to the work item. This will
    show the details for this item. From here, you can click on **work items** from
    the top menu. This will display the work item that we linked in the previous step:![Figure
    5.22 – Linked work item
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16392_05_022.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.22 – Linked work item
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By clicking on that work item, you can look at its details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this demonstration, we covered how to link test results to work items. In
    the next section, we are going to cover how to use Feature Flags to test in production.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Feature Flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use a Feature Flag to turn features in your code, such as specific
    methods or sections in your code, on or off. This can be extremely helpful when
    you want to hide (disable) and expose (enable) features in a solution. Features
    that are not complete and ready for release yet can be hidden or exposed in the
    solution. This allows us to test code in production for a subset of users. You
    can enable the code for a subset of users, for instance, based on the login name
    of the user and let them test the features before releasing them to others. However,
    there is a drawback to Feature Flags: they introduce more complexity in your code,
    so it is better to constrain the number of toggles in your application.'
  prefs: []
  type: TYPE_NORMAL
- en: The recommended approach when creating Feature Flags is to keep them outside
    the application. For instance, a web or app configuration file is a good place
    to add Feature Flags because you can change them easily, without the need to redeploy
    the application again.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to implement a Feature Flag in a .NET Core
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Using Feature Flags to test in production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this demonstration, we are going to create a new .NET Core application in
    Visual Studio Code. Then, we are going to implement a Feature Flag for this application.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to add a very basic Feature Flag that changes the welcome message
    from *Welcome* to *Welcome to Learn Azure DevOps*. This is only going to be tested
    by a subset of users. Therefore, we need to open `Razor` application with .NET
    Core. I have created a new folder on my local filesystem called `FeatureFlags`
    for this. Open this folder in Visual Studio Code. Check the next section for the
    detailed steps.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new .NET Core application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a new .NET Core application, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: With **Visual Studio Code** open, click on **Terminal** > **New terminal** from
    the top menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Terminal, add the following line of code to create a new project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The newly created project will now open. Open the Terminal once more and add
    the following line of code to test the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of running this code will look as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.23 – Output in the Terminal'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16392_05_023.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.23 – Output in the Terminal
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigate to the .NET Core application by clicking on one of the localhost URLs
    in the Terminal output. You will then see the following:![Figure 5.24 – Running
    the new project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16392_05_024.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.24 – Running the new project
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to add the `Microsoft.FeatureManagement` NuGet package to
    the project. Therefore, add the following line of code to the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the package has been installed, open the `Program.cs` class and add the
    following `using` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, open the `appsettings.json` file. We are going create a `FeatureManagement`
    section in this file. Replace the code inside the file with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, open the `Startup.cs` class. Here, add the `using` statement again and
    add the following to the `ConfigureServices` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can inject this into a controller, for instance. Open the code behind
    the home page of the application, which can be found in the `Index.cshtml.cs`
    file, and add the `using` statement again. Then, replace the `IndexModel` class
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Index.cshtml.cs` class will look as follows:![Figure 5.25 – Overview of
    the Index.cshtml.cs file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16392_05_025.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.25 – Overview of the Index.cshtml.cs file
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, open the `Index.cshtml` file and replace the code inside it with the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will inject the welcome message into the web page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Build and run the code by opening a new Terminal window and adding the following
    line of code to the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let the application open in the browser and open the `appsettings.json` file
    again in Visual Studio Code. Change the `ChangeBanner` Feature Flag to **true**
    and reload the website in your browser by pressing *F5*. This will result in the
    following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.26 – Welcome message changed based on the Feature Flag provided'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16392_05_026.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.26 – Welcome message changed based on the Feature Flag provided
  prefs: []
  type: TYPE_NORMAL
- en: In this demonstration, we added some Feature Flags to our application using
    the `Featuremanagement` NuGet package of Microsoft. Using these Feature Flags,
    we changed the welcome message for the home page of the application. This concludes
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to run quality tests in a build pipeline in
    more depth. With this, you can now run unit tests from the build pipeline and
    execute coverage tests from Azure DevOps. Lastly, we covered how to create Future
    Flags inside an application that you can use in your future projects as well.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to focus on how to host build agents in Azure
    Pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out the following links for more information about the topics that were
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit test basics: [https://docs.microsoft.com/en-us/visualstudio/test/unit-test-basics?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/test/unit-test-basics?view=vs-2019)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run quality tests in your build pipeline by using Azure Pipelines: [https://docs.microsoft.com/en-us/learn/modules/run-quality-tests-build-pipeline/](https://docs.microsoft.com/en-us/learn/modules/run-quality-tests-build-pipeline/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Explore how to progressively expose your features in production for some or
    all users: [https://docs.microsoft.com/en-us/azure/devops/migrate/phase-features-with-feature-flags?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/migrate/phase-features-with-feature-flags?view=azure-devops)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
