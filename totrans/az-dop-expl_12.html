<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer301">&#13;
			<p id="_idParaDest-166" class="chapter-number"><a id="_idTextAnchor180"/>Chapter 8:</p>&#13;
			<h1 id="_idParaDest-167"><a id="_idTextAnchor181"/>Deploying Applications with Azure DevOps</h1>&#13;
			<p>In previous chapters, we saw how you can automate your development processes by using build pipelines for your code. But an important part of the software life cycle is also the release phase. In this chapter, we will cover an overview of release pipelines; we'll see how to create a release pipeline with Azure DevOps and how you can automate and improve the deployment of your solutions by using release approvals and multi-stage pipelines.</p>&#13;
			<p>We will cover the following topics in this chapter:</p>&#13;
			<ul>&#13;
				<li>An overview of release pipelines</li>&#13;
				<li>Creating a release pipeline with Azure DevOps</li>&#13;
				<li>Configuring continuous deployment on a release pipeline</li>&#13;
				<li>Creating a multi-stage release pipeline</li>&#13;
				<li>Using approvals and gates for controlling your release process</li>&#13;
				<li>Using environments and deployment groups</li>&#13;
				<li>Using YAML-based pipelines for release</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-168"><a id="_idTextAnchor182"/>Technical requirements</h1>&#13;
			<p>To follow this chapter, you need to have an active Azure DevOps organization. The organization used in this chapter is the <strong class="bold">PartsUnlimited</strong> organization we created in <a href="B16392_01_Final_JM_ePub.xhtml#_idTextAnchor027"><em class="italic">Chapter 1</em></a>, <em class="italic">Azure DevOps Overview</em>.</p>&#13;
			<h1 id="_idParaDest-169"><a id="_idTextAnchor183"/>An overview of release pipelines</h1>&#13;
			<p><strong class="bold">Release pipelines</strong> permit you <a id="_idIndexMarker585"/>to implement the continuous delivery phase of a <a id="_idIndexMarker586"/>software life cycle. With a release pipeline, you can automate the process of testing and deliver your solutions (committed code) to the final environments or directly to the customer's site (continuous delivery and continuous deployment).</p>&#13;
			<p>With <strong class="bold">continuous delivery</strong>, you deliver <a id="_idIndexMarker587"/>code to a certain environment for testing <a id="_idIndexMarker588"/>or quality control, while <strong class="bold">continuous deployment</strong> is the phase where you release code to a final production environment.</p>&#13;
			<p>A release pipeline can be triggered manually (you decide when you want to deploy your code) or it can be triggered according to events such as a code commit on the master branch, after the completion of a stage (for example, the production testing stage), or according to a schedule.</p>&#13;
			<p>A release pipeline <a id="_idIndexMarker589"/>is normally connected to an <strong class="bold">artifact store</strong> (a deployable component for an application and output of a build). An artifact store contains a set of artifacts for a build (distinct artifact versions), and a release pipeline takes these artifacts and provisions the needed infrastructure and steps for deploying the artifacts.</p>&#13;
			<p>A release pipeline (exactly as we saw in <a href="B16392_04_Final_JM_ePub.xhtml#_idTextAnchor096"><em class="italic">Chapter 4</em></a>, <em class="italic">Understanding Azure DevOps Pipelines</em>, for the build pipeline definition) is composed of different stages (parts of the pipeline that can run independently), and each stage is composed of <strong class="bold">jobs</strong> and <strong class="bold">tasks</strong>.</p>&#13;
			<p>A schema of a release pipeline is as follows:</p>&#13;
			<div>&#13;
				<div id="_idContainer261" class="IMG---Figure">&#13;
					<img src="Images/Figure_8.01_B16392.jpg" alt=""/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 8.1 – Release pipeline schema</p>&#13;
			<p>As you can <a id="_idIndexMarker590"/>see in the preceding diagram, a release pipeline starts from artifacts (the output of a successfully completed build) and then moves between stages, executing jobs and tasks.</p>&#13;
			<p>In Azure DevOps, a release pipeline is executed according to the following steps:</p>&#13;
			<ol>&#13;
				<li>When a deployment request is triggered, Azure Pipelines checks whether a pre-deployment approval phase is required and eventually sends approval notifications to the involved people in a team.</li>&#13;
				<li>When approved, the deployment job is queued and waits for an agent.</li>&#13;
				<li>An agent that is able to run this deployment job picks up the job.</li>&#13;
				<li>The agent downloads the artifacts as specified in the release pipeline definition.</li>&#13;
				<li>The agent runs the tasks defined in the deployment job and creates a log for each step.</li>&#13;
				<li>When the deployment for a stage is completed, Azure Pipelines executes a post-deployment approval (if present).</li>&#13;
				<li>The deployment then goes to the next stage.</li>&#13;
			</ol>&#13;
			<p>In a release pipeline, an artifact is deployed to an <strong class="bold">environment</strong> (where your final application will run), and these environments can be the following:</p>&#13;
			<ul>&#13;
				<li>A machine on your corporate network</li>&#13;
				<li>A virtual machine in the cloud</li>&#13;
				<li>A containerized environment, such as Docker or Kubernetes</li>&#13;
				<li>A managed service, such as Azure App Service</li>&#13;
				<li>A serverless environment, such as Azure Functions</li>&#13;
			</ul>&#13;
			<p>A way to <a id="_idIndexMarker591"/>define an Azure Pipelines environment is with a YAML file, where you can include an environment section that specifies the Azure Pipelines environment where you'll deploy your artifact, or by using the classic UI-based editor</p>&#13;
			<p>In the next section, we'll see how to define a release pipeline with the Azure DevOps UI in detail.</p>&#13;
			<h1 id="_idParaDest-170"><a id="_idTextAnchor184"/>Creating a release pipeline with Azure DevOps</h1>&#13;
			<p>The final <a id="_idIndexMarker592"/>goal for implementing a complete CI/CD process <a id="_idIndexMarker593"/>with DevOps is to automate the deployment of your software to a final environment (for example, the final customer), and to achieve this goal, you <a id="_idIndexMarker594"/>need to create a <strong class="bold">release pipeline</strong>.</p>&#13;
			<p>A release pipeline takes the build artifacts (the result of your build process) and deploys those artifacts to one or more final environments. </p>&#13;
			<p>To create our first release pipeline, we'll use the <strong class="bold">PartsUnlimited</strong> web application project previously deployed on Azure DevOps:</p>&#13;
			<ol>&#13;
				<li value="1">To create a release pipeline with Azure DevOps, click on <strong class="bold">Pipelines</strong> on the left menu, select <strong class="bold">Releases</strong>, and then click on <strong class="bold">New release pipeline</strong>:<div id="_idContainer262" class="IMG---Figure"><img src="Images/Figure_8.02_B16392.jpg" alt="Figure 8.2 – Creating a new release pipeline&#13;&#10;"/></div><p class="figure-caption">Figure 8.2 – Creating a new release pipeline</p></li>&#13;
				<li>In the <strong class="bold">Select a template</strong> list <a id="_idIndexMarker595"/>that appears on the right, you <a id="_idIndexMarker596"/>have a set of available templates for creating releases for different types of applications and platforms. For our application, select <strong class="bold">Azure App Service deployment</strong> and click <strong class="bold">Apply</strong>:<div id="_idContainer263" class="IMG---Figure"><img src="Images/Figure_8.03_B16392.jpg" alt="Figure 8.3 – Release pipeline template selection&#13; &#10;"/></div><p class="figure-caption">Figure 8.3 – Release pipeline template selection</p></li>&#13;
				<li>Now, provide <a id="_idIndexMarker597"/>a name for the stage that will <a id="_idIndexMarker598"/>contain the release tasks. Here, I'm calling it <strong class="source-inline">Deploy to cloud</strong>:<div id="_idContainer264" class="IMG---Figure"><img src="Images/Figure_8.04_B16392.jpg" alt="Figure 8.4 – Stage name&#13;&#10;"/></div><p class="figure-caption">Figure 8.4 – Stage name</p></li>&#13;
				<li>In the <strong class="bold">Stages</strong> section, click on the <strong class="bold">1 job, 1 task</strong> link. Here, you need to provide <a id="_idIndexMarker599"/>the setti<a id="_idTextAnchor185"/>ngs of the <a id="_idIndexMarker600"/>Azure web app environment where your application will be deployed, such as your Azure subscription and the App Service instance (web app) where the code will be deployed:</li>&#13;
			</ol>&#13;
			<div>&#13;
				<div id="_idContainer265" class="IMG---Figure">&#13;
					<img src="Images/Figure_8.05_B16392.jpg" alt="Figure 8.5 – Stage settings&#13;&#10;"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 8.5 – Stage settings</p>&#13;
			<p>You have <a id="_idIndexMarker601"/>now defined the stage of your release pipeline (single-stage). In <a id="_idIndexMarker602"/>the next section, we'll see how to specify the artifacts for your release pipeline.</p>&#13;
			<p>Defining artifacts for a release pipeline</p>&#13;
			<p><strong class="bold">Artifacts</strong> are <a id="_idIndexMarker603"/>all the items (output of a build) that must be deployed in your final environment, and <a id="_idIndexMarker604"/>Azure Pipelines can deploy artifacts that come <a id="_idIndexMarker605"/>from different artifact sources:</p>&#13;
			<ol>&#13;
				<li value="1">To select artifacts, on the main release pipeline screen, click on <strong class="bold">Add an artifact</strong>:<div id="_idContainer266" class="IMG---Figure"><img src="Images/Figure_8.06_B16392.jpg" alt="Figure 8.6 – Adding an artifact to a release pipeline&#13;&#10;"/></div><p class="figure-caption">Figure 8.6 – Adding an artifact to a release pipeline</p></li>&#13;
				<li>In the <strong class="bold">Add an artifact</strong> panel, you have <strong class="bold">Source type</strong> automatically set to <strong class="bold">Build</strong> (this means that you're deploying the output of a build pipeline). Here, you need to select the build pipeline that you want to use as the source (the name or ID of the build pipeline that publishes the artifact; here, I'm using the <strong class="bold">PartsUnlimitedE2E</strong> build pipeline) and the default version (the default version will be deployed <a id="_idIndexMarker606"/>when new releases are created. The version <a id="_idIndexMarker607"/>can be changed for manually created releases at the time of release creation):<div id="_idContainer267" class="IMG---Figure"><img src="Images/Figure_8.07_B16392.jpg" alt="Figure 8.7 – Add an artifact&#13;&#10;"/></div><p class="figure-caption">Figure 8.7 – Add an artifact</p></li>&#13;
				<li>Click on the <strong class="bold">Add</strong> button to save the artifact configuration, and then click on the <strong class="bold">Save</strong> button in the top-right corner to save your release pipeline:</li>&#13;
			</ol>&#13;
			<div>&#13;
				<div id="_idContainer268" class="IMG---Figure">&#13;
					<img src="Images/Figure_8.08_B16392.jpg" alt="Figure 8.8 – Saving a release pipeline&#13;&#10;"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 8.8 – Saving a release pipeline</p>&#13;
			<p>Your <a id="_idIndexMarker608"/>release pipeline is now ready. In the next section, we'll see how <a id="_idIndexMarker609"/>to create the Azure DevOps release process.</p>&#13;
			<h2 id="_idParaDest-171"><a id="_idTextAnchor186"/>Creating the Azure DevOps release</h2>&#13;
			<p>After defining <a id="_idIndexMarker610"/>our release pipeline (stages and artifacts), we <a id="_idIndexMarker611"/>need to create a <strong class="bold">release</strong>. A release is simply a run of your release pipeline:</p>&#13;
			<ol>&#13;
				<li value="1">To create a release, on the release pipeline definition page, click on the <strong class="bold">Create release</strong> button in the top-right corner:<div id="_idContainer269" class="IMG---Figure"><img src="Images/Figure_8.09_B16392.jpg" alt="Figure 8.9 – Creating a release&#13; &#10;"/></div><p class="figure-caption">Figure 8.9 – Creating a release</p></li>&#13;
				<li>On the <strong class="bold">Create a new release</strong> page, accept all the default values (you need to have a successfully completed <a id="_idIndexMarker612"/>build with artifacts created), and <a id="_idIndexMarker613"/>then click on <strong class="bold">Create</strong>:<div id="_idContainer270" class="IMG---Figure"><img src="Images/Figure_8.10_B16392.jpg" alt="Figure 8.10 – Creating a release&#13;&#10;"/></div><p class="figure-caption">Figure 8.10 – Creating a release</p></li>&#13;
				<li>A <a id="_idIndexMarker614"/>new release is now created, and <a id="_idIndexMarker615"/>you will see a green bar indicating that:<div id="_idContainer271" class="IMG---Figure"><img src="Images/Figure_8.11_B16392.jpg" alt="Figure 8.11 – Release created&#13;&#10;"/></div><p class="figure-caption">Figure 8.11 – Release created</p></li>&#13;
				<li>Now, you <a id="_idIndexMarker616"/>can click on the release name (here, it is <strong class="bold">Release-1</strong>) and <a id="_idIndexMarker617"/>you will be redirected to the details of the release process:<div id="_idContainer272" class="IMG---Figure"><img src="Images/Figure_8.12_B16392.jpg" alt="Figure 8.12 – Release details&#13;&#10;"/></div><p class="figure-caption">Figure 8.12 – Release details</p></li>&#13;
				<li>If you <a id="_idIndexMarker618"/>click on the stage, you can see the details <a id="_idIndexMarker619"/>of each step:</li>&#13;
			</ol>&#13;
			<div>&#13;
				<div id="_idContainer273" class="IMG---Figure">&#13;
					<img src="Images/Figure_8.13_B16392.jpg" alt="Figure 8.13 – Details of the stage&#13;&#10;"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 8.13 – Details of the stage</p>&#13;
			<p>You <a id="_idIndexMarker620"/>have completed your first release <a id="_idIndexMarker621"/>pipeline. Here, we have triggered it manually. In the next section, we'll see how to use variables in your pipeline.</p>&#13;
			<h3>Using variables in a release pipeline</h3>&#13;
			<p>In a release <a id="_idIndexMarker622"/>pipeline, you can also use variables and variable groups to specify variable parameters that can be used in your pipeline tasks. To specify a variable for your release pipeline, select the <strong class="bold">Variables</strong> tab and specify the name and value of your variable:</p>&#13;
			<div>&#13;
				<div id="_idContainer274" class="IMG---Figure">&#13;
					<img src="Images/Figure_8.14_B16392.jpg" alt="Figure 8.14 – Release pipeline variables&#13;&#10;"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 8.14 – Release pipeline variables</p>&#13;
			<p>You can <a id="_idIndexMarker623"/>then use the variables in your pipeline's tasks by using the <strong class="source-inline">$(VariableName)</strong> notation, as in the following screenshot:</p>&#13;
			<div>&#13;
				<div id="_idContainer275" class="IMG---Figure">&#13;
					<img src="Images/Figure_8.15_B16392.jpg" alt="Figure 8.15 – Using a variable in a release pipeline task&#13;&#10;"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 8.15 – Using a variable in a release pipeline task</p>&#13;
			<p>Using variables is recommended if you have parameters that change on your pipeline. In the next section, we'll see how to configure triggers for continuous deployment.</p>&#13;
			<h2 id="_idParaDest-172"><a id="_idTextAnchor187"/>Configuring the release pipeline triggers for continuous deployment</h2>&#13;
			<p>To <a id="_idIndexMarker624"/>automate the continuous deployment <a id="_idIndexMarker625"/>of your application, you need to configure triggers in your release pipeline definition:</p>&#13;
			<ol>&#13;
				<li value="1">To do that, click on the <strong class="bold">Continuous deployment trigger</strong> icon in the pipeline's <strong class="bold">Artifacts</strong> section:<div id="_idContainer276" class="IMG---Figure"><img src="Images/Figure_8.16_B16392.jpg" alt="Figure 8.16 – Continuous deployment trigger&#13;&#10;"/></div><p class="figure-caption">Figure 8.16 – Continuous deployment trigger</p></li>&#13;
				<li>In <a id="_idIndexMarker626"/>the <strong class="bold">Continuous deployment trigger</strong> panel, enable it to automatically create a new <a id="_idIndexMarker627"/>release after every successfully completed build and select a branch filter (for example, the build pipeline's default branch):<div id="_idContainer277" class="IMG---Figure"><img src="Images/Figure_8.17_B16392.jpg" alt="Figure 8.17 – Continuous deployment trigger configuration&#13;&#10;"/></div><p class="figure-caption">Figure 8.17 – Continuous deployment trigger configuration</p></li>&#13;
				<li>Now, in <a id="_idIndexMarker628"/>the <strong class="bold">Stages</strong> section, select <a id="_idIndexMarker629"/>the <strong class="bold">Pre-deployment conditions</strong> icon:<div id="_idContainer278" class="IMG---Figure"><img src="Images/Figure_8.18_B16392.jpg" alt="Figure 8.18 – Pre-deployment conditions&#13;&#10;"/></div><p class="figure-caption">Figure 8.18 – Pre-deployment conditions</p></li>&#13;
				<li>In <a id="_idIndexMarker630"/>the <strong class="bold">Pre-deployment conditions</strong> pane, check that the trigger for this stage is set to <strong class="bold">After release</strong> (this <a id="_idIndexMarker631"/>means that the deployment stage will start automatically when a new release is created from this pipeline):</li>&#13;
			</ol>&#13;
			<div>&#13;
				<div id="_idContainer279" class="IMG---Figure">&#13;
					<img src="Images/Figure_8.19_B16392.jpg" alt="Figure 8.19 – Pre-deployment conditions definition&#13;&#10;"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 8.19 – Pre-deployment conditions definition</p>&#13;
			<p>In this <a id="_idIndexMarker632"/>pane, you can also define <a id="_idIndexMarker633"/>other parameters, such as selecting artifact condition(s) to trigger a new deployment (a release will be deployed to this stage only if all the artifact conditions match), setting up a schedule for the deployment, allowing pull request-based releases to be deployed to this stage, selecting the users who can approve or reject deployments to this stage (pre-deployment approvals), defining gates to evaluate before deployment, and defining behavior when multiple releases are queued for deployment.</p>&#13;
			<p>You have now created a release pipeline that takes your artifacts and deploys them to the cloud by using Azure DevOps and also by applying continuous deployment triggers and pre-deployment conditions checks.</p>&#13;
			<p>In the next section, we'll see how to improve our release pipeline by using multiple stages.</p>&#13;
			<h1 id="_idParaDest-173"><a id="_idTextAnchor188"/>Creating a multi-stage release pipeline</h1>&#13;
			<p>A multi-stage <a id="_idIndexMarker634"/>release pipeline is useful when you want to release your applications with multiple steps (staging), such as, for example, development, staging, and production. A quite common scenario in the real world is, for example, deploying an application initially to a testing environment. When tests are finished, the application is moved to a quality acceptance stage, and then, if the customer accepts the release, the application is moved to a production environment.</p>&#13;
			<p>Here, we'll do the same: starting from the previously created single-stage pipeline, we'll create a new release <a id="_idIndexMarker635"/>pipeline with <a id="_idIndexMarker636"/>three stages, called <strong class="bold">DEV</strong>, <strong class="bold">QA</strong>, and <strong class="bold">Production</strong>. Each stage is a deployment <a id="_idIndexMarker637"/>target for our pipeline:</p>&#13;
			<ol>&#13;
				<li value="1">In the previously defined pipeline, as a first step, I renamed the <strong class="bold">Deploy to cloud</strong> stage to <strong class="bold">Production</strong>. This will be the final stage of the release pipeline.</li>&#13;
				<li>Now, click on the <strong class="bold">Clone</strong> action to clone the defined stage into a new stage:<div id="_idContainer280" class="IMG---Figure"><img src="Images/Figure_8.20_B16392.jpg" alt="Figure 8.20 – Cloning a stage&#13; &#10;"/></div><p class="figure-caption">Figure 8.20 – Cloning a stage</p></li>&#13;
				<li>A new <a id="_idIndexMarker638"/>cloned stage appears after the previously created stage. Change the name of this stage to <strong class="source-inline">QA</strong>:<div id="_idContainer281" class="IMG---Figure"><img src="Images/Figure_8.21_B16392.jpg" alt="Figure 8.21 – Cloned stage (QA)&#13;&#10;"/></div><p class="figure-caption">Figure 8.21 – Cloned stage (QA)</p></li>&#13;
				<li>Now, we <a id="_idIndexMarker639"/>need to reorganize the stages because the <strong class="bold">QA</strong> stage must occur before the <strong class="bold">Production</strong> stage. To reorganize these stages, select the <strong class="bold">QA</strong> stage and choose the pre-deployment conditions. In the <strong class="bold">Pre-deployment conditions</strong> pane, select <strong class="bold">After release</strong> as the trigger (instead of <strong class="bold">After stage</strong>):<div id="_idContainer282" class="IMG---Figure"><img src="Images/Figure_8.22_B16392.jpg" alt="Figure 8.22 – Pre-deployment conditions for the QA stage&#13;&#10;"/></div><p class="figure-caption">Figure 8.22 – Pre-deployment conditions for the QA stage</p></li>&#13;
				<li>As you <a id="_idIndexMarker640"/>can see, the pipeline diagram has now changed (you have the <strong class="bold">QA</strong> and <strong class="bold">Production</strong> stages executed in parallel). Now, select the <strong class="bold">Pre-deployment conditions</strong> properties for the <strong class="bold">Production</strong> stage; set the trigger to <strong class="bold">After stage</strong> and select <strong class="bold">QA</strong> as the stage:<div id="_idContainer283" class="IMG---Figure"><img src="Images/Figure_8.23_B16392.jpg" alt="Figure 8.23 – Pre-deployment conditions for the Production stage&#13;&#10;"/></div><p class="figure-caption">Figure 8.23 – Pre-deployment conditions for the Production stage</p></li>&#13;
				<li>The <a id="_idIndexMarker641"/>stages are now ordered as we want (<strong class="bold">QA</strong> occurs before <strong class="bold">Production</strong>).</li>&#13;
				<li>At this point, we have two stages that deploy the application to the same environment (<strong class="bold">QA</strong> was created as a clone of <strong class="bold">Production</strong>). Select the <strong class="bold">QA</strong> stage from the <strong class="bold">Tasks</strong> drop-down list and change <strong class="bold">App service name</strong> to a new instance:<div id="_idContainer284" class="IMG---Figure"><img src="Images/Figure_8.24_B16392.jpg" alt="Figure 8.24 – QA stage details&#13;&#10;"/></div><p class="figure-caption">Figure 8.24 – QA stage details</p></li>&#13;
				<li>Now, we need to repeat the same steps for creating the <strong class="bold">DEV</strong> stage. Clone it from <strong class="bold">QA</strong>, set its <strong class="bold">Pre-deployment conditions</strong> properties with the trigger set to <strong class="bold">After Release</strong>, and change the <strong class="bold">QA</strong> trigger to <strong class="bold">After stage</strong>, with <strong class="bold">DEV</strong> as the selected stage. Your pipeline will now look as follows:</li>&#13;
			</ol>&#13;
			<div>&#13;
				<div id="_idContainer285" class="IMG---Figure">&#13;
					<img src="Images/Figure_8.25_B16392.jpg" alt="Figure 8.25 – Multi-stage release pipeline defined&#13;&#10;"/>&#13;
				</div>&#13;
			</div>&#13;
			<p>cYou have <a id="_idIndexMarker642"/>now created a release pipeline with different stages (<strong class="bold">Dev</strong>, <strong class="bold">QA</strong>, and <strong class="bold">Production</strong>) for controlling the deployment steps of your code.</p>&#13;
			<p>In the next section, we'll see how to add approvals for moving between stages.</p>&#13;
			<h1 id="_idParaDest-174"><a id="_idTextAnchor189"/>Using approvals and gates for managing deployments</h1>&#13;
			<p>As previously <a id="_idIndexMarker643"/>configured, our release pipeline will move between <a id="_idIndexMarker644"/>stages only if the previous stage is completed successfully. This is okay for moving from <strong class="bold">DEV</strong> to <strong class="bold">QA</strong> because on this transition, our application is deployed to a testing environment, but the transition from <strong class="bold">QA</strong> to <strong class="bold">Production</strong> should usually be controlled because the release of an application into a production environment normally occurs after an approval.</p>&#13;
			<h2 id="_idParaDest-175"><a id="_idTextAnchor190"/>Creating approvals</h2>&#13;
			<p>Let's follow <a id="_idIndexMarker645"/>these steps to create approvals:</p>&#13;
			<ol>&#13;
				<li value="1">To create an approval step, from our pipeline definition, select the <strong class="bold">Pre-deployment conditions</strong> properties of the <strong class="bold">Production</strong> stage. Here, go to the <strong class="bold">Pre-deployment approvals</strong> section and enable it. Then, in the <strong class="bold">Approvers</strong> section, select the users that will be responsible for approving. Please also check that the <strong class="bold">The user requesting a release or deployment should not approve it</strong> option is not ticked:<div id="_idContainer286" class="IMG---Figure"><img src="Images/Figure_8.26_B16392.jpg" alt="Figure 8.26 – Setting approvals&#13;&#10;"/></div><p class="figure-caption">Figure 8.26 – Setting approvals</p></li>&#13;
				<li>Click on <strong class="bold">Save</strong> to save your pipeline definition.</li>&#13;
				<li>Now, create <a id="_idIndexMarker646"/>a new release to start our pipeline and click on the name of the created release (here, it is called <strong class="bold">Release-2</strong>):<div id="_idContainer287" class="IMG---Figure"><img src="Images/Figure_8.27_B16392.jpg" alt="Figure 8.27 – Multi-stage release triggered&#13;&#10;"/></div><p class="figure-caption">Figure 8.27 – Multi-stage release triggered</p></li>&#13;
				<li>The release pipeline starts. The <strong class="bold">DEV</strong> and <strong class="bold">QA</strong> stages are completed, while on the <strong class="bold">Production</strong> stage, a <strong class="bold">Pending approval</strong> status appears:<div id="_idContainer288" class="IMG---Figure"><img src="Images/Figure_8.28_B16392.jpg" alt="Figure 8.28 – Pending approval&#13;&#10;"/></div><p class="figure-caption">Figure 8.28 – Pending approval</p></li>&#13;
				<li>The release <a id="_idIndexMarker647"/>pipeline is waiting for approval. You can click on the <strong class="bold">Pending approval</strong> icon and the approval dialog is opened. Here, you can insert a comment and then approve or reject the release:<div id="_idContainer289" class="IMG---Figure"><img src="Images/Figure_8.29_B16392.jpg" alt="Figure 8.29 – Approving a stage&#13;&#10;"/></div><p class="figure-caption">Figure 8.29 – Approving a stage</p></li>&#13;
				<li>You can <a id="_idIndexMarker648"/>also defer the stage to a specific date if needed or reassign the approval to another user.</li>&#13;
				<li>If you click on <strong class="bold">Approve</strong>, the stage is approved and the release pipeline is completed:<div id="_idContainer290" class="IMG---Figure"><img src="Images/Figure_8.30_B16392.jpg" alt="Figure 8.30 – Multi-stage pipeline completed&#13;&#10;"/></div><p class="figure-caption">Figure 8.30 – Multi-stage pipeline completed</p></li>&#13;
				<li>If you <a id="_idIndexMarker649"/>now click on the Azure App Service instance deployed by your pipeline, you can see that the final code (the <strong class="bold">PartsUnlimited</strong> website) is deployed in the cloud:</li>&#13;
				<li><div id="_idContainer291" class="IMG---Figure"><img src="Images/Figure_8.31_B16392.jpg" alt="Figure 8.31 – Web app deployed from the release pipeline&#13;&#10;"/></div></li>&#13;
			</ol>&#13;
			<p class="figure-caption">Figure 8.31 – Web app deployed from the release pipeline</p>&#13;
			<h2 id="_idParaDest-176"><a id="_idTextAnchor191"/>Using gates to check conditions</h2>&#13;
			<p>In the previously <a id="_idIndexMarker650"/>explained scenario, we saw how to configure a manual approval process for a release pipeline. Sometimes, you need to avoid the manual process and instead have a policy in place that permits your pipeline to go ahead only if some checks are successfully performed. This <a id="_idIndexMarker651"/>is where <strong class="bold">gates</strong> come in action.</p>&#13;
			<p>In Azure Pipelines, a gate allows you to automatically check for specific conditions from Azure DevOps from external services and then enable the release process only when the conditions are met. You can use gates to check the status of work items and issues of a project and enable the release only if you have no open bugs. You can also query test results, check whether security scans on artifacts are performed before releasing, monitor the infrastructure health before releasing, and so on.</p>&#13;
			<p>As an example, here we want to configure a gate for our previously created release pipeline <a id="_idIndexMarker652"/>where we check for open bugs on Azure Boards. We will see how to do this with the help of the following steps:</p>&#13;
			<p class="callout-heading">Important note</p>&#13;
			<p class="callout">If there are open bugs, the release pipeline cannot go ahead.</p>&#13;
			<ol>&#13;
				<li value="1">To check for open bugs in our project, we need to define a query for work items. From our Azure DevOps project, select <strong class="bold">Boards</strong>, click on <strong class="bold">Queries</strong>, and then select <strong class="bold">New query</strong>:<div id="_idContainer292" class="IMG---Figure"><img src="Images/Figure_8.32_B16392.jpg" alt="Figure 8.32 – Cresting a new query for the gate conditions&#13;&#10;"/></div><p class="figure-caption">Figure 8.32 – Cresting a new query for the gate conditions</p></li>&#13;
				<li>Here, I've defined a query as follows:<div id="_idContainer293" class="IMG---Figure"><img src="Images/Figure_8.33_B16392.jpg" alt="Figure 8.33 – Query definition&#13;&#10;"/></div><p class="figure-caption">Figure 8.33 – Query definition</p><p>This query checks for active bugs in our project. </p></li>&#13;
				<li>Save the <a id="_idIndexMarker653"/>query by giving it a name (for example, <strong class="bold">ActiveBugs</strong>) and specifying a folder (here, I've selected the <strong class="bold">Shared Queries</strong> folder):<div id="_idContainer294" class="IMG---Figure"><img src="Images/Figure_8.34_B16392.jpg" alt="Figure 8.34 – Saving the query definition&#13;&#10;"/></div><p class="figure-caption">Figure 8.34 – Saving the query definition</p></li>&#13;
				<li>Now we're ready to define our gate. From the multi-stage release pipeline we previously created, select the <strong class="bold">Production</strong> stage, click on the bolt icon, and then enable gates, as shown in the following screenshot:<div id="_idContainer295" class="IMG---Figure"><img src="Images/Figure_8.35_B16392.jpg" alt="Figure 8.35 – Enabling gates&#13;&#10;"/></div><p class="figure-caption">Figure 8.35 – Enabling gates</p><p>Here, you can also specify the delay before the evaluation of gates (the time before the added gates are evaluated for the first time. If no gates are added, then the deployment will wait for the specified duration before proceeding), and we can specify the deployment gates (adding gates that evaluate health parameters). These gates are periodically evaluated in parallel and if the gates succeed, the deployment will proceed; otherwise, the deployment is rejected.</p></li>&#13;
				<li>To specify <a id="_idIndexMarker654"/>our gate, click on <strong class="bold">Add</strong> and then select <strong class="bold">Query work items</strong> (this will execute a work item query and check the results):<div id="_idContainer296" class="IMG---Figure"><img src="Images/Figure_8.36_B16392.jpg" alt="Figure 8.36 – Gate definition (Query work items)&#13;&#10;"/></div><p class="figure-caption">Figure 8.36 – Gate definition (Query work items)</p></li>&#13;
				<li>Now, select <a id="_idIndexMarker655"/>the <strong class="bold">ActiveBugs</strong> query from the folder where you previously saved it (the <strong class="bold">Shared folder</strong>, in my case) and specify <strong class="bold">Upper threshold</strong> as <strong class="source-inline">0</strong> (the maximum number of matching work items from the query) because we want the release pipeline to only be completed if we have 0 active bugs:</li>&#13;
			</ol>&#13;
			<div>&#13;
				<div id="_idContainer297" class="IMG---Figure">&#13;
					<img src="Images/Figure_8.37_B16392.jpg" alt="Figure 8.37 – Specifying conditions for the gate&#13;&#10;"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 8.37 – Specifying conditions for the gate</p>&#13;
			<p>Here, you can <a id="_idIndexMarker656"/>also define evaluations options such as <strong class="bold">time between re-evaluation of gates</strong> (the duration after which the gates are re-evaluated; this must be greater than the longest typical response time of the configured gates to allow all responses to be received in each evaluation), <strong class="bold">Minimum duration for steady results after a successful gates evaluation</strong> (all gates must continuously be successful for this duration; <strong class="source-inline">0</strong> means deployment will proceed when all gates succeed in the same evaluation cycle), <strong class="bold">timeout after which gates fail</strong> (the maximum evaluation period for gates; the deployment will be rejected if the timeout is reached before gates succeed).</p>&#13;
			<p>Our gate is now defined and active. You can also define other types of gates and you can also have gates that call Azure Functions to evaluate a release condition (which is useful if you want to integrate your release check with specific conditions on an external system).</p>&#13;
			<h2 id="_idParaDest-177"><a id="_idTextAnchor192"/>Using deployment groups</h2>&#13;
			<p>A <strong class="bold">deployment group</strong> is a <a id="_idIndexMarker657"/>set of machines with a deployment agent installed on each of them. Each deployment group represents a physical environment and it defines a logical group of target machines for parallel deployment.</p>&#13;
			<p>You can define a deployment group in Azure DevOps by going to the <strong class="bold">Pipeline</strong> section and selecting <strong class="bold">Deployment groups</strong>:</p>&#13;
			<div>&#13;
				<div id="_idContainer298" class="IMG---Figure">&#13;
					<img src="Images/Figure_8.38_B16392.jpg" alt="Figure 8.38 – Creating a deployment group&#13;&#10;"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 8.38 – Creating a deployment group</p>&#13;
			<p>Here, you can add servers where the build and release agent is installed.</p>&#13;
			<p>Each created deployment group is a member of a <strong class="bold">deployment pool</strong>, and this pool can also be shared across projects. Deployment groups can only be used on release pipelines.</p>&#13;
			<p>You can add <a id="_idIndexMarker658"/>a deployment group job by going to the release pipeline editor, selecting the job, and clicking on the three-dots button. Here, you can see the <strong class="bold">Add a deployment group job</strong> option:</p>&#13;
			<div>&#13;
				<div id="_idContainer299" class="IMG---Figure">&#13;
					<img src="Images/Figure_8.39_B16392.jpg" alt="Figure 8.39 – Adding a deployment group job&#13;&#10;"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 8.39 – Adding a deployment group job</p>&#13;
			<p>At the time of writing, deployment group jobs are not yet supported on YAML pipelines.</p>&#13;
			<h1 id="_idParaDest-178"><a id="_idTextAnchor193"/>YAML release pipelines with Azure DevOps</h1>&#13;
			<p>A recently <a id="_idIndexMarker659"/>added feature of Azure DevOps is the option to define release pipelines by using YAML (previously, this was possible only for the CI part). This is now possible by <a id="_idIndexMarker660"/>using multi-stage pipelines and with that, you can use a unified YAML experience for configuring Azure DevOps pipelines for CI, CD, and CI/CD.</p>&#13;
			<p>Defining the release YAML pipeline can be done exactly as described in <a href="B16392_04_Final_JM_ePub.xhtml#_idTextAnchor096"><em class="italic">Chapter 4</em></a>, <em class="italic">Understanding Azure DevOps Pipelines</em>. There are, however, some concepts to understand, such as <strong class="bold">environments</strong>.</p>&#13;
			<p><strong class="bold">Environments</strong> are a group of resources targeted by a pipeline – for example, Azure Web Apps, virtual machines, or Kubernetes clusters. You can use environments to group resources by scope – for example, you can create an environment called <strong class="bold">development</strong> with your development resources and an environment called <strong class="bold">production</strong> with the production resources. Environments can be created by going to the <strong class="bold">Environments</strong> section under <strong class="bold">Pipelines</strong>:</p>&#13;
			<div>&#13;
				<div id="_idContainer300" class="IMG---Figure">&#13;
					<img src="Images/Figure_8.40_B16392.jpg" alt="Figure 8.40 – Creating environments&#13;&#10;"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 8.40 – Creating environments</p>&#13;
			<p>The following <a id="_idIndexMarker661"/>is an example of a multi-stage <a id="_idIndexMarker662"/>release pipeline for deploying a .NET Core application on Azure Web Apps:</p>&#13;
			<p class="source-code">stages:</p>&#13;
			<p class="source-code">	- stage: Build_Source_# Build Source Code for Dotnet Core Web App</p>&#13;
			<p class="source-code">	  jobs:</p>&#13;
			<p class="source-code">	  - job: Build</p>&#13;
			<p class="source-code">	    pool: 'Hosted VS2017'</p>&#13;
			<p class="source-code">	    variables:</p>&#13;
			<p class="source-code">	      buildConfiguration: 'Release' </p>&#13;
			<p class="source-code">	    continueOnError: false</p>&#13;
			<p class="source-code">	    steps:</p>&#13;
			<p class="source-code">	    - task: DotNetCoreCLI@2</p>&#13;
			<p class="source-code">	      inputs:</p>&#13;
			<p class="source-code">	        command: build</p>&#13;
			<p class="source-code">	        arguments: '--configuration $(buildConfiguration)'</p>&#13;
			<p class="source-code">	    - task: DotNetCoreCLI@2</p>&#13;
			<p class="source-code">	      inputs:</p>&#13;
			<p class="source-code">	        command: publish</p>&#13;
			<p class="source-code">	        arguments: '--configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)'</p>&#13;
			<p class="source-code">	        modifyOutputPath: true</p>&#13;
			<p class="source-code">	        zipAfterPublish: true</p>&#13;
			<p class="source-code">	    - task: PublishBuildArtifacts@1</p>&#13;
			<p class="source-code">	      inputs:</p>&#13;
			<p class="source-code">	        path: $(Build.ArtifactStagingDirectory)</p>&#13;
			<p class="source-code">	        artifact: drop</p>&#13;
			<p class="source-code">	</p>&#13;
			<p class="source-code">	- stage: Deploy_In_Dev # Deploy artifacts to the dev environment</p>&#13;
			<p class="source-code">	  jobs:</p>&#13;
			<p class="source-code">	  - deployment: azure_web_app_dev</p>&#13;
			<p class="source-code">	    pool: 'Hosted VS2017'</p>&#13;
			<p class="source-code">	    variables:</p>&#13;
			<p class="source-code">	      WebAppName: 'PartsUnlimited-dev'</p>&#13;
			<p class="source-code">	    environment: 'dev-environment'</p>&#13;
			<p class="source-code">	    strategy:</p>&#13;
			<p class="source-code">	      runOnce:</p>&#13;
			<p class="source-code">	        deploy:</p>&#13;
			<p class="source-code">	          steps:</p>&#13;
			<p class="source-code">	          - task: AzureRMWebAppDeployment@4</p>&#13;
			<p class="source-code">	            displayName: Azure App Service Deploy</p>&#13;
			<p class="source-code">	            inputs:</p>&#13;
			<p class="source-code">	              WebAppKind: webApp</p>&#13;
			<p class="source-code">	              ConnectedServiceName: 'pay-as-you-go'</p>&#13;
			<p class="source-code">	              WebAppName: $(WebAppName)</p>&#13;
			<p class="source-code">	              Package: $(System.WorkFolder)/**/*.zip</p>&#13;
			<p class="source-code">	- stage: Deploy_In_QA # Deploy artifacts to the qa environment</p>&#13;
			<p class="source-code">	  jobs:</p>&#13;
			<p class="source-code">	  - deployment: azure_web_app_qa</p>&#13;
			<p class="source-code">	    pool: 'Hosted VS2017'</p>&#13;
			<p class="source-code">	    variables:</p>&#13;
			<p class="source-code">	      WebAppName: 'PartsUnlimited-qa'</p>&#13;
			<p class="source-code">	    environment: 'qa-environment'</p>&#13;
			<p class="source-code">	    strategy:</p>&#13;
			<p class="source-code">	      runOnce:</p>&#13;
			<p class="source-code">	        deploy:</p>&#13;
			<p class="source-code">	          steps:</p>&#13;
			<p class="source-code">	          - task: AzureRMWebAppDeployment@4</p>&#13;
			<p class="source-code">	            displayName: Azure App Service Deploy</p>&#13;
			<p class="source-code">	            inputs:</p>&#13;
			<p class="source-code">	              WebAppKind: webApp</p>&#13;
			<p class="source-code">	              ConnectedServiceName: 'pay-as-you-go'</p>&#13;
			<p class="source-code">	              WebAppName: $(WebAppName)</p>&#13;
			<p class="source-code">	              Package: $(System.WorkFolder)/**/*.zip</p>&#13;
			<p class="source-code">	- stage: Deploy_In_Production # Deploy artifacts to the production environment</p>&#13;
			<p class="source-code">	  jobs:</p>&#13;
			<p class="source-code">	  - deployment: azure_web_app_prod</p>&#13;
			<p class="source-code">	    pool: 'Hosted VS2017'</p>&#13;
			<p class="source-code">	    variables:</p>&#13;
			<p class="source-code">	      WebAppName: 'PartsUnlimited'</p>&#13;
			<p class="source-code">	    environment: 'prod-environment'</p>&#13;
			<p class="source-code">	    strategy:</p>&#13;
			<p class="source-code">	      runOnce:</p>&#13;
			<p class="source-code">	        deploy:</p>&#13;
			<p class="source-code">	          steps:</p>&#13;
			<p class="source-code">	          - task: AzureRMWebAppDeployment@4</p>&#13;
			<p class="source-code">	            displayName: Azure App Service Deploy</p>&#13;
			<p class="source-code">	            inputs:</p>&#13;
			<p class="source-code">	              WebAppKind: webApp</p>&#13;
			<p class="source-code">	              ConnectedServiceName: 'pay-as-you-go'</p>&#13;
			<p class="source-code">	              WebAppName: $(WebAppName)</p>&#13;
			<p class="source-code">	              Package: $(System.WorkFolder)/**/*.zip</p>&#13;
			<p>As you <a id="_idIndexMarker663"/>can see in the preceding YAML file, the pipeline <a id="_idIndexMarker664"/>defines <a id="_idIndexMarker665"/>four stages: <strong class="bold">Build Source</strong>, <strong class="bold">Deploy in Dev</strong>, <strong class="bold">Deploy in QA</strong>, and <strong class="bold">Deploy in Production</strong>. At <a id="_idIndexMarker666"/>each of these <a id="_idIndexMarker667"/>stages, the <a id="_idIndexMarker668"/>application is deployed on the specified environment.</p>&#13;
			<h1 id="_idParaDest-179"><a id="_idTextAnchor194"/>Summary</h1>&#13;
			<p>In this chapter, we had a full overview of how to work with release pipelines in Azure DevOps.</p>&#13;
			<p>We created a basic release pipeline for the <strong class="bold">PartsUnlimited</strong> project, defined artifacts, and created our first release by adding continuous deployment conditions.</p>&#13;
			<p>Then, we improved our pipeline definition by using multiple stages (<strong class="bold">DEV</strong>, <strong class="bold">QA</strong>, and <strong class="bold">Production</strong>), and at the end of this chapter, we saw how to define approvals and gates for managing the release of our code in a more controlled way and the concepts around YAML-based release pipelines</p>&#13;
			<p>In the next chapter, we'll see how to integrate Azure DevOps with GitHub.</p>&#13;
		</div>&#13;
	</div></body></html>