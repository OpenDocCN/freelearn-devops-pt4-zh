<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer433">&#13;
			<p id="_idParaDest-208" class="chapter-number"><a id="_idTextAnchor224"/>Chapter 11:</p>&#13;
			<h1 id="_idParaDest-209"><a id="_idTextAnchor225"/>Real-World CI/CD Scenarios with Azure DevOps </h1>&#13;
			<p>In this chapter, we'll show you some sample projects where the <strong class="bold">continuous integration and continuous delivery</strong> (<strong class="bold">CI/CD</strong>) processes are handled by using Azure DevOps. We'll be<a id="_idIndexMarker811"/> taking sample applications and setting up a CI/CD pipeline using Azure DevOps for managing the software development, deployment, and upgrade life cycle. </p>&#13;
			<p>We'll be covering the following topics in this chapter: <a id="_idTextAnchor226"/></p>&#13;
			<ul>&#13;
				<li>Setting up a CI/CD pipeline for .NET-based applications</li>&#13;
				<li>Setting up a CI/CD pipeline for a container-based infrastructure  </li>&#13;
				<li>Azure Architecture Center for DevOps </li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-210"><a id="_idTextAnchor227"/>Technical requirements</h1>&#13;
			<p>To follow along with this chapter, you need to have an active Azure DevOps organization and an Azure subscription.</p>&#13;
			<p>You can sign up for a test Azure DevOps organization at <a href="https://dev.azure.com">https://dev.azure.com</a>. You can get a trial for an Azure subscription at <a href="https://azure.microsoft.com/en-in/free/">https://azure.microsoft.com/en-in/free/</a> if you do not have one already.</p>&#13;
			<p>The code for this chapter is available at <a href="https://github.com/PacktPublishing/Learning-Azure-DevOps---B16392/tree/master/Chapter11">https://github.com/PacktPublishing/Learning-Azure-DevOps---B16392/tree/master/Chapter11</a>.</p>&#13;
			<h1 id="_idParaDest-211"><a id="_idTextAnchor228"/>Setting up a CI/CD pipeline for .NET-based applications</h1>&#13;
			<p>A typical .NET-based <a id="_idIndexMarker812"/>application<a id="_idIndexMarker813"/> includes applications developed using Microsoft's .NET Framework and uses a SQL database in the backend. You may have multiple layers of applications, such as a frontend, backend (also known as the middle tier or API tier), and data tier (SQL Server). </p>&#13;
			<p>Azure Pipelines, which is part of Azure DevOps, provides a comprehensive solution to build, deploy, and manage your .NET-based infrastructure deployments. In this section, we'll look at the steps to configure CI/CD for a sample .NET-based application. </p>&#13;
			<p>We will be creating two environments, named <strong class="bold">staging</strong> and <strong class="bold">production</strong>, for the application and setup of a CI/CD pipeline. </p>&#13;
			<h2 id="_idParaDest-212"><a id="_idTextAnchor229"/>Introduction to the sample application</h2>&#13;
			<p>We'll be using a <a id="_idIndexMarker814"/>simple <strong class="bold">ToDo</strong> application for this walkthrough. It's a web-based application that uses a SQL database in the backend.</p>&#13;
			<p>It is built using Microsoft ASP.NET, targeted for .NET Framework version 4.62. You can access the source code here: <a href="https://github.com/Azure-Samples/dotnet-sqldb-tutorial/tree/master/DotNetAppSqlDb">https://github.com/Azure-Samples/dotnet-sqldb-tutorial/tree/master/DotNetAppSqlDb</a>.</p>&#13;
			<p>It is recommended that you take a quick look at the application code to get familiar with it before we start building the CI/CD pipeline.</p>&#13;
			<h2 id="_idParaDest-213"><a id="_idTextAnchor230"/>Preparing the pre-requisite Azure infrastructure </h2>&#13;
			<p>In this section, we'll <a id="_idIndexMarker815"/>create the required Azure infrastructure to host the application. We will be creating the following resources:</p>&#13;
			<ol>&#13;
				<li><strong class="bold">Resource groups</strong>: The following resource groups will be created for hosting the Azure resources for both environments: <p>  a) <strong class="source-inline">Contoso-ToDo-Staging</strong></p><p>  b) <strong class="source-inline">Contoso-ToDo-Production</strong></p></li>&#13;
				<li><strong class="bold">Application components</strong>: We'll be creating the following resources for both the staging and production environments:<p>  a) Azure App Service to host the web application</p><p>  b) Azure SQL <a id="_idIndexMarker816"/>Database to host the SQL database</p></li>&#13;
			</ol>&#13;
			<h3>Creating a resource group in Azure</h3>&#13;
			<p>A resource group is a <a id="_idIndexMarker817"/>container that holds resources in the Azure cloud. Typically, a resource group includes resources that you want to manage as a group or are maintained in a similar life cycle. We'll be creating two resource groups: one for production and one for staging. Let's create the resource groups in Azure:</p>&#13;
			<ol>&#13;
				<li value="1">Log in to the Azure portal, <a href="https://portal.azure.com">https://portal.azure.com</a>, with your Azure credentials.</li>&#13;
				<li>Click on <strong class="bold">+ Create a resource</strong> and search for <strong class="source-inline">resource group</strong>:<div id="_idContainer377" class="IMG---Figure"><img src="Images/Figure_11.01_B16392.jpg" alt=" "/></div><p class="figure-caption">Figure 11.1 – Resource groups in the Azure portal</p></li>&#13;
				<li>Click <strong class="bold">Create</strong> on the resource group page. </li>&#13;
				<li>Select your subscription and enter the resource group name as <strong class="source-inline">Contoso-ToDo-Staging</strong>.</li>&#13;
				<li>Choose a region close to your location:<div id="_idContainer378" class="IMG---Figure"><img src="Images/Figure_11.02_B16392.jpg" alt="Figure 11.2 – Resource group creation&#13;&#10;"/></div><p class="figure-caption">Figure 11.2 – Resource group creation</p></li>&#13;
				<li>Click on <strong class="bold">Review + Create</strong> and<a id="_idIndexMarker818"/> then <strong class="bold">Create</strong> to start the deployment. </li>&#13;
				<li>Repeat the steps to create another resource group for the production environment named <strong class="source-inline">Contoso-ToDo-Prod</strong>.</li>&#13;
			</ol>&#13;
			<p>You've now created resource groups to host Azure resources.</p>&#13;
			<h3>Creating Azure App Service </h3>&#13;
			<p>Azure App Service<a id="_idIndexMarker819"/> is Microsoft Azure's <strong class="bold">Platform as a Service</strong> (<strong class="bold">PaaS</strong>) web hosting service. You can host any web-based application built in almost any language using App Service. Being a PaaS offering, App Service allows you to just push your code and get your application live without worrying about the underlying hardware, OS, and platform components. </p>&#13;
			<p>In this example, we'll be using Azure App Service to host the <strong class="bold">ToDo</strong> application:</p>&#13;
			<ol>&#13;
				<li value="1">In the Azure portal, click on <strong class="bold">+ Create a resource</strong> and click on <strong class="bold">Web App</strong>:<div id="_idContainer379" class="IMG---Figure"><img src="Images/Figure_11.03_B16392.jpg" alt="Figure 11.3 – Azure Web App in the portal&#13;&#10;"/></div><p class="figure-caption">Figure 11.3 – Azure Web App in the portal</p></li>&#13;
				<li>On <a id="_idIndexMarker820"/>the <strong class="bold">Web App Creation</strong> page, please enter the following values:<p>    a) <strong class="bold">Subscription</strong>: Choose your Azure subscription.</p><p>    b) <strong class="bold">Resource Group</strong>: Select the <strong class="bold">staging</strong> resource group created in the previous task.</p><p>    c) <strong class="bold">Name</strong>: Enter a unique name for your web application – for example, <strong class="source-inline">contosotodostagingXX</strong>, where <strong class="source-inline">XX</strong> is your initials.</p><p>    d) <strong class="bold">Publish</strong>: Choose <strong class="bold">Code</strong>.</p><p>    e) <strong class="bold">Runtime stack</strong>: Choose <strong class="bold">ASP.NET V4.7</strong>.</p><p>    f) <strong class="bold">Operating System</strong>: Choose <strong class="bold">Windows</strong>.</p><p>    g) <strong class="bold">Region</strong>: Choose a region close to your location:</p><div id="_idContainer380" class="IMG---Figure"><img src="Images/Figure_11.04_B16392.jpg" alt="Figure 11.4 – Azure App Service creation&#13;&#10;"/></div><p class="figure-caption">Figure 11.4 – Azure App Service creation</p></li>&#13;
				<li>Under <strong class="bold">App Service Plan</strong>, choose<a id="_idIndexMarker821"/> the following: <p>    a) <strong class="bold">Windows Plan</strong>: Enter a new App Service plan name</p><p>    b) <strong class="bold">Sku and Size</strong>: You can choose any SKU; it is recommended using <strong class="bold">S0</strong> or <strong class="bold">Basic</strong> to avoid any significant Azure costs since this is for testing. In production, you'd use a size that is suitable for your application resources demand:</p><div id="_idContainer381" class="IMG---Figure"><img src="Images/Figure_11.05_B16392.jpg" alt="Figure 11.5 – App Service SKU&#13;&#10;"/></div><p class="figure-caption">Figure 11.5 – App Service SKU</p></li>&#13;
				<li>Click <strong class="bold">Review + Create</strong> and then <strong class="bold">Create</strong> to start the deployment. <p>Once completed, you'll receive a notification with the status displayed as completed.</p></li>&#13;
				<li>Repeat the <a id="_idIndexMarker822"/>steps in this task to create another Azure app service for the production environment. </li>&#13;
			</ol>&#13;
			<p>In this task, we created an Azure app service for hosting the <strong class="bold">ToDo</strong> web application.</p>&#13;
			<h3>Creating an Azure SQL database</h3>&#13;
			<p>Our sample <strong class="bold">ToDo</strong> app is<a id="_idIndexMarker823"/> using Microsoft SQL Server to store all its application data. In this task, we'll create a new Azure SQL database that will be used by the <strong class="bold">ToDo</strong> app to store all the persistent data:</p>&#13;
			<ol>&#13;
				<li value="1">In the Azure portal, click on <strong class="bold">+ Create a resource</strong> and select <strong class="bold">SQL Database</strong>:<div id="_idContainer382" class="IMG---Figure"><img src="Images/Figure_11.06_B16392.jpg" alt=""/></div><p class="figure-caption">Figure 11.6 – SQL Database in Azure</p></li>&#13;
				<li>On the SQL Server <strong class="bold">Basics</strong> details page, provide the following values:<p>    a) <strong class="bold">Subscription</strong>: Select your Azure subscription.</p><p>    b) <strong class="bold">Resource group</strong>: Select the staging resource group created earlier.</p><p>    c) <strong class="bold">Database name</strong>: <strong class="source-inline">contosotodo-staging-db</strong>.</p><p>    d) <strong class="bold">Server</strong>: <strong class="bold">Create new</strong>:</p><p>          i) <strong class="bold">Server Name</strong>: Provide a unique <strong class="bold">SQL Server name</strong>, such as <strong class="source-inline">contosotodo-staging-dbserver</strong>.</p><p>          ii) Provide a <a id="_idIndexMarker824"/>username and password of your choice.</p><p>          iii) <strong class="bold">Location</strong>: The Azure region used for deploying the web application. </p><p>    e) <strong class="bold">Want to use SQL elastic pool?</strong>: <strong class="bold">No</strong>.</p><p>    f) <strong class="bold">Compute + storage</strong>: Change the SKU to <strong class="bold">S0</strong> or <strong class="bold">Basic</strong> to keep the Azure costs low during this test project. In reality, you'd need to choose the right compute and storage combination as per your application requirements:</p><div id="_idContainer383" class="IMG---Figure"><img src="Images/Figure_11.07_B16392.jpg" alt="Figure 11.7 – Create SQL Database in Azure&#13;&#10;"/></div><p class="figure-caption">Figure 11.7 – Create SQL Database in Azure</p></li>&#13;
				<li>Click <a id="_idIndexMarker825"/>on <strong class="bold">Next: Networking &gt;</strong>.</li>&#13;
				<li>For the <strong class="bold">Networking</strong> configuration, select <strong class="bold">Public endpoint</strong> for <strong class="bold">Connectivity method</strong> and choose <strong class="bold">Yes</strong> for <strong class="bold">Allow Azure services and resources to access this server</strong>. Please note that this is just for the purpose of this test project deployment; in production, it is advised to allow access to SQL Server from your specific application servers only. Once selected, click on <strong class="bold">Review + create</strong>:<div id="_idContainer384" class="IMG---Figure"><img src="Images/Figure_11.08_B16392.jpg" alt="Figure 11.8 – Reviewing SQL database creation in Azure&#13;&#10;"/></div><p class="figure-caption">Figure 11.8 – Reviewing SQL database creation in Azure</p></li>&#13;
				<li>Click <strong class="bold">Create</strong> to start the deployment. Once completed, you'll receive a notification in the notification menu.</li>&#13;
				<li>Navigate to the newly create Azure SQL database and copy the connection string. This will be used in the upcoming sections. </li>&#13;
				<li>Repeat the steps<a id="_idIndexMarker826"/> to create another Azure SQL database for production.</li>&#13;
			</ol>&#13;
			<p>In this task, we've created Azure SQL databases for our application.</p>&#13;
			<h2 id="_idParaDest-214"><a id="_idTextAnchor231"/>Setting up an Azure DevOps project</h2>&#13;
			<p>Now that our<a id="_idIndexMarker827"/> Azure infrastructure is ready, we'll now set up an Azure DevOps organization to build the CI/CD pipeline. We will be using Azure Repos as our source control management system:</p>&#13;
			<ol>&#13;
				<li value="1">Log in to <a href="https://dev.azure.com">https://dev.azure.com</a> using your Azure DevOps account.</li>&#13;
				<li>Create a new project named <strong class="source-inline">Contoso ToDo</strong> in your DevOps tenant:<div id="_idContainer385" class="IMG---Figure"><img src="Images/Figure_11.09_B16392.jpg" alt="Figure 11.9 – Creating a DevOps project&#13;&#10;"/></div><p class="figure-caption">Figure 11.9 – Creating a DevOps project</p></li>&#13;
				<li>We will start by <a id="_idIndexMarker828"/>importing the application code in Azure Repos. Click on <strong class="bold">Repos</strong>.</li>&#13;
				<li>Click on <strong class="bold">Import</strong> under <strong class="bold">Import a repository</strong>:<div id="_idContainer386" class="IMG---Figure"><img src="Images/Figure_11.10_B16392.jpg" alt="Figure 11.10 – Import a repository &#13;&#10;"/></div><p class="figure-caption">Figure 11.10 – Import a repository </p></li>&#13;
				<li>For the repository URL, enter <a href="https://github.com/Azure-Samples/dotnet-sqldb-tutorial/">https://github.com/Azure-Samples/dotnet-sqldb-tutorial/</a> and<a id="_idIndexMarker829"/> click <strong class="bold">Import</strong>:</li>&#13;
			</ol>&#13;
			<div>&#13;
				<div id="_idContainer387" class="IMG---Figure">&#13;
					<img src="Images/Figure_11.11_B16392.jpg" alt="Figure 11.11 – Importing a repository from GitHub&#13;&#10;"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 11.11 – Importing a repository from GitHub</p>&#13;
			<p>Once the import is successful, we'll see that project files are now available in Azure Repos. You can explore the code files to look under the hood of the <strong class="bold">ToDo</strong> application. The folder named <strong class="source-inline">DotNetAppSQLDb</strong> contains the source file of the application:</p>&#13;
			<div>&#13;
				<div id="_idContainer388" class="IMG---Figure">&#13;
					<img src="Images/Figure_11.12_B16392.jpg" alt="Figure 11.12 – Files in the Azure repo&#13;&#10;"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 11.12 – Files in the Azure repo</p>&#13;
			<p>We will now set up a <a id="_idIndexMarker830"/>build pipeline for the application.</p>&#13;
			<h3>Setting up CI for the application</h3>&#13;
			<p>Now that our <a id="_idIndexMarker831"/>application code is in Azure Repos, let's create a build pipeline that will build the application package to be deployed to Azure App Service:</p>&#13;
			<ol>&#13;
				<li value="1">In Azure DevOps, browse to <strong class="bold">Pipelines</strong> and click on <strong class="bold">Create Pipeline</strong>:<div id="_idContainer389" class="IMG---Figure"><img src="Images/Figure_11.13_B16392.jpg" alt="Figure 11.13 – Creating a pipeline&#13;&#10;"/></div><p class="figure-caption">Figure 11.13 – Creating a pipeline</p></li>&#13;
				<li>Click on <strong class="bold">Use the classic editor</strong> to create the pipeline using the GUI (this is optional; as described in previous chapters, you can choose to configure the pipeline using a YAML file):<div id="_idContainer390" class="IMG---Figure"><img src="Images/Figure_11.14_B16392.jpg" alt="Figure 11.14 – Select the classic editor&#13;&#10;"/></div><p class="figure-caption">Figure 11.14 – Select the classic editor</p></li>&#13;
				<li>Select your Azure repo<a id="_idIndexMarker832"/> and master branch, then click <strong class="bold">Continue</strong> to move to the next step: <div id="_idContainer391" class="IMG---Figure"><img src="Images/Figure_11.15_B16392.jpg" alt="Figure 11.15 – Selecting the repo&#13;&#10;"/></div><p class="figure-caption">Figure 11.15 – Selecting the repo</p></li>&#13;
				<li>Select <strong class="bold">ASP.NET</strong> as the <a id="_idIndexMarker833"/>pipeline template:<div id="_idContainer392" class="IMG---Figure"><img src="Images/Figure_11.16_B16392.jpg" alt="Figure 11.16 – Selecting the pipeline template &#13;&#10;"/></div><p class="figure-caption">Figure 11.16 – Selecting the pipeline template </p></li>&#13;
				<li>Review the pipeline configuration. For the purpose of this project, the default configuration does the job. Once it's reviewed, click on <strong class="bold">Save &amp; queue</strong>:<div id="_idContainer393" class="IMG---Figure"><img src="Images/Figure_11.17_B16392.jpg" alt="Figure 11.17 – Pipeline build tasks &#13;&#10;"/></div><p class="figure-caption">Figure 11.17 – Pipeline build tasks </p></li>&#13;
				<li>In the <strong class="bold">Run Pipeline</strong> wizard, you can add a comment and click <strong class="bold">Save and run to start execution</strong>. </li>&#13;
				<li>Once the <a id="_idIndexMarker834"/>job is in progress, you can review the status by click on the job name:<div id="_idContainer394" class="IMG---Figure"><img src="Images/Figure_11.18_B16392.jpg" alt="Figure 11.18 – Pipeline build status &#13;&#10;"/></div><p class="figure-caption">Figure 11.18 – Pipeline build status </p></li>&#13;
				<li>Now, let's enable CI on the pipeline to auto-start the build on commit to the <strong class="bold">master</strong> branch. Edit <a id="_idIndexMarker835"/>the pipeline and browse to <strong class="bold">Triggers</strong>, and enable CI. You can choose to filter by branch or change to a different branch if you are not using <strong class="bold">master</strong> as your primary branch:</li>&#13;
			</ol>&#13;
			<div>&#13;
				<div id="_idContainer395" class="IMG---Figure">&#13;
					<img src="Images/Figure_11.19_B16392.jpg" alt="Figure 11.19 – Enable continuous integration &#13;&#10;"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 11.19 – Enable continuous integration </p>&#13;
			<p>In this task, we created a <a id="_idIndexMarker836"/>build pipeline and performed a successful build of our sample <strong class="bold">ToDo</strong> application. In the next task, we'll perform the deployments.</p>&#13;
			<h3>Setting up continuous delivery for the application</h3>&#13;
			<p>Now that our<a id="_idIndexMarker837"/> application is ready to be deployed, we'll create a release pipeline to deploy the application in Azure. In this pipeline, we'll define which Azure resources to deploy the application to and add additional deployment controls.</p>&#13;
			<h4>Setting up the service connection </h4>&#13;
			<p>Azure DevOps <a id="_idIndexMarker838"/>requires access to an Azure subscription in order to be able to deploy and update Azure resources. Service connections in Azure DevOps allow you to connect your Azure DevOps project to external services. Let's create a service connection for Azure Pipelines:</p>&#13;
			<ol>&#13;
				<li value="1">Log in to Azure DevOps and browse to <strong class="bold">Project Settings</strong> | <strong class="bold">Service Connections</strong>.</li>&#13;
				<li>Click on <strong class="bold">Create service connection</strong>.</li>&#13;
				<li>In the connections list, select <strong class="bold">Azure Resource Manager</strong>:<div id="_idContainer396" class="IMG---Figure"><img src="Images/Figure_11.20_B16392.jpg" alt="Figure 11.20 – ARM service connections  &#13;&#10;"/></div><p class="figure-caption">Figure 11.20 – ARM service connections  </p></li>&#13;
				<li>For the service connection authentication method, choose <strong class="bold">Service principal (automatic)</strong>:<div id="_idContainer397" class="IMG---Figure"><img src="Images/Figure_11.21_B16392.jpg" alt="Figure 11.21 – ARM service connections service principal&#13;&#10;"/></div><p class="figure-caption">Figure 11.21 – ARM service connections service principal</p></li>&#13;
				<li>Azure DevOps will <a id="_idIndexMarker839"/>now require you to authenticate to Azure. Please log in with an account with at least subscription<a id="_idIndexMarker840"/> owner rights and global admin rights in the Azure <strong class="bold">Active Directory</strong> (<strong class="bold">AD</strong>) tenant. You can choose to allow the service connection scope to be limited to a resource group or allow the entire subscription. Select your Azure subscription and give it a name:</li>&#13;
			</ol>&#13;
			<div>&#13;
				<div id="_idContainer398" class="IMG---Figure">&#13;
					<img src="Images/Figure_11.22_B16392.jpg" alt="Figure 11.22 – Creating a service connections service principal &#13;&#10;"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 11.22 – Creating a service connections service principal </p>&#13;
			<p>This service <a id="_idIndexMarker841"/>connection is now ready to be used in Azure Pipelines. </p>&#13;
			<h4>Creating a release pipeline </h4>&#13;
			<p>Release pipelines<a id="_idIndexMarker842"/> include all the steps and the workflow to deploy the application to various environments, such as development, staging, QA, and production. Let's start with creating a release pipeline for our <strong class="bold">ToDo</strong> app:</p>&#13;
			<ol>&#13;
				<li value="1">Log in to Azure DevOps and launch your <strong class="source-inline">Contoso ToDo</strong> project.</li>&#13;
				<li>Browse to <strong class="bold">Pipeline</strong> | <strong class="bold">Releases</strong>.</li>&#13;
				<li>Click on <strong class="bold">New pipeline</strong>:<div id="_idContainer399" class="IMG---Figure"><img src="Images/Figure_11.23_B16392.jpg" alt="Figure 11.23 – New release pipeline &#13;&#10;"/></div><p class="figure-caption">Figure 11.23 – New release pipeline </p></li>&#13;
				<li>This will open a page to select a template. Since we're planning to deploy our <strong class="bold">ToDo</strong> app to App Service, select <strong class="bold">Azure App Service deployment</strong>:<div id="_idContainer400" class="IMG---Figure"><img src="Images/Figure_11.24_B16392.jpg" alt="Figure 11.24 – The Azure App Service deployment task &#13;&#10;"/></div><p class="figure-caption">Figure 11.24 – The Azure App Service deployment task </p></li>&#13;
				<li>Enter <strong class="source-inline">Staging Environment</strong> for <strong class="bold">Stage name</strong>. You can choose to give any other <a id="_idIndexMarker843"/>meaningful name that best depicts the scenario in your environment:<div id="_idContainer401" class="IMG---Figure"><img src="Images/Figure_11.25_B16392.jpg" alt="Figure 11.25 – Staging stage &#13;&#10;"/></div><p class="figure-caption">Figure 11.25 – Staging stage </p></li>&#13;
				<li>You can now close the <strong class="bold">Stage</strong> blade. Your pipeline should look as follows: <div id="_idContainer402" class="IMG---Figure"><img src="Images/Figure_11.26_B16392.jpg" alt="Figure 11.26 – Pipeline snapshot  &#13;&#10;"/></div><p class="figure-caption">Figure 11.26 – Pipeline snapshot  </p></li>&#13;
				<li>In order to<a id="_idIndexMarker844"/> deploy the application, first we need to get the application package from the outputs of the build pipeline. Under <strong class="bold">Artifacts</strong>, click <strong class="bold">+ Add</strong>:<div id="_idContainer403" class="IMG---Figure"><img src="Images/Figure_11.27_B16392.jpg" alt="Figure 11.27 – Artifact in the release pipeline&#13;&#10;"/></div><p class="figure-caption">Figure 11.27 – Artifact in the release pipeline</p></li>&#13;
				<li>Select <strong class="bold">Build</strong> as <strong class="bold">Source type</strong> and select the build pipeline created in the previous task. You can choose to configure which version is to be deployed by default:<div id="_idContainer404" class="IMG---Figure"><img src="Images/Figure_11.28_B16392.jpg" alt="Figure 11.28 – Artifact source in the release pipeline"/></div><p class="figure-caption">Figure 11.28 – Artifact source in the release pipeline</p></li>&#13;
				<li>Click on<a id="_idIndexMarker845"/> the <strong class="bold">Continuous deployment trigger</strong> button and enable continuous deployment. Enabling continuous deployment will trigger a release every time there's a new build version available (typically after you run a build pipeline with CI). If you enable <strong class="bold">Pull request trigger</strong>, a release will be created every time we have a new build version, even with a pull request. This may be a useful scenario for pure development pipelines:<div id="_idContainer405" class="IMG---Figure"><img src="Images/Figure_11.29_B16392.jpg" alt="Figure 11.29 – Enabling continuous deployment   &#13;&#10;"/></div><p class="figure-caption">Figure 11.29 – Enabling continuous deployment</p></li>&#13;
				<li>In <strong class="bold">Stages</strong>, click<a id="_idIndexMarker846"/> on <strong class="bold">1 job, 1 task</strong> in the development environment:<div id="_idContainer406" class="IMG---Figure"><img src="Images/Figure_11.30_B16392.jpg" alt="Figure 11.30 – Pipeline stage&#13;&#10;"/></div><p class="figure-caption">Figure 11.30 – Pipeline stage</p></li>&#13;
				<li>Inside the tasks view, select your Azure subscription service connection and the app service that you deployed earlier:<div id="_idContainer407" class="IMG---Figure"><img src="Images/Figure_11.31_B16392.jpg" alt="Figure 11.31 – App service deployment task&#13;&#10;"/></div><p class="figure-caption">Figure 11.31 – App service deployment task</p></li>&#13;
				<li>Click on <strong class="bold">Deploy Azure App Service</strong> and review the app service deployment information. </li>&#13;
				<li>Click on <strong class="bold">+</strong> to add another task to apply the <strong class="bold">SQL migration scripts</strong> for getting the database ready. Search for SQL and select <strong class="bold">Azure SQL Database deployment</strong>.</li>&#13;
				<li>In <strong class="bold">Azure SQL Task</strong>, change <a id="_idIndexMarker847"/>the following settings:<p>    a) <strong class="bold">Display Name</strong>: Apply database migration script.</p><p>    b) Select your Azure subscription and provide the database connection details captured while creating the Azure SQL database. </p><p>    c) <strong class="bold">Deploy Type</strong>: Inline SQL script </p><p>    d) <strong class="bold">Inline SQL Script</strong>: Provide the following script code. This will create the required tables in the SQL database. Please note that this is a sample SQL script to create the required schema (also available at <a href="https://github.com/PacktPublishing/Learning-Azure-DevOps---B16392/tree/master/Chapter11">https://github.com/PacktPublishing/Learning-Azure-DevOps---B16392/tree/master/Chapter11</a>); in a production environment, you may choose to do so using the SQL Server Data Tools project in Azure Pipelines. Please refer to this documentation to learn more about doing Azure DevOps for SQL: <a href="https://devblogs.microsoft.com/azure-sql/devops-for-azure-sql/">https://devblogs.microsoft.com/azure-sql/devops-for-azure-sql/</a>:</p><p class="source-code"><strong class="bold">/****** Object:  Table [dbo].[__MigrationHistory]    Script Date: 8/24/2020 12:35:05 PM ******/</strong></p><p class="source-code"><strong class="bold">SET ANSI_NULLS ON</strong></p><p class="source-code"><strong class="bold">SET QUOTED_IDENTIFIER ON</strong></p><p class="source-code"><strong class="bold">IF NOT EXISTS</strong></p><p class="source-code"><strong class="bold">   (  SELECT [name]</strong></p><p class="source-code"><strong class="bold">      FROM sys.tables</strong></p><p class="source-code"><strong class="bold">      WHERE [name] = '__MigrationHistory'</strong></p><p class="source-code"><strong class="bold">   )</strong></p><p class="source-code"><strong class="bold">BEGIN</strong></p><p class="source-code"><strong class="bold">    CREATE TABLE [dbo].[__MigrationHistory](</strong></p><p class="source-code"><strong class="bold">        [MigrationId] [nvarchar](150) NOT NULL,</strong></p><p class="source-code"><strong class="bold">        [ContextKey] [nvarchar](300) NOT NULL,</strong></p><p class="source-code"><strong class="bold">        [Model] [varbinary](max) NOT NULL,</strong></p><p class="source-code"><strong class="bold">        [ProductVersion] [nvarchar](32) NOT NULL,</strong></p><p class="source-code"><strong class="bold">    CONSTRAINT [PK_dbo.__MigrationHistory] PRIMARY KEY CLUSTERED </strong></p><p class="source-code"><strong class="bold">    (</strong></p><p class="source-code"><strong class="bold">        [MigrationId] ASC,</strong></p><p class="source-code"><strong class="bold">        [ContextKey] ASC</strong></p><p class="source-code"><strong class="bold">    )WITH (STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF) ON [PRIMARY]</strong></p><p class="source-code"><strong class="bold">    ) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]</strong></p><p class="source-code"><strong class="bold">    </strong></p><p class="source-code"><strong class="bold">END</strong></p><p class="source-code"><strong class="bold">/****** Object:  Table [dbo].[Todoes]    Script Date: 8/24/2020 12:35:05 PM ******/</strong></p><p class="source-code"><strong class="bold">SET ANSI_NULLS ON</strong></p><p class="source-code"><strong class="bold">SET QUOTED_IDENTIFIER ON</strong></p><p class="source-code"><strong class="bold">IF NOT EXISTS</strong></p><p class="source-code"><strong class="bold">   (  SELECT [name]</strong></p><p class="source-code"><strong class="bold">      FROM sys.tables</strong></p><p class="source-code"><strong class="bold">      WHERE [name] = 'Todoes'</strong></p><p class="source-code"><strong class="bold">   )</strong></p><p class="source-code"><strong class="bold">BEGIN</strong></p><p class="source-code"><strong class="bold">    CREATE TABLE [dbo].[Todoes](</strong></p><p class="source-code"><strong class="bold">        [ID] [int] IDENTITY(1,1) NOT NULL,</strong></p><p class="source-code"><strong class="bold">        [Description] [nvarchar](max) NULL,</strong></p><p class="source-code"><strong class="bold">        [CreatedDate] [datetime] NOT NULL,</strong></p><p class="source-code"><strong class="bold">    CONSTRAINT [PK_dbo.Todoes] PRIMARY KEY CLUSTERED </strong></p><p class="source-code"><strong class="bold">    (</strong></p><p class="source-code"><strong class="bold">        [ID] ASC</strong></p><p class="source-code"><strong class="bold">    )WITH (STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF) ON [PRIMARY]</strong></p><p class="source-code"><strong class="bold">    ) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]</strong></p><p class="source-code"><strong class="bold">    </strong></p><p class="source-code"><strong class="bold">END</strong></p></li>&#13;
				<li>Click <strong class="bold">Save</strong> and <strong class="bold">+</strong> to add another task. We'll now need to add another task to update the connection string of the database in the connection settings of Azure App Service. </li>&#13;
				<li>Search for <strong class="bold">Azure App Service Settings</strong> in the task's menu:<div id="_idContainer408" class="IMG---Figure"><img src="Images/Figure_11.32_B16392.jpg" alt="Figure 11.32 – The Azure App Service Settings task&#13;&#10;"/></div><p class="figure-caption">Figure 11.32 – The Azure App Service Settings task</p></li>&#13;
				<li>In the <strong class="bold">Azure App Service Settings</strong> task, select the Azure subscription and app service <a id="_idIndexMarker848"/>connection details for the staging environment. </li>&#13;
				<li>In <strong class="bold">Connection Settings</strong>, provide the database connection string in the following format. Please update your database connection details before saving. Since this is a test lab, we're storing the secure information directly in the pipeline task. However, in a production environment, please use variables and parameters to store any connection string or other information. Please refer to this documentation to learn more about securely using variables and parameters in an Azure pipeline: <a href="https://docs.microsoft.com/bs-cyrl-ba/azure/devops/pipelines/security/inputs?view=azure-devops">https://docs.microsoft.com/bs-cyrl-ba/azure/devops/pipelines/security/inputs?view=azure-devops</a>:<p class="source-code"><strong class="bold">[</strong></p><p class="source-code"><strong class="bold">  {</strong></p><p class="source-code"><strong class="bold">    'name': 'MyDbConnection',</strong></p><p class="source-code"><strong class="bold">    'value': 'Server=tcp:contosotodostagingdb.database.windows.NET,1433;Initial Catalog=ContoSoToDoStageDB;Persist Security Info=False;User ID=azadmin;Password=&lt;YourPassword&gt;;MultipleActiveResultSets=False;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;',</strong></p><p class="source-code"><strong class="bold">    'type': 'SQLAzure',</strong></p><p class="source-code"><strong class="bold">    'slotSetting': false</strong></p><p class="source-code"><strong class="bold">  }</strong></p><p class="source-code"><strong class="bold">]</strong></p></li>&#13;
				<li>Once all the tasks <a id="_idIndexMarker849"/>are updated, click on <strong class="bold">Save</strong>. You can save the pipeline in the root folder upon prompt. This should be the order of the tasks:<p>    a) <strong class="bold">Apply Database migration script</strong></p><p>    b) <strong class="bold">Apply Azure App Service Settings</strong></p><p>    c) <strong class="bold">Deploy Azure App Service</strong>: </p><p class="figure-caption"> </p><div id="_idContainer409" class="IMG---Figure"><img src="Images/Figure_11.33_B16392.jpg" alt="Figure 11.33 – Saving the release pipeline &#13;&#10;"/></div><p class="figure-caption">Figure 11.33 – Saving the release pipeline </p></li>&#13;
				<li>In the pipeline, click on <strong class="bold">+ Add</strong> to add another stage for production. You can select the same Azure App Service deployment, or you can also clone your development environment stage. You can configure the production stage while targeting the production app service and SQL database instances. Your pipeline should now <a id="_idIndexMarker850"/>look as follows:<div id="_idContainer410" class="IMG---Figure"><img src="Images/Figure_11.34_B16392.jpg" alt="Figure 11.34 – Release pipeline &#13;&#10;"/></div><p class="figure-caption">Figure 11.34 – Release pipeline </p></li>&#13;
				<li>Typically, you wouldn't want to auto-deploy to production. Let's modify the flow to include a manual approval for production deployment. Click on <strong class="bold">Pre-Deployment Conditions</strong>:<div id="_idContainer411" class="IMG---Figure"><img src="Images/Figure_11.35_B16392.jpg" alt="Figure 11.35 – Release pipeline trigger control&#13;&#10;"/></div><p class="figure-caption">Figure 11.35 – Release pipeline trigger control</p></li>&#13;
				<li>Enable the <strong class="bold">pre-deployment approval</strong> and select at least one user to approve before <a id="_idIndexMarker851"/>deployment to production happens. </li>&#13;
				<li>You can add an additional stage, such as test cases, performance benchmarks, and so on, and prepare the overall flow. Click <strong class="bold">Save</strong> once you've completed reviewing the pipeline. </li>&#13;
			</ol>&#13;
			<p>The Azure release pipeline to deploy the application is now ready. Let's create a release and see whether we can get our application up and running through CI/CD pipelines. </p>&#13;
			<h3>Creating a release</h3>&#13;
			<p>Let's test the release <a id="_idIndexMarker852"/>pipeline by creating a release manually:</p>&#13;
			<ol>&#13;
				<li value="1">In Azure DevOps, browse to <strong class="bold">Releases</strong> and click on <strong class="bold">Create release</strong>:<div id="_idContainer412" class="IMG---Figure"><img src="Images/Figure_11.36_B16392.jpg" alt="Figure 11.36 – Create release &#13;&#10;"/></div><p class="figure-caption">Figure 11.36 – Create release </p></li>&#13;
				<li>Review the release details and click <strong class="bold">Create</strong>:<div id="_idContainer413" class="IMG---Figure"><img src="Images/Figure_11.37_B16392.jpg" alt="Figure 11.37 – Reviewing release creation &#13;&#10;"/></div><p class="figure-caption">Figure 11.37 – Reviewing release creation </p></li>&#13;
				<li>Clicking <strong class="bold">Create</strong> will<a id="_idIndexMarker853"/> start a release execution; you can review the progress by clicking on logs on the stage:<div id="_idContainer414" class="IMG---Figure"><img src="Images/Figure_11.38_B16392.jpg" alt="Figure 11.38 – Release status&#13;&#10;"/></div><p class="figure-caption">Figure 11.38 – Release status</p><p>Once the development environment deployment has completed, you should try to launch the app service and see whether the <strong class="bold">ToDo</strong> application is working well for you:</p><div id="_idContainer415" class="IMG---Figure"><img src="Images/Figure_11.39_B16392.jpg" alt="Figure 11.39 – The ToDo app &#13;&#10;"/></div><p class="figure-caption">Figure 11.39 – The ToDo app </p></li>&#13;
				<li>You can try to add <strong class="bold">to-do</strong> items and test the application. Once you're ready to approve this for <a id="_idIndexMarker854"/>production deployment, click <strong class="bold">Approve</strong> to start the production deployment:</li>&#13;
			</ol>&#13;
			<div>&#13;
				<div id="_idContainer416" class="IMG---Figure">&#13;
					<img src="Images/Figure_11.40_B16392.jpg" alt="Figure 11.40 – Approving the production deployment&#13;&#10;"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 11.40 – Approving the production deployment</p>&#13;
			<p>You've now completed a release and your application is now ready to be used.</p>&#13;
			<h3>Trying out end-to-end CI/CD flow</h3>&#13;
			<p>Now that you've<a id="_idIndexMarker855"/> completed <a id="_idIndexMarker856"/>setting up an end-to-end CI/CD pipeline, go ahead and try out the following to experience the whole flow:</p>&#13;
			<ol>&#13;
				<li value="1">In Azure Repos, modify the view for the home page. Go to <strong class="bold">Repos</strong> | <strong class="bold">DotNetAppSQLDB</strong> | <strong class="bold">Views</strong> | <strong class="bold">Todos</strong> | <strong class="bold">index.cshtml</strong> and modify the label from <strong class="bold">Create new</strong> to <strong class="bold">Create New ToDo Item</strong>:<div id="_idContainer417" class="IMG---Figure"><img src="Images/Figure_11.41_B16392.jpg" alt="Figure 11.41 – Modifying the app code&#13;&#10;"/></div><p class="figure-caption">Figure 11.41 – Modifying the app code</p></li>&#13;
				<li>Commit the change<a id="_idIndexMarker857"/> in a new<a id="_idIndexMarker858"/> branch and follow through the pull request. You should approve and complete the pull request.<p>This should start an automated build pipeline execution followed through automated release execution. </p><p>In the end, you should have your application updated with the change without having to do any manual steps except the approval task configured for production. </p></li>&#13;
			</ol>&#13;
			<p>Congratulations, you've <a id="_idIndexMarker859"/>now completed<a id="_idIndexMarker860"/> the setup and testing of an end-to-end CI/CD pipeline! In the next section, we'll set up a similar pipeline for a Kubernetes-based application. </p>&#13;
			<h1 id="_idParaDest-215"><a id="_idTextAnchor232"/>Setting up a CI/CD pipeline for a container-based application</h1>&#13;
			<p>In this <a id="_idIndexMarker861"/>example, we'll take a <a id="_idIndexMarker862"/>container-based application and build an end-to-end CI/CD pipeline. We'll take a Python and Redis-based sample application for the purpose of this demonstration.</p>&#13;
			<p>In this example, we'll be using various Azure resources in the overall solution architecture. This includes the following:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">Azure DevOps</strong>: CI/CD pipeline</li>&#13;
				<li><strong class="bold">Azure Kubernetes Service</strong> (<strong class="bold">AKS</strong>): For<a id="_idIndexMarker863"/> hosting the containers</li>&#13;
				<li><strong class="bold">Azure Container Registry</strong> (<strong class="bold">ACR</strong>): Container <a id="_idIndexMarker864"/>image storage and management</li>&#13;
			</ul>&#13;
			<h2 id="_idParaDest-216"><a id="_idTextAnchor233"/>Introduction to the sample app</h2>&#13;
			<p>In this section, we'll be <a id="_idIndexMarker865"/>using <a id="_idIndexMarker866"/>a sample application called <strong class="bold">Azure Voting App</strong>. It is a standard multi-container-based application that uses the following components: </p>&#13;
			<ul>&#13;
				<li><strong class="bold">The Azure Voting App backend</strong>: This will be running on Redis. </li>&#13;
				<li><strong class="bold">The Azure Voting App frontend</strong>: Web application built with Python.</li>&#13;
			</ul>&#13;
			<p>You can review the application code here: <a href="https://github.com/Azure-Samples/azure-voting-app-redis">https://github.com/Azure-Samples/azure-voting-app-redis</a>.</p>&#13;
			<h2 id="_idParaDest-217"><a id="_idTextAnchor234"/>Setting up the required infrastructure</h2>&#13;
			<p>In order to be able to<a id="_idIndexMarker867"/> build the pipeline, first we need to set up the required infrastructure, including the AKS cluster and Azure container registry. We will be creating separate resources for the staging and production environments as a standard best practice; however, it is possible to use a single environment for both the production and development environments by using a combination of tags and a Kubernetes namespace. </p>&#13;
			<p>In this section, we'll <a id="_idIndexMarker868"/>be using the Azure <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) for all infrastructure provisioning tasks. </p>&#13;
			<h3>Creating the Azure resource group</h3>&#13;
			<p>Let's start by <a id="_idIndexMarker869"/>creating <a id="_idIndexMarker870"/>an Azure resource group for organizing all the resources for your development and production environments:</p>&#13;
			<ol>&#13;
				<li value="1">Log in to Azure Cloud Shell (<a href="https://shell.azure.com">https://shell.azure.com</a>) with your Azure credentials.</li>&#13;
				<li>If this is your first time logging in to Azure Cloud Shell, it will prompt you to create an Azure storage account. Select your subscription and click <strong class="bold">Create Storage</strong>.  </li>&#13;
				<li>Select <strong class="bold">Bash</strong> on the shell type selection.</li>&#13;
				<li>Run the following command to list all your subscriptions:<p class="source-code"><strong class="bold">az account list </strong></p></li>&#13;
				<li>If you need to select a specific subscription for provisioning resources, run the following command:<p class="source-code"><strong class="bold">az account set --subscription 'Your Subscription Name'</strong></p></li>&#13;
				<li>Create a resource named <strong class="source-inline">Contoso-Voting-Stage</strong> by running the following command. You can choose to upload the location with a region of your choice: <p class="source-code"><strong class="bold">az group create -l westus -n Contoso-Voting-Stage</strong></p></li>&#13;
				<li>Repeat the resource group creation command to create another resource group named <strong class="source-inline">Contoso-Voting-Prod</strong> for the production environment.</li>&#13;
			</ol>&#13;
			<p>You have now<a id="_idIndexMarker871"/> completed <a id="_idIndexMarker872"/>the required resource groups. In the next step, you'll create an Azure Kubernetes cluster. </p>&#13;
			<h3>Creating an Azure Kubernetes service </h3>&#13;
			<p>AKS is a managed <a id="_idIndexMarker873"/>Kubernetes offering from Microsoft Azure. There are two types of hosts in<a id="_idIndexMarker874"/> Kubernetes clusters – master (aka the control plane) and nodes. In the world of AKS, there's no master for end users. Microsoft creates and manages master nodes and hides them away from end users. As a user, you only deploy AKS nodes (Kubernetes nodes) in your subscription, whereas the configuration of Kubernetes and the joining of Microsoft-managed Kubernetes masters happens in the background. With AKS, you only pay for the nodes' infrastructure costs; masters are provided for free by Microsoft.</p>&#13;
			<p>We will be using AKS to host our containers. </p>&#13;
			<p>Let's start by creating an AKS cluster:</p>&#13;
			<ol>&#13;
				<li value="1">Log in to Cloud Shell with your Azure credentials.</li>&#13;
				<li>Run the following command to create an AKS cluster with the default configuration and latest version:<p class="source-code"><strong class="bold">az aks create --resource-group Contoso-Voting-Stage --name Contoso-Stage-AKS --node-count 1 --enable-addons monitoring --generate-ssh-keys</strong></p><p>Let's look at this command in detail: </p><p>    a) <strong class="source-inline">az aks create</strong>: The syntax for creating an AKS cluster.</p><p>    b) <strong class="source-inline">--resource-group &amp; --name</strong>: The resource group's name and AKS cluster name.</p><p>    c) <strong class="source-inline">--node-count</strong>: The number of AKS nodes you're creating.</p><p>    d) <strong class="source-inline">--enable-addons</strong>: This specifies add-ons, such as monitoring and HTTP routing.</p><p>    e) <strong class="source-inline">--generate-ssh-keys</strong>: This is a flag that lets <strong class="source-inline">az cli</strong> create SSH keys to be used for agent nodes.</p></li>&#13;
				<li>It may take up to 10 minutes for the AKS cluster to be ready.  You can review the status by <a id="_idIndexMarker875"/>running<a id="_idIndexMarker876"/> the following command:<p class="source-code"><strong class="bold">az aks list</strong></p></li>&#13;
				<li>Once your cluster is ready, you can get the Kubernetes authentication configuration in your Cloud Shell session by running the following command:<p class="source-code"><strong class="bold">az aks get-credentials --resource-group Contoso-Voting-Stage --name Contoso-Stage-AKS</strong></p></li>&#13;
				<li>You can try running <strong class="source-inline">kubectl</strong> commands now to interact with Kubernetes. Run the following command to get a list of all the Kubernetes nodes:<p class="source-code"><strong class="bold">kubectl get nodes</strong></p></li>&#13;
			</ol>&#13;
			<p>Your Azure Kubernetes cluster is now ready; please repeat the process to create another AKS cluster for the production environment. </p>&#13;
			<h3>Creating an Azure container registry </h3>&#13;
			<p>ACR is a private <a id="_idIndexMarker877"/>Docker<a id="_idIndexMarker878"/> container registry that's hosted and managed by Microsoft Azure. ACR is fully compatible with Docker and works in the same way, except that it's managed, hosted, and secured by Microsoft. We will be using ACR to store our container images.</p>&#13;
			<p>Let's create a container registry for the project:</p>&#13;
			<ol>&#13;
				<li value="1">Log in to Azure Cloud Shell and run the following command to create a container registry:<p class="source-code"><strong class="bold">az acr create --resource-group Contoso-Voting-Stage --name ContosoStageACR --sku Basic </strong></p></li>&#13;
				<li>Once your container registry is ready, you can get the status and details of it by running <a id="_idIndexMarker879"/>the<a id="_idIndexMarker880"/> following command:<p class="source-code"><strong class="bold">az acr list</strong></p></li>&#13;
			</ol>&#13;
			<h3>Integrating ACR with AKS </h3>&#13;
			<p>AKS needs to<a id="_idIndexMarker881"/> have <a id="_idIndexMarker882"/>permissions to access the container images<a id="_idIndexMarker883"/> from ACR in order to run the application. Let's enable access for AKS to interact with our ACR.  </p>&#13;
			<p>Run the following command to integrate AKS with our ACR:</p>&#13;
			<p class="source-code">az aks update -n Contoso-Stage-AKS -g Contoso-Voting-Stage --attach-acr ContosoStageACR</p>&#13;
			<p>Now that our infrastructure is ready, we'll begin with setting up the code repository for the application. </p>&#13;
			<h2 id="_idParaDest-218"><a id="_idTextAnchor235"/>Setting up Azure Repos for the voting application</h2>&#13;
			<p>In this <a id="_idIndexMarker884"/>section, we'll create a new Azure DevOps <a id="_idIndexMarker885"/>project and import the <strong class="bold">voting app</strong> source code in Azure Repos:</p>&#13;
			<ol>&#13;
				<li value="1">Log in to Azure DevOps and create a new project named <strong class="source-inline">Contoso Voting App</strong> or any other name of your choice.</li>&#13;
				<li>Navigate to Azure Repos and click <strong class="bold">Import a Git repository</strong>. Please import the Azure voting app repository from: <a href="https://github.com/Azure-Samples/azure-voting-app-redis">https://github.com/Azure-Samples/azure-voting-app-redis</a>:</li>&#13;
			</ol>&#13;
			<div>&#13;
				<div id="_idContainer418" class="IMG---Figure">&#13;
					<img src="Images/Figure_11.42_B16392.jpg" alt="Figure 11.42 – Importing the repository&#13;&#10;"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 11.42 – Importing the repository</p>&#13;
			<p>Now that<a id="_idIndexMarker886"/> our repo is ready, let's start with a <a id="_idIndexMarker887"/>build pipeline.</p>&#13;
			<h2 id="_idParaDest-219"><a id="_idTextAnchor236"/>Setting up the CI pipeline</h2>&#13;
			<p>The build pipeline will <a id="_idIndexMarker888"/>be responsible for building the container image and pushing them in ACR. Let's get started: </p>&#13;
			<ol>&#13;
				<li value="1">Log in to Azure<a id="_idIndexMarker889"/> DevOps and open <strong class="bold">Contoso Voting App Project</strong>.</li>&#13;
				<li>Navigate to <strong class="bold">Pipeline</strong> and click <strong class="bold">Create Pipeline</strong>.</li>&#13;
				<li>Click on <strong class="bold">Use the Classic Editor</strong> for creating the pipeline with the UI.</li>&#13;
				<li>Select the source Azure repo that you created in the previous section as the source for the pipeline. </li>&#13;
				<li>For the template, select <strong class="bold">Docker Container</strong> as the template type:<div id="_idContainer419" class="IMG---Figure"><img src="Images/Figure_11.43_B16392.jpg" alt="Figure 11.43 – Docker container pipeline template &#13;&#10;"/></div><p class="figure-caption">Figure 11.43 – Docker container pipeline template </p></li>&#13;
				<li>In the <strong class="bold">Build an Image</strong> task configuration, provide the following values:<p>    a) <strong class="bold">Container Registry Type</strong>: <strong class="bold">Azure Container Registry</strong>.</p><p>    b) Select your <a id="_idIndexMarker890"/>Azure subscription from the dropdown and authorize it.</p><p>    c) Select <strong class="bold">ACR</strong> from the dropdown. </p><p>    d) <strong class="bold">Action</strong>: <strong class="bold">Build an image</strong>.</p><p>    e) <strong class="bold">Docker File</strong>: The <strong class="source-inline">root/azure-vote/Dockerfile</strong> repo.</p><p>    f) Check <strong class="bold">Include Latest Tag</strong>:</p><div id="_idContainer420" class="IMG---Figure"><img src="Images/Figure_11.44_B16392.jpg" alt="Figure 11.44 – Push an image &#13;&#10;"/></div><p class="figure-caption"> </p><p class="figure-caption">Figure 11.44 – Push an image </p></li>&#13;
				<li>In the <strong class="bold">Push an image</strong> task, select the Azure subscription and ACR again, with the task <a id="_idIndexMarker891"/>being <strong class="bold">Push an image</strong>. Be sure to check <strong class="bold">Include Latest Tag</strong>. </li>&#13;
				<li>Once you're done, review both tasks and click <strong class="bold">Save and Run</strong> to start the pipeline job execution.</li>&#13;
				<li>Review the job logs to see the detailed information about image building and pushing to ACR.</li>&#13;
				<li>Upon completion, navigate to the Azure portal and open the container registry you created earlier. </li>&#13;
				<li>Navigate to <strong class="bold">Repositories</strong>; you should see a new image being created there. Let's look at the image and find out the image name to update in our application deployment configuration:<div id="_idContainer421" class="IMG---Figure"><img src="Images/Figure_11.45_B16392.jpg" alt="Figure 11.45 – Container image in ACR&#13;&#10;"/></div><p class="figure-caption">Figure 11.45 – Container image in ACR</p></li>&#13;
				<li>Make a note<a id="_idIndexMarker892"/> of the image pull connection string. We'll need it in the next exercise:<div id="_idContainer422" class="IMG---Figure"><img src="Images/Figure_11.46_B16392.jpg" alt="Figure 11.46 – Image syntax in ACR&#13;&#10;"/></div><p class="figure-caption">Figure 11.46 – Image syntax in ACR</p></li>&#13;
				<li>Our pipeline is now ready and tested, so let's go back and enable CI in the pipeline trigger configuration:</li>&#13;
			</ol>&#13;
			<div>&#13;
				<div id="_idContainer423" class="IMG---Figure">&#13;
					<img src="Images/Figure_11.47_B16392.jpg" alt="Figure 11.47 – Enabling CI  &#13;&#10;"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 11.47 – Enabling CI </p>&#13;
			<p>Now that our CI <a id="_idIndexMarker893"/>pipeline is ready, let's start with the deployment pipeline. </p>&#13;
			<h2 id="_idParaDest-220"><a id="_idTextAnchor237"/>Setting up the CD pipeline</h2>&#13;
			<p>In this section, we'll<a id="_idIndexMarker894"/> set up the deployment pipeline, which will deploy the application code to AKS and update when necessary. Azure Pipelines provides native integration with Kubernetes clusters hosted on-premises and in the cloud. </p>&#13;
			<h3>Updating the Kubernetes deployment manifest file</h3>&#13;
			<p>In the Kubernetes <a id="_idIndexMarker895"/>world, application <a id="_idIndexMarker896"/>deployment is managed through manifest files written in JSON or YAML. The deployment file for this sample application is already included in the Azure repo. You can review the deployment configuration by reviewing the <strong class="source-inline">azure-vote-all-in-one-redis.yaml</strong> file in the Azure Repos root.</p>&#13;
			<p>By default, the deployment manifest is configured to use the Microsoft-provided container image. We'll need to update it to start using our own custom image. Let's get started:</p>&#13;
			<ol>&#13;
				<li value="1">Navigate to <strong class="bold">Azure Repos</strong> and open the <strong class="source-inline">azure-vote-all-in-one-redis.yaml</strong> file.</li>&#13;
				<li>Click on <strong class="bold">Edit</strong> at the top-right corner of the file editor.</li>&#13;
				<li>Look for the following part of the deployment manifest. This redirects the container engine to use a Microsoft-provided Docker image:<p class="source-code"><strong class="bold">image: microsoft/azure-vote-front:v1</strong></p></li>&#13;
				<li>Replace the value with your own container registry and image name. It should look like the one given as follows. You should specify the latest tag to ensure that the newest image is always used:<p class="source-code"> <strong class="bold">image: contosostageacr.azurecr.io/contosovotingapp:latest</strong></p></li>&#13;
				<li>Commit<a id="_idIndexMarker897"/> the changes to <a id="_idIndexMarker898"/>save the deployment manifest file. </li>&#13;
			</ol>&#13;
			<p>Your application manifest is now ready for deployment. </p>&#13;
			<h3>Setting up the release pipeline</h3>&#13;
			<p>The release<a id="_idIndexMarker899"/> pipeline will be applying the deployment manifest in<a id="_idIndexMarker900"/> the Kubernetes cluster and perform image update tasks. Let's build a pipeline to automate the deployment:</p>&#13;
			<ol>&#13;
				<li value="1">Log in to <strong class="bold">Azure DevOps</strong> | <strong class="bold">Pipelines</strong> | <strong class="bold">Releases</strong>.</li>&#13;
				<li>Create a new release pipeline. Select the <strong class="bold">Deploy to a Kubernetes cluster</strong> template:<div id="_idContainer424" class="IMG---Figure"><img src="Images/Figure_11.48_B16392.jpg" alt="Figure 11.48 – The Deploy to a Kubernetes cluster template &#13;&#10;"/></div><p class="figure-caption">Figure 11.48 – The Deploy to a Kubernetes cluster template </p></li>&#13;
				<li>Update<a id="_idIndexMarker901"/> the <a id="_idIndexMarker902"/>stage name to <strong class="source-inline">Development Environment</strong>. </li>&#13;
				<li>Let's start with adding artifacts. Click on <strong class="bold">Add</strong> in <strong class="bold">artifacts</strong>. </li>&#13;
				<li>In <strong class="bold">Artifact</strong>, select the Azure repo and choose the repository we imported. Click <strong class="bold">Add</strong>:<div id="_idContainer425" class="IMG---Figure"><img src="Images/Figure_11.49_B16392.jpg" alt="Figure 11.49 – Adding an artifact to a pipeline &#13;&#10;"/></div><p class="figure-caption"> </p><p class="figure-caption">Figure 11.49 – Adding an artifact to a pipeline </p></li>&#13;
				<li>In the <strong class="bold">Tasks section</strong>, let's<a id="_idIndexMarker903"/> configure a task to <a id="_idIndexMarker904"/>perform the application deployment. Configure the <strong class="bold">kubectl</strong> task as follows:<p>    a) <strong class="bold">Display Name</strong>: <strong class="source-inline">Deploy to Kubernetes</strong>.</p><p>    b) <strong class="bold">Kubernetes Service Connection</strong>: Create a new server connection and connect to your AKS cluster created earlier:</p><div id="_idContainer426" class="IMG---Figure"><img src="Images/Figure_11.50_B16392.jpg" alt="Figure 11.50 – Kubernetes service connection&#13;&#10;"/></div><p class="figure-caption">Figure 11.50 – Kubernetes service connection</p><p>    c) <strong class="bold">Command</strong>: <strong class="bold">Apply</strong>.</p><p>    d) Click <a id="_idIndexMarker905"/>on <strong class="bold">Choose configuration file</strong> to <a id="_idIndexMarker906"/>provide a path to your deployment YAML file (<strong class="source-inline">azure-vote-all-in-one-redis.yaml</strong>). Browse to your default directory and select the deployment YAML file. We can define additional options, such as Kubernetes secrets and config maps, if required. Click <strong class="bold">Save</strong> after verifying that all the configurations are valid:</p><div id="_idContainer427" class="IMG---Figure"><img src="Images/Figure_11.51_B16392.jpg" alt="Figure 11.51 – Selecting the deployment YAML &#13;&#10;"/></div><p class="figure-caption">Figure 11.51 – Selecting the deployment YAML </p><p>    e) Review the <a id="_idIndexMarker907"/>task configurations<a id="_idIndexMarker908"/> and click <strong class="bold">Save</strong> to save the progress so far:</p><div id="_idContainer428" class="IMG---Figure"><img src="Images/Figure_11.52_B16392.jpg" alt="Figure 11.52 – Task configuration  &#13;&#10;"/></div><p class="figure-caption">Figure 11.52 – Task configuration  </p></li>&#13;
				<li>Now, we'll add <a id="_idIndexMarker909"/>another step in the pipeline so that<a id="_idIndexMarker910"/> we can update the images in AKS after deployment. This will ensure that, at every release, Kubernetes is pulling the latest images. Click on the <strong class="bold">+</strong> sign to add another <strong class="bold">kubectl</strong> task to the pipeline.</li>&#13;
				<li>Configure the task so that it uses the same Kubernetes connection. Under <strong class="bold">Command</strong>, keep <strong class="bold">set</strong> as the command and use <strong class="source-inline">image deployments/azure-vote-front azure-vote-front=youracrname.azurecr.io/contosovotingapp:latest</strong> as the argument. In a production deployment, you may not want to use the latest tag in your pipeline and rather refer to the version tag generated using the build pipeline. This will help you manage your deployments with specific versions and roll back easily if you wish to. </li>&#13;
				<li>Once you're ready, save the pipeline and create a release to test the deployment pipeline.</li>&#13;
				<li>Review the release logs to understand the deployment steps and flow. </li>&#13;
				<li>Once it's completed successfully, go back to editing the pipeline again and enable continuous deployment:<div id="_idContainer429" class="IMG---Figure"><img src="Images/Figure_11.53_B16392.jpg" alt="Figure 11.53 – Enabling continuous deployment &#13;&#10;"/></div><p class="figure-caption">Figure 11.53 – Enabling continuous deployment </p><p>With that, our build and <a id="_idIndexMarker911"/>release configuration with full CI/CD <a id="_idIndexMarker912"/>automation is ready. Let's look at the AKS cluster to ensure that our application has been deployed properly and is accessible (with the release that we just did):</p></li>&#13;
				<li>Connect to your AKS cluster using the Azure shell. </li>&#13;
				<li>Run <strong class="source-inline">kubectl get pods</strong> and <strong class="source-inline">kubectl get services</strong>:<div id="_idContainer430" class="IMG---Figure"><img src="Images/Figure_11.54_B16392.jpg" alt="Figure 11.54 – The kubectl results &#13;&#10;"/></div><p class="figure-caption">Figure 11.54 – The kubectl results </p></li>&#13;
				<li>Make a note of the public IP of the <strong class="source-inline">azure-vote-front</strong> application. You can try launching the public IP to check that the application is working as expected:</li>&#13;
			</ol>&#13;
			<div>&#13;
				<div id="_idContainer431" class="IMG---Figure">&#13;
					<img src="Images/Figure_11.55_B16392.jpg" alt="Figure 11.55 – Voting app launched&#13;&#10;"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 11.55 – Voting app launched</p>&#13;
			<p>Next, we will be<a id="_idIndexMarker913"/> simulating an end-to-end CI/CD experience for this <a id="_idIndexMarker914"/>application.</p>&#13;
			<h2 id="_idParaDest-221"><a id="_idTextAnchor238"/>Simulating an end-to-end CI/CD experience</h2>&#13;
			<p>In the previous<a id="_idIndexMarker915"/> sections, we set up a CI/CD pipeline. Let's try to play around with it and experience the overall flow. Let's start by updating the title of the application from <strong class="bold">Azure Voting App</strong> to <strong class="bold">Contoso Voting App</strong>:</p>&#13;
			<ol>&#13;
				<li value="1">Browse to <strong class="bold">Azure Repos</strong> | <strong class="bold">Files</strong> | <strong class="bold">azure-vote</strong> | <strong class="bold">azure-vote</strong> | <strong class="bold">config_file.cfg</strong> and click <strong class="bold">Edit</strong>.</li>&#13;
				<li>Change the value of <strong class="bold">Title</strong> from <strong class="bold">Azure Voting App</strong> to <strong class="bold">Contoso Voting App</strong>:<div id="_idContainer432" class="IMG---Figure"><img src="Images/Figure_11.56_B16392.jpg" alt="Figure 11.56 – Updating the app name  &#13;&#10;"/></div><p class="figure-caption">Figure 11.56 – Updating the app name  </p></li>&#13;
				<li>Commit the changes through a pull request process. </li>&#13;
				<li>Once the pull request is completed, a build pipeline will trigger that will build the Docker<a id="_idIndexMarker916"/> images and push to ACR.</li>&#13;
				<li>Once the build pipeline is completed, it'll trigger the release pipeline to start another release. In the end, you should see that your web application is updated with the title.</li>&#13;
			</ol>&#13;
			<p>This concludes setting up a CI/CD pipeline for container-based infrastructure hosted on AKS. </p>&#13;
			<h1 id="_idParaDest-222"><a id="_idTextAnchor239"/>Azure Architecture Center for DevOps</h1>&#13;
			<p>Azure Architecture <a id="_idIndexMarker917"/>Center is a centralized place to take<a id="_idIndexMarker918"/> guidance for architecting solutions on Azure using established patterns and practices. There are several sample architectures available around DevOps. </p>&#13;
			<p>You can access Azure <a id="_idIndexMarker919"/>Architecture Center here: <a href="https://docs.microsoft.com/en-us/azure/architecture/">https://docs.microsoft.com/en-us/azure/architecture/</a>.</p>&#13;
			<p>Refer to the following links to learn more about planning the right architecture for DevOps across various infrastructure and application scenarios:</p>&#13;
			<ul>&#13;
				<li>Azure DevOps: <a href="https://docs.microsoft.com/en-us/azure/architecture/example-scenario/apps/devops-dotnet-webapp">https://docs.microsoft.com/en-us/azure/architecture/example-scenario/apps/devops-dotnet-webapp</a></li>&#13;
				<li>DevOps with containers: <a href="https://docs.microsoft.com/en-us/azure/architecture/example-scenario/apps/devops-with-aks">https://docs.microsoft.com/en-us/azure/architecture/example-scenario/apps/devops-with-aks</a></li>&#13;
				<li>Microservices with AKS and Azure DevOps: <a href="https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/microservices-with-aks">https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/microservices-with-aks</a></li>&#13;
				<li>Secure DevOps for AKS: <a href="https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/secure-devops-for-kubernetes">https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/secure-devops-for-kubernetes</a></li>&#13;
				<li>Azure <a id="_idIndexMarker920"/>DevOps<a id="_idIndexMarker921"/> CI/CD pipelines for chatbots: <a href="https://docs.microsoft.com/en-us/azure/architecture/example-scenario/apps/devops-cicd-chatbot">https://docs.microsoft.com/en-us/azure/architecture/example-scenario/apps/devops-cicd-chatbot</a></li>&#13;
				<li>CI/CD for Azure VMs: <a href="https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/cicd-for-azure-vms">https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/cicd-for-azure-vms</a> </li>&#13;
				<li>CI/CD for Azure web apps: <a href="https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/azure-devops-continuous-integration-and-continuous-deployment-for-azure-web-apps">https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/azure-devops-continuous-integration-and-continuous-deployment-for-azure-web-apps</a> </li>&#13;
				<li>CI/CD for containers: <a href="https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/cicd-for-containers">https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/cicd-for-containers</a> </li>&#13;
				<li>Container CI/CD using Jenkins and Kubernetes on AKS: <a href="https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/container-cicd-using-jenkins-and-kubernetes-on-azure-container-service">https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/container-cicd-using-jenkins-and-kubernetes-on-azure-container-service</a> </li>&#13;
				<li>DevSecOps in Azure: <a href="https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/devsecops-in-azure">https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/devsecops-in-azure</a> </li>&#13;
				<li>DevTest deployment for testing IaaS solutions: <a href="https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/dev-test-iaas">https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/dev-test-iaas</a> </li>&#13;
				<li>DevTest deployment for testing PaaS solutions: <a href="https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/dev-test-paas">https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/dev-test-paas</a> </li>&#13;
				<li>DevTest deployment for testing microservice solutions: <a href="https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/dev-test-microservice">https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/dev-test-microservice</a> </li>&#13;
				<li>DevTest Image Factory: <a href="https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/dev-test-image-factory">https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/dev-test-image-factory</a> </li>&#13;
				<li>Immutable infrastructure CI/CD using Jenkins and Terraform on Azure virtual architecture overview: <a href="https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/immutable-infrastructure-cicd-using-jenkins-and-terraform-on-azure-virtual-architecture-overview">https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/immutable-infrastructure-cicd-using-jenkins-and-terraform-on-azure-virtual-architecture-overview</a> </li>&#13;
				<li>DevOps in a hybrid environment: <a href="https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/java-cicd-using-jenkins-and-azure-web-apps">https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/java-cicd-using-jenkins-and-azure-web-apps</a> </li>&#13;
				<li>Java CI/CD <a id="_idIndexMarker922"/>using Jenkins and Azure web <a id="_idIndexMarker923"/>apps: <a href="https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/java-cicd-using-jenkins-and-azure-web-apps">https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/java-cicd-using-jenkins-and-azure-web-apps</a> </li>&#13;
				<li>Run a Jenkins server on Azure: <a href="https://docs.microsoft.com/en-us/azure/architecture/example-scenario/apps/jenkins">https://docs.microsoft.com/en-us/azure/architecture/example-scenario/apps/jenkins</a></li>&#13;
				<li>SharePoint Farm for development testing: <a href="https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/sharepoint-farm-devtest">https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/sharepoint-farm-devtest</a> </li>&#13;
				<li>Sharing location in real time using low-cost serverless Azure services: <a href="https://docs.microsoft.com/en-us/azure/architecture/example-scenario/signalr/">https://docs.microsoft.com/en-us/azure/architecture/example-scenario/signalr/</a> </li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-223"><a id="_idTextAnchor240"/>Summary</h1>&#13;
			<p>In this chapter, we looked at a .NET and SQL-based application and set up a CI/CD pipeline for it using Azure DevOps. We looked at how you manage your production and staging environments through approval workflows.</p>&#13;
			<p>Similarly, we also looked at a container-based application and did a walkthrough of setting up an end-to-end CI/CD pipeline for the application using ACR and AKS. </p>&#13;
			<p>In the end, we talked about Azure Architecture Center, which can be referred to while planning your DevOps architecture. </p>&#13;
			<p>This was the final chapter, and we hope you have enjoyed reading this book!</p>&#13;
		</div>&#13;
	</div></body></html>