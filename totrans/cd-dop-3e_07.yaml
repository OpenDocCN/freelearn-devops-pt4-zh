- en: Vital Measurements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要的衡量指标
- en: Over the previous chapters, we have looked at what tools and techniques you
    should be considering, the need to acknowledge how change will impact people in
    different ways, why culture, behaviors, and environment are important, what potential
    hurdles you'll need to overcome, and how all of this is needed to successfully
    adopt CD and DevOps. If you are taking this into account, creating plans to cater
    for and/or address this, you should be in a good shape to make wide strides forward.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们探讨了你应该考虑哪些工具和技术，如何认识到变革会以不同的方式影响人们，为什么文化、行为和环境如此重要，哪些潜在障碍需要克服，以及这些内容如何帮助你成功地采纳CD和DevOps。如果你已经考虑到这些，并为此制定了计划来应对和/或解决这些问题，那么你应该已经为迈出更大步伐做好了准备。
- en: We will now look at the important but sometimes overlooked—or simply dismissed—area
    of monitoring and measuring progress. We did touch on this subject previously,
    but what we considered was a small slice of the pie, figuratively speaking. What
    we're looking at now is the capturing, compiling, and sharing of metrics related
    to the impact that CD and DevOps has on the day-to-day ways of working and the
    business as a whole.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要关注的是一个重要但有时被忽视——或干脆被忽略——的领域：监控和衡量进展。我们之前曾涉及过这个话题，但当时我们只是看到了其中一小部分。现在我们要探讨的是与持续交付（CD）和开发运维（DevOps）对日常工作方式和整个业务的影响相关的指标的收集、汇总和共享。
- en: This, on the face of it, might be seen as something that is only useful to the
    management types and won't add value to those who will be dealing with the CD
    and DevOps adoption on a day-to-day basis. In some regards, that is true, but
    being able to analyze, understand, and share demonstrable progress will definitely
    add value to you and everyone else who is on the CD and DevOps journey. We're
    not just talking about simple project management charts, graphs, and PowerPoint
    fodder here; what we are looking at is measuring as many aspects of the overall
    process as possible. That way, anyone and everyone can plainly see and understand
    how far you have collectively come and how far from the ultimate goal you are.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从表面上看，这可能被认为只对管理层有用，对那些每天处理CD和DevOps采纳的人没有价值。从某种程度上来说，这是对的，但能够分析、理解和分享可证明的进展，肯定会为你和所有在CD和DevOps旅程中的人带来价值。我们这里说的不是简单的项目管理图表、图形和PowerPoint材料；我们要看的是真正衡量整个流程尽可能多的方面。这样，每个人都能清晰地看到并理解你们集体已经取得的进展，并且了解距离最终目标还有多远。
- en: To do this effectively, you'll need to ensure that you start this data capture
    very early into the CD and DevOps adoption, as it will be very difficult to see
    a comparison between then and now if you don't have data representing *then*.
    You will need to be vigilant and consistent in ensuring that you are continuously
    capturing these measurements so that you can compare the state of progress at
    different points in time. Some would consider this anal, but this whole CD and
    DevOps journey started because the data captured in the elephant exposure pointed
    to areas of waste—or, at the very least, ineffective processes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地进行这项工作，你需要确保在CD和DevOps采纳的初期就开始收集这些数据，因为如果没有代表*当时*的数据，你将很难进行现在与当时的对比。你需要保持警惕和一致性，确保持续收集这些衡量指标，这样你才能在不同时间点比较进展的状态。有些人可能认为这是过于苛刻，但整个CD和DevOps的旅程正是因为在象限曝光中捕捉到的数据指向了浪费的领域——或者至少是低效的流程——而开始的。
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: How to measure the effectiveness of your engineering process(es)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何衡量你的工程流程的有效性
- en: How to measure the stability of the various environments you use and rely on
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何衡量你使用和依赖的各种环境的稳定性
- en: How to measure the impact your adoption of CD and DevOps is having
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何衡量你采纳CD和DevOps所带来的影响
- en: We'll start, as they say, at the beginning and focus initially on engineering
    metrics.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从头开始，首先关注工程度量。
- en: Measuring effective engineering best practices
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 衡量有效的工程最佳实践
- en: 'This is quite a weird concept to get your head around: How can you measure
    effective engineering, and more than that, how can you measure best practices?
    There''s another often-asked question: what has this got to do with DevOps or
    CD? We''ll look at the former in a moment, but now let''s focus on the latter.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当难以理解的概念：如何衡量有效的工程实践，甚至更进一步，如何衡量最佳实践？还有一个常被提问的问题是：这和DevOps或CD有什么关系？我们稍后会讨论前者，但现在我们先专注于后者。
- en: 'Let''s take two scenarios:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看两个场景：
- en: Your current software-engineering process is very waterfall and you have a vast
    amount of manual testing to validate your code just before it gets shipped—which
    happens every 3-6 months—and build in a buffer for bug fixing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你当前的软件工程过程非常瀑布式，并且你有大量的手动测试来验证代码，直到代码准备发布——这一过程通常在3到6个月之间——并且会预留时间来修复BUG。
- en: Your current software-engineering process is pretty agile and follows (mostly)
    industry best practices, however as there is plenty of time between releases you
    can sometimes let technical debt slip (including test automation) as there will
    be time to go back and mop up just before the next release—which happens every
    3-6 months
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你当前的软件工程过程相当灵活，并且大体遵循行业最佳实践。然而，由于发布之间有相当长的时间间隔，你有时可能会忽视技术债务（包括自动化测试），因为你可以在下一次发布前有时间回头去修复——而下一次发布通常是在3到6个月后。
- en: OK, so this is pretty simplistic, but bear with me. As the CD and DevOps adoption
    starts to gather momentum, the time between releases will decrease. Therefore,
    the we can do that later window gets smaller and smaller. This can lead to engineers
    having to start cutting corners simply because they have run out of time to mop
    up the pre-release tech-debt tasks. The adoption of CD and DevOps ultimately allows
    you to deliver solutions quickly—there's nothing that categorically states that
    engineers will be given more time to write and test said solutions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，虽然这个很简化，但请耐心听我说。随着持续交付（CD）和开发运维（DevOps）的推广，发布间隔时间将会缩短。因此，我们可以稍后做的窗口也会越来越小。这可能会导致工程师们为了赶时间而不得不开始“偷工减料”，因为他们已经没有时间去清理发布前的技术债务任务。CD和DevOps的采用最终能够让你快速交付解决方案——并没有什么明确的规定表示工程师会有更多时间来编写和测试这些解决方案。
- en: 'Let''s consider what a large quarterly release looks like in terms of timeline
    and effort, as shown:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一个大型季度发布的时间线和工作量，如下所示：
- en: '![](img/03651732-d728-43e1-aa7c-8725be322b3f.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03651732-d728-43e1-aa7c-8725be322b3f.png)'
- en: 'Now let''s compare that to a CD-type release, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们与CD类型的发布进行比较，如下所示：
- en: '![](img/192a5c25-d72b-4737-8cfe-131a500e1422.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/192a5c25-d72b-4737-8cfe-131a500e1422.png)'
- en: These are both very simplistic examples, but they highlight the impact that
    reducing the time between releases will have on the key players. The we can do
    that later window goes from days/weeks to hours.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是非常简化的例子，但它们突出了减少发布间隔时间对关键角色产生的影响。我们可以稍后做的窗口从几天/几周缩短到几小时。
- en: In [Chapter 5](6a4f746d-b386-49b3-b82b-154ff1f604e8.xhtml)*,* *Approaches, Tools,
    and Techniques*, we looked at how the wider business perceives the relationship
    between features and releases. As your CD and DevOps adoption matures, the time
    between releases will decrease, which means that engineers will have less time
    to complete features. If the wider business has become accustomed to having features
    delivered within a given release, they will continue to expect this until things
    bed in.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](6a4f746d-b386-49b3-b82b-154ff1f604e8.xhtml)*，* *方法、工具和技术*中，我们探讨了更广泛的业务如何看待功能和发布之间的关系。随着你的CD和DevOps采用的成熟，发布间隔时间将缩短，这意味着工程师将有更少的时间来完成功能。如果更广泛的业务已经习惯了在给定的发布中交付功能，他们会继续期待这一点，直到新方式稳定下来。
- en: Let's go back to the corners. These will normally be related to the non-cutting
    code, yet still time-consuming activities—skipping the odd unit test here, leaving
    the odd gap in integration tests there, forgoing documentation, reducing the tendency
    to refactor old code, and so on. In simple terms, the engineers will be under
    pressure to deliver and they will no longer have the time to address everything
    they did previously. This therefore becomes technical debt—which is something
    every software-engineering team tries to avoid at all costs, as it will come back
    to bite them later.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到“偷工减料”的话题。这些通常与非修改代码相关，但仍是耗时的活动——例如跳过某些单元测试、在集成测试中留下一些空白、不做文档、减少重构旧代码的倾向等等。简单来说，工程师们会面临交付压力，他们将不再有时间处理之前完成的所有任务。这因此变成了技术债务——这是每个软件工程团队都尽力避免的，因为它最终会在未来反噬他们。
- en: 'Going back to the main subject of measuring effective engineering best practices,
    it''s not as strange or uncommon as you might think. There are a great number
    of software-based businesses around the globe regularly using tools to capture
    data and measurements for things such as:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 回到衡量有效工程最佳实践的主题，这其实并不像你想象的那样陌生或罕见。全球有大量的软件公司定期使用工具来捕捉数据和测量一些内容，例如：
- en: Overall code quality
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整体代码质量
- en: Adherence to coding rules and standards
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循编码规则和标准
- en: Code documentation
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码文档
- en: Code complexity
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码复杂度
- en: Code duplication
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码重复
- en: Redundant code
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冗余代码
- en: Unit-test coverage
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试覆盖率
- en: Technical debt
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术债务
- en: Mean time between failures
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均故障间隔时间
- en: Mean time to resolution
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均解决时间
- en: Bug-escape distance
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺陷逃逸距离
- en: Fix-bounce rate
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复反弹率
- en: 'Measuring each of these in isolation might not bring a vast amount of value;
    however, when pooled together, you can get a very detailed picture of how things
    stand. In addition, if you can continuously capture this level of detail over
    a period of time, you can then start to measure and report on progress. Why this
    is important to the adoption of CD and DevOps is quite simple: if the quality
    of your software decreases due to the fact that things are being shipped faster,
    the laggards will have a field day. If those laggards are in influential and/or
    decision-making positions, the whole adoption could be derailed.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 单独衡量这些指标可能不会带来太多价值；然而，当它们汇总在一起时，你可以获得一个非常详细的整体情况。此外，如果你能够在一段时间内持续捕获这些详细信息，你就可以开始衡量和报告进展。这对持续交付（CD）和DevOps的采用至关重要，原因很简单：如果由于软件发布速度加快而导致质量下降，落后的人员将有机会借此反击。如果这些落后人员处于有影响力和/或决策岗位，整个采用过程可能会被拖延。
- en: As stated previously, if you can spot this as it starts to happen, you have
    a fighting chance of stopping it. There is also another side to this; if your
    quality currently sucks and you can prove that CD and DevOps adoption helps to
    increase quality, then that's a massive good news story—we can ship quicker and
    the quality is vastly better. Take that, laggards!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果你能在问题开始发生时就发现它，你就有机会去制止它。还有另一面：如果你当前的质量很差，而你能证明持续交付（CD）和DevOps的采用有助于提高质量，那么这就是一个巨大的好消息——我们可以更快发布，而质量大幅提高。给那些落后者看看！
- en: It all sounds very simple, and to be honest, it can be, but you need to be mindful
    of the fact that you will need to apply some time, effort, and rigor to ensure
    that you gain the most value. There will also be a degree of trial and error and
    tweaking as you go, to ensure you can capture the data in a reliable and repeatable
    way—more inspecting and adapting—so you need to ensure that you factor this in.
    Not only will these sorts of measurements help your engineering team(s), they
    will also help with building trust across the wider business. For example, you'll
    be able to provide open, honest, and truthful metrics in relation to the quality
    of your software, which, in turn, will reinforce the trust they have in the team(s)
    building and looking after the platform.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很简单，实际上，确实可以做到，但你需要注意，你需要投入一些时间、精力和严格性，确保能够获得最大的价值。过程中也会有一定的试错和调整，以确保能够以可靠和可重复的方式捕获数据——更多的检查和适应——因此你需要确保考虑到这一点。这些衡量标准不仅会帮助你的工程团队，也会有助于在更广泛的业务中建立信任。例如，你将能够提供开放、诚实、真实的软件质量指标，这反过来会增强他们对开发和维护平台的团队的信任。
- en: 'One thing to seriously consider before you look at measuring things such as
    software code metrics is how the engineers themselves will feel about this. What
    Devina is thinking might be a typical reaction:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始衡量诸如软件代码指标等事物之前，有一点需要认真考虑：工程师自己对此的感受。Devina的想法可能是典型反应之一：
- en: '![](img/1c570634-a501-428f-b725-635fd0fb9e24.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c570634-a501-428f-b725-635fd0fb9e24.png)'
- en: A typical reaction to this approach
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对这种方法的典型反应
- en: Some engineers will become guarded or defensive, and may see it as questioning
    their skills and craftsmanship in relation to creating quality code. You need
    to be careful that you don't get barriers put up between you and the engineering
    teams or let them slip back into the *laggards* camp. You should *sell* these
    tools as a positive benefit for the engineers. For example, they have a way to
    definitively prove how good their code actually is; they can use the tools to
    inspect areas of over-complexity or areas of code that are more at risk of containing
    bugs; they can highlight redundant code and remove it from the codebase; and they
    can visually see hard dependencies, which can help when looking at componentization.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一些工程师可能会变得防备或防守，认为这在质疑他们在创建高质量代码方面的技能和工艺。你需要小心，避免在你与工程团队之间建立障碍，也要避免让他们回到*落后者*阵营。你应该将这些工具作为工程师的积极利益来*推销*。例如，他们可以明确证明自己的代码有多好；他们可以利用这些工具检查过于复杂的区域或可能包含漏洞的代码区域；他们可以突出冗余代码并从代码库中移除；他们还可以直观地看到硬依赖关系，这在进行组件化时有很大帮助。
- en: If you have vocal laggards, get them actively involved in the setup and configuration
    of the tools (for example, they could take ownership of defining the threshold
    of acceptable code coverage or choose the tools to be implemented)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些发声的拖后腿者，让他们积极参与工具的设置和配置（例如，他们可以负责定义可接受的代码覆盖率的门槛，或者选择要实施的工具）。
- en: If nothing else, you need to ensure that you have the innovators and followers
    from the engineering community brought in. To add some clarity, let's look at
    a few items from the preceding list—which, by the way, is not exhaustive—in a
    little more detail, and examine why they are potentially important to your CD
    and DevOps adoption. Let's start with code complexity.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有别的，你需要确保工程社区中的创新者和追随者都能参与其中。为了更清晰地说明这一点，我们来看一下前面列表中的几个项目——顺便说一下，这个列表并不完整——并更详细地探讨它们为什么对你的持续交付（CD）和开发运维（DevOps）采用可能至关重要。我们从代码复杂度开始。
- en: Code complexity
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码复杂度
- en: Having complex code is sometimes necessary, especially when you're looking at
    extremely optimized code where in resources are limited and/or there is a real-time
    UI—basically, where every millisecond counts. When you have something such as
    an online store, login page, or a finance module, having overly complex code can
    do more harm than good. Some engineers believe they are special because they can
    write complex code; however, complexity for complexity's sake is really just showing
    off.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有复杂代码有时是必要的，特别是在面对极其优化的代码时，尤其是在资源有限和/或需要实时UI的情况下——基本上是每毫秒都很重要的场景。当你拥有像在线商店、登录页面或财务模块这样的功能时，过于复杂的代码反而可能弊大于利。一些工程师认为他们很特别，因为他们能写复杂的代码；然而，单纯为了复杂而复杂其实就是在炫耀。
- en: Overly complex code can cause lots of general problems—especially when trying
    to debug or when you're trying to extend it to cater for additional use cases—which
    can directly impact the speed at which you can implement even the smallest change.
    The premise of CD is to deliver small, incremental, quality changes. If your code
    is too complex to allow for this, you are going to have issues down the line—normally
    referred to the maintainability, testability, and readability of the code base.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 过于复杂的代码可能会导致许多普遍性的问题——特别是在调试时，或者在你试图扩展代码以满足更多使用案例时——这直接影响到你实施哪怕是最小改动的速度。持续交付的前提是交付小而渐进的高质量改动。如果你的代码过于复杂，以至于无法实现这一点，那么你将在未来遇到问题——通常这被称为代码的可维护性、可测试性和可读性。
- en: I would recommend that you put some time aside to look into this complex (pun
    intended) subject in more detail before you dive into implementing any process
    or tooling. You really need to understand what the underlying principles are and
    the science behind them; otherwise, this will become messy and confused. Some
    of the science is explained in the [Appendix A](b212024b-5ba5-4f01-b76d-a8367c6ec41c.xhtml),
    *Some Useful Information*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你在开始实施任何过程或工具之前，先花些时间更深入地研究这个复杂的（带有双关意味）主题。你真的需要理解其背后的基本原则和科学原理；否则，这将变得混乱不堪。某些科学原理在[附录A](b212024b-5ba5-4f01-b76d-a8367c6ec41c.xhtml)，*一些有用的信息*中做了详细解释。
- en: One suggestion would be to take one of the various code-analysis tools available
    and run a trial to profile your code base, which will help highlight some existing
    pain points. From this, you can start to formulate a plan.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个建议是，选择一些现有的代码分析工具，进行试用，分析你的代码库，帮助你找出一些现有的痛点。通过这些，你可以开始制定一个计划。
- en: The next thing you could consider is code coverage.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你接下来可以考虑的一个方面是代码覆盖率。
- en: Unit-test coverage
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试覆盖率
- en: Incorporating unit tests within the software-development process is uniformly
    recognized as best practice—[Chapter 6](e0c2e609-a018-4a15-aa14-e01fde967902.xhtml),
    *Avoiding Hurdles*. There is a vast amount of information available on this subject,
    so I won't spend too much time focusing on this here, but I would recommend that
    you apply some time and effort into investigating this subject and how you can
    adopt this approach within your SDLC.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发过程中引入单元测试被广泛认为是最佳实践——[第6章](e0c2e609-a018-4a15-aa14-e01fde967902.xhtml)，*避免障碍*。这个主题有大量的信息可供参考，因此我不会在这里花太多时间讨论，但我建议你投入一些时间和精力，研究一下这个主题以及如何在你的软件开发生命周期（SDLC）中采用这种方法。
- en: So as not to short-change you, I will provide some insight and background into
    this subject in relation to CD and DevOps.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不让你觉得我在敷衍你，我将提供一些关于这个主题的见解和背景，特别是与CD和DevOps相关的部分。
- en: At a simplistic level, unit tests allow software-engineering teams to exercise
    and validate code paths and logic at a granular level during the development process;
    this, in turn, can help spot and eradicate software defects very early on. Incorporating
    these tests within CI (see the [Chapter 6](e0c2e609-a018-4a15-aa14-e01fde967902.xhtml),
    *Avoiding Hurdles*, for information on CI) and having them stop the build can
    help stop defects escaping into downstream phases of the CD pipeline. This can
    also be used as an early warning for regression; for example, if the unit test
    that was previously working starts to fail, there is a high probability that regression
    has been introduced.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从简单的角度看，单元测试允许软件工程团队在开发过程中对代码路径和逻辑进行粒度化的验证，这反过来可以帮助尽早发现并消除软件缺陷。将这些测试纳入持续集成（见[第6章](e0c2e609-a018-4a15-aa14-e01fde967902.xhtml)，*避免障碍*，了解持续集成的相关信息）并让它们在构建过程中阻止错误，可以帮助防止缺陷进入持续交付管道的下游阶段。这也可以作为回归的早期警告；例如，如果一个先前正常的单元测试开始失败，很可能是引入了回归问题。
- en: The premise of CD is to be able to ship changes frequently. If you have good
    unit test coverage across the codebase, you will have a greater level of confidence
    that you can ship that code frequently with reduced risk.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付的前提是能够频繁发布变更。如果你的代码库中有良好的单元测试覆盖率，你将对频繁发布该代码并降低风险充满信心。
- en: Analyzing the coverage is a good indication as to how much you can rely upon
    unit tests to spot problems. You can also use this data to map out the areas of
    risk when it comes to shipping code quickly (for example, if your login page is
    frequently changed and has a high level of coverage, the risk of shipping this
    frequently becomes lower).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 分析覆盖率是一个很好的指标，能够表明你在多大程度上可以依赖单元测试来发现问题。你还可以利用这些数据绘制出在快速发布代码时的风险领域（例如，如果你的登录页面经常被修改并且覆盖率较高，那么频繁发布该页面的风险会较低）。
- en: There is one thing you do need to take into account regarding coverage measurements—that
    being the mix of legacy versus new code. What you'll usually find is that legacy
    code—especially that based on older technologies—may have little-to-no unit-test
    coverage. If this type of code makes up the majority of your code base, the coverage
    measure will be pretty low. If the wider business gets too hung up on this measure,
    they may perceive a low score as a major risk. Although this is technically true,
    you can't really expect to have older code fully covered from day one. You therefore
    need to ensure you set the context of the data and have a plan for increasing
    the coverage over time. One approach would be to set a rule that all new code
    or refactored code should have a high degree of coverage (ideally 100% as long
    as this is attainable without slipping into the realm of. diminishing returns),
    and that the overall coverage figure must grow as refactoring of legacy code increases.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件事是你需要考虑的，关于覆盖率的衡量——即旧代码与新代码的混合。你通常会发现，旧代码，尤其是基于旧技术的代码，可能几乎没有单元测试覆盖。如果这类代码占据了你代码库的大部分，覆盖率的衡量结果会非常低。如果更广泛的业务团队过于关注这一指标，他们可能会将低分数视为一个重大风险。虽然从技术角度讲这是正确的，但你不能指望从第一天开始就对旧代码进行全面覆盖。因此，你需要确保为数据设定一个上下文，并制定一个随着时间推移提高覆盖率的计划。一种方法是设定一个规则，要求所有新代码或重构代码应该有较高的覆盖率（理想情况下是100%，前提是在不进入收益递减领域的情况下可以实现），并且随着旧代码重构的增加，总体覆盖率应当增长。
- en: Let's now look at the effectiveness of measuring the frequency of commits.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下提交频率的衡量效果。
- en: Commit and merge rates
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交和合并率
- en: Regular commits to source control is something that should be widely encouraged
    and deeply embedded within your ways of working. Having source code sitting on
    people's workstations or laptops for prolonged periods of time is very risky and
    can sometimes lead to duplication of effort or, worse still, might block the progress
    of other engineers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 定期提交源代码到版本控制系统是应该广泛鼓励并深度嵌入工作方式的一部分。将源代码长时间存放在个人的工作站或笔记本电脑上是非常危险的，有时会导致重复劳动，甚至更糟的情况是，可能会阻碍其他工程师的进展。
- en: There might be a fear that if engineers commit too frequently, the chance of
    defects being created increases, especially when you think there's an outside
    risk that unfinished code could be incorporated into the main code branch. This
    fear is a fallacy. No engineer worth their salt would seriously consider doing
    such a thing—why would they? If you have checks and balances in place, such as
    regular code reviews or a pull-request approval process, the risk of buggy code
    being merged will be vastly reduced. Add in unit tests and code analysis and you're
    looking at next-to-no risk.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有人担心，如果工程师提交代码太频繁，创建缺陷的机会会增加，特别是当你认为未完成的代码可能会被合并到主代码分支时。这种担心是个谬论。没有任何一位称职的工程师会认真考虑做这种事——为什么要这么做？如果你有像定期代码审查或拉取请求审批流程这样的检查和制衡，合并有缺陷的代码的风险将大大减少。再加上单元测试和代码分析，你几乎可以消除风险。
- en: Opposite to this is the very real risk of delays between commits and code merges.
    The more code there is to be merged, the greater the risk and the higher the potential
    for code conflicts, defects, and incomplete functionality to be introduced. The
    CD approach is based on delivering working software often. This should not be
    restricted to software binaries; delivering small incremental chunks of source
    code little and often is also a good practice.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反的是，提交和代码合并之间存在非常真实的延迟风险。需要合并的代码越多，风险就越大，引入代码冲突、缺陷和不完整功能的潜力也就越高。持续交付（CD）方法的核心是经常交付可工作的软件。这不仅限于软件二进制文件；经常交付小的增量源代码也是一种良好的实践。
- en: Most source control systems will have tools and or logs that can be analyzed
    by third-party tools. The sort of data you should be analyzing will include such
    things as number of commits and merges per engineer per day, time between merges,
    and which areas of the code base are changed most frequently.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数源代码控制系统会提供可以通过第三方工具分析的工具和日志。你需要分析的数据包括每天每位工程师的提交和合并次数、合并之间的时间间隔，以及代码库中哪些区域被更改的最频繁。
- en: 'From this data, you can start to see patterns, such as seeing who is playing
    ball and who isn''t, and what areas of the code base carry the most risk. A word
    of warning: don''t use this data to reward or punish engineers, as this can promote
    the wrong kinds of behaviors and can be as damaging as ignoring engineering best
    practices.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些数据中，你可以开始看到一些模式，例如谁在积极合作，谁没有，以及代码库中哪些区域承载着最大的风险。提醒一下：不要使用这些数据来奖励或惩罚工程师，因为这可能会促使错误的行为，甚至可能像忽视工程最佳实践一样具有破坏性。
- en: Next, we'll look at the thorny issue of code violations and adherence to rules.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论代码违规和遵循规则的棘手问题。
- en: Adherence to coding rules and standards
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遵循编码规则和标准
- en: You may already have coding standards within your software-development teams
    and/or try to adhere to an externally-documented and recognized best practice.
    Being able to analyze your code base to see which parts do and don't adhere to
    the standards is extremely useful as it helps highlight areas of potential risk.
    If you continue to capture this data over time, you can start to spot trends—especially
    when these figures start to fall.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在软件开发团队中制定了编码标准和/或试图遵循外部文档化和公认的最佳实践。能够分析你的代码库，查看哪些部分符合标准，哪些不符合，是非常有用的，因为它有助于突出潜在的风险区域。如果你随着时间的推移持续捕获这些数据，你将能开始发现趋势——尤其是当这些数字开始下降时。
- en: There are a number of tools available to help you do this, some of which are
    listed in [Appendix A](b212024b-5ba5-4f01-b76d-a8367c6ec41c.xhtml), Some *Useful
    Information*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多工具可以帮助你做到这一点，其中一些列在[附录 A](b212024b-5ba5-4f01-b76d-a8367c6ec41c.xhtml)中，*一些有用的信息*。
- en: This type of analysis will take some setting up, as it is normally based on
    a set of predefined rules and thresholds (for example, info, minor, major, critical,
    and blocker), and you'll need to work with the engineering teams to agree on and
    set these up within your tooling.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的分析需要一些设置，因为它通常基于一组预定义的规则和阈值（例如，信息、次要、主要、关键和阻塞），你需要与工程团队合作，商定并在工具中设置这些内容。
- en: Measuring adherence to coding rules and standards goes some way to stopping
    defects in your code leaking, but software is software and defects will sneak
    through. What you therefore need to do is analyze what happens when they do.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 衡量遵循编码规则和标准有助于防止代码中的缺陷泄露，但软件就是软件，缺陷总会悄悄出现。因此，你需要做的是分析缺陷出现后的情况。
- en: Quality metrics
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 质量指标
- en: Quality is something that everyone involved in writing and delivering software
    should want to uphold and build into their solutions. The preceding sections included
    some elements of quality metrics, but you should also consider some specific measurements
    targeted on time.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 质量是所有参与编写和交付软件的人应该希望维护并融入其解决方案的东西。前面的部分包含了一些质量度量的元素，但你还应该考虑一些专门针对时间的具体度量。
- en: 'The ones that are pertinent to CD and DevOps are **Mean time between failures**
    (**MTBF**), **Mean time to resolution** (**MTTR**), and defect-escape distance,
    which are explained as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与CD和DevOps相关的关键指标是**平均故障间隔时间**（**MTBF**）、**平均修复时间**（**MTTR**）和缺陷逃逸距离，具体解释如下：
- en: '**MTBF**: This will help you measure how often problems (or failures) are found
    by end users—the longer the time between failures, the greater the stability and
    quality of the overall platform'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MTBF**：这将帮助你衡量最终用户发现问题（或故障）的频率——故障之间的时间越长，整体平台的稳定性和质量越高。'
- en: '**MTTR**: This will help you measure the time taken between an issue being
    found and being fixed'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MTTR**：这将帮助你衡量从发现问题到修复问题所花费的时间'
- en: '**Defect escape distance**: This will help you measure when an issue is found
    and by whom—for example, defects found by the engineering team are close to the
    source of the defect (for example, one of the team), whereas UAT spotting a defect
    is farther out from the source'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺陷逃逸距离**：这将帮助你衡量问题发现的时间和发现者——例如，工程团队发现的缺陷离缺陷源较近（例如，团队中的某个成员），而UAT发现的缺陷则离源头更远。'
- en: The first two give some good indication as to how CD and DevOps adoption is
    going as they relate to the speed of delivery. For example, one would expect MTBF
    to go up and MTTR to go down over time if CD and DevOps adoption is working well.
    If they don't, there's something wrong that needs looking into.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前两者为CD和DevOps的采用情况提供了一些良好的指示，尤其是它们与交付速度的关系。例如，预计如果CD和DevOps的采用运作良好，MTBF会逐渐增加，而MTTR则会逐渐减少。如果没有发生这种变化，那就意味着存在某些问题需要调查。
- en: The third of the trio—defect-escape distance—is a good indication of engineering
    best practices and how well the CD pipeline is picking up issues early. If the
    engineering team is spotting defects early on in the process—for example, a CI
    step fails due to a failing unit test—then the distance and impact is small. If
    a defect escapes to a downstream process—for example, the UAT team—then the distance
    and impact is larger. If a defect gets all the way to the production environment
    then ... well, I think you get the gist.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 三者中的第三个——缺陷逃逸距离——是工程最佳实践和持续集成（CD）管道是否能够及早发现问题的良好指示。如果工程团队在流程早期就能发现缺陷——例如，由于单元测试失败，CI步骤失败——那么距离和影响就很小。如果缺陷逃逸到下游流程——例如，用户验收测试（UAT）团队——那么距离和影响就会更大。如果缺陷最终进入生产环境，那么……我想你应该明白了。
- en: 'One way to represent this is to add a $ value to a defect based upon the environment
    it is found in and the time it took to find it. For example, let''s assume we
    have four environments used as part of the CD pipeline: Dev, QA, UAT, and Prod.
    We then apply a sliding scale of cost for each environment based upon the distance
    from the source:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一种表示方法是根据缺陷所在的环境以及发现它所需的时间，为每个缺陷添加一个美元价值。例如，假设我们有四个环境，作为CD管道的一部分：开发、QA、UAT和生产。然后根据每个环境距离源头的远近，应用一个滑动成本比例：
- en: '| **Env** | **Cost** |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **环境** | **成本** |'
- en: '| Dev | 1 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 开发 | 1 |'
- en: '| QA | 2 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| QA | 2 |'
- en: '| UAT | 8 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| UAT | 8 |'
- en: '| Prod | 16 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 生产 | 16 |'
- en: 'Let''s now consider the cost of each defect using a multiplier based upon the
    lead time between the defect being created and it being spotted. You''ll end up
    with something such as this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑每个缺陷的成本，使用一个乘数，基于缺陷创建和发现之间的交付时间。你将得到如下结果：
- en: '| **Defect#** | **Env** | **Env cost** | **Lead time (days)** | **Defect cost**
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **缺陷#** | **环境** | **环境成本** | **交付时间（天）** | **缺陷成本** |'
- en: '| DE1 | Dev | 1 | 2 | 2 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| DE1 | 开发 | 1 | 2 | 2 |'
- en: '| DE2 | Dev | 1 | 5 | 5 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| DE2 | 开发 | 1 | 5 | 5 |'
- en: '| DE3 | QA | 2 | 10 | 20 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| DE3 | QA | 2 | 10 | 20 |'
- en: '| DE4 | Dev | 1 | 0.5 | 0.5 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| DE4 | 开发 | 1 | 0.5 | 0.5 |'
- en: '| DE5 | Prod | 16 | 20 | 320 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| DE5 | 生产 | 16 | 20 | 320 |'
- en: '| DE6 | Prod | 16 | 50 | 800 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| DE6 | 生产 | 16 | 50 | 800 |'
- en: '| DE7 | UAT | 8 | 5 | 40 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| DE7 | UAT | 8 | 5 | 40 |'
- en: '| DE8 | QA | 2 | 7 | 14 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| DE8 | QA | 2 | 7 | 14 |'
- en: '| DE9 | Dev | 1 | 15 | 15 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| DE9 | 开发 | 1 | 15 | 15 |'
- en: '| DE10 | UAT | 8 | 12 | 96 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| DE10 | UAT | 8 | 12 | 96 |'
- en: This is a snapshot in time that gives you an indication of the cost of defects.
    This doesn't mean you should totally eradicate defects—the only way to do that
    is to stop writing software—but you should focus on eradicating the high-cost
    defects. After all, the cost of defects found by customers in real life is far
    greater than a defect found during the SDLC.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个时间快照，给你一个关于缺陷成本的指示。这并不意味着你应该完全消除缺陷——做到这一点的唯一方法是停止编写软件——但你应该专注于消除高成本的缺陷。毕竟，客户在实际环境中发现的缺陷成本远高于在SDLC阶段发现的缺陷成本。
- en: We'll now take a look at the meaning of lead (and cycle) times.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看交付时间（和循环时间）的含义。
- en: Cycle and lead times
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环时间和交付时间
- en: 'These are more time-based metrics that are very useful to measure the progress
    and effectiveness of the changes you make during CD and DevOps adoption. These
    two metrics are pretty simple to understand:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是更基于时间的指标，对于衡量你在CD和DevOps采纳过程中的变化进展和效果非常有用。这两个指标相对简单易懂：
- en: '**Lead time**: The measurement of time between a requirement being identified
    and it being delivered to a customer'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交付时间**：从需求被识别到交付给客户之间的时间测量'
- en: '**Cycle time**: The time between someone starting work on a given work item/story/defect
    and it being delivered to a customer'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环时间**：从某人开始处理某个工作项/故事/缺陷到交付给客户之间的时间'
- en: 'The following diagram should give you a better idea of what this means:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表应该能让你更清楚地了解这是什么意思：
- en: '![](img/faf0fba6-2d2d-4f74-b195-cd453a7341f4.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/faf0fba6-2d2d-4f74-b195-cd453a7341f4.png)'
- en: The observant among you may notice that for defects, the lead time is pretty
    much the same as for MTTR, which means that one simple data point can be used
    for two measurements. Two for the price of one is good value.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你们中的敏锐观察者可能会注意到，对于缺陷来说，交付时间与MTTR几乎是相同的，这意味着一个简单的数据点可以用于两个度量标准。以一换二，物有所值。
- en: Regularly taking snapshots of lead and cycle time gives a very good indication
    of whether things are working well (or not, as the case may be). It should be
    noted that lead time can be dependent on changes in business priorities and time-based
    commitments—for example, a feature may be deprioritized when something more urgent
    comes into the backlog—so there may be some fluctuation in the value over time.
    What you should be striving toward is an overall reduction in lead time. Cycle
    time, on the other hand, is more within the control of the engineering team, and
    therefore reducing that is within their hands. As CD and DevOps adoption takes
    hold, the act of delivery should be much simpler, so the average cycle time should
    decrease. If it doesn't, you should be looking at what is causing the pain points.
    Some of that may be related to quality issues.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 定期拍摄交付时间和循环时间的快照，可以很好地指示事情是否在顺利进行（或者，情况可能并非如此）。需要注意的是，交付时间可能会受到业务优先级和时间承诺变化的影响——例如，当更紧急的任务进入待办事项列表时，某个功能可能会被降级优先级——因此，数值可能会随着时间的推移而波动。你应该争取的是交付时间的总体减少。另一方面，循环时间更多地受工程团队控制，因此减少循环时间掌握在他们手中。随着CD和DevOps采纳的推进，交付过程应该变得更加简单，因此平均循环时间应该减少。如果没有减少，你应该检查是什么原因导致了瓶颈。有些原因可能与质量问题相关。
- en: Quality gates
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 质量门控
- en: Not only does capturing data help build up a picture over time and spot trends,
    but you can also use the data to stop quality issues from leaking. What I mean
    by this is that once you have some data captured and analyzed regarding such things
    as code coverage, adherence to coding standards, code complexity, or code documentation
    levels, you could set some thresholds within the CD pipeline, which, if exceeded,
    will stop the pipeline in its tracks. You can also implement quality gates based
    upon the results of automated tests—again, if the tests fail, the CD pipeline
    stops.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获数据不仅有助于随着时间的推移建立一个清晰的全貌并发现趋势，还可以帮助你防止质量问题的泄露。我的意思是，一旦你收集并分析了关于代码覆盖率、编码标准遵循情况、代码复杂度或代码文档化水平等方面的数据，你可以在CD流水线中设置一些阈值，如果超过这些阈值，流水线会立刻停止。你还可以根据自动化测试的结果实施质量门控——同样地，如果测试失败，CD流水线也会停止。
- en: For example, let's assume that you have decided that any new piece of software
    must have 100 percent unit-test code coverage and must not contain any documented
    security vulnerabilities; then you can implement a code analysis/linting tool
    within the CD pipeline to check each commit or merge. If the tools report that
    the code in question doesn't pass the checks, the CD pipeline will stop and let
    the team know.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: When referring to the CD pipeline, I would include the CI solution being part
    of the whole pipeline—just in case you were thinking they are separate things.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of such tools will not only ensure your code is up to scratch,
    it can also help reduce things such as escaping defects and ensuring code that
    flows through the CD pipeline with minimal interruption. Capturing this data will
    also give you some historical insight in relation to when quality gates pass/fail,
    which may correlate with another event—for example, failures may grow during the
    frantic period before a major release.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Some of you may be thinking that this all sounds like hard work—on top of all
    the other hard work—so is it actually worth it? Yes, it is!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Where to start and why bother?
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As stated earlier, there are many things that you can and should be measuring,
    analyzing, and producing metrics for, and there are many tools that can help you
    do this. You just need to work out what is most important and start from there.
    The work and effort needed to set up the tools required should be seen as a great
    opportunity to bring into play some of the good behaviors you want to embed: collaboration,
    open and honest dialogue, and trust.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: I would advise implementing these types of tools early in your CD and DevOps
    adoption so that you can start to track progress from the get-go. Needless to
    say, it is not going to be a pretty sight to begin with, and there will no doubt
    be questions around the validity of doing this when it doesn't directly drive
    the adoption forward—in fact, things might look pretty awful, especially early
    on.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'It might not directly affect the adoption, but it offers some worthwhile additions,
    which are explained here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Having additional data to prove the quality of the software will, in turn, build
    trust that the code can be shipped quickly and safely
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a good chance that having a very concise view of the overall code base
    will help with the re-engineering to componentize the platform
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the engineers have more confidence in the code base, they can focus on new
    feature development without concerns about opening a can of worms every time they
    make a change
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll now move our focus from measuring the act of creating software and look
    at the importance of measuring what happens when it's built.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Measuring the real world
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Analyzing and measuring your code and engineering expertise is one thing; however,
    for CD and DevOps to really work, you also need to keep a close eye on the overall
    environment, platform, the running software, and the progress of CD and DevOps
    effectiveness. Let's start with environments.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Measuring the stability of the environments
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may have a number of different environments that are used for different
    purposes throughout the product-delivery process: development, CI, QA, UAT, performance/load
    testing, and so on. As your release cycle speeds up, your reliance on these various
    environments will grow—if you''re working in a 2-to-3-month release cycle, having
    an issue within one of the environments for half a day or so will not have, in
    the grand scheme of things, a vast impact on your release, whereas if you''re
    releasing 10 times per day, a half-a-day downtime is a major impact.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'There seems to be a universal vocabulary throughout the IT industry related
    to this, and the term environmental issue crops up time and time again, as we
    can see here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e8de5-84d0-4dd9-9c86-b5a5cd93a7c7.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: The universal environmental issue discussion
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: We've all heard this, and some of us are just as guilty of saying these things
    ourselves. All in all, it's far from helpful and can be counterproductive in the
    long run, especially where building good working relationships across the Dev
    and Ops divide is concerned, as the implication is that the infrastructure (which
    is looked after by the operations side) is at fault even though there's no concrete
    proof.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome this attitude and instill some good behaviors, we need to do one
    of two things:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Prove beyond a shadow of a doubt that the software platform is working as expected,
    and, therefore, any issues encountered must be based on problems within the infrastructure
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prove beyond a shadow of a doubt that the infrastructure is working as expected,
    and, therefore, any issues encountered must be based on problems within the software
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When I said quite simple, I actually meant not very simple. Let's look at the
    options we have.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating automated tests
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've looked at the merits of using automated tests to help prove the quality
    of each software component as it is being released, but what if you were to group
    these tests together and run them continuously against a given environment? This
    way, you would end up with a vast majority of the platform being tested over and
    over again—continuously, in fact.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: If you were to capture the results of these tests, you can quickly and easily
    see how healthy the environment is, or, more precisely, you could see whether
    the software is behaving as expected. If tests start failing, we can look at what
    has changed since that last successful run and try to pinpoint the root cause.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'There are, of course, many caveats to this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: You'll need a good coverage of tests to build a high level of confidence
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might have different tests written in different ways using different technologies,
    which do not play well together
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some tests could conflict with each other, especially if they rely on certain
    predetermined sets of test data being available
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tests themselves might not be bulletproof and might not show issues, especially
    when they have mocking or stubbing included
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of your tests might flap, which is to say they are inconsistent and for
    one reason or another fail every now and again
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It could take many hours to run all of the tests end-to-end (on the assumption
    that you are running these sequentially)
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assuming that you are happy to live with the caveats or you have resources available
    to bolster up the tests so that they can be run as a group continuously and consistently,
    you will end up with a solution that will give you a higher level of confidence
    in the software platform.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: I would suggest you apply some focus to flapping and/or tests that do not provide
    the same results after execution, as these will impact confidence. The rule of
    thumb is that if you can't trust the test, either refactor it or remove it from
    the suite.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: If you extend this thinking, you could also use the same approach to build confidence
    in your environment(s). For example, if you run the same test suite a number of
    times against the same environment without changing anything in terms of software,
    configuration, or environment, you should get the same results each time. Therefore,
    you should be able to spot instability issues within a given environment with
    relative ease—sort of.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Combining automated tests and system monitoring
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Realistically, just running tests will only give you half the story. To get
    a truer picture, you could combine your automated test results with the output
    of your monitoring solution (as covered in [Chapter 5](6a4f746d-b386-49b3-b82b-154ff1f604e8.xhtml),
    *Approaches, Tools, and Techniques*). Combining the two will give you a more holistic
    view of the stability—or not, as the case may be—of the environment as a whole.
    More importantly, should problems occur, you will have a better chance of pinpointing
    the root cause(s).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: OK, so I've made this sound quite simple, and to be honest, the overall objective
    is simple; the implementation might be somewhat more difficult. As ever, there
    are many tools available that will allow you do to this, but again, time and effort
    is required to get them implemented and set up correctly. You should see this
    as yet another DevOps collaboration opportunity.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, however, another caveat that we should add to the previously mentioned
    list: you might have major issues trying to run some of your automated tests in
    the production environment'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Unless your operations team is happy with test data being generated and torn
    down within the production database many times per hour/day and they are happy
    with the extra load that will generate and the possible security implications,
    this approach might be restricted to non-production environments.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: This might be enough to begin with, but if you want a well-rounded picture,
    you need to look at another complementary approach to gain some more in-depth
    real-time metrics.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Real-time monitoring of the software itself
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Combining automated tests and system monitoring will give you useful data,
    but will realistically only prove two things: the platform is up, and the tests
    pass. It does not give you an in-depth understanding of how your software platform
    is behaving or, more importantly, how it is behaving in the production environment
    being used by many millions of real-world users. To achieve this, you need to
    go to the next level.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Consider how a Formula One car is developed. We have a test driver sitting in
    the cockpit who is generating input to make the car do something; their foot is
    on the accelerator, making the car move forward, and they are steering the car
    to make it go around corners. You have a fleet of technicians and engineers observing
    how fast the car goes, and they can observe how the car functions (that is, the
    car goes faster when the accelerator is pressed and goes around a corner when
    the steering wheel is turned). This is all well and good, but what is more valuable
    to the technicians and the engineers is the in-depth metrics and data generated
    by the myriad of sensors and electronic gubbins deep within the car itself.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: This approach can be applied to a software platform as well. You need data and
    metrics from deep within the bowels of the platform to fully understand what is
    going on; no amount of testing and observation of the results will give you this.
    This is not a new concept; it has been around for many years. Just look at any
    operating system; there are many ways to delve into the depths and pull out useful
    and meaningful metrics and data. Why not simply apply this concept to software
    components? In some respects, this is already built in; look at the various log
    files that your software platform generates (for example, HTTP logs and error
    logs), so you have a head start; if only you could harvest this data and make
    use of it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of tools available that allow you to trawl through such
    output and compile them into useful and meaningful reports and graphs. There is
    a but here: it''s very difficult to generate this in real-time, especially when
    there''s a vast amount of data being produced, which will take time to fetch and
    process.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'A cleaner approach would be to build something into the software itself that
    can produce this kind of low-level data for you in a small, concise, and consistent
    format that is useful to you—if truth be told, your average HTTP log contains
    a vast amount of data that is of no value to you at all. I''ll cover some examples
    in [Appendix A](b212024b-5ba5-4f01-b76d-a8367c6ec41c.xhtml), *Some Useful Information*,
    but simply put, this approach falls into two categories:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Incorporate a health-check function within your software APIs; this will provide
    low-level metrics data when called periodically by a central data-collection solution
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extend your software platform to push low-level metrics data to a central data-collection
    solution periodically
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will, of course, need something to act as the central data-collection solution,
    but there are tools available if you shop around and work in a DevOps manner to
    choose and implement what works best for you.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring utopia
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whatever approach (or combination of approaches) you adopt, you should end up
    with some very rich and in-depth information. In essence, you'll much have as
    much data as your average Formula One technician (that being lots and lots of
    data). You just need to pull it all together into a coherent and easy-to-understand
    form. This challenge is another one to encourage DevOps behaviors, as the sort
    of data you want to capture/present is best fleshed out and agreed on between
    the engineers on both sides.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re unsure whether you should measure a specific part of the platform
    or the infrastructure, but feel it might be useful, measure it anyway. You never
    know whether this data will come in handy later. The rule of thumb is: if it moves,
    monitor it; if it doesn''t move, monitor it just in case.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, what you want to be able to do is ensure that the entire environment
    (infrastructure, configuration, and software platform) is healthy. This way, if
    someone says it must be an environmental issue, they might actually be correct.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'If we pull all of this together, we can now expand up on the preceding list:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Prove beyond a shadow of a doubt that the software platform is working as expected,
    and, therefore, any issues encountered must be based on problems within the infrastructure
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prove beyond a shadow of a doubt that the infrastructure is working as expected,
    and, therefore, any issues encountered must be based on problems within the software
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agree that problems can occur for whatever reason and that the root cause(s)
    should be identified and addressed in a collaborative DevOps way
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll now move on from the technical side of measuring and look at the business-focused
    view.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Effectiveness of CD and DevOps
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing CD and DevOps is not cheap. There's quite a lot of effort required,
    which directly translates into cost. Every business likes to see a return on investment,
    so there is no reason why you should not provide this sort of information and
    data. For the majority of this chapter, we've been focusing on the more in-depth,
    technical side of measuring progress and success. This is very valuable to technical-minded
    individuals, but your average middle manager might not get the subtleties of what
    it means, and to be honest, you can't really blame them. Seeing a huge amount
    of data and charts that contain information, such as **Transactions per second**
    (**TPS**) counts, response times for a given software component, or how many commits
    were made, is not awe-inspiring for your average suit. What they like is top-level
    summary information and data, which represents progress and success.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: As far as CD and DevOps is concerned, the main factors that are important are
    improvements in efficiency and throughput, as these translate directly into how
    quickly products can be delivered to the market and how quickly the business can
    start realizing the value. This is what it's all about. CD and DevOps is the catalyst
    to allow for this to be realized, so why not show this?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'With any luck, you will have (or plan to have) some tooling to facilitate and
    orchestrate the CD process. What you should also have built into this tooling
    is metrics; the sort of metrics that you should be capturing are:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: A count of the number of deployments completed
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time taken to take a release candidate to production
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time taken from commit to the working software being in production
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A count of the release candidates that have been built
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A league table of software components that are released
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of the unique software components going through the CD pipeline
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can then take this data and summarize it for all to see—it must be simple,
    and it must be easy to understand. An example of the sort of information you could
    display on screens around the office could be something such as the one shown
    in the following screenshot:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98597789-08b6-453f-9e04-017a75f96108.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: An example page summarizing the effectiveness of the CD process
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: This kind of information is extremely effective, and if it's visible and easily
    accessible, it also opens up discussions around how well things are progressing
    and what areas still need some work and optimization.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: What would also be valuable, especially to management types, is financial data
    and information, such as the cost of each release in terms of resources. If you
    have this data available to you, including it will not only be useful for the
    management, but it could also help provide focus for the engineering teams, as
    they will start to understand how much these things cost.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Access to this data and information should not be restricted and should be highly
    visible so that everyone can see the progress being made and, more importantly,
    see how far they are from the original goal.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: We've looked at the effectiveness; let's now look at the real-world impact.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Impact of CD and DevOps
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing CD and DevOps will have an impact on your ways of working and business
    as a whole. This is a fact. What would be good is to understand what this impact
    actually is. You might already be capturing and reporting against things such
    as business **key performance indicators** (**KPI**) (number of active users,
    revenue, page visits, and so on), so why not add these into the overarching metrics
    and measurements? If CD and DevOps is having a positive impact on customer retention,
    wouldn't it be nice for everyone to see this?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: At a basic level, you want to ensure that you are going in the right direction.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move away from measuring and monitoring, let''s look at something
    that, on the face of it, does seem strange: measuring your DevOps culture.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Measuring your culture
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I know what you''re thinking: measuring software, environments, and processes
    is hard enough, but how can you measure something as intangible as culture? To
    be honest, there are no easy answers, and it really depends on what you feel is
    most valuable. For example, you might feel having developers working with system
    operators 20 percent of their time is a good indication that DevOps is working
    and is healthy, or the fact that live issues are resolved by developers and the
    operations team is a good sign.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Capturing this information can also be tricky, but it doesn't need to be overly
    complex. What you really need to know is how people feel things are progressing
    and whether they think things are progressing in the correct way.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to capture this is to ask as many people as you can. Of course,
    you''ll want to capture some meaningful data points—simply having a graph with
    the words it''s going OK doesn''t really give you much. You could look at using
    periodical interviews or questionnaires that capture data such as:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Do you feel there is an effective level of collaboration between engineers (Dev
    and Ops)?
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How willing are engineers (Dev and Ops) to collaborate to solve production issues?
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you feel blame is still predominant when issues occur?
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you feel operations engineers are involved early enough in feature development?
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there enough opportunities for engineers (Dev and Ops) to improve their
    ways of working?
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you feel you have the tools, skills, and environment to effectively do your
    job?
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you feel that CD and DevOps is having a positive impact on our business?
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There might be other example questions that you can think up; however, don't
    overdo it and bombard people—KISS (see the [Chapter 3](17779905-1394-4db1-995e-04c6af9a5125.xhtml),
    *Culture and Behaviors are the Cornerstones to Success*). If you can use questions
    that allow for answers in a scale form (for example, 1 being strongly agree, 2
    being agree, 3 being disagree, and 4 being strongly disagree), you'll be able
    to get a clearer picture, which you can then compare over time.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Again, if you pool this data with your technical data, this might provide some
    insights you were not expecting. For example, maybe you implemented a new process
    that has reduced the escaped defects by 10 percent, but releases per day have
    dropped by 5 percent and the majority of the engineering team is unhappy. In such
    a case, you might have a problem with the process itself or the acceptance of
    it at a grass-roots level.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, you learned that capturing data and measurements is
    important, as this gives you a clear indication of whether things are working
    and progressing in the way you planned and hoped for. Whether you're interested
    in the gains in software quality over time, reduction in bugs, performance of
    your software platform, or number of environmental issues in the past quarter,
    you need data. Lots of data. Complementing this with business-focused and real-world
    data will only add value and provide you with more insight into how things are
    going.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: You are striving to encourage openness and honesty throughout the organization
    (see the [Chapter 4](a19ac942-68bd-48a6-b59e-cd67ced91b65.xhtml), *Culture and
    Behaviors*); therefore, sharing all of the metrics and data you collect during
    your CD and DevOps implementation will provide a high degree of transparency.
    At the end of the day, every part of any business turns into data, metrics, and
    graphs (financial figures, head count, public opinion of your product, and so
    on), so why should the product-delivery process be any different?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: The sooner you start to capture this data, the sooner you can inspect and adapt.
    You need to extend your mantra from monitor, monitor, and then monitor some more,
    to monitor and measure continuously and consistently.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Let's now move from measuring everything that can and should be measured to
    see how things look once your CD and DevOps adoption has matured. In [Chapter
    8](c2437827-f7ff-49a7-8ee7-5bdd39c5ddbe.xhtml), *You Are Not Finished Just Yet*,
    we'll be covering some of the things you should be considering when CD and DevOps
    become the norm.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
