<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Expanding Your Opportunity Horizon</h1>
                </header>
            
            <article>
                
<p>As you may have guessed by this point, we have largely been focused on traditional software delivery within a traditional, established business that delivers traditional web/server software-based solutions and products rather than the young, trendy, and innovative start-up software businesses out there, the reason being that they normally have the agility and opportunity to be creative in the way they deliver software built into their DNA. Most tech startups—especially those formed in the last few years<span>—</span>normally build CD and DevOps into their normal day-to-day ways of working.</p>
<p><span class="IntenseQuoteChar">It may be that you currently work within such a hipster business, but CD and DevOps wasn't built into the ways of working from the start. That shouldn't be a problem, as this book should have given you some good ideas and guidance with regards to addressing this gap</span>.</p>
<p>The vast majority of businesses that deliver software on a day-to-day basis are not so lucky<span>—t</span>he intention might be there, but the will to act might be lacking. Hence, the focus is on the traditional. There's a strong possibility that you yourself work within one of these traditional businesses.</p>
<p>Having followed the advice provided in this book and successfully adopted CD and DevOps, there's a very good chance that you would have caught up with the whippersnappers and your business is able to be just as agile and creative in how it delivers software, and maybe even more so.</p>
<p>At the tail end of <a href="c2437827-f7ff-49a7-8ee7-5bdd39c5ddbe.xhtml"/><a href="c2437827-f7ff-49a7-8ee7-5bdd39c5ddbe.xhtml">Chapter 8</a>, <em>You Are Not Finished Just Yet</em>, we turned our focus onto <em>you</em> and how <em>you</em> could take your newfound knowledge, skills, and experience forward, beyond the initial goal of embedding the CD and DevOps ways of working within your organization. Let's look at what this could actually mean.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What about me?</h1>
                </header>
            
            <article>
                
<p>Let's presume at this point in the narrative that you have been instrumental in the successful adoption of CD and DevOps and have delivered what you set out to do. Things are working well, even better than you envisaged. The business is all grown up, can tie its own shoe laces, and doesn't need you to hold its hand anymore<span>—</span>well, not quite.</p>
<p>As mentioned in <a href="c2437827-f7ff-49a7-8ee7-5bdd39c5ddbe.xhtml">Chapter 8</a>, <em>You Are Not Finished Just Yet</em>, you should take a moment or two to consider where most of the individuals within the business were at the beginning of the journey and where they are now. Consider the changes in ways of working, communication, collaboration, and behaviors. Think of the proportion of innovators, <span>followers</span>, and laggards in the early stages of the evolution and what the proportion is now. Taking all of this into account, you will most probably find that in reality, the majority are now at the same point that you were when you started out<span>—</span>they are just starting to fully realize that there is another way to do things and that it is a better way. Sure, there's still work to be done to make things as effective and efficient as possible, and there are still a few kinks to iron out, but things are, on the whole, good.</p>
<p>Now, look at how far <em>you</em> have personally come in comparison; as far as most of the people you have been working with and coaching and teaching in the ways of the CD and DevOps think, you are akin to a figure way off in the distance:</p>
<div style="padding-left: 60px">                        <img src="assets/a6c1d65a-6359-4569-b979-b57505916d67.png" style=""/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Others' perception of you</div>
<p>Regardless of your role at the beginning of the journey, be that a developer, a system admin, a manager, or something else, your role has now changed. Like it or not, you have become the holder of knowledge, expertise and experience. You are the CD and DevOps subject-matter expert. You know your stuff.</p>
<div class="packt_infobox">You may feel that your fellow early-adopting innovators are also standing shoulder to shoulder with you, but for the sake of simplicity, you are the one reading this, and therefore you are the one standing in the distance.</div>
<p>You have traveled far, the landscape has changed quite dramatically from where you started, and you have new hills to climb<span>—</span>these are the new opportunities that the business is now ready to look at. Maybe these were challenges that the business could not overcome earlier; maybe they simply didn't know these opportunities existed, but with newfound knowledge, they are keen to try new things. Maybe your <strong>Chief Technology Officer</strong> (<strong>CTO</strong>) has been chatting with his young and trendy counterparts at the golf club. Whatever the reason, now is the time to apply <em>your stuff</em> to these new challenges and opportunities. What follows are some examples of how you can bring to bear your skills, expertise, and experience beyond traditional software delivery.</p>
<p>What follows are some examples of doors that can open following that successful adoption of CD and DevOps. Some of these may be achievable without CD and/or DevOps, but from experience, the results will not be as good without as they would with them. These are the sorts of new challenges and opportunities that you<span>—</span>should you accept them<span>—</span>could apply some focus, attention, and time to.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Performance and load-testing</h1>
                </header>
            
            <article>
                
<p>The more observant among you might have noticed that there is little mention of performance or load-testing throughout this book. This is intentional as, in my mind, attempting this activity without the close collaboration, tooling, and techniques that come from adopting CD and DevOps is a fool's errand. Yes, there are many established and traditional approaches, but these normally amount to shoehorning something into the process just before you want to ship your code<span>—</span>which might well result in the code not shipping due to the fact that performance issues were found at the last minute. You may have overcome this problem by implementing a process that periodically takes a build of the software and runs some intensive automated tests against it within a controlled and highly-monitored environment. This can help, but unless you have set up the automated tests to <strong>exactly</strong> mirror real-world usage, you're basically giving everyone false hope that no performance issues will be found once the code is live.</p>
<p>I would also hazard a guess and say performance/load-testing was seen as a burden, or even an area of waste, during the elephant-exposing inspection stage. It needn't be, and shouldn't be the case.</p>
<div class="packt_infobox">Once you have adopted CD and DevOps, the act of performance/load-testing can become relatively simple and straightforward. You just need to change the way you think about and approach it.</div>
<p>There's a very simple and understandable way to consider load- and performance-testing; by far the best place to ascertain how your software is performing under real-world load and usage is within your production environment. You may be reading this and thinking, has the author lost his mind? This may be true, but I would ask you to bear with me and decide for yourself.</p>
<p>Let's presume that you have implemented extensive monitoring of your overall production environment and the software running within (as mentioned in <a href="390f69c0-7f66-41a7-93a6-ee5c1bc8733a.xhtml">Chapter 7</a>, <em>Vital Measurements</em>), from which you can observe in great detail what is going on under the covers in terms of hardware, infrastructure, and software. From this, you can form a very clear idea of how things should look during normal day-to-day operations.</p>
<p>With this data, you should then be able to safely run controlled experiments and observe the results in terms of overall platform performance. For example, you could run an experiment to incrementally apply additional load to the platform while it's being used, either by routing more user activity to a specific node or server or by running some non-intrusive automated test that will generate load in a controlled manner. As you turn up the dials and the load increases, you will start to see where the pain points are<span>—</span>a heat map of sorts<span>—</span>in near real-time. As both Dev and Ops are working closely together, observing the platform as a whole, they should be able to work out where the problems are by comparing normal day-to-day stats with those generated under load.</p>
<p>If and when issues are pinpointed, they could easily be overcome by applying patches in real time using the CD tooling used on a daily basis while the load is still in place<span>—</span>giving instant feedback. Alternatively, they might witness an overall slowdown of the platform, but the monitoring solution doesn't highlight anything specific. This could mean that there is a gap in the overall monitoring coverage, which again can be pinpointed and addressed in a collaborative way. Either way, simply turning the dials back down will put things back to the normal day-to-day load.</p>
<p>Some of you may be reading this and thinking that the production environment is sacrosanct and should not be used for such activities as this could impact customers using the platform at the same time. My view is that unless you are purposefully restricting the number of people who can access the production environment, then this increase in load will happen without your knowledge in an uncontrolled manner<span>—</span>especially if your CD and DevOps adoption directly attributes to an increase in customer satisfaction and growth. Why not make sure your production environment is ready for this growth before it happens?</p>
<p>All in all, trying to run performance- or load-testing without extensive monitoring in place and/or a high degree of collaboration between the Dev and Ops teams will not provide the results you expect or need. Doing so anywhere other than the production environment will give mixed results. This is not an obvious benefit of adopting CD and DevOps, but it is a very powerful and compelling benefit, as is reducing complexity.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reducing feature-flag complexity</h1>
                </header>
            
            <article>
                
<p>There are many established approaches to allow for different use cases or user flows to be switched on and off in real time, but most revolve around some sort of feature flag or configuration setting within the platform. Although this is a viable approach, it does add something to the code base, which can, over time, become a massive headache. That something is complexity.</p>
<p>Not only does this add complexity to the code base, it also adds complexity to related activities such as testing and the setup/support of the overall platform, especially if you start to chain the feature flags together. For example, let's assume you have a new reporting feature (let's call it feature C) that is automatically enabled if the reporting menu feature (let's call it feature B) is manually enabled <strong>and</strong> the legacy-reporting feature (let's call that feature A) is manually disabled. If feature A <strong>and</strong> B are manually enabled, then feature C is automatically disabled. However, if feature A and B are manually disabled, then the third-party reporting feature (feature D) becomes automatically enabled.</p>
<p>The following may make the example easier to understand:</p>
<p><img src="assets/6b9bc518-eba4-41eb-b390-5e188a44f660.png"/></p>
<p>It all seems simple enough and based upon simple logic gates, but consider what will happen when you have a platform that has feature flags controlling dozens or hundreds of features<span>—</span>some independent of each other, and some forming a weird, convoluted daisy-chain feature tree. Testing of all of these combinations and trying to support a production system that can be set up in hundreds (and sometimes thousands) of different states will be a nightmare, saying nothing of the pretty pointless task of trying to debug a given problem when it arises.</p>
<div class="packt_infobox">I worked on one product that had in excess of 50,000 feature flags<span>—</span>the origins of and features being controlled by the majority had been lost in the mists of time, and therefore new flags were continually being added to control newly-added features. Complexity gone mad!</div>
<p>Having successfully adopted CD and DevOps, you will be regularly and consonantly shipping code with ease, and you'll have the Dev and Ops team working as one. Therefore, it would be far simpler to consider using the CD approach to enable and disable features or functionality. In other words, to enable a given feature, you just ship the code with it in<span>—</span>no messing around with flags, settings, or daisy-chaining. You'll of course test this first to ensure there's no unforeseen negative impacts, but there is a very simple way back: ship the previous version that didn't have the new feature/functionality (if you follow the "never break your consumer" advice from <a href="6a4f746d-b386-49b3-b82b-154ff1f604e8.xhtml" target="_blank">Chapter 5</a>, <span><em>Approaches, Tools, and Techniques</em>, </span>rolling back should not cause any issues). Nice and simple to comprehend, develop, and support, I think you'll agree.</p>
<p>OK, so this is may actually be an overly simplistic view, but with CD and DevOps, you can start looking at these sorts of problems in new and innovative ways. The advantages might not be immediately obvious, but reducing complexity, if nothing else, will save you time, money and effort, as well as reducing waste in the process.</p>
<p>One of reasons for using feature flagging within software is to enable A/B testing. Let's now look at what A/B testing actually is and how CD and DevOps can help improve this approach.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A/B testing</h1>
                </header>
            
            <article>
                
<p>A/B testing has been around for a while and is an extremely effective way of trying out changes to user journeys and/or logic flows within a software solution. The simple premise being that you can<span>—</span>through configuration, feature-flagging, or clever traffic-routing<span>—</span>send a predetermined number of users (or the transactions generated by use of the software itself) down different paths. This can help try out new features and/or functionality under controlled conditions normally within a production environment to prove or disprove certain hypotheses.</p>
<div class="packt_infobox">I won't go into too much depth regarding this subject<span>—</span>there are plenty of books and online resources focused on this subject that I encourage you to read.</div>
<p>Let's, for example, say that your business wants to see what the impact would be if they introduced a new design or subtle web page layout change. If you can, in some way, redirect specific users or groups of users down path A and the rest down path B, you can then monitor and compare the user behavior via analytics and metrics to see which worked best.</p>
<p class="mce-root"/>
<p>The following diagram provides a simplistic overview of this approach:</p>
<div style="padding-left: 120px" class="CDPAlignLeft CDPAlign">     <img src="assets/9e7f8e11-8381-47fe-96a6-8c1c4797357d.png" style=""/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">A simplistic example of A/B testing</div>
<p>Another useful approach would be to run A/B experiments covertly. For example, if you have a new recommendation service that you want to trial, you could force some user traffic and transactions to this new service and see how it works compared to the incumbent service. You could even use the same mechanism to route data to a specific service as part of load-testing. The possibilities are endless.</p>
<p>You don't necessarily need CD or DevOps to implement A/B testing; however, both do give you some major benefits:</p>
<ul>
<li>The ability to ship code extremely quickly<span>—</span>for example, you want to implement the code to split traffic to A or B across all servers in minutes so that all users start using the same code at the same time.</li>
<li>You have Dev and Ops closely working together, monitoring everything that is going on. If gaps are found in the data used to analyze the results, you have the ability to address this with relative ease.</li>
<li>You have the option to roll everything back relatively quickly with little/no impact if things take an unexpected turn or you have completed your experiment.</li>
</ul>
<p>Without CD and DevOps, you would need to plan this kind of activity very closely in advance and hope nothing is missing or amiss when you implement it. Unless you have the ability to make small patch releases, you will no doubt need to include any changes<span>—</span>however small<span>—</span>within a full release cycle so the normal risk-averse process will kick in. The same will apply for rolling the changes back when you're done.</p>
<p>Another variation (or at least a close relation) of A/B testing is alpha and beta testing (sometimes referred to as closed or pre-release testing). This gives us the ability to try out wide-reaching UI, UX, and functional changes alongside the existing solution. Normally, this is narrowed down to specific users and/or via invitation only. Where A/B testing is traditionally targeted as small and specific changes, this type of testing is normally more far-reaching in nature. The basic premise still applies: the ability to try out new features and functionality in a controlled manner. Again, this can be achieved without CD and DevOps, but it will be far more complex, risky, and prone to failure as old-school processes will get in the way, slow things down and<span>—</span>based on experience<span>—</span>ultimately be blamed for the failure of the test. Consider what it would take to maintain two versions of the entire UI and run them in parallel without a mechanism to react to issues in a timely manner.</p>
<p>As stated, A/B testing pretty much boils down to proving or disproving certain hypotheses, whether due to changes in market conditions or as part of a strategic direction change. Whatever the reason behind it, running an A/B test is normally time-critical. Without CD and DevOps to help you deliver quality software frequently, the ability to successfully run A/B tests will be hampered as the world may have moved on while you struggle to get releases planned and executed, and the use case you originally wanted to test may no longer be relevant. As they say, time waits for no man, women, or A/B tests.</p>
<p>We'll now move from testing to colors<span>—</span>blue and green, in fact.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Blue-green deployments</h1>
                </header>
            
            <article>
                
<p>Some of you <em>au fait</em> with CD will no doubt have heard of blue-green deployments, which are one of the cornerstones of the original CD approach. For those of you not in the know, blue-green deployments allow you to deploy (as the name suggests) a new version of software (or a new server with updated O/S, or new configuration or DB engine, and so on) while the incumbent version/server is up and running, and then seamlessly switch new for old. This is a very simplistic overview of the approach, but suffice it to say it's quite an easy concept to get your head around.</p>
<p>This approach vastly improves your ability to not only reduce/remove the need for downtime (see <a href="6a4f746d-b386-49b3-b82b-154ff1f604e8.xhtml">Chapter 5</a>, <em>Approaches, Tools, and Techniques</em>), but also to try side-by-side versioning (for example, running two different versions of the same thing within the same environment)<span>—</span>which is something that can also help A/B testing:</p>
<div style="padding-left: 60px" class="CDPAlignLeft CDPAlign">    <img src="assets/e87e7d70-97bb-4441-871a-5c27db89807d.png" style=""/></div>
<p>Although this approach is very much tied to CD, the adoption of DevOps as well will make this so much easier to manage, plan, and coordinate. Without close collaboration and trust between the Dev and Ops team, there is potential for things to go badly wrong<span>—</span>especially when dealing with the production environment. For example, what if a developer inadvertently deploys a breaking change within an API alongside the existing API but the consuming service (see <a href="6a4f746d-b386-49b3-b82b-154ff1f604e8.xhtml" target="_blank">Chapter 5</a>, <em><span>Approaches, Tools, and Techniques</span></em>) starts to talk to both? This will lead to very inconsistent results and some head-scratching. With DevOps, finding the root cause will be relatively easy and fixing the potential data issues can be sorted collaboratively.</p>
<p>Rather than going into too much detail, I highly recommend you do some research and reading into CD<span>—</span>there's a list of reference materials in the <a href="b212024b-5ba5-4f01-b76d-a8367c6ec41c.xhtml">Appendix A</a>, <em>Some Useful Information</em><span>—</span>but, suffice it to say that blue-green deployments is a very powerful tool.</p>
<p>Something else that I would highly recommend is leveraging CD and DevOps to ease the burden of security-patching.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Security-patching and bacon-saving</h1>
                </header>
            
            <article>
                
<p>It seems that every day the news is full of reports about the latest business that has been hacked in some way, or has suffered a <strong>distributed denial-of-service</strong> (<strong>DDOS</strong>) attack. These, of course, are only the ones we know about<span>—</span>research suggests that there are a good number of business that don't publicly admit to large-scale IT security issues (and why would they?). In recent years, this has made businesses<span>—</span>especially at the executive level<span>—</span>extremely wary of change and very focused on ensuring their IT systems are fully (mostly) up to date in terms of security patches. Most times, this is at the expense of software delivery.</p>
<p>When a business has adopted CD and DevOps, the implementation and validation of security patches simply becomes another change to deliver. If the patch is at the operating-system (O/S) level, then the configuration-as-code approach covered in <a href="6a4f746d-b386-49b3-b82b-154ff1f604e8.xhtml" target="_blank">Chapter 5</a>, <span><em>Approaches, Tools, and Techniques</em>,</span> will cater for this. The same would apply for networking, infrastructure, and runtime frameworks (for example JAVA, .NET, and so on). If the patch is at the software level (for example, found within some open source software used), then there is a tried and tested method of shipping software changes via a CD pipeline.</p>
<p>To keep the narrative simple, let's assume that a business has been hacked and customer data has been stolen within the attach due to a security flaw within their network and unpatched OS.</p>
<p class="mce-root"/>
<p>Let's now apply this scenario to a traditional listed business that has <strong>not</strong> adopted CD or DevOps. Consider the following questions and think of the answers that would apply:</p>
<ol>
<li>How quickly do you think they would apply a patch to overcome the problem?</li>
<li>How calm do you think their operations team feels with their CEO, VP of PR, and SVP of operations all breathing down their necks wanting to know when the IT system will be patched?</li>
<li>How confident are the Ops team that hastily applying an OS and network patch that should have been applied months ago will <strong>not</strong> impact the software platform?</li>
<li>How happy do you think the development team will be when the SVP of engineering tells them that they can't go home until they have sorted out a fix to overcome the issues introduced by hurriedly applying an OS patch?</li>
<li>How much market value do you think is wiped off a listed company when news gets out that they have been hacked and customer data has been stolen?</li>
<li>How many heads will roll?</li>
</ol>
<p>It doesn't take a PhD to guess the answers to these questions. Situations such as this are not as isolated or uncommon as they used to be, and the fallout in recent years has been very widespread, expensive, and career-limiting for those caught up in it all.</p>
<p>Now imagine the same situation for a business that has adopted CD and DevOps. The answers to the preceding questions would be something like this:</p>
<ol>
<li>As quickly as they can normally release<span>—</span>minutes or hours, at the most.</li>
<li>Perfectly calm, and, to be honest, the senior management wouldn't know anything about it until they've been informed that an issue had been found during routine monitoring and is in the process of being addressed.</li>
<li>Very confident, as they can collaborate with the development team to ensure that there are no impacts and/or work on a plan to address the impacts in parallel.</li>
<li>They won't have to.</li>
<li>If the message delivered is, "We found an issue and have already applied a fix. The impact was minimal and we can assure our customers that their data is perfectly safe," the news isn't very newsworthy and the markets might not even care. In fact, they might even see it as good news and want to invest more in the business. (OK, I can't quantify this, but it is plausible.)</li>
<li>None.</li>
</ol>
<p class="mce-root"/>
<div class="packt_tip packt_infobox">If your CD and DevOps adoption has matured, the probability of a hack due to outdated security-patching would be quite small as the monitoring for and implementation of regular security patches will be incorporated into the day-to-day ways of working, either via configuration-as-code or as part of the software delivery pipeline. However, there will always be unforeseen security holes, so it's good to know that there's a rapid way to address these situations as and when they arise.</div>
<p>As you can see, adopting CD and DevOps can provide some major bacon-saving benefits. That isn't to say that you couldn't achieve the same results without CD and DevOps, but having the ability to deliver quickly and having a very close working relationship across the Dev and Ops teams will make it much easier to spot and fix live issues before anything breaks<span>—</span>or your business becomes the top story on the evening news.</p>
<p>As previously stated, there will always be unforeseen events that can impact the running production system, and keeping ahead of this can be difficult. However, there is an approach that can help to surface these problems before they manifest themselves. This involves actively trying to break the live platform. On purpose.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Order-out-of-chaos monkey</h1>
                </header>
            
            <article>
                
<p>It doesn't matter how much care and attention you apply to your platform; something can and will inevitably go wrong when you least expect it. For example, a server will fail, a process might start looping, a network switch will decide it doesn't want to be a network switch anymore, the SAN will decide it likes to function in single-user mode, the latest security patch will cause issues in the software platform, or someone will decide to hack you because you're a nice big target. As the saying goes, you should always expect the unexpected.</p>
<p>Most businesses will have some sort of business contingency plan in place to cater for the unexpected, but there's a strong possibility that they don't try to purposely force the issue, at least not to the extent that something bad actually happens<span>—</span>they just hope nothing bad will ever happen, and if it does, they hope and pray that they'll be ready and the plan works.</p>
<p>What if you had a set of tools that could safely initiate a failure at will in a controlled manner with the goal of observing what happens and, more importantly, where the weak spots in your platform are? This is exactly what some bright spark did a few years ago, and this has been widely adopted as the <strong>chaos monkey approach</strong>. There are a few variations, but what it boils down to is this: a set of tools that you can run within your closely-monitored environment whose <em>raison d'être</em> is to try and break it.</p>
<div class="packt_infobox">If you do some research into this subject, you'll find that the majority of the tools currently available are very much focused on cloud-based installations. That isn't to say that such tools cannot be used within an on-premise environment, but the effectiveness may be lower and the risk higher, so you should bear that in mind.</div>
<p>If you attempted this approach without a strongly-embedded CD and DevOps culture, you would end up in a complete mess<span>—</span>to be honest, I doubt if you would be even be allowed to try it in the first place without getting someone very high up in the organization to understand why this should be done, and be willing to take the risk. With close collaboration, in-depth monitoring, and the trust-based relationships that come from CD and DevOps, attempting to break the platform to observe what happens is relatively (but not totally) risk-free.</p>
<div class="packt_infobox">There is one caveat to this approach: you need to be confident that your platform has been designed and built to gracefully allow for failure. You should avoid committing platformicide in public with core dumps and HTTP 500 messages available for all to see. Again, this can be addressed in a DevOps way by ensuring the environment and software that runs within it fail gracefully.</div>
<p>One other advantage to the chaos monkey approach is that it's also a great way to share knowledge of how the overall platform works across both the Dev and Ops teams. As any creative and technically-minded person will tell you, the best way to understand how something works is to push it to its breaking point to see what makes it tick. Going back to our F1 racing car analogy in <a href="390f69c0-7f66-41a7-93a6-ee5c1bc8733a.xhtml">Chapter 7</a>, <em>Vital Measurements</em>, the engineers and drivers regularly push the cars and components to the limit during testing and practice laps to ensure the car will work as designed when it needs to. The information gleaned from this activity can mean the difference between a podium finish and being lapped.</p>
<p>We'll now move away from the potentially destructive power of CD and DevOps, and consider how CD and DevOps can make the lives of your customers and other teams within your organization so much better.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">End user self-service</h1>
                </header>
            
            <article>
                
<p>Over the course of this book, we have been focused on a unidirectional process of pushing software out to given environments (including production). This in essence revolves around a software-engineering team having confidence in their changes, and therefore triggering the process to ship it or an Ops team who are confident to ship a config as code change.</p>
<p>What if you were to turn this around and allow the users of your software platform to initiate the <em>pulling</em> of your software at will? It might sound strange, but there are a few legitimate scenarios in which this could be required.</p>
<p>Let's look at a few scenarios:</p>
<ul>
<li>You have an implementation team that supports the on-boarding of new customers, and they would like to test out different scenarios and use cases so that they can ensure their manual test scripts, FAQs, and training documentation are up to date.</li>
<li>The SecOps team needs to run a set of deep security scans and some DDOS scenarios against a copy of the platform within their locked-down test lab.</li>
<li>The PR and marketing team needs to take screen grabs of the current beta platform for a press release.</li>
<li>The sales team is about to demo to an important new client and wants a local copy of the software platform running in a VM on their Mac as there is no reliable Wi-Fi available in the conference center.</li>
<li>An internal auditor is investigating a data breach from six months ago and wants an exact copy of the platform as it was then.</li>
</ul>
<p>Using traditional techniques and approaches, each of the previous scenarios would involve quite a large amount of mundane work (and that's putting it very mildly) to set up a dedicated environment and get all of the software needed installed and working as it should<span>—</span>saying nothing of the infrastructure setup. This mundane work would have to be prioritized according to the workload the various teams already have, and therefore it may take a very long time<span>—</span>most probably far beyond the date when the environments are <strong>needed</strong>. I'm pretty sure that you will have experienced this frustration yourself<span>—</span>I know I have many times.</p>
<p>Now consider how much mundane extra work it would entail if these teams/users could press a button and have an entire environment automatically set up for them? What if they could also specify the exact version they wanted (for example, production, beta, current work in progress, a snapshot in time, and so on) via a self-service portal?</p>
<p>With CD and DevOps embedded into your ways of working, there's no obvious reason you shouldn't be able to do this. It will take some work to set up, but you have the tooling that can reliably provision environments, deploy software assets, and provide in-depth monitoring. If the automation goes a little astray or doesn't cater for one of the scenarios, you have a DevOps team who are used to collaborating and are, therefore, happy to help solve the problems.</p>
<p class="mce-root"/>
<p>Extending the user self-service beyond your organizational boundary is also something CD and DevOps can help you realize.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Thing as a service</h1>
                </header>
            
            <article>
                
<p>As software solutions mature, the businesses that invested in them continually look for new and interesting ways of leveraging said investment. In plain terms, they want to make more money from the software they have already paid for.</p>
<p>There are a number of well-established ways of doing this, but <strong>PaaS (Platform as a Service</strong>) or <strong>SaaS (Software as a Service)</strong> are the most popular and are very much in vogue in terms of new and interesting ways of making more money out of an existing software platform. You may recall that we briefly touched upon these in <a href="17779905-1394-4db1-995e-04c6af9a5125.xhtml" target="_blank"/><a href="17779905-1394-4db1-995e-04c6af9a5125.xhtml" target="_blank">Chapter 3</a>, <span><em>Culture and Behaviors—The Cornerstones to Success</em>,</span> in relation to third-party tools. The premise is pretty simple; you expose via <strong>Application Programming Interfaces</strong> (<strong>APIs</strong>) certain parts of functionality to a first or third party who that uses APIs to extend their software platform to include the functionality you provide. For example, if your software platform specialized in car rental bookings, you could expose APIs to a price comparison web site to allow their users to seamlessly book a car via your software platform.</p>
<p>This type of approach has been around for many years, and sometimes referred to as B2B or similar), but has always been seen as something that is painful to implement, maintain, secure, monetize, and support<span>—</span>especially by businesses that deliver software in the traditional way. There's also complexity in terms of making any changes that could impact the APIs, which can lead to technical debt mounting up and/or upset customers/clients who use said APIs (see "never break your consumer" in <a href="6a4f746d-b386-49b3-b82b-154ff1f604e8.xhtml" target="_blank">Chapter 5</a>, <em><span>Approaches, Tools, and Techniques</span></em>). Counter to this is the problem that any API changes required are slow to deliver<span>—</span>more of a problem when the first/third party has adopted CD and DevOps and can move far quicker than you. This can sometimes lead to them looking at the completion for their next partner.</p>
<p>I wouldn't say that CD and DevOps adoption will enable this approach without some effort and investment, but it will drastically simplify the ability to get it up and running and then keep it running. This in turn should remove the perception that SaaS/PaaS is too painful to implement and should be seen as something that legitimately is a new and interesting way of leveraging your software platform. In addition, you'll tend to find that organizations that have already adopted CD and DevOps are more likely to work with suppliers who work in a similar way, as they know that new requirements can be implemented quickly and reliably and that collaboration is something that just happens.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Throughout this chapter, we've focused on your evolution beyond leading the adoption of CD and DevOps and how you can help the business evolve beyond simply delivering quality software frequently. We've looked at some examples of how CD and DevOps can further improve the ways of working for everyone involved in product delivery and how either/both can help open up new opportunities for the business.</p>
<p>You can probably think of scenarios and interesting problems more pertinent to your situation, organization, or business, but the point is that with CD and DevOps embedded within your ways of working, you are able to take the load off the Ops and Dev team, help them solve new problems, and improve the satisfaction of your customers both internally and externally.</p>
<p>Thus far, we have been sticking to the kinds of web/server-based software delivery that the founders of the CD and DevOps movements sought to optimize, streamline, and make far less painful. In our closing chapter, we'll look at how CD and DevOps can be used outside of their comfort zone, and how you could add yet more value to your organization and business.</p>


            </article>

            
        </section>
    </body></html>