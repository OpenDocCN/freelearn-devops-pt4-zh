<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Some Useful Information</h1>
                </header>
            
            <article>
                
<p>Although this book provides some (hopefully) useful information, there's only so much space available. Therefore, I've compiled a list of additional sources of information that will complement this book. I've also included a list of the many subject-matter experts out there who might be able to provide further assistance and guidance as you progress along your journey. Additional resources can be found on my website at <a href="http://www.swartout.co.uk/">http://www.swartout.co.uk</a><a href="http://www.swartout.co.uk/">.</a></p>
<p>What follows is by no means an exhaustive list, but it is a good start.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tools</h1>
                </header>
            
            <article>
                
<p>Some of the following tools are mentioned within this book, and some are considered the best of breed for CD and DevOps:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<thead>
<tr>
<td>
<p><strong>Tool</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
<td>
<p><strong>Where to find more information</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
<p>Jenkins</p>
</td>
<td/>
<td>
<p><a href="https://jenkins.io/">https://jenkins.io/</a></p>
</td>
</tr>
<tr>
<td>
<p>GIT</p>
</td>
<td>
<p>A free and open source distributed version-control system</p>
</td>
<td>
<p><a href="https://git-scm.com/">https://git-scm.com/</a></p>
</td>
</tr>
<tr>
<td>
<p>GitHub</p>
</td>
<td>
<p>An online-hosted community solution based on GIT</p>
</td>
<td>
<p><a href="https://github.com/">https://github.com/</a></p>
</td>
</tr>
<tr>
<td>
<p>Graphite</p>
</td>
<td>
<p>A highly scalable real-time graphing system that allows you to publish metric data from within your application</p>
</td>
<td>
<p><a href="http://graphiteapp.org/">http://graphiteapp.org/</a></p>
</td>
</tr>
<tr>
<td>
<p>Tasseo</p>
</td>
<td>
<p>A simple-to-use Graphite dashboard</p>
</td>
<td>
<p><a href="https://github.com/obfuscurity/tasseo">https://github.com/obfuscurity/tasseo</a></p>
</td>
</tr>
<tr>
<td>
<p>SonarQube</p>
</td>
<td>
<p>An open platform to manage code quality</p>
</td>
<td>
<p><a href="https://www.sonarqube.org/">https://www.sonarqube.org/</a></p>
</td>
</tr>
<tr>
<td>
<p>Ganglia</p>
</td>
<td>
<p>A scalable distributed monitoring system for high-performance computing systems</p>
</td>
<td>
<p><a href="http://ganglia.sourceforge.net/">http://ganglia.sourceforge.net/</a></p>
</td>
</tr>
<tr>
<td>
<p>Nagios</p>
</td>
<td>
<p>A powerful monitoring system that enables organizations to identify and resolve IT-infrastructure problems before they affect critical business processes</p>
</td>
<td>
<p><a href="https://www.nagios.org/">https://www.nagios.org/</a></p>
</td>
</tr>
<tr>
<td>
<p>Puppet Labs</p>
</td>
<td>
<p>A tool to automate the creation and maintenance of IT infrastructure</p>
</td>
<td>
<p><a href="https://puppet.com/">https://puppet.com/</a></p>
</td>
</tr>
<tr>
<td>
<p>Chef</p>
</td>
<td>
<p>Another tool to automate the creation and maintenance of IT infrastructure</p>
</td>
<td>
<p><a href="https://www.chef.io/chef/">https://www.chef.io/chef/</a></p>
</td>
</tr>
<tr>
<td>
<p>Vagrant</p>
</td>
<td>
<p>A tool to build complete development environments using automation</p>
</td>
<td>
<p><a href="https://www.vagrantup.com/">https://www.vagrantup.com/</a></p>
</td>
</tr>
<tr>
<td>
<p>Docker</p>
</td>
<td>
<p>An open platform for distributed applications</p>
</td>
<td>
<p><a href="https://www.docker.com/">https://www.docker.com/</a></p>
</td>
</tr>
<tr>
<td>
<p>Kubernetes (<a href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/">https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/</a>)</p>
</td>
<td>
<p>An open source system for automating deployment, scaling, and management of containerized applications</p>
</td>
<td>
<p><a href="https://kubernetes.io/">https://kubernetes.io/</a></p>
</td>
</tr>
<tr>
<td>
<p>Octopus deploy</p>
</td>
<td>
<p>A rather good tool that can be used as a CD pipeline</p>
</td>
<td>
<p><a href="https://octopus.com/"><span class="MsoHyperlink">https://octopus.com/</span></a></p>
</td>
</tr>
<tr>
<td>
<p>Yammer</p>
</td>
<td>
<p>An Enterprise private social network (think of it as a corporate Facebook)</p>
</td>
<td>
<p><a href="https://www.yammer.com">https://www.yammer.com</a></p>
</td>
</tr>
<tr>
<td>
<p>Slack</p>
</td>
<td>
<p>A mature and widely used collaboration tool and platform</p>
</td>
<td>
<p><a href="https://slack.com/">https://slack.com/</a></p>
</td>
</tr>
<tr>
<td>
<p>IRC</p>
</td>
<td>
<p>The granddaddy of collaboration and chat tools</p>
</td>
<td>
<p><a href="http://www.irc.org/">http://www.irc.org/</a></p>
</td>
</tr>
<tr>
<td>
<p>Hubot</p>
</td>
<td>
<p>An automated bot that can be set up within most chatroom systems</p>
</td>
<td>
<p><a href="https://hubot.github.com/">https://hubot.github.com/</a></p>
</td>
</tr>
<tr>
<td>
<p>Trello</p>
</td>
<td>
<p>An online scrum/Kanban board solution</p>
</td>
<td>
<p><a href="https://trello.com/">https://trello.com/</a></p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">People</h1>
                </header>
            
            <article>
                
<p>What follows is a list of people who are actively involved in the agile and continuous delivery and DevOps communities:</p>
<ul>
<li>Patrick Debois is seen by many in the DevOps community as the daddy of DevOps and the founder of the DevOpsDays movement (<a href="http://devopsdays.org/">http://devopsdays.org/</a><a href="http://devopsdays.org/">)</a>. This relatively small get-together of like-minded individuals in 2009 has grown into a global gathering.</li>
<li>John Botchagalupe Willis is a regular and renowned contributor to the DevOps community and has inspired many with his honest way of sharing his wisdom.</li>
<li>Jez Humble is the co-author of the Continuous Delivery book that is used by many as the definitive reference material when investigating or implementing continuous delivery. He also actively contributes to the continuous-delivery blog at <a href="http://continuousdelivery.com/">http://continuousdelivery.com/</a>.</li>
<li>John Allspaw is the SVP of Operations at <a href="https://www.etsy.com/">https://www.etsy.com/</a> and seems to understand the value of DevOps-even though he's one of the senior management types.</li>
<li>Gareth Rushgrove is a self-confessed web geek, who seems to somehow find time to produce the DevOps weekly email newsletter (<a href="http://devopsweekly.com/">http://</a> <a href="http://devopsweekly.com/">devopsweekly.com/</a>), which is full of useful and insightful information.</li>
<li>Gene Kim, co-author of <em>The Phoenix Project</em>, is the founder and former CTO of Tripwire. He is passionate about IT operations, security, and compliance, and how IT organizations successfully transform from good to great.</li>
<li>Mitchell Hashimoto is a self-confessed DevOps tools mad scientist and the creator of Vagrant, Packer, Serf, Consul, and Terraform.</li>
<li>Rachel Davies is an internationally recognized expert in coaching teams on the effective use of agile approaches and has a wealth of knowledge when it comes to retrospective techniques and games.</li>
<li>Ken Schwaber and Mike Cohn are the godfathers of scrum and agile.</li>
<li>John Clapham is an all-round nice guy and agile/DevOps evangelist.</li>
<li>Karl Scotland is a renowned agile coach who specializes in lean and agile techniques.</li>
<li>Keith Watson is well known throughout the UK DevOps community and I have the privilege of working closely with him.</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recommended reading</h1>
                </header>
            
            <article>
                
<p>The following books are well worth a read, even if you don't decide for some strange reason to adopt CD and/or DevOps:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Resource</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
<td>
<p><strong>Link</strong></p>
</td>
</tr>
<tr>
<td>
<p><em>Agile Coaching</em></p>
</td>
<td>
<p>A nice introduction on how to become a good agile coach</p>
</td>
<td>
<p><a href="https://pragprog.com/book/sdcoach/agile-coaching">https://pragprog.com/book/sdcoach/agile-coaching</a></p>
</td>
</tr>
<tr>
<td>
<p><em>Agile Retrospectives: Making Good Teams Great</em></p>
</td>
<td>
<p>An excellent book that covers most of what you need to know to run effective retrospectives</p>
</td>
<td>
<p><a href="https://pragprog.com/book/dlret/agile-retrospectives">https://pragprog.com/book/dlret/agile-retrospectives</a></p>
</td>
</tr>
<tr>
<td>
<p><em>Continuous Delivery: Reliable Software Releases Through Build, Test, and Deployment Automation</em></p>
</td>
<td>
<p>The CD bible</p>
</td>
<td>
<p><a href="http://www.amazon.com/dp/0321601912?tag=contindelive-20">http://www.amazon.com/dp/0321601912?tag=contindelive-20</a></p>
</td>
</tr>
<tr>
<td>
<p><em>The Phoenix Project</em></p>
</td>
<td>
<p>A unique take on DevOps adoption in fiction form, well worth a read</p>
</td>
<td>
<p><a href="http://itrevolution.com/books/phoenix-project-devops-book/">http://itrevolution.com/books/phoenix-project-devops-book/</a></p>
</td>
</tr>
<tr>
<td>
<p><em>Agile Product Management with Scrum</em></p>
</td>
<td>
<p>View scrum and agile from the product managers' point of view</p>
</td>
<td>
<p><a href="http://www.amazon.com/exec/obidos/ASIN/0321605780/mountaingoats-20">http://www.amazon.com/exec/obidos/ASIN/0321605780/mountaingoats-20</a></p>
</td>
</tr>
<tr>
<td>
<p><em><span>The Enterprise and Scrum</span></em></p>
</td>
<td>
<p><span>This book provides some addition insight into the challenges of adopting an agile approach and ways of working</span></p>
</td>
<td>
<p><a href="http://www.amazon.com/exec/obidos/ASIN/0735623376/mountaingoats-20">http://www.amazon.com/exec/obidos/ASIN/0735623376/mountaingoats-20</a></p>
</td>
</tr>
<tr>
<td>
<p><em><span>The Lean Startup</span></em></p>
</td>
<td>
<p><span>Real-life experiences and insights into how to transform your business, culture, and ways of working</span></p>
</td>
<td>
<p><a href="http://amzn.com/0307887898">http://amzn.com/0307887898</a></p>
</td>
</tr>
<tr>
<td>
<p><span><em>Getting Value out of Agile Retrospectives</em></span></p>
</td>
<td>
<p><span>Gives a good introduction on retrospectives and provides a good, long list of games/exercises</span></p>
</td>
<td>
<p><a href="https://leanpub.com/gettingvalueoutofagileretrospectives">https://leanpub.com/gettingvalueoutofagileretrospectives</a></p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Retrospective games</h1>
                </header>
            
            <article>
                
<p>Retrospectives are normally the inspect part of the agile inspect and adapt. If you are aware of or are using scrum or some other agile methodology, then running retrospectives should be nothing new. If you have never run a retrospective before, then you would have some fun things to learn.</p>
<p>The remit of a retrospective is to look back over a specific period of time, project, release, or simply a business change and highlight what worked well, what didn't work well, and what improvements are needed. This process can traditionally be a bit dry, so retrospectives tend to be based on games (some people refer to these as exercises, but I prefer the word "games"), which encourages collaboration, engagement, and injects a bit of fun.</p>
<p>As with any game, there are always rules to follow. Here are some example rules:</p>
<ul>
<li>Each session should be strictly time-boxed</li>
<li>Everyone should be given a voice and a chance to actively contribute</li>
<li>Everyone should be able to voice their opinion but not at the expense of others</li>
<li>Whoever is facilitating the session is in charge and should control the session as such</li>
<li>The session should result in tangible and realistic actions that can be taken forward as improvements</li>
</ul>
<p>As with the value-stream mapping technique mentioned in <a href="03ef279d-c51d-4e35-a137-701636c17d5f.xhtml">Chapter 2</a>, <em>Understanding Your Current Pain Points</em>, the only tools you really need are pens, paper, a whiteboard (or simply a wall), some space, and some sticky notes.</p>
<p>I've already introduced you to timeline and value-stream mapping. Let me now introduce you to one of my favorite games, StoStaKee.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">StoStaKee</h1>
                </header>
            
            <article>
                
<p>This stands for stop, start, and keep. Again, this is an interactive time-boxed exercise focused on past events. This time, you ask everyone to fill in sticky notes related to things they would like to stop doing, start doing, or keep doing, and add them to one of three columns (stop, start, and keep). You then get everyone to vote—again, with sticky dots on the ones they feel most strongly about. Again, you should encourage lots of open and constructive discussions to ensure that everyone understands what each note means. The end goal is a set of actions to take forward. The following diagram depicts a typical StoStaKee board:</p>
<p><img src="assets/9ae1ccae-511b-4ef7-beac-6609cae7c113.png" style="width:79.92em;height:41.50em;"/></p>
<div class="packt_figref"><span>A typical StoStaKee board</span></div>
<p>The preceding examples are a mere subset of what is available, but both have proven time and time again to be the most effective in investigating and, more importantly, understanding the issues within a broken process.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Vital measurements expanded</h1>
                </header>
            
            <article>
                
<p><a href="https://cdp.packtpub.com/continuous_delivery_and_devops__a_quickstart_guide__third_edition/wp-admin/post.php?post=6&amp;action=edit#post_308">Chapter 7</a><span>, </span><em>Vital Measurements</em><span>,</span> introduced you to a number of different ways of measuring certain aspects of your processes. We will now expand on some of these and look in more detail at what you could/should be measuring. We'll start by revisiting code complexity and the science behind it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Code complexity – some science</h1>
                </header>
            
            <article>
                
<p>As mentioned in <a href="https://cdp.packtpub.com/continuous_delivery_and_devops__a_quickstart_guide__third_edition/wp-admin/post.php?post=6&amp;action=edit#post_308">Chapter 7</a><span>, </span><em>Vital Measurements</em><span>,</span> having complex code in some circumstances is fine and sometimes necessary; however, overly complex code can cause you lots of problems, especially when trying to debug or when you're trying to extend it to cater to additional use cases. Therefore, being able to analyze how complex a piece of code is should help.</p>
<p>There are a few documented and recognized ways of measuring the complexity of source code, but the one most referred to is the cyclomatic complexity metric (sometimes referred to as MCC or McCabe Cyclomatic Complexity) introduced by Thomas McCabe in the 1970s. This metric has some real-world science behind it, which can, with the correct tools, provide quantifiable measurements based on your source code. The MCC formula is calculated as follows:</p>
<p style="padding-left: 240px"><em>M = E - N + X</em></p>
<p>In the preceding formula, <em>M</em> is the MCC metric, <em>E</em> is the number of edges (the code executed as a result of a decision), <em>N</em> is the number of nodes or decision points (conditional statements), and <em>X</em> is the number of exits (return statements) in the graph of the method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Code versus comments</h1>
                </header>
            
            <article>
                
<p>Including comments within your source will make it much more readable, especially in the future when someone other than the original author has to refactor or bug fix the code. Some tools will allow you to measure and analyze the ratio of code versus comments.</p>
<p>That said, some software engineers don't believe that comments are worthwhile and believe that if another engineer cannot read the code, then they're not worth their salt. This is one view; however, including comments within one's source should be encouraged as a good engineering practice and good manners.</p>
<p>One thing to look out for should you implement a code-versus-comments analysis is those individuals who get around the rules by simply including things such as the following code snippet:</p>
<pre>/**<br/>* This is a comment because I've been told to include comments in my<br/>* code<br/>* Some sort of code analysis has been implemented and I need to<br/>* include comments to ensure that my code is not highlighted as poor<br/>* quality.<br/>*<br/>* I'm not too sure what the percentage of comments vs code is<br/>* required but if I include lots of this kind of thing the tool will<br/>* ignore my code and I can get on with my day job<br/>*<br/>* In fact this is pretty much a waste of time as whoever is reading<br/>* this should be looking at the code rather than reading comments.<br/>* If you don't understand the code then maybe you shouldn't be trying<br/>* to change it?!?<br/>*/</pre>
<p>This might be a bit extreme, but I'm sure if you look close enough at your code base, you might well find similar sorts of things hidden away.</p>
<p>One other good reason for comments—in my experience<span>—</span>is for those situations when you have to take the lid off some very old code (by today's standards, very old could be a couple of years) to investigate a possible bug or simply find out what it does. If the code is based on outdated design patterns or even based on an old language standard (for example, an older version of Java or C#), it might be quite time-consuming trying to understand what the code is doing without, at least, some level of commenting.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Embedding monitoring into your software</h1>
                </header>
            
            <article>
                
<p>As mentioned in <a href="390f69c0-7f66-41a7-93a6-ee5c1bc8733a.xhtml">Chapter 7</a>, <em>Vital Measurements</em>, there are a few ways you can include and embed the generation of metrics within the software itself.</p>
<p>Let's assume that your software components contain APIs that are used for component-to-component communication. If you were able to extend these APIs to include some sort of a health-check functionality, you could construct a tool that simply calls each component and asks the component how it is. The component can then return various bits of data, which indicates its health. This might seem a bit convoluted, but it's not that difficult.</p>
<p>The following diagram gives an overview of how this might look:</p>
<div style="padding-left: 90px"><img src="assets/e185e0d3-411d-4012-83f2-798bbf859e84.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">A health-checker solution harvesting health-status data form software components</div>
<p>In this example, we have a health-checker tool that calls each component via the APIs and gets back data that can then be stored, reported, or displayed on a dashboard. The returned data can be as simple or complex as you like. What you're after is to ascertain whether each component is healthy. Let's say, for example, one element of the data returned indicated whether or not the software component could connect to the database. If this comes back as false and you notice that the system monitor looking at the free disk space on the database server is showing next to zero, you can very quickly ascertain what the problem is and rectify it.</p>
<p>This method of monitoring is good but relies on you having some tooling in place to call each component in turn, harvest the data, and present it to you in some readable/usable form. It's also restricted to what the APIs can return or rather how they are designed and implemented. If, for example, you wanted to extend the data collection to include something such as the number of open database connections, you will need to change the APIs, redeploy all of the components, and then update the tooling to accept this new data element. This is not a huge problem, but a problem all the same. What could be a huge problem, though, is the single point of failure, which is the tooling itself. If this stops working for whatever reason, you're again blind, as you don't have any data to look at, and, more importantly, you're not harvesting it.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>There is an alternative approach that can overcome these problems. In this approach, the component itself generates the metrics you need and pushes the data to your tooling. Something like Graphite does this very well. Instead of extending the APIs, you simply implement a small amount of code; this allows you to fill up buckets of metrics data from within the software component itself and push these buckets out to the Graphite platform. Once in Graphite, you can interrogate the data and produce some very interesting real-time graphs. Another advantage of Graphite is the plethora of tools now available to generate and create very effective graphs, charts, and dashboards based on the Graphite data.</p>


            </article>

            
        </section>
    </body></html>