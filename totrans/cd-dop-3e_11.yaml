- en: Some Useful Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although this book provides some (hopefully) useful information, there's only
    so much space available. Therefore, I've compiled a list of additional sources
    of information that will complement this book. I've also included a list of the
    many subject-matter experts out there who might be able to provide further assistance
    and guidance as you progress along your journey. Additional resources can be found
    on my website at [http://www.swartout.co.uk](http://www.swartout.co.uk/)[.](http://www.swartout.co.uk/)
  prefs: []
  type: TYPE_NORMAL
- en: What follows is by no means an exhaustive list, but it is a good start.
  prefs: []
  type: TYPE_NORMAL
- en: Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some of the following tools are mentioned within this book, and some are considered
    the best of breed for CD and DevOps:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tool** | **Description** | **Where to find more information** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Jenkins |  | [https://jenkins.io/](https://jenkins.io/) |'
  prefs: []
  type: TYPE_TB
- en: '| GIT | A free and open source distributed version-control system | [https://git-scm.com/](https://git-scm.com/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| GitHub | An online-hosted community solution based on GIT | [https://github.com/](https://github.com/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Graphite | A highly scalable real-time graphing system that allows you to
    publish metric data from within your application | [http://graphiteapp.org/](http://graphiteapp.org/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Tasseo | A simple-to-use Graphite dashboard | [https://github.com/obfuscurity/tasseo](https://github.com/obfuscurity/tasseo)
    |'
  prefs: []
  type: TYPE_TB
- en: '| SonarQube | An open platform to manage code quality | [https://www.sonarqube.org/](https://www.sonarqube.org/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Ganglia | A scalable distributed monitoring system for high-performance computing
    systems | [http://ganglia.sourceforge.net/](http://ganglia.sourceforge.net/) |'
  prefs: []
  type: TYPE_TB
- en: '| Nagios | A powerful monitoring system that enables organizations to identify
    and resolve IT-infrastructure problems before they affect critical business processes
    | [https://www.nagios.org/](https://www.nagios.org/) |'
  prefs: []
  type: TYPE_TB
- en: '| Puppet Labs | A tool to automate the creation and maintenance of IT infrastructure
    | [https://puppet.com/](https://puppet.com/) |'
  prefs: []
  type: TYPE_TB
- en: '| Chef | Another tool to automate the creation and maintenance of IT infrastructure
    | [https://www.chef.io/chef/](https://www.chef.io/chef/) |'
  prefs: []
  type: TYPE_TB
- en: '| Vagrant | A tool to build complete development environments using automation
    | [https://www.vagrantup.com/](https://www.vagrantup.com/) |'
  prefs: []
  type: TYPE_TB
- en: '| Docker | An open platform for distributed applications | [https://www.docker.com/](https://www.docker.com/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Kubernetes ([https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/))
    | An open source system for automating deployment, scaling, and management of
    containerized applications | [https://kubernetes.io/](https://kubernetes.io/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Octopus deploy | A rather good tool that can be used as a CD pipeline | [https://octopus.com/](https://octopus.com/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Yammer | An Enterprise private social network (think of it as a corporate
    Facebook) | [https://www.yammer.com](https://www.yammer.com) |'
  prefs: []
  type: TYPE_TB
- en: '| Slack | A mature and widely used collaboration tool and platform | [https://slack.com/](https://slack.com/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| IRC | The granddaddy of collaboration and chat tools | [http://www.irc.org/](http://www.irc.org/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Hubot | An automated bot that can be set up within most chatroom systems
    | [https://hubot.github.com/](https://hubot.github.com/) |'
  prefs: []
  type: TYPE_TB
- en: '| Trello | An online scrum/Kanban board solution | [https://trello.com/](https://trello.com/)
    |'
  prefs: []
  type: TYPE_TB
- en: People
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What follows is a list of people who are actively involved in the agile and
    continuous delivery and DevOps communities:'
  prefs: []
  type: TYPE_NORMAL
- en: Patrick Debois is seen by many in the DevOps community as the daddy of DevOps
    and the founder of the DevOpsDays movement ([http://devopsdays.org/](http://devopsdays.org/)[)](http://devopsdays.org/).
    This relatively small get-together of like-minded individuals in 2009 has grown
    into a global gathering.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: John Botchagalupe Willis is a regular and renowned contributor to the DevOps
    community and has inspired many with his honest way of sharing his wisdom.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jez Humble is the co-author of the Continuous Delivery book that is used by
    many as the definitive reference material when investigating or implementing continuous
    delivery. He also actively contributes to the continuous-delivery blog at [http://continuousdelivery.com/](http://continuousdelivery.com/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: John Allspaw is the SVP of Operations at [https://www.etsy.com/](https://www.etsy.com/)
    and seems to understand the value of DevOps-even though he's one of the senior
    management types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gareth Rushgrove is a self-confessed web geek, who seems to somehow find time
    to produce the DevOps weekly email newsletter ([http://](http://devopsweekly.com/)
    [devopsweekly.com/](http://devopsweekly.com/)), which is full of useful and insightful
    information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gene Kim, co-author of *The Phoenix Project*, is the founder and former CTO
    of Tripwire. He is passionate about IT operations, security, and compliance, and
    how IT organizations successfully transform from good to great.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mitchell Hashimoto is a self-confessed DevOps tools mad scientist and the creator
    of Vagrant, Packer, Serf, Consul, and Terraform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rachel Davies is an internationally recognized expert in coaching teams on the
    effective use of agile approaches and has a wealth of knowledge when it comes
    to retrospective techniques and games.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ken Schwaber and Mike Cohn are the godfathers of scrum and agile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: John Clapham is an all-round nice guy and agile/DevOps evangelist.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Karl Scotland is a renowned agile coach who specializes in lean and agile techniques.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keith Watson is well known throughout the UK DevOps community and I have the
    privilege of working closely with him.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommended reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following books are well worth a read, even if you don''t decide for some
    strange reason to adopt CD and/or DevOps:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Resource** | **Description** | **Link** |'
  prefs: []
  type: TYPE_TB
- en: '| *Agile Coaching* | A nice introduction on how to become a good agile coach
    | [https://pragprog.com/book/sdcoach/agile-coaching](https://pragprog.com/book/sdcoach/agile-coaching)
    |'
  prefs: []
  type: TYPE_TB
- en: '| *Agile Retrospectives: Making Good Teams Great* | An excellent book that
    covers most of what you need to know to run effective retrospectives | [https://pragprog.com/book/dlret/agile-retrospectives](https://pragprog.com/book/dlret/agile-retrospectives)
    |'
  prefs: []
  type: TYPE_TB
- en: '| *Continuous Delivery: Reliable Software Releases Through Build, Test, and
    Deployment Automation* | The CD bible | [http://www.amazon.com/dp/0321601912?tag=contindelive-20](http://www.amazon.com/dp/0321601912?tag=contindelive-20)
    |'
  prefs: []
  type: TYPE_TB
- en: '| *The Phoenix Project* | A unique take on DevOps adoption in fiction form,
    well worth a read | [http://itrevolution.com/books/phoenix-project-devops-book/](http://itrevolution.com/books/phoenix-project-devops-book/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| *Agile Product Management with Scrum* | View scrum and agile from the product
    managers'' point of view | [http://www.amazon.com/exec/obidos/ASIN/0321605780/mountaingoats-20](http://www.amazon.com/exec/obidos/ASIN/0321605780/mountaingoats-20)
    |'
  prefs: []
  type: TYPE_TB
- en: '| *The Enterprise and Scrum* | This book provides some addition insight into
    the challenges of adopting an agile approach and ways of working | [http://www.amazon.com/exec/obidos/ASIN/0735623376/mountaingoats-20](http://www.amazon.com/exec/obidos/ASIN/0735623376/mountaingoats-20)
    |'
  prefs: []
  type: TYPE_TB
- en: '| *The Lean Startup* | Real-life experiences and insights into how to transform
    your business, culture, and ways of working | [http://amzn.com/0307887898](http://amzn.com/0307887898)
    |'
  prefs: []
  type: TYPE_TB
- en: '| *Getting Value out of Agile Retrospectives* | Gives a good introduction on
    retrospectives and provides a good, long list of games/exercises | [https://leanpub.com/gettingvalueoutofagileretrospectives](https://leanpub.com/gettingvalueoutofagileretrospectives)
    |'
  prefs: []
  type: TYPE_TB
- en: Retrospective games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Retrospectives are normally the inspect part of the agile inspect and adapt.
    If you are aware of or are using scrum or some other agile methodology, then running
    retrospectives should be nothing new. If you have never run a retrospective before,
    then you would have some fun things to learn.
  prefs: []
  type: TYPE_NORMAL
- en: The remit of a retrospective is to look back over a specific period of time,
    project, release, or simply a business change and highlight what worked well,
    what didn't work well, and what improvements are needed. This process can traditionally
    be a bit dry, so retrospectives tend to be based on games (some people refer to
    these as exercises, but I prefer the word "games"), which encourages collaboration,
    engagement, and injects a bit of fun.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with any game, there are always rules to follow. Here are some example rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Each session should be strictly time-boxed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everyone should be given a voice and a chance to actively contribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everyone should be able to voice their opinion but not at the expense of others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whoever is facilitating the session is in charge and should control the session
    as such
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The session should result in tangible and realistic actions that can be taken
    forward as improvements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with the value-stream mapping technique mentioned in [Chapter 2](03ef279d-c51d-4e35-a137-701636c17d5f.xhtml),
    *Understanding Your Current Pain Points*, the only tools you really need are pens,
    paper, a whiteboard (or simply a wall), some space, and some sticky notes.
  prefs: []
  type: TYPE_NORMAL
- en: I've already introduced you to timeline and value-stream mapping. Let me now
    introduce you to one of my favorite games, StoStaKee.
  prefs: []
  type: TYPE_NORMAL
- en: StoStaKee
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This stands for stop, start, and keep. Again, this is an interactive time-boxed
    exercise focused on past events. This time, you ask everyone to fill in sticky
    notes related to things they would like to stop doing, start doing, or keep doing,
    and add them to one of three columns (stop, start, and keep). You then get everyone
    to vote—again, with sticky dots on the ones they feel most strongly about. Again,
    you should encourage lots of open and constructive discussions to ensure that
    everyone understands what each note means. The end goal is a set of actions to
    take forward. The following diagram depicts a typical StoStaKee board:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ae1ccae-511b-4ef7-beac-6609cae7c113.png)'
  prefs: []
  type: TYPE_IMG
- en: A typical StoStaKee board
  prefs: []
  type: TYPE_NORMAL
- en: The preceding examples are a mere subset of what is available, but both have
    proven time and time again to be the most effective in investigating and, more
    importantly, understanding the issues within a broken process.
  prefs: []
  type: TYPE_NORMAL
- en: Vital measurements expanded
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 7](https://cdp.packtpub.com/continuous_delivery_and_devops__a_quickstart_guide__third_edition/wp-admin/post.php?post=6&action=edit#post_308),
    *Vital Measurements*, introduced you to a number of different ways of measuring
    certain aspects of your processes. We will now expand on some of these and look
    in more detail at what you could/should be measuring. We''ll start by revisiting
    code complexity and the science behind it.'
  prefs: []
  type: TYPE_NORMAL
- en: Code complexity – some science
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 7](https://cdp.packtpub.com/continuous_delivery_and_devops__a_quickstart_guide__third_edition/wp-admin/post.php?post=6&action=edit#post_308),
    *Vital Measurements*, having complex code in some circumstances is fine and sometimes
    necessary; however, overly complex code can cause you lots of problems, especially
    when trying to debug or when you're trying to extend it to cater to additional
    use cases. Therefore, being able to analyze how complex a piece of code is should
    help.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few documented and recognized ways of measuring the complexity
    of source code, but the one most referred to is the cyclomatic complexity metric
    (sometimes referred to as MCC or McCabe Cyclomatic Complexity) introduced by Thomas
    McCabe in the 1970s. This metric has some real-world science behind it, which
    can, with the correct tools, provide quantifiable measurements based on your source
    code. The MCC formula is calculated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*M = E - N + X*'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding formula, *M* is the MCC metric, *E* is the number of edges
    (the code executed as a result of a decision), *N* is the number of nodes or decision
    points (conditional statements), and *X* is the number of exits (return statements)
    in the graph of the method.
  prefs: []
  type: TYPE_NORMAL
- en: Code versus comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Including comments within your source will make it much more readable, especially
    in the future when someone other than the original author has to refactor or bug
    fix the code. Some tools will allow you to measure and analyze the ratio of code
    versus comments.
  prefs: []
  type: TYPE_NORMAL
- en: That said, some software engineers don't believe that comments are worthwhile
    and believe that if another engineer cannot read the code, then they're not worth
    their salt. This is one view; however, including comments within one's source
    should be encouraged as a good engineering practice and good manners.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to look out for should you implement a code-versus-comments analysis
    is those individuals who get around the rules by simply including things such
    as the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This might be a bit extreme, but I'm sure if you look close enough at your code
    base, you might well find similar sorts of things hidden away.
  prefs: []
  type: TYPE_NORMAL
- en: One other good reason for comments—in my experience—is for those situations
    when you have to take the lid off some very old code (by today's standards, very
    old could be a couple of years) to investigate a possible bug or simply find out
    what it does. If the code is based on outdated design patterns or even based on
    an old language standard (for example, an older version of Java or C#), it might
    be quite time-consuming trying to understand what the code is doing without, at
    least, some level of commenting.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding monitoring into your software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 7](390f69c0-7f66-41a7-93a6-ee5c1bc8733a.xhtml), *Vital
    Measurements*, there are a few ways you can include and embed the generation of
    metrics within the software itself.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that your software components contain APIs that are used for component-to-component
    communication. If you were able to extend these APIs to include some sort of a
    health-check functionality, you could construct a tool that simply calls each
    component and asks the component how it is. The component can then return various
    bits of data, which indicates its health. This might seem a bit convoluted, but
    it's not that difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram gives an overview of how this might look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e185e0d3-411d-4012-83f2-798bbf859e84.png)'
  prefs: []
  type: TYPE_IMG
- en: A health-checker solution harvesting health-status data form software components
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we have a health-checker tool that calls each component via
    the APIs and gets back data that can then be stored, reported, or displayed on
    a dashboard. The returned data can be as simple or complex as you like. What you're
    after is to ascertain whether each component is healthy. Let's say, for example,
    one element of the data returned indicated whether or not the software component
    could connect to the database. If this comes back as false and you notice that
    the system monitor looking at the free disk space on the database server is showing
    next to zero, you can very quickly ascertain what the problem is and rectify it.
  prefs: []
  type: TYPE_NORMAL
- en: This method of monitoring is good but relies on you having some tooling in place
    to call each component in turn, harvest the data, and present it to you in some
    readable/usable form. It's also restricted to what the APIs can return or rather
    how they are designed and implemented. If, for example, you wanted to extend the
    data collection to include something such as the number of open database connections,
    you will need to change the APIs, redeploy all of the components, and then update
    the tooling to accept this new data element. This is not a huge problem, but a
    problem all the same. What could be a huge problem, though, is the single point
    of failure, which is the tooling itself. If this stops working for whatever reason,
    you're again blind, as you don't have any data to look at, and, more importantly,
    you're not harvesting it.
  prefs: []
  type: TYPE_NORMAL
- en: There is an alternative approach that can overcome these problems. In this approach,
    the component itself generates the metrics you need and pushes the data to your
    tooling. Something like Graphite does this very well. Instead of extending the
    APIs, you simply implement a small amount of code; this allows you to fill up
    buckets of metrics data from within the software component itself and push these
    buckets out to the Graphite platform. Once in Graphite, you can interrogate the
    data and produce some very interesting real-time graphs. Another advantage of
    Graphite is the plethora of tools now available to generate and create very effective
    graphs, charts, and dashboards based on the Graphite data.
  prefs: []
  type: TYPE_NORMAL
