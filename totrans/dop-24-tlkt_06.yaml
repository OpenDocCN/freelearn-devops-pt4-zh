- en: Rumblings Of An Old Men
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I spend a significant chunk of my time helping companies improve their systems.
    The most challenging part of my job is going back home after an engagement knowing
    that the next time I visit the same company, I will discover that there was no
    significant improvement. I cannot say that is not partly my fault. It certainly
    is. I might not be very good at what I do. Or maybe I am not good at conveying
    the right message. Maybe my advice was wrong. There can be many reasons for those
    failures, and I do admit that they are probably mostly my fault. Still, I cannot
    shake the feeling that my failures are caused by something else. I think that
    the root cause is in false expectations.
  prefs: []
  type: TYPE_NORMAL
- en: People want to improve. That is in our nature. Or, at least, most of us do.
    We became engineers because we are curious. We like to play with new toys. We
    love to explore new possibilities. And yet, the more we work in a company, the
    more we become complacent. We learn something, and then we stop learning. We shift
    our focus towards climbing company ladders. The more time passes, the more emphasis
    we put on defending our positions which often mean the status quo.
  prefs: []
  type: TYPE_NORMAL
- en: We become experts in something, and that expertise brings us to glory and, hopefully,
    it lands a promotion, or two. From there on, we ride on that glory. *Look at me,
    I’m a DB2 expert. That’s me, I set up VMWare virtualization. I brought the benefits
    of Spring to our Java development.* Once that happens, we often try to make sure
    that those benefits stay intact forever. We won’t switch to NoSQL because that
    would mean that my DB2 expertise is not as valuable anymore. We won’t move to
    Cloud, because I am the guru behind VMWare. We will not adopt Go, because I know
    how to code in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Those voices are critical because they are being voiced by senior people. Everyone
    needs to listen to them, even though the real motivations behind those voices
    are selfish. They are not based on actual knowledge, but often on repeated experience.
    Having twenty years of experience with DB2 is not truly twenty years of improvement,
    but rather the same experience repeated twenty times. Yet, twenty years has weight.
    People listen to you, but not because they trust you, but because you are senior
    and management believes in your capabilities to make decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Combine voices from the old with management’s fear of unknown and their quest
    for short-term benefits. The result is often status quo. *That worked for years,
    why would we change it to something else. Why would I trust a junior developer
    telling me what to do?* Even if a claim for change is backed by the experience
    from giants like Google, Amazon, and Netflix (just to name a few), you are likely
    to get a response along the following lines. *“We are different”*. *“That does
    not apply here.”* *“I’d like to do that but regulations, which I do not truly
    understand, prevent me from changing anything.”*
  prefs: []
  type: TYPE_NORMAL
- en: Still, sooner or later, a directive to change comes along. Your CTO might have
    gone to the Gartner meeting where he was told to switch to microservices. Too
    many people spoke about Agile for upper management to ignore it. DevOps is a huge
    thing, so we need to employ it as well. Kubernetes is everywhere, so we’ll start
    working on a PoC soon.
  prefs: []
  type: TYPE_NORMAL
- en: When those things do happen, when a change is approved, you might be ecstatic.
    This is your moment. This is when you’ll start doing something delicious. That
    is often the moment when I receive a call. *“We want to do this and that. Can
    you help us?”* I usually (not always) say yes. That’s what I do. And yet, I know
    that my engagement will not produce a tangible improvement. I guess that hope
    dies last.
  prefs: []
  type: TYPE_NORMAL
- en: Why am I so pessimistic? Why do I think that improvements do not produce tangible
    benefits? The answer lies in the scope of required changes.
  prefs: []
  type: TYPE_NORMAL
- en: Almost every tool is a result of specific processes. A process, on the other
    hand, is a product of a particular culture. Adopting a process without making
    cultural changes is a waste of time. Adopting tools without accepting the processes
    behind them is a futile effort that will result only in wasted time and potentially
    substantial license costs. In infrequent occasions, companies do choose to accept
    the need to change all three (culture, processes, and tools). They make a decision,
    and sometimes they even start moving in the right direction. Those are precious
    cases that should be cherished. But they are likely to fail as well. After a while,
    usually a few months later, we realize the scope of those changes. Only the brave
    will survive, and only those committed will see it through.
  prefs: []
  type: TYPE_NORMAL
- en: Those who do choose to proceed and indeed change their culture, and their processes,
    and their tools, will realize that they are incompatible with the applications
    they’ve been developing over the years. Containers work with everything, but benefits
    are genuinely tremendous when developing microservices, not monoliths. Test-driven
    development increases confidence, quality, and speed, but only if applications
    are designed to be testable. Zero-downtime deployments are not a myth. They work,
    but only if our applications are cloud-native, if they follow at least some of
    [twelve factors](https://12factor.net/), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not only about tools, processes, and culture, but also about getting rid
    of the technical debt you’ve been accumulating over the years. By debt, I don’t
    necessarily mean that you did something wrong when you started, but rather that
    time converted something awesome into a horrible monster. Do you spend fifty percent
    of your time refactoring? If you’re not, you’re accumulating technical debt. It’s
    unavoidable.
  prefs: []
  type: TYPE_NORMAL
- en: When faced with all those challenges, giving up is the expected outcome. It’s
    human to throw down the towel when there’s no light at the end of the tunnel.
    I don’t judge you. I feel your pain. You’re not moving forward because the obstacles
    are too big. Still, you have to get up because there is no alternative. You will
    continue. You will improve. It’ll hurt a lot, but there is no alternative, except
    slow death while your competition is looking over your soon-to-be corpse.
  prefs: []
  type: TYPE_NORMAL
- en: You got this far, and I can assume only two possible explanations. You are one
    of those who read technical books as a way to escape from reality, or you are
    applying at least some of the things we discussed thus far. I hope it’s the latter.
    If that’s the case, you do not fall into “yet another failure of mine.” I thank
    you for that. It makes me feel better.
  prefs: []
  type: TYPE_NORMAL
- en: If you do employ the lessons from this book, without faking, you are indeed
    doing something great. There is no way of pretending continuous delivery (CD).
    Every commit you make is ready for production if all the stages are green. The
    decision whether to deploy it to production is based on business or marketing
    needs, and it is not technical in any sense. You can even take a step forward
    and practice continuous deployment (CDP). It removes the only action performed
    by a human and deploys every green commit to production. Neither of the two can
    be faked. You cannot do CD or CDP partly. You cannot be almost there. If you are,
    you’re doing continuous integration, it-will-be-deployed-eventually process, or
    something else.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, you are, hopefully, ready to do this. You will take a step towards
    continuous deployment inside a Kubernetes cluster. By the end of this book, the
    only thing left for you is to spend an unknown amount of time “modernizing” architecture
    of your applications or throwing them to thrash and starting over. You’ll be changing
    your tools, processes, and culture. This book will not help you with all of those.
    We’re focused on tools and processes. You’ll have to figure out what to do with
    your culture and architecture. The same holds true for the way you write your
    tests. I won’t teach you testing, and I won’t preach TDD. I’ll assume that you
    already know all that and that we can focus on continuous deployment pipeline
    only.
  prefs: []
  type: TYPE_NORMAL
- en: At this moment, you might feel desperate. You might not be ready. You might
    think that you don’t have a buyout from your management, that the people in your
    company will not accept this direction, or that you don’t have enough time and
    funds. Do not get depressed. Knowing the path is the most crucial part. Even if
    you cannot get there any time soon, you should still know what the destination
    is, so that your steps are at least moving you in the right direction.
  prefs: []
  type: TYPE_NORMAL
- en: What Is Continuous Deployment?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: That’s it. That’s the shortest, and probably the most accurate definition of
    continuous deployment you’ll ever find. Is that too much for you? If you don’t
    think you can (or should) ever get there, we can fall back to continuous delivery.
  prefs: []
  type: TYPE_NORMAL
- en: The only substantial difference between continuous deployment (CDP) and continuous
    delivery (CD) is that one deploys to production while the other requires that
    we choose which commit is deployed to production. That’s much easier, isn’t it?
    Actually, it isn’t. It’s almost the same since in both cases we are so confident
    in the process that every commit is or can be deployed to production. In the case
    of continuous delivery, we (humans) do need to make a decision on what to deploy.
    However, that is the cause of significant confusion. What follows is the vital
    part so please read it carefully.
  prefs: []
  type: TYPE_NORMAL
- en: If every commit (that did not fail the pipeline) is deployable to production,
    there is no need for an engineer to decide what will be deployed. **Every commit
    is deployable**, we just might not want to have a feature available to users straight
    away. It’s a business decision. Period.
  prefs: []
  type: TYPE_NORMAL
- en: As a learning experience, you should take the least technical person in a company
    and put him (or her) in front of a screen with the builds and let him (or her)
    choose which release to deploy. Someone from cleaning services is an excellent
    candidate to be that person. Now, before that person clicks the button to deploy
    a random release, you need to remove yourself from that room.
  prefs: []
  type: TYPE_NORMAL
- en: Here comes the critical question. How would you feel in that situation? If you’d
    go to the closest bar to have a coffee confident that nothing wrong will happen,
    you are in the right place. If you would have a nervous breakdown, you’re still
    far from being there. If that’s the case, do not despair. Most of us would have
    a nervous breakdown from letting a random person deploy a random release. That’s
    not what matters. What is important is whether you want to get there. If you do,
    read on. If you don’t, I hope you’re reading a free sample of the book, and you
    can make an educated decision not to waste money. Get something else to read.
  prefs: []
  type: TYPE_NORMAL
- en: “Hold on,” you might say. “I am already doing continuous integration,” could
    be the thought in your head right now. “Is continuous delivery or deployment truly
    that different?” Well, the answer is that it’s not, but that you probably misunderstood
    what continuous integration is. I won’t even try to define it for you. Over fifteen
    years passed since CI became a thing. I will, however, ask you a few questions.
    If you answer with “no” to at least one of them, you’re not doing CI. Here it
    goes.
  prefs: []
  type: TYPE_NORMAL
- en: Are you building and, at least partially, testing your application on every
    commit without exceptions and no matter to which branch that commit is pushed
    to?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is everyone committing at least once a day?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you merge your branches to the *master* after a couple of days, if not more
    frequently?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you stop doing whatever you’re doing to fix a failed build? Is that the highest
    priority (after fire emergency, earthquakes, and other life-threatening events)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s it. Those are the only questions you need to answer. Be honest with yourself.
    Did you really respond with “yes” to all four of those questions? If you did,
    you’re my hero. If you didn’t, there is only one more question left to answer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Do you really want to do continuous integration (CI), delivery (CD), or deployment
    (CDP)?**'
  prefs: []
  type: TYPE_NORMAL
