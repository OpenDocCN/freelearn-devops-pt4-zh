- en: Deploying Stateful Applications At Scale
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the applications are deployed to Kubernetes using Deployments. It is,
    without a doubt, the most commonly used controller. Deployments provide (almost)
    everything we might need. We can specify the number of replicas when our applications
    need to be scaled. We can mount volumes through PersistentVolumeClaims. We can
    communicate with the Pods controlled by Deployments through Services. We can execute
    rolling updates that will deploy new releases without downtime. There are quite
    a few other features enabled by Deployments. Does that mean that Deployments are
    the preferable way to run all types of applications? Is there a feature we might
    need that is not already available through Deployments and other resources we
    can associate with them?
  prefs: []
  type: TYPE_NORMAL
- en: When running stateful applications in Kubernetes, we soon realize that Deployments
    do not offer everything we need. It’s not that we require additional features,
    but that some of those available in Deployments do not behave just as we might
    want them to. In many cases, Deployments are an excellent fit for stateless applications.
    However, we might need to look for a different controller that will allow us to
    run stateful applications safely and efficiently. That controller is StatefulSet.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s experience some of the problems behind stateful applications, and the
    benefits *StatefulSets* bring to the table. To do that, we need a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll skip the theory (for now), and dive straight into examples. To do that,
    we need a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Creating A Cluster
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll start the hands-on walk-through by cloning the `vfarcic/k8s-specs` repository
    that contains all the example definitions we’ll use throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
