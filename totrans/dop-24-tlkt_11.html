<html><head></head><body>
<div class="calibre6">
<h2 id="leanpub-auto-distributing-kubernetes-applications" class="calibre16">Distributing Kubernetes Applications</h2>

<aside class="information">
    <p class="calibre3">Being able to package applications is of no use unless we can distribute them. A Kubernetes application is a combination of one or more container images and YAML files that describe them. If we are to distribute our applications, we need to store both container images and YAML definitions in repositories.</p>

</aside>

<p class="calibre3">We are already storing our images in <a href="https://hub.docker.com/">Docker Hub</a>. We could have chosen a different container registry but, since Docker Hub is so convenient, we’ll continue using it throughout the book. Even though that might not be the best choice, if we move the discussion about repositories for container images out of the way, we can focus on YAML files or, to be more concrete, Helm Charts.</p>

<p class="calibre3">At this point, you might be thinking that being able to run Charts located on your laptop is an excellent way to go. All you have to do is check out the code of an application hoping that the Chart is there and execute a command like <code class="calibre19">helm upgrade -i go-demo-3 helm/go-demo-3</code>. You’d be correct that’s the easiest way to install or upgrade an application that you are developing. However, your application is not the only one you’ll be installing.</p>

<p class="calibre3">If you are a developer, you will almost certainly want to run many applications on your laptop. If you need to check whether your app integrates with those developed by your colleagues, you’ll want to run theirs as well. You can continue down the same path of checking out their code and installing local Charts. But that already starts being tedious. You’ll need to know which repositories they’re using, and check out more code than you truly need. Wouldn’t it be better to install your colleagues’ applications in the same way as installing publicly available third-party applications? Wouldn’t it be great if you could execute something like <code class="calibre19">helm search my-company-repo/</code>, get the list of all the apps created in your organization, and install those you need? We are already using the same approach with container images (e.g., <code class="calibre19">docker image pull</code>), with Linux packages (<code class="calibre19">apt install vim</code>), and many other packages and distributions. Why not do the same with Helm Charts? Why would we restrict the ability to pull a definition of an application only to those created by third-parties? We should be able to distribute our apps in the same way.</p>

<p class="calibre3">Helm Charts are still very young. The project just started, and there aren’t many repositories to choose. Today (June 2018), <a href="https://github.com/kubernetes-helm/chartmuseum">ChartMuseum</a> is one of the few, if not the only one available. So, picking the right solution is very straightforward. When there aren’t many choices, the selection process is easy.</p>

<p class="calibre3">In this chapter, we’ll explore Helm repositories and how we can leverage them to distribute our Charts across an organization, or even publish them to a broader audience if we are in the business of providing software to the more general public.</p>

<p class="calibre3">As always, we need to start from somewhere, and that is a Kubernetes cluster.</p>

<h3 id="leanpub-auto-creating-a-cluster-and-retrieving-its-ip" class="calibre20">Creating A Cluster And Retrieving Its IP</h3>

<p class="calibre3">You know the drill. Create a new cluster or reuse the one you dedicated to the exercises.</p>

<p class="calibre3">First, we’ll go to the local copy of the <em class="calibre17">vfarcic/k8s-specs</em> repository and make sure that we have the latest revision. Who knows? I might have changed something since you read the last chapter.</p>

<aside class="information">
    <p class="calibre3">All the commands from this chapter are available in the <a href="https://gist.github.com/e0657623045b43259fe258a146f05e1a">05-chart-museum.sh</a> Gist.</p>

</aside>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code><code class="nb">cd</code> k8s-specs
<code class="lineno">2 </code>
<code class="lineno">3 </code>git pull
</pre></div>

</figure>

<p class="calibre3">The requirements for the cluster are now slightly different. We’ll need <strong class="calibre18">Helm server</strong> (<strong class="calibre18">tiller</strong>). On top of that, if you are a <strong class="calibre18">minishift</strong> user, you’ll need a cluster with 4GB RAM.</p>

<p class="calibre3">For your convenience, the new Gists and the specs are available.</p>

<ul class="calibre21">
  <li class="calibre15">
<a href="https://gist.github.com/7e6b068c6d3d56fc53416ac2cd4086e3">docker4mac-helm.sh</a>: <strong class="calibre18">Docker for Mac</strong> with 3 CPUs, 3 GB RAM, with <strong class="calibre18">nginx Ingress</strong>, and with <strong class="calibre18">tiller</strong>.</li>
  <li class="calibre15">
<a href="https://gist.github.com/728246d8be349ffb52770f72c39e9564">minikube-helm.sh</a>: <strong class="calibre18">minikube</strong> with 3 CPUs, 3 GB RAM, with <code class="calibre19">ingress</code>, <code class="calibre19">storage-provisioner</code>, and <code class="calibre19">default-storageclass</code> addons enabled, and with <strong class="calibre18">tiller</strong>.</li>
  <li class="calibre15">
<a href="https://gist.github.com/6c1ebd59305fba9eb0102a5a8cea863b">kops-helm.sh</a>: <strong class="calibre18">kops in AWS</strong> with 3 t2.small masters and 2 t2.medium nodes spread in three availability zones, with <strong class="calibre18">nginx Ingress</strong>, and with <strong class="calibre18">tiller</strong>. The Gist assumes that the prerequisites are set through <a href="part0018.html#appendix-b">Appendix B</a>.</li>
  <li class="calibre15">
<a href="https://gist.github.com/945ab1e68afa9e49f85cec3bc6df4959">minishift-helm.sh</a>: <strong class="calibre18">minishift</strong> with 3 CPUs, 3 GB RAM, with version 1.16+, and with <strong class="calibre18">tiller</strong>.</li>
  <li class="calibre15">
<a href="https://gist.github.com/1593ed36c4b768a462b1a32d5400649b">gke-helm.sh</a>: <strong class="calibre18">Google Kubernetes Engine (GKE)</strong> with 3 n1-highcpu-2 (2 CPUs, 1.8 GB RAM) nodes (one in each zone), and with <strong class="calibre18">nginx Ingress</strong> controller running on top of the “standard” one that comes with GKE, and with <strong class="calibre18">tiller</strong>. We’ll use nginx Ingress for compatibility with other platforms. Feel free to modify the YAML files and Helm Charts if you prefer NOT to install nginx Ingress.</li>
  <li class="calibre15">
<a href="https://gist.github.com/6de44c440c0d0facb20b743c079bd12f">eks-helm.sh</a>: <strong class="calibre18">Elastic Kubernetes Service (EKS)</strong> with 2 t2.medium nodes, with <strong class="calibre18">nginx Ingress</strong> controller, with a <strong class="calibre18">default StorageClass</strong>, and with <strong class="calibre18">tiller</strong>.</li>
</ul>

<p class="calibre3">Besides creating a cluster, we’ll need an IP through which we can access it. The instructions that follow differ from one Kubernetes flavor to another. Please make sure you execute those matching your cluster.</p>

<p class="calibre3">If your cluster is running in <strong class="calibre18">AWS</strong> and if it was created with <strong class="calibre18">kops</strong>, we’ll retrieve the IP by digging the hostname of the Elastic Load Balancer (ELB). Please execute the commands that follow.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code><code class="nv">LB_HOST</code><code class="o">=</code><code class="k">$(</code>kubectl -n kube-ingress <code class="se">\</code>
<code class="lineno">2 </code>    get svc ingress-nginx <code class="se">\</code>
<code class="lineno">3 </code>    -o <code class="nv">jsonpath</code><code class="o">=</code><code class="s">"{.status.loadBalancer.ingress[0].hostname}"</code><code class="k">)</code>
<code class="lineno">4 </code>
<code class="lineno">5 </code><code class="nv">LB_IP</code><code class="o">=</code><code class="s">"</code><code class="k">$(</code>dig +short <code class="nv">$LB_HOST</code> <code class="se">\</code>
<code class="lineno">6 </code>    <code class="calibre19">|</code> tail -n <code class="o">1</code><code class="k">)</code><code class="s">"</code>
</pre></div>

</figure>

<p class="calibre3">If your cluster is running in <strong class="calibre18">AWS</strong> and if it was created as <strong class="calibre18">EKS</strong>, we’ll retrieve the IP by digging the hostname of the Elastic Load Balancer (ELB). Please execute the commands that follow.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code><code class="nv">LB_HOST</code><code class="o">=</code><code class="k">$(</code>kubectl -n ingress-nginx <code class="se">\</code>
<code class="lineno">2 </code>    get svc ingress-nginx <code class="se">\</code>
<code class="lineno">3 </code>    -o <code class="nv">jsonpath</code><code class="o">=</code><code class="s">"{.status.loadBalancer.ingress[0].hostname}"</code><code class="k">)</code>
<code class="lineno">4 </code>
<code class="lineno">5 </code><code class="nv">LB_IP</code><code class="o">=</code><code class="s">"</code><code class="k">$(</code>dig +short <code class="nv">$LB_HOST</code> <code class="se">\</code>
<code class="lineno">6 </code>    <code class="calibre19">|</code> tail -n <code class="o">1</code><code class="k">)</code><code class="s">"</code>
</pre></div>

</figure>

<p class="calibre3">If you’re using <strong class="calibre18">Docker For Mac or Windows</strong>, the cluster is accessible through localhost. Since we need an IP, we’ll use <code class="calibre19">127.0.0.1</code> instead. Please execute the command that follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code><code class="nv">LB_IP</code><code class="o">=</code><code class="s">"127.0.0.1"</code>
</pre></div>

</figure>

<p class="calibre3"><strong class="calibre18">Minikube</strong> users can retrieve the IP through <code class="calibre19">minikube ip</code>. If you are one of them, please execute the command that follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code><code class="nv">LB_IP</code><code class="o">=</code><code class="k">$(</code>minikube ip<code class="k">)</code>
</pre></div>

</figure>

<p class="calibre3">Retrieving IP from <strong class="calibre18">minishift</strong> is similar to minikube. If that’s your Kubernetes flavor, please execute the command that follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code><code class="nv">LB_IP</code><code class="o">=</code><code class="k">$(</code>minishift ip<code class="k">)</code>
</pre></div>

</figure>

<p class="calibre3">Finally, if you are using <strong class="calibre18">GKE</strong>, the IP we’re looking for is available through the <code class="calibre19">ingress-nginx</code> service. Please execute the command that follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code><code class="nv">LB_IP</code><code class="o">=</code><code class="k">$(</code>kubectl -n ingress-nginx <code class="se">\</code>
<code class="lineno">2 </code>    get svc ingress-nginx <code class="se">\</code>
<code class="lineno">3 </code>    -o <code class="nv">jsonpath</code><code class="o">=</code><code class="s">"{.status.loadBalancer.ingress[0].ip}"</code><code class="k">)</code>
</pre></div>

</figure>

<p class="calibre3">No matter how you retrieved the IP of your cluster, we’ll validate it by echoing the <code class="calibre19">LB_IP</code> variable.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code><code class="nb">echo</code> <code class="nv">$LB_IP</code>
</pre></div>

</figure>

<p class="calibre3">The output will differ from one case to another. In my case, it is <code class="calibre19">52.15.140.221</code>.</p>

<p class="calibre3">There’s only one more thing left before we jump into Chart repositories. We’ll merge your fork of the <em class="calibre17">go-demo-3</em> code repository with the origin and thus ensure that you are up-to-date with changes I might have made in the meantime.</p>

<p class="calibre3">First, we’ll move into the fork’s directory.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code><code class="nb">cd</code> ../go-demo-3
</pre></div>

</figure>

<p class="calibre3">To be on the safe side, we’ll push the changes you might have made in the previous chapter, and then we’ll sync your fork with the upstream repository. That way, we’ll guarantee that you have all the changes I might have made.</p>

<p class="calibre3">You probably already know how to push your changes and how to sync with the upstream repository. In case you don’t, the commands are as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno"> 1 </code>git add .
<code class="lineno"> 2 </code>
<code class="lineno"> 3 </code>git commit -m <code class="se">\</code>
<code class="lineno"> 4 </code>    <code class="s">"Packaging Kubernetes Applications chapter"</code>
<code class="lineno"> 5 </code>
<code class="lineno"> 6 </code>git push
<code class="lineno"> 7 </code>
<code class="lineno"> 8 </code>git remote add upstream <code class="se">\</code>
<code class="lineno"> 9 </code>    https://github.com/vfarcic/go-demo-3.git
<code class="lineno">10 </code>
<code class="lineno">11 </code>git fetch upstream
<code class="lineno">12 </code>
<code class="lineno">13 </code>git checkout master
<code class="lineno">14 </code>
<code class="lineno">15 </code>git merge upstream/master
</pre></div>

</figure>

<p class="calibre3">We pushed the changes we made in the previous chapter, we fetched the upstream repository <em class="calibre17">vfarcic/go-demo-3</em>, and we merged the latest code from it. The only thing left is to go back to the <code class="calibre19">k8s-specs</code> directory.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code><code class="nb">cd</code> ../k8s-specs
</pre></div>

</figure>

<p class="calibre3">Now we are ready to explore Helm repositories with <em class="calibre17">ChartMuseum</em>.</p>

<h3 id="leanpub-auto-using-chartmuseum" class="calibre20">Using ChartMuseum</h3>

<p class="calibre3">Just as <a href="https://docs.docker.com/registry/">Docker Registry</a> is a place where we can publish our container images and make them accessible to others, we can use Chart repository to accomplish similar goals with our Charts.</p>

<p class="calibre3">A Chart repository is a location where packaged Charts can be stored and retrieved. We’ll use <a href="https://github.com/kubernetes-helm/chartmuseum">ChartMuseum</a> for that. There aren’t many other solutions to choose. We can say that we picked it because there were no alternatives. That will change soon. I’m sure that Helm Charts will become integrated into general purpose repositories. At the time of this writing (June 2018), Charts are already supported by JFrog’s <a href="https://www.jfrog.com/confluence/display/RTF/Helm+Chart+Repositories">Artifactory</a>. You could easily build one yourself if you’re adventurous. All you’d need is a way to store <code class="calibre19">index.yaml</code> file that contains all the Charts and an API that could be used to push and retrieve packages. Anything else would be a bonus, not a requirement.</p>

<p class="calibre3">That’s it. That’s all the explanation you need, except a note that we’ll go with the easiest solution. We won’t build a Charts repository ourselves, nor we are going to pay for Artifactory. We’ll use ChartMuseum.</p>

<p class="calibre3">ChartMuseum is already available in the official Helm repository. We’ll add it to your Helm installation just in case you removed it accidentally.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>helm repo add stable <code class="se">\</code>
<code class="lineno">2 </code>    https://kubernetes-charts.storage.googleapis.com
</pre></div>

</figure>

<p class="calibre3">You should see the output claiming that <code class="calibre19">"stable" has been added to your repositories</code>.</p>

<p class="calibre3">Next, we’ll take a quick look at the values available in <code class="calibre19">chartmuseum</code>.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>helm inspect values stable/chartmuseum
</pre></div>

</figure>

<p class="calibre3">The output, limited to the relevant parts, is as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno"> 1 </code><code class="nn">...</code>
<code class="lineno"> 2 </code><code class="calibre19">image</code><code class="calibre19">:</code>
<code class="lineno"> 3 </code>  <code class="calibre19">repository</code><code class="calibre19">:</code> <code class="calibre19">chartmuseum/chartmuseum</code>
<code class="lineno"> 4 </code>  <code class="calibre19">tag</code><code class="calibre19">:</code> <code class="calibre19">v0.7.0</code>
<code class="lineno"> 5 </code>  <code class="calibre19">pullPolicy</code><code class="calibre19">:</code> <code class="calibre19">IfNotPresent</code>
<code class="lineno"> 6 </code><code class="calibre19">env</code><code class="calibre19">:</code>
<code class="lineno"> 7 </code>  <code class="calibre19">open</code><code class="calibre19">:</code>
<code class="lineno"> 8 </code>    <code class="calibre19">...</code>
<code class="lineno"> 9 </code>    <code class="calibre19">DISABLE_API</code><code class="calibre19">:</code> <code class="calibre19">true</code>
<code class="lineno">10 </code>    <code class="calibre19">...</code>
<code class="lineno">11 </code>  <code class="calibre19">secret</code><code class="calibre19">:</code>
<code class="lineno">12 </code>    <code class="c"># username for basic http authentication</code>
<code class="lineno">13 </code>    <code class="calibre19">BASIC_AUTH_USER</code><code class="calibre19">:</code>
<code class="lineno">14 </code>    <code class="c"># password for basic http authentication</code>
<code class="lineno">15 </code>    <code class="calibre19">BASIC_AUTH_PASS</code><code class="calibre19">:</code>
<code class="lineno">16 </code>    <code class="calibre19">...</code>
<code class="lineno">17 </code><code class="calibre19">resources</code><code class="calibre19">:</code> <code class="calibre19">{}</code>
<code class="lineno">18 </code><code class="c">#  limits:</code>
<code class="lineno">19 </code><code class="c">#    cpu: 100m</code>
<code class="lineno">20 </code><code class="c">#    memory: 128Mi</code>
<code class="lineno">21 </code><code class="c">#  requests:</code>
<code class="lineno">22 </code><code class="c">#    cpu: 80m</code>
<code class="lineno">23 </code><code class="c">#    memory: 64Mi</code>
<code class="lineno">24 </code><code class="nn">...</code>
<code class="lineno">25 </code><code class="calibre19">persistence</code><code class="calibre19">:</code>
<code class="lineno">26 </code>  <code class="calibre19">enabled</code><code class="calibre19">:</code> <code class="calibre19">false</code>
<code class="lineno">27 </code>  <code class="calibre19">...</code>
<code class="lineno">28 </code><code class="c">## Ingress for load balancer</code>
<code class="lineno">29 </code><code class="calibre19">ingress</code><code class="calibre19">:</code>
<code class="lineno">30 </code>  <code class="calibre19">enabled</code><code class="calibre19">:</code> <code class="calibre19">false</code>
<code class="lineno">31 </code><code class="nn">...</code>
<code class="lineno">32 </code><code class="c">#   annotations:</code>
<code class="lineno">33 </code><code class="c">#     kubernetes.io/ingress.class: nginx</code>
<code class="lineno">34 </code><code class="c">#     kubernetes.io/tls-acme: "true"</code>
<code class="lineno">35 </code>
<code class="lineno">36 </code><code class="c">## Chartmuseum Ingress hostnames</code>
<code class="lineno">37 </code><code class="c">## Must be provided if Ingress is enabled</code>
<code class="lineno">38 </code><code class="c">##</code>
<code class="lineno">39 </code><code class="c">#   hosts:</code>
<code class="lineno">40 </code><code class="c">#     chartmuseum.domain.com:</code>
<code class="lineno">41 </code><code class="c">#         - /charts</code>
<code class="lineno">42 </code><code class="c">#         - /index.yaml</code>
<code class="lineno">43 </code><code class="nn">...</code>
</pre></div>

</figure>

<p class="calibre3">We can, and we will change the image tag. We’ll try to make that our practice with all installations. We’ll always use a specific tag, and leave latest for developers and others who might not be concerned with stability of the system.</p>

<p class="calibre3">By default, access to the API is disabled through the <code class="calibre19">DISABLE_API: true</code> entry. We’ll have to enable it if we are to interact with the API. We can see that there are, among others, <code class="calibre19">BASIC_AUTH_USER</code> and <code class="calibre19">BASIC_AUTH_PASS</code> secrets which we can use if we’d like to provide a basic HTTP authentication.</p>

<p class="calibre3">i&gt; Please visit <a href="https://github.com/helm/chartmuseum#api">ChartMuseum API</a> documentation if you’re interested in more details.</p>

<p class="calibre3">Further down are the commented resources. We’ll have to define them ourselves.</p>

<p class="calibre3">We’ll need to persist the state of the application and make it accessible through Ingress. Both can be accomplished by changing related <code class="calibre19">enabled</code> entries to <code class="calibre19">true</code> and, in case of Ingress, by adding a few annotations and a host.</p>

<p class="calibre3">Now that we went through the values we’re interested in, we can proceed with the practical parts. We’ll need to define the address (domain) we’ll use for ChartMuseum.</p>

<p class="calibre3">We already have the IP of the cluster (hopefully the IP of the external LB), and we can use it to create a <code class="calibre19">nip.io</code> domain, just as we did in the previous chapter.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code><code class="nv">CM_ADDR</code><code class="o">=</code><code class="s">"cm.</code><code class="nv">$LB_IP</code><code class="s">.nip.io"</code>
</pre></div>

</figure>

<p class="calibre3">To be on the safe side, we’ll <code class="calibre19">echo</code> the value stored in <code class="calibre19">CM_ADDR</code>, and check whether it looks OK.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code><code class="nb">echo</code> <code class="nv">$CM_ADDR</code>
</pre></div>

</figure>

<p class="calibre3">In my case, the output is <code class="calibre19">cm.18.221.122.90.nip.io</code>.</p>

<p class="calibre3">If you go back to the values output, you’ll notice that the Chart requires host to be defined as a key/value pairs. The problem is that “special” characters cannot be used as part of keys. In the case of our address, we need to escape all the dots. We’ll use a bit of <code class="calibre19">sed</code> magic for that.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code><code class="nv">CM_ADDR_ESC</code><code class="o">=</code><code class="k">$(</code><code class="nb">echo</code> <code class="nv">$CM_ADDR</code> <code class="se">\</code>
<code class="lineno">2 </code>    <code class="calibre19">|</code> sed -e <code class="s">"s@\.@\\\.@g"</code><code class="k">)</code>
<code class="lineno">3 </code>
<code class="lineno">4 </code><code class="nb">echo</code> <code class="nv">$CM_ADDR_ESC</code>
</pre></div>

</figure>

<p class="calibre3">We echoed the address, and we sent the output to the <code class="calibre19">sed</code> command that replaced every <code class="calibre19">.</code> character with <code class="calibre19">\.</code>. The output of the latter command should be similar to the one that follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>cm\.18\.221\.122\.90\.nip\.io
</pre></div>

</figure>

<p class="calibre3">I already prepared a file with all the values we’ll want to customize. Let’s take a quick look at it.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>cat helm/chartmuseum-values.yml
</pre></div>

</figure>

<p class="calibre3">The output is as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno"> 1 </code><code class="calibre19">image</code><code class="calibre19">:</code>
<code class="lineno"> 2 </code>  <code class="calibre19">tag</code><code class="calibre19">:</code> <code class="calibre19">v0.7.0</code>
<code class="lineno"> 3 </code><code class="calibre19">env</code><code class="calibre19">:</code>
<code class="lineno"> 4 </code>  <code class="calibre19">open</code><code class="calibre19">:</code>
<code class="lineno"> 5 </code>    <code class="calibre19">DISABLE_API</code><code class="calibre19">:</code> <code class="calibre19">false</code>
<code class="lineno"> 6 </code><code class="calibre19">resources</code><code class="calibre19">:</code>
<code class="lineno"> 7 </code>  <code class="calibre19">limits</code><code class="calibre19">:</code>
<code class="lineno"> 8 </code>    <code class="calibre19">cpu</code><code class="calibre19">:</code> <code class="calibre19">100m</code>
<code class="lineno"> 9 </code>    <code class="calibre19">memory</code><code class="calibre19">:</code> <code class="calibre19">128Mi</code>
<code class="lineno">10 </code>  <code class="calibre19">requests</code><code class="calibre19">:</code>
<code class="lineno">11 </code>    <code class="calibre19">cpu</code><code class="calibre19">:</code> <code class="calibre19">80m</code>
<code class="lineno">12 </code>    <code class="calibre19">memory</code><code class="calibre19">:</code> <code class="calibre19">64Mi</code>
<code class="lineno">13 </code><code class="calibre19">persistence</code><code class="calibre19">:</code>
<code class="lineno">14 </code>  <code class="calibre19">enabled</code><code class="calibre19">:</code> <code class="calibre19">true</code>
<code class="lineno">15 </code><code class="calibre19">ingress</code><code class="calibre19">:</code>
<code class="lineno">16 </code>  <code class="calibre19">enabled</code><code class="calibre19">:</code> <code class="calibre19">true</code>
<code class="lineno">17 </code>  <code class="calibre19">annotations</code><code class="calibre19">:</code>
<code class="lineno">18 </code>    <code class="calibre19">kubernetes.io/ingress.class</code><code class="calibre19">:</code> <code class="s">"nginx"</code>
<code class="lineno">19 </code>    <code class="calibre19">ingress.kubernetes.io/ssl-redirect</code><code class="calibre19">:</code> <code class="s">"false"</code>
<code class="lineno">20 </code>    <code class="calibre19">nginx.ingress.kubernetes.io/ssl-redirect</code><code class="calibre19">:</code> <code class="s">"false"</code>
<code class="lineno">21 </code>  <code class="calibre19">hosts</code><code class="calibre19">:</code>
<code class="lineno">22 </code>    <code class="calibre19">cm.127.0.0.1.nip.io</code><code class="calibre19">:</code>
<code class="lineno">23 </code>    <code class="calibre19">-</code> <code class="calibre19">/</code>
</pre></div>

</figure>

<p class="calibre3">This is becoming monotonous, and that’s OK. It should be that way. Installations should be boring and follow the same pattern. We found that pattern in Helm.</p>

<p class="calibre3">The <em class="calibre17">chartmuseum-values.yml</em> file defines the values we discussed. It sets the <code class="calibre19">tag</code> we’ll use, and it enables the API. It defines the <code class="calibre19">resources</code>, and you already know that the values we’re using should be taken with a lot of skepticism. In the “real” production, the amount of memory and CPU your applications require will differ significantly from what we can observe in our examples. So we should always monitor our applications real usage patterns, and fine-tune the configuration instead of guessing.</p>

<p class="calibre3">We enabled <code class="calibre19">persistence</code>, and we’ll use the default StorageClass, since we did not specify any explicitly.</p>

<p class="calibre3">Ingress section defines the same annotations as those we used with the other Helm installations. It also defines a single host that will handle requests from all paths (<code class="calibre19">/</code>). Think of it as a reminder only. We cannot rely on the host in the <em class="calibre17">chartmuseum-values.yml</em> file since it likely differs from the <code class="calibre19">nip.io</code> address you defined. I could not predict which one will be in your case. So, we’ll overwrite that value with a <code class="calibre19">--set</code> argument.</p>

<p class="calibre3">Let’s install the Chart.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>helm install stable/chartmuseum <code class="se">\</code>
<code class="lineno">2 </code>    --namespace charts <code class="se">\</code>
<code class="lineno">3 </code>    --name cm <code class="se">\</code>
<code class="lineno">4 </code>    --values helm/chartmuseum-values.yml <code class="se">\</code>
<code class="lineno">5 </code>    --set ingress.hosts.<code class="s">"</code><code class="nv">$CM_ADDR_ESC</code><code class="s">"</code><code class="o">={</code><code class="s">"/"</code><code class="o">}</code> <code class="se">\</code>
<code class="lineno">6 </code>    --set env.secret.BASIC_AUTH_USER<code class="o">=</code>admin <code class="se">\</code>
<code class="lineno">7 </code>    --set env.secret.BASIC_AUTH_PASS<code class="o">=</code>admin
</pre></div>

</figure>

<p class="calibre3">The Chart is installed. Instead of waiting in silence for all the Pods to start running, we’ll briefly discuss security.</p>

<p class="calibre3">We defined the username and the password through <code class="calibre19">--set</code> arguments. They shouldn’t be stored in <code class="calibre19">helm/chartmuseum-values.yml</code> since that would defy the purpose of secrecy.</p>

<p class="calibre3">Personally, I believe that there’s no reason to hide the Charts. They do not (should not) contain anything confidential. The applications are stored in a container registry. Even if someone decides to use our Charts, that person would not be able to deploy our images, if our registry is configured to require authentication.</p>

<p class="calibre3">If that is not enough, and we do want to protect our Charts besides protecting images, we should ask yourself who should not be allowed to access them. If we want to prevent only outsiders from accessing our Charts, the fix is easy. We can put our cluster inside a VPN and make the domain accessible only to internal users. On the other hand, if we want to prevent even internal users from accessing our Charts, we can add basic HTTP authentication. We already saw the <code class="calibre19">secret</code> section when we inspected the values. You could set <code class="calibre19">env.secret.BASIC_AUTH_USER</code> and <code class="calibre19">env.secret.BASIC_AUTH_PASS</code> to enable basic authentication. That’s what we did in our example.</p>

<p class="calibre3">If none of those methods is secure enough, we can implement the best security measure of all. We can disable access to all humans by removing Ingress and changing the Service type to <code class="calibre19">ClusterIP</code>. That would result in only processes running in Pods being able to access the Charts. A good example would be to allow Jenkins to push and pull the Charts, and no one else. Even though that approach is more secure, it does not provide access to the Charts to people who might need it. Humans are true users of ChartMuseum. For scripts, it is easy to know which repository contains the definitions they need and to clone the code, even if that is only for the purpose of retrieving Charts. Humans need a way to search for Charts, to inspect them, and to run them on their laptops or servers.</p>

<p class="calibre3">We opted to a middle solution. We set up basic authentication which is better than no authentication, but still less secure than allowing only those within a VPN to access Charts or disabling human access altogether.</p>

<aside class="warning">
    <h3 id="leanpub-auto-a-note-to-minishift-users-21" class="calibre22">A note to minishift users</h3>

  <p class="calibre3">OpenShift ignores Ingress resources so we’ll have to create a Route to accomplish the same effect. Please execute the command that follows.</p>

  <p class="calibre3"><code class="calibre19">oc -n charts create route edge --service cm-chartmuseum --hostname $CM_ADDR --insecure-policy Allow</code></p>

</aside>

<p class="calibre3">By now, the resources we installed should be up-and-running. We’ll confirm that just to be on the safe side.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>kubectl -n charts <code class="se">\</code>
<code class="lineno">2 </code>    rollout status deploy <code class="se">\</code>
<code class="lineno">3 </code>    cm-chartmuseum
</pre></div>

</figure>

<p class="calibre3">The output should show that the <code class="calibre19">deployment "cm-chartmuseum"</code> was <code class="calibre19">successfully rolled out</code>.</p>

<p class="calibre3">Next, we’ll check whether the application is healthy.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>curl <code class="s">"http://</code><code class="nv">$CM_ADDR</code><code class="s">/health"</code>
</pre></div>

</figure>

<p class="calibre3">The output is as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code><code class="calibre19">{</code><code class="k">"healthy"</code><code class="calibre19">:</code><code class="k">true</code><code class="calibre19">}</code>
</pre></div>

</figure>

<p class="calibre3">Now we can open ChartMuseum in browser.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>open <code class="s">"http://</code><code class="nv">$CM_ADDR</code><code class="s">"</code>
</pre></div>

</figure>

<p class="calibre3">You will be asked for a username and a password. Please use <em class="calibre17">admin</em> for both and click the <em class="calibre17">Sign in</em> button.</p>


<figure class="image1">
  <img src="../images/00014.jpeg" alt="Figure 5-1: ChartMuseum's welcome screen" class="calibre25"/>
  <figcaption class="calibre26">Figure 5-1: ChartMuseum’s welcome screen</figcaption>
</figure>


<p class="calibre3">As you can see, there’s not much of the UI to look. We are supposed to interact with ChartMuseum through its API. If we need to visualize our Charts, we’ll need to look for a different solution.</p>

<p class="calibre3">Let’s see the index.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>curl <code class="s">"http://</code><code class="nv">$CM_ADDR</code><code class="s">/index.yaml"</code>
</pre></div>

</figure>

<p class="calibre3">Since we did not specify the username and the password, we got <code class="calibre19">{"error":"unauthorized"}</code> as the output. We’ll need to authenticate every time we want to interact with ChartMuseum API.</p>

<p class="calibre3">Let’s try again but, this time, with the authentication info.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>curl -u admin:admin <code class="se">\</code>
<code class="lineno">2 </code>    <code class="s">"http://</code><code class="nv">$CM_ADDR</code><code class="s">/index.yaml"</code>
</pre></div>

</figure>

<p class="calibre3">The output is as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code><code class="calibre19">apiVersion</code><code class="calibre19">:</code> <code class="calibre19">v1</code>
<code class="lineno">2 </code><code class="calibre19">entries</code><code class="calibre19">:</code> <code class="calibre19">{}</code>
<code class="lineno">3 </code><code class="calibre19">generated</code><code class="calibre19">:</code> <code class="s">"2018-06-02T21:38:30Z"</code>
</pre></div>

</figure>

<p class="calibre3">It should come as no surprise that we have no entries to the museum. We did not yet push a Chart. Before we do any pushing, we should add a new repository to our Helm client.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>helm repo add chartmuseum <code class="se">\</code>
<code class="lineno">2 </code>    http://<code class="nv">$CM_ADDR</code> <code class="se">\</code>
<code class="lineno">3 </code>    --username admin <code class="se">\</code>
<code class="lineno">4 </code>    --password admin
</pre></div>

</figure>

<p class="calibre3">The output states that <code class="calibre19">"chartmuseum" has been added to your repositories</code>. From now on, all the Charts we store in our ChartMuseum installation will be available through our Helm client.</p>

<p class="calibre3">The only thing left is to start pushing Charts to ChartMuseum. We could do that by sending <code class="calibre19">curl</code> requests. However, there is a better way, so we’ll skip HTTP requests and install a Helm plugin instead.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>helm plugin install <code class="se">\</code>
<code class="lineno">2 </code>    https://github.com/chartmuseum/helm-push
</pre></div>

</figure>

<p class="calibre3">This plugin added a new command <code class="calibre19">helm push</code>. Let’s give it a spin.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>helm push <code class="se">\</code>
<code class="lineno">2 </code>    ../go-demo-3/helm/go-demo-3/ <code class="se">\</code>
<code class="lineno">3 </code>    chartmuseum <code class="se">\</code>
<code class="lineno">4 </code>    --username admin <code class="se">\</code>
<code class="lineno">5 </code>    --password admin
</pre></div>

</figure>

<p class="calibre3">The output is as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>Pushing go-demo-3-0.0.1.tgz to chartmuseum...
<code class="lineno">2 </code>Done.
</pre></div>

</figure>

<p class="calibre3">We pushed a Chart located in the <code class="calibre19">../go-demo-3/helm/go-demo-3/</code> directory into a repository <code class="calibre19">chartmuseum</code>. We can confirm that the push was indeed successful by retrieving <code class="calibre19">index.yaml</code> file from the repository.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>curl <code class="s">"http://</code><code class="nv">$CM_ADDR</code><code class="s">/index.yaml"</code> <code class="se">\</code>
<code class="lineno">2 </code>    -u admin:admin
</pre></div>

</figure>

<p class="calibre3">The output is as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno"> 1 </code><code class="calibre19">apiVersion</code><code class="calibre19">:</code> <code class="calibre19">v1</code>
<code class="lineno"> 2 </code><code class="calibre19">entries</code><code class="calibre19">:</code>
<code class="lineno"> 3 </code>  <code class="calibre19">go-demo-3</code><code class="calibre19">:</code>
<code class="lineno"> 4 </code>  <code class="calibre19">-</code> <code class="calibre19">apiVersion</code><code class="calibre19">:</code> <code class="calibre19">v1</code>
<code class="lineno"> 5 </code>    <code class="calibre19">created</code><code class="calibre19">:</code> <code class="s">"2018-06-02T21:39:21Z"</code>
<code class="lineno"> 6 </code>    <code class="calibre19">description</code><code class="calibre19">:</code> <code class="calibre19">A silly demo based on API written in Go and MongoDB</code>
<code class="lineno"> 7 </code>    <code class="calibre19">digest</code><code class="calibre19">:</code> <code class="calibre19">d8443c78485e80644ff9bfddcf32cc9f270864fb50b75377dbe813b280708519</code>
<code class="lineno"> 8 </code>    <code class="calibre19">home</code><code class="calibre19">:</code> <code class="calibre19">http://www.devopstoolkitseries.com/</code>
<code class="lineno"> 9 </code>    <code class="calibre19">keywords</code><code class="calibre19">:</code>
<code class="lineno">10 </code>    <code class="calibre19">-</code> <code class="calibre19">api</code>
<code class="lineno">11 </code>    <code class="calibre19">-</code> <code class="calibre19">backend</code>
<code class="lineno">12 </code>    <code class="calibre19">-</code> <code class="calibre19">go</code>
<code class="lineno">13 </code>    <code class="calibre19">-</code> <code class="calibre19">database</code>
<code class="lineno">14 </code>    <code class="calibre19">-</code> <code class="calibre19">mongodb</code>
<code class="lineno">15 </code>    <code class="calibre19">maintainers</code><code class="calibre19">:</code>
<code class="lineno">16 </code>    <code class="calibre19">-</code> <code class="calibre19">email</code><code class="calibre19">:</code> <code class="calibre19">viktor@farcic.com</code>
<code class="lineno">17 </code>      <code class="calibre19">name</code><code class="calibre19">:</code> <code class="calibre19">Viktor Farcic</code>
<code class="lineno">18 </code>    <code class="calibre19">name</code><code class="calibre19">:</code> <code class="calibre19">go-demo-3</code>
<code class="lineno">19 </code>    <code class="calibre19">sources</code><code class="calibre19">:</code>
<code class="lineno">20 </code>    <code class="calibre19">-</code> <code class="calibre19">https://github.com/vfarcic/go-demo-3</code>
<code class="lineno">21 </code>    <code class="calibre19">urls</code><code class="calibre19">:</code>
<code class="lineno">22 </code>    <code class="calibre19">-</code> <code class="calibre19">charts/go-demo-3-0.0.1.tgz</code>
<code class="lineno">23 </code>    <code class="calibre19">version</code><code class="calibre19">:</code> <code class="calibre19">0.0.1</code>
<code class="lineno">24 </code><code class="calibre19">generated</code><code class="calibre19">:</code> <code class="s">"2018-06-02T21:39:28Z"</code>
</pre></div>

</figure>

<p class="calibre3">We can see that the <code class="calibre19">go-demo-3</code> Chart is now in the repository. Most of the information comes from the <code class="calibre19">Chart.yaml</code> file we explored in the previous chapter.</p>

<p class="calibre3">Finally, we should validate that our local Helm client indeed sees the new Chart.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>helm search chartmuseum/
</pre></div>

</figure>

<p class="calibre3">The output is probably disappointing. It states that <code class="calibre19">no results</code> were <code class="calibre19">found</code>. The problem is that even though the Chart is stored in the ChartMuseum repository, we did not update the repository information stored locally in the Helm client. So, let’s update it first.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>helm repo update
</pre></div>

</figure>

<p class="calibre3">The output is as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>Hang tight while we grab the latest from your chart repositories...
<code class="lineno">2 </code>...Skip local chart repository
<code class="lineno">3 </code>...Successfully got an update from the "chartmuseum" chart repository
<code class="lineno">4 </code>...Successfully got an update from the "stable" chart repository
<code class="lineno">5 </code>Update Complete. Happy Helming!
</pre></div>

</figure>

<p class="calibre3">If you added more repositories to your Helm client, you might see a bigger output. Those additional repositories do not matter in this context. What does matter is that the <code class="calibre19">chartmuseum</code> was updated and that we can try to search it again.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>helm search chartmuseum/
</pre></div>

</figure>

<p class="calibre3">This time, the output is not empty.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>NAME                 	CHART VERSION	APP VERSION	DESCRIPTION                         \
<code class="lineno">2 </code>              
<code class="lineno">3 </code>chartmuseum/go-demo-3	0.0.1        	           	A silly demo based on API written in\
<code class="lineno">4 </code> Go and Mon...
</pre></div>

</figure>

<p class="calibre3">Our Chart is now available in ChartMuseum, and we can access it with our Helm client. Let’s inspect the Chart.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>helm inspect chartmuseum/go-demo-3
</pre></div>

</figure>

<p class="calibre3">We won’t go through the output since it is the same as the one we explored in the previous chapter. The only difference is that this time it is not retrieved from the Chart stored locally, but from ChartMuseum running inside our cluster. From now on, anyone with the access to that repository can deploy the <em class="calibre17">go-demo-3</em> application.</p>

<p class="calibre3">To be on the safe side, and fully confident in the solution, we’ll deploy the Chart before announcing to everyone that they can use the new repository to install applications.</p>

<p class="calibre3">Just as with the other applications, we’ll start by defining a domain we’ll use for <em class="calibre17">go-demo-3</em>.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code><code class="nv">GD3_ADDR</code><code class="o">=</code><code class="s">"go-demo-3.</code><code class="nv">$LB_IP</code><code class="s">.nip.io"</code>
</pre></div>

</figure>

<p class="calibre3">Next, we’ll output the address as a way to confirm that it looks OK.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code><code class="nb">echo</code> <code class="nv">$GD3_ADDR</code>
</pre></div>

</figure>

<p class="calibre3">The output should be similar to <code class="calibre19">go-demo-3.18.221.122.90.nip.io</code>.</p>

<p class="calibre3">Now we can finally install <em class="calibre17">go-demo-3</em> Chart stored in ChartMuseum running inside our cluster. We’ll continue using <code class="calibre19">upgrade</code> with <code class="calibre19">-i</code> since that is more friendly to our yet-to-be-defined continuous deployment process.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>helm upgrade -i go-demo-3 <code class="se">\</code>
<code class="lineno">2 </code>    chartmuseum/go-demo-3 <code class="se">\</code>
<code class="lineno">3 </code>    --namespace go-demo-3 <code class="se">\</code>
<code class="lineno">4 </code>    --set image.tag<code class="o">=</code><code class="o">1</code>.0 <code class="se">\</code>
<code class="lineno">5 </code>    --set ingress.host<code class="o">=</code><code class="nv">$GD3_ADDR</code> <code class="se">\</code>
<code class="lineno">6 </code>    --reuse-values
</pre></div>

</figure>

<p class="calibre3">We can see from the first line of the output that the <code class="calibre19">release "go-demo-3" does not exist</code>, so Helm decided to install it, instead of doing the upgrade. The rest of the output is the same as the one you saw in the previous chapter. It contains the list of the resources created from the Chart as well as the post-installation instructions.</p>

<aside class="warning">
    <h3 id="leanpub-auto-a-note-to-minishift-users-22" class="calibre22">A note to minishift users</h3>

  <p class="calibre3">OpenShift ignores Ingress resources so we’ll have to create a Route to accomplish the same effect. Please execute the command that follows.</p>

  <p class="calibre3"><code class="calibre19">oc -n go-demo-3 create route edge --service go-demo-3 --hostname $GD3_ADDR --insecure-policy Allow</code></p>

</aside>

<p class="calibre3">Next, we’ll wait until the application is rolled out and confirm that we can access it.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>kubectl -n go-demo-3 <code class="se">\</code>
<code class="lineno">2 </code>    rollout status deploy go-demo-3
<code class="lineno">3 </code>
<code class="lineno">4 </code>curl <code class="s">"http://</code><code class="nv">$GD3_ADDR</code><code class="s">/demo/hello"</code>
</pre></div>

</figure>

<p class="calibre3">The latter command output the familiar <code class="calibre19">hello, world!</code> message thus confirming that the application is up-and-running.</p>

<p class="calibre3">The only thing left to learn is how to remove Charts from ChartMuseum. But, before we do that, we’ll delete <em class="calibre17">go-demo-3</em> from the cluster. We don’t need it anymore.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>helm delete go-demo-3 --purge
</pre></div>

</figure>

<p class="calibre3">Unfortunately, there is no Helm plugin that will allow us to delete a Chart from a repository, so we’ll accomplish our mission using <code class="calibre19">curl</code>.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>curl -XDELETE <code class="se">\</code>
<code class="lineno">2 </code>    <code class="s">"http://</code><code class="nv">$CM_ADDR</code><code class="s">/api/charts/go-demo-3/0.0.1"</code> <code class="se">\</code>
<code class="lineno">3 </code>    -u admin:admin
</pre></div>

</figure>

<p class="calibre3">The output is as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code><code class="calibre19">{</code><code class="k">"deleted"</code><code class="calibre19">:</code><code class="k">true</code><code class="calibre19">}</code>
</pre></div>

</figure>

<p class="calibre3">The chart is deleted from the repository.</p>

<p class="calibre3">Now you know everything there is to know about ChartMuseum. OK, maybe you don’t know everything you should know, but you do know the basics that will allow you to explore it further.</p>

<p class="calibre3">Now that you know how to push and pull Charts to and from ChartMuseum, you might still be wondering if there is an UI that will allow us to visualize Charts. Read on.</p>

<h3 id="leanpub-auto-using-monocular" class="calibre20">Using Monocular</h3>

<p class="calibre3">I don’t think that UIs are useful. We tend to focus on the features they provide, and that distracts us from command line and code. We often get so immersed into filling fields and clicking buttons, that we often forget that the key to automation is to master CLIs and to write code that lives in a code repository. I think that UIs do more damage than good to software engineers.</p>

<p class="calibre3">That being said, I am fully aware that not everyone shares my views. Some like UIs and prefer pretty colors over black and white terminal screens. For those, I will guide you how to get a UI that will utilize Helm repositories and allow you to do some of the things we did through CLI by clicking buttons. We’ll explore <a href="https://github.com/kubernetes-helm/monocular">Monocular</a>.</p>

<p class="calibre3">Monocular is web-based UI for managing Kubernetes applications packaged as Helm Charts. It allows us to search and discover available charts from multiple repositories, and install them in our clusters with one click.</p>

<p class="calibre3">Monocular can be installed with Helm. It is available through a Chart residing in its own <a href="https://kubernetes-helm.github.io/monocular">repository</a>. So, our first step is to add the repository to our Helm client.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>helm repo add monocular <code class="se">\</code>
<code class="lineno">2 </code>    https://kubernetes-helm.github.io/monocular
</pre></div>

</figure>

<p class="calibre3">Let’s take a look at the available values.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>helm inspect values monocular/monocular
</pre></div>

</figure>

<p class="calibre3">The output, limited to the values we’re interested in, is as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno"> 1 </code><code class="calibre19">api</code><code class="calibre19">:</code>
<code class="lineno"> 2 </code>  <code class="calibre19">...</code>
<code class="lineno"> 3 </code>  <code class="calibre19">image</code><code class="calibre19">:</code>
<code class="lineno"> 4 </code>    <code class="calibre19">repository</code><code class="calibre19">:</code> <code class="calibre19">bitnami/monocular-api</code>
<code class="lineno"> 5 </code>    <code class="calibre19">tag</code><code class="calibre19">:</code> <code class="calibre19">v0.7.2</code>
<code class="lineno"> 6 </code>    <code class="calibre19">...</code>
<code class="lineno"> 7 </code>  <code class="calibre19">resources</code><code class="calibre19">:</code>
<code class="lineno"> 8 </code>    <code class="calibre19">limits</code><code class="calibre19">:</code>
<code class="lineno"> 9 </code>      <code class="calibre19">cpu</code><code class="calibre19">:</code> <code class="calibre19">100m</code>
<code class="lineno">10 </code>      <code class="calibre19">memory</code><code class="calibre19">:</code> <code class="calibre19">128Mi</code>
<code class="lineno">11 </code>    <code class="calibre19">requests</code><code class="calibre19">:</code>
<code class="lineno">12 </code>      <code class="calibre19">cpu</code><code class="calibre19">:</code> <code class="calibre19">100m</code>
<code class="lineno">13 </code>      <code class="calibre19">memory</code><code class="calibre19">:</code> <code class="calibre19">128Mi</code>
<code class="lineno">14 </code>  <code class="calibre19">...</code>
<code class="lineno">15 </code><code class="calibre19">ui</code><code class="calibre19">:</code>
<code class="lineno">16 </code>  <code class="calibre19">...</code>
<code class="lineno">17 </code>  <code class="calibre19">image</code><code class="calibre19">:</code>
<code class="lineno">18 </code>    <code class="calibre19">repository</code><code class="calibre19">:</code> <code class="calibre19">bitnami/monocular-ui</code>
<code class="lineno">19 </code>    <code class="calibre19">tag</code><code class="calibre19">:</code> <code class="calibre19">v0.7.2</code>
<code class="lineno">20 </code>    <code class="calibre19">...</code>
<code class="lineno">21 </code><code class="calibre19">ingress</code><code class="calibre19">:</code>
<code class="lineno">22 </code>  <code class="calibre19">enabled</code><code class="calibre19">:</code> <code class="calibre19">true</code>
<code class="lineno">23 </code>  <code class="calibre19">hosts</code><code class="calibre19">:</code>
<code class="lineno">24 </code>  <code class="c"># Wildcard</code>
<code class="lineno">25 </code>  <code class="calibre19">-</code>
<code class="lineno">26 </code>  <code class="c"># - monocular.local</code>
<code class="lineno">27 </code>
<code class="lineno">28 </code>  <code class="c">## Ingress annotations</code>
<code class="lineno">29 </code>  <code class="c">##</code>
<code class="lineno">30 </code>  <code class="calibre19">annotations</code><code class="calibre19">:</code>
<code class="lineno">31 </code>    <code class="c">## Nginx ingress controller (default)</code>
<code class="lineno">32 </code>    <code class="calibre19">nginx.ingress.kubernetes.io/rewrite-target</code><code class="calibre19">:</code> <code class="calibre19">/</code>
<code class="lineno">33 </code>    <code class="calibre19">kubernetes.io/ingress.class</code><code class="calibre19">:</code> <code class="calibre19">nginx</code>
<code class="lineno">34 </code>    <code class="calibre19">...</code>
</pre></div>

</figure>

<p class="calibre3">Just as with the other Charts, we’ll use a fixed version of the images by customizing <code class="calibre19">image.tag</code> values in both the <code class="calibre19">api</code> and the <code class="calibre19">ui</code> sections.</p>

<p class="calibre3">We’ll need to increase the resources since those specified by default are too low.</p>

<p class="calibre3">Ingress is already enabled, but we’ll have to specify the host. Also, we’ll add the “old” style annotations so that older versions of nginx Ingress are supported as well.</p>

<p class="calibre3">Those changes are already available in the <code class="calibre19">monocular-values.yml</code> file, so let’s take a quick look at it.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>cat helm/monocular-values.yml
</pre></div>

</figure>

<p class="calibre3">The output is as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno"> 1 </code><code class="calibre19">api</code><code class="calibre19">:</code>
<code class="lineno"> 2 </code>  <code class="calibre19">image</code><code class="calibre19">:</code>
<code class="lineno"> 3 </code>    <code class="calibre19">tag</code><code class="calibre19">:</code> <code class="calibre19">v0.7.0</code>
<code class="lineno"> 4 </code>  <code class="calibre19">resources</code><code class="calibre19">:</code>
<code class="lineno"> 5 </code>    <code class="calibre19">limits</code><code class="calibre19">:</code>
<code class="lineno"> 6 </code>      <code class="calibre19">cpu</code><code class="calibre19">:</code> <code class="calibre19">500m</code>
<code class="lineno"> 7 </code>      <code class="calibre19">memory</code><code class="calibre19">:</code> <code class="calibre19">1Gi</code>
<code class="lineno"> 8 </code>    <code class="calibre19">requests</code><code class="calibre19">:</code>
<code class="lineno"> 9 </code>      <code class="calibre19">cpu</code><code class="calibre19">:</code> <code class="calibre19">200m</code>
<code class="lineno">10 </code>      <code class="calibre19">memory</code><code class="calibre19">:</code> <code class="calibre19">512Mi</code>
<code class="lineno">11 </code><code class="calibre19">ui</code><code class="calibre19">:</code>
<code class="lineno">12 </code>  <code class="calibre19">image</code><code class="calibre19">:</code>
<code class="lineno">13 </code>    <code class="calibre19">tag</code><code class="calibre19">:</code> <code class="calibre19">v0.7.0</code>
<code class="lineno">14 </code><code class="calibre19">ingress</code><code class="calibre19">:</code>
<code class="lineno">15 </code>  <code class="calibre19">annotations</code><code class="calibre19">:</code>
<code class="lineno">16 </code>    <code class="calibre19">kubernetes.io/ingress.class</code><code class="calibre19">:</code> <code class="s">"nginx"</code>
<code class="lineno">17 </code>    <code class="calibre19">ingress.kubernetes.io/rewrite-target</code><code class="calibre19">:</code> <code class="calibre19">/</code>
<code class="lineno">18 </code>    <code class="calibre19">nginx.ingress.kubernetes.io/rewrite-target</code><code class="calibre19">:</code> <code class="calibre19">/</code>
<code class="lineno">19 </code>    <code class="calibre19">ingress.kubernetes.io/ssl-redirect</code><code class="calibre19">:</code> <code class="s">"false"</code>
<code class="lineno">20 </code>    <code class="calibre19">nginx.ingress.kubernetes.io/ssl-redirect</code><code class="calibre19">:</code> <code class="s">"false"</code>
</pre></div>

</figure>

<p class="calibre3">Before we proceed, we’ll have to generate a valid hostname that we’ll use with Monocular Ingress resource.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code><code class="nv">MONOCULAR_ADDR</code><code class="o">=</code><code class="s">"monocular.</code><code class="nv">$LB_IP</code><code class="s">.nip.io"</code>
<code class="lineno">2 </code>
<code class="lineno">3 </code><code class="nb">echo</code> <code class="nv">$MONOCULAR_ADDR</code>
</pre></div>

</figure>

<p class="calibre3">The output of the latter command should be similar to the one that follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>monocular.18.221.122.90.nip.io
</pre></div>

</figure>

<aside class="warning">
    <h3 id="leanpub-auto-a-note-to-minishift-users-23" class="calibre22">A note to minishift users</h3>

  <p class="calibre3">Installing Monocular in OpenShift creates a few issues and requires quite a few changes to the commands that follow. Please use the instructions from <a href="https://blog.openshift.com/deploy-monocular-openshift/">Deploy Monocular on OpenShift</a> article instead of the command that follows.</p>

</aside>

<p class="calibre3">Now we are ready to install Monocular Chart.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>helm install monocular/monocular <code class="se">\</code>
<code class="lineno">2 </code>    --namespace charts <code class="se">\</code>
<code class="lineno">3 </code>    --name monocular <code class="se">\</code>
<code class="lineno">4 </code>    --values helm/monocular-values.yml <code class="se">\</code>
<code class="lineno">5 </code>    --set ingress.hosts<code class="o">={</code><code class="nv">$MONOCULAR_ADDR</code><code class="o">}</code>
</pre></div>

</figure>

<p class="calibre3">The output follows the same pattern as the other charts. It shows the status at the top, followed with the resources it created. At the bottom are short instructions for the post-installation steps.</p>

<p class="calibre3">We should wait until the application rolls out before giving a spin to its UI.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>kubectl -n charts <code class="se">\</code>
<code class="lineno">2 </code>    rollout status <code class="se">\</code>
<code class="lineno">3 </code>    deploy monocular-monocular-api
</pre></div>

</figure>

<p class="calibre3">It will take a while until the API rolls out and the <code class="calibre19">monocular-api</code> Pods might fail a few times. Be patient.</p>

<p class="calibre3">Now we can open Monocular in a browser.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>open <code class="s">"http://</code><code class="nv">$MONOCULAR_ADDR</code><code class="s">"</code>
</pre></div>

</figure>


<figure class="image1">
  <img src="../images/00015.jpeg" alt="Figure 5-2: Monocular's home screen" class="calibre25"/>
  <figcaption class="calibre26">Figure 5-2: Monocular’s home screen</figcaption>
</figure>


<p class="calibre3">If we click on the <em class="calibre17">Charts</em> link in top-right corner of the screen, we’ll see all the charts available in the two default repositories (<em class="calibre17">stable</em> and <em class="calibre17">incubator</em>). We can use the link on the left-hand menu to filter them by a repository and to change the ordering. We can also use the <em class="calibre17">Search charts…</em> field to filter Charts.</p>

<p class="calibre3">The <em class="calibre17">Repositories</em> screen can be used to list those that are currently configured, as well as to add new ones.</p>

<p class="calibre3">The <em class="calibre17">Deployments</em> screen list all the Helm installations. At the moment, we have <em class="calibre17">cm</em> (ChartMuseum) and <em class="calibre17">monocular</em> running through Helm Charts. Additionally, there is the <em class="calibre17">New deployment</em> button that we can use to install a new Chart. Please click it and observe that you are taken back to the <em class="calibre17">Charts</em> screen. We are about to install Jenkins.</p>

<p class="calibre3">Type <em class="calibre17">jenkins</em> in the <em class="calibre17">Search charts…</em> field. The list of the Charts will be filtered, and we’ll see only Jenkins. Click on the only Chart.</p>

<p class="calibre3">On the left-hand side of the screen is the same information we can see by executing <code class="calibre19">helm inspect stable/jenkins</code> command. On the right-hand side, there is the <em class="calibre17">Install</em> section which we can use for <em class="calibre17">one click installation</em> or to copy <em class="calibre17">Helm CLI</em> commands.</p>

<p class="calibre3">Please remain in the <em class="calibre17">One Click Installation</em> tab and click the <em class="calibre17">Install jenkins v…</em> button. You will be presented with a popup with a field to specify a Namespace where the Chart will be installed. Please type <em class="calibre17">jenkins</em> and click the <em class="calibre17">Deploy</em> button.</p>

<p class="calibre3">We were redirected to the screen with the same information we’d get if we executed <code class="calibre19">helm install stable/jenkins --namespace jenkins</code>.</p>

<p class="calibre3">Even though using Monocular might seem tempting at the begging, it has a few serious drawbacks. We’ll discuss them soon. For now, please click the red <em class="calibre17">Delete deployment</em> button to remove Jenkins.</p>

<p class="calibre3">The major problem with Monocular is that it does not allow us to specify values during Charts installation. There will hardly ever be the case when we’ll install Charts without any custom values. That inability alone should be enough to discard Monocular for any serious usage. On top of that, it does not provide the option to upgrade Charts.</p>

<p class="calibre3">Today (June 2018) Monocular project is still too young to be taken seriously. That will probably change as the project matures. For now, my recommendation is not to use it. That might provoke an adverse reaction. You might feel that I wasted your time by showing you a tool that is not useful. However, I thought that you should know that the UI exists and that it is the only free option we have today. I’ll leave that decision to you. You know what it does and how to install it.</p>

<h3 id="leanpub-auto-what-now-4" class="calibre20">What Now?</h3>

<p class="calibre3">We will continue using ChartMuseum throughout the rest of the book, and I will leave it to you to decide whether Monocular is useful or a waste of computing resources.</p>

<p class="calibre3">We could have set up a container registry, but we didn’t. There are too many tools in the market ranging from free solutions like <a href="https://docs.docker.com/registry/">Docker Registry</a> all the way until enterprise products like <a href="https://docs.docker.com/ee/dtr/">Docker Trusted Registry</a> and JFrog’ <a href="https://www.jfrog.com/confluence/display/RTF/Docker+Registry">Artifactory</a>. The problem is that Docker Registry (free version) is very insecure. It provides only a very basic authentication. Still, the price is right (it’s free). On the other hand, you might opt for one of the commercial solutions and leverage the additional features they provide. Never the less, I felt that for our use-case it is the best if we stick with <a href="https://hub.docker.com/">Docker Hub</a>. Almost everyone has an account there, and it is an excellent choice for the examples we’re having. Once you translate the knowledge from here to your “real” processes, you should have no problem switching to any other container registry if you choose to do so. By now, you should have all the skills required to run a registry in your cluster.</p>

<p class="calibre3">All in all, we’ll continue using Docker Hub for storing container images, and we’ll run ChartMuseum in our cluster and use it to distribute Helm Charts.</p>

<p class="calibre3">All that’s left is for us to remove the Charts we installed. We’ll delete them all at once. Alternatively, you can delete the whole cluster if you do plan to make a break. In any case, the next chapter will start from scratch.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>helm delete <code class="k">$(</code>helm ls -q<code class="k">)</code> --purge
<code class="lineno">2 </code>
<code class="lineno">3 </code>kubectl delete ns <code class="se">\</code>
<code class="lineno">4 </code>    charts go-demo-3 jenkins
</pre></div>

</figure>



</div>
</body></html>