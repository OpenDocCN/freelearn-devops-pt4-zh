- en: Continuous Delivery With Jenkins And GitOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given that we already explored continuous deployment, you might be wondering
    why are we even talking at this point about continuous delivery. There are a few
    reasons for that. First of all, I am conscious that many of you will not or can
    not implement continuous deployment. Your tests might not be as reliable as you’d
    need them to be. Your processes might not allow full automation. You might have
    to follow regulations that prevent you from reaching nirvana. There could be many
    other reasons. The point is that not everyone can apply continuous deployment.
    Even among those that can get there, there are indeed some that do not want that
    as the destination. So, we’ll explore continuous delivery as an alternative to
    continuous deployment.
  prefs: []
  type: TYPE_NORMAL
- en: There are other reasons for writing this chapter. So far, I showed you one possible
    implementation of the continuous deployment pipeline. We could modify the existing
    pipeline by adding an `input` step before making the release and upgrading production.
    That would add *proceed* and *cancel* buttons that we could use to choose whether
    to upgrade the production release or not. This chapter would be the shortest chapter
    ever, and that would be boring. Where’s the fun in doing a small variation of
    the same?
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use this chapter to explore a few alternative approaches to writing Jenkins
    pipeline. Just as the pipeline from the previous chapter could be easily converted
    from continuous deployment to continuous delivery process, what we’re going to
    do next could also go both ways. So, even though our objective is to write a continuous
    delivery pipeline, the lessons from this chapter could be easily applied to continuous
    deployment as well.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use this opportunity to explore declarative pipeline as an alternative
    to scripted. We’ll switch from using a separate VM for building docker image to
    using the Docker socket to build it in one of the nodes of the cluster. We’ll
    explore how we can define our whole productions environment differently. We’ll
    even introduce GitOps.
  prefs: []
  type: TYPE_NORMAL
- en: The real goal is to give you valid alternatives to the approaches we used so
    far, thus allowing you to make better decisions when implementing lessons-learned
    in your organization. I hope that by the end of this chapter you will be able
    to cherry-pick things that suit you the best and assemble your own process.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for the prep-talk. You know what continuous delivery is, and you know
    how to use Kubernetes. Let’s define some pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Creating A Cluster
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as before, we’ll start the practical part by making sure that we have the
    latest version of the *k8s-specs* repository.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
