<html><head></head><body>
<div class="calibre6">
<h2 id="appendix-a" class="calibre16">Appendix A: Installing kubectl and Creating A Cluster With minikube</h2>

<p class="calibre3">The text that follows provides the essential information you’ll need to create a local Kubernetes cluster using minikube. This appendix contains a few sub-chapters from <a href="https://amzn.to/2GvzDjy">The DevOps 2.3 Toolkit: Kubernetes</a>. Please refer to it for a more detailed information.</p>

<h3 id="leanpub-auto-running-kubernetes-cluster-locally" class="calibre20">Running Kubernetes Cluster Locally</h3>

<p class="calibre3">Minikube creates a single-node cluster inside a VM on your laptop. While that is not ideal since we won’t be able to demonstrate some of the features Kubernetes provides in a multi-node setup, it should be more than enough to explain most of the concepts behind Kubernetes. Later on, we’ll move into a more production-like environment and explore the features that cannot be demonstrated in Minikube.</p>

<aside class="warning">
    <h3 id="leanpub-auto-a-note-to-windows-users-5" class="calibre22">A note to Windows users</h3>

  <p class="calibre3">Please run all the examples from <em class="calibre17">GitBash</em> (installed through <em class="calibre17">Git</em>). That way the commands you’ll see throughout the book will be same as those that should be executed on <em class="calibre17">MacOS</em> or any <em class="calibre17">Linux</em> distribution. If you’re using Hyper-V instead of VirtualBox, you may need to run the <em class="calibre17">GitBash</em> window as an Administrator.</p>

</aside>

<p class="calibre3">Before we dive into Minikube installation, there are a few prerequisites we should set up. The first in line is <code class="calibre19">kubectl</code>.</p>

<h3 id="leanpub-auto-installing-kubectl" class="calibre20">Installing kubectl</h3>

<p class="calibre3">Kubernetes’ command-line tool, <code class="calibre19">kubectl</code>, is used to manage a cluster and applications running inside it. We’ll use <code class="calibre19">kubectl</code> a lot throughout the book, so we won’t go into details just yet. Instead, we’ll discuss its commands through examples that will follow shortly. For now, think of it as your interlocutor with a Kubernetes cluster.</p>

<p class="calibre3">Let’s install <code class="calibre19">kubectl</code>.</p>

<aside class="information">
    <p class="calibre3">All the commands from this chapter are available in the <a href="https://gist.github.com/77ca05f4d16125b5a5a5dc30a1ade7fc">02-minikube.sh</a> Gist.</p>

</aside>

<aside class="tip">
    <p class="calibre3">Feel free to skip the installation steps if you already have <code class="calibre19">kubectl</code>. Just make sure that it is version 1.8 or above.</p>

</aside>

<p class="calibre3">If you are a <strong class="calibre18">MacOS user</strong>, please execute the commands that follow.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>curl -LO https://storage.googleapis.com/kubernetes-release/release/<code class="s">`</code>curl -s https://<code class="se">\</code>
<code class="lineno">2 </code>storage.googleapis.com/kubernetes-release/release/stable.txt<code class="s">`</code>/bin/darwin/amd64/kubec<code class="se">\</code>
<code class="lineno">3 </code>tl
<code class="lineno">4 </code>
<code class="lineno">5 </code>chmod +x ./kubectl
<code class="lineno">6 </code>
<code class="lineno">7 </code>sudo mv ./kubectl /usr/local/bin/kubectl
</pre></div>

</figure>

<p class="calibre3">If you already have <a href="https://brew.sh/">Homebrew</a> package manager installed, you can “brew” it with the command that follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>brew install kubectl
</pre></div>

</figure>

<p class="calibre3">If, on the other hand, you’re a <strong class="calibre18">Linux user</strong>, the commands that will install <code class="calibre19">kubectl</code> are as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>curl -LO https://storage.googleapis.com/kubernetes-release/release/<code class="k">$(</code>curl -s https:/<code class="se">\</code>
<code class="lineno">2 </code>/storage.googleapis.com/kubernetes-release/release/stable.txt<code class="k">)</code>/bin/linux/amd64/kubec<code class="se">\</code>
<code class="lineno">3 </code>tl
<code class="lineno">4 </code>
<code class="lineno">5 </code>chmod +x ./kubectl
<code class="lineno">6 </code>
<code class="lineno">7 </code>sudo mv ./kubectl /usr/local/bin/kubectl
</pre></div>

</figure>

<p class="calibre3">Finally, <strong class="calibre18">Windows users</strong> should download the binary through the command that follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>curl -LO https://storage.googleapis.com/kubernetes-release/release/<code class="k">$(</code>curl -s https:/<code class="se">\</code>
<code class="lineno">2 </code>/storage.googleapis.com/kubernetes-release/release/stable.txt<code class="k">)</code>/bin/windows/amd64/kub<code class="se">\</code>
<code class="lineno">3 </code>ectl.exe
</pre></div>

</figure>

<p class="calibre3">Feel free to copy the binary to any directory. The important thing is to add it to your <code class="calibre19">PATH</code>.</p>

<p class="calibre3">Let’s check <code class="calibre19">kubectl</code> version and, at the same time, validate that it is working correctly. No matter which OS you’re using, the command is as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>kubectl version
</pre></div>

</figure>

<p class="calibre3">The output is as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>Client Version: version.Info{Major:"1", Minor:"9", GitVersion:"v1.9.0", GitCommit:"9\
<code class="lineno">2 </code>25c127ec6b946659ad0fd596fa959be43f0cc05", GitTreeState:"clean", BuildDate:"2017-12-1\
<code class="lineno">3 </code>5T21:07:38Z", GoVersion:"go1.9.2", Compiler:"gc", Platform:"darwin/amd64"}
<code class="lineno">4 </code>The connection to the server localhost:8080 was refused - did you specify the right \
<code class="lineno">5 </code>host or port?
</pre></div>

</figure>

<p class="calibre3">That is a very ugly and unreadable output. Fortunately, <code class="calibre19">kubectl</code> can use a few different formats for its output. For example, we can tell it to output the command in <code class="calibre19">yaml</code> format</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>kubectl version --output<code class="o">=</code>yaml
</pre></div>

</figure>

<p class="calibre3">The output is as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno"> 1 </code><code class="calibre19">clientVersion</code><code class="o">:</code>
<code class="lineno"> 2 </code>  <code class="calibre19">buildDate</code><code class="o">:</code> <code class="o">2017</code><code class="o">-</code><code class="o">12</code><code class="o">-</code><code class="o">15</code><code class="calibre19">T21</code><code class="o">:</code><code class="o">07</code><code class="o">:</code><code class="o">38</code><code class="calibre19">Z</code>
<code class="lineno"> 3 </code>  <code class="calibre19">compiler</code><code class="o">:</code> <code class="calibre19">gc</code>
<code class="lineno"> 4 </code>  <code class="calibre19">gitCommit</code><code class="o">:</code> <code class="o">925</code><code class="calibre19">c127ec6b946659ad0fd596fa959be43f0cc05</code>
<code class="lineno"> 5 </code>  <code class="calibre19">gitTreeState</code><code class="o">:</code> <code class="calibre19">clean</code>
<code class="lineno"> 6 </code>  <code class="calibre19">gitVersion</code><code class="o">:</code> <code class="calibre19">v1</code><code class="o">.</code><code class="o">9.0</code>
<code class="lineno"> 7 </code>  <code class="calibre19">goVersion</code><code class="o">:</code> <code class="calibre19">go1</code><code class="o">.</code><code class="o">9.2</code>
<code class="lineno"> 8 </code>  <code class="calibre19">major</code><code class="o">:</code> <code class="s">"1"</code>
<code class="lineno"> 9 </code>  <code class="calibre19">minor</code><code class="o">:</code> <code class="s">"9"</code>
<code class="lineno">10 </code>  <code class="calibre19">platform</code><code class="o">:</code> <code class="calibre19">darwin</code><code class="o">/</code><code class="calibre19">amd64</code>
<code class="lineno">11 </code>
<code class="lineno">12 </code><code class="calibre19">The</code> <code class="calibre19">connection</code> <code class="calibre19">to</code> <code class="calibre19">the</code> <code class="calibre19">server</code> <code class="calibre19">localhost</code><code class="o">:</code><code class="o">8080</code> <code class="calibre19">was</code> <code class="calibre19">refused</code> <code class="o">-</code> <code class="calibre19">did</code> <code class="calibre19">you</code> <code class="calibre19">specify</code> <code class="calibre19">the</code> <code class="calibre19">right</code> <code class="o">\</code>
<code class="lineno">13 </code><code class="calibre19">host</code> <code class="calibre19">or</code> <code class="calibre19">port</code><code class="o">?</code>
</pre></div>

</figure>

<p class="calibre3">That was a much better (more readable) output.</p>

<p class="calibre3">We can see that the client version is 1.9. At the bottom is the error message stating that <code class="calibre19">kubectl</code> could not connect to the server. That is expected since we did not yet create a cluster. That’s our next step.</p>

<aside class="information">
    <p class="calibre3">At the time of writing this book kubectl version was 1.9.0. Your version might be different when you install.</p>

</aside>

<h3 id="leanpub-auto-installing-minikube" class="calibre20">Installing Minikube</h3>

<p class="calibre3">Minikube supports several virtualization technologies. We’ll use VirtualBox throughout the book since it is the only virtualization supported in all operating systems. If you do not have it already, please head to the <a href="https://www.virtualbox.org/wiki/Downloads">Download VirtualBox</a> page and get the version that matches your OS. Please keep in mind that for VirtualBox or HyperV to work, virtualization must be enabled in the BIOS. Most laptops should have it enabled by default.</p>

<p class="calibre3">Finally, we can install Minikube.</p>

<p class="calibre3">If you’re using <strong class="calibre18">MacOS</strong>, please execute the command that follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>brew cask install minikube
</pre></div>

</figure>

<p class="calibre3">If, on the other hand, you prefer <strong class="calibre18">Linux</strong>, the command is as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-l<code class="se">\</code>
<code class="lineno">2 </code>inux-amd64 <code class="o">&amp;&amp;</code> chmod +x minikube <code class="o">&amp;&amp;</code> sudo mv minikube /usr/local/bin/
</pre></div>

</figure>

<p class="calibre3">Finally, you will not get a command if you are a Windows user. Instead, download the latest release from of the <a href="https://storage.googleapis.com/minikube/releases/latest/minikube-windows-amd64.exe">minikube-windows-amd64.exe</a> file, rename it to <code class="calibre19">minikube.exe</code>, and add it to your path.</p>

<p class="calibre3">We’ll test whether Minikube works by checking its version.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>minikube version
</pre></div>

</figure>

<p class="calibre3">The output is as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>minikube version: v0.23.0
</pre></div>

</figure>

<p class="calibre3">Now we’re ready to give the cluster a spin.</p>

<h3 id="leanpub-auto-creating-a-local-kubernetes-cluster-with-minikube" class="calibre20">Creating A Local Kubernetes Cluster With Minikube</h3>

<p class="calibre3">The folks behind Minikube made creating a cluster as easy as it can get. All we need to do is to execute a single command. Minikube will start a virtual machine locally and deploy the necessary Kubernetes components into it. The VM will get configured with Docker and Kubernetes via a single binary called localkube.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>minikube start --vm-driver<code class="o">=</code>virtualbox
</pre></div>

</figure>

<aside class="warning">
    <h3 id="leanpub-auto-a-note-to-windows-users-6" class="calibre22">A note to Windows users</h3>

  <p class="calibre3">You might experience problems with <code class="calibre19">virtualbox</code>. If that’s the case, you might want to use <code class="calibre19">hyperv</code> instead. Open a Powershell Admin Window and execute the <code class="calibre19">Get-NetAdapter</code> command, noting the name of your network connection. Create a <code class="calibre19">hyperv</code> virtual switch <code class="calibre19">New-VMSwitch -name NonDockerSwitch -NetAdapterName Ethernet -AllowManagementOS $true</code> replacing <code class="calibre19">Ethernet</code> with your network connection name. Then create the Minikube vm: <code class="calibre19">minikube start --vm-driver=hyperv --hyperv-virtual-switch "NonDockerSwitch" --memory=4096</code>. Other minikube commands such as <code class="calibre19">minikube start</code>, <code class="calibre19">minikube stop</code> and <code class="calibre19">minikube delete</code> all work the same whether you’re using VirutalBox or Hyper-V.</p>

</aside>

<p class="calibre3">A few moments later, a new Minikube VM will be created and set up, and a cluster will be ready for use.</p>

<p class="calibre3">When we executed the <code class="calibre19">minikube start</code> command, it created a new VM based on the Minikube image. That image contains a few binaries. It has both <a href="https://www.docker.com/">Docker</a> and <a href="https://coreos.com/rkt/">rkt</a> container engines as well as <em class="calibre17">localkube</em> library. The library includes all the components necessary for running Kubernetes. We’ll go into details of all those components later. For now, the important thing is that localkube provides everything we need to run a Kubernetes cluster locally.</p>

<p class="calibre3">Remember that this is a single-node cluster. While that is unfortunate, it is still the easiest way (as far as I know) to “play” with Kubernetes locally. It should do, for now. Later on, we’ll explore ways to create a multi-node cluster that will be much closer to a production setup.</p>

<p class="calibre3">Let’s take a look at the status of the cluster.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>minikube status
</pre></div>

</figure>

<p class="calibre3">The output is as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code><code class="calibre19">minikube</code><code class="o">:</code> <code class="calibre19">Running</code>
<code class="lineno">2 </code><code class="calibre19">cluster</code><code class="o">:</code> <code class="calibre19">Running</code>
<code class="lineno">3 </code><code class="calibre19">kubectl</code><code class="o">:</code> <code class="calibre19">Correctly</code> <code class="calibre19">Configured</code><code class="o">:</code> <code class="calibre19">pointing</code> <code class="calibre19">to</code> <code class="calibre19">minikube</code><code class="o">-</code><code class="calibre19">vm</code> <code class="calibre19">at</code> <code class="o">192.168</code><code class="o">.</code><code class="o">99.100</code>
</pre></div>

</figure>

<p class="calibre3">Minikube is running, and it initialized a Kubernetes cluster. It even configured <code class="calibre19">kubectl</code> so that it points to the newly created VM.</p>

<p class="calibre3">You won’t see much UI in this book. I believe that a terminal is the best way to operate a cluster. More importantly, I am convinced that one should master a tool through its commands first. Later on, once we feel comfortable and understand how the tool works, we can choose to use a UI on top of it. We’ll explore the Kubernetes UI in one of the later chapters. For now, I’ll let you have a quick glimpse of it.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>minikube dashboard
</pre></div>

</figure>

<p class="calibre3">Feel free to explore the UI but don’t take too long. You’ll only get confused with concepts that we did not yet study. Once we learn about pods, replica-sets, services, and a myriad of other Kubernetes components, the UI will start making much more sense.</p>

<p class="calibre3">Another useful Minikube command is <code class="calibre19">docker-env</code>.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>minikube docker-env
</pre></div>

</figure>

<p class="calibre3">The output is as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>export DOCKER_TLS_VERIFY="1"
<code class="lineno">2 </code>export DOCKER_HOST="tcp://192.168.99.100:2376"
<code class="lineno">3 </code>export DOCKER_CERT_PATH="/Users/vfarcic/.minikube/certs"
<code class="lineno">4 </code>export DOCKER_API_VERSION="1.23"
<code class="lineno">5 </code># Run this command to configure your shell:
<code class="lineno">6 </code># eval $(minikube docker-env)
</pre></div>

</figure>

<p class="calibre3">If you worked with Docker Machine, you’ll notice that the output is the same. Both <code class="calibre19">docker-machine env</code> and <code class="calibre19">minikube docker-env</code> serve the same purpose. They output the environment variables required for a local Docker client to communicate with a remote Docker server. In this case, that Docker server is the one inside a VM created by Minikube. I assume that you already have Docker installed on your laptop. If that’s not the case, please go to the <a href="https://docs.docker.com/engine/installation/">Install Docker</a> page and follow the instructions for your operating system. Once Docker is installed, we can connect the client running on your laptop with the server in the Minikube VM.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code><code class="nb">eval</code> <code class="k">$(</code>minikube docker-env<code class="k">)</code>
</pre></div>

</figure>

<p class="calibre3">We evaluated (created) the environment variables provided through the <code class="calibre19">minikube docker-env</code> command. As a result, every command we send to our local Docker client will be executed on the Minikube VM. We can test that easily by, for example, listing all the running containers on that VM.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>docker container ls
</pre></div>

</figure>

<p class="calibre3">The containers listed in the output are those required by Kubernetes. We can, in a way, consider them system containers. We won’t discuss each of them. As a matter of fact, we won’t discuss any of them. At least, not right away. All you need to know, at this point, is that they make Kubernetes work.</p>

<p class="calibre3">Since almost everything in that VM is a container, pointing the local Docker client to the service inside it should be all you need (besides <code class="calibre19">kubectl</code>). Still, in some cases, you might want to SSH into the VM.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>minikube ssh
<code class="lineno">2 </code>
<code class="lineno">3 </code>docker container ls
<code class="lineno">4 </code>
<code class="lineno">5 </code><code class="nb">exit</code>
</pre></div>

</figure>

<p class="calibre3">We entered into the Minikube VM, listed containers, and got out. There’s no reason to do anything else beyond showing that SSH is possible, even though you probably won’t use it.</p>

<p class="calibre3">What else is there to verify? We can, for example, confirm that <code class="calibre19">kubectl</code> is also pointing to the Minikube VM.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>kubectl config current-context
</pre></div>

</figure>

<p class="calibre3">The output should be a single word, <code class="calibre19">minikube</code>, indicating that <code class="calibre19">kubectl</code> is configured to talk to Kubernetes inside the newly created cluster.</p>

<p class="calibre3">As an additional verification, we can list all the nodes of the cluster.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>kubectl get nodes
</pre></div>

</figure>

<p class="calibre3">The output is as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>NAME     STATUS ROLES  AGE VERSION
<code class="lineno">2 </code>minikube Ready  &lt;none&gt; 31m v1.8.0
</pre></div>

</figure>

<p class="calibre3">It should come as no surprise that there is only one node, conveniently called <code class="calibre19">minikube</code>.</p>

<p class="calibre3">If you are experienced with Docker Machine or Vagrant, you probably noticed the similar pattern. Minikube commands are almost exactly the same as those from Docker Machine which, on the other hand, are similar to those from Vagrant.</p>

<p class="calibre3">We can do all the common things we would expect from a virtual machine. For example, we can stop it.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>minikube stop
</pre></div>

</figure>

<p class="calibre3">We can start it again.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>minikube start
</pre></div>

</figure>

<p class="calibre3">We can delete it.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>minikube delete
</pre></div>

</figure>

<p class="calibre3">One interesting feature is the ability to specify which Kubernetes version we’d like to use.</p>

<p class="calibre3">Since Kubernetes is still a young project, we can expect quite a lot of changes at a rapid pace. That will often mean that our production cluster might not be running the latest version. On the other hand, we should strive to have our local environment as close to production as possible (within reason).</p>

<p class="calibre3">We can list all the available versions with the command that follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>minikube get-k8s-versions
</pre></div>

</figure>

<p class="calibre3">The output, limited to the first few lines, is as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>The following Kubernetes versions are available:
<code class="lineno">2 </code>        - v1.9.0
<code class="lineno">3 </code>        - v1.8.0
<code class="lineno">4 </code>        - v1.7.5
<code class="lineno">5 </code>        - v1.7.4
<code class="lineno">6 </code>        - v1.7.3
<code class="lineno">7 </code>        - v1.7.2
<code class="lineno">8 </code>        - v1.7.0
<code class="lineno">9 </code>        ...
</pre></div>

</figure>

<p class="calibre3">Now that we know which versions are available, we can create a new cluster based on, let’s say, Kubernetes v1.7.0.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>minikube start \
<code class="lineno">2 </code>    --vm-driver=virtualbox \
<code class="lineno">3 </code>    --kubernetes-version="v1.7.0"
<code class="lineno">4 </code>
<code class="lineno">5 </code>kubectl version --output=yaml
</pre></div>

</figure>

<p class="calibre3">We created a new cluster and output versions of the client and the server.</p>

<p class="calibre3">The output of the latter command is as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno"> 1 </code><code class="calibre19">clientVersion</code><code class="o">:</code>
<code class="lineno"> 2 </code>  <code class="calibre19">buildDate</code><code class="o">:</code> <code class="o">2017</code><code class="o">-</code><code class="o">10</code><code class="o">-</code><code class="o">24</code><code class="calibre19">T19</code><code class="o">:</code><code class="o">48</code><code class="o">:</code><code class="o">57</code><code class="calibre19">Z</code>
<code class="lineno"> 3 </code>  <code class="calibre19">compiler</code><code class="o">:</code> <code class="calibre19">gc</code>
<code class="lineno"> 4 </code>  <code class="calibre19">gitCommit</code><code class="o">:</code> <code class="calibre19">bdaeafa71f6c7c04636251031f93464384d54963</code>
<code class="lineno"> 5 </code>  <code class="calibre19">gitTreeState</code><code class="o">:</code> <code class="calibre19">clean</code>
<code class="lineno"> 6 </code>  <code class="calibre19">gitVersion</code><code class="o">:</code> <code class="calibre19">v1</code><code class="o">.</code><code class="o">8.2</code>
<code class="lineno"> 7 </code>  <code class="calibre19">goVersion</code><code class="o">:</code> <code class="calibre19">go1</code><code class="o">.</code><code class="o">8.3</code>
<code class="lineno"> 8 </code>  <code class="calibre19">major</code><code class="o">:</code> <code class="s">"1"</code>
<code class="lineno"> 9 </code>  <code class="calibre19">minor</code><code class="o">:</code> <code class="s">"8"</code>
<code class="lineno">10 </code>  <code class="calibre19">platform</code><code class="o">:</code> <code class="calibre19">darwin</code><code class="o">/</code><code class="calibre19">amd64</code>
<code class="lineno">11 </code><code class="calibre19">serverVersion</code><code class="o">:</code>
<code class="lineno">12 </code>  <code class="calibre19">buildDate</code><code class="o">:</code> <code class="o">2017</code><code class="o">-</code><code class="o">10</code><code class="o">-</code><code class="o">04</code><code class="calibre19">T09</code><code class="o">:</code><code class="o">25</code><code class="o">:</code><code class="o">40</code><code class="calibre19">Z</code>
<code class="lineno">13 </code>  <code class="calibre19">compiler</code><code class="o">:</code> <code class="calibre19">gc</code>
<code class="lineno">14 </code>  <code class="calibre19">gitCommit</code><code class="o">:</code> <code class="calibre19">d3ada0119e776222f11ec7945e6d860061339aad</code>
<code class="lineno">15 </code>  <code class="calibre19">gitTreeState</code><code class="o">:</code> <code class="calibre19">dirty</code>
<code class="lineno">16 </code>  <code class="calibre19">gitVersion</code><code class="o">:</code> <code class="calibre19">v1</code><code class="o">.</code><code class="o">7.0</code>
<code class="lineno">17 </code>  <code class="calibre19">goVersion</code><code class="o">:</code> <code class="calibre19">go1</code><code class="o">.</code><code class="o">8.3</code>
<code class="lineno">18 </code>  <code class="calibre19">major</code><code class="o">:</code> <code class="s">"1"</code>
<code class="lineno">19 </code>  <code class="calibre19">minor</code><code class="o">:</code> <code class="s">"7"</code>
<code class="lineno">20 </code>  <code class="calibre19">platform</code><code class="o">:</code> <code class="calibre19">linux</code><code class="o">/</code><code class="calibre19">amd64</code>
</pre></div>

</figure>

<p class="calibre3">If you focus on the <code class="calibre19">serverVersion</code> section, you’ll notice that the <code class="calibre19">major</code> version is <code class="calibre19">1</code> and the <code class="calibre19">minor</code> is <code class="calibre19">7</code>.</p>

<h3 id="leanpub-auto-what-now-8" class="calibre20">What Now?</h3>

<p class="calibre3">We are finished with a short introduction to Minikube. Actually, this might be called a long introduction as well. We use it to create a single-node Kubernetes cluster, launch the UI, do common VM operations like stop, restart, and delete, and so on. There’s not much more to it. If you are familiar with Vagrant or Docker Machine, the principle is the same, and the commands are very similar.</p>

<p class="calibre3">Before we leave, we’ll destroy the cluster. The next chapter will start fresh. That way, you can execute commands from any chapter at any time.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>minikube delete
</pre></div>

</figure>

<p class="calibre3">That’s it. The cluster is no more.</p>



</div>
</body></html>