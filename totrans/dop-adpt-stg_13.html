<html><head></head><body>
		<div id="_idContainer040">
			<h1 id="_idParaDest-189"><em class="italic"><a id="_idTextAnchor188"/>Chapter 9</em>: Understanding the Technical Stack for DevOps</h1>
			<p>Adding tooling to your DevOps investments is key to making sure your adoption goes from good to great. There are many DevOps tools on the market today. Understanding what toolsets to implement for today and for tomorrow can be challenging. In this chapter, we look at the pros and cons of the main tooling involved in DevOps.</p>
			<p>By the end of this chapter, you can expect to gain an understanding of the different families of DevOps tools as well as understanding how tooling helps in DevOps. You will also understand the benefits and obstacles of DevOps tooling.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>What are the families of DevOps tools?</li>
				<li>How does tooling help the adoption of DevOps?</li>
				<li>Understanding the benefits of DevOps tooling</li>
				<li>Understanding the obstacles of DevOps tooling</li>
			</ul>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor189"/>What are the families of DevOps tools?</h1>
			<p>The <a id="_idIndexMarker466"/>DevOps ecosystem, as we call it, has a number of different categories that tools fall into. Some of these tools are designed, developed, and marketed for incredibly specific reasons. There are industry-specific tools that solve unique problems as well.</p>
			<p>Of course, you also come across tools that, while specific to a category, also apply across many industries, and some tools are suites of tools that provide services right across the ecosystem.</p>
			<p>We can use a traditional diagram that depicts the DevOps loop to talk about the different categories. I like to use the following categories, which closely align to those given in traditional diagrams <a id="_idIndexMarker467"/>but have slight differences:</p>
			<ul>
				<li>Collaborating</li>
				<li>Building</li>
				<li>Testing</li>
				<li>Deploying</li>
				<li>Running</li>
			</ul>
			<p>You can see a visual depiction of this in the following diagram:</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B17192_09_01.jpg" alt="Figure 9.1 – Visual representation of the toolchain phases&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – Visual representation of the toolchain phases</p>
			<p>Let's have a look at these in more detail to understand what types of tools are part of each section of the ecosystem.</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor190"/>Collaborating</h2>
			<p>I have added <a id="_idIndexMarker468"/>collaboration to this list, which is not actually found on most traditional lists, because of the importance that collaboration has in DevOps. So far, we have looked at collaboration from a cultural perspective as well as when it comes to people and processes, but tooling is important to collaboration as well.</p>
			<p>You can have great <a id="_idIndexMarker469"/>processes, people, and culture within your organization around collaboration, but in the end, without the right tools in place, you still won't get very far, and scaling will also be a real issue.</p>
			<p>When you think of collaboration, it's easy to think of the big players such as Zoom, Microsoft Teams, Skype, and others, but the toolset is much broader than that. Collaboration is also about knowledge sharing.</p>
			<p>Tools such as Read the Docs, GitHub Pages, and Apiary are all documentation tools; they are also classed as collaboration tools.</p>
			<p>Knowledge sharing is important in any organization, but in teams where there is a high level of collaboration and a concerted move toward DevOps practices, knowledge is incredibly important. Every bit of knowledge about your product should be noted down and stored centrally so it can be found should anyone need it.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Think of knowledge management as a way to avoid knowledge silos. Without these silos in place, you are able to scale much better and ensure that everyone has an equal opportunity to learn new skills and learn more about the product.</p>
			<p>Knowledge also includes documentation. In my opinion, you cannot consider something to be completed if no documentation exists for it. This documentation may be public-facing or it may be just for internal teams. Either way, it is important.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor191"/>Building</h2>
			<p>Build tools are <a id="_idIndexMarker470"/>what enable you to take what you have developed and turn it into something that you can later deploy somewhere else. This starts with source control tooling. By far the most common such tool <a id="_idIndexMarker471"/>today is <strong class="bold">Git</strong>. It comes in a number of flavors, and one of the most popular is GitHub, although the Git technology is to be found within a number of different source control products.</p>
			<p>Tooling also enables continuous integration. This practice entails taking your artifacts from your source control repository and running them through an automated workflow called a pipeline. During the pipeline, a number of tasks are completed, and the result of that pipeline is a tangible artifact that you can then later deploy.</p>
			<p>Build tools are also not exclusively related to software. You can also build infrastructure with some tools as well. This is known as infrastructure as code. If you are using containers, you will also find tools to help you build them.</p>
			<p>If your application<a id="_idIndexMarker472"/> involves the use of a database, you will also find database tooling available to you to manage your database schema and structure.</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor192"/>Testing</h2>
			<p>Testing is <a id="_idIndexMarker473"/>one of the broadest terms when it comes to DevOps tooling. Here you will find tools to perform testing for a wide range of requirements. The process of testing could be anything from the unit testing of code by developers all the way through to user acceptance testing and tools that automate browser testing for web applications.</p>
			<p>In addition to this, testing can include security scanning your application against baselines from the OWASP Top 10, static and dynamic code analysis for vulnerabilities, and load testing to ensure your application performs well under load.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor193"/>Deploying</h2>
			<p>The act of<a id="_idIndexMarker474"/> deployment is where you can take your built and tested application artifact and deploy it to where it needs to go. This could be to a cloud platform such as Microsoft Azure, Amazon Web Services, or Google Cloud. It could also be a mobile app store or even an on-premises data center.</p>
			<p>If you are deploying to a cloud platform or app store, then you will likely be using native tooling to deploy to those environments. Those tools will probably only perform the deployment to those specific environments for you and nothing else.</p>
			<p>You could also be deploying to a package management repository if you are writing sharable application libraries for other developers to use. You can also get tools that support this scenario.</p>
			<p>If you are working with containers, then you are also likely to be working with artifact management tools; these come under the deployment banner as well. Tools that enable you to point your containers to container registries, either public or private, are accessed at this point.</p>
			<p>Finally, even if you <a id="_idIndexMarker475"/>are provisioning and deploying virtual machines or other types of traditional infrastructure, you may use tools responsible for baseline configuration management or provisioning your infrastructure. These tools can save huge amounts of time when it comes to managing enterprise-scale infrastructure.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor194"/>Running</h2>
			<p>Once you have<a id="_idIndexMarker476"/> deployed your application, you have entered what is known as the run phase. At this point, the operations team uses tooling to manage the application. Developers may also have a number of tools in place here to help with the monitoring of application performance and the capturing of exceptions.</p>
			<p>Some of the tools in the run phase may be natively built into the platform you are using; some may be additional products and tools. For example, you may use the native monitoring capabilities in your cloud platform and then use an application performance monitoring tool to monitor both the infrastructure performance and the application performance.</p>
			<p>From experience, this is one area of tooling that is lacking at many organizations; however, the right run tooling is critical to ensuring that you have the right technical feedback in terms of infrastructure and application performance so that you can make data-based decisions.</p>
			<p>Now that we understand the different families of DevOps tools within the DevOps toolchain, let's now look at how tooling helps with the adoption of DevOps.</p>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor195"/>How does tooling help the adoption of DevOps?</h1>
			<p>DevOps uses its relationship to Agile development and then looks to create a culture that fosters collaboration and value streams. This is achieved by combining trusted principles and practices such as Lean, Theory of Constraints, and the Toyota Production System with Agile development.</p>
			<p>In order to achieve this, DevOps requires an organization to adopt cultural changes within teams and adopt technical principles such as automation, version control, and continuous integration and delivery. In a similar way to the manufacturing industry, the integration of the right tools is fundamental to fully realize the benefits of the technical practices within DevOps.</p>
			<p>A word of caution, though: DevOps is not just about using tools – it's about the combination of everything we have learned so far and interaction with tools that properly realizes the benefits of DevOps.</p>
			<p>Here is a good set of <a id="_idIndexMarker477"/>guidelines that can be used to help pick the right tooling for your organization:</p>
			<ul>
				<li>Choose tools that facilitate collaboration.</li>
				<li>Use tools that enhance communication.</li>
				<li>Lean toward tools with APIs.</li>
				<li>Always encourage learning.</li>
				<li>Avoid environment-specific tools.</li>
			</ul>
			<p>Now let's look at these guidelines in more detail to get a better understanding of how to apply them.</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor196"/>Choosing tools that facilitate collaboration</h2>
			<p>The ability to have effective collaboration between teams is critical for the success of DevOps. With tools specifically aimed at collaboration, it would be easy to think that you should buy a dedicated tool for this, but in the DevOps toolchain, there are lots of different tools you can use to enhance collaboration between teams.</p>
			<p>A good example of this is<a id="_idIndexMarker478"/> version control, which is really a key element of the DevOps approach. As you are trying to encourage more people to make use of version control tools in the organizations, consider the impact of your tool choice. You and trusted members of your foundational team may be comfortable with a command line-only tool, but what about everyone else? Using a command line-only tool can end up as a barrier for some people who are more comfortable using user interfaces.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">In this example, a command-line tool for version control is part of the DevOps toolchain but is unfamiliar to people, especially non-developers.</p>
			<p>In this instance, there is very<a id="_idIndexMarker479"/> little collaboration opportunity given the limited audience of the command-line tool. However, if you adopt a version control platform such as GitLab, GitHub, BitBucket, or Azure DevOps, you can take advantage of discussion around file changes and commits within the code you are committing; this is a form of collaboration.</p>
			<p>This helps collaboration with people who have different skills and encourages more people to learn how to use the platform for their own needs, thus helping to encourage collaboration.</p>
			<p>The approach we discussed here works in other parts of the toolchain as well, not just for version control. It doesn't have to just impact a new tool either; this could be on existing tools within your organization.</p>
			<p>Consider the impact of permissions on collaboration. A number of times, I have worked with operations teams who refuse to give developers access to what they believe is their tooling, thinking that nobody else should have access. If you want to improve collaboration, open that tool up to the developers – the result is better collaboration between the two teams. The tool has not changed, but the permissions have.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor197"/>Using tools that enhance communication</h2>
			<p>In my experience, one of the biggest problems and certainly the most common problem among organizations building modern software platforms using a DevOps approach is the mismatch that exists between the responsibilities of teams and their tools.</p>
			<p>Sometimes, organizations have multiple tools to achieve something when one tool would do the job. The reverse is also true: sometimes organizations have one single tool that causes problems when teams need separate tools.</p>
			<p>One of the biggest impacts on the interaction between teams and the effectiveness of their communication is around the use of shared tools. Shared tools make sense to enable collaboration between teams, but if you need boundaries of responsibility to be clear, then using separate tools may be the best way to go. We discussed business benefits, team topologies, and the pitfalls of DevOps in <a href="B17192_02_Final_ASB_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Business Benefits, Team Topologies, and Pitfalls of DevOps</em>. Use this to understand which model is right for your organization.</p>
			<p>If you are working toward a close working relationship between your development and operations teams, then a separate ticketing system will only result in poor communication between those teams. In order to help these teams be effective, you should choose a tool that <a id="_idIndexMarker480"/>meets the needs of both teams.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">When considering tools, don't pick a tool for the whole organization before you have considered the team relationships first.</p>
			<p>The key is to make sure you look at the whole organization, deploy tools that are shared for collaborative teams, and where you need to, don't be afraid to use separate tools.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor198"/>Lean toward tools with APIs</h2>
			<p>Service-based architectures and API-driven applications are the cornerstones of cloud-native or cloud-ready systems. Tools that give you the ability to be customizable and highly automated are a major plus. Having tools that have full-featured APIs, and HTTP-based ones at that, are a must.</p>
			<p>The use of APIs from a DevOps perspective allows you to take the many different tools you are using and connect them together as part of your processes. Tools that match these criteria are important, as when you come to change your existing tooling for something new, it is easy to change the plumbing that sticks everything together.</p>
			<p>It is really easy to chain together tools using this method, but you need to be careful about scripts that are undocumented in this process. Tools that power the software delivery and operations processes should be treated like production tools. This means having the ability to properly document and release these tools.</p>
			<p>Many organizations at the lower end of the maturity scale make the mistake of implementing new tools without the operational support needed to make those tools work well and be effective.</p>
			<p>In summary, you should be aiming to gain new capabilities by combining multiple API-driven tools.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor199"/>Always encouraging learning</h2>
			<p>When you look at the<a id="_idIndexMarker481"/> tools in the DevOps toolchain, quite a few of them are rather involved and can be very complicated, especially when people are new to the tooling. When tools are complex, you shouldn't expect everyone to adopt them quickly.</p>
			<p>The opposite can also happen, in that when a tool is complicated and difficult to use, people may dig in their heels and not use it. This is why you have to think about providing training opportunities for people with new tools.</p>
			<p>The introduction of a new tool requires you to assess the wider skills within your organization and then build a roadmap for the teams to move to improved ways of working. Giving people the opportunity to learn at their own pace is crucial, so looking at tools with multiple interfaces, such as a user interface, command line, and API, gives everyone the ability to learn.</p>
			<p>The process of adopting DevOps is one of moving from manual to automated; not everyone will be in the same place at the same time, so giving people the ability and especially the space to learn gives you the best chance of people successfully adopting new tools and approaches.</p>
			<p>Think of this as a step evolution: avoid fear by introducing tools that are scary and give people the option to learn at their own pace. Just like Agile teaches incremental improvement through sprints, treat your tooling the same and prefer those small gains over future state and a big bang approach.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor200"/>Avoiding environment-specific tools</h2>
			<p>With the adoption of DevOps comes an increase in speed and frequency of delivery. This means that to be successful, you need to increase the feedback loops within your delivery and operations processes. As many technology-focused people as possible should be learning as much as they can about how production works so that, in turn, they can build more reliable products that are more resilient. Changes to the system should also be tested before any deployment to production.</p>
			<p>Any tools that are only running in production cause problems because this prevents people from learning, as production is treated as a special case rather than just another environment your application runs in.</p>
			<p>To be as effective as possible, you should choose tools that work in all environments; this even includes the developer's local environment in some cases. Watch out for tools that charge per environment to deploy or install and try to look for tools that provide site-wide license approaches to keep costs down if at all possible.</p>
			<p>Think about the automation approach of DevOps as well; good DevOps tools should be able to be set up automatically in each environment. Stay away from tools that require manual effort to deploy – these tools are not good choices in DevOps.</p>
			<p>When you run the same <a id="_idIndexMarker482"/>tool throughout each environment, you are increasing the level of engagement between your teams and increasing learning opportunities. Keeping a tool to production only locks people out of learning opportunities.</p>
			<p>In summary, when it comes to environment-specific tools, avoid them at all costs. This breaks the feedback loop around learning, as well as making your continuous integration and delivery difficult.</p>
			<p>Now we understand how tooling helps your adoption of DevOps, let's look at the benefits of DevOps tooling.</p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor201"/>Understanding the benefits of DevOps tooling</h1>
			<p>According to the <em class="italic">State of DevOps report (2017)</em> by Puppet (<a href="https://puppet.com/blog/2017-state-devops-report-here">https://puppet.com/blog/2017-state-devops-report-here</a>), <em class="italic">"the ability to develop and deliver software efficiently and accurately is a key differentiator and value driver for all organizations."</em> While the report may be a few years old now, the content is still right on point when we talk about why we do DevOps.</p>
			<p>The report finds that <a id="_idIndexMarker483"/>DevOps organizations are more than twice as likely to overachieve when it comes to efficiency, satisfaction, quality, and the fulfillment of organizational goals. Those objectives give a great insight into successful DevOps organizations. But how do they do it?</p>
			<p>Using those key points as a benchmark, integrating the right tools to successfully apply DevOps technical practices will enable you to realize the following benefits:</p>
			<ul>
				<li>Increased code and deployment velocity</li>
				<li>Reduction of time to market for new products and features</li>
				<li>Decrease in the failure rate of new releases</li>
				<li>Improve the mean time to recovery</li>
				<li>Improvement in reliability metrics</li>
				<li>Enhanced collaboration and productivity</li>
				<li>Eliminating high levels of work in progress and technical debt</li>
			</ul>
			<p>We have already <a id="_idIndexMarker484"/>explored the benefits of enhanced collaboration and productivity through some of the examples earlier in the chapter; one common theme between all of these benefits is around collaboration and communication, but let's now take a look at these benefits in more detail using tooling as examples.</p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor202"/>Increasing code and deployment velocity</h2>
			<p>It's really not possible to accurately measure velocity around deployments and code without having tooling in place. A combination of information from your version control software, your backlog management tooling, and your pipeline environment will be needed to gain insights into this information.</p>
			<p>Having this tooling in place and having the ability to accurately report on velocity is important: it helps you plan better as a team as well as understanding your limitations in terms of how much work you can complete in a single sprint.</p>
			<p>Understanding this in the long term also helps you make decisions about when to hire more team members, especially when you combine this information with your technical debt and work in progress.</p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor203"/>Reduction of time to market for new products and features</h2>
			<p>Communication and collaboration are really at the center of this one, especially at the start of this process. When you have good tools that foster good collaboration between teams, as well as good communication, you have the ability to take your ideas from inception to production quicker.</p>
			<p>Add into that tooling <a id="_idIndexMarker485"/>around continuous integration and deployment, and all of a sudden, once your idea has been developed and tested, it can be deployed in no time at all, going through the various testing cycles.</p>
			<p>This alone is a huge business driver for many organizations, especially those in the business of software. If you are able to take your ideas to market quicker than your competitors, this gives you a competitive edge over them, ultimately giving your customers more reasons to use your product over theirs.</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor204"/>Decrease in the failure rate of new releases</h2>
			<p>When you have invested in your pipelines to a point where they handle your deployments consistently, that brings into focus the need for a feedback loop. That loop, in this instance, is around improving the quality of the build and release pipelines.</p>
			<p>By introducing the monitoring of your pipelines and using the built-in reporting that is in many existing CI and <a id="_idIndexMarker486"/>CD tools, you are able to pull metrics that show the success of your pipeline executions.</p>
			<p>When a failure occurs, see this as a learning opportunity, pull information as to why it happened, and find out what you can do to improve quality so it does not happen again. This cycle, with the information you are gathering, goes to decrease the failure rate of your releases and helps you develop higher-quality pipelines.</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor205"/>Improving the mean time to resolution</h2>
			<p>Nobody likes downtime in their application, no matter how well the infrastructure is designed or how well the application is developed. You are likely to experience downtime at some point.</p>
			<p>Monolithic environments or legacy working environments have traditionally had a harsh view on application <a id="_idIndexMarker487"/>downtime and the impact of that downtime. Today, instead of measuring <strong class="bold">Service Level Agreements (SLAs)</strong>, many organizations who practice DevOps are now turning to the measurement of <strong class="bold">mean time to resolution (MTTR)</strong>, which <a id="_idIndexMarker488"/>measures the mean average time to recover a service from a failure.</p>
			<p>Site reliability tooling is critical in this space to enable you to gain as much information as possible about the outage. This includes 360-degree monitoring of your infrastructure and application, including performance and exceptions; user journeys; and synthetic transactions monitoring every aspect of the application's performance, availability, and security.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">You should also not underestimate the importance of log files, which are often overlooked.</p>
			<p>Log files add another dimension to your troubleshooting capabilities as well. So often, I have seen developers and operations teams scratching their heads because they don't have the appropriate logs available to diagnose an application outage.</p>
			<p>When you have all this information at your disposal, as well as good communication, collaboration, and documentation, you stand a better chance of getting to the bottom of the issue as quickly as possible.</p>
			<p>Measuring the endpoint <a id="_idIndexMarker489"/>availability of your application also gives you the ability to measure MTTR. You can measure the time between outage and the resumption of service. After each outage, it is important to sit back and review the information collected and look not only at how to avoid the outage again but also how to make process changes or changes anywhere else to reduce the amount of time needed to restore service next time.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor206"/>Improvement in reliability metrics</h2>
			<p>Right off the back of MTTR is the improvement of reliability metrics. Using many of the same principles we discussed previously, you can also improve the reliability of all facets of your application.</p>
			<p>The majority of site reliability and instrumentation tools will be able to feed into producing a dashboard or scorecard that gives you a picture of your reliability. As discussed previously, using this data to actually go forward and improve reliability is what sets organizations apart in levels of maturity.</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor207"/>Eliminating high levels of work in progress and technical debt</h2>
			<p>One of the biggest killers of productivity in a DevOps environment is the amount of work in progress and high levels of <strong class="bold">technical debt</strong> that exist at some organizations. All backlog management tools that I have worked with give you the ability to flag up via a dashboard or on a Kanban board, for example, the amount of work in progress for each team member.</p>
			<p>Make sure the level of work here is acceptable. What is acceptable, of course, differs per team in general and of<a id="_idIndexMarker490"/> course per individual, their skills, and the work they are capable of completing.</p>
			<p>Striking a balance can be difficult, but when people have too many "work in progress" items, it kills productivity. My experience tells me that each individual stays highly productive when they have no more than three active work in progress items. After this point, their productivity will start to take a tumble.</p>
			<p>Another killer of productivity is the levels of technical debt in the organization. Technical debt, sometimes known as design debt, reflects the cost of additional rework in your application.</p>
			<p>For example, if you designed a part of your application using an easy method today, instead of using a better approach that would take longer, that is technical debt. We usually then add technical debt to the backlog to revisit at a later date and resolve.</p>
			<p>In order to understand your<a id="_idIndexMarker491"/> levels of technical debt, you need a reliable way of recording it. In some tools, you could create a specific backlog template to record it, or simply add a tag to a user story or bug – you decide how to record it.</p>
			<p>You can then run queries and add data to dashboards to highlight your technical debt. When it gets to levels that you deem unacceptable, you can run a technical debt sprint aimed at reducing the amount of technical debt.</p>
			<p>We have spent this section looking at the benefits of tooling in the DevOps toolchain and seeing how different tools add benefit to our DevOps value. Next, let's look at the obstacles that exist when it comes to onboarding successful tooling.</p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor208"/>Understanding the obstacles of DevOps tooling</h1>
			<p>So far, we have covered all the<a id="_idIndexMarker492"/> positives about tooling in the DevOps toolchain. What about some of the obstacles that come from working with so many different tools? Here are a few things that are obstacles to the adoption of these tools:</p>
			<ul>
				<li>Lack of definition of DevOps</li>
				<li>Shortage of knowledge on tooling</li>
				<li>Evaluation of tools</li>
				<li>The volume of tools available on the market</li>
				<li>Lack of tool integration</li>
			</ul>
			<p>Let's now look at these points in more detail to better understand the obstacles to adopting tools.</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor209"/>Lack of definition of DevOps outcomes</h2>
			<p>It goes without<a id="_idIndexMarker493"/> saying that without a properly defined definition of what DevOps is and what it means to your organization, you are going to struggle with tooling. This leads to organizations deploying tooling because their competitors are deploying tools or for other primitive reasons.</p>
			<p>Having that definition also helps you understand what the tooling roadmap might look like and how you can properly address the gaps that exist with the right tools, using all the pointers we have discussed in this chapter.</p>
			<p>Not only does your organization need a definition of DevOps, but it also needs to be standard across your whole organization. Everyone from top to bottom needs to buy into this in order for every part of your DevOps adoption to be successful; this includes tooling.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor210"/>Inadequate knowledge of tooling</h2>
			<p>Having a shortage of knowledge on the different tooling available can also be a barrier to success. This issue can manifest in a few ways; however, some of them are more damaging to overall progress than others.</p>
			<p>Firstly, a lack of knowledge can hamper your efforts to pick the right tool for the task. While nobody will ever be an expert in the whole toolchain, or even in one specific area, having broad knowledge will help you make an evaluation in line with the information you are able to gather from the vendor.</p>
			<p>Secondly, the lack of knowledge can leave you in limbo – without that broad knowledge of the tooling, you may find yourself in a position where you don't understand how the tools are addressing your specific needs. This delay can hurt your implementation.</p>
			<p>Thirdly, and finally, when you have a lack of tooling knowledge, the worst it can do is paralyze your decision making. Rather than making the wrong decision, as in point one, or lacking understanding, as in point two, this is more about misunderstanding what the tool is there to achieve.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor211"/>Evaluation of tools</h2>
			<p>As with any purchase of software from any vendor, your organization is going to want to make sure you get the most from any demonstration or trial offers. This is a big investment, and you want to make sure you are picking a tool that checks the right boxes and delivers what you need.</p>
			<p>Take into account the<a id="_idIndexMarker494"/> cost of a tool against the value it provides. You must make sure that the return on investment for the purchase is in line with expectations.</p>
			<p>If you are evaluating multiple tools, make sure the evaluation of them is equal. There is no point performing different evaluations on tools that do the same thing. Not only does this not give each of your candidates the opportunity to shine, but it ensures that no bias is involved in the decision-making process.</p>
			<p>Everyone has an affinity with different technology stacks and tools, but you need to make sure you pick the right tool for the organization, not use what you have used in the past just because you know the tool.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor212"/>The volume of tools available on the market</h2>
			<p>Of course, before you even get to the evaluation of tools, you have to tread your way through the vast ocean of tools that exist in the various categories of the DevOps toolchain.</p>
			<p>The number of tools is so vast that the <strong class="bold">Cloud Native Computing Foundation (CNCF)</strong> has even <a id="_idIndexMarker495"/>created a web tool detailing the tools within their area and provides a number of filters for you to limit your searches. This is<a id="_idIndexMarker496"/> the <em class="italic">CNCF Cloud Native Landscape</em> (<a href="https://landscape.cncf.io">https://landscape.cncf.io</a>). Don't be mistaken: this is incredibly useful, but it also highlights the issues we face when selecting tools.</p>
			<p>To add to the list of tools charted by the CNCF, there are of course other tools as well that are not within the CNCF ecosystem. This expansive list of tools adds to the paralysis you can feel when looking at the tooling options available.</p>
			<p>You can get through the <a id="_idIndexMarker497"/>marketing offered by the vendors by looking at independent sources of information on the tools. Go to community posts by people who use the products, look at their use cases, and use this information to help you shortlist tools.</p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor213"/>Lack of tool integration</h2>
			<p>Earlier in the chapter, we talked about the importance of integration within DevOps tooling. Working with a tool that lacks sufficient integration limits your capability, depending on that limitation depends on the impact it has.</p>
			<p>For example, continuous integration and deployment tooling without sufficient integration is going<a id="_idIndexMarker498"/> to be a problem if the platform doesn't provide a wide array of other services with it. When looking at these tools, we should look for integration opportunities with backlog management tools, our deployment platform, and our ticketing system if that is a requirement.</p>
			<p>We also must consider integration with tools providing security services for them to be valuable to our overall ambitions.</p>
			<p>That lack of integration creates a black box for your tooling, where you are unable to interface with it or retrieve what might be valuable data from it.</p>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor214"/>Summary</h1>
			<p>In this chapter, we have looked at tooling within the DevOps toolchain. We have looked at the different families of DevOps tooling and looked at how tooling helps the adoption of DevOps in your organization. We then looked at the benefits of DevOps tooling and looked to understand the obstacles that may prevent the adoption of good-quality tools.</p>
			<p>Next, we will look at how to develop a strategy for the implementation of tooling. We will look at the architectural and security requirements for your tooling and how to develop training plans to help the team, and tie this in with defining owners and processes for DevOps tools.</p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor215"/>Questions</h1>
			<p>Let's now recap some of what we have learned throughout this chapter:</p>
			<ol>
				<li>Which tools have an impact across the whole DevOps toolchain?<p>a. Build tools</p><p>b. Testing tools</p><p>c. Collaboration tools</p><p>d. Run tools</p></li>
				<li>Why are APIs so important when adopting tooling?<p>a. They're not – we don't need APIs.</p><p>b. They provide automation and integration opportunities.</p><p>c. DevOps engineers need to learn about APIs.</p><p>d. All good tools come with APIs anyway.</p></li>
			</ol>
		</div>
	</body></html>