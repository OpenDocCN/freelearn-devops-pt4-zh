- en: 6\. Open Technical Practices – Beginnings, Starting Right
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 开放技术实践——开始，正确起步
- en: So far, we have talked about the foundational culture and collaboration practices
    that support our discovery, options, and delivery Mobius loop. The next two chapters
    establish the technical practices that teams should implement to make the foundation
    even stronger.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了支持我们发现、选项和交付莫比乌斯环的基础文化和协作实践。接下来的两章将建立团队应实施的技术实践，以使基础更加牢固。
- en: Think of the Mobius loop as an engine turning from discovery through options
    generation and into delivery. This cycle continues by doing more delivery until
    we need to revisit the outcomes we've targeted. Delivery is where we take the
    concept and make it real. As we deliver, we will learn a lot and garner feedback
    from our stakeholders and our team. At some point in time, we will need to revisit
    the discovery side of the loop, either to adjust what we know or to realign what
    we deliver next.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 把莫比乌斯环想象成一个从发现到选项生成再到交付的引擎。这个循环通过更多的交付不断进行，直到我们需要重新审视我们所设定的结果。交付是我们将概念变为现实的过程。在交付的过程中，我们会学到很多，并从利益相关者和团队中获得反馈。某个时刻，我们将需要重新审视循环中的发现环节，调整我们所知道的内容或重新对齐我们接下来要交付的内容。
- en: '![](img/B16297_06_01.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_01.jpg)'
- en: 'Figure 6.1: The Mobius loop'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：莫比乌斯环
- en: Imagine we've done one iteration and built some new features for our product,
    such as a leaderboard for our PetBattle app – it's very likely we'd be OK to demo
    and release that functionality without investing time or effort in building out
    a solid technical foundation. But as our iterations continue and the application's
    complexity grows, we may find ourselves beginning to drown in manual testing or
    technical debt. As we hit iteration five or six, things that were working will
    most likely start to break and our ability to predict how much we can do will
    start to fall apart. This could demotivate the team and have people lose confidence
    in our product or ability to execute. Breaking trust at this stage is a difficult
    thing to come back from.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经完成了一次迭代并为我们的产品构建了一些新功能，比如我们为PetBattle应用程序增加了一个排行榜——很可能我们会觉得可以展示并发布这个功能，而不需要投入时间和精力来建立一个扎实的技术基础。但是随着迭代的继续，应用的复杂性增加，我们可能会发现自己开始淹没在手动测试或技术债务中。当我们进行到第五或第六次迭代时，以前有效的做法很可能会开始崩溃，我们预测能做多少事的能力也会开始瓦解。这可能会让团队失去动力，并让人们对我们的产品或执行能力失去信心。在这个阶段失去信任是很难恢复的。
- en: To successfully build software incrementally, we need to ensure we can operate
    smoothly and sustainably. Constant rewrites and fixes will hinder this.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功地逐步构建软件，我们需要确保能够顺利且可持续地运作。不断的重写和修复将阻碍这一过程。
- en: For these reasons, it's important we support our delivery capability with a
    set of foundational technical practices, much like we did with the collaboration
    and culture. Practices such as **configuration-as-code**, **infrastructure-as-code**,
    and even **everything-as-code** can help ensure a team's work is repeatable. Identifying
    how a team will do testing and automating that testing can lead to higher-quality
    output and simplify defect management. Picking the right development workflow
    and tools will accelerate the team's ability to deliver the software and not spend
    all their time managing their tools instead.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这些原因，我们必须通过一套基础技术实践来支持我们的交付能力，就像我们在协作和文化方面所做的那样。**配置即代码**、**基础设施即代码**，甚至**一切皆代码**等实践可以帮助确保团队的工作具有可重复性。确定团队如何进行测试并自动化测试，可以提高输出质量并简化缺陷管理。选择合适的开发工作流和工具将加快团队交付软件的能力，而不是把所有时间都花在管理工具上。
- en: Adding practices to the foundation is not a one-time activity. As the applications
    grow in number and complexity, it's important to bolster the foundation with new
    and more comprehensive use of practices.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 向基础中添加实践并不是一次性的活动。随着应用程序数量和复杂性的增加，重要的是通过新方法和更全面的实践来加强基础。
- en: In the next two chapters, we will share the technical practices implemented
    on the foundational level that have enabled us to achieve the best success. They
    are part of the foundation because they are not time-boxed practices; rather,
    they are continually carried out as part of our daily work. Later in the book,
    we'll explore how bolstering these practices with great use of the platform can
    enable sustainability and scalability of continuous delivery.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，我们将分享在基础层面实施的技术实践，这些实践帮助我们取得了最佳的成功。它们构成了基础的一部分，因为它们不是时间限制的实践；相反，它们是我们日常工作的一部分，不断进行。书中的后续部分，我们将探讨如何通过充分利用平台来加强这些实践，从而实现持续交付的可持续性和可扩展性。
- en: 'In this chapter, we want to start off right by covering the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们希望通过涵盖以下内容来正确开始：
- en: Green from go!
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Green from Go!**'
- en: Pairing and mobbing
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配对编程与集体编程
- en: The container-native approach
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器原生方法
- en: 'Pipelines: CI-CD²'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道：CI-CD²
- en: Everything as code
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一切皆代码
- en: Developer workflows
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者工作流
- en: Green from Go!
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**Green from Go!**'
- en: '**Green from go!** really just means setting yourself up the correct way when
    kicking off a new piece of work. For us, that means having all our foundational
    pieces of software up and running before writing any application software. It
    is another mantra of ours. Much like **show, not tell**, this one is all about
    getting things working with a light touch into a usable state.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**Green from Go!** 实际上意味着在开始新的工作时，以正确的方式为自己铺路。对我们来说，这意味着在编写任何应用程序软件之前，先确保所有基础软件组件都已启动并运行。这是我们另一个座右铭。就像**展示，而非讲述**一样，这个理念的核心是通过轻松的方式使事物达到可用状态并开始运作。'
- en: For example, take choosing the tool we want to use to automate the building
    of our code, such as Jenkins or Tekton, or choosing how we manage secrets or access
    to private information. The ambition with **green from go!** should be obvious
    – clear the pathway to empower developers to get on and do what they do best –
    writing amazing, high-quality software that delights end users.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，选择我们想要用来自动化构建代码的工具，如 Jenkins 或 Tekton，或者选择如何管理机密或访问私密信息。**Green from Go!**
    的目标应该很明确——清除障碍，赋能开发人员，让他们专注于做他们最擅长的事情——编写出令人惊叹的高质量软件，给最终用户带来愉悦的体验。
- en: When we engage in any new piece of software delivery, we always ensure the tools
    we need to do our jobs are in place. We will have picked a few that will help
    us automate taking our code, compiling it, and delivering it to an environment
    where it can be tested. This means all the tools need to be re-creatable from
    scripts or another mechanism so we can easily kick-start any engagement to the
    same level with consistency and the learning from each run can be brought to the
    next one.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始任何新的软件交付任务时，我们总是确保完成工作的工具已经到位。我们会选择一些工具，帮助我们自动化代码的提取、编译，并将其交付到可以进行测试的环境中。这意味着所有工具都需要能够通过脚本或其他机制重新创建，这样我们可以轻松启动每次工作，并保持一致性，同时将每次运行的学习成果带入下一个任务。
- en: Green from go! will also include any reference apps or pipelines using the tools.
    This could be a simple AngularJS application scaffold with an end-to-end build
    process running against it, proving that we can take code and deliver it to users.
    The level of complexity of this process should be low enough to allow the teams
    to evolve it to their specific needs. For example, a team might want to do more
    non-functional testing in their pipeline, or perhaps another team wants to try
    out a new cool testing framework. The priority here is to have enough of a foundation
    to not slow the team down in doing these repeatable tasks when kicking off new
    work but to get them focused on writing new functionality.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**Green from Go!** 还将包括使用这些工具的任何参考应用程序或管道。这可能是一个简单的 AngularJS 应用程序框架，配有完整的构建过程，确保我们能够将代码交付给用户。这个过程的复杂性应足够低，以便团队根据特定需求进行演化。例如，一个团队可能希望在其管道中进行更多的非功能性测试，或者另一个团队可能想尝试一个新的酷炫测试框架。这里的优先级是，确保有足够的基础，以便在启动新工作时不会拖慢团队执行这些可重复任务的速度，而是让他们专注于编写新功能。'
- en: It's also important to not have too much in the kit bag – it is our experience
    that when bringing new teams on board using an accelerator, the technical burden
    it can have can cause some team members to not engage with it. In order for teams
    to take ownership and maintain something that accelerates their delivery, they
    often need to feel like they helped to build it. If something is too complex to
    engage with, it becomes "that thing that Brian knows all about, so I don't need
    to know it." This kind of behavior is dangerous in a team as it can lead to silos
    and gaps in the team's collective ownership and responsibility. Often, when the
    build system then fails or breaks in some way, that person becomes the single
    point of failure when trying to recover it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是不要让工具包过于复杂——我们的经验是，当引入新团队使用加速器时，它可能带来的技术负担会导致一些团队成员不愿参与其中。为了让团队真正拥有并维护一个加速他们交付的工具，他们通常需要感觉到自己参与了构建过程。如果某样东西过于复杂，无法投入使用，它就变成了“布莱恩非常了解的东西，所以我不需要了解”。这种行为在团队中是危险的，因为它可能导致孤岛效应，破坏团队的集体所有权和责任。当构建系统出现故障或破裂时，那个了解这一切的人就会成为单点故障，恢复过程中的瓶颈。
- en: In the next section, let's look at two practices that help build collective
    ownership and understanding.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨两种有助于建立集体所有权和理解的实践。
- en: Pair Programming and Mob Programming
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配对编程与集体编程
- en: Pair programming and mob programming help us deal with a phenomenon that people
    term **Unicorn Developers**. It has various names across different regions and
    companies, such as **the Hero Developer** or **the Rockstar Developer**. But we
    all can identify who they are when we see them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 配对编程和集体编程帮助我们应对人们所称的**独角兽开发者**现象。这个现象在不同地区和公司有不同的名字，例如**英雄开发者**或**明星开发者**。但当我们看到他们时，我们都能认出他们。
- en: For those who don't know; the Unicorn Developer is the one who has all the knowledge
    and keeps it to themselves. They're the person who writes the most magnificent
    code, and the code that is usually the least understood. They have all the keys
    and secrets in their head, including all the ideas and knowledge. They are often
    the one producing so much new work that they don't have time to document it, meaning
    no one else can continue on the work in their absence. At this point, you can
    probably identify if your team has a Unicorn; it may even be you!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不太了解的人来说；独角兽开发者是那种掌握所有知识却将其保留给自己的人。他们是写出最华丽代码的人，而这些代码通常是最难理解的。他们的脑袋里充满了所有的钥匙和秘密，包括所有的想法和知识。他们往往是产出大量新工作的那个人，以至于没有时间进行文档记录，这意味着当他们不在时，其他人无法继续工作。此时，你可能已经能够识别出你的团队是否有一个独角兽开发者；甚至这可能是你自己！
- en: '![](img/B16297_06_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_02.jpg)'
- en: 'Figure 6.2: The Unicorn'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：独角兽
- en: So why do we have a problem with the Unicorn?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们会有独角兽的问题呢？
- en: The Unicorn is a bottleneck and an icon of failed projects. They are the single
    point of failure in the system. When the Unicorn goes on holiday, projects grind
    to a halt. When things go wrong, the Unicorn has to step in to fix things, meaning
    new work cannot be completed while they are preoccupied.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 独角兽开发者是瓶颈，是失败项目的象征。他们是系统中的单点故障。当独角兽休假时，项目就会停滞不前。当出现问题时，独角兽必须介入解决问题，这意味着在他们忙于解决问题时，新的工作无法完成。
- en: 'Organizations want to create high-performing teams around their products –
    they want entire teams of **Rockstars**. A great philosophy in achieving this
    is to "mob to learn, pair to build":'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 组织希望围绕其产品创建高效能的团队——他们希望拥有一整支**明星团队**。实现这一目标的一个重要理念是“集体学习，配对构建”：
- en: Pair programming involves two engineers working together with one computer on
    one problem at a time.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配对编程是指两名工程师共同使用一台计算机来解决一个问题。
- en: Mob programming[1](#footnote-023) involves an entire team working together with
    one machine to solve one problem.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集体编程[1](#footnote-023)是指整个团队共同使用一台机器来解决一个问题。
- en: Pairs and mobs of engineers allow for more knowledge transfer and create a shared
    understanding of the problem and the journey to get to the solution.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 成对编程和集体编程能够促进更多的知识传递，并且帮助大家共同理解问题和解决方案的过程。
- en: Mob to Learn, Pair to Build
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集体学习，配对构建
- en: To understand why pairing is different, let's use an analogy. Imagine you're
    a carpenter and you look at a magnificent rocking chair. What do you learn from
    seeing the completed piece? Probably not a lot; you might see how one or two pieces
    connect, but not all of them. Now imagine you worked with the carpenter assembling
    and crafting the pieces. You'd get to experience the hidden parts, the joinery
    that was used, how it was created, and how it's all connected. You'd identify
    the problems faced while fitting the parts together and understand why they're
    assembled in a given order. You could take a step back and review the furniture
    as it's being built, giving you a better perspective on the creation process.
    The same applies when writing and engineering software. Pairing makes better programmers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解配对编程的不同，我们可以用一个类比。假设你是一个木匠，你看到了一把精美的摇椅。你从看到这件完成的作品中学到了什么？可能不多；你也许会看到一两个部件如何连接，但不会了解所有的连接方式。现在想象你和木匠一起组装和制作这些部件。你会体验到隐藏的部分、使用的榫接技术、是如何制作的以及它们如何连接的。你会发现拼接部件时遇到的问题，并理解它们为什么按照特定的顺序组装。当你在建造的过程中能退一步审视这件家具时，你能更好地理解整个创作过程。同样的道理适用于软件的编写和工程设计。配对编程能培养更好的程序员。
- en: 'I can hear the skeptics out there thinking to themselves, hmmm sounds like
    two developers doing one person''s job. Doesn''t sound very cost effective to
    me…. Well, there are a number of interesting advantages to pair programming and
    mobbing:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以听到那些怀疑论者在心里想，嗯，这听起来像是两个开发者做一个人的工作。对我来说，这并不具有成本效益……嗯，配对编程和集体编程有很多有趣的优势：
- en: '**Mentoring of team members**: New team members can be brought up to speed
    quickly when they work alongside others, tackling the same problem as someone
    who knows the code better. Sharing tips and tricks or shortcuts can widen both
    pairs'' skill depth. This sharing can also bring junior associates up to speed
    very rapidly.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队成员的指导**：当新成员与其他人一起工作，解决与熟悉代码的人共同面对的问题时，可以很快跟上进度。分享技巧、窍门或快捷方式可以增加配对成员的技能深度。这种分享也能帮助初级开发者迅速提升。'
- en: '**Half the code**: When you ask an organization to spend two developers on
    one problem, the usual math kicks in of "won''t that mean half the code gets written?
    In truth, hopefully even less code gets written! Two minds working on the same
    problem makes for more efficiently written code, so less spaghetti.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码量减半**：当你要求一个组织让两个开发者共同解决一个问题时，通常的思维方式是“那是不是意味着只有一半的代码能写出来？”实际上，理想情况下，写出的代码甚至会更少！两个大脑共同解决同一个问题能写出更高效的代码，因此避免了过度复杂的代码。'
- en: '**No pull requests**: Pairing means you have to share your thought process
    with your pair. This synchronization means code is being reviewed as it''s written.
    Often, people reviewing pull requests are too busy writing their own code and
    they can only give very superficial reviews. When you pair, you review as you
    go and therefore write leaner, better-understood code. You won''t cut corners
    when pairing as someone is watching.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有拉取请求**：配对编程意味着你必须与配对者分享你的思考过程。这种同步意味着代码在编写时就会被审查。通常，审查拉取请求的人太忙于编写自己的代码，他们只能给出非常表面的审查。当你进行配对编程时，你会在过程中进行审查，因此写出的代码更简洁、理解更深刻。配对编程时，你不会偷工减料，因为有人在看着你。'
- en: '**Team bonding**: Humans are social creatures; we share and interact all the
    time. Pairing and mobbing facilitates this interaction. Instead of sitting in
    a room with headphones in, ignoring the world around you, developers in pairs
    look happier. A room with mobbing and pairing going on is louder. Happy coders
    lead to better code.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队凝聚力**：人类是社会性动物，我们总是进行交流和互动。配对编程和集体编程促进了这种互动。与其一个人戴着耳机坐在房间里忽视周围的世界，配对编程的开发者看起来更开心。进行配对和集体编程的房间会更热闹。快乐的程序员能写出更好的代码。'
- en: '**The knowledge stays in the team**: With more than one mind solving the same
    problem, the understanding and logic stays with them. As pairs naturally shuffle
    from task to task, the depth of knowledge stays with the team and not with an
    individual. This means when holidays or even flu season take over, the team can
    still continue to work at pace knowing the Unicorn is not leaving with key information.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**知识留在团队中**：通过多个人共同解决同一个问题，理解和逻辑将会留在团队中。当配对成员自然地从任务到任务转换时，知识的深度将留在团队，而不是某个个体身上。这意味着，当假期或流感季节来临时，团队仍然可以保持工作进度，因为团队不会因为某个“独角兽”离开而失去关键信息。'
- en: '[1](#footnote-023-backlink) A relatively new practice championed by Woody Zuill
    – [https://woodyzuill.com/](https://woodyzuill.com/)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](#footnote-023-backlink) 由Woody Zuill倡导的一种相对较新的实践 – [https://woodyzuill.com/](https://woodyzuill.com/)'
- en: '![](img/B16297_06_03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_03.jpg)'
- en: 'Figure 6.3: Mob programming in action'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3：集体编程实践
- en: When tackling new problems (whether that's a new framework, a new language,
    or even a particularly hard problem), we will all group together. Huddled around
    one computer with a very large screen, we can explore the problem we're trying
    to solve. We mob around the problem until the cross-functional team is satisfied
    that they have enough knowledge or a rough scaffold of how to complete their tasks.
    The team then breaks away into groups of two to pull items from the backlog and
    begin implementation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决新问题时（无论是新的框架、新的语言，还是特别难的问题），我们都会聚集在一起。大家围坐在一台大屏幕电脑前，探索我们要解决的问题。我们围绕问题进行集体协作，直到跨职能团队确认他们已经掌握了足够的知识或拥有了解决问题的大致框架。然后，团队会拆分成小组，每组两人，从待办事项中提取任务并开始实施。
- en: '![](img/B16297_06_04.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_04.jpg)'
- en: 'Figure 6.4: Pair programming in action'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4：配对编程实践
- en: Mobbing and pairing allows teams to cross-skill. Sharing experience and expertise
    leads to better teams. Well-oiled teams working like this can continue to build
    their product sustainably and at pace, driving toward outcomes, not outputs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 集体编程和配对编程使团队能够跨领域学习。经验和专业知识的共享能促进更好的团队合作。像这样高效运作的团队可以持续并迅速地推动产品建设，专注于成果而非单纯的输出。
- en: You can learn more and collaborate about these practices by going to the Open
    Practice Library site at [https://openpracticelibrary.com/practice/pair-programming/](https://openpracticelibrary.com/practice/pair-programming/)
    and [https://openpracticelibrary.com/practice/mob-programming/](https://openpracticelibrary.com/practice/mob-programming/).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问 Open Practice Library 网站上的[https://openpracticelibrary.com/practice/pair-programming/](https://openpracticelibrary.com/practice/pair-programming/)
    和[https://openpracticelibrary.com/practice/mob-programming/](https://openpracticelibrary.com/practice/mob-programming/)来了解更多并合作交流这些实践。
- en: Containers and Being Container-Native
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器与容器原生
- en: 'Before we can define exactly what containers are (hint: they are Linux processes!)
    and what container-native means, we need to look back in time to see what led
    to containers.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能准确地定义什么是容器（提示：它们是 Linux 进程！）以及什么是容器原生之前，我们需要回顾一下历史，看看是什么推动了容器的出现。
- en: Container History
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器的历史
- en: 'If you are over a certain age (over 30!), it is very likely your first computer
    program involved compiling source code and statically linking it with libraries
    from the operating system. Computer scientists then invented dynamic linking –
    which is great: you could patch one library and all of the programs you had written
    would pick up that change once restarted. This of course created a different problem
    – managing all of the dependencies. Packaging technologies such as RPM and YUM
    were created to help solve the dependency problem when distributing and managing
    Linux operating systems. Operating system distributions are one mechanism for
    collaboratively sharing and managing lots of different software packages at scale,
    and ultimately it is the software communities that evolve around these different
    software packages that solve real-world problems.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经超过了某个年龄（超过30岁！），很可能你写的第一段程序涉及编译源代码，并将其与操作系统中的库静态链接。之后，计算机科学家发明了动态链接技术——这很好：你只需修补一个库，所有你写的程序在重新启动后都会自动采用该变更。当然，这也带来了新的问题——如何管理所有依赖。像
    RPM 和 YUM 这样的打包技术被创建出来，以帮助解决在分发和管理 Linux 操作系统时的依赖问题。操作系统的发行版是一个协作共享和管理大量不同软件包的机制，最终围绕这些软件包形成的软件社区解决了实际问题。
- en: Of course, running your application on one physical machine is fine, but running
    lots of applications across lots of machines becomes a standard requirement as
    you scale. Virtualization solved how to run many operating systems on one machine
    in an isolated fashion. Indeed, the prominent form of cloud computing has been
    running virtual machines on someone else's hardware.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，运行一个应用程序在一台物理机上没问题，但当你需要在多台机器上运行大量应用程序时，随着规模的扩大，这就成为了标准需求。虚拟化技术解决了如何在一台机器上以隔离方式运行多个操作系统的问题。实际上，云计算的主流形式就是在他人的硬件上运行虚拟机。
- en: Virtualized infrastructure solved many problems of running applications at scale.
    However, configuring all of the pieces required to manage a fleet of **virtual
    machines** (**VMs**) leading to an explosion of tooling and technology related
    to configuration management. There was also the problem of "VM sprawl" – lots
    of VMs everywhere using too many resources that were difficult to patch and manage
    as a whole. Every application was managed independently, possibly by different
    teams. It was seen as desirable to reduce the interdependency between each application
    and so each application was also deployed in its own VM. To help control this
    spread of VMs, they were managed centrally by an infrastructure and operations
    team. Silos between teams were built! Many tools were created to help configure
    VMs. Each VM has overhead for running system processes and daemons, and so a lot
    of effort has been spent building tools that help avoid over-allocating machine
    resources to help save money.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化基础设施解决了大规模运行应用程序的许多问题。然而，管理一大批**虚拟机**（**VMs**）所需配置的所有组件，导致了与配置管理相关的工具和技术的爆炸性增长。还有“虚拟机泛滥”的问题——大量虚拟机到处都是，占用了太多资源，且很难整体修补和管理。每个应用程序都是独立管理的，可能由不同的团队负责。为了减少每个应用程序之间的相互依赖，每个应用程序也被部署在自己的虚拟机中。为了控制虚拟机的扩展，这些虚拟机由基础设施和运维团队集中管理。团队之间的隔阂也因此形成！许多工具被创建出来帮助配置虚拟机。每个虚拟机都有运行系统进程和守护进程的开销，因此，许多精力被投入到构建工具上，帮助避免过度分配机器资源，从而节省成本。
- en: For developers, the user interface in a VM deployed within an organization was
    not particularly self-service. Requesting a VM to be provisioned takes time. Workflow,
    ticketing, and provisioning systems were automated to try and help speed up this
    service request process. This was made radically better by public cloud services
    with an API-driven infrastructure, where provisioning a VM takes minutes and there
    is real self-service for developers. The control and VM sprawl issues still exist,
    though.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发人员来说，部署在组织内部的虚拟机（VM）用户界面并不特别具备自助服务功能。请求提供虚拟机的过程需要时间。工作流、票务和供应系统已自动化，以帮助加速此服务请求过程。然而，通过公共云服务，API驱动的基础设施使得虚拟机的提供只需要几分钟，而且开发人员可以真正实现自助服务。不过，控制和虚拟机泛滥的问题仍然存在。
- en: The application stack that developers used is still dependent on the operating
    system and libraries packaged into the VM that came with the kernel (for example,
    libc, libssl). And developers were usually not allowed to change the VM configuration,
    either because of perceived security or stability concerns. This was an infrastructure
    or operations team responsibility. Often, VMs were not easy to update, patch,
    and manage. It was not clear to the infrastructure or operations team what the
    effect of updating and rebooting a machine would have on the applications they
    supported.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员使用的应用堆栈仍然依赖于包含在虚拟机中的操作系统和库，这些虚拟机是与内核一起提供的（例如libc、libssl）。并且开发人员通常不允许更改虚拟机配置，可能是出于安全性或稳定性考虑。这通常是基础设施或运维团队的责任。通常，虚拟机更新、修补和管理起来并不容易。基础设施或运维团队不清楚更新和重启一台机器会对他们支持的应用程序产生什么影响。
- en: How Containers Work
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器工作原理
- en: It is often said that the journey of containers is one of **process isolation**.
    The containers concept likely started with chroot in 1979, then graduated to BSD
    Linux jails in the early 2000s where Solaris Containers picked them up in 2004.[2](#footnote-022)
    Solaris zones were a form of technology that isolated and combined system resource
    controls and boundary separation. From the outside, they looked like VMs, but
    they were not.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 人们常说，容器的发展历程是**进程隔离**的历程。容器的概念可能始于1979年的chroot，随后在2000年代初期发展成了BSD Linux监狱，2004年Solaris容器也采用了这一技术。[2](#footnote-022)
    Solaris区域是一种技术形式，结合了系统资源控制和边界隔离。从外部来看，它们像虚拟机，但实际上并不是虚拟机。
- en: '[2](#footnote-022-backlink) [https://www.section.io/engineering-education/history-of-container-technology/](https://www.section.io/engineering-education/history-of-container-technology/)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[2](#footnote-022-backlink) [https://www.section.io/engineering-education/history-of-container-technology/](https://www.section.io/engineering-education/history-of-container-technology/)'
- en: Technology companies that run a large number of workloads are always looking
    at ways to save resources and ultimately be more efficient. Roll forward to 2006
    and a number of technology enhancements were made within the core Linux kernel
    that was related to the isolation of Linux processes. Google introduced the technology
    initially called process containers that was later renamed cgroups. It was designed
    for limiting, accounting, and isolating resource usage (CPU, memory, disk I/O,
    and network) of a collection of processes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 运行大量工作负载的科技公司总是寻找节省资源和最终提高效率的方法。回到2006年，核心 Linux 内核中进行了多项与 Linux 进程隔离相关的技术增强。谷歌最初引入了一项名为“进程容器”的技术，后来更名为
    cgroups。它旨在限制、计量和隔离一组进程的资源使用（CPU、内存、磁盘 I/O 和网络）。
- en: A novel solution to the dependency problem for containers was introduced by
    Docker in 2013\. Packaging applications and their dependencies into container
    images lead to an explosion in popularity for containers. Container images were
    made freely available and distributed online via container registries such as
    [dockerhub.io](http://dockerhub.io) and [quay.io](http://quay.io).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 2013年，Docker 提出了一个解决容器依赖问题的新方案。将应用程序及其依赖项打包成容器镜像，导致容器的普及爆炸式增长。容器镜像被免费提供并通过容器注册中心在线分发，如[dockerhub.io](http://dockerhub.io)和[quay.io](http://quay.io)。
- en: A running container is really just Linux processes with extra protections and
    data structures supporting the process in the kernel. Running containers on a
    single machine was easy; running thousands of containers across a compute farm
    was a much harder problem to solve. Enter into the scene container orchestration
    engines of which the Kubernetes project is by far the most widely used today.
    The OpenShift Container Platform is a product that brings together Linux, Kubernetes,
    and container technologies to allow enterprises to run containers safely and securely
    at scale in the enterprise.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 运行中的容器实际上只是具有额外保护和数据结构支持的 Linux 进程，这些数据结构支持内核中的进程。在单台机器上运行容器很容易；在计算农场中跨越成千上万个容器则是一个更加棘手的问题。于是，容器编排引擎登场，其中
    Kubernetes 项目无疑是目前使用最广泛的。OpenShift 容器平台是一个结合了 Linux、Kubernetes 和容器技术的产品，允许企业在规模化环境中安全、可靠地运行容器。
- en: Of course, to get to real business value, it is not enough to package your applications
    as containers and deploy a Kubernetes platform such as OpenShift. Just because
    you build it does not mean that all users will immediately flock to the platform!
    Modern application delivery using trusted supply chains forces new tools and ways
    of working onto your teams. New behaviors are required.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，要获得真正的商业价值，仅仅将应用程序打包为容器并部署一个像 OpenShift 这样的 Kubernetes 平台是不够的。仅仅因为你构建了它，并不意味着所有用户会立即涌向该平台！使用受信任供应链的现代应用交付迫使你的团队采用新的工具和工作方式。新的行为方式是必须的。
- en: With containers, the developer's user experience has been radically changed.
    Developers can now self-service their applications without having to go through
    the provisioning of a VM. Of course, someone still had to provision the platform!
    Provisioning and starting of containers took seconds and minutes, and today with
    serverless-focused technology stacks, milliseconds.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器后，开发者的用户体验发生了彻底变化。开发者现在可以自助服务他们的应用程序，而无需经过虚拟机的配置。当然，仍然有人需要配置平台！容器的配置和启动只需几秒钟到几分钟，而今天，借助专注于无服务器技术栈的支持，甚至可以在毫秒级别完成。
- en: Developers can control the packaging, running, and upgrading of their applications
    easily using container images. The application is no longer tied to the version
    of libraries packaged in the kernel. It is possible to pull out all of an application's
    code and dependencies into a container image. You can run multiple versions of
    the same application together without being dependent on the same version of libraries
    in the kernel.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以轻松控制应用程序的打包、运行和升级，使用容器镜像即可实现。应用程序不再依赖于内核中打包的库版本。你可以将一个应用程序的所有代码和依赖项提取到一个容器镜像中。你可以同时运行同一个应用程序的多个版本，而不必依赖于内核中相同版本的库。
- en: The immutable nature of a container image also improved the overall service
    quality of applications. Teams could ensure that exactly the same container image
    would be run in different environments, such as development and production. To
    be able to run this immutable container image in different environments, developers
    started to learn that by externalizing their application configuration they could
    easily run the same container anywhere. The application configuration management
    was now built in as part of the container deployment process and the platform.
    This led to clearer boundaries between what the **developers** controlled (their
    applications and configuration) and what **ITOps** controlled (the platform itself).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像的不变性还提高了应用程序的整体服务质量。团队可以确保在不同的环境中运行完全相同的容器镜像，比如开发环境和生产环境。为了能够在不同环境中运行这种不变的容器镜像，开发人员开始学习通过外部化应用程序配置，他们可以轻松地在任何地方运行相同的容器。应用程序配置管理现在作为容器部署过程和平台的一部分构建在其中。这使得**开发人员**控制的部分（他们的应用程序和配置）与**ITOps**
    控制的部分（平台本身）之间的边界更加明确。
- en: '![](img/B16297_06_05.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_06_05.jpg)'
- en: 'Figure 6.5: Containerization providing clear boundaries'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5：容器化提供清晰的边界
- en: In a multi-tenant environment, different groups of users can isolate via projects
    so as to increase utilization of the underlying infrastructure. In OpenShift there
    are built-in mechanisms for controlling network ingress and egress, role-based
    access control, and security, as well as out-of-the-box metrics, monitoring, and
    alerting capabilities. The platform supports the idea of mounting persistent data
    storage into your containers. The platform supports these stateful applications
    so that when a container is stopped/restarted or moved to another compute node,
    so too is the persistent volume.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在多租户环境中，不同的用户组可以通过项目进行隔离，从而提高底层基础设施的利用率。在 OpenShift 中，内置了控制网络流入和流出、基于角色的访问控制和安全性等机制，以及开箱即用的指标、监控和警报功能。该平台支持将持久数据存储挂载到容器中。平台支持这些有状态的应用程序，以便当容器停止/重启或迁移到另一个计算节点时，持久卷也会随之移动。
- en: The demarcation of team roles within a container ecosystem is different compared
    to virtualized infrastructure. **InfraOps** teams can manage the OpenShift platform
    and supporting infrastructure, while development teams can self-service provision
    and run application services on the platform. It is a "set up and get out of the
    way" mentality. Of course, there are still complexities that need to be discussed
    and agreed upon before you can reach this goal. When to run cluster-wide services
    and operators, how to perform rolling platform upgrades while managing business
    application service levels under change, security, storage, high availability,
    and load balancing/networking concerns usually require everyone's involvement.
    It is the coming together of these teams and the DevOps conversations between
    them that form the backbone of modern DevOps practices today.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器生态系统中，团队角色的划分与虚拟化基础设施不同。**InfraOps** 团队可以管理 OpenShift 平台及其支持的基础设施，而开发团队则可以自助服务来部署和运行平台上的应用服务。这是一种“设置好后就不干涉”的心态。当然，在达到这一目标之前，仍然存在需要讨论和达成一致的复杂问题。何时运行集群级别的服务和操作员，如何在管理业务应用服务级别变化的同时执行滚动平台升级，安全性、存储、高可用性以及负载均衡/网络问题通常需要每个人的参与。正是这些团队的汇聚和他们之间的
    DevOps 对话，构成了当今现代 DevOps 实践的骨架。
- en: You can learn more and collaborate about the containers practice by going to
    the Open Practice Library page at [openpracticelibrary.com/practice/containers](http://openpracticelibrary.com/practice/containers).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问 [openpracticelibrary.com/practice/containers](http://openpracticelibrary.com/practice/containers)
    页面来了解更多并与他人合作容器实践。
- en: Pipelines — CI or CD or CD²?
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流水线 — CI、CD 还是 CD²？
- en: '*"The job of a pipeline is to prove your code is not releasable."* – Jez Humble'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*“流水线的工作是证明你的代码不可发布。”* – Jez Humble'
- en: OK – let's set the scene and get some basics out of the way. How do we take
    our code from individual lines of text on a laptop to being an application running
    in a container in production? Well, there are lots of ways with lots of kooky-sounding
    names! Teams call the journey our software goes through a pipeline, but there
    are numerous ways to implement one.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 好的——让我们设置场景，并先解决一些基本问题。我们如何将代码从笔记本上的单行文本转化为在生产环境中运行的容器中的应用程序？嗯，有很多方式，名字也各不相同！团队将软件的旅程称为流水线，但实现方式有很多种。
- en: Let's pause for a minute and think about what a software pipeline really is
    with the help of our friend Derek, the DevOps Dinosaur!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Derek the DevOps Dinosaur
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](img/Donal.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: Before I joined the Red Hat Open Innovation Labs team, I was a developer working
    for a large system integrator. While there, someone asked me to explain what a
    pipeline is – referring to some build automation I had created. The person asking
    me was an executive partner and had very limited technical knowledge. He wanted
    to know what a pipeline is in simple language that he could understand and relate
    to when talking to his customers. His questions were fundamental, such as what
    does one look like and what should it do?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: While thinking of ways to describe a pipeline in a simplified, relatable way,
    I kept thinking about whether I could explain it in a way that a three-year-old
    would understand – I could probably explain it to him. And so, Derek the DevOps
    Dinosaur was born.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Let's Forget about Software for a Minute…
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine for a moment that we're not building software. We're not configuring
    Jenkins, dealing with shells, Ansible, or any other automation tool. Let's imagine
    we're building dinosaurs! Big, scary, tough, monstrous, and ferocious ones with
    lots of teeth! Close your eyes and imagine the scary dinosaur for yourself. Maybe
    you're imagining some kind of hybrid Jurassic Park dinosaur. Think about the parts
    of the dinosaur you'd want to build – how many teeth does it have? How many arms
    and legs? When I think of my scary dinosaur, I think of Derek.️
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_06_06.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: Introducing Derek'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we know Derek is as big and scary as I need him to be? Let's start
    with his parts. First, we might analyze each of the individual parts of our dinosaur.
    Give them a quick check-over and ensure they meet the standard we set. For example,
    do I have two arms and two legs for my dinosaur? Has he got enough teeth? If it
    all looks good, we can then pop the parts in the ️Dino-Constructor 5000™.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: With the Dino-Constructor 5000™ complete, we should hopefully produce our dinosaur,
    Derek.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_06_07.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: Introducing the Dino-Constructor 5000™'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: How Do I Know My Dinosaur Is Fierce Enough?
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So, we've got a Dinosaur. But remember, we're here to build ferocious scary
    dinosaurs that are tough and fit. How do we know Derek is tough enough? Well,
    we could put him through a series of obstacles. Let's build an obstacle course
    for Derek.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_06_08.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: The dinosaur obstacle course'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: We'll start him on a climbing wall, much like the one you'd see recruits on
    in an army movie. Then if he's lucky enough to get over that hurdle, he's on to
    the next obstacle where he must jump over some spikes, Indiana Jones style! Next,
    we check how fit our dinosaur is; if he's able to run fast on the treadmill, he
    gets to pass on to the next step. Here he must try swimming past some fish that
    are trying to nibble on him. Once through that, perhaps he has to jump through
    a ring of fire. If Derek is capable and makes it through the obstacles, he can
    then run toward his pen – however, if Derek is not careful, he may be stopped
    by the swinging blade that was menacingly looming over him the whole time, like
    something from a Mario level. At any time, the blade could drop and stop Derek
    dead in his tracks. Let's for a moment assume Derek was careful and has made it
    into the pen where the other dinosaurs are.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_06_09.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: The dinosaur pen'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Derek can now live out his days with the other dinosaurs in the Dino Petting
    Zoo, Danny and Debbie. However, unfortunately for Derek, Debbie the dinosaur is
    quite mean to him. She keeps stealing all of the precious grass and water that
    Derek likes to eat (Derek is vegetarian in this metaphor!). So, in order to give
    Derek the isolation and correct amount of things he needs to be strong and healthy,
    the zookeeper comes along and moves him to a new pen.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Derek, as it turns out, is quite a popular dinosaur at the zoo, so the zookeeper
    decides to make clones of him and puts them all in a pen with Derek. He is happy
    here and has enough of all the things he needs to survive.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_06_10.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10: The zookeeper moves Derek to a new pen'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: But Wait – We're Building Software, Not Dinosaurs!
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sorry to shatter the illusion, but yes, we're (sadly) not in the business of
    making dinosaurs. We are here to build software applications. What we have just
    done to our dinosaur is the same thing we do to our code base on every commit.
    We build our code, run it through a series of obstacles, and then deploy it for
    our users to consume it. This is a pipeline; it's quite simple really!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at our dinosaur pipeline in more detail. In the first step, we assess
    the individual pieces that make up our dinosaur – its arms, legs, teeth, and so
    on. We ask questions such as are there enough parts? Does each hand have three
    fingers? I often think of this step as the static code analysis part of a pipeline.
    In the JavaScript world, this could be as simple as linting the code base or perhaps
    even running something more complex such as SonarQube to inspect the code quality.
    The Dino-Constructor 5000™ represents the compile step of any language.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The obstacle course we built for Derek represents the steps we should carry
    out to further assess our code quality. The initial hurdle Derek must get over
    could represent some unit testing. It is important that these obstacles are tough
    enough of a challenge while also not being so easy that they provide no value.
    For example, if Derek can make it over the climbing wall with ease, then it's
    probably not testing all the parts of him. Imagine for a moment that we decided
    to add another arm to Derek. We now have a terrifying three-armed dinosaur! If
    we were to ask him to climb the wall again, he would find it much simpler than
    before. In this regard it is important to increase the difficulty of the climb,
    perhaps widening the gaps or making it steeper so it presents more of a challenge.
    Thinking back to code, the logic still holds. When we introduce new features to
    our applications, we need to improve the testing coverage to include this. Writing
    tests is not a one-time thing; it must continue to evolve alongside our application
    development.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The other obstacles represent additional testing types. The small piranha pool
    Derek must swim through in order to get to safety could represent some early integration
    tests. The treadmill he must run on may be a kind of performance testing. The
    final obstacle Derek must pass unscathed is the giant blade hanging above him.
    Constantly looming, this testing type is, in my eyes, often the one that gets
    forgotten about. Derek may think he is free and run toward the pen only for the
    blade to drop on him and mean he can go no further – this is an example of security
    testing. Often forgotten about until the last minute, it can be a showstopper
    for final deployment in a lot of cases.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_06_11.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: Failing to make the cut when moving to a new pen'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Once Derek arrives at the dinosaur pen, he has to share the space with some
    other dinosaurs. Perhaps, at this point, the code has been deployed to a public
    cloud or a VM with competition for shared resources. Hopefully, by now, the operations
    team has noticed the application is running out of memory or there is a lack of
    compute. To combat this problem, the team might automate the containerization
    of the application. Once the code is in a container, it becomes shippable. We
    can move the container between cloud providers or even just between environments.
    At this stage, the code is packaged up with all of the dependencies it requires
    to run. This ability to move code without the need to rebuild and test can be
    safely achieved by building immutable container images. Versioning the application
    configuration separately from the built software means we can also horizontally
    scale our software easily by running more instances based on user demand.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: A Final Thought on Building Dinosaurs
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of these testing types can, and should, be automated as part of a software
    pipeline. On each automated process that should execute building, testing, and
    deploying, the code should check if each proceeding step is successful. Through
    this process, teams can deliver new features faster. Teams can introduce new code
    without fear of regression. Container platforms such as Red Hat OpenShift and
    Kubernetes can ensure an application always exists in the desired state. These
    platforms can also be used to run our software pipelines, using build tools such
    as Jenkins to run the stages. Dynamic provisioning of test tools such as Zalenium
    to execute our browser tests as well as using Jenkins to build makes creating
    pipelines repeatable and reusable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: By automating all steps in a pipeline like this, we can ultimately get the dev
    and ops teams' awesome output into the hands of users quicker.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to Derek, we now know that a pipeline is a series of steps we use to
    build, package, test, and deploy our software. Now, let's look at some of the
    terminology people use to describe a software delivery pipeline.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Integration
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Continuous Integration** (**CI**) is a software development practice that
    was popularized by the authors of Extreme Programming. There have been countless
    books written about it but the shortest definitions are sometimes the simplest!
    The three-word definition of CI is to "integrate code continuously." That is to
    say, developers and teams should regularly commit and push their code into the
    repository and have some automated process to compile, package, and test that
    code. This process should happen frequently – many times throughout the day for
    maximum effect.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_06_12.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: Continuous Integration'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: More teams fall down on this CI hurdle than you may think. Often, teams think
    they are practicing CI when in fact they are not.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Integrate Continuously
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](img/Noel.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: I worked on a Labs residency for a security company a few years ago. The team
    was fairly junior with several team members who'd just graduated. The team decided
    to create feature branches when writing their code so as to not break the workflows
    of others. Unfortunately, this led us to having these branches that lived for
    the duration of the sprint. We had lots of automation that was triggered when
    code was merged but we weren't merging frequently enough.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: For two sprints, we had the same mad dash to merge all our features at the end
    of the sprint just before the weekly demo – and it was chaotic, to say the least!
    This resulted in bi-weekly "mini-integrations." We had lots of automation set
    up to validate our code but we were not using it frequently enough. As you can
    imagine, there is nothing continuous about this process – we were not integrating
    continuously!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'To remedy this, we talked about it over our retrospective. If the tool you''re
    using, in our case Jenkins, can give you data about the frequency of builds or
    its usage stats, these can be great things to print out or bring to a sprint retrospective.
    A brilliant Scrum Master I once worked with always did this and it helped the
    team focus during the retro on actionable things that we could do to make things
    faster. In our case on this residency, we were operating in one-week iterations.
    This meant only four days of actual development time! Through the retrospective,
    we identified a few actions from looking at the data being supplied to the team:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '**Integrate continuously** – This was a big change for us, to try as often
    as possible to merge features together and get that validation we needed to avoid
    the merge hell we were encountering during demos.'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Smaller features** – The team realized that work was being broken down into
    too-large chunks. Each chunk was taking most of the sprint to complete. A smaller
    task size for each feature meant we could validate faster in smaller chunks whether
    things would work or not.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can learn more and collaborate about the CI practice by going to the Open
    Practice Library page at [openpracticelibrary.com/practice/continuous-integration](http://openpracticelibrary.com/practice/continuous-integration).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Delivery
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Continuous Delivery** (**CD**) is a development process where on every code
    change, teams build, test, and package their code such that it can go all the
    way to production. It is delivered to the doorway of production in an automated
    way but not let in. Lots of teams get to this state, and it is a great place to
    get to, but are held back from releasing all the way to production usually due
    to organizational release cadences or additional approvals being required. The
    important thing here is that they could release to production if needs be.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_06_13.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.13: Continuous Delivery'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Building Confidence in the Quality of the Software Delivery Pipeline
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](img/Donal.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: Early in my career when the concepts of automated testing and CD were new to
    me but still at the bleeding edge for some industries, I was working for a large
    retailer in the UK. They operated a very traditional approach to software deployments
    with a maximum of one release per quarter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Deployments were a scary thing to them – they would involve a team of specialists
    who would come in during the dark hours of a Sunday morning to begin their manual
    task. They would take down the website, put up a holding page, and begin working
    through the script they were asked to run. Mostly this was a success, but on some
    occasions when things went wrong, they may have been left with outages for days!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: This engagement was to build a mobile channel for the retailer to reach their
    customers. My role was to write some of the integration services between the mobile
    app and the commerce platform as well as to write a suite of automated integration
    tests. The retailer I was working for was very traditional and so they had in
    their project plan a three-week block prior to going live in which all the testing
    would occur. The retailer thought we were wasting our time writing automated tests
    and radiating the scores on a wall for all to see – they were confident the three-week
    window would be enough!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Our team was not willing to wait until the end to find out all the issues; they
    wanted feedback as they proceeded. We created a series of automated jobs in Jenkins
    to build the apps and APIs and deploy them to the user acceptance test environment.
    This meant that for months before the testing team was even engaged, we were delivering
    application revisions for them to test. Our automated tests emulated user behavior
    from the mobile app and tested for the happy path and all known error or sad paths
    through calling APIs with different input parameters. We also got hold of the
    user acceptance testing team's regression test scripts that would be manually
    executed and codified them as a set of tests for doing the same API calls. This
    excited the business as they began to see the app evolve. Features were getting
    added and issues were being fixed as they showed it off internally. It was a new
    experience for them, as they were only used to seeing the whole thing at the end.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Fast forward to the end of the project and the business had started to see the
    value of the tests we'd written. On every change, we had automated the building
    of the mobile app, deploying it to the app store, and we ran a huge suite of integration
    tests. They continued to do their manual testing phase at the end, which did throw
    up a few bugs (which we then wrote automated tests for and fixed). However, when
    they compared the number of issues found during this phase against other similar
    projects, there were far fewer.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: On the day of go live, the team was all set to push the app to the app stores
    and do the final deployment of the APIs. The retailer had marketing campaigns
    and other events aligned with this go live date, so the pressure was on! The teams
    were making minor app fixes right up to this point. Every change required the
    business to sign off the release, which meant involving the manual test team.
    Due to the pressure of the release window, the business decided to only do a quick
    smoke test of the app to see if the issue being fixed was resolved on a specific
    release candidate. This smoke test passed, so they were ready to roll – however,
    our automated tests threw up two failures in a service delivering product reviews
    within the application. There had been a minor change to the data format in the
    system of record further down the architecture that meant some data transformation
    functions were not working. This was not caught by the manual test team as they
    were not smoke testing this functionality. We flagged it up that our tests had
    spotted a regression, and the release was paused while this issue was resolved.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: It may seem like a trivial example, but this marked a big turning point for
    the retailer. They'd witnessed first-hand the speed, reliability, and effectiveness
    of our automated test suite as well as the speed at which we could build, validate,
    and deliver a production-ready application. The act of writing and running automated
    tests built huge trust within the wider organization, prompting them to change
    their ways radically in favor of more automation and more test automation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more and collaborate about the CD practice by going to the Open
    Practice Library page at [openpracticelibrary.com/practice/continuous-delivery](http://openpracticelibrary.com/practice/continuous-delivery).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Deployment (CD²)
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Continuous Deployment** (**CD²**) takes the process of CD but goes one step
    further and delivers applications into production and therefore into the hands
    of our end users. I think of CD as a big train – one that operates on a very reliable
    timetable. It bundles up all the changes, taking everything in our repositories
    and compiling, packaging, testing, and promoting the application through all environments,
    verifying it at each stage.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_06_14.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.14: CI, CD, and CD²'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: By continuously delivering to production, you speed up the delivery of features
    and fixes to end users compared to holding back for big bang releases. Delivering
    faster leads to business agility – the ability to react to changing customer and
    market demands and generate feedback from features sooner. Developers will not
    have to wait weeks or months from when their code is written for an end user to
    try it. A quick feedback loop is vital and time and money should be spent considering
    the best tooling to enable this speedy delivery.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: When the Work Is Done, Ship It!
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](img/Tim.jpg)![](img/Noel.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: Thinking about the ability to deliver at speed, where every change could be
    deployed to production, it's important to set the technology up to allow changes
    to flow freely with confidence. This requires strong buy-in from the people around
    the team, such as leadership and product owners, who can often block such efforts
    because too much change is considered harmful to quality or end user experience.
    These conceptions are often formed from previous bad experiences around failed
    deliveries. So, it is a two-way street – trust is built in that the team can execute
    with excellence.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: One of the best product owners we've worked with was at a European car manufacturer.
    They were replacing a knowledge base application used by dealers and mechanics
    to diagnose problems and order parts. Historically, changes to this application
    were farmed out to suppliers with each one patching on their changes. They would
    hire a systems integrator to add some new functionality and in doing so would
    often introduce new bugs or issues. This outsourcing of development meant that
    architectural design decisions were made outside of the customers' product team,
    which led to technical debt and an unsustainable solution in the long run. The
    team decided to wipe the slate clean and rebuild the application by bringing the
    development in-house. We were engaged to help kick start this team the right way,
    using a residency, and help them build a product team connected to their end users.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: A number of sprints into the engagement but still early in the development,
    the team was creating the authentication flow for users. I was pair programming
    with one of the engineers and we'd written the logout functionality. We had test-written
    and demonstrated the feature to the product owner running in our test environment.
    The Definition of Done the team agreed meant we had to show the feature to someone
    from the product team so they could accept it. So, as far as the engineering effort
    was concerned, we were done. The product owner did a quick test and it looked
    good in the test environment, so at the end of the sprint when we promoted all
    our changes up to production, our feature was released.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The UX folks were doing some usability testing with the latest increment of
    the application when they noticed some buggy behavior with logout not working
    from one of the screens. This was reported to the engineer and me, who worked
    on it initially, and we could spot the issue immediately. This was a small fix,
    so we wrote another test and made the change.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: We demonstrated the process to the product owner – writing a test that failed,
    writing code that would make the test pass, iterating, and then delivering that
    fixed logout code all the way to production. The ability to deliver small incremental
    improvements into the hands of our end users when they were ready to be shipped
    paved the way to deliver continuously.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: The lesson here is that Scrum may start to impede a team's ability to continuously
    deliver small incremental changes safely to production because Scrum delivers
    at the end of a sprint. "When the work is done, just ship it to production."
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: We have learned about the role of software pipelines, which codify the steps
    required to build, package, test, and deploy our application code into various
    environments up to but not necessarily including production – the practice of
    CD. We then looked at an approach to continuously deploying small incremental
    changes all the way to production.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about CD² by going to the Open Practice Library page at [openpracticelibrary.com/practice/continuous-deployment](http://openpracticelibrary.com/practice/continuous-deployment).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Everything-as-Code
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have heard about this one before: [insert software term here]-as-code.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Examples include infrastructure-as-code, config-as-code, tests-as-code, and
    now everything-as-code. This practice has been around for a long time but some
    organizations have been slow to adopt it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Here's the problem – historically, organizations have had to get expensive specialists
    to deploy complex environments. They would spend hours going through pages of
    instructions, line by line, eventually getting the deployment to work. A number
    of weeks would pass and the organization would like to create another environment,
    exactly like this one, for further testing. What do they do now? Call the specialist
    and ask them to come back at a great cost! This is fine, if you like hiring expensive
    specialists a lot.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what''s the solution? The everything-as-code practice is simple: you treat
    every part of a system as you would any other line of code. You write it down
    and store it in a version control system, such as Git. Do we really mean to automate
    every part of the system? Yes.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: We start by automating the infrastructure layer, the lowest level, from the
    bare metal servers to the operating systems, networks, application configuration,
    and on up through to application deployments.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'This automation effort sounds like an awful lot of work, and could be expensive
    in terms of people''s time – why should you invest in doing it? Here''s why:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '**Traceability**: Having your environment descriptions and structure stored
    in a version control system allows us to audit changes made to the system, tracked
    to the individual who made them.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repeatable**: Moving from one cloud provider to another should be a simple
    task. Picking a deployment target should be like shopping around for the best
    price that week. By storing all things as code, systems can be re-created in moments
    in various providers.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitOps**: A single source of the truth means no more tribal knowledge or
    experts needed to set up cables or attach hard drives.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phoenix server**: No more fears of configuration drift. If a server needs
    to be patched or randomly dies, that''s OK. Just create it again from scratch
    using the stored configuration.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-functional teams**: Writing all things as code improves collaboration
    between silos in an organization. The development team is able to contribute to
    the environment creation or can recreate their own like-for-like environments
    in a sandbox.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**De-risking**: Changes can be applied to environments or application deployments
    and reverted to previous states quickly, thus de-risking big upgrades of any kind.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are plenty of approaches to implementing everything-as-code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '**Networks and infrastructure**: Ansible can be used to declaratively define
    the system you''re implementing, and Istio can help with managing network traffic
    between apps and services.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application environments**: Containerization provides a proven, repeatable
    way to package applications and their dependencies in a way that both developers
    and operators love.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Developer workflows/build automation**: Use Jenkins'' Pipeline as Code or
    Tekton to describe how your application is taken from source, compiled, tested,
    and turned into something runnable.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration drift**: ArgoCD is a tool that implements the GitOps pattern
    for your application and support tooling.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing as code**: Selenium tests written as acceptance criteria in the behavior-driven
    development form can bring business analysts and developers one step closer together.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security and compliance**: Open Policy Agent and Advanced Cluster Manager
    are tools that enforce policies across the whole stack.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Teams who treat the whole system as code are stronger, faster, and better for
    it. We should no longer think about just infrastructure-as-code but automating
    the whole system – everything from application properties to networks and security
    policies. Then we codify it!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Can You Build a Second One of Those for Me, Please?
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](img/Author_4.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: Spending time on automating the creation of test environments? "Sounds costly
    and a waste of my time" – I can hear some people reading this saying to themselves.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: While working for a customer in the UK, I was building mobile apps and a bunch
    of JavaScript services to supply data to the apps in a consumable way optimized
    for the mobile. The services layer of adapters was deployed on IBM's MobileFirst
    (then Worklight), a big Java app that required a specialist to configure and install.
    We had several environments, from dev to system integration test environments
    to user acceptance test environments and production. All the common environments
    you'd imagine in a very traditional ecosystem.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The specialist spent two weeks configuring and installing the user acceptance
    test servers. Two of them were made available to allow us to have more than one
    thing under test at any given time. You wanted a third? Well, that meant bringing
    back that expensive specialist to build the third one and another week of their
    time. In production we had eight servers, each manually configured and deployed!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: When I look back on this engagement and think about the pressure we faced to
    get the servers configured and deployed along with the time taken for each one,
    it seems like madness. The consultant would rock up, spend the day messing around
    on the terminal making manual changes here and there and manually testing the
    results. None of the config files back then were stored in Git or even turned
    into scripts that she could execute to make spinning up the next one faster. Every
    piece of information was tribal and in her head. We wanted a third server? We
    had to hire her to come back and do it all again!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Some years later on another engagement for a public sector client, I saw similar
    behavior. I thought maybe creating servers in this way was a localized instance
    but on the government contract, there were teams spinning up servers for the developers
    to use that were not using any scripting or automation. If you wanted a server,
    you raised a ticket and waited a week. If you wanted an exact copy of that one,
    you raised another ticket and sometimes received one that was identical. In this
    case, the team was manually executing shell commands inside each VM and more often
    than not forgot to run a command or two!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: These examples may feel a bit old now – but the reality is that I still see
    organizations with a traditional approach to infrastructure, automation, and repeatability.
    Not being able to test changes on representative hardware can be a challenge for
    teams trying to go fast. Teams need to have the power to spin up and spin down
    application stacks on demand. Modern approaches to how we package applications,
    such as containers, can really help to bring down this wall. No longer does a
    developer need to stub out test cases with database calls, because they can just
    spin up a real database in a container and test against it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more and collaborate about the everything-as-code practice by
    going to the Open Practice Library page at [openpracticelibrary.com/practice/everything-as-code](http://openpracticelibrary.com/practice/everything-as-code).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: So, what approach did the PetBattle team take while practicing everything-as-code?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Establishing the Technical Foundation for PetBattle
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section will cover the beginning of our journey of PetBattle as the development
    team tries to set up a technical foundation with tools we will cover in later
    chapters. Any section in a box such as this one is going to lean in a bit more
    on the technical side.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: PetBattle began life as a hobby for some engineers – a pet project, if you will.
    This project provides the team with a real-world application where they can try
    out new frameworks and technology. In order to wrap some modern software practices
    around PetBattle, they enhance the application with some build and test automation.
    As the demand for PetBattle increases, we will look at autoscaling and how we
    can apply practices from the Open Practice Library to identify how we should build
    things.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: For PetBattle, we embrace modern software development paradigms – we monitor
    and respond to configuration drift so the team can implement GitOps to monitor
    this drift. Our environments should be like a phoenix, able to rise from the ashes!
    In other words, we can destroy them with confidence as we can recreate them from
    code.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at PetBattle's first piece of software they want to deploy, Jenkins.
    This section will explore how to deploy and manage Jenkins on OpenShift using
    Jenkins.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: The PetBattle team is using OpenShift to deploy their applications. They have
    chosen to use Jenkins to get started with automating some of their tasks for building
    and deploying their software automatically. Jenkins is an open source automation
    server that can run many tasks and is supported on OpenShift. Jenkins also has
    a strong helpful community surrounding it and there is a large plugin ecosystem
    too, making automating almost any task you can think of a cinch!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have established PetBattle's technical foundation, let's explore
    Jenkins a little more and the role it can play in strengthening foundations.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins – Our Best Friend!
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](img/Donal.jpg)![](img/Noel.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: We like to think of Jenkins as our friend. We remember the days when teams would
    have someone build the app on their local machine and send it to the ops team
    via email. To do deployments, it would be a specialized team that came in, usually
    overnight, and did the deployment so as to minimize interruptions.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Deployments were seen as a risky, scary thing. One time, a team we worked with
    went out the night before a big deployment. When they stumbled into work in the
    wee hours of the morning they were not quite in the sharpest of mindsets. As you'd
    imagine when running an upgrade, they skipped a step and broke things. The reason
    we think of Jenkins as our friend is that he doesn't do things like that. He does
    not go out the night before and arrive at work tired (unless, of course, you forget
    to feed him lots of RAM and CPU). Jenkins also won't forget a line to execute
    in a script; he's pretty good in that way. But he's also pretty dumb in other
    ways; Jenkins is only as clever as the instructions you feed him. Jenkins in his
    vanilla form is fairly basic, so we give him additional superpowers to be able
    to run builds for specific technology using agents and to report test scores in
    a machine-readable way using plugins. But once he's got it once, he will do it
    over and over again without failing – especially if you configure him as code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Helm Overview
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This next section is going to get a bit more detailed on the technical side
    of things. Prepare for some code snippets and whatnot! If this is not your thing,
    feel free to skip over it to the next section all about Git and developer workflows.
    We'll mark any section that's going to have code snippets and be a bit lower level
    with this handy sign!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Techie.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: Jenkins comes with OpenShift, and there are several ways for the team to install
    and configure it. Any member of the cross-functional team could go to the OpenShift
    console and install it from the catalog. It's as simple as clicking a few buttons
    in the UI and choosing to add a persistent hard disk or not. This is a great way
    for the team to get moving fast but also would not honor our technical foundation
    practice of everything-as-code!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: PetBattle now has two choices for how they could create an instance of Jenkins
    while honoring our everything-as-code practice. They could use OpenShift or Helm
    templates containing all of the Kubernetes and OpenShift objects that would be
    required to deploy a working Jenkins. For the purposes of this book, we will focus
    exclusively on Helm as our Kubernetes package manager.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Helm is an application package manager for Kubernetes that allows both developers
    and operators to easily package the resources and configuration that make up an
    application into a release. Helm is used for application life cycle management
    for installing, upgrading, and rolling back application deployments, thus simplifying
    the installation of an application on an OpenShift cluster. In Helm, applications
    are packaged up and distributed as Helm charts. A Helm chart is made up of several
    YAML files and templates. These Helm templates should output Kubernetes YAML once
    processed. Let's take a look at an example Helm chart.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'From our experience using Jenkins on OpenShift with customers, we have written
    a chart to deploy the Red Hat instance of Jenkins and give it a few superpowers.
    We''ll look at those afterward. Let''s first explore the anatomy of a chart:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The Jenkins chart, like all Helm charts, is made up of a number YAML files:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '`Chart.yaml`: This is the manifest of our Jenkins chart. It contains metadata
    such as the name, description, and maintainer information. The manifest also contains
    the application version and the version of the chart. If the chart has any dependencies
    on another chart or charts, they would also be listed here.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`README.md`: Instructions for the chart, how to install it, and how to customize
    it.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`templates/*`: This folder contains all the resources that need to be deployed
    to install and configure a running Jenkins instance, such as deployments, services,
    routes, and pvc.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values.yaml`: These are the sensible (default) values that the chart can be
    run with so a user can just install the chart and get up and running quickly.
    Customizations to these values can be supplied on the command line or by supplying
    your own values.yaml file when installing a chart.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red Hat **Communities of Practice** (**CoP**) is an organization that creates
    reusable software based on experiences and learnings from working with customers.
    This software is then open sourced and shared. We can add the CoP Helm Charts
    repository, which contains a Jenkins Helm chart for us to use.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we need the helm command-line tool. From your laptop, follow the
    instructions on the `helm.sh` ([https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/))
    website to install the helm tool. Then add the Red Hat CoP helm repository as
    follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can search this helm repository for Jenkins chart versions we can use:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_06_15.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.15: Searching the helm repository for the Jenkins chart'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Installing Jenkins Using Helm
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The quickest way to get access to your very own OpenShift cluster is to install
    CodeReady Containers on your laptop. Linux, Windows, and macOS are supported.
    You will need to log in and follow the instructions located here: [https://developers.redhat.com/products/codeready-containers/overview](https://developers.redhat.com/products/codeready-containers/overview),
    and you should see a two-step process similar to *Figure 6.16*:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_06_16.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.16: Installing CodeReady Containers'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Other OpenShift clusters you have access to may also work, as long as you have
    sufficient resources and privileges. The CodeReady Containers install gives you
    cluster administrator privilege (the highest level of privilege) and is limited
    by how much RAM, CPU, and disk space your laptop has. We recommend 8 G RAM, 4
    vCPUs, and 31 GB of disk space as a minimum, which would correspond to starting
    CRC on linux with:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There are more detailed OpenShift sizing instructions in the Appendix.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: To install the Jenkins chart, we will log in to OpenShift, create a new project,
    and install the Helm chart. If you're missing any of the tools needed to run these
    commands, have no fear, as they can be downloaded and installed to match your
    OpenShift cluster version directly from the OpenShift console. Click on the ?
    icon and then Command Line Tools to find the latest instructions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_06_17.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.17: Downloading Command Line Tools from OpenShift'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'The string after installation, my-jenkins, is the release name that is used
    by the Helm template engine:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It allows us to create multiple releases in the one namespace, which is useful
    for testing purposes:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_06_18.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.18: Creating multiple releases in a single namespace'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Helm charts can be installed in a number of ways. You can also run helm template
    against a local copy of the chart. If you are interested in doing this, fetch
    the chart and run this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This can be useful if you want to play around and see what the output is before
    applying it to an OpenShift cluster or if you want to validate things while debugging
    or testing a chart's configuration. You can also supply `--dry-run` to the helm
    install command to verify the chart before installing it.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Let me just pause a minute and say that this is not a book about Helm! There
    are great books out there written specifically for it, such as Learn Helm ([https://www.packtpub.com/product/learn-helm/9781839214295](https://www.packtpub.com/product/learn-helm/9781839214295))
    by *Andy Block* and *Austin Dewey*. Our aim is just to scratch the surface to
    show how easy it is to get going in a reusable and repeatable way with Helm and
    OpenShift.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Using helm install as demonstrated previously is great as it will create a
    life cycle managed by the Helm CLI to run upgrades and roll back releases if needed.
    These revisions are integrated into OpenShift and can be viewed in the UI or on
    the command line. Every time a new revision is deployed to the cluster, a new
    secret will be created, making rollback very simple:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To see all the pods being spun up by the Jenkins chart, you can run this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should see a large volume of pods being created – this is because this
    Helm chart contains lots of additional configuration-as-code for Jenkins. Write
    once and deploy many times:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_06_19.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.19: Pods being created'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: You may notice a bunch of agent build pods in the output. Jenkins by itself
    is a bit useless. One of Jenkins' superpowers is his ability to be extended using
    what are called plugins – small bits of code that provide new functions and features.
    To install these plugins, we could wait until Jenkins is deployed and configure
    the plugins manually through the UI – but this is the everything-as-code world,
    so we don't want to do that!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'The Jenkins Helm chart is configured to pre-install a bunch of useful Jenkins
    agent plugins. These agents know how to build container images using various language-specific
    stacks. The configuration for the agent plugins is defined in the Helm chart''s
    `values.yaml` file, which you can see by using this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The Helm chart is defining a list of build configurations to build each agent
    image. The Jenkins agent images use an OpenShift project called **Source-to-Image**
    (**S2I**) to do their language-specific build of your applications. S2I is a toolkit
    and workflow for building reproducible container images from source code; you
    can read about it here: [https://github.com/openshift/source-to-image](https://github.com/openshift/source-to-image).
    You basically feed S2I your source code via a Git repository URL and it takes
    care of the rest.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Using language-specific agents makes Jenkins easier to extend. We do not have
    to install tools into the base Jenkins image; rather, we define an agent and add
    it to the Helm chart agent plugins values list. OpenShift makes it very easy to
    create agents for Jenkins. We can extend the base image with any binary we want
    to use in our pipelines and apply the label `role=jenkins-slave` to make it discoverable
    in Jenkins. This gives us a near "serverless" ability for Jenkins to dynamically
    provision an agent when it's required. In this case, a pod gets launched and Jenkins
    will connect to it, execute its tasks, and destroy it when it's done. This means
    no agents lying idle waiting to be executed and a clean slate every time we run
    a build.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a bunch of Jenkins agents available in the CoP; you can use them
    or create your own: [https://github.com/redhat-cop/containers-quickstarts/tree/master/jenkins-agents](https://github.com/redhat-cop/containers-quickstarts/tree/master/jenkins-agents).'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the agent plugins, the Jenkins image is extensible from the base
    image in a number of different ways. You can specify a list of plugins to install
    when you build the Jenkins image. We use S2I to build our Jenkins image and add
    our list of `plugins.txt` from this Git repository: [https://github.com/rht-labs/s2i-config-jenkins](https://github.com/rht-labs/s2i-config-jenkins).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Once the Jenkins build has completed, a Jenkins deployment and running container
    instance will be available.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_06_20.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.20: Available Jenkins deployment and a running container instance'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the S2I plugins and agents are configured. You can log in to Jenkins
    using its route, which is available in the OpenShift web console, or by running
    this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By running this single `helm install` command, we get a sensible starting point
    to be able to do lots of things with our build server, Jenkins. By codifying the
    Jenkins configuration, we can repeatedly deploy Jenkins into many environments
    without ever having to touch the Jenkins UI.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our build server, before starting development we should familiarize
    ourselves with the types of code workflows developers use. If you are an experienced
    developer, you will already be pretty familiar with the next section's content.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Developer Workflows
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Git is a **version control system** (**VCS**) created by Linus Torvalds (author
    of the Linux kernel) to track changes in source code and easily manage these changes
    across many file types and developers. Git differs from other VCS in that it is
    decentralized. This means that unlike, for example, **Subversion** (**svn**),
    each developer retains a complete copy of the source code locally when they check
    it out. Locally, each developer has a copy of all the history and can rewind or
    fast forward to different versions as they need to. An engineer makes their changes
    and applies those changes as a delta on top of another's work. This is known as
    a commit. Git can be conceptualized as a tree, with a trunk of these changes or
    commits on top of each other. Branches can spring out from the trunk as independent
    pieces of functionality, or work that is not ready can be merged back to the trunk.
    Once something is committed to Git, it is forever in the history and can always
    be found – so be careful not to add something secret, such as a password, by mistake!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Git is the underlying technology behind some big companies such as GitHub and
    GitLab. They have taken the Git product and added some social features and issue-tracking
    capabilities to help manage a code base.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: There are many workflows for Git that development teams can use when writing
    code, and choosing the correct one can seem like a daunting task. Some are designed
    to give teams a sense of safety and security, especially in large complex projects,
    while others promote speed and trust within the teams. The most popular source
    code management workflows for Git are Trunk, GitFlow, and GitHub Flow. Let's explore
    each in detail and see how we could use them to help us promote CD.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: GitFlow
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GitFlow was first published about 10 years ago by Vincent Driessen. The workflow
    was built from his experience using Git, a relatively new tool at the time. As
    teams moved to Git from a non-branching-based code repository, some new concepts
    and core practices had to be defined. GitFlow tried to answer this by adding a
    well-thought-out structure to branch names and their conventions.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'A well-defined branching strategy is at the heart of GitFlow. Changes are committed
    to different named branches depending on the type of change. New features are
    developed on branches that are called `feature-*` branches. `hotfixes-*` branches
    are created for patching changes to bugs in production and a release branch. GitFlow
    describes two reserved and long-living branches:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '**Master**: This is the branch that contains our releases or our production-ready
    code. Sometimes this branch is referred to as the main branch.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Develop**: This branch is our integration branch. It is usually the most
    turbulent and very likely to contain bugs or other issues as it is the place where
    teams first bring their code together.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The naming and usage conventions defined in GitFlow make it easier for a new
    developer to discover what each branch is doing. The developer can bring additional
    changes made by other team members into their feature branch, when they choose
    to, by merging in any new changes. Branching in this way avoids breaking things
    for other engineers by ensuring that the feature functionality is complete before
    asking to merge their code from the feature into the develop branch. When a set
    of features is ready to be promoted to the mainline master branch, the developers
    merge their code to the master via the release branch.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: You may be reading this and thinking, this sounds complex! And in some ways,
    it is. But in a large project with a single code base, this can be exactly what
    is required to ensure developers are free to work on their code without having
    to manage their code.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Flow
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GitHub Flow is similar to GitFlow in that it shares some of the same words in
    its name. Branching is a core pillar of Git, and GitHub Flow uses this by keeping
    one long-lived branch, that is, the main or master branch. Developers then work
    in branches off main, where they can commit changes and experiment without affecting
    the main branch.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: These could be feature branches like in GitFlow, but there is no naming convention
    to be followed. It is important to name the branch sensibly using a descriptive
    name, such as sign-up-form or refactor-auth-service. No branches called another-new-feature-branch,
    please!
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: At any point in time, the developer can raise a pull request, where other engineers
    can discuss the code and its approach, and design by providing feedback for the
    changes that are still in progress. The original author can then incorporate this
    discussion into the software. When the team is happy and the code is reviewed,
    the changes can be approved and merged to the main branch.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Flow is great at promoting the peer review of work and promoting transparency
    in how a decision was made. Git by its nature is searchable, and the discussion
    on a merge request provides valuable insight and traceability into how architectural
    and coding decisions were made.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Trunk-Based Development
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both GitHub Flow and GitFlow use branching strategies and merging patterns to
    bring independent development activities together. Branching in Git is made extremely
    easy. However, when merging all of the branches together, conflicts can still
    occur that require human intervention.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the frequency of this branching, some teams end up in merge hell,
    where everyone tries to bring their changes in at once, leading to the complex
    and often frustrating event of trying to unpick all the changes that were made
    while maintaining a working code base!
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Trunk-based development ([https://trunkbaseddevelopment.com/](https://trunkbaseddevelopment.com/))
    takes a somewhat different approach to this particular problem by saying **no**
    to branches!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_06_21.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.21: Merge hell'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: In trunk-based development, developers collaborate on one single main branch
    referred to as the trunk. Devs work on their changes and apply them directly to
    the trunk. In a perfect world, the commits are small in nature and frequent throughout
    the development process. The golden rules here are never break the build and always
    be release-ready. In this regard, a developer must always ensure this is the case.
    Development could be automated using some CI process, but the key is that the
    trust within the team must be there.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: In a large-scale enterprise, this constant merging to master sounds like it
    could create headaches. How, for example, do you do a peer review of the code?
    For large-scale application development with many engineers and many teams, it
    is suggested that very short-lived feature branches can be a great help. They
    provide decision logs during the review process, but the key here is short. Short-lived
    feature branches should only be alive for a day or two at most (definitely no
    longer than a sprint) and are deleted once the code is merged to prevent them
    from becoming feature release branches.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Too Many Choices — Tell Me What to Do
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each of these Git workflows has been tried and tested with teams for years.
    Some teams choose one as a standard, whereas others adopt one or more depending
    on their own context.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: The original author of GitFlow recently revised his views to suggest GitFlow
    does not work well for "applications that are delivered continuously" such as
    web apps. Branches can create distance between production code and work in progress
    and GitFlow sees code moving between several branches before it's released. If
    we think of a developer working on their feature, they get it merged into the
    develop branch and then they move on to a new feature branch.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: The new feature sits waiting (potentially along with some other features that
    have been completed) until the end of the development cycle. At this point, it's
    bundled up and moved across to master via the release branch, possibly two weeks
    after the work was completed. All of these extra steps mean a developer is not
    getting the feedback they need from users in the field for a long time after the
    development is complete. In terms of a feedback loop, if the rework is required
    on the item or a bug arises, it could take weeks before it is rectified. Add to
    that the context switch for the developer, who has to go back over what they previously
    did, which could end up having an impact on the team's velocity.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: In CI, does having feature branches slow us down? It's very easy for a developer
    to effectively hide out on their branch while development is happening. We have
    worked with teams in the past who have claimed to be doing CI, but their build
    system remains idle until the day of review. At this point, all the developers
    rush to integrate their features in a last-minute mini-integration session that
    often reveals misunderstanding in the designs or broken software. Long-lived feature
    branches do not easily marry up with CI.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Short-lived feature branches are a great way to help with some of these concerns.
    Developers can work away on small chunks in an isolated way and still merge frequently.
    Short feedback loops are the king of improving software delivery metrics. If branches
    add time to this loop, how can we tighten it further? Peer reviews can often be
    a burden to teams by creating a dependency on one individual or breaking the focus
    of another engineer in order to complete a feature. By pairing engineers, you
    gain implicit peer review. Pushing changes as a pair straight to the trunk is
    a great way to achieve speed. In a container ecosystem, you only want to build
    once and verify your application is working before deploying it to many places.
    Trunk-based development underpins this by encouraging frequent small changes pushed
    straight to the head, where CI and CD can then take over.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: From our experience in kickstarting product teams with varying skill sets, choosing
    the right one should be seen as more of a pathway, a sliding scale from immature
    to mature teams. Teams that are new to Git may find the use of feature branches
    a comforting way to not step on the toes of other developers. The book *Accelerate*[3](#footnote-021)
    measured the software delivery performance of many teams and concluded that high-performing
    teams use trunk-based development.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: No matter what you choose as your approach to managing code, the key here is
    the frequency of delivery. How long will it take you to get software into the
    hands of your end users? Does having feature branches slow you down? Or do those
    branches provide you with a safe place for your team to start? As the team matures
    and becomes more familiar with each other and the tools, your software output
    can increase.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: The big call to action here is to let the teams choose the way that works best
    for them and build the automation around the workflow and tools. This allows the
    developers to focus on the hard stuff – writing code not managing the code. Initially,
    this will just be a guess. Teams should use retrospectives to assess whether things
    are working or not and evolve accordingly. It's important to not set out one dogma
    to fit all development activities across all teams because every team is going
    to be different. One shoe size is not going to fit everyone!
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[3](#footnote-021-backlink) [https://itrevolution.com/book/accelerate/](https://itrevolution.com/book/accelerate/)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we learned that we could get off to a great start by being
    green from go! By automating the deployment of our application build and packaging
    tools, Jenkins and Helm can establish a technical foundation that will allow our
    teams to integrate continuously (CI) and continuously deploy (CD) our code to
    production.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: We learned that we can align our developer code workflow across our team and
    begin to iterate on our CI/CD pipelines to help us deliver applications faster.
    We can increase code quality and understanding by pairing developers together
    to help shorten the code review feedback loop.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: As a team, we learned all of these new skills and techniques together by trying
    mob programming and, in the process, said goodbye to our love for Unicorn developers.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_06_22.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.22: Adding technical practices to the foundation'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: In the second half of *Open Technology Practices*, we will learn about the bigger
    picture, discover what GitOps is all about, vastly improve our code quality through
    testing, and finish off with some lessons about our emerging architecture.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
