- en: 7\. Open Technical Practices — The Midpoint
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to build on the foundational technical practices
    that we started in the previous chapter. We will acquire a shared understanding
    of our software delivery pipeline using the Big Picture practice. Even the less
    technical team members will be able to follow what happens to our software as
    it is being written and delivered.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We will then explain a technique that allows DevOps teams to deliver software
    changes using Git as the driving tool. The practice of GitOps leads to greater
    visibility of changes within our system, allowing the team to debug and resolve
    issues faster. We will explore how to improve our code quality through test automation
    and conclude this chapter by asking the question *How do we know if our architecture
    is good?*
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The Big Picture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitOps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emerging architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Big Picture
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Open Technical practice that costs little to produce but is great in creating
    a shared understanding of part of a system is the Big Picture workshop. It is
    a simple practice used to visualize all the steps that a software pipeline goes
    through in moving code from source (for example, Git), through compile and test,
    and then into the hands of our happy users. Building it collaboratively is a great
    activity for a team to do as it helps to bridge the gap between techies and business
    folks. It's great for articulating the importance and sometimes the complexity
    of continuous delivery.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_07_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: The Big Picture'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: A Big Picture can easily be created with just some stickies and a clear board
    or space. Of course, if you're feeling more artistic, it can also be doodled!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_07_02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: An example Big Picture'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be reading this and thinking *Sounds fluffy to me – why should I bother
    to make one?* Here''s why:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '**Shared understanding**: When the whole team collaborates around making the
    Big Picture, they get a shared sense of how their pipelines connect code to users.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prototype quickly**: It''s cheaper to write and draw before implementing
    a single line of code! Rapidly prototype with some markers and Post-Its, moving
    stages of your pen and paper pipeline.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity simplified**: The Big Picture helps bring non-techies into the
    mix by showing them the components required to manage the software life cycle.
    Build it up one step at a time to demonstrate the complexity in a simple visual
    flow.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Information radiator**: Like all these practices, the Big Picture is an evolving
    artifact. As the complexity of a software delivery pipeline grows, the Big Picture
    should be updated to reflect this. It is a graphic that can be displayed to all
    and should not be hidden.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B16297_07_03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Collaborating to get a shared understanding of the Big Picture'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Big Pictures can also be drawn using online collaboration tools. We used Miro
    to draw the following digital Big Picture online.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_07_04.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_04.jpg)'
- en: 'Figure 7.4: A digital Big Picture'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：数字“大图”
- en: 'The material required for this practice is fairly simple: some stickies, marker
    pens, painters'' tape, and a big blank wall or canvas are all that''s required,
    and these are fairly common things to have in our kit bags! There are a number
    of simple steps to follow in creating your Big Picture, but let''s use our PetBattle
    example to show how a team might use this in practice.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 创建“大图”所需的材料相当简单：一些便签、马克笔、油漆胶带以及一面大空白墙或画布，这些都是我们常见的工具！创建“大图”有一些简单的步骤，但让我们通过 PetBattle
    示例来展示团队如何在实际中使用它。
- en: PetBattle – Building a Big Picture
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PetBattle – 构建“大图”
- en: The PetBattle Techies decided to build a Big Picture to demonstrate their proposal
    for how the software should be built, tested, and deployed via some automation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: PetBattle 技术团队决定构建一个“大图”来展示他们关于软件如何通过一些自动化构建、测试和部署的提案。
- en: First, they invite all the others in the team to help explain some of the technology
    and complexity of the automation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，他们邀请团队中的其他成员帮助解释一些自动化技术和复杂性。
- en: 'They use painters'' tape to form a large box that represents the cloud and
    another box inside it to represent the OpenShift cluster they''re going to use
    (deployed in the cloud). In this case, the metaphor is: OpenShift is just a big
    box where we can put some things running in the cloud. The box is so large that
    we can fill it with all the things we could possibly want, from sandboxes, to
    tooling, to production apps.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 他们用油漆胶带形成一个大框，代表云环境，框内再画一个小框，代表他们将使用的 OpenShift 集群（部署在云中）。在这种情况下，比喻是：OpenShift
    就是一个大框，我们可以将一些在云中运行的东西放进去。这个框非常大，可以填满我们可能需要的所有东西，从沙箱、工具到生产应用。
- en: '![](img/B16297_07_05.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_05.jpg)'
- en: 'Figure 7.5: Starting the PetBattle Big Picture'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5：启动 PetBattle“大图”
- en: They draw a box to the left side to represent their local development environment.
    This is their laptop for now, but it could also be a cloud-hosted IDE that the
    development team could write their code in that is deployed inside the cluster.
    One such product, CodeReadyWorkspaces, is a cloud-hosted IDE that runs in the
    OpenShift cluster that could be of great use to the team. Using an IDE like this
    allows us to further our everything-as-code practice by providing developers with
    their coding environment as a code artifact.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 他们在左侧画一个框，表示他们的本地开发环境。目前这是他们的笔记本电脑，但它也可以是一个云托管的 IDE，开发团队可以在其中编写代码，并且该 IDE 被部署在集群内。CodeReadyWorkspaces
    就是一个这样的产品，它是一个云托管的 IDE，运行在 OpenShift 集群内，对团队可能非常有用。使用这样的 IDE 可以通过提供作为代码工件的开发环境来进一步推动我们的“万物皆代码”实践。
- en: 'Next, they slice up the OpenShift cluster into smaller boxes. Each of these
    represents the OpenShift projects (or Kubernetes namespaces). We can think of
    these projects as rooms that separate one collection of applications from another.
    To keep things simple, the team decides on four namespaces initially:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，他们将 OpenShift 集群划分成更小的部分。每个部分代表一个 OpenShift 项目（或 Kubernetes 命名空间）。我们可以将这些项目视为将一个应用集合与另一个应用集合分开的房间。为了简化问题，团队决定最初使用四个命名空间：
- en: '![](img/B16297_07_06.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_06.jpg)'
- en: 'Figure 7.6: PetBattle Big Picture projects'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6：PetBattle“大图”项目
- en: '**Dev**: A sandbox project for the dev team to validate their app or get fast
    feedback from.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发**：开发团队用来验证他们的应用或快速获取反馈的沙箱项目。'
- en: '**Test**: A project to deploy all our applications to and run our system tests
    against.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：一个用于部署所有应用并进行系统测试的项目。'
- en: '**Production**: The project that PetBattle''s customers will use to access
    the applications once they''ve cleared our tests.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产**：PetBattle 客户在通过我们的测试后用来访问应用的项目。'
- en: '**CI-CD**: The project that houses all the tooling that supports **Continuous
    Integration** (**CI**) and **Continuous Delivery** (**CD**).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CI-CD**：包含所有支持 **持续集成**（**CI**）和 **持续交付**（**CD**）工具的项目。'
- en: With the OpenShift cluster logically sliced up into the projects the teams will
    use, the team draws the tools they will use in each project.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 OpenShift 集群逻辑划分为团队将使用的项目后，团队在每个项目中绘制出他们将使用的工具。
- en: '![](img/B16297_07_07.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_07.jpg)'
- en: 'Figure 7.7: PetBattle Big Picture initial frameworks'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7：PetBattle“大图”初步框架
- en: Starting with their *local* development environment – in other words, their
    laptops or cloud-hosted workspace – the existing PetBattle is built using Angular
    (a JavaScript framework for building web apps) for the frontend. Quarkus (supersonic
    Java) is used for the API layer, and MongoDB for the persistence layer, so they
    add each of these tools to their workspace and write a one-line definition for
    how the tool or framework is being used by this team.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: For PetBattle, we are going to use Helm to package up all the Kubernetes resources
    (Deployments, ConfigMaps, and so on) used to manage the application topology.
    We'll also use ArgoCD, a GitOps tool to manage our config-as-code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_07_08.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: PetBattle Big Picture source code and registry'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: PetBattle will use GitHub to store its source code. When building images, it
    is likely the team will need to store the built image internally on the OpenShift
    cluster using the internal registry. The team also wants to make their images
    available externally and so have decided to also make use of [Quay.io](http://Quay.io),
    an external registry hosted in the public cloud.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_07_09.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: PetBattle Big Picture pipeline tools'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The team then starts to add the tooling they will use to create their pipelines
    in their CI/CD namespace. They use more stickies to draw the tools and add a one-liner
    definition of what each tool is or how they will use it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: For example, the team is going to use Jenkins for their build and test automation.
    To store and cache application build dependencies and artifacts, the team opted
    to use the open-source artifact repository called Nexus. For Nexus, they add a
    simple one-liner to highlight the fact that it is used to house their software
    artifacts as well as their Helm repository. Shared understanding is key here,
    so it's important for the team to make sure everyone is aware what the purpose
    of each item is – this includes the product owner, designers, and all other interested
    parties. They don't need to be experts, but having an understanding of what the
    tools are used for can help them establish better empathy with the development
    team and see for themselves all the things needed to be able to ship code so quickly
    to users.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: With some of the tools in place on the Big Picture, the PetBattle team can now
    start to implement the design they've put in place.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The Big Picture can be created in a physical room with lots of colorful sticky
    notes or with everyone distributed using a tool such as Mural, Miro, PowerPoint
    or Google Slides. We have provided a useful template with all the icons we use
    which should help you get started. You can download this from the book's GitHub
    repository.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_07_10.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.10: The Big Picture template'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: You can download this from the book's GitHub repository.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The Big Picture allows us to get a shared understanding and team alignment around
    the use of technical tools at a high level. Like all the practices we put in place
    in this book, the Big Picture is not a one-time thing. The Big Picture is a tool
    we will revisit and enhance as we add more complexity to our architecture and
    begin implementing our pipelines. We will continue to explore the Big Picture
    in *Section 6, Build It, Run It, Own It*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 大局观使我们能够在高层次上对使用技术工具达成共识并进行团队对齐。就像我们在本书中介绍的所有实践一样，大局观不是一次性的。大局观是一个我们将不断回顾和完善的工具，随着我们向架构中添加更多复杂性并开始实施流水线，我们将不断完善它。我们将在*第六部分：构建、运行、拥有*中继续探讨大局观。
- en: You can learn more about, and collaborate on, Big Picture practices by going
    to the Open Practice Library page at [https://openpracticelibrary.com/practice/the-big-picture/](https://openpracticelibrary.com/practice/the-big-picture/).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问[https://openpracticelibrary.com/practice/the-big-picture/](https://openpracticelibrary.com/practice/the-big-picture/)页面，了解更多关于大局观的实践并进行合作。
- en: GitOps
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitOps
- en: Up to this point, we've talked about Git and the developer workflows available
    to our teams. We've spoken about everything-as-code, from infrastructure to tooling
    to applications all along the stack. Now, let's tie this all together with GitOps.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了Git以及为团队提供的开发工作流。我们谈到了全代码化，从基础设施到工具，再到整个堆栈中的应用程序。现在，让我们通过GitOps将这一切结合起来。
- en: GitOps sounds a bit like a buzzword, as DevOps was when it was first coined.
    In fact, we heard someone describe it to us as DevOps for the year 2020\. GitOps
    is a simple process of managing all of your systems, environments, and applications
    via Git. Git represents the single source of truth for all your applications,
    your tooling, and even your clusters. Changes to any of these things can be pull
    requested and discussed before an automated process applies them.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps听起来有点像流行词，就像DevOps在最初被提出时一样。事实上，我们曾听到有人这样描述它：GitOps是2020年的DevOps。GitOps是通过Git管理所有系统、环境和应用程序的简单过程。Git代表了所有应用程序、工具甚至集群的唯一真实来源。对这些任何内容的更改都可以通过拉取请求来提交并进行讨论，之后自动化过程会应用这些更改。
- en: The difference between **infrastructure-as-code** (**IaC**) and GitOps is the
    approach to managing the configuration. IaC is agnostic to where you store the
    configuration; it could be on a flash drive in your drawer or it could be a shared
    drive in the cloud. GitOps, as the name suggests, means storing the full system
    specifications in Git.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**基础设施即代码**（**IaC**）和GitOps的区别在于管理配置的方式。IaC与配置存储的位置无关；它可以存储在你抽屉里的U盘上，也可以存储在云中的共享驱动器上。而GitOps，顾名思义，是指将完整的系统规范存储在Git中。'
- en: The same principles hold true for IaC and GitOps – ideally, every action should
    be idempotent. Every action or operation can be applied multiple times, producing
    the exact same result. This is a very useful property in many situations, as it
    means that an operation can be repeated or retried as often as necessary without
    causing unintended effects. Configuration should be created declaratively. That
    is to say, you write the configuration to describe the desired state of an application
    or set of apps.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: IaC和GitOps的原则是相同的——理想情况下，每个操作应该是幂等的。每个操作或行为可以应用多次，产生完全相同的结果。这在许多情况下非常有用，因为它意味着可以根据需要重复或重试操作，而不会产生意外效果。配置应该声明性地创建。也就是说，你写下配置来描述应用程序或一组应用程序的期望状态。
- en: GitOps can be seen as a developer-centric approach to Ops. It teaches developers
    good practices around taking ownership of code once it leaves their machines and
    the approach to deploying and monitoring this code once it's running.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps可以看作是一个面向开发人员的运维方法。它教会开发人员在代码离开他们的机器后如何接管代码，并指导他们如何部署和监控运行中的代码。
- en: As developers, we hate repeating ourselves, so much so that we even have an
    acronym for it – DRY = don't repeat yourself! When encountering something that
    needs to be done more than once, our first instinct should be to try to automate
    it. Once something is automated or repeatable, the next step is simple. Check
    it into Git so that it can be audited, shared, and managed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，我们讨厌重复自己，甚至为此创造了一个缩写——DRY = Don't Repeat Yourself（不要重复自己）！当遇到需要做多次的事情时，我们的第一反应应该是尽量将其自动化。一旦某件事被自动化或变得可重复，下一步就是简单的操作。将其提交到Git中，这样它就可以被审计、共享和管理。
- en: For example, whenever we want to deploy a new application to OpenShift, we could
    run some manual commands to spin up the application, create services and routes,
    and even bind a ConfigMap. But taking the time to create a Helm chart for this
    is reusable and repeatable. We can design the final state of the application in
    code and then check this into Git instead. This is a more cloud-native way of
    writing and managing our application code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: To implement a GitOps approach to our Helm chart example, all we need to do
    is connect a tool to the Git repository, which can be alerted or watch for changes
    coming through. When those changes arrive, this tool can assess the difference
    between what the current state is and what state is desired and apply the changes
    automatically for us. Enter ArgoCD.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: ArgoCD
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From ArgoCD''s website, this is described as a tool that:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '*automates the deployment of the desired application states in the specified
    target environments. Application deployments can track updates to branches, tags,
    or be pinned to a specific version of manifests at a Git commit*.[1](#footnote-029)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: When something is seen as not matching the required state in Git, an application
    becomes out of sync. Depending on how you have implemented your GitOps, ArgoCD
    can then resync the changes to apply whatever is in Git immediately or fire a
    warning to initiate some other workflow. In the world of Continuous Delivery as
    implemented by ArgoCD, Git is the single source of truth, so we should always
    apply the changes as seen there.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: What types of things can ArgoCD apply? ArgoCD recognizes traditional Kubernetes
    YAML, Kustomize,[2](#footnote-028) Helm, and all sorts of other things. Unlike
    Helm, which uses templating heavily, Kustomize allows you to take YAML files and
    emits text in a template-free declarative way. You can patch Kubernetes resources
    and use folder-based structures to apply what is termed an overlay or YAML override,
    which emits text, leaving the original YAML untouched. For our purposes, we will
    stick to Helm and a little bit of Kustomize where appropriate.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: ArgoCD is another tool (and there are others like it, such as Flux) in the long
    list of tools that we need to be able to implement CI and CD. Unlike Jenkins,
    which we could also use to manage our application deployments, ArgoCD is specialized
    and very good at managing and maintaining just our deployments.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[1](#footnote-029-backlink) [https://argo-cd.readthedocs.io/en/stable/](https://argo-cd.readthedocs.io/en/stable/)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[2](#footnote-028-backlink) [https://github.com/kubernetes-sigs/kustomize](https://github.com/kubernetes-sigs/kustomize)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins could apply our Helm charts in a done once and finish sort of way. It
    doesn't have the capability to keep watching our Kubernetes resources to ensure
    the desired state in Git stays that way in our clusters. If someone decides to
    change something in the cluster, for example, add a new environment variable to
    a running application, ArgoCD will detect that change and overwrite it. This means
    no more one-of-a-kind deployments or manual tweaks once they're deployed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins可以一次性应用我们的Helm charts，类似于“完成后就结束”的方式。它没有能力持续监控我们的Kubernetes资源，以确保Git中的期望状态在集群中保持不变。如果有人决定改变集群中的某些内容，比如向正在运行的应用程序添加一个新环境变量，ArgoCD会检测到这一变化并覆盖它。这意味着一旦部署后，就不会再有独一无二的部署或手动调整。
- en: ArgoCD enables teams to enforce this golden rule – if it's not in Git, it's
    not real. This is perfect for audit tasks – all you have to do is check the Git
    log to see who committed and pushed the code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ArgoCD使团队能够强制执行这一黄金法则——如果它不在Git中，那就不是真的。这对于审计任务非常完美——你所需要做的就是检查Git日志，看看是谁提交并推送了代码。
- en: If It's Not in Git, It's Not Real!
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果不在Git中，那就不是真的！
- en: '![](img/Author_21.jpg)![](img/Author_41.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Author_21.jpg)![](img/Author_41.jpg)'
- en: We worked on a virtual residency with the World Health Organization helping
    to manage the COVID-19 crisis. We were building a new platform to help educate
    people in the field and disseminate information faster. We decided to use GitOps
    to do Continuous Delivery and, in particular, used ArgoCD to manage our Helm charts.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与世界卫生组织合作进行虚拟驻地，帮助管理COVID-19危机。我们正在建设一个新的平台，以帮助现场人员进行教育，并加速信息传播。我们决定使用GitOps进行持续交付，特别是使用ArgoCD来管理我们的Helm
    charts。
- en: To do cloud-native properly, namespaces and environments should be ephemeral.
    We should be able to recreate everything of use to us from their description in
    code. This includes namespaces, quotas, and role bindings, as well as applications
    and databases. To prove this in one sprint, we created a cleanup job that would
    delete the dev and test projects in OpenShift. Our configuration repository was
    linked to ArgoCD, which watched the cluster and, if anything changed, it was set
    to reapply the resources as described in Git. The time for this job to execute
    was on a Wednesday afternoon around lunchtime, about an hour before our sprint
    review. What could possibly go wrong?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正做到云原生，命名空间和环境应该是短暂的。我们应该能够从代码中的描述重新创建所有对我们有用的内容。这包括命名空间、配额和角色绑定，以及应用程序和数据库。为了在一个冲刺周期内证明这一点，我们创建了一个清理任务，用来删除OpenShift中的开发和测试项目。我们的配置库链接到ArgoCD，ArgoCD监控集群，并在任何变化发生时，重新应用Git中描述的资源。这个任务的执行时间定在周三下午午餐时间，约在冲刺评审前一个小时。可能出现什么问题呢？
- en: The team got ready to do their demo as normal, but about 20 mins before showtime,
    one team member called out that the build was failing and his demo was broken
    and he could not figure out why. The team scrambled to sort the issue, with everyone
    jumping on a call and mobbing around the problem. Rewinding what could have changed
    in the past hour, the only thing that had executed was the cleanup job we had
    written. We immediately thought we'd written something incorrectly with our job
    and so went to debug it, but it was fine. The next step was to look more closely
    at the build and the failure message.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 团队像往常一样准备进行演示，但在演示开始前约20分钟，其中一名团队成员喊道构建失败，他的演示坏了，而且他找不出原因。团队迅速行动，大家都加入了电话会议，共同解决问题。在回顾过去一小时可能发生的变化时，唯一执行的任务就是我们写的清理工作。我们立刻认为是我们在工作中写错了什么，于是去调试它，但一切正常。接下来的步骤是更加仔细地查看构建和错误信息。
- en: At this point, we discovered someone on the team had manually deployed a database
    to the dev environment. They were connecting to it for their demo AND using it
    as the test database in our Jenkins Pipelines. Essentially, someone on the team
    had created a Pet – a hand-reared server that was cared for and nurtured by one
    person and not known about by the rest of the team. In the world of ephemeral
    environments, what we really want is Cattle. Cattle are mass-produced, created
    using automation, and killed off when no longer required. Hence, when our job
    ran to clear out the project, all resources were destroyed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到这时，我们发现团队中的某个人手动将数据库部署到了开发环境。他们正在连接到它进行演示，并将其作为我们Jenkins流水线中的测试数据库。实际上，团队中的某人创建了一个“宠物”——一个由某个人精心照料和培养的服务器，其他人对此一无所知。在短命环境的世界中，我们真正需要的是“牛”。“牛”是大规模生产的，通过自动化创建，并在不再需要时被销毁。因此，当我们的工作运行并清理项目时，所有资源都被销毁了。
- en: 'The team learned a valuable lesson in this experience which they made very
    visible:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_07_11.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.11: If it''s not in Git, it''s not real'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: It gave rise to a mantra we added to our social contract from *Chapter 4, Open
    Culture.*
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Implementing GitOps
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](img/Techie1.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: Let's build the big picture with some real working code! In this section, we
    are going to take a technical detour! Prepare for some code snippets. If this
    is not your thing, feel free to skip over it to the next section all about testing!
    We'll mark any section that's going to have code snippets with this handy sign.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore ArgoCD and create the components of our Big Picture from code.
    To do this, we will first explore a sample project that can be used as a starting
    point for development.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: At Red Hat Open Innovation Labs, we have automated the bootstrap of Labs Residency
    CI-CD tooling to accelerate setup and onboarding. The code repository is called
    Ubiquitous Journey, so it makes sense for us to start here. We will explore this
    repository and set up our technical foundation using it. In later sections of
    the book, we will extend it with new technology and tools. This repo is available
    on the PetBattle GitHub organization – [https://github.com/petbattle/ubiquitous-journey](https://github.com/petbattle/ubiquitous-journey).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The first task we would normally perform on our OpenShift cluster when deploying
    Jenkins is to create a new project using the command line. We could follow this
    manual approach again, adding in role bindings and quotas for our project, and
    repeat these steps for each bit of our Big Picture. But let's do it in a way that
    honors our everything-as-code practice.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: From your laptop, fork the sample project and open it up in your favorite code
    editor.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: We are going to make changes to our project so maintaining your own copy of
    it is necessary for GitOps. From here on out, when we encounter a new repo, you'll
    probably find it easier to fork it so you can make changes to it. For the purposes
    of the book going forward, we will continue using PetBattle organization so feel
    free to equate this to your own organization or user.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Ubiquitous Journey project is broken down into two main components (some
    of the files are removed from the breakdown below for simplicity), Bootstrap and
    Ubiquitous Journey. If you're wondering why we named the project Ubiquitous Journey…
    well, we didn't! We hit the **generate random name** button on GitHub and this
    is what it chose for us. As is the case with most things in software, naming things
    is hard! We did plan on renaming the repo at some stage, but now the name has
    kind of stuck and we like it!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The bootstrap folder contains a Helm chart definition with a values-bootstrap.yaml
    file and Chart.yaml manifest. There are no templates for this chart because it''s
    actually just a wrapper for other Helm charts. If we look at the Chart.yaml manifest,
    we can see that it has a dependency of the ArgoCD chart, another called bootstrap,
    and a helper chart called sealed-secrets. The bootstrap folder Helm chart is acting
    as a wrapper chart, allowing us to control the variables we pass to these dependencies.
    In this case, our variables are stored in the `values-bootstrap.yaml` file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 启动文件夹包含一个 Helm 图表定义，带有一个 values-bootstrap.yaml 文件和 Chart.yaml 清单。这个图表没有模板，因为它实际上只是其他
    Helm 图表的包装器。如果我们查看 Chart.yaml 清单，可以看到它依赖于 ArgoCD 图表，另一个称为 bootstrap 的图表和一个名为 sealed-secrets
    的辅助图表。启动文件夹 Helm 图表充当包装图表，允许我们控制传递给这些依赖项的变量。在这种情况下，我们的变量存储在 `values-bootstrap.yaml`
    文件中：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The bootstrap chart is responsible for creating the listed projects in our OpenShift
    cluster. In the example, these are labs-ci-cd, labs-dev, labs-test, labs-staging,
    labs-pm, and labs-cluster-ops. Dev, Test, Staging, and CI/CD will hopefully be
    self-explanatory; if not, take a look at the previous chapter, where we discussed
    CI/CD in depth. The labs-pm namespace is for deploying other project management
    tools (for example, collaboration tools such as etherpad). The labs-cluster-ops
    namespace is used for operational jobs and tasks.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 启动图表负责在我们的 OpenShift 集群中创建列出的项目。在示例中，这些项目包括 labs-ci-cd、labs-dev、labs-test、labs-staging、labs-pm
    和 labs-cluster-ops。Dev、Test、Staging 和 CI/CD 可能会很容易理解；如果不明白，请查看前一章，我们在那里深入讨论了 CI/CD。labs-pm
    命名空间用于部署其他项目管理工具（例如协作工具如 etherpad）。labs-cluster-ops 命名空间用于操作性工作和任务。
- en: Resources in OpenShift have **role-based access control** (**RBAC**) applied.[3](#footnote-027)
    RBAC determines whether a user is allowed to perform a given action within a project.
    We bind the listed user groups to the service accounts within these projects.
    Don't worry if your cluster does not have the labs-dev and labs-admin groups set
    up right now. It is enough if you are logged in to your cluster with a user who
    has cluster admin privilege.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 中的资源应用了 **基于角色的访问控制** (**RBAC**)。[3](#footnote-027) RBAC 决定用户是否被允许在项目内执行给定的操作。我们将列出的用户组绑定到这些项目内的服务帐户上。如果您的集群目前尚未设置
    labs-dev 和 labs-admin 组，不要担心。只要您以具有集群管理员特权的用户登录到您的集群中即可。
- en: '[PRE53]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[3](#footnote-027-backlink) [https://docs.openshift.com/container-platform/4.6/authentication/using-rbac.html](https://docs.openshift.com/container-platform/4.6/authentication/using-rbac.html)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[3](#footnote-027-backlink) [https://docs.openshift.com/container-platform/4.6/authentication/using-rbac.html](https://docs.openshift.com/container-platform/4.6/authentication/using-rbac.html)'
- en: The second part of this file overwrites some variables in the ArgoCD chart.
    This Helm chart installs the ArgoCD operator and configures it with sensible defaults.
    For a list of all the possible variables that could be passed to this chart, you
    can check out the Operator Docs for ArgoCD – [https://argocd-operator.readthedocs.io/en/latest/](https://argocd-operator.readthedocs.io/en/latest/).
    There is no point in recreating those docs in this book, but it's useful to have
    them saved if you want to do some exploring.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件的第二部分覆盖了 ArgoCD 图表中的一些变量。这个 Helm 图表安装了 ArgoCD 操作员，并使用合理的默认值进行配置。关于可以传递给此图表的所有可能变量的列表，您可以查看
    ArgoCD 操作员文档 - [https://argocd-operator.readthedocs.io/en/latest/](https://argocd-operator.readthedocs.io/en/latest/)。在这本书中没有重新创建这些文档的意义，但如果您想进行一些探索，保存它们是很有用的。
- en: It is worth calling out the `applicationInstanceLabelKey` variable. This needs
    to be unique for your cluster. If you deploy more than one instance of ArgoCD
    to a cluster with the same instance label, the two ArgoCD instances will try to
    manage the same resources and then they'll fight over who actually owns them and
    get you into a world of pain, so make sure the `applicationInstanceLabelKey` is
    unique!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 需要特别注意 `applicationInstanceLabelKey` 变量。这个变量在你的集群中必须是唯一的。如果你在一个集群上部署了多个 ArgoCD
    实例，并且它们的实例标签相同，那么这两个 ArgoCD 实例将尝试管理相同的资源，然后它们会争夺到底是谁真正拥有这些资源，并且会给你带来很多麻烦，所以确保
    `applicationInstanceLabelKey` 是唯一的！
- en: 'Let''s deploy this setup and see what it gives us. If you wish to change the
    names of the projects that are created, you can edit the values file, but for
    now we''ll use the defaults. In a terminal on your laptop, try the following command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们部署这个设置，看看它给我们带来了什么。如果您希望更改创建的项目名称，请编辑值文件，但现在我们将使用默认值。在您的笔记本电脑终端上，尝试以下命令：
- en: '[PRE65]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Running a Helm template like this should bring down our chart dependencies and
    process our templates. This can be a handy way to validate that the YAML file
    looks as we expect. Let's install the bootstrap Helm chart into its own namespace.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The output of this command should be a successful installation of the bootstrap
    Helm chart:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_07_12.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.12: Bootstrap ArgoCD using Helm'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check the pods coming up with:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You should start to see the ArgoCD server start to come alive after a minute
    or two:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_07_13.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.13: Labs-ci-cd namespace pods starting up'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, if you have a look in the UI, you should see the topology with all the
    components of ArgoCD:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_07_14.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.14: OpenShift developer topology view of the labs-ci-cd project'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at ArgoCD by clicking the link in the UI, or you can get
    the URL from the command line using the following command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Log in with your OpenShift credentials. We should see an empty ArgoCD instance:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_07_15.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.15: Empty ArgoCD instance from the web interface'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we should ask ourselves the question *What happens when someone
    changes the bootstrap configuration values for our cluster?* for example, to add
    more projects or change the roles or groups? Can we do this in an automated and
    tracked way, in other words, using GitOps? Fear not, ArgoCD to the rescue! We
    can now point ArgoCD to the Git repository we've been working on.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create an ArgoCD application from the ArgoCD web interface by selecting
    +New App -> Edit as YAML and copying and pasting the following definition:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Hit Save, followed by Create. You should see the `bootstrap-journey` application
    synced:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_07_16.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.16: Bootstrap ArgoCD application from the web interface'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create the same application on the terminal. You can log in using
    single sign-on to OpenShift from the terminal using this one liner. It requires
    a terminal that is not headless, in other words, it can connect to your screen
    and browser:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Create the new app and sync the changes. With this in place, argocd will now
    actively track changes to our Git repository and roll them out for us! Simple!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'You can select the application in the web interface to drill down into it:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_07_17.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.17: Bootstrap application details from the web interface'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Excellent – we are on our way to completing our Big Picture as code and laying
    down our technical foundation! We've created the projects and added the first
    tool, ArgoCD, to our kit bag. Now, let's take it a step further and fill our cluster
    with some of the applications we think would be initially useful for building
    out CI/CD pipelines. At the beginning of any project, this will usually be a best
    guess. As we start to build out the product, we must continuously evolve the toolset
    we use. This is not a one-time process; it's a set of tools that need to be extended
    when required or trashed if no longer useful. The important thing here is to ensure
    that things are deployed in a repeatable way.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Let's add some tooling. Open your editor on the ubiquitous-journey project.
    Inside ubiquitous-journey/values-tooling.yaml, we have some useful variables referencing
    Helm charts ready for us to pick from, including Jenkins, which we manually deployed
    previously!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The layout of this file is simple. For each item in the applications array,
    it expects to find a Helm chart or a reference to a Git repository with some Kubernetes
    yaml (or Kustomize) at a particular version.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: When using Helm, any overrides to the defaults supplied by the chart can be
    added here, but for the Nexus chart shown, we are using the default values, so
    there is no need for value overrides for Nexus. There are other fields for each
    application, and these are mostly related to the operation of ArgoCD. For example,
    you can configure the application synchronization policy – sync-policy – which
    tells ArgoCD to always keep your application synced when set to automatic. The
    destination namespace may be specified. With some Kubernetes and OpenShift API
    objects, ArgoCD needs to be asked to ignore differences it finds; this is particularly
    true when controllers and operators write back the status and other fields into
    the objects themselves. We have found over time that each release of ArgoCD lessens
    the need to specify these *ignores* as the generated differences are taken care
    of automatically.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'The other important field for each application entry is the `enabled: true
    | false` – it''s easy to run down the list and enable the tools we know we need
    straight away. For now, we are going to start with just four tools: Jenkins, Nexus,
    Tekton, and Code Ready Workspaces. These are the bare bones for scaffolding our
    application and pipelines. At this point, it is worth mentioning the other two
    `values` files, `extratooling` and `day2ops`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Like our CI/CD application list in `values-tooling.yaml`, they contain references
    to useful Helm charts and YAML files for deploying in our cluster. The extra tooling
    contains project management and collaboration tools, while the `day2ops` contains
    useful prune jobs to keep our cluster tidy. For now, we will disable all of the
    extra tooling and day2ops apps. This gives us a minimal setup to get started with.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are running CRC, please check the Appendix for any details prior to
    deploying the tooling. Let''s deploy these tools from the command line using Helm
    and `oc`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: If you check the ArgoCD web page, you should now see these applications begin
    to deploy and synchronize into your cluster. It will take some time for them all
    to synchronize completely. Jenkins, for example, builds all of the default agent
    images that we may need for running pipeline jobs.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_07_18.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.18: The complete picture with all our tools installed'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: We have now successfully bootstrapped our CI/CD tooling! We will revisit these
    configurations as we find we need to add and update the tools we need to develop,
    test, and deliver PetBattle. By practicing *everything-as-code*, we can easily
    redeploy these tools into any Kubernetes cluster, track changes we may make, and
    manage the life cycle of the tools (upgrade them as their versions and features
    change).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Testing Testing Testing!
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to this point, we've spoken about some of the tools we can use to move application
    code from ideas through compilation and into deployment. But how do we know the
    stuff we've built is actually working as we expect it to? If we create a pipeline
    that just compiles code and moves it to production – is it done? No, there are
    testing quality steps and gates that we need to introduce into our software pipelines!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: The Test Automation Pyramid
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How do we know our feature works as we expect it to? We should test it and see!
    It is not always clear how we should test our feature, nor is it clear when we
    have done too much or not enough testing. Should we create test instructions and
    manually test the feature? Should we test the feature in isolation? Should we
    test all its constituent parts or just the whole thing? What is a definition of
    a unit test exactly?
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s face it, testing is complicated. We are going to advocate for creating
    not just any tests, but automated tests! *The Test Automation Pyramid*, authored
    by *Michael Cohn*, is a good starting point for us moving through the world of
    automated testing. Let''s take a simplified look at the *traditional* test automation
    pyramid by the original author:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image043.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.19: The testing triangle'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: In the standard three-tiered testing triangle, the things at the bottom (listed
    above as **UNIT TESTS**) are the things we should do more of. Unit tests are the
    smallest amount of code we can test within an application. These units should
    have little to no dependency on other items and so when we run them, they give
    us immediate and precise feedback. Unit tests should point us exactly to where
    the problem is in our code. Moreover, the thinking here is that unit tests are
    cheap to write, easy to maintain, and fast to execute. Therefore, we want more
    of them. This is why they sit at the base of the testing triangle.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Service tests are sometimes seen as integration tests and are the next level
    up the testing triangle. These are API tests that are validating the services
    within your application behave as expected. This may include single service calls,
    as well as chains of service calls, when one service calls another service. The
    width of the testing tier in the triangle relates to how many types of a particular
    test there should be in your code base. According to the pyramid, we should have
    fewer of these service tests than unit tests as they can be costly to execute.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: The top tier of the testing triangle is reserved for **User Interface** (**UI**)
    tests, or end-to-end system tests. These are responsible for validating that the
    system, as the sum of its components and parts, is behaving as expected. Often,
    UI tests can be brittle in the face of change, break more often, and require maintenance
    to keep them relevant, so the rationale from the testing pyramid is that we should
    do fewer of these as they are difficult to perform and provide less feedback for
    us.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Testing in Practice
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Test Automation Pyramid is a great place to start when thinking about your
    own testing. As with all models and patterns, people have over-simplified some
    of its original meaning. In fact, if you do an image search for the testing pyramid,
    you'll see that most of the results are missing the most important keyword – automation!
    Often, organizations lose sight of this, and they think doing manual testing for
    these tiers is good enough.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Testing is important; in fact, it's critical to being able to deliver at speed!
    If you imagine not investing the time into writing automated tests, it may be
    possible to complete a sprint without breaking things. It's probable that we'd
    be able to do two sprints and not break things. However, once we hit that third
    or fourth sprint, that's when your software system starts to misbehave. Applications
    that were written in sprint one now have bugs appearing in them because their
    functional behavior does not work as intended. Functions and APIs that were thought
    to be working were, in fact, completely broken! Being able to release software
    at speed is one thing, but being able to release quality software at speed is
    the differentiator.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: What is important when thinking about testing is to apply context. You don't
    have to blindly follow a model such as the testing pyramid. In fact, it's a good
    place to start from, but it's not a golden hammer to apply in all environments.
    For example, you might be building a web app with static content or third-party
    services, so UI testing is probably the most important thing.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: What is important is to be sensible about the types of testing you're aiming
    to perform and the value they provide. You may find that it's more important to
    your product that covering the services layer is a better option. If you don't
    have access to the code, then writing black-box tests that assess the services
    with well-defined inputs and outputs is more appropriate to your quality control.
    Likewise, measuring the number of tests, as suggested by the pyramid, tells us
    nothing about the quality of the tests. Good quality tests catch errors before
    your user does. When there is a failure in production, or a bug raised by a user,
    it is very likely that you need to write some more automated tests.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image045.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.20: Measuring tests'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: The other way to look at this would be to calculate the risk of not testing
    a piece of functionality. Perhaps the application you're writing is a one-time
    throwaway or just a simple technical spike that does not require rigorous testing.
    However, if a piece of functionality within your product is used all the time
    and it has no automated tests written for it at all, this could be a good place
    to focus your automated testing efforts.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a culture within your product development team where testing is a continual
    practice. Testing should not be an afterthought of the development process. All
    too often, we see testing beginning once the development team throws a package
    over a wall to the test team for some testing to begin. For us, every item in
    a sprint will always have some level of testing. This isn''t done by some third-party
    team, but by the engineers themselves. Developers will often favor unit and integration
    testing, but **quality assurance** (**QA**) teams will often favor automated UI
    testing to validate the application from a user''s point of view. Sometimes, if
    the culture is not right and a team is being squeezed to turn out new features,
    testing quality can drop, leading to an almost inverted testing pyramid: a few
    unit tests on the bottom, followed by a few more service tests, and then a load
    of brittle UI tests sitting on top! This has an effect on the quality of the software
    delivery pipelines. The feedback loop from Dev to QA can be very long, with little
    to no value from unit tests and expensive UI tests that are not providing feedback
    quickly enough.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Decreasing the quality by inverting the testing pyramid during delivery can
    be very damaging to a team. If the volume of defects increases markedly, trust
    in the team will falter. If there is no trust in the team, then autonomy could
    be the next thing to break, leading to a heavy command-and-control-driven culture.
    Teams operating in this way will very quickly fail and top talent will leave.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Testing and the Definition of Done
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](img/Author_42.jpg)![](img/Noel2.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
- en: While working on a residency recently with the World Health Organization, we
    started out with great ambition to write tests for each sprint item. We got off
    to a good start by including testing in our Definition of Done for each sprint
    item. We agreed that there must be some automated testing for each item being
    taken into a sprint.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: The first sprint went by in a flash as we were working in one-week iterations.
    As we were a new team, everyone was motivated and keen to try new things. By sprint
    three, we were taking on more stories than we could get through with our team's
    capacity.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: The work we were doing was becoming more complex and we missed out some of the
    automated tests. We claimed a feature or two were done. In the demo for that week,
    we admitted to the product owner that the piece of work was functionally done,
    but not done according to our own criteria.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: We tried to be honest with ourselves, but found we'd slipped up again the following
    week. At this point, it became clear to us that when we did sprint planning, we
    were not thinking correctly about the capacity required for writing tests. The
    Definition of Done was in place, but we were still not being honest. We were a
    team that was keen to keep moving forward and picking up new items before previous
    ones were done.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: In a retrospective session, we decided a good way forward would be for us to
    capture testing effort when writing our tasks. When taking an item from the backlog,
    we would add subtasks for all of the automated testing. This way, all of the work
    associated with test automation became visible to the team because these subtasks
    were on the sprint board. Having a task to write tests for your feature makes
    it pretty hard to move on to the next item when it's still in progress!
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more and collaborate on CI practices by going to the Open Practice
    Library page at [https://openpracticelibrary.com/practice/test-automation/](https://openpracticelibrary.com/practice/test-automation/).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: TDD or BDD or DDT
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of books written on testing and how to write great tests
    that are meaningful and provide value. Our ambition is not to rewrite these books,
    but to give you pointers to things you could research further if this topic really
    interests you. Some approaches to testing that teams find useful at the various
    levels of the triangle are things such as **Behavior-Driven Development** (**BDD**),
    **Test-Driven Development** (**TDD**), and **Developer-Driven Testing** (**DDT**).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_07_21.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.21: Test-Driven Development'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'TDD is a simple process, yet somewhat misunderstood by some teams. The process
    is fairly simple. Start off by writing some tests for the functionality you''re
    building. At this point, they should fail (**RED**). If they don''t fail, then
    your tests are not very well written OR the functionality already exists! A developer
    will then write the code to make the test pass (**GREEN**). With the tests now
    green, refactoring can take place or, as Kent Beck, an American software engineer
    and the creator of extreme programming, puts it, *refactor to remove duplication*.
    Remove duplicate code or make the code leaner and tidy it up while maintaining
    the green state of the tests. The process is simple: **Red > Green > Refactor**.
    Writing tests first is a hard practice to do and takes time and perseverance to
    get the skills right, but it can lead to less spaghetti code. Because the tests
    are written first, they lead the design and implementation of the code.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_07_22.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.22: Executing Test-Driven Development'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'A great exercise to do with teams wanting to try TDD without code is to do
    the Lego TDD simulation on Gargoyle Software''s website: [http://gargoylesoftware.com/articles/lego_tdd](http://gargoylesoftware.com/articles/lego_tdd).'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more and collaborate on TDD by going to the Open Practice Library
    page at [openpracticelibrary.com/practice/test-driven-development](http://openpracticelibrary.com/practice/test-driven-development).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: DDT is easy and probably the place to start if you're not writing any tests.
    The important point here is that some tests are being written! DDT focuses on
    the developers writing code as well as writing the tests. Simply put, the developer
    codes for a bit, writes some automated tests, and then goes back to coding and
    testing. This might sound a bit like TDD, but the key difference is the order.
    Code first and then test, resulting in the code influencing the tests as opposed
    to the tests leading the software design. The objective of DDT is that developers
    need to own their code and that everyone should be responsible for testing.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_07_23.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.23: Developer-Driven Testing'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: BDD is a great tool to have in your toolbox as it brings people together in
    a shared understanding of the scope of a story or feature under development. It's
    less of an engineering tool and more of a method that focuses on the conversation
    to be had between business and developers when writing features. BDD is about
    using a shared language to write concrete examples of how an application should
    behave.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'How the tests are implemented is then decided by the developers. But, more
    importantly, a common language can be used between developers and product owners
    to scope out a story without leading the design of the software. BDD can be a
    useful way to write acceptance criteria for a story together. There is a common
    syntax or approach to writing BDD tests based on work by *Dan North*, an agile
    coach and originator of BDD[4](#footnote-026):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[4](#footnote-026-backlink) [https://dannorth.net/introducing-bdd/](https://dannorth.net/introducing-bdd/)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: For any feature being developed, there are probably a number of scenarios that
    could be tested. These scenarios are defined using the common syntax of Given,
    When, Then. Codifying the acceptance criteria using a common syntax can simplify
    the writing of tests and gaining a shared understanding of the scope of an activity.
    Dan North suggested this story-driven approach to BDD some years back and, since
    then, the syntax has been adopted by lots of the testing frameworks, such as Cucumber.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: BDD for Our Ops Tooling Python Library
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](img/Author_22.jpg)![](img/Author_31.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
- en: 'I worked on a public sector engagement a few years back. I was part of a team
    helping them automate some of their Ops capabilities. They had teams of people
    configuring VMs manually in a non-repeatable way. Part of that work involved me
    building a command-line interface for the team to help automate the creation and
    onboarding of team members (users) and their roles into a Free IPA server (Red
    Hat Identity Management). The following screenshot shows one of the BDD scenario
    templates for adding an existing user and deleting a user:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_07_231.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.24: A BDD scenario'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: The architect on the team was a strong believer in the BDD approach to writing
    stories. All of our acceptance criteria were written in this way, and it was a
    great way for us to understand the scope of what we were doing. When I was pairing
    with another engineer, we would use the acceptance criteria written in the BDD
    syntax as our starting point. We imported the syntax straight from Jira to scaffold
    out the test cases using Python Behave. For us as engineers, this made coding
    the features a breeze. We had been given the specifications, so we could easily
    implement our code to pass the tests.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'BDD can help engineers understand the context of features better. It also helps
    bridge the gap of alignment with business experts and product owners:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Product Owners Seeing Their Thoughts in Code!
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we coach teams, we encourage them to use the sprint review or showcase
    events as an opportunity to show the world EVERYTHING they've worked on. That
    includes setting up and improving test automation.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: One particular recurrence I've noticed from several teams I've worked with is
    when the product owner or business SMEs first see automation of BDD running. They
    think back to the sprint planning event a week or two earlier, when the teams
    were confirming acceptance criteria for stories they were going to accept into
    the sprint. Often, these criteria would be written using BDD syntax and it would
    be the PO or business experts providing the input.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: When they see a test automation suite running in the sprint review or showcase,
    they will see the console showing the tests automated, the same thoughts, the
    same instructions, and the same business logic all codified.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: BDD brings down the wall between technology and business people.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Example Mapping
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Example Mapping, by Matt Wynne, CEO of Cucumber,[5](#footnote-025) is another
    great tool to have in the toolbox. Once again, with a lot of these practices,
    it''s just another really useful way to articulate and drive a conversation. In
    this case, Example Mapping is primarily used to drive shared understanding when
    writing stories and creating acceptance criteria. We believe it''s great for helping
    teams write behavioral-driven tests. The process is simple and only involves four
    colored Post-Its:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '**Yellow**: For the story itself (as a header for the example map)'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blue**: For specific rules associated with the story'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Green**: For examples of rules'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Red**: For questions or unknowns that arise during the discussion'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5](#footnote-025-backlink) [https://cucumber.io/blog/bdd/example-mapping-introduction/](https://cucumber.io/blog/bdd/example-mapping-introduction/)'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_07_24.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.25: Example Mapping'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Begin by selecting a story and write it on a yellow sticky note. Place it at
    the top of your example map as a header. In a horizontal row underneath that,
    begin writing business rules on blue sticky notes. Beneath the blue business rules,
    create columns of green sticky notes with individual examples of those business
    rules. These could be relatively unstructured Friends-notation *The one where...*
    examples, or full-blown Given, When, Then criteria.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: As misunderstandings arise surrounding individual examples or entire business
    rules, add red stickies with questions written on them.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: When there are enough examples that everyone is comfortable with, they can be
    rewritten as both automated tests and acceptance criteria.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Example Mapping in the Field
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](img/Noel3.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
- en: On the World Health Organization residency, I found this practice so simple
    to use but such a great tool to articulate the scope of a story and get alignment
    on the acceptance tests we'd write.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: We were using Event Storming (more on this later) to model the onboarding process
    for a new user to their application. We had a command that read *Submit relevant
    topics of interest*, which was added to our backlog. We chose this command so
    we could learn more about things our users would be interested in, in order to
    better serve them recommendations.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: We used Example Mapping to break this story down by first writing some rules.
    We were not super strict on following a ubiquitous language at this point as we
    knew the team would convert them into BDD-style syntax afterward.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_07_25.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.26: Example Mapping example'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: The conversion within the team brought out some misunderstandings regarding
    the scope of the activity. The developers wondered more about edge cases, such
    as, *what happens if the page is refreshed or returned to?* We were able to capture
    these questions as part of the Example Mapping and add a new rule and some examples.
    Subsequently, the team could convert the examples into the BDD syntax.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: As with all these practices, the act of having this conversation with the correct
    people and capturing the examples meant we gained great team alignment and were
    able to convert them to acceptance tests and implement them as part of our development
    workflow.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about, and collaborate on, the Example Mapping practice by
    going to the Open Practice Library page at [openpracticelibrary.com/practice/example-mapping](http://openpracticelibrary.com/practice/example-mapping).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Non-functional Testing
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the importance of testing cannot be overstated, it's critical to keep
    an eye on other metrics that may give further insight into the quality of our
    code. For example, how do you know your tests have enough breadth to check all
    the code? What if my tests are passing, but the application response time is awful?
    Traditional unit and integration testing might not catch these things. There are
    tools we can use to identify causes and issues with our code base and, more importantly,
    fix them sooner rather than later.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage reporters are simple to implement and usually come bundled up
    with a lot of modern test frameworks. The idea is simple. While running our test
    cases, the code base is being watched. Once test execution is completed, a report
    is generated showing what lines of code have been hit and where there are gaps.
    These are useful reports to help the team identify where there is room for improvement
    but they should not be treated as the absolute truth. As with all these things,
    there are ways to trick the coverage reports, but good developers and peer review
    processes should catch these things. Often, teams will strive to increase the
    testing coverage if they have not started from a very good state. Bringing these
    reports to a retrospective can be good for teams to analyze and set higher targets.
    More aggressive teams may even fail their pipeline as unstable if the coverage
    is below a certain threshold!
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Static code analysis is another tool that can provide insight into a code base
    not detected by unit testing, creating rules for how the code should look and
    execute. Consistency in an approach to how you write code is particularly important
    for non-compiled languages such as JavaScript. JavaScript also behaves differently
    in different browsers, so writing a set of rules such as using single quotes instead
    of double quotes for all strings can help ward off any unexpected behavior. If
    we have the rules codified, we may as well ensure that everyone adheres to them,
    so add them to our pipeline! Coding standards are very important in multi-team
    setups too. If the code base conforms to a standard structure and design, it can
    also make maintenance and updates to it very simple.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Performance Testing Sam's Code
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](img/Author_23.jpg)![](img/Author_32.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
- en: Around 2014, we worked for a retail organization building mobile backend services
    and some automation around it. This layer of services was responsible for aggregating
    data from different backend systems such as product listers and categories, and
    reviews. The services also performed some very basic data manipulation to make
    the payloads more mobile consumable. It was critical that the adapters responded
    in a very timely manner, as mobile latency was high compared to modern mobile
    networks and a fast API response time made all the difference.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Our team was always cognizant that we should keep track of the time taken for
    the adapters to respond. We knew the organization would perform a traditional
    load-testing initiative at the end of the program; however, we didn't want to
    wait until then to reveal any surprises. We figured there had to be a way to continuously
    validate changes we made to the adapter tier in order to highlight any performance
    degradation.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: We created a nightly job in Jenkins (our automation tool) to check the performance
    of the adapters each evening. This was a fairly simple job that simulated 1,000s
    of parallel requests to the APIs. From this, we plotted the response time of the
    service each day and reported it through Jenkins. This allowed us to create a
    baseline for where a normal response should be and allow us to fail the job's
    execution if the value fell above or below an expected range!
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_07_26.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.27: Automated discovery of performance bottlenecks'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: One day, we came into the office and our nightly job had turned red! Perfect,
    we thought, let's Stop the World and stop all the things we're doing while we
    inspect what's changed in the system since last night. A quick check of the changes
    that were made in the system revealed that Sam, one of the team members, had tried
    to check in some new logic for one of the data translation functions. Sam had
    introduced a big loop inside a loop inside another loop, which had caused the
    code execution time to spike. It was something that was not caught by our traditional
    unit testing, as the logic was working fine. It was just taking longer to compute.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: We quickly responded and fixed the problem immediately. If we hadn't caught
    this performance bottleneck, it could have been weeks or more before we realized
    what was happening. We could have been building more functionality on top of this
    dodgy piece of code, making it much harder to unpick at a later date.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Being able to respond to feedback like this was critical. We're not saying that
    big load testing on the product was not necessary, but this one simple automated
    job provided us with a ton of value just by catching this one issue. It was cheap
    to write and maintain and caught this error potentially sooner than we would otherwise
    have noticed. Sam tried to write some more code a few weeks later and we got a
    similar failure.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_07_27.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.28: More light automated performance tests'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Have no fear though – Sam, who's a good friend of ours, no longer writes code
    for a living as he's moved into a technical sales role. We don't have a blame
    culture within our workspaces and I'm sure if Sam was telling you this story,
    he'd say it was one of us that checked in that silly piece of code. I'll let you
    decide who it was.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of other types of testing and I won't list them all; we'd have
    to write another book to fit them all in. We go into more detail about the non-functional
    nature of our software in the next section, *Discover It*.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: A Few Final Thoughts on Testing
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We cannot understate the importance of testing in delivering features at speed,
    especially automated testing. Whether you follow the test pyramid or some other
    paradigm is up to you – just remember it's all about the conversation. If TDD
    is not the right thing for you, make sure you still have the conversation between
    business and technical teams to identify sensible tests using examples. The go-to
    for us is to use BDD as it allows us to bring together the world of business and
    technology.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we're not saying there is no place in the world for separate QA teams.
    Not at all, it's about automating all the things and getting feedback early. If
    the QA is a separate function within your organization and is only engaged some
    weeks before going live, then this is a problem. Bring the skills of QA into the
    team and left-shift that capability into the team so that they can get early feedback
    more often.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Emerging Architecture
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Hope is not a design method*.[6](#footnote-024)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: How do we know our architecture is good? What does good mean? Is good architecture
    measurable? Have you ever had to operate, support, or fix a system that is poorly
    architected?
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'It may be easier to identify some characteristics of what *a* *poor architecture*
    looks like:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: An unstable and unreliable system that fails regularly in unknown and unexpected
    ways.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system is slow from a user's point of view.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not scale well with increased users or loads.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is hard to upgrade because one small change requires everything to be re-deployed,
    which is slow and costly.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is dependent on clients or other systems and cannot be easily modified or
    changed without changing the other systems as well.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a lot of complex business functions that are buried in the database,
    that may involve triggers, and cannot be easily changed due to a complex database
    schema with unknown side effects when modified.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system is hard to manage and operate.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[6](#footnote-024-backlink) [Michael T. Nygard, Release It!: Design and Deploy
    Production-Ready Software](https://pragprog.com/titles/mnee2/release-it-second-edition/)'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: The list goes on and on.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: In frontline software support and operations, there is nothing worse than getting
    called consistently at 3 in the morning to firefight a recurrent complex system
    crash, and after restoring the service, the root cause analysis points back to
    a complex failing architecture – where there is no easy fix other than re-designing
    or rewriting the software.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: A lot of deep-seated issues with software arise from poorly judged architecture
    decisions. Many times, most of these decisions are made at the initial stages
    of product development when the big architecture is designed upfront and set in
    stone, concrete, or mud. Often, the system architects present their architectural
    masterpiece to the development teams and henceforth work to ensure the problem
    fits the architecture rather than the architecture fitting the problem.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: The development process continues using this eighth architectural wonder of
    the world and all goes well initially; it even may run in production. But then,
    one day, the business asks for some feature that doesn't fit well into the architectural
    approach and then there's hell to pay to get the change done.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Technical decisions during development often have to be made based on the best
    intentions, but with incomplete or sparse information. The wisdom gained from
    the more experienced members of the team can often be invaluable during design
    discussions. Those with scars from previous projects with bad architecture are
    definitely worth listening to and learning from. There can, however, be a downside
    to this, as we'll see in The Hammer section.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: As a product team, we must be willing and able to adapt and change the architecture
    when requirements substantially change or a system failure tells us that we're
    hitting the limits of our existing architecture.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Generally speaking, it is better to make architectural and technical decisions
    as late as reasonably responsible to do so, so that the most information is available
    to those making the decisions.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Emergent architecture is the practice of having *just enough of an architecture*
    so that the product developments keep moving forward, but is flexible enough that
    architecture changes can be made as more information becomes available.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: There have been literally dozens of excellent books and articles written on
    what is considered *good architecture and patterns* over the years. Our personal
    choice is anything written by *Martin Fowler* ([https://martinfowler.com/books/](https://martinfowler.com/books/)),
    *Chris Richardson* ([https://microservices.io/](https://microservices.io/)), and
    *Sam Newman* ([https://samnewman.io/books/](https://samnewman.io/books/)), but
    there are many others.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Observations from the Field
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, our intention is to outline some of the recurring patterns/approaches,
    both good and bad, that we've come across. None of these are new, but we thought
    it useful to call them out here.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Patterns per Square Meter
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *count of software patterns applied* in a product is never a good quality
    metric. Software patterns are well-known, reusable templates for solving particular
    problems. Don't make the mistake of assuming that a system that includes a bunch
    of software patterns is superior to one with fewer of them.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Expect Failures and Deal with It
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Catastrophic system failure is clearly undesirable. A system that never completely
    stops working in the face of subsystem failures is usually preferable. It can
    recover gracefully when subsystems fail and may support a subset of functions
    even if components are unavailable. We can apply architectural patterns wisely,
    for example, bulkheads to reduce the damage done by any individual failure. Absolute
    failures are often easier to deal with than capacity, latency, or seems kind of
    slow issues.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'When reviewing an architecture and, in particular, a distributed one, one piece
    of invaluable advice that I received from a very experienced architect some time
    ago is this – always be asking this question: *What happens if this component
    fails or slows down?* If there is no good answer to the question, then there is
    likely more that needs designing to prevent failure scenarios.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: The Hammer
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One pattern or behavior that we've seen a lot through the years is the Golden
    Hammer pattern, in other words, if all you have is a hammer, everything looks
    like a nail. This is more formally known as the Law of the Instrument.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: All developers have their favorite tools and architectural approaches. For example,
    the authors are fans of reactive, streaming architectures (Mike), asynchronous
    event-driven messaging (Noel), and anything with Node.js or Emojis (Donal). The
    risk here is that your own bias may lead you down an architectural path that is
    ultimately the wrong approach.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself listening to the first 10-20 seconds of a discussion around
    a business problem and feel compelled to jump in saying Oh well, product, architecture,
    or tool X can help with this, let's face it, you may be reaching for your golden
    hammer.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Resumé-Driven Development
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many times, we''ve been involved in discussions around a technology being used
    in a customer solution that is either out of place or just doesn''t quite fit
    the problem they''re trying to address. We often discover that someone had introduced
    this technology as they were keen to learn it and somehow it went from a technical
    experiment or spike to a core component technology. There''s absolutely nothing
    wrong with technology experimentation; it should be encouraged, but care should
    be applied to ensure that a chosen technology doesn''t lead to a dead end or become
    a technology solution looking for a problem. Examples of technologies where we''ve
    seen this include Service Mesh and others as depicted in *Figure 7.29*:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_07_28.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.29: Adopting the coolest tech on the block'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Wear Different Hats
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Software architecture has to work well from multiple perspectives, not just
    from the design and build viewpoint. Different teams/personas will have different
    perspectives, for example, deployment, testing, and operational management. A
    *good* software architecture will try to address as many of these concerns as
    possible.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Social Media-Driven Development — Keeping Up with the Cool Kids
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Companies such as Google, Amazon, and Microsoft produce and utilize some amazing
    technology and techniques. These are often focused on the size of the problems
    that these hyper-scalers face. Most of us never work with that scale of complexity
    or user demand, so care should be taken that you judge technology on your particular
    business needs rather than what is the tech *du jour* that the *cool* kids are
    using. One area where we observe this a lot is in the *monolith versus microservices*
    discussion. Both are very relevant and very valid approaches to software architecture.
    Both have their pros and cons, but the correct approach to take is to ask yourself
    what is best for the business and customers that adds value.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Good Service Design
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Good service design can be hard to achieve. Ultimately, we should always lower
    the operational burden of our applications. We can do this by designing them so
    that we minimize the cost of change of any given application. Modern applications
    are normally broken down into different components or services that expose methods
    or functions. At the heart of good system architecture is service design. This
    is often based on practices such as **Domain-Driven Design** (**DDD**), which
    is fundamentally about understanding a business problem and communicating that
    understanding among the team in an unambiguous way. Services that are part of
    the same business domain are grouped together, like our Tournament Service in
    PetBattle V2, or our Cat Service in our hobbyist application. We can achieve good
    service design by following these two principles:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '**Loose coupling**: When a change to one service does not require a change
    to another service. By designing loosely coupled service APIs, we can deploy service
    changes easily. The interior design of the service may be changed completely without
    API consumers being affected.'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High cohesion**: We want related system behavior to sit together and unrelated
    behavior to sit elsewhere. Our order management system is independent of our shipping
    and delivery system. This lowers the cognitive load for developers because related
    system functionality sits together. Often there is design tension here between
    defining related business system domains (using DDD, for example) and reusable
    technical functionality, such as libraries or APIs, that may span multiple systems.'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical Design Group-Think
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have talked about some anti-patterns when designing systems in general. Another
    bit of advice is for technical leaders to set directions and not just descriptions
    of what to do or of what has been. One way to help achieve this is an exercise
    in parallel thinking, whereby everyone contributes their ideas collaboratively
    and at the same time, rather than just following the one way of thinking from
    the most senior in the team. The emphasis is on *what can be*, not *what is*,
    to help design a way forward. It is not about who is right and who is wrong.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: Human Resources and Time Are Your Most Valuable Assets
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In knowledge-based work, humans are usually the most expensive resource. So,
    it makes sense to strive to reduce toil or undifferentiated manual work. This
    is a never-ending trend to automate all the things, which allows much better quality
    and feedback for our products.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Information Leakage – Data Centricity Matters
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In tech, we are flooded with data. But do we make the best use of all the data
    available in our applications and systems? When architecting, we have to consider
    carefully the quantity and quality of data available within our applications and
    infrastructure. Often, engineering decisions and trade-offs must be made that
    move data processing nearer edge devices just because sending all that data back
    to a central processing core is not physically possible because of bandwidth or
    latency restrictions, or it is just too costly to move all that data around (think
    cloud!). So, when designing systems, consider when:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: Data integrity is lost during data capture
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data is not streamed or stored at all
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data is not accessible for other uses
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data is not analyzed at all
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data is not communicated and remains hidden
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data is not used in decision-making
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We often forget to think about how much data is lost – the lost data can be
    a massive source of lost opportunity for our business. This happens in cloud,
    IoT, industrial, and even mobile web use cases with processing data on our mobile
    phones.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Some Final Musings on Architecture
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Architecture is a critical concern when building software systems. Getting it
    right is a continuous balancing act of reviewing current and potential future
    requirements and assessing how the architecture fits those requirements.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: A certain degree of upfront architecture and design work is always needed, and
    it should be accompanied by flexibility and honesty to ensure that the initial
    architecture can change as answers to uncertain questions are discovered and more
    information is added to the collective understanding of the problems at hand.
    The ability to constantly improve the architecture throughout the product life
    cycle is another important goal.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'One quote that comes to mind when we talk about big upfront decisions is the
    following famous quote from a Prussian field marshal: *No plan survives contact
    with the enemy. – Helmuth von Moltke*. Or, in more modern terms: *Everyone has
    a plan till they get punched in the mouth. – Mike Tyson*.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Flexibility, adaptability, and the willingness to change are key characteristics
    required for success in dynamic environments. In summary, there are many architectural
    considerations that the team needs to consider as their applications scale and
    adapt to change. By experimenting and adapting the architecture as the business
    needs change, they will be better able to deliver the service SLAs that were promised
    and ultimately evolve the user experience to be optimal.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we continued our exploration of technical practices to create
    a solid foundation for us to be able to deliver at speed as one single cohesive
    unit. By using techniques such as the Big Picture to gain a shared understanding
    of our delivery pipelines, we further identified methods for testing and how we
    can connect the business to the acceptance tests in a way that's more developer-
    and business-friendly.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_07_29.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.30: Adding more technical practices to the foundation'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: As we explored lessons that led us to an emerging architecture approach, we
    also learned that a lot of the magic is in having the conversation to begin with.
    Treating the whole of your IT organization as a satellite will not be effective;
    we must create an environment where we can succeed as a whole. Key to this is
    bringing together the people with the knowledge, and the people with authority
    and power.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: In later chapters, we will go more in-depth into the technical implementation
    of PetBattle.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: 'To close off this section, we have now built a solid foundation of culture,
    leadership, and technical excellence. We have put in place principles and practices,
    including:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: Autonomy, mastery, and purpose
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Psychological safety
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Social contracts, stop-the-world events, real-time retrospectives, team identity,
    and information radiation
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leadership intent and team empowerment
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Priority sliders
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Team spaces
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything as code
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration, continuous delivery, and continuous deployment
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test automation
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emerging architecture
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B16297_07_30.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.31: The foundation of culture and technical practices'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: Our foundation is strong. It will need continuous nurturing and bolstering as
    we build products on top of it. However, we're good to go with our first product
    teams. In the next chapter, we'll explore some practices we can use for continuous
    product discovery.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
