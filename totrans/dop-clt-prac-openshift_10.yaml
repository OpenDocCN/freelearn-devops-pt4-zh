- en: 7\. Open Technical Practices — The Midpoint
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 开放技术实践——中期
- en: In this chapter, we are going to build on the foundational technical practices
    that we started in the previous chapter. We will acquire a shared understanding
    of our software delivery pipeline using the Big Picture practice. Even the less
    technical team members will be able to follow what happens to our software as
    it is being written and delivered.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续上一章中开始的基础技术实践。我们将通过大局观实践，获得对我们软件交付管道的共享理解。即便是技术不太熟悉的团队成员，也能跟得上我们的软件在编写和交付过程中的变化。
- en: We will then explain a technique that allows DevOps teams to deliver software
    changes using Git as the driving tool. The practice of GitOps leads to greater
    visibility of changes within our system, allowing the team to debug and resolve
    issues faster. We will explore how to improve our code quality through test automation
    and conclude this chapter by asking the question *How do we know if our architecture
    is good?*
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将解释一种技术，允许DevOps团队使用Git作为驱动工具来交付软件变更。GitOps的实践有助于提升我们系统中变更的可见性，使团队能够更快地调试和解决问题。我们将探讨如何通过自动化测试提高代码质量，并通过提问*我们的架构是否优秀？*来总结本章内容。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The Big Picture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大局观
- en: GitOps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitOps
- en: Testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Emerging architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新兴架构
- en: The Big Picture
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大局观
- en: An Open Technical practice that costs little to produce but is great in creating
    a shared understanding of part of a system is the Big Picture workshop. It is
    a simple practice used to visualize all the steps that a software pipeline goes
    through in moving code from source (for example, Git), through compile and test,
    and then into the hands of our happy users. Building it collaboratively is a great
    activity for a team to do as it helps to bridge the gap between techies and business
    folks. It's great for articulating the importance and sometimes the complexity
    of continuous delivery.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一种成本低廉、但能很好地创建系统共享理解的开放技术实践是大局观工作坊。这是一个简单的实践，用来可视化软件管道中所有步骤，从源代码（例如Git）开始，到编译和测试，再到最后交付给我们的用户。团队协作地构建大局观是一个极好的活动，能够弥合技术人员与业务人员之间的差距。它非常适合阐明持续交付的重要性以及其中的复杂性。
- en: '![](img/B16297_07_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_01.jpg)'
- en: 'Figure 7.1: The Big Picture'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：大局观
- en: A Big Picture can easily be created with just some stickies and a clear board
    or space. Of course, if you're feeling more artistic, it can also be doodled!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 大局观可以通过简单的便签和一个清晰的板子或空间轻松创建。当然，如果你更具艺术天赋，也可以用涂鸦方式画出来！
- en: '![](img/B16297_07_02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_02.jpg)'
- en: 'Figure 7.2: An example Big Picture'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：一个大局观示例
- en: 'You may be reading this and thinking *Sounds fluffy to me – why should I bother
    to make one?* Here''s why:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在读到这里时会想，*这听起来很空泛——我为什么要费心做一个大局观？* 下面是原因：
- en: '**Shared understanding**: When the whole team collaborates around making the
    Big Picture, they get a shared sense of how their pipelines connect code to users.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享理解**：当整个团队围绕大局观进行协作时，他们会对管道如何将代码与用户连接产生共享的理解。'
- en: '**Prototype quickly**: It''s cheaper to write and draw before implementing
    a single line of code! Rapidly prototype with some markers and Post-Its, moving
    stages of your pen and paper pipeline.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速原型**：在实现任何一行代码之前，先写下来或画出来更便宜！快速原型设计，用标记笔和便签纸，移动笔和纸管道的各个阶段。'
- en: '**Complexity simplified**: The Big Picture helps bring non-techies into the
    mix by showing them the components required to manage the software life cycle.
    Build it up one step at a time to demonstrate the complexity in a simple visual
    flow.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化复杂性**：大局观通过展示管理软件生命周期所需的组件，帮助非技术人员更好地理解整个过程。一步步构建，展示复杂性，同时保持简单直观的视觉流。'
- en: '**Information radiator**: Like all these practices, the Big Picture is an evolving
    artifact. As the complexity of a software delivery pipeline grows, the Big Picture
    should be updated to reflect this. It is a graphic that can be displayed to all
    and should not be hidden.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息辐射器**：和所有这些实践一样，大局观是一个不断发展的成果。随着软件交付管道的复杂性增长，大局观应当及时更新以反映这一变化。它是一个可以公开展示的图形，不应被隐藏。'
- en: '![](img/B16297_07_03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_03.jpg)'
- en: 'Figure 7.3: Collaborating to get a shared understanding of the Big Picture'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：协作以达成大局观的共享理解
- en: Big Pictures can also be drawn using online collaboration tools. We used Miro
    to draw the following digital Big Picture online.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 大局观也可以使用在线协作工具绘制。我们使用了Miro来绘制以下数字化的大局观。
- en: '![](img/B16297_07_04.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_04.jpg)'
- en: 'Figure 7.4: A digital Big Picture'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：数字“大图”
- en: 'The material required for this practice is fairly simple: some stickies, marker
    pens, painters'' tape, and a big blank wall or canvas are all that''s required,
    and these are fairly common things to have in our kit bags! There are a number
    of simple steps to follow in creating your Big Picture, but let''s use our PetBattle
    example to show how a team might use this in practice.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 创建“大图”所需的材料相当简单：一些便签、马克笔、油漆胶带以及一面大空白墙或画布，这些都是我们常见的工具！创建“大图”有一些简单的步骤，但让我们通过 PetBattle
    示例来展示团队如何在实际中使用它。
- en: PetBattle – Building a Big Picture
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PetBattle – 构建“大图”
- en: The PetBattle Techies decided to build a Big Picture to demonstrate their proposal
    for how the software should be built, tested, and deployed via some automation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: PetBattle 技术团队决定构建一个“大图”来展示他们关于软件如何通过一些自动化构建、测试和部署的提案。
- en: First, they invite all the others in the team to help explain some of the technology
    and complexity of the automation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，他们邀请团队中的其他成员帮助解释一些自动化技术和复杂性。
- en: 'They use painters'' tape to form a large box that represents the cloud and
    another box inside it to represent the OpenShift cluster they''re going to use
    (deployed in the cloud). In this case, the metaphor is: OpenShift is just a big
    box where we can put some things running in the cloud. The box is so large that
    we can fill it with all the things we could possibly want, from sandboxes, to
    tooling, to production apps.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 他们用油漆胶带形成一个大框，代表云环境，框内再画一个小框，代表他们将使用的 OpenShift 集群（部署在云中）。在这种情况下，比喻是：OpenShift
    就是一个大框，我们可以将一些在云中运行的东西放进去。这个框非常大，可以填满我们可能需要的所有东西，从沙箱、工具到生产应用。
- en: '![](img/B16297_07_05.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_05.jpg)'
- en: 'Figure 7.5: Starting the PetBattle Big Picture'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5：启动 PetBattle“大图”
- en: They draw a box to the left side to represent their local development environment.
    This is their laptop for now, but it could also be a cloud-hosted IDE that the
    development team could write their code in that is deployed inside the cluster.
    One such product, CodeReadyWorkspaces, is a cloud-hosted IDE that runs in the
    OpenShift cluster that could be of great use to the team. Using an IDE like this
    allows us to further our everything-as-code practice by providing developers with
    their coding environment as a code artifact.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 他们在左侧画一个框，表示他们的本地开发环境。目前这是他们的笔记本电脑，但它也可以是一个云托管的 IDE，开发团队可以在其中编写代码，并且该 IDE 被部署在集群内。CodeReadyWorkspaces
    就是一个这样的产品，它是一个云托管的 IDE，运行在 OpenShift 集群内，对团队可能非常有用。使用这样的 IDE 可以通过提供作为代码工件的开发环境来进一步推动我们的“万物皆代码”实践。
- en: 'Next, they slice up the OpenShift cluster into smaller boxes. Each of these
    represents the OpenShift projects (or Kubernetes namespaces). We can think of
    these projects as rooms that separate one collection of applications from another.
    To keep things simple, the team decides on four namespaces initially:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，他们将 OpenShift 集群划分成更小的部分。每个部分代表一个 OpenShift 项目（或 Kubernetes 命名空间）。我们可以将这些项目视为将一个应用集合与另一个应用集合分开的房间。为了简化问题，团队决定最初使用四个命名空间：
- en: '![](img/B16297_07_06.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_06.jpg)'
- en: 'Figure 7.6: PetBattle Big Picture projects'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6：PetBattle“大图”项目
- en: '**Dev**: A sandbox project for the dev team to validate their app or get fast
    feedback from.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发**：开发团队用来验证他们的应用或快速获取反馈的沙箱项目。'
- en: '**Test**: A project to deploy all our applications to and run our system tests
    against.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：一个用于部署所有应用并进行系统测试的项目。'
- en: '**Production**: The project that PetBattle''s customers will use to access
    the applications once they''ve cleared our tests.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产**：PetBattle 客户在通过我们的测试后用来访问应用的项目。'
- en: '**CI-CD**: The project that houses all the tooling that supports **Continuous
    Integration** (**CI**) and **Continuous Delivery** (**CD**).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CI-CD**：包含所有支持 **持续集成**（**CI**）和 **持续交付**（**CD**）工具的项目。'
- en: With the OpenShift cluster logically sliced up into the projects the teams will
    use, the team draws the tools they will use in each project.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 OpenShift 集群逻辑划分为团队将使用的项目后，团队在每个项目中绘制出他们将使用的工具。
- en: '![](img/B16297_07_07.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_07.jpg)'
- en: 'Figure 7.7: PetBattle Big Picture initial frameworks'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7：PetBattle“大图”初步框架
- en: Starting with their *local* development environment – in other words, their
    laptops or cloud-hosted workspace – the existing PetBattle is built using Angular
    (a JavaScript framework for building web apps) for the frontend. Quarkus (supersonic
    Java) is used for the API layer, and MongoDB for the persistence layer, so they
    add each of these tools to their workspace and write a one-line definition for
    how the tool or framework is being used by this team.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从他们的*本地*开发环境开始——换句话说，就是他们的笔记本电脑或云托管的工作空间——现有的PetBattle是使用Angular（一个用于构建Web应用的JavaScript框架）来构建前端的。API层使用Quarkus（超声速Java），持久化层使用MongoDB，因此他们将这些工具添加到工作空间，并写下一行定义，说明该团队是如何使用这些工具或框架的。
- en: For PetBattle, we are going to use Helm to package up all the Kubernetes resources
    (Deployments, ConfigMaps, and so on) used to manage the application topology.
    We'll also use ArgoCD, a GitOps tool to manage our config-as-code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于PetBattle，我们将使用Helm将所有用于管理应用拓扑的Kubernetes资源（部署、配置映射等）打包。我们还将使用ArgoCD，这是一种GitOps工具，用于管理我们的配置即代码。
- en: '![](img/B16297_07_08.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_08.jpg)'
- en: 'Figure 7.8: PetBattle Big Picture source code and registry'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：PetBattle大图源代码和注册表
- en: PetBattle will use GitHub to store its source code. When building images, it
    is likely the team will need to store the built image internally on the OpenShift
    cluster using the internal registry. The team also wants to make their images
    available externally and so have decided to also make use of [Quay.io](http://Quay.io),
    an external registry hosted in the public cloud.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: PetBattle将使用GitHub存储其源代码。在构建镜像时，团队很可能需要使用内部注册表将构建好的镜像存储在OpenShift集群内。团队还希望将镜像对外提供，因此决定同时使用[Quay.io](http://Quay.io)，一个托管在公共云中的外部注册表。
- en: '![](img/B16297_07_09.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_09.jpg)'
- en: 'Figure 7.9: PetBattle Big Picture pipeline tools'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9：PetBattle大图管道工具
- en: The team then starts to add the tooling they will use to create their pipelines
    in their CI/CD namespace. They use more stickies to draw the tools and add a one-liner
    definition of what each tool is or how they will use it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，团队开始在其CI/CD命名空间中添加他们将用于创建管道的工具。他们使用更多便利贴来绘制这些工具，并为每个工具写一个简短的定义，说明它是什么或者他们将如何使用它。
- en: For example, the team is going to use Jenkins for their build and test automation.
    To store and cache application build dependencies and artifacts, the team opted
    to use the open-source artifact repository called Nexus. For Nexus, they add a
    simple one-liner to highlight the fact that it is used to house their software
    artifacts as well as their Helm repository. Shared understanding is key here,
    so it's important for the team to make sure everyone is aware what the purpose
    of each item is – this includes the product owner, designers, and all other interested
    parties. They don't need to be experts, but having an understanding of what the
    tools are used for can help them establish better empathy with the development
    team and see for themselves all the things needed to be able to ship code so quickly
    to users.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，团队将使用Jenkins进行构建和测试自动化。为了存储和缓存应用程序构建依赖项和工件，团队选择使用开源的工件库——Nexus。对于Nexus，他们添加了一个简单的一行定义，强调它用于存放他们的软件工件以及Helm库。共享理解是关键，因此团队需要确保每个人都清楚每个项目的目的——这包括产品负责人、设计师和所有其他相关方。他们不需要成为专家，但了解工具的用途有助于他们与开发团队建立更好的共鸣，亲身了解需要做些什么才能迅速将代码交付给用户。
- en: With some of the tools in place on the Big Picture, the PetBattle team can now
    start to implement the design they've put in place.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在大图上放置了一些工具后，PetBattle团队现在可以开始实施他们已经设定的设计。
- en: The Big Picture can be created in a physical room with lots of colorful sticky
    notes or with everyone distributed using a tool such as Mural, Miro, PowerPoint
    or Google Slides. We have provided a useful template with all the icons we use
    which should help you get started. You can download this from the book's GitHub
    repository.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个大图可以通过在一个充满五颜六色便利贴的实际房间里创建，或者使用Mural、Miro、PowerPoint或Google Slides等工具进行远程协作。我们提供了一个有用的模板，其中包含我们使用的所有图标，应该能帮助你开始。你可以从本书的GitHub仓库下载这个模板。
- en: '![](img/B16297_07_10.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_10.jpg)'
- en: 'Figure 7.10: The Big Picture template'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：大图模板
- en: You can download this from the book's GitHub repository.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从本书的GitHub仓库下载此文件。
- en: The Big Picture allows us to get a shared understanding and team alignment around
    the use of technical tools at a high level. Like all the practices we put in place
    in this book, the Big Picture is not a one-time thing. The Big Picture is a tool
    we will revisit and enhance as we add more complexity to our architecture and
    begin implementing our pipelines. We will continue to explore the Big Picture
    in *Section 6, Build It, Run It, Own It*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 大局观使我们能够在高层次上对使用技术工具达成共识并进行团队对齐。就像我们在本书中介绍的所有实践一样，大局观不是一次性的。大局观是一个我们将不断回顾和完善的工具，随着我们向架构中添加更多复杂性并开始实施流水线，我们将不断完善它。我们将在*第六部分：构建、运行、拥有*中继续探讨大局观。
- en: You can learn more about, and collaborate on, Big Picture practices by going
    to the Open Practice Library page at [https://openpracticelibrary.com/practice/the-big-picture/](https://openpracticelibrary.com/practice/the-big-picture/).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问[https://openpracticelibrary.com/practice/the-big-picture/](https://openpracticelibrary.com/practice/the-big-picture/)页面，了解更多关于大局观的实践并进行合作。
- en: GitOps
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitOps
- en: Up to this point, we've talked about Git and the developer workflows available
    to our teams. We've spoken about everything-as-code, from infrastructure to tooling
    to applications all along the stack. Now, let's tie this all together with GitOps.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了Git以及为团队提供的开发工作流。我们谈到了全代码化，从基础设施到工具，再到整个堆栈中的应用程序。现在，让我们通过GitOps将这一切结合起来。
- en: GitOps sounds a bit like a buzzword, as DevOps was when it was first coined.
    In fact, we heard someone describe it to us as DevOps for the year 2020\. GitOps
    is a simple process of managing all of your systems, environments, and applications
    via Git. Git represents the single source of truth for all your applications,
    your tooling, and even your clusters. Changes to any of these things can be pull
    requested and discussed before an automated process applies them.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps听起来有点像流行词，就像DevOps在最初被提出时一样。事实上，我们曾听到有人这样描述它：GitOps是2020年的DevOps。GitOps是通过Git管理所有系统、环境和应用程序的简单过程。Git代表了所有应用程序、工具甚至集群的唯一真实来源。对这些任何内容的更改都可以通过拉取请求来提交并进行讨论，之后自动化过程会应用这些更改。
- en: The difference between **infrastructure-as-code** (**IaC**) and GitOps is the
    approach to managing the configuration. IaC is agnostic to where you store the
    configuration; it could be on a flash drive in your drawer or it could be a shared
    drive in the cloud. GitOps, as the name suggests, means storing the full system
    specifications in Git.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**基础设施即代码**（**IaC**）和GitOps的区别在于管理配置的方式。IaC与配置存储的位置无关；它可以存储在你抽屉里的U盘上，也可以存储在云中的共享驱动器上。而GitOps，顾名思义，是指将完整的系统规范存储在Git中。'
- en: The same principles hold true for IaC and GitOps – ideally, every action should
    be idempotent. Every action or operation can be applied multiple times, producing
    the exact same result. This is a very useful property in many situations, as it
    means that an operation can be repeated or retried as often as necessary without
    causing unintended effects. Configuration should be created declaratively. That
    is to say, you write the configuration to describe the desired state of an application
    or set of apps.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: IaC和GitOps的原则是相同的——理想情况下，每个操作应该是幂等的。每个操作或行为可以应用多次，产生完全相同的结果。这在许多情况下非常有用，因为它意味着可以根据需要重复或重试操作，而不会产生意外效果。配置应该声明性地创建。也就是说，你写下配置来描述应用程序或一组应用程序的期望状态。
- en: GitOps can be seen as a developer-centric approach to Ops. It teaches developers
    good practices around taking ownership of code once it leaves their machines and
    the approach to deploying and monitoring this code once it's running.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps可以看作是一个面向开发人员的运维方法。它教会开发人员在代码离开他们的机器后如何接管代码，并指导他们如何部署和监控运行中的代码。
- en: As developers, we hate repeating ourselves, so much so that we even have an
    acronym for it – DRY = don't repeat yourself! When encountering something that
    needs to be done more than once, our first instinct should be to try to automate
    it. Once something is automated or repeatable, the next step is simple. Check
    it into Git so that it can be audited, shared, and managed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，我们讨厌重复自己，甚至为此创造了一个缩写——DRY = Don't Repeat Yourself（不要重复自己）！当遇到需要做多次的事情时，我们的第一反应应该是尽量将其自动化。一旦某件事被自动化或变得可重复，下一步就是简单的操作。将其提交到Git中，这样它就可以被审计、共享和管理。
- en: For example, whenever we want to deploy a new application to OpenShift, we could
    run some manual commands to spin up the application, create services and routes,
    and even bind a ConfigMap. But taking the time to create a Helm chart for this
    is reusable and repeatable. We can design the final state of the application in
    code and then check this into Git instead. This is a more cloud-native way of
    writing and managing our application code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，每当我们想要将一个新的应用部署到 OpenShift 时，我们可以运行一些手动命令来启动应用、创建服务和路由，甚至绑定一个 ConfigMap。但花时间为此创建一个
    Helm 图表是可重用且可重复的。我们可以在代码中设计应用的最终状态，然后将其检查到 Git 中。这是一种更符合云原生方式的应用代码编写和管理方法。
- en: To implement a GitOps approach to our Helm chart example, all we need to do
    is connect a tool to the Git repository, which can be alerted or watch for changes
    coming through. When those changes arrive, this tool can assess the difference
    between what the current state is and what state is desired and apply the changes
    automatically for us. Enter ArgoCD.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 GitOps 方法应用于我们的 Helm 图表示例，我们只需将一个工具连接到 Git 仓库，该工具可以被提醒或监视变化。当变化到来时，该工具可以评估当前状态与所需状态之间的差异，并自动为我们应用这些变化。进入
    ArgoCD。
- en: ArgoCD
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ArgoCD
- en: 'From ArgoCD''s website, this is described as a tool that:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 ArgoCD 网站的描述，这是一个被定义为：
- en: '*automates the deployment of the desired application states in the specified
    target environments. Application deployments can track updates to branches, tags,
    or be pinned to a specific version of manifests at a Git commit*.[1](#footnote-029)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*自动化在指定目标环境中部署所需的应用状态。应用部署可以跟踪分支、标签的更新，或固定到某个特定的 Git 提交版本的清单*。[1](#footnote-029)'
- en: When something is seen as not matching the required state in Git, an application
    becomes out of sync. Depending on how you have implemented your GitOps, ArgoCD
    can then resync the changes to apply whatever is in Git immediately or fire a
    warning to initiate some other workflow. In the world of Continuous Delivery as
    implemented by ArgoCD, Git is the single source of truth, so we should always
    apply the changes as seen there.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当某个状态在 Git 中与所需状态不匹配时，应用会变得不同步。根据你实施 GitOps 的方式，ArgoCD 可以重新同步更改，立即应用 Git 中的内容，或者触发警告以启动其他工作流。在
    ArgoCD 实现的持续交付世界中，Git 是唯一的真实来源，因此我们应该始终按 Git 中的内容应用更改。
- en: What types of things can ArgoCD apply? ArgoCD recognizes traditional Kubernetes
    YAML, Kustomize,[2](#footnote-028) Helm, and all sorts of other things. Unlike
    Helm, which uses templating heavily, Kustomize allows you to take YAML files and
    emits text in a template-free declarative way. You can patch Kubernetes resources
    and use folder-based structures to apply what is termed an overlay or YAML override,
    which emits text, leaving the original YAML untouched. For our purposes, we will
    stick to Helm and a little bit of Kustomize where appropriate.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ArgoCD 可以应用哪些类型的内容？ArgoCD 识别传统的 Kubernetes YAML、Kustomize，[2](#footnote-028)
    Helm 以及其他各种内容。与 heavily 使用模板的 Helm 不同，Kustomize 允许你使用 YAML 文件，并以无需模板的声明方式输出文本。你可以修补
    Kubernetes 资源，并使用基于文件夹的结构应用所谓的覆盖或 YAML 覆盖，这会输出文本，保持原始 YAML 不变。就我们而言，我们将主要使用 Helm
    和适当的 Kustomize。
- en: ArgoCD is another tool (and there are others like it, such as Flux) in the long
    list of tools that we need to be able to implement CI and CD. Unlike Jenkins,
    which we could also use to manage our application deployments, ArgoCD is specialized
    and very good at managing and maintaining just our deployments.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ArgoCD 是一个工具（还有像 Flux 这样的其他工具）在我们实现 CI 和 CD 时所需要的一长串工具中的一员。与我们也可以用来管理应用部署的 Jenkins
    不同，ArgoCD 专注并且非常擅长仅管理和维护我们的部署。
- en: '[1](#footnote-029-backlink) [https://argo-cd.readthedocs.io/en/stable/](https://argo-cd.readthedocs.io/en/stable/)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](#footnote-029-backlink) [https://argo-cd.readthedocs.io/en/stable/](https://argo-cd.readthedocs.io/en/stable/)'
- en: '[2](#footnote-028-backlink) [https://github.com/kubernetes-sigs/kustomize](https://github.com/kubernetes-sigs/kustomize)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[2](#footnote-028-backlink) [https://github.com/kubernetes-sigs/kustomize](https://github.com/kubernetes-sigs/kustomize)'
- en: Jenkins could apply our Helm charts in a done once and finish sort of way. It
    doesn't have the capability to keep watching our Kubernetes resources to ensure
    the desired state in Git stays that way in our clusters. If someone decides to
    change something in the cluster, for example, add a new environment variable to
    a running application, ArgoCD will detect that change and overwrite it. This means
    no more one-of-a-kind deployments or manual tweaks once they're deployed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins可以一次性应用我们的Helm charts，类似于“完成后就结束”的方式。它没有能力持续监控我们的Kubernetes资源，以确保Git中的期望状态在集群中保持不变。如果有人决定改变集群中的某些内容，比如向正在运行的应用程序添加一个新环境变量，ArgoCD会检测到这一变化并覆盖它。这意味着一旦部署后，就不会再有独一无二的部署或手动调整。
- en: ArgoCD enables teams to enforce this golden rule – if it's not in Git, it's
    not real. This is perfect for audit tasks – all you have to do is check the Git
    log to see who committed and pushed the code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ArgoCD使团队能够强制执行这一黄金法则——如果它不在Git中，那就不是真的。这对于审计任务非常完美——你所需要做的就是检查Git日志，看看是谁提交并推送了代码。
- en: If It's Not in Git, It's Not Real!
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果不在Git中，那就不是真的！
- en: '![](img/Author_21.jpg)![](img/Author_41.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Author_21.jpg)![](img/Author_41.jpg)'
- en: We worked on a virtual residency with the World Health Organization helping
    to manage the COVID-19 crisis. We were building a new platform to help educate
    people in the field and disseminate information faster. We decided to use GitOps
    to do Continuous Delivery and, in particular, used ArgoCD to manage our Helm charts.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与世界卫生组织合作进行虚拟驻地，帮助管理COVID-19危机。我们正在建设一个新的平台，以帮助现场人员进行教育，并加速信息传播。我们决定使用GitOps进行持续交付，特别是使用ArgoCD来管理我们的Helm
    charts。
- en: To do cloud-native properly, namespaces and environments should be ephemeral.
    We should be able to recreate everything of use to us from their description in
    code. This includes namespaces, quotas, and role bindings, as well as applications
    and databases. To prove this in one sprint, we created a cleanup job that would
    delete the dev and test projects in OpenShift. Our configuration repository was
    linked to ArgoCD, which watched the cluster and, if anything changed, it was set
    to reapply the resources as described in Git. The time for this job to execute
    was on a Wednesday afternoon around lunchtime, about an hour before our sprint
    review. What could possibly go wrong?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正做到云原生，命名空间和环境应该是短暂的。我们应该能够从代码中的描述重新创建所有对我们有用的内容。这包括命名空间、配额和角色绑定，以及应用程序和数据库。为了在一个冲刺周期内证明这一点，我们创建了一个清理任务，用来删除OpenShift中的开发和测试项目。我们的配置库链接到ArgoCD，ArgoCD监控集群，并在任何变化发生时，重新应用Git中描述的资源。这个任务的执行时间定在周三下午午餐时间，约在冲刺评审前一个小时。可能出现什么问题呢？
- en: The team got ready to do their demo as normal, but about 20 mins before showtime,
    one team member called out that the build was failing and his demo was broken
    and he could not figure out why. The team scrambled to sort the issue, with everyone
    jumping on a call and mobbing around the problem. Rewinding what could have changed
    in the past hour, the only thing that had executed was the cleanup job we had
    written. We immediately thought we'd written something incorrectly with our job
    and so went to debug it, but it was fine. The next step was to look more closely
    at the build and the failure message.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 团队像往常一样准备进行演示，但在演示开始前约20分钟，其中一名团队成员喊道构建失败，他的演示坏了，而且他找不出原因。团队迅速行动，大家都加入了电话会议，共同解决问题。在回顾过去一小时可能发生的变化时，唯一执行的任务就是我们写的清理工作。我们立刻认为是我们在工作中写错了什么，于是去调试它，但一切正常。接下来的步骤是更加仔细地查看构建和错误信息。
- en: At this point, we discovered someone on the team had manually deployed a database
    to the dev environment. They were connecting to it for their demo AND using it
    as the test database in our Jenkins Pipelines. Essentially, someone on the team
    had created a Pet – a hand-reared server that was cared for and nurtured by one
    person and not known about by the rest of the team. In the world of ephemeral
    environments, what we really want is Cattle. Cattle are mass-produced, created
    using automation, and killed off when no longer required. Hence, when our job
    ran to clear out the project, all resources were destroyed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到这时，我们发现团队中的某个人手动将数据库部署到了开发环境。他们正在连接到它进行演示，并将其作为我们Jenkins流水线中的测试数据库。实际上，团队中的某人创建了一个“宠物”——一个由某个人精心照料和培养的服务器，其他人对此一无所知。在短命环境的世界中，我们真正需要的是“牛”。“牛”是大规模生产的，通过自动化创建，并在不再需要时被销毁。因此，当我们的工作运行并清理项目时，所有资源都被销毁了。
- en: 'The team learned a valuable lesson in this experience which they made very
    visible:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 团队从这次经验中学到了一个宝贵的教训，并且他们将这一点非常显著地展示了出来：
- en: '![](img/B16297_07_11.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_11.jpg)'
- en: 'Figure 7.11: If it''s not in Git, it''s not real'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11：如果它不在 Git 中，它就不真实
- en: It gave rise to a mantra we added to our social contract from *Chapter 4, Open
    Culture.*
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了一句口号，我们将其加入到我们的社会契约中，来自 *第 4 章，开放文化*。
- en: Implementing GitOps
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 GitOps
- en: '![](img/Techie1.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Techie1.jpg)'
- en: Let's build the big picture with some real working code! In this section, we
    are going to take a technical detour! Prepare for some code snippets. If this
    is not your thing, feel free to skip over it to the next section all about testing!
    We'll mark any section that's going to have code snippets with this handy sign.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一些真正可工作的代码来构建大局！在这一节中，我们将进行一个技术绕行！准备好一些代码片段。如果这不是你的兴趣，随时可以跳过，直接进入下一个全是关于测试的章节！我们会用这个方便的标志标记任何包含代码片段的部分。
- en: Let's explore ArgoCD and create the components of our Big Picture from code.
    To do this, we will first explore a sample project that can be used as a starting
    point for development.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索 ArgoCD，并从代码中创建我们大局的组件。为此，我们将首先探索一个可以作为开发起点的示例项目。
- en: At Red Hat Open Innovation Labs, we have automated the bootstrap of Labs Residency
    CI-CD tooling to accelerate setup and onboarding. The code repository is called
    Ubiquitous Journey, so it makes sense for us to start here. We will explore this
    repository and set up our technical foundation using it. In later sections of
    the book, we will extend it with new technology and tools. This repo is available
    on the PetBattle GitHub organization – [https://github.com/petbattle/ubiquitous-journey](https://github.com/petbattle/ubiquitous-journey).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Red Hat 开放创新实验室，我们已经实现了 Labs Residency CI-CD 工具的自动化引导，以加速设置和入职。代码库名为 Ubiquitous
    Journey，因此从这里开始是合适的。我们将探索这个代码库，并使用它建立我们的技术基础。在本书的后续章节中，我们将使用新技术和工具扩展它。这个代码库可以在
    PetBattle GitHub 组织中找到 – [https://github.com/petbattle/ubiquitous-journey](https://github.com/petbattle/ubiquitous-journey)。
- en: The first task we would normally perform on our OpenShift cluster when deploying
    Jenkins is to create a new project using the command line. We could follow this
    manual approach again, adding in role bindings and quotas for our project, and
    repeat these steps for each bit of our Big Picture. But let's do it in a way that
    honors our everything-as-code practice.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 OpenShift 集群上部署 Jenkins 时，我们通常执行的第一个任务是使用命令行创建一个新项目。我们可以再次按照这种手动方式进行，添加角色绑定和配额，并为我们大局中的每一部分重复这些步骤。但我们决定以一种符合我们一切皆代码实践的方式来做。
- en: From your laptop, fork the sample project and open it up in your favorite code
    editor.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的笔记本电脑上，fork 这个示例项目，并在你喜欢的代码编辑器中打开它。
- en: We are going to make changes to our project so maintaining your own copy of
    it is necessary for GitOps. From here on out, when we encounter a new repo, you'll
    probably find it easier to fork it so you can make changes to it. For the purposes
    of the book going forward, we will continue using PetBattle organization so feel
    free to equate this to your own organization or user.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对项目进行更改，因此保持你自己的副本是 GitOps 所必需的。从现在开始，当我们遇到一个新的代码库时，你可能会发现通过 fork 它来进行更改会更容易。为了本书的后续内容，我们将继续使用
    PetBattle 组织，所以你可以将它等同于你自己的组织或用户。
- en: '[PRE0]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Ubiquitous Journey project is broken down into two main components (some
    of the files are removed from the breakdown below for simplicity), Bootstrap and
    Ubiquitous Journey. If you're wondering why we named the project Ubiquitous Journey…
    well, we didn't! We hit the **generate random name** button on GitHub and this
    is what it chose for us. As is the case with most things in software, naming things
    is hard! We did plan on renaming the repo at some stage, but now the name has
    kind of stuck and we like it!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Ubiquitous Journey 项目被分为两个主要组件（为简化起见，下面的分解中移除了一些文件），分别是 Bootstrap 和 Ubiquitous
    Journey。如果你在想我们为什么给这个项目命名为 Ubiquitous Journey……嗯，实际上我们并没有命名！我们按下了 GitHub 上的 **生成随机名称**
    按钮，它为我们选择了这个名字。就像大多数软件中的事情一样，命名真的很难！我们本来打算在某个阶段重命名这个代码库，但现在这个名字已经有点粘住了，我们也挺喜欢它的！
- en: '[PRE1]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The bootstrap folder contains a Helm chart definition with a values-bootstrap.yaml
    file and Chart.yaml manifest. There are no templates for this chart because it''s
    actually just a wrapper for other Helm charts. If we look at the Chart.yaml manifest,
    we can see that it has a dependency of the ArgoCD chart, another called bootstrap,
    and a helper chart called sealed-secrets. The bootstrap folder Helm chart is acting
    as a wrapper chart, allowing us to control the variables we pass to these dependencies.
    In this case, our variables are stored in the `values-bootstrap.yaml` file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 启动文件夹包含一个 Helm 图表定义，带有一个 values-bootstrap.yaml 文件和 Chart.yaml 清单。这个图表没有模板，因为它实际上只是其他
    Helm 图表的包装器。如果我们查看 Chart.yaml 清单，可以看到它依赖于 ArgoCD 图表，另一个称为 bootstrap 的图表和一个名为 sealed-secrets
    的辅助图表。启动文件夹 Helm 图表充当包装图表，允许我们控制传递给这些依赖项的变量。在这种情况下，我们的变量存储在 `values-bootstrap.yaml`
    文件中：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The bootstrap chart is responsible for creating the listed projects in our OpenShift
    cluster. In the example, these are labs-ci-cd, labs-dev, labs-test, labs-staging,
    labs-pm, and labs-cluster-ops. Dev, Test, Staging, and CI/CD will hopefully be
    self-explanatory; if not, take a look at the previous chapter, where we discussed
    CI/CD in depth. The labs-pm namespace is for deploying other project management
    tools (for example, collaboration tools such as etherpad). The labs-cluster-ops
    namespace is used for operational jobs and tasks.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 启动图表负责在我们的 OpenShift 集群中创建列出的项目。在示例中，这些项目包括 labs-ci-cd、labs-dev、labs-test、labs-staging、labs-pm
    和 labs-cluster-ops。Dev、Test、Staging 和 CI/CD 可能会很容易理解；如果不明白，请查看前一章，我们在那里深入讨论了 CI/CD。labs-pm
    命名空间用于部署其他项目管理工具（例如协作工具如 etherpad）。labs-cluster-ops 命名空间用于操作性工作和任务。
- en: Resources in OpenShift have **role-based access control** (**RBAC**) applied.[3](#footnote-027)
    RBAC determines whether a user is allowed to perform a given action within a project.
    We bind the listed user groups to the service accounts within these projects.
    Don't worry if your cluster does not have the labs-dev and labs-admin groups set
    up right now. It is enough if you are logged in to your cluster with a user who
    has cluster admin privilege.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 中的资源应用了 **基于角色的访问控制** (**RBAC**)。[3](#footnote-027) RBAC 决定用户是否被允许在项目内执行给定的操作。我们将列出的用户组绑定到这些项目内的服务帐户上。如果您的集群目前尚未设置
    labs-dev 和 labs-admin 组，不要担心。只要您以具有集群管理员特权的用户登录到您的集群中即可。
- en: '[PRE53]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[3](#footnote-027-backlink) [https://docs.openshift.com/container-platform/4.6/authentication/using-rbac.html](https://docs.openshift.com/container-platform/4.6/authentication/using-rbac.html)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[3](#footnote-027-backlink) [https://docs.openshift.com/container-platform/4.6/authentication/using-rbac.html](https://docs.openshift.com/container-platform/4.6/authentication/using-rbac.html)'
- en: The second part of this file overwrites some variables in the ArgoCD chart.
    This Helm chart installs the ArgoCD operator and configures it with sensible defaults.
    For a list of all the possible variables that could be passed to this chart, you
    can check out the Operator Docs for ArgoCD – [https://argocd-operator.readthedocs.io/en/latest/](https://argocd-operator.readthedocs.io/en/latest/).
    There is no point in recreating those docs in this book, but it's useful to have
    them saved if you want to do some exploring.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件的第二部分覆盖了 ArgoCD 图表中的一些变量。这个 Helm 图表安装了 ArgoCD 操作员，并使用合理的默认值进行配置。关于可以传递给此图表的所有可能变量的列表，您可以查看
    ArgoCD 操作员文档 - [https://argocd-operator.readthedocs.io/en/latest/](https://argocd-operator.readthedocs.io/en/latest/)。在这本书中没有重新创建这些文档的意义，但如果您想进行一些探索，保存它们是很有用的。
- en: It is worth calling out the `applicationInstanceLabelKey` variable. This needs
    to be unique for your cluster. If you deploy more than one instance of ArgoCD
    to a cluster with the same instance label, the two ArgoCD instances will try to
    manage the same resources and then they'll fight over who actually owns them and
    get you into a world of pain, so make sure the `applicationInstanceLabelKey` is
    unique!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 需要特别注意 `applicationInstanceLabelKey` 变量。这个变量在你的集群中必须是唯一的。如果你在一个集群上部署了多个 ArgoCD
    实例，并且它们的实例标签相同，那么这两个 ArgoCD 实例将尝试管理相同的资源，然后它们会争夺到底是谁真正拥有这些资源，并且会给你带来很多麻烦，所以确保
    `applicationInstanceLabelKey` 是唯一的！
- en: 'Let''s deploy this setup and see what it gives us. If you wish to change the
    names of the projects that are created, you can edit the values file, but for
    now we''ll use the defaults. In a terminal on your laptop, try the following command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们部署这个设置，看看它给我们带来了什么。如果您希望更改创建的项目名称，请编辑值文件，但现在我们将使用默认值。在您的笔记本电脑终端上，尝试以下命令：
- en: '[PRE65]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Running a Helm template like this should bring down our chart dependencies and
    process our templates. This can be a handy way to validate that the YAML file
    looks as we expect. Let's install the bootstrap Helm chart into its own namespace.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 运行像这样的 Helm 模板应该会下载我们的图表依赖项并处理我们的模板。这是验证 YAML 文件是否符合预期的便捷方式。让我们将引导 Helm 图表安装到它自己的命名空间中。
- en: '[PRE67]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The output of this command should be a successful installation of the bootstrap
    Helm chart:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出应为成功安装引导 Helm 图表：
- en: '![](img/B16297_07_12.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_12.jpg)'
- en: 'Figure 7.12: Bootstrap ArgoCD using Helm'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12：使用 Helm 引导 ArgoCD
- en: 'You can check the pods coming up with:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下命令检查正在启动的 Pod：
- en: '[PRE70]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You should start to see the ArgoCD server start to come alive after a minute
    or two:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在一两分钟后看到 ArgoCD 服务器开始启动：
- en: '![](img/B16297_07_13.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_13.jpg)'
- en: 'Figure 7.13: Labs-ci-cd namespace pods starting up'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13：Labs-ci-cd 命名空间中的 Pod 启动
- en: 'Or, if you have a look in the UI, you should see the topology with all the
    components of ArgoCD:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你查看 UI，你应该能看到包含所有 ArgoCD 组件的拓扑图：
- en: '![](img/B16297_07_14.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_14.jpg)'
- en: 'Figure 7.14: OpenShift developer topology view of the labs-ci-cd project'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14：OpenShift 开发者拓扑视图，展示 labs-ci-cd 项目
- en: 'Let''s take a look at ArgoCD by clicking the link in the UI, or you can get
    the URL from the command line using the following command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过点击 UI 中的链接来查看 ArgoCD，或者你也可以使用以下命令从命令行获取 URL：
- en: '[PRE71]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Log in with your OpenShift credentials. We should see an empty ArgoCD instance:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenShift 凭证登录。我们应该会看到一个空的 ArgoCD 实例：
- en: '![](img/B16297_07_15.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_15.jpg)'
- en: 'Figure 7.15: Empty ArgoCD instance from the web interface'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15：通过 Web 界面查看空的 ArgoCD 实例
- en: At this point, we should ask ourselves the question *What happens when someone
    changes the bootstrap configuration values for our cluster?* for example, to add
    more projects or change the roles or groups? Can we do this in an automated and
    tracked way, in other words, using GitOps? Fear not, ArgoCD to the rescue! We
    can now point ArgoCD to the Git repository we've been working on.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该问自己一个问题：*当有人更改我们集群的引导配置值时会发生什么？* 比如，添加更多项目或更改角色或组？我们能以自动化和可追踪的方式完成吗？换句话说，使用
    GitOps 可以吗？别担心，ArgoCD 来拯救我们！我们现在可以将 ArgoCD 指向我们一直在使用的 Git 仓库。
- en: 'We can create an ArgoCD application from the ArgoCD web interface by selecting
    +New App -> Edit as YAML and copying and pasting the following definition:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 ArgoCD Web 界面选择 +New App -> Edit as YAML 来创建一个 ArgoCD 应用程序，并复制粘贴以下定义：
- en: '[PRE72]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Hit Save, followed by Create. You should see the `bootstrap-journey` application
    synced:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 点击保存，然后点击创建。你应该能看到`bootstrap-journey`应用程序已同步：
- en: '![](img/B16297_07_16.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_16.jpg)'
- en: 'Figure 7.16: Bootstrap ArgoCD application from the web interface'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16：通过 Web 界面查看引导 ArgoCD 应用程序
- en: 'We can also create the same application on the terminal. You can log in using
    single sign-on to OpenShift from the terminal using this one liner. It requires
    a terminal that is not headless, in other words, it can connect to your screen
    and browser:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在终端中创建相同的应用程序。你可以使用单点登录通过终端登录到 OpenShift，使用以下一行命令。此命令需要一个非无头的终端，换句话说，它可以连接到你的屏幕和浏览器：
- en: '[PRE94]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Create the new app and sync the changes. With this in place, argocd will now
    actively track changes to our Git repository and roll them out for us! Simple!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新应用并同步更改。完成这些操作后，argocd 将会主动跟踪我们 Git 仓库中的更改并为我们部署它们！很简单！
- en: '[PRE97]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'You can select the application in the web interface to drill down into it:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Web 界面中选择应用程序，进入其详细信息：
- en: '![](img/B16297_07_17.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_17.jpg)'
- en: 'Figure 7.17: Bootstrap application details from the web interface'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17：通过 Web 界面查看引导应用程序的详细信息
- en: Excellent – we are on our way to completing our Big Picture as code and laying
    down our technical foundation! We've created the projects and added the first
    tool, ArgoCD, to our kit bag. Now, let's take it a step further and fill our cluster
    with some of the applications we think would be initially useful for building
    out CI/CD pipelines. At the beginning of any project, this will usually be a best
    guess. As we start to build out the product, we must continuously evolve the toolset
    we use. This is not a one-time process; it's a set of tools that need to be extended
    when required or trashed if no longer useful. The important thing here is to ensure
    that things are deployed in a repeatable way.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒——我们正在完成将“大图景”转化为代码，并奠定我们的技术基础！我们已经创建了项目，并将第一个工具 ArgoCD 添加到工具包中。现在，让我们更进一步，填充我们的集群，加入一些我们认为最初有助于构建
    CI/CD 管道的应用程序。在任何项目的开始阶段，这通常是一个最好的猜测。随着我们开始构建产品，我们必须不断发展我们使用的工具集。这不是一次性过程；它是一组工具，在需要时需要扩展，或者如果不再有用就丢弃。这里重要的是确保事物能够以可重复的方式进行部署。
- en: Let's add some tooling. Open your editor on the ubiquitous-journey project.
    Inside ubiquitous-journey/values-tooling.yaml, we have some useful variables referencing
    Helm charts ready for us to pick from, including Jenkins, which we manually deployed
    previously!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些工具。打开你在 ubiquitous-journey 项目中的编辑器。在 ubiquitous-journey/values-tooling.yaml
    中，我们有一些有用的变量，引用了 Helm 图表，供我们选择使用，包括我们之前手动部署的 Jenkins！
- en: '[PRE106]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The layout of this file is simple. For each item in the applications array,
    it expects to find a Helm chart or a reference to a Git repository with some Kubernetes
    yaml (or Kustomize) at a particular version.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件的布局很简单。对于应用程序数组中的每一项，它期望找到一个 Helm 图表或一个指向 Git 仓库的引用，该仓库包含某个特定版本的 Kubernetes
    yaml（或 Kustomize）文件。
- en: When using Helm, any overrides to the defaults supplied by the chart can be
    added here, but for the Nexus chart shown, we are using the default values, so
    there is no need for value overrides for Nexus. There are other fields for each
    application, and these are mostly related to the operation of ArgoCD. For example,
    you can configure the application synchronization policy – sync-policy – which
    tells ArgoCD to always keep your application synced when set to automatic. The
    destination namespace may be specified. With some Kubernetes and OpenShift API
    objects, ArgoCD needs to be asked to ignore differences it finds; this is particularly
    true when controllers and operators write back the status and other fields into
    the objects themselves. We have found over time that each release of ArgoCD lessens
    the need to specify these *ignores* as the generated differences are taken care
    of automatically.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Helm 时，任何对图表提供的默认值的覆盖都可以在此处添加，但对于显示的 Nexus 图表，我们使用的是默认值，因此不需要对 Nexus 进行值覆盖。每个应用还有其他字段，这些字段大多与
    ArgoCD 的操作有关。例如，您可以配置应用同步策略（sync-policy），当设置为自动时，它会告诉 ArgoCD 始终保持应用的同步。可以指定目标命名空间。对于一些
    Kubernetes 和 OpenShift API 对象，ArgoCD 需要被要求忽略它发现的差异；尤其是在控制器和操作员将状态及其他字段写回对象本身时，这一点尤其如此。我们随着时间的推移发现，随着每个
    ArgoCD 版本的发布，指定这些 *忽略* 的需求逐渐减少，因为生成的差异会自动处理。
- en: 'The other important field for each application entry is the `enabled: true
    | false` – it''s easy to run down the list and enable the tools we know we need
    straight away. For now, we are going to start with just four tools: Jenkins, Nexus,
    Tekton, and Code Ready Workspaces. These are the bare bones for scaffolding our
    application and pipelines. At this point, it is worth mentioning the other two
    `values` files, `extratooling` and `day2ops`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '每个应用条目的另一个重要字段是 `enabled: true | false` —— 只需沿着列表跑一遍，启用我们立刻需要的工具就很容易。目前，我们将从四个工具开始：Jenkins、Nexus、Tekton
    和 Code Ready Workspaces。这些是我们应用程序和管道框架的基础。此时，值得提到另外两个 `values` 文件，`extratooling`
    和 `day2ops`：'
- en: '[PRE132]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Like our CI/CD application list in `values-tooling.yaml`, they contain references
    to useful Helm charts and YAML files for deploying in our cluster. The extra tooling
    contains project management and collaboration tools, while the `day2ops` contains
    useful prune jobs to keep our cluster tidy. For now, we will disable all of the
    extra tooling and day2ops apps. This gives us a minimal setup to get started with.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在 `values-tooling.yaml` 中的 CI/CD 应用列表一样，它们包含了用于在我们的集群中部署的有用 Helm 图表和 YAML
    文件的引用。额外的工具包含了项目管理和协作工具，而 `day2ops` 包含了用于保持集群整洁的有用修剪任务。现在，我们将禁用所有额外的工具和 day2ops
    应用。这为我们提供了一个最小的设置来开始使用。
- en: 'If you are running CRC, please check the Appendix for any details prior to
    deploying the tooling. Let''s deploy these tools from the command line using Helm
    and `oc`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在运行CRC，请在部署工具之前查看附录中的任何细节。让我们通过命令行使用Helm和`oc`来部署这些工具：
- en: '[PRE138]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: If you check the ArgoCD web page, you should now see these applications begin
    to deploy and synchronize into your cluster. It will take some time for them all
    to synchronize completely. Jenkins, for example, builds all of the default agent
    images that we may need for running pipeline jobs.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看ArgoCD网页，你应该现在能看到这些应用开始部署并同步到你的集群中。它们会花一些时间来完全同步。例如，Jenkins会构建我们在运行管道作业时可能需要的所有默认代理镜像。
- en: '![](img/B16297_07_18.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_18.jpg)'
- en: 'Figure 7.18: The complete picture with all our tools installed'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18：安装了所有工具后的完整图景
- en: We have now successfully bootstrapped our CI/CD tooling! We will revisit these
    configurations as we find we need to add and update the tools we need to develop,
    test, and deliver PetBattle. By practicing *everything-as-code*, we can easily
    redeploy these tools into any Kubernetes cluster, track changes we may make, and
    manage the life cycle of the tools (upgrade them as their versions and features
    change).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功引导了我们的CI/CD工具！我们将在发现需要添加和更新开发、测试和交付PetBattle所需工具时重新访问这些配置。通过实践*一切皆代码*，我们可以轻松地将这些工具重新部署到任何Kubernetes集群中，跟踪我们可能做出的更改，并管理工具的生命周期（随着版本和功能的变化，升级它们）。
- en: Testing Testing Testing!
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试，测试，测试！
- en: Up to this point, we've spoken about some of the tools we can use to move application
    code from ideas through compilation and into deployment. But how do we know the
    stuff we've built is actually working as we expect it to? If we create a pipeline
    that just compiles code and moves it to production – is it done? No, there are
    testing quality steps and gates that we need to introduce into our software pipelines!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了可以用来将应用代码从构思到编译再到部署的一些工具。但我们怎么知道我们构建的东西真的按预期工作呢？如果我们创建一个仅仅编译代码并将其推送到生产环境的管道——这样就完成了吗？不，还需要在我们的软件管道中加入测试质量步骤和关卡！
- en: The Test Automation Pyramid
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试自动化金字塔
- en: How do we know our feature works as we expect it to? We should test it and see!
    It is not always clear how we should test our feature, nor is it clear when we
    have done too much or not enough testing. Should we create test instructions and
    manually test the feature? Should we test the feature in isolation? Should we
    test all its constituent parts or just the whole thing? What is a definition of
    a unit test exactly?
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们怎么知道我们的功能是否按预期工作？我们应该进行测试并查看结果！测试我们的功能的方式并不总是很明确，什么时候测试得足够多或过多也不清楚。我们是否应该创建测试指令并手动测试这个功能？我们是否应该将功能单独测试？我们是应该测试所有的组成部分，还是只测试整个功能？那么，单元测试的定义究竟是什么？
- en: 'Let''s face it, testing is complicated. We are going to advocate for creating
    not just any tests, but automated tests! *The Test Automation Pyramid*, authored
    by *Michael Cohn*, is a good starting point for us moving through the world of
    automated testing. Let''s take a simplified look at the *traditional* test automation
    pyramid by the original author:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，测试是复杂的。我们将主张创建的不仅仅是任何测试，而是自动化测试！*测试自动化金字塔*，由*迈克尔·科恩*（Michael Cohn）撰写，是我们进入自动化测试世界的一个良好起点。让我们简化地看看原作者所提出的*传统的*测试自动化金字塔：
- en: '![](img/image043.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image043.jpg)'
- en: 'Figure 7.19: The testing triangle'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19：测试金字塔
- en: In the standard three-tiered testing triangle, the things at the bottom (listed
    above as **UNIT TESTS**) are the things we should do more of. Unit tests are the
    smallest amount of code we can test within an application. These units should
    have little to no dependency on other items and so when we run them, they give
    us immediate and precise feedback. Unit tests should point us exactly to where
    the problem is in our code. Moreover, the thinking here is that unit tests are
    cheap to write, easy to maintain, and fast to execute. Therefore, we want more
    of them. This is why they sit at the base of the testing triangle.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准的三层测试三角形中，底部的内容（上文列为**单元测试**）是我们应该做得更多的事情。单元测试是我们在应用程序中可以测试的最小代码单元。这些单元应该尽可能少依赖其他项，因此，当我们运行它们时，它们会给我们即时且精确的反馈。单元测试应该直接指出代码中问题的具体位置。此外，单元测试的思路是它们编写成本低、易于维护、执行速度快。因此，我们希望更多的进行单元测试。这也是为什么它们位于测试金字塔的底部。
- en: Service tests are sometimes seen as integration tests and are the next level
    up the testing triangle. These are API tests that are validating the services
    within your application behave as expected. This may include single service calls,
    as well as chains of service calls, when one service calls another service. The
    width of the testing tier in the triangle relates to how many types of a particular
    test there should be in your code base. According to the pyramid, we should have
    fewer of these service tests than unit tests as they can be costly to execute.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 服务测试有时被视为集成测试，是测试三角形中的下一个层级。这些是 API 测试，用于验证你应用中的服务是否按预期运行。这可能包括单一服务调用，以及服务调用链，当一个服务调用另一个服务时。测试层级的宽度与代码库中应该有多少类型的特定测试相关。根据金字塔的理念，服务测试应该比单元测试少，因为它们的执行成本较高。
- en: The top tier of the testing triangle is reserved for **User Interface** (**UI**)
    tests, or end-to-end system tests. These are responsible for validating that the
    system, as the sum of its components and parts, is behaving as expected. Often,
    UI tests can be brittle in the face of change, break more often, and require maintenance
    to keep them relevant, so the rationale from the testing pyramid is that we should
    do fewer of these as they are difficult to perform and provide less feedback for
    us.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 测试三角形的最顶层是专门用于**用户界面**（**UI**）测试，或端到端系统测试。这些测试负责验证系统作为其各个组件和部分的总和，是否按预期运行。通常，UI
    测试在面对变化时容易变得脆弱，出现故障的频率较高，并且需要维护以保持其有效性。因此，测试金字塔的理由是，我们应该减少这类测试的数量，因为它们难以执行，且提供的反馈较少。
- en: Testing in Practice
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实践中的测试
- en: The Test Automation Pyramid is a great place to start when thinking about your
    own testing. As with all models and patterns, people have over-simplified some
    of its original meaning. In fact, if you do an image search for the testing pyramid,
    you'll see that most of the results are missing the most important keyword – automation!
    Often, organizations lose sight of this, and they think doing manual testing for
    these tiers is good enough.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 测试自动化金字塔是思考自己测试的一个很好的起点。和所有模型和模式一样，人们有时过于简化了其原始含义。事实上，如果你进行测试金字塔的图片搜索，你会发现大多数结果缺少一个最重要的关键词——自动化！通常，组织会忽视这一点，认为为这些层级进行手动测试就足够了。
- en: Testing is important; in fact, it's critical to being able to deliver at speed!
    If you imagine not investing the time into writing automated tests, it may be
    possible to complete a sprint without breaking things. It's probable that we'd
    be able to do two sprints and not break things. However, once we hit that third
    or fourth sprint, that's when your software system starts to misbehave. Applications
    that were written in sprint one now have bugs appearing in them because their
    functional behavior does not work as intended. Functions and APIs that were thought
    to be working were, in fact, completely broken! Being able to release software
    at speed is one thing, but being able to release quality software at speed is
    the differentiator.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 测试很重要；事实上，它对于能够快速交付至关重要！如果你想象一下没有投入时间编写自动化测试，可能会在完成一个 sprint 时不会出问题。也许我们能够完成两个
    sprint 而不出现问题。然而，一旦进入第三或第四个 sprint，软件系统就开始出现异常。第一 sprint 编写的应用程序现在会出现错误，因为它们的功能行为不再按预期工作。曾经被认为正常的函数和
    API，实际上完全崩溃了！能够快速发布软件是一回事，但能够快速发布高质量的软件才是区分的关键。
- en: What is important when thinking about testing is to apply context. You don't
    have to blindly follow a model such as the testing pyramid. In fact, it's a good
    place to start from, but it's not a golden hammer to apply in all environments.
    For example, you might be building a web app with static content or third-party
    services, so UI testing is probably the most important thing.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑测试时，重要的是要应用上下文。你不必盲目遵循像测试金字塔这样的模型。实际上，这是一种很好的起点，但它并不是在所有环境中都适用的万能法则。例如，你可能正在构建一个包含静态内容或第三方服务的
    Web 应用，因此 UI 测试可能是最重要的事情。
- en: What is important is to be sensible about the types of testing you're aiming
    to perform and the value they provide. You may find that it's more important to
    your product that covering the services layer is a better option. If you don't
    have access to the code, then writing black-box tests that assess the services
    with well-defined inputs and outputs is more appropriate to your quality control.
    Likewise, measuring the number of tests, as suggested by the pyramid, tells us
    nothing about the quality of the tests. Good quality tests catch errors before
    your user does. When there is a failure in production, or a bug raised by a user,
    it is very likely that you need to write some more automated tests.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理智地看待你打算执行的测试类型以及它们所提供的价值。你可能会发现，对于你的产品而言，覆盖服务层可能是更好的选择。如果你无法访问代码，那么编写评估服务的黑盒测试，通过明确定义的输入和输出进行测试，更适合你的质量控制。同样，像金字塔建议的那样，衡量测试数量并不能告诉我们测试的质量。高质量的测试会在用户发现之前捕捉到错误。当生产环境出现故障或用户报告了一个bug时，很可能你需要编写更多的自动化测试。
- en: '![](img/image045.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image045.jpg)'
- en: 'Figure 7.20: Measuring tests'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.20：测试衡量
- en: The other way to look at this would be to calculate the risk of not testing
    a piece of functionality. Perhaps the application you're writing is a one-time
    throwaway or just a simple technical spike that does not require rigorous testing.
    However, if a piece of functionality within your product is used all the time
    and it has no automated tests written for it at all, this could be a good place
    to focus your automated testing efforts.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待此问题的方式是计算不对某项功能进行测试的风险。也许你写的应用程序是一次性的，或者只是一个不需要严格测试的简单技术验证。然而，如果你产品中的某个功能被频繁使用，并且根本没有编写自动化测试，那么这个功能可能是你自动化测试工作应该重点关注的地方。
- en: 'Create a culture within your product development team where testing is a continual
    practice. Testing should not be an afterthought of the development process. All
    too often, we see testing beginning once the development team throws a package
    over a wall to the test team for some testing to begin. For us, every item in
    a sprint will always have some level of testing. This isn''t done by some third-party
    team, but by the engineers themselves. Developers will often favor unit and integration
    testing, but **quality assurance** (**QA**) teams will often favor automated UI
    testing to validate the application from a user''s point of view. Sometimes, if
    the culture is not right and a team is being squeezed to turn out new features,
    testing quality can drop, leading to an almost inverted testing pyramid: a few
    unit tests on the bottom, followed by a few more service tests, and then a load
    of brittle UI tests sitting on top! This has an effect on the quality of the software
    delivery pipelines. The feedback loop from Dev to QA can be very long, with little
    to no value from unit tests and expensive UI tests that are not providing feedback
    quickly enough.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的产品开发团队内创建一种测试是持续实践的文化。测试不应该是开发过程的事后思考。我们经常看到，测试是在开发团队将包丢给测试团队后才开始的。对我们来说，每个冲刺中的每个项目都会有一定程度的测试。这不是由某个第三方团队完成的，而是由工程师自己完成的。开发人员通常更偏向单元测试和集成测试，但**质量保证**（**QA**）团队则常常偏向自动化UI测试，从用户的角度验证应用程序。有时，如果文化不对，团队在被压迫加速推出新功能时，测试质量可能下降，导致几乎是反向的测试金字塔：底部有少量单元测试，接着是更多的服务测试，然后是大量脆弱的UI测试堆积在上面！这会影响软件交付管道的质量。从开发到QA的反馈循环可能非常长，单元测试几乎没有价值，而昂贵的UI测试反馈又过慢，无法及时提供反馈。
- en: Decreasing the quality by inverting the testing pyramid during delivery can
    be very damaging to a team. If the volume of defects increases markedly, trust
    in the team will falter. If there is no trust in the team, then autonomy could
    be the next thing to break, leading to a heavy command-and-control-driven culture.
    Teams operating in this way will very quickly fail and top talent will leave.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在交付过程中通过反转测试金字塔来降低质量可能会对团队造成很大伤害。如果缺陷数量显著增加，团队的信任将动摇。如果团队失去信任，那么自主性可能是下一个被破坏的方面，这将导致重度的命令与控制驱动文化。以这种方式运作的团队将很快失败，顶尖人才也将离开。
- en: Testing and the Definition of Done
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试与完成定义
- en: '![](img/Author_42.jpg)![](img/Noel2.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Author_42.jpg)![](img/Noel2.jpg)'
- en: While working on a residency recently with the World Health Organization, we
    started out with great ambition to write tests for each sprint item. We got off
    to a good start by including testing in our Definition of Done for each sprint
    item. We agreed that there must be some automated testing for each item being
    taken into a sprint.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最近与世界卫生组织合作时，我们在一开始就有着很大的雄心，计划为每个冲刺项目编写测试。我们通过在每个冲刺项目的“完成定义”中加入测试，开始得相当顺利。我们一致认为，每个进入冲刺的项目必须包含一些自动化测试。
- en: The first sprint went by in a flash as we were working in one-week iterations.
    As we were a new team, everyone was motivated and keen to try new things. By sprint
    three, we were taking on more stories than we could get through with our team's
    capacity.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个冲刺在一周的迭代中迅速过去。由于我们是一个新团队，每个人都充满动力，渴望尝试新事物。到了第三个冲刺，我们已经接手了超出团队能力范围的故事。
- en: The work we were doing was becoming more complex and we missed out some of the
    automated tests. We claimed a feature or two were done. In the demo for that week,
    we admitted to the product owner that the piece of work was functionally done,
    but not done according to our own criteria.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的工作变得越来越复杂，错过了一些自动化测试。我们宣称某些功能已经完成。在当周的演示中，我们向产品负责人承认，这项工作在功能上已完成，但根据我们自己的标准还没有完成。
- en: We tried to be honest with ourselves, but found we'd slipped up again the following
    week. At this point, it became clear to us that when we did sprint planning, we
    were not thinking correctly about the capacity required for writing tests. The
    Definition of Done was in place, but we were still not being honest. We were a
    team that was keen to keep moving forward and picking up new items before previous
    ones were done.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尽力对自己诚实，但发现我们在接下来的一个星期又犯了错。此时，我们清楚地意识到，在做冲刺规划时，我们没有正确地考虑编写测试所需的容量。虽然已经有了“完成定义”，但我们仍然没有做到诚实。我们是一个渴望不断向前推进、在前一个任务未完成时就急于开始新任务的团队。
- en: In a retrospective session, we decided a good way forward would be for us to
    capture testing effort when writing our tasks. When taking an item from the backlog,
    we would add subtasks for all of the automated testing. This way, all of the work
    associated with test automation became visible to the team because these subtasks
    were on the sprint board. Having a task to write tests for your feature makes
    it pretty hard to move on to the next item when it's still in progress!
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在一次回顾会议上，我们决定一个好的前进方向是，在编写任务时记录测试工作量。当从待办事项中提取项目时，我们会为所有自动化测试添加子任务。通过这种方式，与测试自动化相关的所有工作变得对团队可见，因为这些子任务出现在冲刺看板上。为你的功能编写测试的任务使得在任务还在进行中的时候，很难继续处理下一个任务！
- en: You can learn more and collaborate on CI practices by going to the Open Practice
    Library page at [https://openpracticelibrary.com/practice/test-automation/](https://openpracticelibrary.com/practice/test-automation/).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问 [https://openpracticelibrary.com/practice/test-automation/](https://openpracticelibrary.com/practice/test-automation/)
    来了解更多内容并协作进行持续集成实践。
- en: TDD or BDD or DDT
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TDD 或 BDD 或 DDT
- en: There are a number of books written on testing and how to write great tests
    that are meaningful and provide value. Our ambition is not to rewrite these books,
    but to give you pointers to things you could research further if this topic really
    interests you. Some approaches to testing that teams find useful at the various
    levels of the triangle are things such as **Behavior-Driven Development** (**BDD**),
    **Test-Driven Development** (**TDD**), and **Developer-Driven Testing** (**DDT**).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 关于测试以及如何编写有意义且能提供价值的好测试，已经有许多书籍。我们的目标不是重写这些书籍，而是给你一些提示，帮助你进一步研究这个话题，如果它真的引起了你的兴趣。团队在三角形的不同层级上发现有用的一些测试方法，包括
    **行为驱动开发** (**BDD**)、**测试驱动开发** (**TDD**)，以及 **开发者驱动测试** (**DDT**)。
- en: '![](img/B16297_07_21.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_21.jpg)'
- en: 'Figure 7.21: Test-Driven Development'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.21：测试驱动开发
- en: 'TDD is a simple process, yet somewhat misunderstood by some teams. The process
    is fairly simple. Start off by writing some tests for the functionality you''re
    building. At this point, they should fail (**RED**). If they don''t fail, then
    your tests are not very well written OR the functionality already exists! A developer
    will then write the code to make the test pass (**GREEN**). With the tests now
    green, refactoring can take place or, as Kent Beck, an American software engineer
    and the creator of extreme programming, puts it, *refactor to remove duplication*.
    Remove duplicate code or make the code leaner and tidy it up while maintaining
    the green state of the tests. The process is simple: **Red > Green > Refactor**.
    Writing tests first is a hard practice to do and takes time and perseverance to
    get the skills right, but it can lead to less spaghetti code. Because the tests
    are written first, they lead the design and implementation of the code.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是一个简单的过程，但一些团队可能误解了它。过程相当简单。首先为你正在构建的功能编写一些测试。此时，测试应该是失败的（**RED**）。如果测试没有失败，那么说明你的测试写得不好，或者功能已经存在！然后开发者将编写代码使测试通过（**GREEN**）。当测试通过后，可以进行重构，或者正如极限编程的创造者、美国软件工程师Kent
    Beck所说，*重构以去除重复*。删除重复代码或使代码更加简洁并整理它，同时保持测试通过的状态。这个过程很简单：**红色 > 绿色 > 重构**。先编写测试是一项艰难的实践，需要时间和毅力来掌握技巧，但它可以减少混乱的代码。因为测试是首先编写的，它们引导了代码的设计和实现。
- en: '![](img/B16297_07_22.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_22.jpg)'
- en: 'Figure 7.22: Executing Test-Driven Development'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.22：执行测试驱动开发
- en: 'A great exercise to do with teams wanting to try TDD without code is to do
    the Lego TDD simulation on Gargoyle Software''s website: [http://gargoylesoftware.com/articles/lego_tdd](http://gargoylesoftware.com/articles/lego_tdd).'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 一个适合团队尝试TDD而不涉及代码的练习是通过Gargoyle Software网站上的乐高TDD模拟：[http://gargoylesoftware.com/articles/lego_tdd](http://gargoylesoftware.com/articles/lego_tdd)。
- en: You can learn more and collaborate on TDD by going to the Open Practice Library
    page at [openpracticelibrary.com/practice/test-driven-development](http://openpracticelibrary.com/practice/test-driven-development).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问[openpracticelibrary.com/practice/test-driven-development](http://openpracticelibrary.com/practice/test-driven-development)页面来了解更多关于TDD并进行协作。
- en: DDT is easy and probably the place to start if you're not writing any tests.
    The important point here is that some tests are being written! DDT focuses on
    the developers writing code as well as writing the tests. Simply put, the developer
    codes for a bit, writes some automated tests, and then goes back to coding and
    testing. This might sound a bit like TDD, but the key difference is the order.
    Code first and then test, resulting in the code influencing the tests as opposed
    to the tests leading the software design. The objective of DDT is that developers
    need to own their code and that everyone should be responsible for testing.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: DDT很容易实现，可能是如果你没有编写任何测试时，开始的地方。这里的重点是确实有一些测试被编写了！DDT侧重于开发者编写代码并同时编写测试。简单来说，开发者先编写代码，写一些自动化测试，然后再回到编码和测试。这听起来有点像TDD，但关键的区别在于顺序。先编码再测试，导致代码影响测试，而不是测试引导软件设计。DDT的目标是让开发者对自己的代码负责，且每个人都应对测试负责。
- en: '![](img/B16297_07_23.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_23.jpg)'
- en: 'Figure 7.23: Developer-Driven Testing'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.23：开发者驱动的测试
- en: BDD is a great tool to have in your toolbox as it brings people together in
    a shared understanding of the scope of a story or feature under development. It's
    less of an engineering tool and more of a method that focuses on the conversation
    to be had between business and developers when writing features. BDD is about
    using a shared language to write concrete examples of how an application should
    behave.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: BDD是你工具箱中一个很好的工具，因为它让人们在共同理解一个正在开发的故事或特性的范围时凝聚在一起。它不太像工程工具，更像是一种方法，侧重于业务和开发者在编写功能时的对话。BDD是通过使用共享语言编写应用程序行为的具体示例。
- en: 'How the tests are implemented is then decided by the developers. But, more
    importantly, a common language can be used between developers and product owners
    to scope out a story without leading the design of the software. BDD can be a
    useful way to write acceptance criteria for a story together. There is a common
    syntax or approach to writing BDD tests based on work by *Dan North*, an agile
    coach and originator of BDD[4](#footnote-026):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的实现方式由开发人员决定。但更重要的是，开发人员和产品负责人之间可以使用一种通用语言来划定故事的范围，而不需要引导软件设计。BDD 可以作为一种有用的方式，共同编写故事的验收标准。BDD
    测试的编写有一种常用的语法或方法，基于 *Dan North*（敏捷教练和 BDD 创始人）的工作[4](#footnote-026)：
- en: '[PRE140]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[4](#footnote-026-backlink) [https://dannorth.net/introducing-bdd/](https://dannorth.net/introducing-bdd/)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '[4](#footnote-026-backlink) [https://dannorth.net/introducing-bdd/](https://dannorth.net/introducing-bdd/)'
- en: 'For example:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE146]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: For any feature being developed, there are probably a number of scenarios that
    could be tested. These scenarios are defined using the common syntax of Given,
    When, Then. Codifying the acceptance criteria using a common syntax can simplify
    the writing of tests and gaining a shared understanding of the scope of an activity.
    Dan North suggested this story-driven approach to BDD some years back and, since
    then, the syntax has been adopted by lots of the testing frameworks, such as Cucumber.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 对于正在开发的任何功能，可能会有多个场景需要测试。这些场景使用常见的语法——Given, When, Then 来定义。使用通用语法编写验收标准可以简化测试的编写，并帮助大家达成对活动范围的共同理解。Dan
    North 多年前提出了这种以故事为驱动的方法，并且从那时起，许多测试框架（如 Cucumber）都采用了这种语法。
- en: BDD for Our Ops Tooling Python Library
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的运维工具 Python 库的 BDD
- en: '![](img/Author_22.jpg)![](img/Author_31.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Author_22.jpg)![](img/Author_31.jpg)'
- en: 'I worked on a public sector engagement a few years back. I was part of a team
    helping them automate some of their Ops capabilities. They had teams of people
    configuring VMs manually in a non-repeatable way. Part of that work involved me
    building a command-line interface for the team to help automate the creation and
    onboarding of team members (users) and their roles into a Free IPA server (Red
    Hat Identity Management). The following screenshot shows one of the BDD scenario
    templates for adding an existing user and deleting a user:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，我参与了一个公共部门的项目。我是团队的一员，帮助他们自动化一些操作能力。以前，他们有团队成员手动配置虚拟机（VM），而且这种方式无法重复使用。我的工作之一是为团队构建一个命令行界面，帮助自动化创建和添加团队成员（用户）及其角色到
    Free IPA 服务器（Red Hat 身份管理）。下图显示了添加现有用户和删除用户的一个 BDD 场景模板：
- en: '![](img/B16297_07_231.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_231.jpg)'
- en: 'Figure 7.24: A BDD scenario'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.24：一个 BDD 场景
- en: The architect on the team was a strong believer in the BDD approach to writing
    stories. All of our acceptance criteria were written in this way, and it was a
    great way for us to understand the scope of what we were doing. When I was pairing
    with another engineer, we would use the acceptance criteria written in the BDD
    syntax as our starting point. We imported the syntax straight from Jira to scaffold
    out the test cases using Python Behave. For us as engineers, this made coding
    the features a breeze. We had been given the specifications, so we could easily
    implement our code to pass the tests.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 团队中的架构师是 BDD 写作方法的坚定支持者。我们所有的验收标准都是按照这种方式编写的，这让我们更好地理解自己所做工作的范围。当我与另一位工程师配对时，我们会将按照
    BDD 语法编写的验收标准作为起点。我们直接从 Jira 导入语法，通过 Python Behave 来搭建测试用例。对于我们这些工程师来说，这使得功能编码变得轻松。我们已经得到了规范，所以可以轻松地实现我们的代码以通过测试。
- en: 'BDD can help engineers understand the context of features better. It also helps
    bridge the gap of alignment with business experts and product owners:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: BDD 可以帮助工程师更好地理解功能的背景。它还帮助弥合与业务专家和产品负责人的对齐差距：
- en: Product Owners Seeing Their Thoughts in Code!
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产品负责人看到他们的想法以代码形式呈现！
- en: When we coach teams, we encourage them to use the sprint review or showcase
    events as an opportunity to show the world EVERYTHING they've worked on. That
    includes setting up and improving test automation.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们指导团队时，我们鼓励他们利用冲刺评审或展示活动，作为展示他们所有工作成果的机会。包括设置和改进测试自动化。
- en: One particular recurrence I've noticed from several teams I've worked with is
    when the product owner or business SMEs first see automation of BDD running. They
    think back to the sprint planning event a week or two earlier, when the teams
    were confirming acceptance criteria for stories they were going to accept into
    the sprint. Often, these criteria would be written using BDD syntax and it would
    be the PO or business experts providing the input.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我从我曾合作的几个团队中注意到一个特别的现象，当产品负责人或业务领域专家第一次看到BDD自动化运行时，他们会回想起一两周前的冲刺规划会议，当时团队正在确认将要进入冲刺的故事的验收标准。通常，这些标准会使用BDD语法书写，输入的内容则来自产品负责人或业务专家。
- en: When they see a test automation suite running in the sprint review or showcase,
    they will see the console showing the tests automated, the same thoughts, the
    same instructions, and the same business logic all codified.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 当他们在冲刺评审或展示会上看到测试自动化套件运行时，他们会看到控制台显示已自动化的测试，相同的思路、相同的指令，以及相同的业务逻辑都已被编码。
- en: BDD brings down the wall between technology and business people.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: BDD打破了技术人员与业务人员之间的壁垒。
- en: Example Mapping
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Example Mapping
- en: 'Example Mapping, by Matt Wynne, CEO of Cucumber,[5](#footnote-025) is another
    great tool to have in the toolbox. Once again, with a lot of these practices,
    it''s just another really useful way to articulate and drive a conversation. In
    this case, Example Mapping is primarily used to drive shared understanding when
    writing stories and creating acceptance criteria. We believe it''s great for helping
    teams write behavioral-driven tests. The process is simple and only involves four
    colored Post-Its:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 由Cucumber首席执行官Matt Wynne提出的Example Mapping，[5](#footnote-025) 是另一个非常有用的工具，值得添加到工具箱中。再一次，很多这些实践实际上是非常有用的方式来阐明并推动对话。在这种情况下，Example
    Mapping 主要用于在编写故事和创建验收标准时推动共同理解。我们认为它对于帮助团队编写行为驱动的测试非常有帮助。这个过程简单，且只涉及四种颜色的便签：
- en: '**Yellow**: For the story itself (as a header for the example map)'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**黄色**：用于故事本身（作为示例图的标题）'
- en: '**Blue**: For specific rules associated with the story'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝色**：用于与故事相关的具体规则'
- en: '**Green**: For examples of rules'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绿色**：用于规则示例'
- en: '**Red**: For questions or unknowns that arise during the discussion'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**红色**：用于讨论中出现的问题或未知项'
- en: '[5](#footnote-025-backlink) [https://cucumber.io/blog/bdd/example-mapping-introduction/](https://cucumber.io/blog/bdd/example-mapping-introduction/)'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '[5](#footnote-025-backlink) [https://cucumber.io/blog/bdd/example-mapping-introduction/](https://cucumber.io/blog/bdd/example-mapping-introduction/)'
- en: '![](img/B16297_07_24.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_24.jpg)'
- en: 'Figure 7.25: Example Mapping'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.25：Example Mapping
- en: Begin by selecting a story and write it on a yellow sticky note. Place it at
    the top of your example map as a header. In a horizontal row underneath that,
    begin writing business rules on blue sticky notes. Beneath the blue business rules,
    create columns of green sticky notes with individual examples of those business
    rules. These could be relatively unstructured Friends-notation *The one where...*
    examples, or full-blown Given, When, Then criteria.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 首先选择一个故事并将其写在黄色便签上，将其放在示例图的顶部作为标题。在其下方的横向行中，开始写下蓝色便签上的业务规则。蓝色业务规则下方，创建一列绿色便签，列出这些业务规则的具体示例。这些示例可以是相对不太结构化的朋友标记*The
    one where...* 示例，也可以是完整的Given, When, Then标准。
- en: As misunderstandings arise surrounding individual examples or entire business
    rules, add red stickies with questions written on them.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 当在讨论中出现对单个示例或整个业务规则的误解时，添加红色便签并写上问题。
- en: When there are enough examples that everyone is comfortable with, they can be
    rewritten as both automated tests and acceptance criteria.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 当有足够的示例，大家都能理解时，它们可以被重写为自动化测试和验收标准。
- en: Example Mapping in the Field
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际应用中的Example Mapping
- en: '![](img/Noel3.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Noel3.jpg)'
- en: On the World Health Organization residency, I found this practice so simple
    to use but such a great tool to articulate the scope of a story and get alignment
    on the acceptance tests we'd write.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在世界卫生组织的驻地项目中，我发现这种做法非常简单易用，但它是一个很好的工具，用来阐明故事的范围，并就我们将编写的验收测试达成一致。
- en: We were using Event Storming (more on this later) to model the onboarding process
    for a new user to their application. We had a command that read *Submit relevant
    topics of interest*, which was added to our backlog. We chose this command so
    we could learn more about things our users would be interested in, in order to
    better serve them recommendations.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Event Storming（稍后会详细介绍）来建模新用户加入应用程序的过程。我们有一个命令，写着*提交相关的兴趣话题*，并将其添加到我们的待办事项列表中。我们选择这个命令是为了更好地了解用户感兴趣的事物，从而更好地为他们提供推荐。
- en: We used Example Mapping to break this story down by first writing some rules.
    We were not super strict on following a ubiquitous language at this point as we
    knew the team would convert them into BDD-style syntax afterward.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用示例映射来分解这个故事，首先编写一些规则。此时我们并没有严格遵循统一语言，因为我们知道团队会在之后将这些规则转换为BDD风格的语法。
- en: '![](img/B16297_07_25.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_25.jpg)'
- en: 'Figure 7.26: Example Mapping example'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.26：示例映射示例
- en: The conversion within the team brought out some misunderstandings regarding
    the scope of the activity. The developers wondered more about edge cases, such
    as, *what happens if the page is refreshed or returned to?* We were able to capture
    these questions as part of the Example Mapping and add a new rule and some examples.
    Subsequently, the team could convert the examples into the BDD syntax.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 团队内部的转换引发了一些关于活动范围的误解。开发人员更关心边缘情况，比如，*如果页面被刷新或返回会发生什么？* 我们能够将这些问题作为示例映射的一部分捕捉下来，并添加了新的规则和一些示例。随后，团队能够将这些示例转换为BDD语法。
- en: As with all these practices, the act of having this conversation with the correct
    people and capturing the examples meant we gained great team alignment and were
    able to convert them to acceptance tests and implement them as part of our development
    workflow.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有这些实践一样，与正确的人进行这样的对话并捕捉示例意味着我们获得了良好的团队对齐，并能够将其转化为验收测试，并作为我们开发工作流的一部分实施。
- en: You can learn more about, and collaborate on, the Example Mapping practice by
    going to the Open Practice Library page at [openpracticelibrary.com/practice/example-mapping](http://openpracticelibrary.com/practice/example-mapping).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问[openpracticelibrary.com/practice/example-mapping](http://openpracticelibrary.com/practice/example-mapping)页面，了解更多关于示例映射实践的内容，并进行协作。
- en: Non-functional Testing
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非功能测试
- en: While the importance of testing cannot be overstated, it's critical to keep
    an eye on other metrics that may give further insight into the quality of our
    code. For example, how do you know your tests have enough breadth to check all
    the code? What if my tests are passing, but the application response time is awful?
    Traditional unit and integration testing might not catch these things. There are
    tools we can use to identify causes and issues with our code base and, more importantly,
    fix them sooner rather than later.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然测试的重要性不容小觑，但关注其他可能进一步揭示我们代码质量的指标同样至关重要。例如，你怎么知道你的测试覆盖了所有代码？如果我的测试都通过了，但应用的响应时间很差呢？传统的单元测试和集成测试可能捕捉不到这些问题。我们可以使用一些工具来识别代码库中的原因和问题，更重要的是，尽早修复这些问题，而不是等到更晚。
- en: Code coverage reporters are simple to implement and usually come bundled up
    with a lot of modern test frameworks. The idea is simple. While running our test
    cases, the code base is being watched. Once test execution is completed, a report
    is generated showing what lines of code have been hit and where there are gaps.
    These are useful reports to help the team identify where there is room for improvement
    but they should not be treated as the absolute truth. As with all these things,
    there are ways to trick the coverage reports, but good developers and peer review
    processes should catch these things. Often, teams will strive to increase the
    testing coverage if they have not started from a very good state. Bringing these
    reports to a retrospective can be good for teams to analyze and set higher targets.
    More aggressive teams may even fail their pipeline as unstable if the coverage
    is below a certain threshold!
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率报告器易于实现，通常与许多现代测试框架一起捆绑。其思想很简单：在运行我们的测试用例时，代码库会被监视。一旦测试执行完成，就会生成一份报告，显示哪些代码行已经被执行，哪些地方存在空白。这些报告对帮助团队识别改进空间非常有用，但不应被视为绝对真理。像所有这些工具一样，覆盖率报告是有可能被欺骗的，但优秀的开发者和同行评审流程应该能发现这些问题。通常，如果团队的测试覆盖率还不高，他们会努力提升覆盖率。将这些报告带到回顾会上，对团队来说是一个很好的分析工具，并可以设定更高的目标。一些进取心强的团队甚至会将覆盖率低于某一阈值的情况视为管道不稳定，导致失败！
- en: Static code analysis is another tool that can provide insight into a code base
    not detected by unit testing, creating rules for how the code should look and
    execute. Consistency in an approach to how you write code is particularly important
    for non-compiled languages such as JavaScript. JavaScript also behaves differently
    in different browsers, so writing a set of rules such as using single quotes instead
    of double quotes for all strings can help ward off any unexpected behavior. If
    we have the rules codified, we may as well ensure that everyone adheres to them,
    so add them to our pipeline! Coding standards are very important in multi-team
    setups too. If the code base conforms to a standard structure and design, it can
    also make maintenance and updates to it very simple.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 静态代码分析是另一个可以提供单元测试未能检测到的代码库洞察的工具，它创建了代码应如何编写和执行的规则。如何编写代码的一致性对非编译语言（如 JavaScript）尤为重要。JavaScript
    在不同浏览器中的行为也有所不同，因此编写一套规则，比如所有字符串都使用单引号而非双引号，有助于避免任何意外的行为。如果我们将这些规则编码化，那么我们不妨确保每个人都遵守这些规则，因此将它们添加到我们的流水线中！编码标准在多团队合作的环境中也非常重要。如果代码库符合标准结构和设计，也会使其维护和更新变得非常简单。
- en: Performance Testing Sam's Code
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能测试 Sam 的代码
- en: '![](img/Author_23.jpg)![](img/Author_32.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Author_23.jpg)![](img/Author_32.jpg)'
- en: Around 2014, we worked for a retail organization building mobile backend services
    and some automation around it. This layer of services was responsible for aggregating
    data from different backend systems such as product listers and categories, and
    reviews. The services also performed some very basic data manipulation to make
    the payloads more mobile consumable. It was critical that the adapters responded
    in a very timely manner, as mobile latency was high compared to modern mobile
    networks and a fast API response time made all the difference.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在 2014 年，我们为一家零售公司工作，构建了移动后台服务及一些相关的自动化工具。这一服务层负责聚合来自不同后台系统的数据，例如产品列表、类别和评论。这些服务还进行了一些非常基础的数据处理，以使数据负载更加适合移动端使用。适配器响应的及时性至关重要，因为与现代移动网络相比，移动端的延迟较高，而快速的
    API 响应时间能够带来显著的差异。
- en: Our team was always cognizant that we should keep track of the time taken for
    the adapters to respond. We knew the organization would perform a traditional
    load-testing initiative at the end of the program; however, we didn't want to
    wait until then to reveal any surprises. We figured there had to be a way to continuously
    validate changes we made to the adapter tier in order to highlight any performance
    degradation.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的团队始终意识到，我们应该跟踪适配器响应所需的时间。我们知道组织会在程序结束时进行传统的负载测试，但我们不想等到那时才发现问题。我们认为，一定有一种方法可以持续验证我们对适配器层所做的更改，以便及早发现任何性能下降的问题。
- en: We created a nightly job in Jenkins (our automation tool) to check the performance
    of the adapters each evening. This was a fairly simple job that simulated 1,000s
    of parallel requests to the APIs. From this, we plotted the response time of the
    service each day and reported it through Jenkins. This allowed us to create a
    baseline for where a normal response should be and allow us to fail the job's
    execution if the value fell above or below an expected range!
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Jenkins（我们的自动化工具）中创建了一个夜间任务，每晚检查适配器的性能。这是一个相当简单的任务，模拟了成千上万的并行请求到 API。通过此任务，我们绘制了每天服务的响应时间，并通过
    Jenkins 报告了这些数据。这使我们能够为正常响应的基准值创建一个标准，并在值超出预期范围时让任务执行失败！
- en: '![](img/B16297_07_26.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_26.jpg)'
- en: 'Figure 7.27: Automated discovery of performance bottlenecks'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.27：自动发现性能瓶颈
- en: One day, we came into the office and our nightly job had turned red! Perfect,
    we thought, let's Stop the World and stop all the things we're doing while we
    inspect what's changed in the system since last night. A quick check of the changes
    that were made in the system revealed that Sam, one of the team members, had tried
    to check in some new logic for one of the data translation functions. Sam had
    introduced a big loop inside a loop inside another loop, which had caused the
    code execution time to spike. It was something that was not caught by our traditional
    unit testing, as the logic was working fine. It was just taking longer to compute.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 有一天，我们来到办公室，发现我们的夜间任务变成了红色！我们心想，太好了，让我们停止所有正在进行的工作，检查一下自昨晚以来系统发生了什么变化。快速检查系统中所做的更改后，我们发现团队成员Sam尝试提交了某个数据转换函数的新逻辑。Sam在一个循环内嵌套了另一个循环，导致了代码执行时间的剧增。这是我们的传统单元测试没能捕捉到的问题，因为逻辑本身是正常的，只是计算所需时间变长了。
- en: We quickly responded and fixed the problem immediately. If we hadn't caught
    this performance bottleneck, it could have been weeks or more before we realized
    what was happening. We could have been building more functionality on top of this
    dodgy piece of code, making it much harder to unpick at a later date.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迅速响应并立即修复了问题。如果我们没有发现这个性能瓶颈，可能需要几个星期甚至更长时间才能意识到发生了什么。我们本可以在这段问题代码上继续构建更多功能，这会使得以后更难以拆解。
- en: Being able to respond to feedback like this was critical. We're not saying that
    big load testing on the product was not necessary, but this one simple automated
    job provided us with a ton of value just by catching this one issue. It was cheap
    to write and maintain and caught this error potentially sooner than we would otherwise
    have noticed. Sam tried to write some more code a few weeks later and we got a
    similar failure.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 能够像这样快速响应反馈至关重要。我们并不是说产品上的大负载测试不必要，但这个简单的自动化任务通过捕捉这个问题，给我们带来了大量价值。它编写和维护成本低，而且可能比我们其他方式更早发现了这个错误。几周后，Sam再次尝试编写代码，我们遇到了类似的失败。
- en: '![](img/B16297_07_27.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_27.jpg)'
- en: 'Figure 7.28: More light automated performance tests'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.28：更多轻量级自动化性能测试
- en: Have no fear though – Sam, who's a good friend of ours, no longer writes code
    for a living as he's moved into a technical sales role. We don't have a blame
    culture within our workspaces and I'm sure if Sam was telling you this story,
    he'd say it was one of us that checked in that silly piece of code. I'll let you
    decide who it was.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，别担心——Sam是我们的一位好朋友，现在已经不再从事写代码的工作，他转行做了技术销售角色。我们工作中没有“归咎文化”，我敢肯定，如果Sam在讲这个故事，他会说是我们其中一个人提交了那段愚蠢的代码。我让你自己决定是谁。
- en: There are lots of other types of testing and I won't list them all; we'd have
    to write another book to fit them all in. We go into more detail about the non-functional
    nature of our software in the next section, *Discover It*.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他类型的测试，我不会一一列出；如果要列完这些内容，我们得再写一本书来装下它们。我们将在下一部分中详细探讨我们软件的非功能性特征，*发现它*。
- en: A Few Final Thoughts on Testing
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于测试的一些最终思考
- en: We cannot understate the importance of testing in delivering features at speed,
    especially automated testing. Whether you follow the test pyramid or some other
    paradigm is up to you – just remember it's all about the conversation. If TDD
    is not the right thing for you, make sure you still have the conversation between
    business and technical teams to identify sensible tests using examples. The go-to
    for us is to use BDD as it allows us to bring together the world of business and
    technology.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法低估测试在快速交付功能中的重要性，特别是自动化测试。无论你是遵循测试金字塔还是其他某种范式，这取决于你——只要记住，一切都关乎交流。如果TDD（测试驱动开发）不适合你，确保仍然进行业务与技术团队之间的对话，利用示例来识别合适的测试。我们常用的方法是使用BDD（行为驱动开发），因为它能将业务与技术的世界结合起来。
- en: Lastly, we're not saying there is no place in the world for separate QA teams.
    Not at all, it's about automating all the things and getting feedback early. If
    the QA is a separate function within your organization and is only engaged some
    weeks before going live, then this is a problem. Bring the skills of QA into the
    team and left-shift that capability into the team so that they can get early feedback
    more often.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们并不是说世界上没有独立QA团队的空间。绝对不是，关键是自动化所有事情并尽早获得反馈。如果QA是你公司中的一个独立职能，而且只在上线前几周才参与，那么这是一个问题。将QA的技能带入团队，并将这个能力“左移”到团队中，这样他们可以更频繁地获得早期反馈。
- en: Emerging Architecture
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新兴架构
- en: '*Hope is not a design method*.[6](#footnote-024)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '*希望不是一种设计方法*。[6](#footnote-024)'
- en: How do we know our architecture is good? What does good mean? Is good architecture
    measurable? Have you ever had to operate, support, or fix a system that is poorly
    architected?
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道我们的架构是好的？什么是好的架构？好的架构能否衡量？你是否曾经操作、支持或修复过一个架构不良的系统？
- en: 'It may be easier to identify some characteristics of what *a* *poor architecture*
    looks like:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 识别什么是*糟糕架构*可能会更容易：
- en: An unstable and unreliable system that fails regularly in unknown and unexpected
    ways.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个不稳定且不可靠的系统，经常以未知和意外的方式失败。
- en: The system is slow from a user's point of view.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从用户的角度来看，系统很慢。
- en: It does not scale well with increased users or loads.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它无法随着用户或负载的增加而良好扩展。
- en: It is hard to upgrade because one small change requires everything to be re-deployed,
    which is slow and costly.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它很难升级，因为一个小的变动就需要重新部署整个系统，这既慢又昂贵。
- en: It is dependent on clients or other systems and cannot be easily modified or
    changed without changing the other systems as well.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它依赖于客户端或其他系统，且不能轻易修改或改变，除非同时改变其他系统。
- en: It has a lot of complex business functions that are buried in the database,
    that may involve triggers, and cannot be easily changed due to a complex database
    schema with unknown side effects when modified.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有很多复杂的业务功能，这些功能被埋藏在数据库中，可能涉及触发器，且由于复杂的数据库架构，在修改时可能会产生未知的副作用，难以轻易改变。
- en: The system is hard to manage and operate.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个系统难以管理和运维。
- en: '[6](#footnote-024-backlink) [Michael T. Nygard, Release It!: Design and Deploy
    Production-Ready Software](https://pragprog.com/titles/mnee2/release-it-second-edition/)'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '[6](#footnote-024-backlink) [Michael T. Nygard, 《Release It!：设计和部署生产就绪的软件》](https://pragprog.com/titles/mnee2/release-it-second-edition/)'
- en: The list goes on and on.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 列表还在继续。
- en: In frontline software support and operations, there is nothing worse than getting
    called consistently at 3 in the morning to firefight a recurrent complex system
    crash, and after restoring the service, the root cause analysis points back to
    a complex failing architecture – where there is no easy fix other than re-designing
    or rewriting the software.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在一线软件支持和运维中，没有什么比在凌晨3点被持续呼叫去扑灭一个反复发生的复杂系统崩溃问题更糟糕的了，恢复服务后，根本原因分析却指向了一个复杂的失败架构——除了重新设计或重写软件外，没有其他简便的修复方法。
- en: A lot of deep-seated issues with software arise from poorly judged architecture
    decisions. Many times, most of these decisions are made at the initial stages
    of product development when the big architecture is designed upfront and set in
    stone, concrete, or mud. Often, the system architects present their architectural
    masterpiece to the development teams and henceforth work to ensure the problem
    fits the architecture rather than the architecture fitting the problem.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 许多深层次的软件问题源于不明智的架构决策。很多时候，这些决策在产品开发的初期就已做出，当时大的架构已经设计好并固定不变，可能是石头、混凝土，甚至泥巴做成的。通常，系统架构师会向开发团队展示他们的架构杰作，并从此致力于确保问题适配架构，而不是架构适配问题。
- en: The development process continues using this eighth architectural wonder of
    the world and all goes well initially; it even may run in production. But then,
    one day, the business asks for some feature that doesn't fit well into the architectural
    approach and then there's hell to pay to get the change done.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 开发过程继续使用这座“世界第八大奇迹”的架构，最初一切进展顺利，甚至可能在生产环境中运行。但有一天，业务部门要求一个与架构方法不太契合的功能，然后为了完成这个变更，付出了巨大的代价。
- en: Technical decisions during development often have to be made based on the best
    intentions, but with incomplete or sparse information. The wisdom gained from
    the more experienced members of the team can often be invaluable during design
    discussions. Those with scars from previous projects with bad architecture are
    definitely worth listening to and learning from. There can, however, be a downside
    to this, as we'll see in The Hammer section.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，技术决策往往必须基于最好的意图做出，但此时的信息往往不完整或过于稀疏。团队中经验更丰富的成员在设计讨论中的智慧往往是非常宝贵的。那些在之前项目中经历过糟糕架构的人，绝对值得倾听和学习。然而，正如我们在《锤子》章节中看到的那样，这也可能存在一个弊端。
- en: As a product team, we must be willing and able to adapt and change the architecture
    when requirements substantially change or a system failure tells us that we're
    hitting the limits of our existing architecture.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 作为产品团队，我们必须愿意且能够在需求发生重大变化或系统故障告诉我们现有架构的极限时，适应并改变架构。
- en: Note
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Generally speaking, it is better to make architectural and technical decisions
    as late as reasonably responsible to do so, so that the most information is available
    to those making the decisions.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，最好在合理的范围内尽可能晚些做出架构和技术决策，以便为做出决策的人提供更多的信息。
- en: Emergent architecture is the practice of having *just enough of an architecture*
    so that the product developments keep moving forward, but is flexible enough that
    architecture changes can be made as more information becomes available.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 新兴架构是指拥有*足够的架构*，以便产品开发能够持续推进，同时又足够灵活，能够在获得更多信息时做出架构调整。
- en: There have been literally dozens of excellent books and articles written on
    what is considered *good architecture and patterns* over the years. Our personal
    choice is anything written by *Martin Fowler* ([https://martinfowler.com/books/](https://martinfowler.com/books/)),
    *Chris Richardson* ([https://microservices.io/](https://microservices.io/)), and
    *Sam Newman* ([https://samnewman.io/books/](https://samnewman.io/books/)), but
    there are many others.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，已经有大量优秀的书籍和文章讨论了什么是*良好的架构和模式*。我们个人的推荐是*Martin Fowler*（[https://martinfowler.com/books/](https://martinfowler.com/books/)）、*Chris
    Richardson*（[https://microservices.io/](https://microservices.io/)）和*Sam Newman*（[https://samnewman.io/books/](https://samnewman.io/books/)）的作品，但还有很多其他优秀的作者。
- en: Observations from the Field
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现场观察
- en: In this section, our intention is to outline some of the recurring patterns/approaches,
    both good and bad, that we've come across. None of these are new, but we thought
    it useful to call them out here.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们的目的是概述一些我们遇到的反复出现的模式/方法，包括好的和不好的。虽然这些并不新鲜，但我们认为在这里提出来是有益的。
- en: Patterns per Square Meter
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 每平方米的模式
- en: The *count of software patterns applied* in a product is never a good quality
    metric. Software patterns are well-known, reusable templates for solving particular
    problems. Don't make the mistake of assuming that a system that includes a bunch
    of software patterns is superior to one with fewer of them.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '*应用的软体模式数量*从来不是一个好的质量指标。软件模式是解决特定问题的著名且可重用的模板。不要犯这样的错误：假设一个包含大量软件模式的系统比那些包含较少模式的系统更优越。'
- en: Expect Failures and Deal with It
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预期故障并应对
- en: Catastrophic system failure is clearly undesirable. A system that never completely
    stops working in the face of subsystem failures is usually preferable. It can
    recover gracefully when subsystems fail and may support a subset of functions
    even if components are unavailable. We can apply architectural patterns wisely,
    for example, bulkheads to reduce the damage done by any individual failure. Absolute
    failures are often easier to deal with than capacity, latency, or seems kind of
    slow issues.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 灾难性的系统故障显然是不可取的。在面对子系统故障时，一个从未完全停止工作的系统通常是更可取的。它可以在子系统故障时优雅地恢复，并且即使某些组件不可用，仍然可以支持部分功能。我们可以明智地应用架构模式，例如，使用水密舱来减少单个故障造成的损害。与容量、延迟或“看起来有点慢”的问题相比，绝对故障通常更容易应对。
- en: 'When reviewing an architecture and, in particular, a distributed one, one piece
    of invaluable advice that I received from a very experienced architect some time
    ago is this – always be asking this question: *What happens if this component
    fails or slows down?* If there is no good answer to the question, then there is
    likely more that needs designing to prevent failure scenarios.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查架构时，特别是分布式架构时，我曾从一位经验丰富的架构师那里收到一条非常宝贵的建议，那就是——总是要问这个问题：*如果这个组件发生故障或变慢，会发生什么？*如果这个问题没有一个好的答案，那么可能需要更多的设计工作来防止故障场景的发生。
- en: The Hammer
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 锤子
- en: One pattern or behavior that we've seen a lot through the years is the Golden
    Hammer pattern, in other words, if all you have is a hammer, everything looks
    like a nail. This is more formally known as the Law of the Instrument.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们多年来看到的一个常见模式或行为是黄金锤子模式，换句话说，如果你手里只有一把锤子，那么所有东西看起来都是钉子。这个现象更正式的名称是“工具法则”。
- en: All developers have their favorite tools and architectural approaches. For example,
    the authors are fans of reactive, streaming architectures (Mike), asynchronous
    event-driven messaging (Noel), and anything with Node.js or Emojis (Donal). The
    risk here is that your own bias may lead you down an architectural path that is
    ultimately the wrong approach.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 所有开发人员都有他们最喜欢的工具和架构方法。例如，作者们是反应式流式架构（Mike）、异步事件驱动消息传递（Noel）和任何与Node.js或表情符号相关的技术（Donal）的粉丝。这里的风险是，你自己的偏好可能会引导你走上一条最终是错误的架构道路。
- en: If you find yourself listening to the first 10-20 seconds of a discussion around
    a business problem and feel compelled to jump in saying Oh well, product, architecture,
    or tool X can help with this, let's face it, you may be reaching for your golden
    hammer.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己在讨论一个业务问题的前10到20秒时，忍不住插话说，“哦，产品、架构或工具 X 可以帮助解决这个问题”，那么面对现实吧，你可能正准备拿出你的金锤子。
- en: Resumé-Driven Development
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简历驱动开发
- en: 'Many times, we''ve been involved in discussions around a technology being used
    in a customer solution that is either out of place or just doesn''t quite fit
    the problem they''re trying to address. We often discover that someone had introduced
    this technology as they were keen to learn it and somehow it went from a technical
    experiment or spike to a core component technology. There''s absolutely nothing
    wrong with technology experimentation; it should be encouraged, but care should
    be applied to ensure that a chosen technology doesn''t lead to a dead end or become
    a technology solution looking for a problem. Examples of technologies where we''ve
    seen this include Service Mesh and others as depicted in *Figure 7.29*:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，我们参与了关于某种技术在客户解决方案中使用的讨论，而这项技术要么不合适，要么根本无法解决他们要解决的问题。我们经常发现，有人引入了这项技术，因为他们急于学习它，结果它从一个技术实验或试探变成了核心技术组件。技术实验本身没有任何问题，应该鼓励这种做法，但我们应谨慎，确保所选的技术不会导致死胡同或变成一个找不到问题的技术解决方案。我们看到的一些技术包括服务网格等，如*图7.29*所示：
- en: '![](img/B16297_07_28.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_28.jpg)'
- en: 'Figure 7.29: Adopting the coolest tech on the block'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.29：采用街区上最酷的技术
- en: Wear Different Hats
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 戴上不同的帽子
- en: Software architecture has to work well from multiple perspectives, not just
    from the design and build viewpoint. Different teams/personas will have different
    perspectives, for example, deployment, testing, and operational management. A
    *good* software architecture will try to address as many of these concerns as
    possible.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构必须从多个角度良好运行，而不仅仅是从设计和构建的角度。不同的团队/角色会有不同的视角，例如部署、测试和运维管理。一种*好的*软件架构将尽量解决尽可能多的这些问题。
- en: Social Media-Driven Development — Keeping Up with the Cool Kids
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 社交媒体驱动开发 —— 跟上潮流
- en: Companies such as Google, Amazon, and Microsoft produce and utilize some amazing
    technology and techniques. These are often focused on the size of the problems
    that these hyper-scalers face. Most of us never work with that scale of complexity
    or user demand, so care should be taken that you judge technology on your particular
    business needs rather than what is the tech *du jour* that the *cool* kids are
    using. One area where we observe this a lot is in the *monolith versus microservices*
    discussion. Both are very relevant and very valid approaches to software architecture.
    Both have their pros and cons, but the correct approach to take is to ask yourself
    what is best for the business and customers that adds value.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Google、Amazon 和 Microsoft 这样的公司生产并利用一些令人惊叹的技术和方法。这些技术通常集中于这些超大规模公司所面临的问题规模。我们大多数人从未与如此复杂或用户需求如此庞大的系统打交道，因此应该谨慎判断技术，依据的是你的特定业务需求，而不是那些*流行*的孩子们正在使用的技术。我们经常在*单体与微服务*的讨论中观察到这一点。两者都是非常相关且有效的软件架构方法。它们各有优缺点，但正确的做法是问自己，什么对业务和客户最有价值。
- en: Good Service Design
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 良好的服务设计
- en: 'Good service design can be hard to achieve. Ultimately, we should always lower
    the operational burden of our applications. We can do this by designing them so
    that we minimize the cost of change of any given application. Modern applications
    are normally broken down into different components or services that expose methods
    or functions. At the heart of good system architecture is service design. This
    is often based on practices such as **Domain-Driven Design** (**DDD**), which
    is fundamentally about understanding a business problem and communicating that
    understanding among the team in an unambiguous way. Services that are part of
    the same business domain are grouped together, like our Tournament Service in
    PetBattle V2, or our Cat Service in our hobbyist application. We can achieve good
    service design by following these two principles:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的服务设计很难实现。最终，我们应该始终降低应用程序的操作负担。我们可以通过设计应用程序来实现这一点，从而最小化任何给定应用程序的变更成本。现代应用程序通常被拆分为不同的组件或服务，暴露方法或功能。良好的系统架构的核心是服务设计。这通常基于**领域驱动设计**（**DDD**）等实践，DDD的核心是理解业务问题，并在团队中以明确无误的方式传达这种理解。属于同一业务领域的服务会被归为一组，例如我们在《PetBattle
    V2》中的比赛服务，或我们在爱好者应用中的猫服务。我们可以通过遵循以下两条原则来实现良好的服务设计：
- en: '**Loose coupling**: When a change to one service does not require a change
    to another service. By designing loosely coupled service APIs, we can deploy service
    changes easily. The interior design of the service may be changed completely without
    API consumers being affected.'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**松耦合性**：当对一个服务的更改不需要对另一个服务进行更改时。通过设计松耦合的服务API，我们可以轻松地部署服务更改。服务的内部设计可以完全改变，而不会影响API的使用者。'
- en: '**High cohesion**: We want related system behavior to sit together and unrelated
    behavior to sit elsewhere. Our order management system is independent of our shipping
    and delivery system. This lowers the cognitive load for developers because related
    system functionality sits together. Often there is design tension here between
    defining related business system domains (using DDD, for example) and reusable
    technical functionality, such as libraries or APIs, that may span multiple systems.'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高内聚性**：我们希望相关的系统行为聚集在一起，而无关的行为则分开。我们的订单管理系统与我们的运输和交付系统是独立的。这减少了开发人员的认知负担，因为相关的系统功能聚集在一起。这里通常存在设计上的张力，例如在定义相关的业务系统领域（比如使用DDD）和可重用的技术功能（如库或API，可能跨多个系统）之间的平衡。'
- en: Technical Design Group-Think
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 技术设计集体思维
- en: We have talked about some anti-patterns when designing systems in general. Another
    bit of advice is for technical leaders to set directions and not just descriptions
    of what to do or of what has been. One way to help achieve this is an exercise
    in parallel thinking, whereby everyone contributes their ideas collaboratively
    and at the same time, rather than just following the one way of thinking from
    the most senior in the team. The emphasis is on *what can be*, not *what is*,
    to help design a way forward. It is not about who is right and who is wrong.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了一些设计系统时的反模式。另一条建议是，技术领导者应设定方向，而不仅仅是描述应该做什么或已经做了什么。实现这一点的一种方法是进行平行思维练习，让每个人同时并协作地贡献他们的想法，而不是仅仅跟随团队中最高级别成员的思维方式。重点是*未来可以做到什么*，而不是*当前是什么*，以帮助设计前进的道路。这不是关于谁对谁错。
- en: Human Resources and Time Are Your Most Valuable Assets
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 人力资源和时间是你最宝贵的资产
- en: In knowledge-based work, humans are usually the most expensive resource. So,
    it makes sense to strive to reduce toil or undifferentiated manual work. This
    is a never-ending trend to automate all the things, which allows much better quality
    and feedback for our products.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在知识型工作中，人类通常是最昂贵的资源。因此，努力减少琐碎或无差异的手工劳动是有意义的。这是一个永无止境的趋势，即自动化一切，从而为我们的产品带来更好的质量和反馈。
- en: Information Leakage – Data Centricity Matters
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信息泄露 – 数据中心性至关重要
- en: 'In tech, we are flooded with data. But do we make the best use of all the data
    available in our applications and systems? When architecting, we have to consider
    carefully the quantity and quality of data available within our applications and
    infrastructure. Often, engineering decisions and trade-offs must be made that
    move data processing nearer edge devices just because sending all that data back
    to a central processing core is not physically possible because of bandwidth or
    latency restrictions, or it is just too costly to move all that data around (think
    cloud!). So, when designing systems, consider when:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在技术领域，我们被大量数据淹没。但我们是否充分利用了在我们的应用程序和系统中可用的所有数据？在进行架构设计时，我们必须仔细考虑应用程序和基础设施中可用的数据的数量和质量。通常，工程决策和取舍必须做出，将数据处理靠近边缘设备，仅仅因为将所有数据发送回中央处理核心在物理上是不可能的，原因可能是带宽或延迟限制，或者移动这些数据的成本过高（想象一下云计算！）。因此，在设计系统时，考虑以下情况：
- en: Data integrity is lost during data capture
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据在捕获过程中丧失了完整性
- en: Data is not streamed or stored at all
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据根本没有被流式传输或存储
- en: Data is not accessible for other uses
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据无法供其他用途访问
- en: Data is not analyzed at all
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据根本没有被分析
- en: Data is not communicated and remains hidden
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据没有被传输，且保持隐藏状态
- en: Data is not used in decision-making
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据未被用于决策
- en: We often forget to think about how much data is lost – the lost data can be
    a massive source of lost opportunity for our business. This happens in cloud,
    IoT, industrial, and even mobile web use cases with processing data on our mobile
    phones.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们常常忘记思考丢失的数据量——丢失的数据可能是我们业务中巨大机会的损失源。无论是在云计算、物联网、工业应用，还是在我们的手机上处理数据的移动网页用例中，这种情况都会发生。
- en: Some Final Musings on Architecture
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些关于架构的最后思考
- en: Architecture is a critical concern when building software systems. Getting it
    right is a continuous balancing act of reviewing current and potential future
    requirements and assessing how the architecture fits those requirements.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 架构在构建软件系统时是一个至关重要的考虑因素。做对架构是一个持续的平衡过程，需要审视当前和潜在的未来需求，并评估架构如何适应这些需求。
- en: A certain degree of upfront architecture and design work is always needed, and
    it should be accompanied by flexibility and honesty to ensure that the initial
    architecture can change as answers to uncertain questions are discovered and more
    information is added to the collective understanding of the problems at hand.
    The ability to constantly improve the architecture throughout the product life
    cycle is another important goal.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，都会需要一定程度的前期架构和设计工作，并且应该伴随着灵活性和诚实，以确保初步架构能够随着不确定问题的答案被发现，以及随着更多信息被纳入对当前问题的集体理解，而发生变化。能够在整个产品生命周期中不断改进架构，是另一个重要目标。
- en: 'One quote that comes to mind when we talk about big upfront decisions is the
    following famous quote from a Prussian field marshal: *No plan survives contact
    with the enemy. – Helmuth von Moltke*. Or, in more modern terms: *Everyone has
    a plan till they get punched in the mouth. – Mike Tyson*.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论重大的前期决策时，脑海中浮现出以下普鲁士陆军元帅的著名名言：*没有任何计划能经受住与敌人接触的考验。 – 赫尔穆特·冯·莫尔特克*。或者，换个现代的说法：*每个人都有计划，直到他们被打了嘴巴。–
    麦克·泰森*。
- en: Flexibility, adaptability, and the willingness to change are key characteristics
    required for success in dynamic environments. In summary, there are many architectural
    considerations that the team needs to consider as their applications scale and
    adapt to change. By experimenting and adapting the architecture as the business
    needs change, they will be better able to deliver the service SLAs that were promised
    and ultimately evolve the user experience to be optimal.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 灵活性、适应性和改变的意愿是成功应对动态环境的关键特征。总而言之，团队在应用程序扩展并适应变化时需要考虑许多架构因素。通过在业务需求变化时进行实验和调整架构，他们将更好地提供承诺的服务SLA，并最终使用户体验达到最佳状态。
- en: Conclusion
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, we continued our exploration of technical practices to create
    a solid foundation for us to be able to deliver at speed as one single cohesive
    unit. By using techniques such as the Big Picture to gain a shared understanding
    of our delivery pipelines, we further identified methods for testing and how we
    can connect the business to the acceptance tests in a way that's more developer-
    and business-friendly.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们继续探索了技术实践，为我们能够以快速和统一的团队交付打下坚实的基础。通过使用“大局观”技术，帮助我们对交付流程有共同的理解，我们进一步识别了测试方法，并探讨了如何以更加开发者友好和业务友好的方式将业务与验收测试连接起来。
- en: '![](img/B16297_07_29.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_29.jpg)'
- en: 'Figure 7.30: Adding more technical practices to the foundation'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.30：在基础上添加更多的技术实践
- en: As we explored lessons that led us to an emerging architecture approach, we
    also learned that a lot of the magic is in having the conversation to begin with.
    Treating the whole of your IT organization as a satellite will not be effective;
    we must create an environment where we can succeed as a whole. Key to this is
    bringing together the people with the knowledge, and the people with authority
    and power.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索带领我们走向新兴架构方法的课程时，我们也意识到，很多的“魔力”来自于首先进行对话。将整个IT组织当作一个卫星来对待是行不通的；我们必须创造一个能让我们整体成功的环境。关键是要将拥有知识的人和拥有权威与权力的人聚集在一起。
- en: In later chapters, we will go more in-depth into the technical implementation
    of PetBattle.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我们将更深入地探讨PetBattle的技术实现。
- en: 'To close off this section, we have now built a solid foundation of culture,
    leadership, and technical excellence. We have put in place principles and practices,
    including:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这一部分，我们已经建立了文化、领导力和技术卓越的坚实基础。我们已经建立了包括以下内容的原则和实践：
- en: Autonomy, mastery, and purpose
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自主性、精通度和目标感
- en: Psychological safety
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 心理安全
- en: Social contracts, stop-the-world events, real-time retrospectives, team identity,
    and information radiation
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社会契约、停机事件、实时回顾、团队认同和信息辐射
- en: Leadership intent and team empowerment
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领导意图与团队授权
- en: Priority sliders
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先级滑动条
- en: Team spaces
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队空间
- en: Everything as code
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一切皆代码
- en: Containers
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器
- en: Continuous integration, continuous delivery, and continuous deployment
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成、持续交付和持续部署
- en: Test automation
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试自动化
- en: Emerging architecture
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新兴架构
- en: '![](img/B16297_07_30.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16297_07_30.jpg)'
- en: 'Figure 7.31: The foundation of culture and technical practices'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.31：文化和技术实践的基础
- en: Our foundation is strong. It will need continuous nurturing and bolstering as
    we build products on top of it. However, we're good to go with our first product
    teams. In the next chapter, we'll explore some practices we can use for continuous
    product discovery.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基础很强大。随着我们在其上构建产品，它将需要持续的培养和加强。然而，我们已经准备好启动我们的第一个产品团队。在下一章中，我们将探索一些可以用于持续产品发现的实践。
