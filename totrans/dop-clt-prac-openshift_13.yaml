- en: 9\. Discovering the How
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we started our first iteration of the Discovery loop.
    We focused on practices that helped us discover why and who we're trying to solve
    problems or realize opportunities for.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will shift our focus onto collaboratively learning how
    we might start building a solution that fixes problems for these people or realize
    some new opportunities for them. The practices that we''re going to explore to
    help do this include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event storming**: A colorful practice that visualizes business processes
    into event-driven domains with an emerging architecture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Emerging architecture**: A principle we follow whereby we capture just enough
    information from the Event Storm and other artifacts to start our architecture
    and allow it to emerge over time as we add more complexity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-functional map**: A practice that facilitates conversations to explore
    different non-functional aspects of the solution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metrics-based process map**: A practice that allows us to capture some baseline
    measurements of legacy systems and identify bottlenecks in systems and that provides
    a strong case for moving to a more continuous delivery mode of delivery'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collectively, one of our favorite practices is event storming because it is
    so collaborative and inclusive. It provides something for every role in a team.
    Customers often tell us that what we achieve in a few days using event storming
    would have taken months to capture in a business analysis project.
  prefs: []
  type: TYPE_NORMAL
- en: Event Storming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Event storming is an agile and lean way of getting teams to collaborate on technical
    domain projects, combine thoughts, and learn to work with a shared understanding.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: The Event Storm color puzzle'
  prefs: []
  type: TYPE_NORMAL
- en: Event storming is a modeling workshop for visualizing processes within a business
    or a system. It can give perspectives from differing heights within an organization.
    At the business operation level, Big Picture Event Storming can identify gaps
    and areas of frustration between organizational structures, highlighting where
    tradeoffs exist and thus highlighting areas that need improvement. We can zoom
    in to a lower level of detail by using business process modeling through to application
    feature modeling. Collectively, these allow developers, designers, end users,
    and business stakeholders to speak a shared language where complicated technological
    wizardry is not needed.
  prefs: []
  type: TYPE_NORMAL
- en: While at first the process can seem complex, it has become one of our favorite
    practices at Open Innovation Labs to use with our customers. The short time taken
    to break down silos of knowledge and visualize a business process with this technique
    is what impresses us the most. Event storming is the technique we use for gaining
    a shared understanding of how a business process operates while also visualizing
    any potential issues and solutions. Having facilitated many event storms, this
    part of the chapter is our guide to carrying one out and our commentary on how
    best to apply it.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, you need a big modeling surface, ideally a long wall with much more
    space than you can imagine using. You also need plenty of space for people to
    stand around and see the modeling surface.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: A group storming around the modeling surface'
  prefs: []
  type: TYPE_NORMAL
- en: What Is Event Storming?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Event storming was created by *Alberto Brandolini*[1](#footnote-036) and has
    been documented on numerous blog sites, Wikipedia, and YouTube. We will try to
    summarize what we have learned while using and facilitating this practice.
  prefs: []
  type: TYPE_NORMAL
- en: '[1](#footnote-036-backlink) [https://medium.com/@ziobrando](https://medium.com/@ziobrando)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: A full Event Storm detailing two customer journeys'
  prefs: []
  type: TYPE_NORMAL
- en: In essence, event storming is a group of people having a conversation, discussing
    the business objectives, and capturing these things on sticky notes. If you invite
    the right people, the conversation and visual mapping will help emphasize dependencies
    that may have previously remained hidden. Highlighting these dependencies can
    help teams to avoid making the wrong decisions about a product from a technical
    and business perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Event storming is a pattern for exploration and discovery. It comes from the
    world of **Domain-Driven Design** (**DDD**). DDD is a language- and domain-centric
    approach to software design for complex domains. We like to think of event storming
    as being a stripped-down DDD – DDD-Lite – but with more business focus and less
    of the jargon and complexity. By bringing business domain experts together with
    developers, we can collaboratively build process models by applying a common,
    ubiquitous language that enables developers to model an event-driven system and
    discover microservices.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: Event storming approach and people'
  prefs: []
  type: TYPE_NORMAL
- en: An Event Storm workshop gathers people from across the organization. It does
    not focus on any specific technology, so those skills can be left outside for
    the time being. The only requirement of attendees is their energy, attention,
    and willingness to give it a go. During an Event Storm workshop, everyone is armed
    with orange sticky notes – the **events** – and the knowledge about their part
    of the company that they bring with them.
  prefs: []
  type: TYPE_NORMAL
- en: Software creation is an exploratory task, and while exploring, more learning
    occurs. Capturing this is critically important. Event storming is about visualizing
    all that knowledge as an event-based mind map and identifying the gaps, unknowns,
    and pain points within. With the right audience for an Event Storm, you can get
    harmony between groups who traditionally might never meet and, more importantly,
    bring alignment where previously there may have been misunderstanding.
  prefs: []
  type: TYPE_NORMAL
- en: In an Event Storm workshop, you may have the business analysts, who know the
    business needs and demands, identifying the **commands** and **events** alongside
    the developers, who will implement these as features. Couple this with having
    the UX designers (working with end users) doing UI design and data model validation
    to help support this and you all of a sudden have alignment from end to end. You
    also get early verification of what could work and what won't work before you
    write a single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: For a more comprehensive background of event storming, check out the Open Practice
    Library, where you will find more links, articles, and examples of event storming
    being used in the field with our customers. We are going to focus on an Event
    Storm at the process and feature level.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at what you need in terms of ingredients to run a great Event
    Storm.
  prefs: []
  type: TYPE_NORMAL
- en: The Ingredients
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Event Storm ingredients are all the things you need for a successful Event
    Storm.
  prefs: []
  type: TYPE_NORMAL
- en: First up, you need sticky notes and you need lots of them. Think of a very large
    number of them, then double it. Event storming uses a very specific color-coded
    key. It is important to stick to the authors' colors as it gives consistency as
    you move from Event Storm 1 to Event Storm 2.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need energy. Event storming is an intense workshop that requires people's
    attention the whole time. Ironing out misconceptions requires the right people
    and for them to be able to speak out. Bring lots of good coffee and plenty of
    water and fruit!
  prefs: []
  type: TYPE_NORMAL
- en: You will need a good open space. Give yourself an unlimited modeling surface.
    Roll out some plotter paper, or if you're struggling for wall space, use big foam
    boards that can be moved and added to. You don't want to constrain the amount
    of information gathered by lack of wall space.
  prefs: []
  type: TYPE_NORMAL
- en: People are the most important ingredient. Invite the right people. Get your
    end users, the business analysts, architects, business owners, product owners,
    and developers. Get all the people. The more people you can get, the more fleshed
    out your Event Storm will be. A great event storming coach and facilitator will
    seek to bring everyone who knows the product and everyone who is collectively
    involved in building the product to the Event Storm. If that's too many people,
    they'll look for representatives from each department or team across the organization
    that makes up this cross-functional group.
  prefs: []
  type: TYPE_NORMAL
- en: We have created an Amazon shopping list[2](#footnote-035) for those looking
    for a shopping-list-as-code Event Storm experience. Once you have all the ingredients,
    let's take a look at the recipes to cook up a great Event Storm.
  prefs: []
  type: TYPE_NORMAL
- en: '[2](#footnote-035-backlink) [http://amzn.eu/dViputa](http://amzn.eu/dViputa)'
  prefs: []
  type: TYPE_NORMAL
- en: The Recipe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The event storming recipe is the list of things to do and the order to do them
    in!
  prefs: []
  type: TYPE_NORMAL
- en: First up, you need to preheat your oven. By that, we mean hack the space. Remove
    all the chairs from the room and mark a big, empty wall space for you to roll
    out the modeling surface. Chairs lead to people sitting down, which leads to people
    not participating, which leads to people falling asleep! Give yourself lots of
    room and roll out your plotted paper/foam boards. Do not start in a corner; start
    in the middle of the room if possible. Starting in a corner will mean only 50%
    of the audience will be able to gather around it, therefore removing half of the
    knowledge being offered.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: Rolling out the modeling surface'
  prefs: []
  type: TYPE_NORMAL
- en: Bring out the **Event Storm Flow**, which is a key or legend to the Event Storm.
    We usually make posters (on large, flip chart-sized sticky notes) the night before
    running the workshop, as this can be time-consuming. Hang it so it is within eyeshot
    of all the attendees. People who are new to event storming will want to keep referring
    to it to guide them initially.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: Event Storm Flow'
  prefs: []
  type: TYPE_NORMAL
- en: A more digitized version of this could be added to a digital tool (such as Miro
    or Mural) if you are going to try to run the Event Storm with distributed team
    members.
  prefs: []
  type: TYPE_NORMAL
- en: We normally walk through the flow of the Event Storm at this stage with the
    attendees. This can be fairly overwhelming as there is a lot to introduce. We
    create and walk through an example based on something fabricated but relatable
    to everyone present to help hammer home the key points. Usually, we will go for
    either a to-do list app or something more tangible such as an online Amazon purchase.
    Everyone can relate to these.
  prefs: []
  type: TYPE_NORMAL
- en: With the ingredients all laid out and the oven preheated, it's time to start
    creating the mixture! We start with Events.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: The Events key'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do is set the goal of the event storming workshop. This could
    be the entry point of the flow, the endpoint, or both. Introduce the event poster
    shown in the previous image. In its simplest form, an event is just something
    that happened in the past that someone cares about. With the starting point set,
    ask the attendees to divide into groups of two to three and identify all the events
    they can think of in the system. Timebox this activity. We usually go for 15 to
    20 mins initially and hover around making sure people are on task and conversing,
    clarifying things if needs be. If there are SMEs in the groups, we make sure they
    are divided into the groups equally and not bunched together in one. The SMEs
    are often in the best position to guide this initial building out of the event
    spine because they understand a lot about the domain in question.
  prefs: []
  type: TYPE_NORMAL
- en: With the team's events identified, ask for a volunteer group to play their events
    back to the group by adding them to the modeling surface and begin telling the
    story. Enforce the timeline of the events, moving from left to right. The first
    person in a group to volunteer their spine should be rewarded with a gold medal
    for breaking the ice. We often draw a medal on a sticky note and award it to this
    person so they can wear it with pride! A top tip is to not start fully on the
    left-hand side of the modeling space. When things start to get moved around as
    more knowledge is uncovered, this space can be useful to grow into.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.8: Hanging events on behalf of her team'
  prefs: []
  type: TYPE_NORMAL
- en: Ask the other groups to add in their events along the timeline. Encourage the
    attendees to shuffle theirs along the surface to make room for more events to
    follow. If teams come up with different words to describe the same event, try
    to get a consensus on the language. Clarify events that are not fully developed.
    For example, if a group has a very high-level event such as *Item Ordered*, break
    it down into lower-level details such as *Item Added to Basket* or *Checkout Opened*.
    If there are any questions or assumptions being made, mark them if they cannot
    be answered just yet.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to park the things that cannot be answered confidently and move
    on or you can end up in the weeds very quickly. Ensure enough time is given to
    the discussion in case the answers can be uncovered, but if not, mark them with
    a pink sticky note representing a question. Initially, the **question** key will
    be used very frequently. That is OK; this is the point where we have the least
    collective knowledge of the system. When marking an area with a question, we are
    stating that the conversation will not be forgotten and can be returned to when
    needed. A good idea can be to hold off on revealing this card until enough conversation
    has been had and it is needed in order to move on. Be sure to capture all sides
    of the discussion using multiple cards if need be.
  prefs: []
  type: TYPE_NORMAL
- en: With the spine of events created, have the teams play through the story from
    front to back and back to front. Add any missing events through the conversation
    that occurs. At this stage, we like to mark **pivot events** with some tape coming
    vertically from a single event. These can be useful in framing the boundaries
    between key things and can be great for quickly identifying key sections of the
    timeline.
  prefs: []
  type: TYPE_NORMAL
- en: The next section introduces the bulk of the keys in an Event Storm puzzle. It's
    time to introduce the **actors**, **commands**, **read model**, and **systems**.
    Add the charts for each so they're within eyeshot. Walk through them with the
    group and clarify if anyone has any misunderstandings.
  prefs: []
  type: TYPE_NORMAL
- en: The command represents a decision made by a user in response to some information
    retrieved from the read model. The actor is the person who issues the command
    and the system is the thing that receives the command. It is the responsibility
    of the system to respond to the command and therefore trigger an event.
  prefs: []
  type: TYPE_NORMAL
- en: There is quite a lot introduced in this section, so its important people do
    not get overwhelmed with the next pieces of the puzzle. It can be handy to go
    through another simple example if the audience needs something more relatable.
    We tend to add a few of these pieces to the spine so the example is now in the
    context of the flow being created by the wider group.
  prefs: []
  type: TYPE_NORMAL
- en: The next part of our key provides a mechanism to capture Questions and assumptions
    as well as External Systems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.9: The Questions and External Systems key'
  prefs: []
  type: TYPE_NORMAL
- en: This is followed by Commands and Actors.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.10: The Commands key'
  prefs: []
  type: TYPE_NORMAL
- en: One more part (for now) to add to the key is the Read Model.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.11: The Read Model key'
  prefs: []
  type: TYPE_NORMAL
- en: The Event Storm posters should detail parts of the key with examples. Teams
    should now prepare to add the new parts of the flow again! Break into groups but
    rotate the members. If there are SMEs in given areas, again, make sure they're
    distributed throughout the teams that are formed.
  prefs: []
  type: TYPE_NORMAL
- en: Ask the groups to come up with the actors, commands, and systems that the command
    is issued to. Timebox this to 15 minutes again for the first pass. If the volume
    of events is quite large and the group is too, it can be useful for the teams
    to take the events between the two Pivot Points and flesh them out. This can speed
    things up, and all will be replayed together afterward so the shared understanding
    can still be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: We try to steer groups away from being bogged down on whether the system is
    internal/external or how it should be named. It's good to keep things fuzzy until
    the last point where we really need to know the low-level details. For us, the
    primary thing with the system at this stage is just to identify that there is
    a thing to which the command is issued, thus triggering the corresponding event.
    In our experience, being fuzzy at this stage prevents people from falling down
    a rabbit hole, and keeps the discussions at a high level so everyone feels included.
  prefs: []
  type: TYPE_NORMAL
- en: Have the teams replay their additions to the Event Storm to the rest of the
    group. By doing this, more discussion will be generated and there will be more
    gaps identified. Capture assumptions and add the missing pieces as part of this
    replay.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.12: Three groups storming around the pivot events'
  prefs: []
  type: TYPE_NORMAL
- en: If the teams have divided around pivot events and more time is desired by the
    groups to flesh out the flow, we will often rotate the groups to a new section
    between different pivot events, set a new time box, and go again. This helps to
    validate other groups' work and also flesh out the flow further with fresh eyes,
    revealing more knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: During the next group replay of the full Event Storm, we introduce the next
    part of the key. The Policies and Procedures are introduced along with the Subprocess.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.13: The Policies and Procedures Key'
  prefs: []
  type: TYPE_NORMAL
- en: The policies and procedures are a great way to flesh out some of the gaps between
    commands and events. While the group is replaying the story, ask questions such
    as *Does this always happen?* or say things such as *Whenever a command is issued*,
    *we always do this event*. Doing so will tease out small things between the events
    that have not yet been thought of. We think this is why Brandolini refers to this
    card as the **Lie Detector**.
  prefs: []
  type: TYPE_NORMAL
- en: The subprocess can be a great way of parking content that will not be stormed
    during the scope of the workshop, but will be returned to later, usually in a
    separate event storming session.
  prefs: []
  type: TYPE_NORMAL
- en: A customer we worked with had a process for third-party fulfillment that was
    out of scope for the process they were trying to uncover. The purple subprocess
    sticky note was used to denote this unexplored area and was returned to in later
    workshops. A simple piece of tape was used to connect the two processes once they
    had been nested beneath each other so the visual connection between the two flows
    was not lost. A top tip is not to use a marker or pen as the flow may be (re)moved
    at a later date!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.14: Storming around some of the parked subprocesses'
  prefs: []
  type: TYPE_NORMAL
- en: Branches in the flow will inevitably occur. We mark these in a visual way using
    happy or sad stickers to denote the positive and negative sides of the flow. We
    tend to model the happy path first. Usually, for every happy flow, there is a
    corresponding sad flow. The subprocess in my eyes is a great way to capture these
    without getting bogged down in branches of the flow that we are not trying to
    explore in the scope of the workshop or wish to return to in more detail later.
  prefs: []
  type: TYPE_NORMAL
- en: If an event results in lots of commands being made available, we stack them
    vertically so the flow can be fleshed out one at a time. If time is tight, it
    can be good to just pick one or two flows to flesh them out and return to the
    others later. It's important when branching occurs to focus on the goal of the
    Event Storm and not getting bogged down in the weeds with low-quality information.
  prefs: []
  type: TYPE_NORMAL
- en: With most of the puzzle pieces in place, by now the Event Storm should start
    to tell a more detailed story. Continue to replay the story forward and backward,
    starting in the middle and going in all directions. Challenge all the items that
    are there, and don't be afraid to add or tear up misconceptions. You should start
    to notice the volume of question sticky notes drop off as knowledge is added to
    the Event Storm.
  prefs: []
  type: TYPE_NORMAL
- en: If the system you're modeling has UI components to it, a great add-on is to
    include some high-level UIs to the read model. Simple sketches on sticky notes
    can quickly validate what components the UI might need, as well as validating
    that the data that's needed for them can be retrieved. If you invited any end
    users of the application to the Event Storm, it can be really powerful to replay
    the Event Storm with any UI designs with them to further validate the hypothesis
    of the flow.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.15: The group adding UI to the Event Storm on green sticky notes'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it's time to identify and name the aggregate. The Aggregate is the
    state machine of the system.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.16: The Aggregates key'
  prefs: []
  type: TYPE_NORMAL
- en: It's the thing that receives a command and decides to act upon it or not. We
    only introduce the system early in the flow as the aggregate can be the bit that
    leads to the most confusion and be the biggest time sponge – especially when trying
    to name it!
  prefs: []
  type: TYPE_NORMAL
- en: By holding off until the end, a large portion of the unknowns is cleared up.
    When the flow is more fleshed out, we get the group to replay the Event Storm
    and identify where a system is either existing or has to be built. If it has to
    be built, we add the yellow aggregate card and give it a nonsense name such as
    combobulator. By doing so, it helps people not get bogged down in the boundary
    of where the aggregate should be defined.
  prefs: []
  type: TYPE_NORMAL
- en: Continue to replay the flow and the group will naturally start to identify that
    some commands are issued to the combobulator and others to something else. Capture
    these as something else. When a full pass of the Event Storm has been completed,
    then return to naming it. The depth of understanding should be so high that the
    name and boundary of the aggregate should naturally fall out.
  prefs: []
  type: TYPE_NORMAL
- en: Event Storming with Doubters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](img/Donal.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It's no secret – event storming is my favorite practice. I think it is an immensely
    versatile practice that can be used at various levels of detail to speak a coherent
    language with people from all walks of a company. You can play it back to end
    users to validate a user journey while also keeping the techies involved by identifying
    the system design required to support it.
  prefs: []
  type: TYPE_NORMAL
- en: When I worked for a Swedish car manufacturer, we used event storming to design
    a solution for our app. One of their Java engineers working with us was extremely
    skeptical about this and our process initially. He admitted to me that he saw
    us coming in and thought *Oh, here comes the Post-it brigade*. But once we got
    into it, he rapidly became convinced, he could see the solution unfolding in front
    of us as the team of designers, business analysts, developers, and users all stormed
    around the modeling surface together.
  prefs: []
  type: TYPE_NORMAL
- en: After a couple of days at it (yes, really days!) he came up to me and said how
    shocked he was that in such a short amount of time we'd uncovered so much domain
    knowledge and had revealed enough of the solution for us to start playing with
    the technology and building it out. He was convinced!
  prefs: []
  type: TYPE_NORMAL
- en: Event storming is so versatile – in that same engagement, we were building our
    Event Storm around how a person would author new content within their application.
    It was a knowledge-based application so content manipulation was a key component
    – think of it as a Wikipedia for cars. While modeling it, we came to one section
    of the flow where in the journey, a user would edit some text and save their progress.
    This set off some alarm bells for me as the product owner kept saying the user
    would save their article and then publish it. Having a save button that someone
    would need to press in order to progress seemed odd. In my view, the app should
    have just been saving edits transparently to the user. Suddenly to me it felt
    like we were designing Microsoft Word 97 as opposed to a modern web app in the
    2020s.
  prefs: []
  type: TYPE_NORMAL
- en: So, I challenged the product owner and said, "Should we not have the app autosave
    for us?" He was not in agreement and thought the users would want to save their
    progress manually. I figured, let's use the Event Storm to run an experiment!
    We captured both sides of our arguments for and against a manual save and put
    them on a pink Post-it to represent an assumption we're making. I tend to put
    a dot sticker on Post-its that require further exploration or experimentation.
    This makes it easier to view when looking at the full model. We put a placeholder
    event on the model to say *progress saved* until we'd done some further research.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.17: Using an Event Storm to discuss the autosave feature'
  prefs: []
  type: TYPE_NORMAL
- en: This assumption was then written into our backlog, where our designers were
    able to run an experiment with a clickable prototype to see what the users wanted
    or needed. In the clickable prototype, there was no save button and when asked
    after the tests if they felt it was missing, all of the respondents said they
    assumed their progress was being saved as they updated the content.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to the Event Storm, now we had validated an assumption we've made.
    This meant we could proceed to model out our understanding of the user flow at
    this point. It also meant we could extend the things we'd need to build from a
    technical standpoint with this understanding.
  prefs: []
  type: TYPE_NORMAL
- en: I always think an Event Storm is the best guess at a point in time with the
    knowledge of the people we have in the room. Setting up our environment with a
    social contract to ensure psychological safety means we can freely explore our
    system. We are able to make guesses and return to them or put placeholders on
    the map until we do some further research. This is why event storming, especially
    when paired with all the other practices, is such a great fit for discovering
    and designing a system.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive back into the PetBattle story and look at how their team built up
    their Event Storm.
  prefs: []
  type: TYPE_NORMAL
- en: PetBattle Event Storm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The PetBattle team has decided to use event storming to design part of their
    system. As with all great teams, they started by defining the example they would
    map out. This is important as it frames the end-to-end journey and stops them
    from modeling too big a piece of the application.
  prefs: []
  type: TYPE_NORMAL
- en: '!TOP-TIP => The team is using Friends Notation for their examples. This is
    based on the US sitcom Friends,[3](#footnote-034) where every episode title starts
    with the words The One Where. They have taken some of the deliverables from the
    Impact Map to drill down into the system design and have come up with *The One
    Where Mary enters the daily Tournament and wins a prize*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[3](#footnote-034-backlink) [https://en.wikipedia.org/wiki/Friends](https://en.wikipedia.org/wiki/Friends)'
  prefs: []
  type: TYPE_NORMAL
- en: They add this to their Event Storm in the top-left corner and add Time before
    coming up with the spine of the events.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.18: The One Where Mary enters the daily Tournament and wins a prize'
  prefs: []
  type: TYPE_NORMAL
- en: Individually, the team members came up with all the events within the boundaries
    of the example defined. Starting in the center of the map, one team member put
    their events on the map, describing the story to the team.
  prefs: []
  type: TYPE_NORMAL
- en: Other team members filled in the gaps to include their events, thus forming
    the overarching spine of the story. Here are the first stickies from the PetBattle
    Event Storm. There may be other events that sit between these ones, but the team
    is happy with the depth they have gone to for the moment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.19: First events added to the board'
  prefs: []
  type: TYPE_NORMAL
- en: When two team members had similar events written differently, both were initially
    put on the board and discussed further before agreeing on one phrasing for the
    event.
  prefs: []
  type: TYPE_NORMAL
- en: In the example, *Cat Photo Reviewed* versus *Cat Photo Validated* was up for
    discussion. Ironing out the language of the events is important to bring the team
    to use a consistent vernacular.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.20: Capturing the first unknown / question'
  prefs: []
  type: TYPE_NORMAL
- en: If they cannot agree, or need to make an assumption on the flow, we use a pink
    sticky note to highlight the discussion and capture it on the modeling surface.
    For example, the team decided they didn't need to go into the detail of describing
    how image validation would work at this stage, but they may return to it later.
  prefs: []
  type: TYPE_NORMAL
- en: The team continued to explore the event spine. They filled it out by reading
    the story from left to right and again from right to left, adding new events as
    required. Once they were satisfied with the event spine, they moved on to the
    commands and the data.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.21: The PetBattle event spine'
  prefs: []
  type: TYPE_NORMAL
- en: 'The team now introduced three more pieces to the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The actor** – the who of the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The command** – the action or decision taken by the actor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The read model** – the data needed in order to be able to take an action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can start to tell the narrative of our users' journey. In this example, our
    actor, Mary, *Opens PetBattle*. Whenever this occurs, we display the current leaders
    including information such as the number of votes each cat has, an image of the
    cat, and the owner's name.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.22: Narrating Mary''s PetBattle journey through Event Storm'
  prefs: []
  type: TYPE_NORMAL
- en: While looking at the leaderboard, Mary has a number of options available to
    her. In an Event Storm, things happen sequentially over time. Some commands may
    be carried out in parallel or at any given moment in the flow. A good convention
    is to add commands to the map as soon as they become available to an actor.
  prefs: []
  type: TYPE_NORMAL
- en: When Mary lands on the leaderboard page, there are many journeys that she could
    take. She could log in to play the game, she could vote for a cat in the currently
    running game, or she could simply navigate away from the site. Our convention
    is to stack these commands as each could represent another flow that needs to
    be mapped out. It's important for the team to not drift too far away from the
    example they are mapping out, so they are captured and added to the board but
    not further explored.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.23: Stacking commands'
  prefs: []
  type: TYPE_NORMAL
- en: The read model may be more than data. It could also include a low-fidelity UI
    mockup. Small UI experiments provide a great opportunity to generate user feedback.
    This provides us with product direction without writing a single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: For example, once the *Leader Board Displayed* event occurs, we could sketch
    out what it looks like. This gives our actor an overview of what options are available
    to them and how they could interact with the system.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.24: Sketching out UI ideas'
  prefs: []
  type: TYPE_NORMAL
- en: The PetBattle team's Event Storm is starting to take shape with the addition
    of commands, read models, and actors.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.25: Full Event Storm taking shape'
  prefs: []
  type: TYPE_NORMAL
- en: The PetBattle team now add any external systems they're integrating with along
    with policies/procedures and aggregates.
  prefs: []
  type: TYPE_NORMAL
- en: The purple Policy sticky note is a great way to add rules or habits to the Event
    Storm tying commands to events that were not initiated by an actor.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.26: Adding the first Policy'
  prefs: []
  type: TYPE_NORMAL
- en: In our example, whenever we open the application, we immediately display the
    leaderboard. The actor does not ask for them to be shown so we can connect the
    *Website Opened* event to the *Display Leaders* command by a *Display Leaderboard*
    procedure.
  prefs: []
  type: TYPE_NORMAL
- en: A command must always be issued to a system or an aggregate of systems. This
    system must decide to accept or reject the command and propagate the corresponding
    event(s). This results in happy path events (everything goes OK) or sad path events
    (some error). Generally speaking, there is a lot more value in happy path events
    so we Event Storm the happy path. There is still value in capturing and questioning
    sad path events, for example, the *Cat Photo Invalid* event – *do we care about
    this now?*
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the *Display Leaders* command is issued to the *Tournament Service*.
    The Tournament Service is a new entity (an aggregate) that is responsible for
    holding the state of who's winning the current (and possibly the previous) tournaments.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.27: Processes, policies, and services added to the Event Storm'
  prefs: []
  type: TYPE_NORMAL
- en: The PetBattle team has continued along the flow and event stormed how Mary can
    enter the competition. The Event Storm can now be read much like a story, capturing
    key things the team could explore now or later. Reading from left to right, Mary
    uses her image and ID to add her cat to the competition, then this command is
    issued to a cat service that is responsible for holding the cats' properties,
    such as image and owner.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the photo is uploaded, we execute the verify image policy. The team
    knows they're storming a happy path of image upload so they make an assumption
    that the image is a cat. In order to not think about how image verification could
    work, they put a purple diamond sticky note to return to later. The **Not Safe
    for Families** (**NSFF**) process is a process about ensuring images used on the
    internet are safe for children to see. The need for this can be traced back to
    our impact map's deliverables. The team essentially puts a pin in it here with
    the purple sticky note, knowing they can return to it later when other bets have
    been verified. There may be a lot of information required for the full implementation
    of the NSFF process. It may require further discovery steps. We have now gathered
    just enough information to carry on with our Event Storm.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the cat photo is valid, we immediately enter Mary's cat into the tournament
    through the *Tournament Entry Policy*. The *Tournament* service aggregates information
    from multiple sources into one new meaningful object. It takes *cat.id* that's
    just been uploaded, Mary's ID, and the number of votes Mary's cat received. The
    *Tournament* service processes where Mary's cat sits in the leaderboard along
    with the other competition entries. When the *Animal Lovers* play the game now,
    they will amend the total count for each cat in the current competition.
  prefs: []
  type: TYPE_NORMAL
- en: In an early version of PetBattle, cats were being randomly fetched from the
    internet when there were not enough players uploading their own cats. In an Event
    Storm, this external system is captured on a pink Post-it. The following example
    shows how we could model this interaction. We fetch the tournament cats from the
    *Tournament* service, which results in no cats being found, triggering the *Empty
    Competition* policy. Whenever this occurs, we always fetch random cats from the
    internet and add them to the game. Capturing third-party systems in an Event Storm
    can highlight dependencies that exist within our application.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.28: Using a pink Post-it to capture external elements'
  prefs: []
  type: TYPE_NORMAL
- en: The cross-functional team working on PetBattle's Event Storm includes representatives
    of their UX team. The *User Interface* card provides us with the ability to create
    high-fidelity prototypes. If the group cannot agree on something or have to make
    an assumption, then validation with some end users may be required.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of PetBattle, we had some heated debates around the design of the
    leaderboard. We couldn't agree on how many cats to show, that is, the top 10 or
    just the top three. We also couldn't agree on whether we should always show Mary's
    uploaded cat, even if it was not attracting any votes to be in the top.
  prefs: []
  type: TYPE_NORMAL
- en: We decided to capture this discussion on a pink Post-it. This Post-it represents
    work that needs further exploration and possibly some user research to find out
    what functionality the players of the game would like to see here. As with all
    work, this can be captured and added to our backlog. The team could also build
    out multiple versions of the application, showing the top three cats and the top
    ten. Using OpenShift, we could deploy both versions of the app and gather some
    feedback on the user engagement metrics to help determine which version is preferred
    by the players. In the next section of this book, we will explore some of the
    options around deployment strategy, such as A/B testing, which will enable us
    to learn about the optimal solutions based on behavior and impact.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.29: Using a pink Post-it for a feature that is yet to be finalized'
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the Event Storm exercise, the flow represents a best guess made
    by the team knowing only what they currently know. It is not a static document
    but one that is revisited as they build some of the features identified on the
    map. We now have just enough information to be able to design how the components
    of the system could interact.
  prefs: []
  type: TYPE_NORMAL
- en: We'll see how all of this information is used by other practices on the Options
    Pivot section of the Mobius Loop in *Section 4, Prioritize It*.
  prefs: []
  type: TYPE_NORMAL
- en: Final Thoughts on Event Storming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Event storming is a brilliant technique. The domain knowledge it extracts and
    the time taken to accomplish it is powerful. It can be used at a business level
    to identify pain points and areas to improve, much like a Value Stream map. Lower-level
    event storming is a great, immersive, collaborative process for designing software.
    We would highly recommend you try it; it's a tough one to get right but practice
    makes perfect.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to talk about our approach to discovering
    the technical architecture. Now that we have completed the first run-through of
    our Event Storm, we should be getting ready to run some experiments and write
    some code!
  prefs: []
  type: TYPE_NORMAL
- en: Emerging Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point in time, a traditional architecture approach would be to write
    a high-level or detailed design document. This would normally take months and
    is an activity that would be carried out by enterprise or solution architects.
    It usually involves a high dosage of UML (Universal Modelling Language) diagramming
    and many pages of technical discussion and validation. Let's look at a different
    approach that better aligns with our discovery practices so far.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind emerging architecture is that we get *just enough* knowledge
    and shared understanding of a business domain with *just enough* understanding
    of the logical architecture needed to deliver high-business value features. The
    major architectural approaches can be decided at this stage, such as decoupled
    services, event-driven architecture, APIs, and streaming applications – and subsequently,
    this will be refined in the following iterations.
  prefs: []
  type: TYPE_NORMAL
- en: In our Event Storm, we drilled down on one or two of the TOWs (The One Wheres).
    We want to be confident that the aggregates, commands, and read models would deliver
    just the capability described in that part of the business domain – no more and
    no less.
  prefs: []
  type: TYPE_NORMAL
- en: By taking an emerging architecture approach, we do not invest time in building
    a comprehensive architecture that is not yet going to add business value. It may
    be that the future direction of the product or re-prioritization of features means
    that this architecture is actually never used and therefore time is not wasted.
  prefs: []
  type: TYPE_NORMAL
- en: The team will gather an increased level of shared understanding and confidence
    in the overall solution as they incrementally deliver it. This means that any
    future solutioning conversations benefit from that additional context and understanding.
  prefs: []
  type: TYPE_NORMAL
- en: After our first pass of the Event Storm, our initial draft of the architecture
    is depicted here.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.30: First pass of the PetBattle Event Storm'
  prefs: []
  type: TYPE_NORMAL
- en: We haven't yet fleshed out the details of the AUTH (Authentication), NSFF, and
    Notification processes. These would usually be expanded in subsequent iterations
    of the Event Storm practice. However, given the linearity of books, it was decided
    to add these here to give you an indication of what a future architecture could
    potentially look like.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning an Event Storm to an Emergent Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](img/Author_4.jpg)![](img/Noel.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Event Storm should lend itself nicely to an emergent architecture. The Event
    Storm identifies the systems and aggregates that need to be built. This can give
    you a good idea of where you need to take the design of your software but doesn't
    mean it all needs to be built upfront. You may learn from a user experiment that
    some functionality is not needed or that your initial thoughts on the Event Storm
    were not refined enough. This might sound like bad design but in fact it's just
    better-qualified design that's evolving through experimentation.
  prefs: []
  type: TYPE_NORMAL
- en: We ran an engagement with the **World Health Organization** (**WHO**)[4](#footnote-033)
    that was all about trying to prove out their architecture and building a strong
    cross-functional team around their new learning experience platform. This is the
    platform that health professionals around the world would use to consume learning
    content from the WHO.
  prefs: []
  type: TYPE_NORMAL
- en: The initial Event Storm with the team threw up some interesting services that
    were needed. The course service, which was a type of catalog, as well as a highly
    available and scalable authentication provider were identified as key components.
    As the reader, you may not be able to see all the detail on the figure below and
    it is not necessary - it's simply included to show the amount of information already
    collected.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.31: Event storm of our WHO project'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Event Storm was not overly complex but it looked like this after many weeks
    and informed revisions. The details of each item are not super important; suffice
    to say the long pink and yellow stickies represented unique APIs we needed to
    build from a technical point of view. Ultimately, we discovered through our Event
    Storm a large number of components, not all of which were validated with end users:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.32: Components discovered during WHO Event Storm'
  prefs: []
  type: TYPE_NORMAL
- en: We knew we had lots to do but we also knew we didn't need to do it all at once.
    From our Event Storm, we iteratively built functions and features, adding to the
    architecture as required. This meant we could be focused and lean, keeping one
    eye on the big picture without over-complicating our goal.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.33: Sprint 1 emerging architecture'
  prefs: []
  type: TYPE_NORMAL
- en: 'We evolved the solution design at every sprint. We revalidated the design against
    the Event Storm and only added new components when they were needed. Our first
    sprint introduced the basic elements: a simple frontend application talking to
    an instance of the Red Hat Single Sign-On server (the upstream project is called
    Keycloak).'
  prefs: []
  type: TYPE_NORMAL
- en: The second sprint saw us add our first microservices, discovered as systems
    or aggregates on the Event Storm. In subsequent sprints we added more functionality,
    introduced new components, and hardened previous ones. We added caching to previously
    built services to speed up lookup performance. We were able to build incrementally,
    then add complexity such as a cache after laying the groundwork.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_34.1.jpg)![](img/B16297_09_34.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.34: Sprint 2 and 3 emerging architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.35: Sprint 5 emerging architecture'
  prefs: []
  type: TYPE_NORMAL
- en: We evolved the architecture of our system by continuously going back to the
    Event Storm and modeling more The One Where journeys. Each time we did this, new
    services were discovered.
  prefs: []
  type: TYPE_NORMAL
- en: In one example, the WHO wanted to create a rich recommendation engine that would
    help health care workers find relevant health information courses faster. We needed
    to gather preference data to be able to give a recommendation. So, we created
    an onboarding process to help gather this information.
  prefs: []
  type: TYPE_NORMAL
- en: We were constantly connecting with our end users as we added new functionality,
    providing a feedback loop that helped us validate our initial design assumptions.
    By the final sprint, the complexity of our system had grown but each item on our
    architecture could be traced back to its purpose for a user on the Event Storm.
  prefs: []
  type: TYPE_NORMAL
- en: '[4](#footnote-033-backlink) [https://www.redhat.com/en/success-stories/world-health-organization](https://www.redhat.com/en/success-stories/world-health-organization)'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous real-world example, we made use of a cache to speed up API calls.
    Next, we will look at a practice that will help surface these non-functional aspects
    of our solutions.
  prefs: []
  type: TYPE_NORMAL
- en: The Non-Functional Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Non-functional attributes help define the usability and effectiveness of the
    entire solution. The non-functional map is a tool to capture and articulate these
    non-functional requirements for the system that a team is striving to deliver.
    Most of the practices so far have focused on the functional aspects of a solution
    that relate to business features or functions that end users can directly relate
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Non-functional requirements are broken down into areas represented by each segment
    on a canvas, which are examined and populated in turn as a group.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.36: The non-functional wheel'
  prefs: []
  type: TYPE_NORMAL
- en: We can use this mapping tool to gain a shared understanding of non-functional
    aspects of a system in a visually structured representation. On completion, you
    should have a good view of the key non-functional considerations for the solution.
    Mapping these visually can highlight where work is required to realize them.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s a very simple practice to run and could easily be done in an hour with
    the right people in the room:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that everyone participating is comfortable with the headings and what
    they mean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each heading, capture important considerations or requirements for the system
    or solution and add stickies for each item. Depending on the number of participants,
    you could use facilitation techniques such as 1-2-4-all or splitting into smaller
    groups to capture items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each heading, play back the stickies as a group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'During the playback, think about whether each sticky should be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An item added to the backlog and prioritized as it requires work to realize.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An item that should be included in the Definition of Done for other backlog
    items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Part of the acceptance criteria for other backlog items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From Non-Functional Map to Backlog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](img/Noel.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Discovery practices such as event storming or user story mapping are brilliant
    tools that facilitate conversation and generate work for a backlog. However, they
    are not great when trying to surface non-functional requirements for a solution
    as they tend to be more business process-oriented, driving functional features
    and end user aspects of the solution. We used this practice with a large team
    in a recent engagement. We split into three teams, each armed with our own Post-it
    color.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.37: The non-functional requirements map'
  prefs: []
  type: TYPE_NORMAL
- en: The activity provided a great opportunity for the techies to discuss non-functional
    aspects of our application. The tool proved to be a useful platform for inviting
    other stakeholders into the mix, those not directly involved in building the solution
    but who had a vested stake in the design, such as members of the security team.
    The team voted on some of the items they thought were the most important to focus
    on for further discussion.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.38: Focusing on some items of the non-functional requirements map'
  prefs: []
  type: TYPE_NORMAL
- en: Zooming in on some of the sections of the wheel, such as Reliability, the team
    came up with ideas such as health checks and readiness checks. High availability
    and vulnerability scanning came up as topics to explore from a Security perspective.
    We discussed the items we thought were most important, then transcribed them into
    our backlog. Nearly all of the items on our map represented work that could be
    done by the team.
  prefs: []
  type: TYPE_NORMAL
- en: Some items went into our backlog as spikes (or unknowns) to warrant further
    exploration and others were easily written as user stories for the team to implement,
    such as the Kubernetes readiness and liveness probes.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.39: Sprint backlog items resulting from non-functional map'
  prefs: []
  type: TYPE_NORMAL
- en: The non-functional wheel is a great practice to start a conversation about all
    the different non-functional aspects of the solution. One area it will not necessarily
    facilitate conversation in is the speed of delivery and the lead time to deliver
    code to production. This is a big focus for DevOps and therefore something we
    want to pay attention to during our Discovery loop. To shift focus toward continuous
    delivery, it can be helpful to capture some baseline metrics around delivery processes.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering the Case for Continuous Delivery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we have explored some of our favorite practices that
    help us with product discovery: discovery of the Why using impact mapping, discovery
    of the Who using human-centered design practices, and discovery of the What using
    event storming and emerging architecture. We started to explore some of the How''s
    using the non-functional map. The final set of practices we''d like to introduce
    promotes how we are going to develop our software, and it does so, based on metrics.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common questions we get from our customers is how they can release
    their software to users faster and more frequently. Often, they have adopted agile
    techniques for delivery (for example, they may be using the Scrum framework) but
    still only seem to be able to do one or two releases to production every year.
    Why is that?
  prefs: []
  type: TYPE_NORMAL
- en: The first clue may be to heavy a focus on the delivery framework. As we explained
    in *Section 1, Practices Make Perfect*, when we introduced the Mobius loop, achieving
    successful DevOps culture and practice requires a balanced focus of continuous
    discovery and continuous delivery, and a strong foundation of culture and technical
    practices.
  prefs: []
  type: TYPE_NORMAL
- en: To really understand why it is taking so long to release software into production,
    we need to understand where the bottlenecks are. We need to visualize everything
    that happens from the moment a business stakeholder asks for a new feature all
    the way to the moment that that feature is running in production and being used.
  prefs: []
  type: TYPE_NORMAL
- en: In *Section 1, Practices Make Perfect*, we introduced the idea of a value chain.
    The value chain focused on exploring everything from generating the initial list
    of business requirements through to the point when a big release of software is
    running in production. DevOps is focused on speeding up that value chain. A practice
    that will help visualize all these steps and capture some metrics about how long
    they take is called **Metric-Based Process Mapping** (**MBPM**).
  prefs: []
  type: TYPE_NORMAL
- en: We introduced **Value Stream Mapping** (**vsm**) in *Section 1*, *Practices
    Make Perfect*, so you know it's a macro-level map of the end-to-end delivery flow
    of a particular service or product from its inception until it reaches a customer.
    MBPM, on the other hand, is a more detailed or micro-level view of how some of
    the stages or single processes of a vsm deliver value. These detailed-level views
    show flow and metrics that help provide insights into bottlenecks.
  prefs: []
  type: TYPE_NORMAL
- en: Metrics-Based Process Map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start with a simple example of a software development flow. In the real
    world, the map would be more granular, giving you more detailed steps and roles,
    but for the sake of clarity, let''s look at this simplified example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.40: The MBPM'
  prefs: []
  type: TYPE_NORMAL
- en: 'The map''s layout should be read from left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: Each actor or role has a horizontal swim lane. The roles are the leftmost column
    (yellow stickies in the example, BA, Dev, QA, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a defined starting point and ending point that is identified before
    starting the exercise. In the example, the start is defined as Gather Requirements
    and the end with Deploy New Code to Prod.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each non-actor sticky note has a title that corresponds with an event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actor role that owns the work for that event lines up horizontally with
    the actor sticky note.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The events flow from left to right, with earlier events on the left and later
    events to the right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events that happen in parallel are lined up vertically. If there is shared work
    between roles, those should also be separate stickies lined up vertically as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each card contains three metrics:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lead Time** (**LT**): The total amount of time within normal business hours
    from start to finish that it takes to complete the task. This includes any idle
    time or time waiting on other roles to complete work.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Process Time** (**PT**): The total amount of time someone is actively engaged
    in working on the task. This is a subset of lead time.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Percentage Complete and Accurate** (**PCA**): The percentage of time a task
    is completed accurately on the first attempt. This is a compounding percentage
    with earlier dependent steps.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Any useful information about the execution of the process, such as whether it
    is batched or scheduled (and, if so, at what time) and how many people are involved
    in executing the task.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B16297_09_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.41: Lead Time versus Process Time'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we have a software delivery flow that looks like a traditional
    waterfall pattern of gathering requirements, developing, testing, and deploying
    code. Typically, MBPM would be more granular; for example, instead of saying the
    developer *implements code*, you could break that down to:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing implementation code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The developer's integration test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Peer review
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixing identified issues from peer review
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding and Making Improvements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you have completed your map, you now have a communication tool for the
    team and stakeholders to absorb. The map also helps management see the pain points.
    These costs have a time value and that time value has a cost as these issues continually
    occur. If you have more forward-thinking management, then they may be thinking
    about lost opportunity costs as well. You may have faster-moving competitors generally
    delivering value faster, possibly cheaper, and this is eating into your market
    share.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make improvements, look for the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lead time is much higher than process time**: This may indicate things sitting
    in queues or waiting on someone else; this typically happens at handoffs. Is there
    any way to reduce this waiting time?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low percentage complete and accurate**: Why is it so low? If the answer is
    not obvious, this is a great time for a blameless retro with the team. I bet someone
    has some insights as to why it is happening.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unnecessary steps**: Can you deliver value without a step or a scaled-back
    step?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Things that could be automated**: Reducing manual steps can increase speed
    and accuracy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Could changing the order of operations help? Maybe completing one step sooner
    or in parallel would improve accuracy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You may see many problems, and it may be tempting to try to tackle every obvious
    problem at once. A better strategy is to start with the biggest and easiest wins
    first and prioritize a list of ideas from there. Remember to be agile about the
    improvements themselves: focus on small chunks of work to ensure faster delivery
    of work. Get a fast feedback loop and re-prioritize based on feedback.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you make a change, you need to adjust your map accordingly. You should
    pay close attention to the metrics: are the metrics improving given the volume
    of work flowing through?'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.42: The MBPM'
  prefs: []
  type: TYPE_NORMAL
- en: Improving through Iteration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A tool such as this should not be a one-and-done type of improvement. It needs
    to be used as an iterative endeavor where you make constant improvements. Your
    map should be wall art (if you have a physically co-located team) that is living
    and changing as you improve. It's there to remind and inspire future improvements.
    It's also great for onboarding new team members as you can show them how the process
    works visually.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, perhaps there is an additional improvement that could be added
    around testing, so maybe the next step might be some sort of test automation.
  prefs: []
  type: TYPE_NORMAL
- en: As you tackle the obvious issues and implement more modern industry practices,
    you may find yourself getting to a point where the improvements are not as obvious
    or even questionable. This is where metrics can help inform you if your changes
    make you faster. However, in order to figure this out, you need to experiment.
    Technically, when you were knocking out the obvious changes early on, you were
    experimenting, but given that these changes had such a high chance of succeeding,
    it may not have seemed like an experiment. As you move on to the less obvious
    changes, you may get it wrong and implement something slower based on your metrics.
    This is okay; you are learning (the top performers are always learning) – just
    stop and reflect. This is a good place for a retro. Maybe you can change the idea
    or perhaps you need to roll back that change and try something completely new.
  prefs: []
  type: TYPE_NORMAL
- en: I like to think about improvements through automation in layers. If you are
    in an IT department of a non-tech company, the department was likely founded to
    automate business processes in the industry you are serving. However, over time,
    the IT department itself needed to be automated to deliver faster business process
    automation. This is the second layer of improvement. Within this second layer,
    you could bring in a tool such as MBPM to help identify areas within the IT department
    that can be improved. You may end up with common industry solutions such as automated
    testing or CI/CD pipelines, for instance. You can take the automation even further;
    you may quickly realize you need automation around the area of metrics collection.
    Manual MBPM metrics collection can be time-consuming and repetitive and have human
    errors. In order to speed up the feedback loop and free people up for other work,
    you may want to automate the collection of metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, all this automation work comes at a cost but also can benefit from
    it, and that is why metrics are so important to help inform you if the benefits
    are worth the costs. Also, you should not wait until you have metric collection
    automated before you even start using MBPM. Start simple, understand the process
    and what information you want to collect first, then automate once you get your
    rhythm going.
  prefs: []
  type: TYPE_NORMAL
- en: Scoping an Entire Engagement Using MBPM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](img/Author_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At Open Innovation Labs, we run time-boxed residency engagements with our customers.
    They last between 4 and 12 weeks.
  prefs: []
  type: TYPE_NORMAL
- en: When leading an engagement with a Finnish telecommunications company, their
    focus was on improving the lead time for feature development, adopting some self-healing
    and auto-scaling features of OpenShift, and learning more about Kubernetes and
    site-reliability engineering.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike most of my other engagements I'd led, we were not going to perform any
    application development on this residency. No new features. No new business functionality.
    No new functional release. This was purely non-functional and focused on improving
    the operation of the service the team was responsible for.
  prefs: []
  type: TYPE_NORMAL
- en: This felt like a perfect situation to bring out the MBPM practice. It wasn't
    a practice I'd used previously on new greenfield product development engagements.
    But, given this was a legacy brownfield application and focused on improvement
    and optimization, this discovery practice would be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: The team consisted of a representative from the application development team,
    a representative from the application operations team, and an infrastructure specialist.
    Over the course of a couple of days, these three people combined all their knowledge
    of development and operations processes to create an MBPM.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.43: Cross functional team building their MBPM'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the key learnings that came out from this were:'
  prefs: []
  type: TYPE_NORMAL
- en: There were long lead times for any development to start because of the SLA for
    booking virtual machine time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There was a lot of wasted time waiting for builds and deployments to complete
    because there was a dependency on a third-party team to trigger these.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There was low completeness and accuracy in some of the quality assurance due
    to the large amount of manual testing performed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The yellow sticky notes in the following image show all the processes mapped
    into the MBPM. The pink sticky notes represented ideas for how we could optimize
    the metrics or even make the process obsolete altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.44: An MBPM created for a Finnish telecommunications company'
  prefs: []
  type: TYPE_NORMAL
- en: When we returned to the MBPM three weeks later (after three one-week delivery
    iterations), we captured on blue sticky notes where there had been metrics-based
    improvements as a result of the continuous delivery infrastructure that had been
    introduced.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.45: Updated MBPM created for a Finnish telecommunications company'
  prefs: []
  type: TYPE_NORMAL
- en: This visualized and quantified the benefits of introducing containers, continuous
    integration, continuous delivery, infrastructure as code, and automation across
    the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how PetBattle ran the MBPM exercise to capture some baseline metrics.
  prefs: []
  type: TYPE_NORMAL
- en: PetBattle – MBPM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The current deployment of the PetBattle application is torturous, taking many
    hours to manually copy and deploy artifacts to a Raspberry Pi cluster that also
    happens to be a media server collection that is installed under the table belonging
    to one of the developers.
  prefs: []
  type: TYPE_NORMAL
- en: This seemed concerning to the new engineering team and they suggested visualizing
    everything that happens in the existing software delivery process. This would
    mean a shared understanding of how things worked in the hobbyist app and allow
    them to ideate how they can optimize and improve as PetBattle starts to scale.
  prefs: []
  type: TYPE_NORMAL
- en: The team, led by Tim, created an MBPM on the wall. There was a good bit of discussion
    about who was involved in releasing PetBattle, the actors, and when certain events
    occurred. The team settled on the following flow as representative of what happened
    during a release cycle.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.46: Starting phase of the PetBattle MBPM'
  prefs: []
  type: TYPE_NORMAL
- en: One of the PetBattle developers (Mike) would begin the release cycle by checking
    out all of the code. The next step was to try and figure out whether all of the
    feature branches that needed merging had been merged correctly. There was some
    delay in finding all the right code branches. Packaging the code failed 25% of
    the time because updating the configuration values was always manual and error-prone.
    The deployment to the Raspberry Pi cluster could begin, which usually took 1 hour
    because it was a CPU-intensive task. There was only one cluster, so this took
    down the PetBattle service while deployment happened.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, one of the other PetBattle engineers who understood the Raspberry
    Pi hardware the best (Noel) took time to patch and update the cluster operating
    system and tools. Often while doing this work, hardware issues were discovered
    that required new parts to be ordered. It could take up to three days to wait
    for the parts to arrive and often made the whole cluster unavailable, leading
    to a long wait time for testing a release.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the best tester among the team (Donal) would run through the manual test
    plan. Because the release was already deployed, users would unknowingly use the
    new version, often with a lot of failures. Donal's' testing often failed about
    half the time usually because the test plan needed updating or there were just
    a lot of bugs! Donal diligently entered the bugs he found into a spreadsheet to
    share with the other developers. Often, he got the details mixed up, meaning that
    20% of the reported defects had the wrong information recorded.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_47.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.47: Ending phase of the PetBattle MBPM'
  prefs: []
  type: TYPE_NORMAL
- en: The developers would take a couple of days to fix all of the defects reported
    in Donal's spreadsheet. The code was again merged, packaged, and deployed, often
    with similar failure rates to the first round of deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the end users could use the polished code. Often, end users were testing
    features at the same time as Donal. They would report defects and outages to the
    PetBattle email list.
  prefs: []
  type: TYPE_NORMAL
- en: 'From this practice, the team identified several initiatives that they agreed
    should be put in place:'
  prefs: []
  type: TYPE_NORMAL
- en: Use of containers in cloud infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation of infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous delivery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MBPM is an excellent practice for providing baseline metrics, identifying bottlenecks
    in processes, and driving the case for improvement. It does require a psychologically
    safe environment as the metrics may not be particularly pleasing. Team members
    should not be afraid to radiate this information and should also feel safe in
    sharing information honestly.
  prefs: []
  type: TYPE_NORMAL
- en: We will return to MBPM in *Section 5 – Deliver It* when we measure and learn
    about the improvements we've made in the Delivery loop.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we continued our journey on the Discovery loop with a focus
    on how we are going to deliver solutions – or, at least, how we are going to start.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at DDD and, in particular, the event storming practice, which helped
    visualize the business process flow. Our event-driven architectures started to
    emerge from the Event Storm. We started to further drive user research by making
    bets to form our backlog for feature development.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at a couple of practices that help form non-functional work we
    should consider – the non-functional map and the MBPM. The latter allows us to
    take key measurements associated with legacy software delivery processes and identify
    some of the continuous delivery practices we could employ to help improve and
    optimize them.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter and the previous chapter have enabled lots of ideas and candidates
    for development/configuration work. They are all visualized on the artifacts produced
    by the practices.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16297_09_48.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.48: Discovery phase of the Mobius loop'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, *Chapter 10, Setting Outcomes*, we're going to explore
    how we distill all this information into setting measurable outcomes. We'll then
    look at how we organize and prioritize all these ideas in a way where we can start
    to iteratively deliver value and do so regularly.
  prefs: []
  type: TYPE_NORMAL
