<html><head></head><body>
		<div>
			<h2 class="introHdg"><a id="_idTextAnchor054"/>Introducing Júlia Biró</h2>
			<p class="intro"><a id="_idTextAnchor055"/>Júlia is an experienced infrastructure and tooling engineer with interests in scalable systems, automation, and DevOps. Her experience at companies including Prezi, Ericsson, and currently Contentful give her a wealth of knowledge of how DevOps is integrated into modern IT practices. You can follow her on Twitter at<code class="inline"> @nellgwyn21</code>.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: I know you've worked in DevOps for most of your career, Julia, so I was wondering if we could begin with an overview of your experiences with DevOps and how you got involved in it?</p>
			<h2 class="introHdg">The lightbulb moment</h2>
			<p class="normal"><strong class="bold">Júlia Biró</strong>: I was born and raised in Hungary and trained as a mathematician. I wanted to see if I could take my favorite subject from school and turn it into a career. That turned out to be not such a smart idea. I was not cut out to do math as a career, and I found myself being more interested in the more practical problems. Because of that, in the end, someone suggested that I might want to learn programming, and this is how I gravitated towards the IT sector.</p>
			<p class="normal indent end">Once I was committed, I started training as a software engineer, and eventually, I was lucky enough to join a wonderful company called Prezi, where I was a very junior engineer placed on the infrastructure/DevOps team. It was as if a light bulb had switched on within me. I suddenly found myself knowing that this kind of engineering was what I wanted to do, and from that moment three and a half years ago, I would say I became a DevOps engineer.</p>
			<h2 class="introHdg">The dictionary definition of DevOps</h2>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Now imagine that we're looking up the word DevOps in the dictionary. What definition would we find?</p>
			<p class="normal end"><strong class="bold">Júlia Biró</strong>: In my dictionary, you would find that DevOps is an idea of the functions and responsibilities of teams running services in a company, and the corresponding set of tools to make that happen. There is this fancy name for it, the DevOps toolchain, but it's just a buzzword. It's really whatever anyone wants to understand it as.</p>
			<div>
				<div class="qtFrm" id="_idContainer130">
					<p class="qt">"DevOps is an idea of the functions and responsibilities of teams running services in a company, and the corresponding set of tools to make that happen."</p>
					<p class="qt">—Júlia Biró</p>
				</div>
			</div>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Could you expand on what you mean about it being a buzzword?</p>
			<p class="normal end"><strong class="bold">Júlia Biró</strong>: It's the idea that DevOps is a silver bullet that will make you successful, and that if you adopt DevOps, then everyone will be so much happier. But to really adapt to what DevOps is would be akin to changing three of your internal organs or becoming an animal. It's a really deep structural change that is hard to make unless you are starting very small and have this idea of going towards that ideal from the very beginning. You also must have the flexibility to do it from the start. So, unless you have all of that, then it's very hard to achieve, although there are examples of that happening.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: From what I understand, you worked at Ericsson, which is fairly big, before you worked in Prezi, which is comparatively relatively small. Did you see a difference?</p>
			<p class="normal"><strong class="bold">Júlia Biró</strong>: Very much, though I don't consider Ericsson, at least the parts where I worked, to be DevOps in any sense of the word, partly because the product that I was working on was very different. I don't see how DevOps works with products that have 15-year life cycles and two-year release cycles, which is the case with software that runs on the kind of infrastructure Ericsson produces. I'm not saying it's impossible. It's just I haven't seen it.</p>
			<p class="normal indent end">What I have seen up close though is that leaders in DevOps practices seem to have adopted the DevOps mentality from the point when their company was very small, and as a result, they grew with determination. But it isn't that they decided to change a big thing into DevOps.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Your profile says that you enable teams to take full ownership of their product. What do you mean by that?</p>
			<div>
				<div class="qtFrm" id="_idContainer131">
					<p class="qt">"There's this concept in DevOps that the team should own their service, from writing and testing the code to running it, and to the point where they should actually react if something is not functioning well."</p>
					<p class="qt">—Júlia Biró</p>
				</div>
			</div>
			<p class="normal"><strong class="bold">Júlia Biró</strong>: There's this concept in DevOps that the team should own their service, from writing and testing the code to running it, and to the point where they should actually react if something is not functioning well. This is an idea of DevOps that I think is benefiting companies that are doing that.</p>
			<p class="normal indent end">The first prerequisite for that is that a service needs to be ownable, meaning in size and in complexity. It should be small enough for a reasonable team to own it, which is true for microservices. Then the idea is that one team should do everything, not that someone writes some code, and then separately someone else tests it, another person deploys and runs it, while a third team wakes up in the middle of the night when it breaks. I believe most companies will benefit if they move towards the full ownership model because then teams can be more active and creative in developing new things, and at the end of the day, they will have better quality products because there is less friction between the teams and a bunch of tools that can help them make that happen.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: I assume that you're not talking about a 100-person team.</p>
			<p class="normal end"><strong class="bold">Júlia Biró</strong>: To me, a team is a number of people who can reasonably cooperate in an organic way without someone telling them what to do. From my experience, I don't see how 100 people can do this together. Again, I'm not saying it is impossible, but I have no experience with teams this size.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: So, in that case, you have relatively small teams, but with a greatly increased amount of expertise they need to cover. Because that one small team needs to be capable of testing and deploying, along with all kinds of other things. How do those teams get that knowledge? When I speak with some teams, all I get from them is that "My people know how to write Java getters and setters."</p>
			<p class="normal"><strong class="bold">Júlia Biró</strong>: Maybe you just give the team a piece of paper and tell them to build a Turing complete machine on that and go from there. Just joking! There's this idea of a full stack engineer, who can write both frontend code and backend code in a service client architecture. But the key here is to provide structured and well-documented tooling that people can actually use. It's the same way that you learn to use your washing machine and your coffee maker, or in our case, how you learn to use your CI, and your deployment tools. You need to make them easy, well documented, and well maintained.</p>
			<p class="normal indent">What the DevOps or infrastructure team does is take away the complexity and provide DevOps as a service to the company, and to the other teams who are still doing the owning. The teams are still in ownership of what gets deployed when it gets deployed, and where it will be deployed, but they don't need a lot of access or knowledge to do that.</p>
			<p class="normal indent end">There are areas where it's easier to do this because the CI systems are very clickable and the UI is very good. Admittedly, creating tools with good user interfaces for other tasks take more effort. You can create a deployment system where you click a button and it's deployed, then you click another button and it's revoked. On the other hand, there are tasks where UI is not enough, and your team will need to acquire new knowledge. For example, in configuration management, if you want your teams to handle the environment that their service is running, they'll need to learn some kind of configuration management tool, which is usually, "Oh my god, I need to understand what an OS is*," which will definitely require a bit more knowledge than just writing JavaScript, unless you go serverless with Lambda (*Since the recording of this interview, the pressure for teams to understand and manage running environments have seriously decreased, owing to the spreading of containerized platforms and serverless.).</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: The thing is, when you go serverless with something like Lambda, there is no turning back.</p>
			<p class="normal end"><strong class="bold">Júlia Biró</strong>: But soon, serverless and Lambda will have their own complex management tooling. There is always this emerging layer of hiding complexity and the need to control that by building very, very complex things from that and then that itself becomes complex.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Now that you're a site reliability engineer, do you find that there's a difference between a site reliability engineer and a DevOps engineer?</p>
			<h2 class="introHdg">Site reliability engineering versus DevOps</h2>
			<p class="normal"><strong class="bold">Júlia Biró</strong>: In my understanding, site reliability engineering is a subset of DevOps engineering, a very specific subset with very different goals. A DevOps engineer's job is to make the other teams effective and to help this full ownership principle, while a site reliability engineer is a very simple metric that defines the success of my work, which is the uptime of the site.</p>
			<div>
				<div class="qtFrm" id="_idContainer132">
					<p class="qt">"A DevOps engineer's job is to make the other teams effective and to help this full ownership principle."</p>
					<p class="qt">—Júlia Biró</p>
				</div>
			</div>
			<p class="normal indent end">In my job, I provide the tools for the other teams so that they can operate their systems in a way that achieves high availability. My toolkit provides them with good tooling and good guidelines for testing, monitoring, alerting, easy deployment, and easy reversion. At the end of the day, I'm making sure that they themselves can run their services in a reliable way by owning that knowledge—from how to make good tests all the way to knowing how to handle incidents in an effective way.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: On the one hand, it would be managing tools, but on the other hand, it would be teaching.</p>
			<p class="normal"><strong class="bold">Júlia Biró</strong>: That's exactly it! A DevOps engineer's job is to provide not only tools but also the best practices for teams. For example, it's within the DevOps realm to provide a good local development environment or a good testing environment for the organization.</p>
			<p class="normal indent">As a site reliability engineer, I'm not that interested in the local development environments; that is not my realm. Where I am now, I haven't even seen our local development environment, and I've been there for five months now. But it is very much within my focus what kind of monitoring they should be doing. Monitoring should automatically be installed for a service. In fact, I have a constant barrage of questions that I should be answering, like how do I empower the other teams to create their own monitoring? How can they set up alerts very easily? How can they create good dashboards? What makes dashboards good? How is it going to be always available and providing the right information?</p>
			<p class="normal indent end">You can only expect teams to run their service responsibly if they have tools for that, while also having all the know-how and the concepts around it. It's very much my job to provide that. To give you an example, I am pushing right now for my company to adopt a new, more effective process for incident handling, because if we handle incidents better, then it means those incidents are going to be shorter, which is going to raise our availability and generally improve the company's uptime.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Correct me if I'm wrong, but if the development teams have the ultimate responsibility for what they're doing, do they have a say or a choice in the sense of, for example, making the decision of whether or not to use Kubernetes? I mean it doesn't matter really if the team says no, it's my responsibility, I'm going to use something else. Is that their choice?</p>
			<p class="normal"><strong class="bold">Júlia Biró</strong>: There are multiple points of view here. One is that the homogeneity of the stack and in the tools is usually beneficial in a company because it enables cross-pollination, mobility between teams, building and spreading of knowhow and expertise, and code writing. So, all of these are pointing towards it being better if we are all speaking the same language.</p>
			<p class="normal indent">But on the other hand, with the heterogeneity of tasks we have, you might find that there is a better tool for the job. In general, the sense of freedom (and autonomy) is not to be underestimated. The approaches that I saw working well have one or two standard stacks that are supported. If you choose a different tool, then it's on you to get to the same level of quality, but if your team has the time for it, then why not? Right now, at Prezi, there are two standard stacks. There is tooling, monitoring, testing, whatever around it, and if you choose to do another stack for a user-facing service, then you need to build, for example, inter-service communication, client libraries, and so on.</p>
			<p class="normal indent end">The other thing that is important is to have a production-readiness checklist, with very specific acceptance criteria. You can help people by giving them an easy, simple choice: diverging from the standard has an expense. You have the teams pay for it and not the whole company, and the rest is just quality and process control in the classic sense of the word. Do whatever you want, just make sure you meet the criteria, and your tools are compatible, and then it's okay.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: So what would you say if I said that it's as if you could choose your responsibility, but it's in somebody else's interest to actually make it tempting and interesting for you to use, to the point where you don't really want to move away from it much?</p>
			<p class="normal"><strong class="bold">Júlia Biró</strong>: It doesn't mean that you are not going to move away, because if it's very important for your user experience that you are actually going to provide tooling around the third stack, then other people will start to use it. It's just that the main goal you want to achieve is that people can very easily create a new service and own it, and so you want to spare them the work that they don't need to do.</p>
			<p class="normal indent end">This is what all the standard stacks and tooling are there for, but also the know-how for the same tool. You don't want people to solve the same problem of what is the best way to test or monitor a service 60 times independently of each other. What you want to do is give them good solutions and if they don't work, then they can look for their own solutions or they can raise the problem with you. But your end goal is to reduce friction and reuse knowledge wherever you can.</p>
			<p class="normal end"><strong class="bold"><a id="_idTextAnchor056"/>Viktor Farcic</strong>: I'm curious to know, where are the women in DevOps? I don't see them much in the field.</p>
			<h2 class="introHdg">Women in DevOps… or the lack thereof</h2>
			<p class="normal"><strong class="bold">Júlia Biró</strong>: Well, you're talking to one! That being said, historically speaking since the mid-1980s, the ratio of women in STEM and tech fields has dropped. There's this great article (<span class="URL--PACKT-">https://www.npr.org/sections/money/2014/10/21/357629765/when-women-stopped-coding</span>) by the National Public Radio about why that's the case, and I would really recommend it to any of your readers.</p>
			<p class="normal indent">But nowadays, we find that there is a rising tendency, partly owing to the attention of diversity gaps and partly owing to the will of the industry, for the other half of the population to try to become engineers too. They realized that the same ratio of women is going to be good at programming. But here's the thing: currently, the easiest way to get into tech and code learning is via the frontend. From my own experience, when I first tried to program it was just HTML and CSS, which is not even programming.</p>
			<div>
				<div class="qtFrm" id="_idContainer133">
					<p class="qt">"The veterans in DevOps used to be real system administrators crawling between servers and configuring routers, which is not what they do anymore. But new people are coming from other areas of software engineering and IT."</p>
					<p class="qt">—Júlia Biró</p>
				</div>
			</div>
			<p class="normal indent">Most of the incentives that are inviting women into tech are starting in the frontend, where they'll be introduced to frontend or dynamic websites, and languages and frameworks like HTML+CSS, JavaScript, Python+Django, and Ruby on Rails. Why those languages? Probably because they're the easiest to try at home since you can become a very good frontend developer at your kitchen table. But infrastructure orchestration is not something you can do without some resources, and some problems only appear over a certain scale. It's a field that just needs some time for people to see into.</p>
			<p class="normal indent end">The veterans in DevOps used to be real system administrators crawling between servers and configuring routers, which is not what they do anymore. But new people are coming from other areas of software engineering and IT, and simply put, most of the women who are present in the field are predominantly at the beginning of their careers, so they are more on the frontend side, but they are seeping in slowly and steadily. Actually, it's not just me saying that. There's this great developer survey from Stack Overflow (<span class="URL--PACKT-">https://insights.stackoverflow.com/survey/2017#developer-profile-developer-role-and-gender</span>) which shows this.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: The reason I asked is that I know you're doing a lot of out-of-office activities with the likes of Rails Girls and Django Girls.</p>
			<p class="normal"><strong class="bold">Júlia Biró</strong>: The various events I'm volunteering for are all aimed at inviting more women into tech. I'm working with organizations that are very emphatically extending this invitation, it's not about teaching skills to girls and girls only; it's more about letting the girls or women know that they should try tech because it's a fun thing to do.</p>
			<p class="normal indent">I do this in all kinds of ways, such as participating in Rails Girls and Django Girls, which are open source workshops for women. These are one-day workshop events for building a dynamic web app from scratch attended by people who usually have zero previous knowledge of programming. The fun comes into it by the fact that at the end of the day they've created something that that they can actually show their families because it's deployed on the internet on real servers. The goal of these workshops is to give this feeling of how it works when you create something with technology. After attending these workshops, some women I know have actually changed their careers, and learned Python or Rails, and eventually became professional developers who now have totally legit careers in tech.</p>
			<p class="normal indent end">Another area where I'm working is taking the same concepts but aiming them at kids. It's said that by age 13, a girl realizes that math and technology aren't girly things. In fact, this article (<span class="URL--PACKT-">https://www.theguardian.com/society/2017/sep/20/children-are-straitjacketed-into-gender-roles-in-early-adolescence-says-study</span>) is a very important read about how we're straitjacketing gender roles in the early teenage years. What these programs are trying to do is get to these girls before that. We're trying to give them a very good experience with technology by creating stuff, where they learn that, <em class="italics">Wow, this can be for me</em>. If they happen to enjoy it, great, and if they don't, then no big deal; all they did was spend a day in a workshop with 15 other people and visited a cool office.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Have you ever tried anything that aimed to get girls involved with tech from a high school age so that they could carry it through to a college degree?</p>
			<p class="normal"><strong class="bold">Júlia Biró</strong>: Yes! There was a version of the kid's workshop where we did a 10-week course in Processing (<span class="URL--PACKT-">https://processing.org/</span>) for high school girls. I'm very proud that some of my former pupils from that course are already training as engineers.</p>
			<p class="normal indent">But it's important to note that it's not just women who are not getting this invitation to join the tech world. I have also taught at art universities because I think that programming can be a creative tool in art, and I wanted to give this tool to artists. During this period, we were teaching introductory programming courses to artists, and some of them really liked it, and some of them even tried to use it in their work.</p>
			<p class="normal indent end">The organization that I'm working with in Hungary is Skool (<span class="URL--PACKT-">skool.org.hu</span>)—a project of the Technology Education Foundation—which works with young girls. They have a program where they are working with kids in children's homes, which is amazing because they're usually a group of young people who don't get an invitation into tech, but now they are getting 10-week courses in the children's home.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: That's really brilliant.</p>
			<div>
				<div class="qtFrm" id="_idContainer134">
					<p class="qt">"Diversity does not just have to be about getting more women in the field. It's also about having more people from diverse backgrounds, like reaching out to underprivileged children."</p>
					<p class="qt">—Júlia Biró</p>
				</div>
			</div>
			<p class="normal end"><strong class="bold">Júlia Biró</strong>: It really is, because diversity does not just have to be about getting more women in the field. It's also about having more people from diverse backgrounds, like reaching out to underprivileged children. Tech can be a social mobility fast elevator. Within a very small amount of time you can grow your earning potential a lot. All you need is a laptop and a connection to the internet, and you can become a wonderful engineer if you have the talent for it. But some people don't even have access to those basic tools. Trying to give access to those entry-level tools is part of the job. But it is also important to recognize that being underprivileged has serious negative impact on the skills necessary for learning, so it is not just a laptop that is missing.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Moving on, what do you think will happen next in tech? If you were to predict the future, what are the bottlenecks of today that need to be solved, and what are the major obstacles you see us facing today?</p>
			<h2 class="introHdg">The future of tech and the challenges we face</h2>
			<p class="normal"><strong class="bold">Júlia Biró</strong>: This might sound naive, but complexity is one of the biggest obstacles that we're going to face in the near future. Even when we are using standard tooling, our infrastructure is made up of so many different pieces, and we want to do it right. We want to document it all anyway, so we do it in Terraform. It's just complexity itself.</p>
			<p class="normal indent">My gut feeling is that Terraform is a ticking bomb because it's hard to make and test modifications on it, and it's just as equally hard to find your way around it. Basically, Terraform is a new programming language that has multiple bugs.</p>
			<p class="normal indent">You can also experience complexity when you want to make modifications to a service in a microservices environment. At Contentful, although we have a local development environment, I needed to start six surrounding services to run locally so the servers would start and I could test it. This complexity is related to what the human mind can hold, which is why I think this is now a bottleneck.</p>
			<p class="normal indent end">Scaling used to be a bottleneck 15 years ago, but not anymore. If you do it well then with reasonable limits and with infrastructure scaling, it's actually a very, very easy thing now; it's just the pace in which technologies change that is creating a bottleneck now. Once you become a certain size, changing technology is very, very difficult. But this is not a new problem. People will be stuck on Kubernetes the same way they were stuck on Java.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: You mentioned the pace of—I don't know whether to call it new stuff being developed or innovation—but the pace has increased. How do you follow that?</p>
			<p class="normal end"><strong class="bold">Júlia Biró</strong>: I actually feel bad about not following it.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: But if the pace is increasing, are we going to become superhumans?</p>
			<p class="normal"><strong class="bold">Júlia Biró</strong>: I don't know, and that's why I'm saying it's a bottleneck. As new problems and technologies arise, technologies themselves become more quickly outdated. But at the same time the next and better tools are becoming available at a faster pace. Though this actually has a huge benefit, because no one has to have more than two years' experience with a given tool, and so it doesn't really matter whether you're in the field for two years or 20 years. It means that at the end of the day it's going to be increasingly easier to access this field.</p>
			<p class="normal indent end">For example, I don't need to have been a hands-on system administrator for 10 years to become an effective infrastructure or site reliability engineer. Unlike me, many of my colleagues, who have 10 more years' experience than me, half of that as systems administrators running the internet in the golden days. It'll probably be a psychological limit to how fast companies can adopt new technologies, and it will not be faster than that. But regarding your question about the learning, It's like everything else. If people put their lives to it and spend eight hours working and then another eight reading about the next thing, then they're going to be super good at it.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Does that mean if a company is able to follow the trends, then people working there need to have free time for studying and learning?</p>
			<p class="normal end"><strong class="bold">Júlia Biró</strong>: Of course! I always say that my job is to understand the new thing, and then automate it away. All the problems that I have ever solved should be automated or at least documented, so I don't need to figure the answer out again. Preferably, if I have the time, automated, so no one else has to think about them again. And of course there is time for things like conferences because the rest is just programming, which, of course, is not just programming but also a skill. It's always going to be another layer of abstraction and another set of complexity that we will need to handle and get the tools for.</p>
			<h2 class="introHdg">The inevitability of increasing complexity</h2>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Does that mean increasing complexity is unavoidable?</p>
			<p class="normal end"><strong class="bold">Júlia Biró</strong>: Exactly, just evolution.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: I like that one.</p>
			<p class="normal"><strong class="bold">Júlia Biró</strong>: Here's the thing. Once you can do something, you put two of those together, and then by the time you have put five together, you feel like, "Oh, this is terrible," and you automate it. Then by the 22nd time you realize that you want that particular instance to be slightly different and that you want to put an <code class="inline">if</code> there. You basically want to control it with variables in a full programming language and then, bam! You have created another layer of complexity.</p>
			<p class="normal indent end">But once you have a programming language with it, there's nothing that's going to stop you from having 5,000, instead of 50. It's easy to say, "Here I have another layer." After that, all you need to do is teach everyone about that and put that into the code, and from there, code review and from there move onto testing and developing an entire environment for that.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: You mentioned the complexity of legacy applications. Is there a moment when it doesn't make sense to maintain something anymore? For instance, say you've got a legacy system written in COBOL or Java. If you want to reduce complexity at some point in time, you need to start over. But at the same time, nobody wants to throw away five years' worth of applications.</p>
			<p class="normal end"><strong class="bold">Júlia Biró</strong>: You could always refactor it into smaller pieces if you can factor it away, and that seems to be the DevOps idea right now. Not to throw away the monolith and replace it, but to actually break it down into smaller pieces. And, of course, the smaller pieces give complexity, but inside of them, they are more containable and accessible.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: So, we are replacing one complexity with another.</p>
			<p class="normal end"><strong class="bold">Júlia Biró</strong>: Yes, basically that's what is happening. But the advantage of this is that replacing it results in a more dividable and parallelizable complexity. If you have a monolith and you have 100 people working on it, then all 100 of them need to have the complexity of that monolith in their heads. If you can break it down to 10 pieces, then 90 people will have to know the complexity of one-tenth, and maybe some dependencies, and 10 people will need to have the complexity of the DevOps toolchain or running microservices.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: As we begin to wrap up this conversation, is there anything you would like to talk about that I've not asked you about yet?</p>
			<p class="normal"><strong class="bold">Júlia Biró</strong>: In my career, I came from one company where I really experienced DevOps, infrastructure, and site reliability, along with all these new concepts. I then joined Contentful in May 2018 just after it experienced a big burst of growth, and it took some time (about a year) for it to adjust to its new size and for the necessary tools and processes to emerge. In the year since, it has really caught up.</p>
			<h2 class="introHdg">Thinking pragmatically</h2>
			<p class="normal indent">What interests me right now is that these differences make me think really pragmatically about what is done, why it is done, and what it is that I should import from Prezi and initiate at Contentful. For example, what are the DevOps ideas that are obtainable and worth obtaining for my new company? I see that because, for example, my Contentful stack has younger and fresher technologies than the stack at Prezi. Yet, on the other hand, some of the toolings are much more mature, and the complexity is crushing.</p>
			<p class="normal indent end">What makes me tick in my daily work is my belief that Contentful will grow, and I chose to follow it because I want to be in there while it's growing, and I want to facilitate that growth.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Would you say that it's easier to promote things when in one situation over another? Is it easier with a well-established stack or a young company with less?</p>
			<p class="normal"><strong class="bold">Júlia Biró</strong>: It's quite different. For example, one of the signs of maturity is that by the time I left Prezi, there was a very well-defined process of how to promote ideas. A year ago, when I first started trying to promote ideas at Contentful, I didn't even know which was the right platform to start on. A year later, there is definitely a clear process. On the other hand, because there are only half as many engineers and layers at Contentful, I really only need to convince two or three people over lunch, and then something may get started.</p>
			<div>
				<div class="qtFrm" id="_idContainer135">
					<p class="qt">"One of the signs of maturity is that by the time I left Prezi, there was a very well-defined process of how to promote ideas."</p>
					<p class="qt">—Júlia Biró</p>
				</div>
			</div>
			<p class="normal indent">I don't have a preference for this or that. With Prezi, I needed to learn a lot of tools. For example, as a member of the team who was responsible for the monitoring pipeline, which itself consisted of six different microservices. And that was just monitoring, and that was hard. Now at Contentful, I often feel that we don't have a real structured concept of working out where we are going.</p>
			<p class="normal indent end">The worst thing is that I'm constantly thinking we have no idea how we are doing this really. I say it not like we don't know what technology to use, but that we don't know how we want to use that technology. All these things are mushy and undefined, and that gives you a lot of uncertainty, which is hard for me to deal with because I don't deal with uncertainty very well. So, for me, this is the challenge. But on the other hand, if I set my mind to tidy up things, then it's very easy because all I need to do sometimes is just write down something and try to get the others to follow or agree on it. Just creating processes is almost as effective as creating tools, because it can already fix things.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Here's a question. Every company thinks that they are special and they're doing things in a special way. Yet, there are some commonly proven things that work better than others. Our industry is so heterogeneous that actually we still don't know what works better than others. Or is it the case that companies are simply uninformed and incapable, or is it something else altogether?</p>
			<p class="normal"><strong class="bold">Júlia Biró</strong>: No, I don't think we are so heterogeneous actually. As I was looking to change jobs, it was very easy for me to find a company that uses 60 percent of the same tools as my previous company; the only difference was that they were used in slightly different ways. The beauty of the microservices architecture is actually that the diversity is contained inside the microservice and then, as an engineer, standard problems mean that you can have standard solutions, and it's an advantage.</p>
			<p class="normal indent">There was an idea at Prezi, which I think makes sense, that you should focus your efforts on the specific problem domain in which your expertise and your service area lie. You should try to solve the other problems as easily and in as standard a way as possible. In Prezi, that meant that we have our very own special solutions for rendering visualizations and other things, but we don't want to reinvent the wheel when it comes to monitoring because we are a visual communications company and not a monitoring company.</p>
			<p class="normal indent end">At Contentful, we are making sure that your content is both easily editable while still being highly available, because this is our expertise and this is our service, there's a big emphasis on usability. We are not a monitoring company. We are not going to invest a lot of effort into monitoring. It's not that we are not going to do it, it's just that we are not going to write our own solution in it from scratch because our monitoring problems are standard and standard tooling should handle it.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: So, you should focus on your specialty and then try to get the rest in through a standard way. But what confuses me is that it's a bit contradictory because, on the one hand, we can agree we should have standards, so we don't waste our time, but on the other hand, if things are changing on a daily basis, you're never increasing speed, and thus standards cannot also be long-lasting.</p>
			<p class="normal end"><strong class="bold">Júlia Biró</strong>: Usually every problem domain has a smallish set of standard solutions that you can choose from, maybe three to five, that are very well documented and very well supported. But like you said, the bottleneck always moves. All new solutions are about improving some bottleneck, but they're not solving the same problem over and over again. They are solving the next problem.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: So, whenever we solve a problem, there is another one to solve, and so actually the ever-increasing speed of new processes and tools are a reflection of us raising the bar.</p>
			<p class="normal end"><strong class="bold">Júlia Biró</strong>: For example, there are currently five big tools in container scheduling and orchestration. I don't think there's going to be 50 industry standards in that thing, and the new technology is not going to be about container orchestration anymore. It's going to be about something else, something on top of it.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Like a cake?</p>
			<p class="normal end"><strong class="bold">Júlia Biró</strong>: Always like a cake. For example, once virtual machines become an easily accessible resource, you can grow your infrastructure to the point where you need to have personal negotiations with AWS about how much of the residual nodes you are using. People will probably have 6 billion Kubernetes clusters, but then after that, it will just become an easily scalable resource again, and then the complexity will go somewhere else.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: I agree.</p>
			<p class="normal end"><strong class="bold">Júlia Biró</strong>: I mean, people are still writing UNIX tools, but that's because we are using UNIX tools that are 30 years old, on a daily basis. Why? Because they are in every bit of software that we write, and we are not adopting new standards on that one because they are the same standard solutions. For servers, you use NGINX, HAProxy, or Apache server, and they all do the same stuff and then you know, it's OK, it works, you don't need to have a sixteenth one.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: That's brilliant. I am wondering, though, what makes you click?</p>
			<h2 class="introHdg">The engineering constant</h2>
			<p class="normal"><strong class="bold">Júlia Biró</strong>: I've had the privilege of working with some very experienced engineers, like yourself for example. I'm also very new at this, but we've already said that technologies change a lot and I am very interested in seeing what is the "engineering constant".</p>
			<p class="normal indent end">What are the things that will probably come with experience? They're not really knowledge of specific technologies, but skills, thinking patterns, and best practices that can be used overall and don't get outdated. Whether some of those are something that can be picked up to the benefit of my work without having to spend five years learning two or three single technologies in depth. The question from all this is, "What are the things that I can learn without having to spend 10 years in tech, and which will not get outdated?"</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: You can learn Kubernetes in a year.</p>
			<p class="normal end"><strong class="bold">Júlia Biró</strong>: But Kubernetes will get outdated in around three to five years' time.</p>
			<h2 class="introHdg">Are there constants in the tech industry?</h2>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: I'm kidding. But is there such a thing that will never become outdated? If you move outside of tech, is anything cultural that is continuously changing our perception of everything? Are there such things as constants in the tech industry?</p>
			<p class="normal end"><strong class="bold">Júlia Biró</strong>: There are basic ideas, such as the depiction of female beauty, which seems to be a very constant thing in the past around 3,000 to 5,000 years in art and across the entire world. Methods for manipulating masses (for making a bigger part of your population stand on your side) are also mostly unchanging ever since the history of written politics.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: OK, fair enough, you can have that.</p>
			<p class="normal end"><strong class="bold">Júlia Biró</strong>: I do feel that as I talk to engineers around me who might have experiences from different fields, there are some approaches that they apply uniformly, regardless of the field or of the actual problem. Approaches that don't change. Whether you're doing programming in 1983, 2003, or in 2013, sometimes the questions are the same, but the answers are different, and then the solutions are different. I'm interested in that part, the part that separates engineering from programming.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: But isn't that partly a sign of immaturity in our industry?</p>
			<p class="normal end"><strong class="bold">Júlia Biró</strong>: It's partly a sign of maturity, and I see that all around me. It's also something I learn mostly from people who have more experience in the field than me. But I also think that it is something that can be made conscious and that it's something that you can steal a bit, so you try to use it even when you don't have that experience.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: It was not long ago that I spoke with an acquaintance of mine, who is an architect, and I was telling him how only yesterday we were using Java, and today we're using Go, and god only knows what's tomorrow. He explained to me, "Yeah, because what I do as an architect has existed for a couple of thousand years and we've had time to figure it out, and you haven't."</p>
			<p class="normal end"><strong class="bold">Júlia Biró</strong>: I mean, the laws of aesthetics are not changing, but the way in which buildings are built has changed very much in the last two centuries because of the change of materials.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: But you just said, architecture has existed for two centuries, and we've only been around for 50 years.</p>
			<p class="normal"><strong class="bold">Júlia Biró</strong>: No, and here's the thing. An ex-colleague of mine who works in a remote-only company with all senior engineers told a story: "We're going to dinner. We meet once a year in person, and we go to this off-site/team-building event, and we try to architect problems. It's ridiculous the amount of advancement you can get by asking, 'what is the problem we are trying to solve?'"</p>
			<div>
				<div class="qtFrm" id="_idContainer136">
					<p class="qt">"That's like a super simple trick that senior engineers do. They're not letting themselves be dragged into the small details or down rabbit holes, but from time to time they take a step back and try to ask, 'Are we getting closer, and could there be a shorter way?'"</p>
					<p class="qt">—Júlia Biró</p>
				</div>
			</div>
			<p class="normal indent end">That's like a super simple trick that senior engineers do. They're not letting <a id="_idIndexMarker031"/>themselves be dragged into the small details or down rabbit holes, but from time to time they take a step back and try to ask, "Are we getting closer, and could there be a shorter way?" This all comes with maturity, but if you're sneaky like me, then you try to use it early. I'm interested in these things. Basically, is there a fast track to becoming a senior engineer? This would be my interest. Because I don't have that much time.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: That's a great point of view. Thank you for sparing some time to talk to me today.</p>
		</div>
	</body></html>