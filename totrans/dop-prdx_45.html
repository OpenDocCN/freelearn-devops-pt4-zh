<html><head></head><body>
		<div>
			<h2 class="introHdg"><a id="_idTextAnchor075"/>Introducing Bret Fisher</h2>
			<p class="intro"><a id="_idTextAnchor076"/>Bret Fisher is a freelance DevOps and Docker consultant, Udemy instructor, trainer, speaker, and open source volunteer. He also teaches courses on Docker and container technology. You can follow him on Twitter at <code class="inline">@BretFisher</code>.</p>
			<h2 class="introHdg">What is DevOps?</h2>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: I want to start by asking if you could give us the elevator pitch as to who you are, and how you're involved with the DevOps community.</p>
			<p class="normal end"><strong class="bold">Bret Fisher</strong>: Firstly, I would say that I'm a DevOps consultant who mainly focuses on Docker. That being said, I'm actually a Docker Captain, who both works and teaches the program. I guess you could say I live and breathe Docker 24/7.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Last night, I was talking to three self-proclaimed DevOps engineers who were all from different companies. You'd think they would all describe their jobs in the same way, but they didn't. In fact, each of them described their jobs using different terms. So, my question for you is, and it's something I've asked everyone in this book, what the heck is DevOps?</p>
			<p class="normal"><strong class="bold">Bret Fisher</strong>: The definition of DevOps today is not what people who do DevOps actually do, so it's funny that you've asked me this question. People have asked me to inject more DevOps into my Docker course because they're self-proclaimed beginners in DevOps. But they're actually not beginners of DevOps, they're beginners in IT.</p>
			<div>
				<div class="qtFrm" id="_idContainer173">
					<p class="qt">"The definition of DevOps today is not what people who do DevOps actually do."</p>
					<p class="qt">—Bret Fisher</p>
				</div>
			</div>
			<p class="normal indent end">If John or Jane, who are just starting out in IT, comes to me saying that they want to do DevOps, I find it difficult to do. Why? Because, to me, DevOps is something you can only do after you've been in operations or in development for a while, because you have to know both in some form before you really get the overarching idea of DevOps. You can't really be a part of DevOps if you're new to either area.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: So, really nobody knows what DevOps actually is?</p>
			<p class="normal"><strong class="bold">Bret Fisher</strong>: To me, DevOps is literally if you're a developer, you're working with operations, and you're sharing the same concerns around the concept of getting the software off of the developer's laptop, into production, and everything in between. Then, after the software is in production, the job of DevOps is making sure that the project remains up and that you can update it reliably, and that there's this continuous feedback loop between everyone involved in the process. The loop is how the software is getting from the developer all the way through to the servers and then getting updated in an ever-increasingly faster loop.</p>
			<p class="normal indent end">But let's, for a minute, imagine that I'm in a DevOps team with you. If, in the future, we're still shipping software at the same pace that we're shipping it now, I would say that we're not doing very well as a team. We should be optimizing and making the system more efficient, assuming of course that we wanted to go faster. If the company's not trying to go faster, then that's fine. I find it funny that DevOps is now becoming this entryway thing for people want to get into technology. Everybody's saying that technology is awesome and that DevOps is something we all should be doing, but I just don't see how that works. If I don't know how to be a developer, and I don't know how to be operations, then how could I possibly do both of them and DevOps?</p>
			<p class="normal"><strong class="bold">Viktor Farcic</strong>: That's the issue I keep coming across. I'm continuously meeting people who are just starting their IT journey. At that stage of their career, they know nothing about anything. They're starting from scratch.</p>
			<p class="normal indent end">It would be as if my first introduction to IT is me saying: "I'm going to become a DevOps engineer." It's as if I'm choosing whether I'm going to become a tester. I'm going to become a developer, and I really don't understand how that happened. You said earlier that you do Docker courses, but to me, when you've completed them, you're certified DevOps, and you have an ability to say: "I'm a certified DevOps beginner."</p>
			<p class="normal"><strong class="bold">Bret Fisher</strong>: If someone said that he or she was new in the industry and wanted to get into DevOps, then I could hire them with the idea of training them towards that specific goal. If I had to make them a DevOps engineer, their first job would obviously be to learn the developing language that the team is running and effectively become a very junior developer.</p>
			<p class="normal indent">I would stick the newbie on the build team, so they would have to be someone involved with using Jenkins and either building or testing the app and automating that part. For me, that's the only role where they don't have to develop the code but, instead, have to understand the code just a little bit. They don't really have to know the operations, but they're going to have to talk to the operators, and as a result, they're going to learn a little bit of the operators' pain.</p>
			<div>
				<div class="qtFrm" id="_idContainer174">
					<p class="qt">"If I had to make them a DevOps engineer, their first job would obviously be to learn the developing language that the team is running and effectively become a very junior developer."</p>
					<p class="qt">—Bret Fisher</p>
				</div>
			</div>
			<p class="normal indent">Fast-forward a year: I would now say that you've done all that for a while, let's actually have you be responsible for some servers, and from there, you get a little bit of operations sysadmin experience. Fast-forward another year, and now you can say: "OK, maybe you can start focusing on DevOps-related issues." People that are new to operations find it a tough thing because they don't understand software and servers, which raises the question of what exactly are they operating?</p>
			<p class="normal indent end">I'm sure there are some job descriptions out there that say they're looking for a junior DevOps engineer. I just have to ask, who would do that job well? Is it somebody who's a developer and likes to tinker with servers, or is it a server admin who knows a little bit about how to script and code? I really don't know, but what I do know is that I don't have a good answer to your question. What's funny is that there are all of these courses that say you can do DevOps now, but all they do is teach you a tool like Jenkins, which doesn't make you DevOps.</p>
			<h2 class="introHdg">Right here, right now</h2>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: I find that interesting because, when I've gone to conferences—say, over the last two years—all I'm seeing is every single vendor and every single product being labeled as DevOps. Yes, it has already existed for years, but today, every single product is called a DevOps product. Just look at Jenkins. I know that you go to a lot of conferences, so I was wondering what your thoughts are on this?</p>
			<p class="normal"><strong class="bold">Bret Fisher</strong>: DevOps is like the new cloud. Remember when we were all joking in 2013 about what is the cloud? All we knew was that it's just servers on the internet. That's all it is. But we had this new term, and everybody had to use it. All of these companies came out with all of these products, and they all had the word "cloud" in it somewhere.</p>
			<p class="normal indent end">So, now, what is the cloud? The cloud doesn't mean anything. It's just the internet. I feel like that's what the word DevOps is going toward, though I must put my hands up as I'm guilty of this because my course has DevOps in the title.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Even my previous books have DevOps in their title—the <em class="italics">DevOps Toolkit</em> series.</p>
			<p class="normal end"><strong class="bold">Bret Fisher</strong>: My title is <em class="italics">DevOps Dude</em>, simply because it works. I get more requests to interview for jobs on LinkedIn simply because DevOps is in my title.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: I can tell you if I named my books <em class="italics">Operations Toolkit</em>, instead of <em class="italics">DevOps Toolkit</em>, it would just sell seven copies, and six of those seven copies would be bought by my relatives. But let's shift focus onto containers. I don't ever recall seeing something becoming so popular so quickly, so I'm left wondering why is that?</p>
			<p class="normal"><strong class="bold">Bret Fisher</strong>: Whenever I do a Docker 101 talk, I talk about how we've been around in IT for a long time, and that, in the past, we never got paid for it, but actually we were still doing it. We were doing it just for fun, but now we get paid to do it for fun. I was in technology back when we took out the mainframe and put in PCs, which were actually just DOS operating systems. We also had to actually put mice on the PCs because they were going to get Windows, which is something we then had to install on the machines—machines that didn't have the internet. Then, eventually, we finally got the TCP/IP suite of communication protocols and were able to simply plug up all of the computers to the internet.</p>
			<p class="normal indent end">Then, after the internet, we had virtualization, and during those times, I was the guy in the big company with half a million employees that was walking around saying, "Virtualization is the future." Meanwhile, everyone else was saying, "You're stupid, you're crazy, the servers will run slow, we're never going to be able to build security." It's the same arguments we hear today for containers, and last year, for the cloud. Now, with the cloud, it's basically all about putting our data on the internet. You're taking your data out of the data center, putting it on the internet, and letting someone else take care of it. Even though that was 11 years ago when Amazon's AWS service launched, it's still happening today. Even though we were all like, "Oh, everybody's going to be there." The truth is, not everyone is there yet.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Out of interest, what would you say is today's version of the cloud?</p>
			<p class="normal"><strong class="bold">Bret Fisher</strong>: I would say containers. It was only three years ago when I changed my entire career to focus on containers. Why? Because I've been a part of enough of these transitions to know that this is the next one. If you look at these waves, every single one of them—from mainframe to PC, PC to the internet, PC to virtualization, virtualization to cloud, and now containers—seems to happen faster than the one before it. At least, that's my theory.</p>
			<p class="normal indent end">Virtualization took a decade, but it was taken on pretty quickly. But moving to the cloud for a lot of companies happened much quicker than virtualization. Today, we're seeing containers having a much faster adoption rate, at least when compared to virtualization. I think that's the nature of where we're at in the industry, and so whatever the next thing is going to be, it's going to happen faster than containers.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: And when I think about it, it's probably going to last a shorter amount of time as well.</p>
			<p class="normal end"><strong class="bold">Bret Fisher</strong>: It might just as well last that long. But here's the thing: it might be more volatile, where we'll eventually get containers that will be so good that we won't even need most virtualization. Maybe in the future, virtualization will become unnecessary.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: But then, if it's happening so fast, how can humanity keep up with that?</p>
			<p class="normal end"><strong class="bold">Bret Fisher</strong>: It doesn't.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Each time I read about the next release of something—say, Docker—I feel like I'm in a position where I haven't even finished with the last one, and yet there's already a new one to learn, and I end up having no idea what's going on.</p>
			<h2 class="introHdg">Skipping a generation – a good or bad idea?</h2>
			<p class="normal end"><strong class="bold">Bret Fisher</strong>: Exactly, so you'll have companies that skip a generation. For example, company X might now be doing virtualization. They didn't really do cloud, so they skipped it, but now they're going to do containers instead of just virtualization in the cloud.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: But can you do that? Is jumping a generation a good idea?</p>
			<p class="normal"><strong class="bold">Bret Fisher</strong>: Not without your pain increasing. The pain increases because you're part of a team, and organizational learning means that we've both got to know that you're never a silo of knowledge. The entire team has to learn together and so, even if you were to hire a container expert, in a good-sized organization, it's going to take them years to get the entire team up to speed on all of that tech.</p>
			<p class="normal indent">If the companies aren't doing cloud yet and you're going to take them to the cloud, but now they're also going to do containers too, that's going to suck. They're probably going to make more mistakes, but it's still going to get there, eventually. You're just going to incur more pain and more suffering. Laura Frank, the Director of Engineering at CloudBees, actually has a new term for this. She calls it the laggard tax.</p>
			<div>
				<div class="qtFrm" id="_idContainer175">
					<p class="qt">"We still have people using mainframes, and we still have people that are not fully virtualized. There are still companies out there running 10-year-old servers that were never virtualized."</p>
					<p class="qt">—Bret Fisher</p>
				</div>
			</div>
			<p class="normal indent end">If you've ever seen that bell chart diagram where you have your people up at the front when the technology first starts, then there's also the people at the very beginning of it and, after that, the majority of us, and finally, there are the laggards. Laura describes laggard tax as being if you're so slow to adopt the technology—let's say, as in our case, the cloud—it's actually going to cost you more in the long term because you might have to completely skip a generation of technology. But the thing is, none of these are absolutes. We still have people using mainframes, and we still have people that are not fully virtualized. There are still companies out there running 10-year-old servers that were never virtualized.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: I know people, and I'm not joking, who are still graduating in the COBOL language.</p>
			<p class="normal"><strong class="bold">Bret Fisher</strong>: Even looking forward a decade, there will still be people that are not yet doing containers, and instead only doing virtualization or something along those lines.</p>
			<p class="normal indent">There was a good session at GOTO Chicago a couple of weeks ago where the keynoter talked about how 30 years ago in technology, life was great because you could be someone who, if you were fully invested in the community, knew a little bit about most things. You could know a good amount about most languages and most technologies. But what stood out was how he said that now no one knows anything about anything. We all have just a fraction of the knowledge available about current technology. Even in a team, you probably don't even know a tenth of the languages out there. How can we possibly make educated decisions fully aware of everything that's available to us? The answer is just we don't.</p>
			<div>
				<div class="qtFrm" id="_idContainer176">
					<p class="qt">"No one knows anything about anything."</p>
					<p class="qt">—Bret Fisher</p>
				</div>
			</div>
			<p class="normal indent">As an industry, we're stumbling through the dark, only engaging with whatever works for us right here and now. There's no right or wrong until you've been hacked and then you're wrong. The number one way to fail in this industry is to just wait until your product has been hacked, and then suddenly everybody will blame you for everything at that point. But until you've been hacked, as long as it works, it doesn't really matter.</p>
			<p class="normal indent">I believe it was back at GOTO where I got on a rant about how you walk in the average company—and by "average", I don't mean the Google- or Netflix-type companies—and you start critiquing all of the different parts of their technology stack. There's going to be at least a half a dozen things at that company that would be front-page-worthy. Company A still stores their passwords in a spreadsheet, while company B doesn't even monitor their most critical DNS servers. Or company C has had the same root password for their servers for the past five years, while in that time period, 30 people have been fired from the company, and yet they've never changed the password. You're going to find these issues in every company. If it's all that mixed up, if it's all horrible, or if it's simply just luck that we're not all doomed to crash and fail, then I think, at the end of the day, all that really matters is getting stuff to work and doing the best you can at that moment. It's never going to be perfect, and it's never going to be great.</p>
			<h2 class="introHdg">Using containers</h2>
			<p class="normal indent end">Going back to your earlier question though, I think that the definition of DevOps itself inherently means compromise. The operations and developers at any company have to compromise to get the stuff to work together and to go faster. Maybe that's compromising on security or on testing. Maybe our testing lifecycle isn't four weeks' worth of user testing anymore; maybe it's just four days before we go to production? But in a lot of cases, we can't just speed things up without making some sort of eventual compromise that every party involved in would be okay with.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Let's talk more about you, Bret. From my understanding, most of the time, you're helping companies or people adapt to using containers. Do you think we should be shipping everything in containers? As someone who's so invested in the concept, do you ever sit back and say that, actually, no, this stays as it is—we're not going to use containers?</p>
			<p class="normal end"><strong class="bold">Bret Fisher</strong>: Obviously, we can say that, technically, everything can run in a container. The real question that needs to be asked is about how much pain and suffering you want to go through in order to make your "thing" run in a container.</p>
			<p class="normal indent">In my own experience, if I'm starting a project with a client, I'll look at whatever tool or technology they're going to run, and together, we'll try to imagine what the end goal is. If that's in a container, how will that make their product or service better? If their goal is a database and we only update that database's engine once every six months, they don't need to patch it every month. They're not moving it around in the environment, it's already on a server with redundant power supplies, redundant memory, redundant switching, and redundant NICs, which is a lot of data centers.</p>
			<div>
				<div class="qtFrm" id="_idContainer177">
					<p class="qt">"I will always prefer the thing that they're going to update every day/week versus the thing that's just going to sit there reliably and never change for months at a time."</p>
					<p class="qt">—Bret Fisher</p>
				</div>
			</div>
			<p class="normal indent">A lot of private data centers are still very hardware redundancy focused, unlike the cloud where it's the complete opposite. For me, I will always prefer the thing that they're going to update every day/week versus the thing that's just going to sit there reliably and never change for months at a time. Usually, that means your web APIs or your new worker jobs for your PHP workers on the backend of your system are constantly changing; those are always the things that I try to get them to do first. Then, by the time we get to the things that require really big and complicated databases, the companies are usually out of money, and so we won't ever do those things, and they'll stay where they are.</p>
			<p class="normal indent end">A lot of companies, especially if it's a new product or app, will containerize the database to begin with. But I'm always telling them, "Don't make this database the first thing you put in a container!" Anything with persistent data is always going to be harder no matter what you do, whether it's in or out of a container, so I would try to avoid that at first. But if it's brand new, and if I can give them a Docker file that they can put in a container—even if it's not in orchestration, it's just on a server in a container and that's the only thing on that server, and it never moves—then that's fine. I'll be happy. Because, at least, at that point, it's in a container and they're not writing shell scripts to do <code class="inline">apt-get</code> installs of MySQL.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Let's say somebody doesn't know anything about containers. Would you recommend still teaching them to start from the beginning, in a similar way to what we experienced with containers four years ago? Let's get them started with containers, then move onto schedulers, or should they just jump straight into schedulers? Where should the newbie go today?</p>
			<p class="normal"><strong class="bold">Bret Fisher</strong>: I would always want to teach them the localhost. I feel that maybe because it's universal, even if you're not a developer, and you're just a sysadmin, showing how your Mac/Windows machine can run an Ubuntu container or a CentOS container and then having all of those tools right there in front of you so that you don't have to figure out how to put curl on your Windows desktop. I feel like that is valuable for everybody regardless of your background.</p>
			<p class="normal indent end">Maybe I'm a traditionalist, and I don't want to teach you an orchestrator because I feel that sometimes, by teaching orchestration first, it would be like telling you the solution before you even know the problem. To me, it's like if you're a Windows admin in a data center. Traditionally, you would use something like System Center for Microsoft or some big enterprisey server management tool, but if you're new to server admin, showing you that tool at the start would be confusing. To the newbie, it would seem very complex, because the newbie doesn't even know how to run one server much less a thousand servers. If I'm teaching you that tool and you don't even know how to manage one or two servers, I feel like the tool that's going to help you to manage a thousand servers isn't going to seem very useful.</p>
			<div>
				<div class="qtFrm" id="_idContainer178">
					<p class="qt">"Maybe I'm a traditionalist, and I don't want to teach you an orchestrator because I feel that sometimes, by teaching orchestration first, it would be like telling you the solution before you even know the problem."</p>
					<p class="qt">—Bret Fisher</p>
				</div>
			</div>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: It's kind of a doubt that I have. I've been in a number of situations where I explain containers and then it turns out that I'm explaining it to somebody who is very new to IT in general. "What's the benefit of me explaining this to you?" I feel like asking them, "How can you see the benefit if you haven't experienced the pain first?"</p>
			<p class="normal"><strong class="bold">Bret Fisher</strong>: That's tough, but it's possible. If you go back to 2013, you'll remember that Solomon Hyke, who founded Docker, talked about why we all teach Docker. He talked about the matrix from hell with all of the little question marks in the boxes, and he also explained the matrix of hell and why we have all of these systems and patches for various things.</p>
			<p class="normal indent end">Let's say you want to install a Ruby app on my local machine and my development team has a mixture of both Windows, Mac, and Linux machines. But then, I also have servers that are Linux, and some of those servers are in the cloud running a different distribution of Linux, and I have a different package manager. Now I have all of these different environments. My goal is to install the same thing on all of them and to ensure it works exactly the same way when you hear someone describe that. Hopefully, this will make sure that you realize you have two options. You can think: "OK, that sounds very painful," or equally, "I could just do this one thing and keep doing it over and over." So maybe, if you're brand new, you should go through that whole "why Docker?" thing.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Yeah, shouldn't that be included in courses? That's kind of like saying: "I'm going to make you do everything without Docker to realize how beneficial Docker is, or even containers in general."</p>
			<p class="normal end"><strong class="bold">Bret Fisher</strong>: Exactly, it's like saying that, first, we're going to do this on Ubuntu. We're going to install your Node.js app on Ubuntu, and then we're going to use Node v10, which means you can't use the latest <code class="inline">apt-get</code>. Sorry, but you're going to have to go get something else. You have to build it yourself, and then we're going to make you do it on CentOS. After that, we're going to make you do it on Red Hat, Enterprise, and Linux. Oh, and by the way, we're also going to make you do it all on Windows. But we're not done yet. After all four of those, we're now going to do it on Docker on those same four systems. That's going to waste a lot of their time. And the simple fact is, they may not want to do that at all. But maybe you would just be good enough to show an installation document that says: This is what you would have to do. You just show them these 12 pages of documentation for how to do this, and maybe that's enough.</p>
			<h2 class="introHdg">The future of the OS</h2>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: I have the impression that many OSes, apart from being Docker containers, made us question quite a few things, such as do we even need Ubuntu and Red Hat?</p>
			<p class="normal end"><strong class="bold">Bret Fisher</strong>: That's the distribution issue. <a id="_idTextAnchor077"/>The Linux distributions don't want to hear the fact that they're becoming less relevant, but the truth is that they are becoming less relevant. I have no doubt that several of them will succeed in making themselves more relevant in the container space, and that they'll come up with tools that will make it worth me using Ubuntu to run containers instead of choosing something else. To an extent, it's already true today because I would choose one over the other simply because it comes with a more modern kernel that's going to work better with Docker. If you've got a five-year-old kernel that's still on the 3 series, I know I'm not going to prefer you just because I now have to go and update the kernel before I even want to put Docker on it. So that's step one.</p>
			<div>
				<div class="qtFrm" id="_idContainer179">
					<p class="qt">"The Linux distributions don't want to hear the fact that they're becoming less relevant, but the truth is that they are becoming less relevant."</p>
					<p class="qt">—Bret Fisher</p>
				</div>
			</div>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Back to your question about learning the basics first, and learning the problem before you can learn the solution. I've been saying this about things such as TCP/IP, for example. You've been around long enough to know that when we got started, we were reading a book literally called <em class="italics">TCP/IP</em>.</p>
			<p class="normal end"><strong class="bold">Bret Fisher</strong>: I've actually been trying to suppress that memory, and you've just brought it back. Thanks!</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: I remember that the book was actually called <em class="italics">TCP/IP Unleashed</em>, and it was either the 4th or 5th edition because they just kept re-releasing the books because that's how we all learned before the age of Google. This meant that, for years and years, I kept thinking I was lucky to build networks for the first time. We were switching mainly from IPX to TCP/IP, Thicknet and Thinnet, and all of these different protocols and standards to Ethernet. Because of that, I had to learn about TCP packet size, headers, different protocols, and all of that stuff.</p>
			<p class="normal end"><strong class="bold">Bret Fisher</strong>: But today, the issue is that you can ask anyone younger than 30 years old to break down what the OSI layers are and they're probably not going to know any of it, yet they can still get employed and do the work.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Which is a good thing.</p>
			<p class="normal"><strong class="bold">Bret Fisher</strong>: It's both a good thing and a bad thing at the same time. I was convinced for the longest time that, eventually, we're going to have this world where very few people even understand how networks work. It's all going to start to just crumble underneath the weight of the lack of knowledge. In your team, when things start to go wrong, you're thinking we don't know how any of this other stuff that we use works because it's always just worked.</p>
			<p class="normal indent end">It's like public infrastructure. How many of us know how to fix an electrical grid? None of us do. Yet, when it breaks, we're all wishing we really could help. But we haven't yet had a problem, so I don't know. Maybe it's just not a big issue. When I interview people though, I still ask them questions like, "Which layer of the OSI stack does a switch operate on?" or "Which one does a router operate?"</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Do you ever get the answer?</p>
			<p class="normal"><strong class="bold">Bret Fisher</strong>: Sometimes, but it really depends on who you ask. If they're going to be a developer, they're not going to care about that. But if I'm hiring a sysadmin or something, then they should. They all have to really think about it, because to me, it's the foundation of how everything talks to everything else. If you don't even know the basics of that, how could you possibly troubleshoot a computer even in Docker?</p>
			<p class="normal indent end">We're creating all of these virtual networks in Docker, but then the minute you have an IP address conflict, suddenly you must start caring about subnets and subnet masking.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: It opens an issue.</p>
			<p class="normal end"><strong class="bold">Bret Fisher</strong>: Yes, which is for somebody else to solve.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: I have a feeling that this is actually where we are moving in the industry. I see the same thing with programming. Nobody knows how to program anymore, and instead, we all just know how to use the libraries to do stuff.</p>
			<p class="normal end"><strong class="bold">Bret Fisher</strong>: That's a good point. If you're doing nothing but libraries, and you had to write it all by yourself, how would you do it? It sounds like we both learned originally by copying code out of books, which is how I learned BASIC.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: I don't know whether it was happening in your part of the world, but when I was a kid, I would get those computer magazines that featured around four to five pages of code that you would read and write.</p>
			<p class="normal end"><strong class="bold">Bret Fisher</strong>: I don't remember the name of the magazines, but I do remember my dad bringing home this huge 3-inch book, and within it, there would be five or six programs. What I do remember is spending an entire weekend never going outside, just sitting at the computer typing from the book, line for line, just to make an app or game.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Let me guess, it's not a strongly typed language. You needed to finish it before you could discover if something was wrong?</p>
			<p class="normal"><strong class="bold">Bret Fisher</strong>: Yes! Because if it didn't work, you had to go through line by line, all 600 of them. This was done on the Tandy color computer, TRS-80. The biggest problem was that the saving device was a tape recorder. Because of this, you had to plug in an analog line, which would make a sound like a modem to record to the tape. The only way to know if your save worked was to turn the computer off and then back on, play back the tape and then hope your program ran. If it didn't run, you had to type all 600 lines of it all over again.</p>
			<p class="normal indent end">I just remember the weekend that I left the computer on overnight because I wasn't finished. I recorded it to tape on Sunday, I played it back, and it didn't work. I had the sound up too loud or something, and there was distortion. So, I had to retype the whole program just to play it again, which was a horrible way to learn.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: I found myself telling the stories in terms of saying: "You kids have no idea what you're doing." But then I find myself thinking I sound like my mother saying this new generation has no idea what to do.</p>
			<p class="normal end"><strong class="bold">Bret Fisher</strong>: Yeah, your story is boring, but you're exactly right, and that's why this story is boring. Because everybody's first website is very exciting, no matter how old you are. That first time you make a program or anything you've coded work, it's always super exciting to you, and it's always incredibly boring to everyone else.</p>
			<h2 class="introHdg">Looking into the future</h2>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: If you had a crystal ball, where would you predict we're going to be in the next year, next decade, or even further out? Obviously, now the leading-edge tech is containers, but what's coming after?</p>
			<p class="normal end"><strong class="bold">Bret Fisher</strong>: I think it's going to take us a long time before orchestration is normal.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: I mean, with that, we're just starting.</p>
			<p class="normal"><strong class="bold">Bret Fisher</strong>: It's a lot harder now than it's going to be, and it has to get a lot easier before most people are going to use it. I'm really a fan of the whole one container per VM concept, such as Clear Containers with Linux. VMware is doing a little bit of it, Microsoft's doing it, and Docker's doing it with the LinuxKit. I don't necessarily know if we're going to end up with a world where it's a lot of just one container per VM or if it's going to be this world of mini containers in a VM. But I think locked-down apps, whatever the future of containers is, will be the norm.</p>
			<div>
				<div class="qtFrm" id="_idContainer180">
					<p class="qt">"I don't know what the next thing is, and I don't have the pulse on what's going to replace containers. But I think it's going to take us a long time to come up with a new concept at the OS level."</p>
					<p class="qt">—Bret Fisher</p>
				</div>
			</div>
			<p class="normal indent">It'll be weird in 10 years for you to be a software company that sells software that doesn't ship in some form of container image. I mean, it's kind of weird now, depending on where you are in the industry. It'd be very normal to download images. It wouldn't surprise me if we somehow got to the point where we had a bunch of package managers that were downloading. Right now, you have to use <code class="inline">docker pull</code> to get a Docker image, but I can see it as the future <code class="inline">apt-get</code>. The future of <code class="inline">yum</code> is it's downloading of images, <a id="_idTextAnchor078"/>tarballs of container images, and it's running containerd or something in the background, but that's just normal for those apps.</p>
			<p class="normal indent end">But I think it's going to take us a lot longer. I don't know what the next thing is, and I don't have the pulse on what's going to replace containers. But I think it's going to take us a long time to come up with a new concept at the OS level. Everyone talks about unikernels, but I'm not entirely convinced.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: I haven't heard anybody really talk about using unikernels.</p>
			<p class="normal end"><strong class="bold">Bret Fisher</strong>: No, I think the distribution wars are over. The future is roll-your-own distribution. All of the distribution packages will become much more modular, and so it won't really matter what distribution you're running. I love the LinuxKit idea. That's something I'm behind.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Likewise.</p>
			<p class="normal end"><strong class="bold">Bret Fisher</strong>: I hope that the idea of building your own distribution catches on and that it becomes more mainstream and popular. I'd love to be able to say that I'm on DigitalOcean, or I'm on AWS—wherever I am—and just have my preferred distribution. I would have a YAML file that makes it, and I just give it to this instead of me choosing Ubuntu, Amazon, or CentOS. I'd just upload my YAML, and then they'll make my OS for me and put it on a virtual machine. I don't know that it's going to be the future, but I'd love for that to be possible.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Is serverless computing going to kill containers?</p>
			<p class="normal end"><strong class="bold">Bret Fisher</strong>: I personally think serverless and containers go hand-in-hand. You really can't do serverless well without containers.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Thank you! You're the first one to say that. I try to explain to people how serverless and containers support each other, and they all look at me like, <em class="italics">no</em>.</p>
			<p class="normal end"><strong class="bold">Bret Fisher</strong>: Serverless is to me containers as a service.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: But does that mean everything below the level of orchestrators and containers is going to be commodities? Do you even have to care about what's happening below it, for instance, the operating systems that you commented on?</p>
			<p class="normal"><strong class="bold">Bret Fisher</strong>: I really don't think so. We've had this talk before. If we're looking out, five years is a long time. I mean, five years ago, there were no container orchestrators. Five years would be two to three times the current lifecycle of these tools. So, certainly.</p>
			<p class="normal indent end">Let me back that up. For me, any new tool that I'm going to recommend to someone has to be able to replace at least one other tool. It can't be a net add because nobody has any time for anything new. They can't add another tool to their stack if it doesn't replace at least one—if not ideally two—tools, it's very unlikely they're going to adopt it. But right now, I don't feel like orchestrators will really replace any single tool completely.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: That's very true.</p>
			<p class="normal"><strong class="bold">Bret Fisher</strong>: I still need Ansible, Chef, or Puppet to deploy my servers. But now, you look at something like InfraKit, which has not yet taken off, but is like a Terraform plus Swarm. It's basically the idea that the same tool could be my orchestrator and yet also deploy my infrastructure and manage the infrastructure all at the same time. That sounds like a better play and a better pitch to someone.</p>
			<p class="normal indent">Now, you've got this tool that you already manage your infrastructure with, but it's a real big pain to do updates to that infrastructure. So, what if I gave you a tool that does that, plus updates and daily automated management of everything? Maybe that's where we end up in five years. I know today it can manage your infrastructure, but that's not the always-on default option.</p>
			<p class="normal indent end">Perhaps, eventually, whatever tool we're using will be the same tool to create your infrastructure, update your infrastructure, and deploy your apps. All of those things happen by default without any extra packages or any extra tools on top of it. It just comes as a single distribution of tools. I feel like that's the only way we're going to get people to adopt it. Because you've got to get rid of something. And maybe that means you truly have tools that aren't being used anymore. Like, we can get rid of Puppet, Chef, or Ansible, and we only really need this tool.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Because that's kind of a problem. I have the impression that I'm yet to find a big enterprise com<a id="_idTextAnchor079"/>pany that ever removed anything. Maybe I was unlucky, but I've never seen that.</p>
			<h2 class="introHdg">Closing thoughts</h2>
			<p class="normal end"><strong class="bold">Bret Fisher</strong>: The last thing I'll say <a id="_idIndexMarker037"/>is that it's both hard, and rare. A tool has to be extremely awesome in order to be a net add, on top of everything you're already currently doing Docker did that. Docker was beneficial enough by itself that you could still use your Ansibles and your Puppets. You were also able to still have your VMware, all of your <code class="inline">apt-get</code> and other package install tools such as your npms, and your composer. What <a id="_idIndexMarker038"/>you had was this extra tool in the stack and people used it. It's not going to happen very often, so whatever's next probably won't be able to do that. But again, I don't know, and it might just be because I'm skeptical.</p>
			<p class="normal end"><strong class="bold">Viktor Farcic</strong>: Great! I know we're out of time now, so I just wanted to say thank you for taking the time to talk to me today. I really enjoyed talking to you, and I hope to talk to you soon.</p>
			<p class="normal end"><strong class="bold">Bret Fisher</strong>: No problem! It's been great talking to you too, Viktor.</p>
		</div>
	</body></html>