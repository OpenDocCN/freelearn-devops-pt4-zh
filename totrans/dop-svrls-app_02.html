<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Understanding Serverless Frameworks</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we looked into the world of serverless computing, how it works, what the purpose of it is, the benefits of adopting it, the different service providers, and how they fare in terms of the services they offer. We also learned about the pros and cons of adopting a serverless architecture. The goal of this chapter is to teach us different serverless deployment frameworks, and how they will eventually help us to achieve continuous integration and continuous delivery. Furthermore, we will also look at the various features provided by the frameworks and talk in more detail about the serverless framework, learning what it does under the hood.</p>
<p>In the world of application development, the process of developing an application is usually the same. The developer develops the code on their local machine, and compiles and pushes the changes to the source code management repository. The tester then tests and publishes reports, and the ops team plays the role of deploying the code into various different environments and manages the infrastructure.</p>
<p>But there is a chance that the same code will fail on production. Now, to get this code working again, the developer, tester, and operations teams have to work overtime to get the production live again. During root-cause analysis, the developer will say that his code works fine on his PC, the tester will claim that she has tested everything and will provide reports supporting this fact, and the operations guy will say that his job is just to deploy the code. So the challenges we have here are as follows:</p>
<ul>
<li>Make the code run perfectly on production every time it is deployed</li>
<li>Speed up the deployment cycle </li>
<li>Make the team work together and own their responsibility</li>
<li>Have tensionless production deployment </li>
</ul>
<p>The solution to all these problems is adopting DevOps, automating both the process and team collaboration.</p>
<div class="packt_quote"><span>"DevOps is a set of practices that automate the processes between the software development and IT teams, so that they can build, test, and release software faster and more reliably."</span></div>
<div class="packt_quote" style="padding-left: 630px"><span>-Definition of DevOps on Atlassian</span></div>
<p>DevOps rides on the wheels of tools, people, processes, and feedback loops. But tools and processes are the front wheel of DevOps, and play a very important role in driving faster release cycles on non-production and production environments, and in continuous integration, continuous testing, and continuous deployment.</p>
<p>Using serverless architecture to implement DevOps is much easier, as we do not have to worry about the underlying infrastructure. However, we still need continuous integration, monitoring, logging, and continuous deployment for smoother-sailing code to production. As serverless is still in its infancy,  there are quite a few newly developed tools and frameworks that are available, but these numbers will eventually grow. We will be looking at the more popular tools or frameworks, and finally focus on one framework, looking at it in detail and learning about the features that it offers. </p>
<p>All the tools that we will be looking at in this book are open source frameworks. They each serve a particular function on an as-per-need basis. We will consider four popular serverless frameworks and look at what they have to offer. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ClaudiaJS</h1>
                </header>
            
            <article>
                
<p><strong>ClaudiaJS</strong> is one of the earliest of the deployment frameworks and tools. It is licensed under open source, and, at the time writing, it only supports AWS Lambda. ClaudiaJS is a Node.js library that helps to deploy Node.js projects on to AWS Lambda and API Gateway. It currently supports just the Node.js language. ClaudiaJS claims that it is not a framework, but a deployment tool, so the developer just calls it ClaudiaJS within their code and does not have to change their code structure. ClaudiaJS is built on top of AWS SDK and AWS CLI. It flags three types of JavaScript libraries:</p>
<ul>
<li>Command-line library</li>
<li>API builder library</li>
<li>Bot builder library</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Command-line library</h1>
                </header>
            
            <article>
                
<p><span>The first JavaScript library is a </span><span>command-line tool or library. The command-line tool helps to deploy, update, roll back, package, invoke or test, and destroy Lambda functions, and it also works seamlessly with AWS API Gateway</span><span>. It uses the standard npm packaging conventions, which just means that you can call it without making changes to your actual code structure. So the really interesting features with ClaudiaJs's command-line library are as follows:</span></p>
<ul>
<li><kbd>claudia create </kbd>: This command will create a function and a related security role on the AWS portal</li>
<li><kbd>claudia update </kbd>: This command will update the function by deploying a new version of the function and update the associated API </li>
<li><kbd>claudia test-lambda</kbd>: This command will execute the Lambda function </li>
<li><kbd>claudia set-version</kbd>: This command will point the Lambda API stage to the latest deployment version </li>
<li><kbd>claudia add-scheduled-event</kbd>: This command can add the scheduled recurring events for the Lambda function to run, so through this, we can keep the Lambda function warm </li>
<li><kbd>claudia destroy</kbd>: This command will destroy the function and associated API and security roles<span><br/></span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">API builder library </h1>
                </header>
            
            <article>
                
<p>The second type of library is the API builder library. It is the extension of the ClaudiaJS library, and it helps in setting up the AWS API Gateway endpoint. It also helps to route multiple API gateways to a single Lambda function. It automatically enables the CORS for the endpoints. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bot builder library</h1>
                </header>
            
            <article>
                
<p>This library is one of the most interesting libraries provided by ClaudiaJS. This library helps to create different types of bots within minutes. It has out-of-the-box features to integrate with Facebook Messenger, Telegram, and Skype. It is pretty easy to set up a bot using ClaudiaJS bot libraries. </p>
<p>To summarize, ClaudiaJS is great tool when using the AWS Cloud provider. It also supports Node.js. The documentation link provided in the following information box is up to date; the documentation explains each and every CLI command very well. There are lots of tutorials available, ranging from simple development to advanced tasks. The bot libraries are one of the best things that ClaudiaJS can provide. However, <span>there is no support for multiple serverless providers, nor for multiple languages. </span></p>
<div class="packt_infobox">More information on Claudia.JS can found at the following link: <br/>
<a href="https://claudiajs.com">https://claudiajs.com</a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Apex</h1>
                </header>
            
            <article>
                
<p><strong>Apex</strong> is yet another serverless framework that is built on the Go to manage AWS Lambda functions. It is an open source framework and uses Terraform for bootstrapping the resources, which makes it faster to execute. The features provided by the frameworks are the ability to deploy, test functions, roll back deployment, view metrics, and tail logs.</p>
<p>Although it does not support invoking the function locally, it does support multiple languages, such as Node.js, Python, Java, Rust, and Go. We can create various environments through Apex. It has good documentation and helps you to quickly get started with using the frameworks. However, Apex currently only supports AWS Lambda.</p>
<div class="packt_infobox">More information on Apex can be found at the following link:<br/>
<a href="http://apex.run/#function-hooks">http://apex.run/#function-hooks</a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Zappa</h1>
                </header>
            
            <article>
                
<p>If you decide to write your functions in Python, then you can use Zappa to deploy them. <strong>Zappa</strong> is a CLI/command-line framework, and it is open source. Zappa currently supports Python WSGI applications, which are basically Flask and Django applications. It can deploy macro and micro applications. Zappa has a wide variety of features, such as the ability to deploy functions like API to AWS lambda and AWS API Gateway respectively. It can also configure AWS events sources.</p>
<p>Once deployed, we can also invoke the function through Zappa. It can fetch or tail the logs from the AWS. It also allows rollback to the previous version. We can set up multistage deployment (by <strong>stage</strong>, it means multiple environment deployments, such as <kbd>dev</kbd>, <kbd>qa</kbd>, <kbd>uat</kbd>, and <kbd>prod</kbd>).</p>
<p>Zappa also has the cool feature of being able to keep the Lambda function warm. This makes for better performance and decreases latency, to an extent. It allows us to schedule deployment, which means that we can set up deployment earlier on in the day so that it does not interfere with regular traffic. It has the ability to undeploy the purging of logs from the CloudWatch. We can also use it to package the Lambda functions for future deployment. Post deployment status can also be checked through Zappa. Zappa allows us to deploy the Lambda function to any region in AWS. Let's look at a few of Zappa's features: </p>
<ul>
<li><strong>Installation of Zappa:</strong> To install Zappa, you need to make sure that you have Python 2.7 or older, and that you have PIP installed and configured on your local machine or laptop. You also need to make sure that your AWS credentials are set up (<a href="https://aws.amazon.com/blogs/security/a-new-and-standardized-way-to-manage-credentials-in-the-aws-sdks/">https://aws.amazon.com/blogs/security/a-new-and-standardized-way-to-manage-credentials-in-the-aws-sdks/</a>). We need Python and pip to install Zappa on the local environment: </li>
</ul>
<pre style="padding-left: 60px">$ pip install zappa </pre>
<ul>
<li><strong>Zappa init:</strong> The <kbd>init</kbd> code phrase will set up deployment settings. It should automatically detect the Flask/Django application and it will create a JSON file named <kbd>zappa_settings.json</kbd> within the project directory: </li>
</ul>
<pre style="padding-left: 60px">$ zappa init </pre>
<ul>
<li><strong>Packaging and deployment:</strong> Once the settings are configured, we can package and deploy the application using the following command. By default, it uses the production stage, but we can create multiple different stages: </li>
</ul>
<pre style="padding-left: 60px"> $ zappa deploy production</pre>
<p>Zappa is an awesome framework, but there are a few cons about it, such as the fact that it does not support other cloud providers, such as Azure, Google, and OpenWhisk. It only supports Python-WSGI-based applications and no other languages, such as Node.js. </p>
<div class="packt_infobox">You can find more information about the Zappa framework at the following link: <br/>
<a href="https://www.zappa.io/">https://www.zappa.io/</a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Serverless Framework</h1>
                </header>
            
            <article>
                
<p><strong>Serverless Framework</strong> is one of the most popular frameworks for building serverless architectures. It is an open source CLI, with about 23,000 stars on GitHub. There is also an enterprise edition that helps in setting up templates and providing support. This framework has been used by many companies, such as EA, Coca Cola, Expedia, and Reuters. It is a framework that supports lots of cloud service providers, such as AWS, Azure, Google, OpenWhisk, Kubeless, Oracle Fn, and many others. It has a very well-documented user guide containing quite a large number of examples to help you start using it. It supports lots of languages, such as Node.js, Python, Java, Scala, C#, Go, F#, Groovy, Kotlin, PHP, and Swift.</p>
<p>It supports the life cycle of serverless architecture, which can build, deploy, update, and delete. It supports function grouping for easy management of code, processes, and resources across large projects, and also provides fairly good support for CD/CI. It has far better community support compared to other frameworks. It provides lots of plugins to support framework functionality. There are a lot of blogs to help us build the best practices in using the framework. It has a support forum and slack rooms for resolving issues and problems. It supports lots of features, such as deploying functions and events, invoking functions, tailing logs, integration testing, and packaging for future deployment. Let's take a closer look at the features of Serverless Framework. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Framework features </h1>
                </header>
            
            <article>
                
<p>There are many features available in Serverless Framework, although they vary with the cloud provider. I will list and describe a few of the more important and more common ones.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Services and deployment</h1>
                </header>
            
            <article>
                
<p>A service is a project where we define the functions, the events that trigger them, and any infrastructure resources that are required for the function to perform. They are collected together into one file, which is called <kbd>serverless.yml</kbd>: </p>
<pre>eg. <br/> myServerlessService/<br/>        serverless.yml</pre>
<p class="mce-root"/>
<p>When we start using Serverless Framework for deployment, we will be using one single service. But as the application grows, it is recommended that you have multiple services as shown in the following code: </p>
<pre> users/<br/>        serverless.yml # Contains 4 functions  <br/> posts/<br/>         serverless.yml # Contains 4 functions</pre>
<p><span>Having multiple services can isolate the infrastructure resources that are to be used. But it also has a drawback, as currently each service creates a separate REST API on API Gateway. This is a limitation with API Gateway. But there is a workaround to resolve this, which we will look into in future chapters. </span></p>
<p>To create the service, we have to use the <kbd>create</kbd> command, and we must pass the runtime language in which you would like to write the service. We can also provide the path, as shown in the following example: </p>
<pre><span>$ serverless create --template &lt;runtimes&gt; --path myService</span></pre>
<p>The main purpose of Serverless Framework is to deploy functions, events, and infrastructure resources into the remote cloud without much hassle, and that is done through the <kbd>deploy</kbd> plugin. There are various features that this <kbd>deploy</kbd> plugin provides. Let us look at a few of them: </p>
<ul>
<li><strong>Deploy to different stages and regions:</strong> <br/>
<kbd>$ serverless deploy --stage production --region <span>us-east-1</span></kbd></li>
<li><strong>Deploying single function from the service:</strong><br/>
<kbd>$ serverless deploy function &lt;function_name&gt; </kbd></li>
<li><strong>Deploying package to cloud:</strong><br/>
<kbd>$ serverless deploy --package &lt;path to package&gt;</kbd></li>
</ul>
<p>This <kbd>deploy</kbd> plugin works in the following ways:</p>
<ul>
<li>The framework packages up the targeted AWS Lambda function into a <kbd>.zip</kbd> file</li>
<li>The framework fetches the hash of the already uploaded function <kbd>.zip</kbd> file and compares it to the local <kbd>.zip</kbd> file hash</li>
<li>The framework terminates if both hashes are the same</li>
<li>That .zip file is uploaded to your S3 bucket using the same name as the previous function, which is the CloudFormation stack it is pointing to</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functions and events</h1>
                </header>
            
            <article>
                
<p>Functions are the properties that are defined within the service, and they are defined within the <kbd>serverless.yml</kbd>, so we name the function and provide the handler property to the function, and this property points to the function file, which could be Node.js or Python. We can add multiple functions within the property. The functions can inherit the properties from the provider or we can define the properties at function level. These function properties vary as per the cloud provider, as shown in the following code:</p>
<div>
<pre># serverless.yml<br/>service: myService<br/>provider:<br/>  name: aws<br/>  runtime: nodejs6.10<br/>  memorySize: 512 # will be inherited by all functions<br/>functions:<br/>  usersAdd:<br/>    handler: handler.userAdd<br/>    description: optional description for your function<br/>userModify:<br/>    handler: handler.userModify<br/>userDelete:<br/>    handler: handler.userDelete<br/>    memorySize: 256 # function specific</pre></div>
<p class="mce-root">The functions can be listed as arrays if we create a separate file for each function: </p>
<pre class="mce-root"> # serverless.yml<br/> <br/> functions: <br/>     - ${file(../user-functions.yml)}<br/>   - ${file(../post-functions.yml)}<br/> # user-functions.yml <br/>addUser: <br/>     handler: handler.user <br/>deleteUser: <br/>      handler: handler.user</pre>
<p class="mce-root">An environment object property can also be added to the function within the service, and it should be a key–pair value. Also, the function-specific environment variable overrides the provider-specific environment variable: </p>
<pre class="mce-root"> # serverless.yml <br/>service: service-name <br/>provider: aws <br/> <br/> functions: <br/>   hello: <br/>       handler: handler.hello <br/>       environment: <br/>           TABLE_NAME: tableName</pre>
<p><span>Events are things that trigger the function, such as the S3 bucket upload. There are multiple events supported by Serverless Framework, but they vary as per the cloud provider. We can define multiple events for a single function, as shown in the following code: </span></p>
<div>
<pre>events:<br/> - http:<br/>    path: handler<br/>    method: get</pre></div>
<div class="packt_infobox">The types of events provided for AWS Lambda by Serverless Framework are shown at the following link:<br/>
<a href="https://serverless.com/framework/docs/providers/aws/events/">https://serverless.com/framework/docs/providers/aws/events/</a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Variables and plugins</h1>
                </header>
            
            <article>
                
<p><strong>Variables</strong> are the values that can be passed to the configuration values within the <kbd>serverless.yml</kbd> while running the Serverless Framework command. They need to pass reference values enclosed in <kbd>${}</kbd> brackets, but you can use variables in property values rather than in the property keys. The following code shows how this is added in the <kbd>serverless.yml</kbd> file:  </p>
<pre class="mce-root">provider:  <br/>    name: aws <br/>     stage: ${opt:stage, 'dev'}</pre>
<p>In the following statement, we pass the parameter to the CLI and the <kbd>stage</kbd> value is populated in the <kbd>serverless.yml</kbd> file:</p>
<pre>$ serverless <span>deploy --stage qa</span></pre>
<p><span>The variables can be used recursively as reference properties—that is, we can combine multiple values and variable sources, as shown in the following environment variable: <br/></span></p>
<pre><span> </span>environment: SERV_SECRET: ${file(../config.${self:provider.stage}.json):CREDS}<span><span class="hljs-string"> </span></span></pre>
<p class="mce-root"/>
<p><span>We can reference environment variables as well (as shown in the following code), but it is insecure to add sensitive data to environment variables, because they can be accessed through build logs or in the serverless CloudFormation templates: </span></p>
<pre class="mce-root">functions: <br/>    myfunction: <br/>        name: ${env:FUNC_PREFIX}-myfunction <br/>        handler: handler.myfunction</pre>
<p>Let's look at a few tutorials for doing this. Make sure that you have the latest Serverless Framework installed and working: </p>
<ol>
<li>Create a simple <kbd>hello</kbd> project with the Serverless AWS template, then open this project in your favorite editor: </li>
</ol>
<pre style="padding-left: 60px"> $ serverless create --template aws-nodejs --path env-variable-service </pre>
<ol start="2">
<li>Replace the <kbd>serverless.yml</kbd> file and handler, as shown in the following code. Here, we are adding an environment variable by the name of <kbd>MY_VAR</kbd>, and in the handler, we display the environment variable in the message output: </li>
</ol>
<pre style="padding-left: 60px">  $ cat serverless.yml<br/>service: env-variable-service<br/># You can pin your service to only deploy with a specific Serverless version<br/> # Check out our docs for more details<br/> # frameworkVersion: "=X.X.X"<br/>provider:<br/>   name: aws<br/>   runtime: nodejs6.10<br/># you can define service wide environment variables here<br/>   environment:<br/>     MY_VAR: Lion<br/>  functions:<br/>     hello:<br/>       handler: handler.hello<br/> $ less handler.js<br/>'use strict';<br/>module.exports.hello = (event, context, callback) =&gt; {<br/>const response = {<br/>  statusCode: 200,<br/>  body: JSON.stringify({<br/>    message: `my favourite animal is ${process.env.MY_VAR}`,<br/>    input: event,<br/>  }),<br/>};<br/>callback(null, response);<br/>};</pre>
<ol start="3">
<li>Let's invoke locally and look at the result. If you look in the message section, you can see the value of the environment variable that we defined, as shown in the following code: </li>
</ol>
<pre style="padding-left: 60px"> $ serverless invoke local -f hello<br/> {<br/> "statusCode": 200,<br/> "body": "{\"message\":\"my favourite animal is Lion\",\"input\":\"\"}"<br/> }<span class="packt_screen"><br/></span></pre>
<p>As we discussed earlier for nonsensitive data, adding a variable into the <kbd>serverless.yml</kbd> file should be fine, but how do we add sensitive data into an environment variable, like a database connection. Let's look into the steps needed to do this: </p>
<ol>
<li>Create a new file in the <span><kbd>env-variable-service</kbd> folder and name it <strong><kbd>serverless.env.yml</kbd></strong>. Then add the following details into it, as shown in the following code. Here, we are creating a secret variable as per the environment:<br/></span></li>
</ol>
<pre style="padding-left: 60px"><span> </span>$ less serverless.env.yml<br/> dev:<br/>   MYSECRET_VAR: '<strong>It is at secret den</strong>'<span><br/></span></pre>
<ol start="2">
<li>Let's add one more environment variable in the <kbd>serverless.yml</kbd> file, but this time the value will be pulled from the file, so you need to add the highlighted line as the environment variable. This way, Serverless Framework will read through the file and refer it to the specific environment: </li>
</ol>
<div>
<pre style="padding-left: 60px"># serverless.yml<br/> # you can define service wide environment variables here<br/>environment:<br/>   MY_VAR: Lion<br/>   MYSECRET_VAR: ${file(./serverless.env.yml):dev.MYSECRET_VAR}</pre></div>
<ol start="3">
<li>Let's change the response of the handler to display the secret through the message. Ideally, we should be displaying the secret over the screen, but for this tutorial, I am doing it manually.  So let's replace the message body with the one displayed in the following code: </li>
</ol>
<pre class="mce-root" style="padding-left: 60px"> # handler.js<br/>message:<span> </span><span>`my favourite animal is</span><span> </span><span>${</span><span>process</span><span>.</span><span>env</span><span>.</span><span>MY_VAR</span><span>}</span><span> </span><span>and</span><span> </span><span>${</span><span>process</span><span>.</span><span>env</span><span>.</span><span>MYSECRET_VAR</span><span>}</span><span>`</span><span>,</span></pre>
<ol start="4">
<li>Invoke the function locally and look at the output: </li>
</ol>
<pre class="mce-root" style="padding-left: 60px"> $ serverless invoke local -f hello<br/> {<br/> "statusCode": 200,<br/> "body": "{\"message\":\"my favourite animal is Lion and It is at secret den\",\"input\":\"\"}"<br/> }</pre>
<p>Finally, like I said, we can have multiple environment variables for each deployment stage, such as <kbd>dev</kbd>, <kbd>sit</kbd>,<kbd>uat</kbd>, and <kbd>prod</kbd>. The following steps show us how we can add them: </p>
<ol>
<li>Let's add one more environment variable for <kbd>prod</kbd> to the <kbd><span>serverless.env.yml</span></kbd> <span>file</span><span>. Then, we can use them dynamically within the <kbd>serverless.yml</kbd> file, as shown in the following code: </span></li>
</ol>
<pre class="mce-root" style="padding-left: 60px"> $ less serverless.env.yml<br/>dev<span>:<br/></span>   MYSECRET_VAR<span>:</span><span> </span><span>'It is at secret dev den'<br/></span>prod<span>:<br/></span>   <span>MYSECRET_VAR</span><span>:</span><span> </span><span>'It is at secret prod den'</span></pre>
<ol start="2">
<li>Now, we need to makes changes to the <kbd>serverless.yml</kbd> file to dynamically pick up the environment variable on the basis of the stage that we set at the time of the invocation or deployment of the function, which is the replacement of the <kbd>MYSECRET_VAR</kbd> line with the following line:</li>
</ol>
<pre style="padding-left: 60px"><span> </span>#serverless.yml<br/>MYSECRET_VAR: ${file(./serverless.env.yml):${opt:stage}.MYSECRET_VAR}</pre>
<ol start="3">
<li>We will now invoke the function locally <span>and look at the output for a different stage: <br/></span></li>
</ol>
<pre style="padding-left: 60px"><span> </span>$ serverless invoke local -f hello -s dev<br/> {<br/> "statusCode": 200,<br/> "body": "{\"message\":\"my favourite animal is Lion and It is at secret dev den\",\"input\":\"\"}"<br/> }<br/> <br/> $ serverless invoke local -f hello -s prod<br/> {<br/> "statusCode": 200,<br/> "body": "{\"message\":\"my favourite animal is Lion and It is at secret Prod den\",\"input\":\"\"}"<br/> }</pre>
<div class="packt_infobox">I have uploaded the preceding tutorials into the following GitHub repository as well, so you can use them at your leisure:<br/>
<a href="https://github.com/shzshi/env-variable-service.git">https://github.com/shzshi/env-variable-service.git</a></div>
<div>
<p>The plugins are custom JavaScript code that provide extension to existing CLI commands within Serverless Framework. The framework itself is a group of plugins that is provided in the core. We can build our own custom plugin; Serverless Framework provides documentation for this plugin as well. The plugin can be installed using the following code: </p>
<div>
<pre>$ npm install --save custom-serverless-plugin</pre></div>
</div>
<p><span>We also need to call them within the <kbd>serverless</kbd> service, using the following code: </span></p>
<div>
<pre>serverless.yml file <br/> plugins:<br/>     - custom-serverless-plugin</pre></div>
<div class="packt_infobox">A list of existing Serverless plugins can be found at the following link:<br/>
<a href="https://github.com/serverless/plugins">https://github.com/serverless/plugins</a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resources</h1>
                </header>
            
            <article>
                
<p>When we create Lambda functions, they might be dependent on many different types of infrastructure resources, such as AWS, DynamoDB or AWS S3, so we can define these resources within the <kbd>serverless.yml</kbd> file and deploy them. When we add these resources, they get added to the <kbd>serverless.yml</kbd> file, and when they are deployed, they get added to the CloudFormation stack and are executed at<span> </span>serverless deploy.<strong> </strong>We can look at the following example to see how these resources are defined: </p>
<div>
<pre>resources:<br/>  Resources:<br/>    NewResource:<br/>       Type: AWS::S3::Bucket<br/>       Properties:<br/>         BucketName: my-s3-bucket</pre></div>
<div class="packt_infobox">You can refer to the following link for more details on resources and to see which resources are available using only AWS Lambda: <a href="https://serverless.com/framework/docs/providers/aws/guide/resources/">https://serverless.com/framework/docs/providers/aws/guide/resources/</a></div>
<p>Let's look at a simple example of Serverless Framework using AWS Lambda. <br/>
You will need the following prerequisites for this: </p>
<ul>
<li class="mce-root"><span>A free AWS account needs to be created</span></li>
<li><span>Nodejs 4.0 and higher must be installed on the local machine</span></li>
<li><span>AWS CLI can also be installed, but this is optional</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up AWS access keys </h1>
                </header>
            
            <article>
                
<p>Go through the following steps:</p>
<ol>
<li>Log in to the AWS account and go to the <span class="packt_screen">IAM</span> (<span class="packt_screen">Identity &amp; Access Management</span>) page.</li>
<li>Click on <span class="packt_screen">Users</span> on the left-hand side bar, then click on the <span class="packt_screen">Add User </span>button and add the username <kbd>adm-serverless</kbd>. Then enable <span class="packt_screen">programmatic access</span><strong> </strong>by clicking the checkbox. Then click on the <span class="packt_screen">Next:Premissions</span><strong> </strong>button. </li>
<li>On this page, select <span class="packt_screen">Attach existing policies directly</span>, search for and select the <span class="packt_screen">AdministratorAccess</span> checkbox, then click on <span class="packt_screen">Next:Review</span>.</li>
<li>Now check whether everything is good, then click <span class="packt_screen">Create User</span>. This will create a user and show us the access key ID<strong> </strong>and secret access key. Copy and store these keys somewhere, temporarily. </li>
</ol>
<ol start="5">
<li>Now that we have the keys, we export them as an environment variable so that they will be accessed by the framework to perform their required function: </li>
</ol>
<pre style="padding-left: 60px">$ export <span>AWS_ACCESS_KEY_ID=&lt;access-key-id&gt;<br/></span>$ export <span>AWS_SECRET_ACCESS_KEY=&lt;secret-key-id&gt;</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installation of Serverless Framework</h1>
                </header>
            
            <article>
                
<p>Go through the following steps:</p>
<ol>
<li class="mce-root"><span>Install Node.js 4.0 or higher from </span><a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a><span> . Once installed, we can verify installation through the following command:</span></li>
</ol>
<pre style="color: black;padding-left: 60px"> $ node --version</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="2">
<li>Now we need to install Serverless Framework globally through the following command:</li>
</ol>
<pre style="padding-left: 60px"> $ npm install -g serverless</pre>
<ol start="3">
<li>Once installed successfully, we can verify the installation by using the following command. It will show all the framework commands and documentation: </li>
</ol>
<pre style="padding-left: 60px">$ serverless</pre>
<ol start="4">
<li>We can also see the version of Serverless Framework installed by using the following command: </li>
</ol>
<pre style="padding-left: 60px">$ serverless --version</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lambda service and function deployment</h1>
                </header>
            
            <article>
                
<p>In the following step, we will be create a simple Node.js service and Lambda function, and then deploy and invoke them: </p>
<ol>
<li>Create a new service using the Node.js template by Serverless Framework. We need to make sure that the name is unique and add the path to the service, which is optional. This command will create two files—<kbd>handler.js</kbd> and <kbd>serverless.yml</kbd>: </li>
</ol>
<pre style="padding-left: 60px">$ serverless create --template aws-nodejs --path my-serverless-service<br/>Serverless: Generating boilerplate...<br/> Serverless: Generating boilerplate in "/Users/shashi/Documents/packt/chapter2/serverless/my-serverless-service"<br/> _______ __<br/> | _ .-----.----.--.--.-----.----| .-----.-----.-----.<br/> | |___| -__| _| | | -__| _| | -__|__ --|__ --|<br/> |____ |_____|__| \___/|_____|__| |__|_____|_____|_____|<br/> | | | The Serverless Application Framework<br/> | | serverless.com, v1.26.1<br/> -------'<br/>Serverless: Successfully generated boilerplate for template: "aws-nodejs"</pre>
<p>A service is the framework's unit of organization. It can be considered as a project file. It's where we can define functions, the events that trigger them, and the resources of the function that we will use. All of these are placed into one file <kbd>serverless.yml</kbd>. In this <kbd>.yaml</kbd> file, we define the service called <kbd>my-serverless-service</kbd>. Then we define the provider; as I mentioned earlier, Serverless Framework supports a lot of other cloud service providers. We can list the provider details in this tag and also mention the runtime, which in our case is Node.js. The runtime will change depending on the language we use to write the function. We can define the environment or stage we are deploying to—which in our case is <kbd>dev</kbd>—as well as the respective region. Then, in the <kbd>functions</kbd> section, we define the function name—which in our case is <kbd>hello</kbd>—which has an attribute called <kbd>handler</kbd>, and this handler will call the <kbd>handler.js</kbd> file. We can also define the memory size. Next, I have added an HTTP event, which, in addition to the Lambda function, provisions the AWS API Gateway. It will create and provide an endpoint for the handler. So, using one script, we can provision a Lambda function and an API endpoint. We can define various other attributes and parameters; we will look into these in more detail in the next chapter.</p>
<div class="packt_quote packt_infobox"><span>Please make sure the <kbd>.yaml</kbd> files are properly indented, otherwise they will fail. You can also use the one that I have put on the following GitHub link: <br/>
<a href="https://github.com/shzshi/my-serverless-service.git">https://github.com/shzshi/my-serverless-service.git</a><br/></span></div>
<pre class="mce-root">$ cat serverless.yml <br/># Welcome to Serverless!<br/>#<br/># This file is the main config file for your service.<br/># It's very minimal at this point and uses default values.<br/># You can always add more config options for more control.<br/># We've included some commented out config examples here.<br/># Just uncomment any of them to get that config option.<br/>#<br/># For full config options, check the docs:<br/># docs.serverless.com <br/>#<br/># Happy Coding!<br/>service<span>:</span><span> </span><span>my-serverless-service<br/></span># You can pin your service to only deploy with a specific Serverless version<br/># Check out our docs for more details<br/># frameworkVersion: "=X.X.X"<br/>provider<span>:<br/></span>name<span>:</span><span> </span><span>aws<br/></span>runtime<span>:</span><span> </span><span>nodejs6.10<br/></span>stage<span>:</span><span> </span><span>dev<br/></span>region<span>:</span><span> </span><span>us-east-1<br/></span>functions<span>:<br/></span>hello<span>:<br/></span>handler<span>:</span><span> </span><span>handler.hello<br/></span>memorySize<span>:</span><span> </span><span>128<br/></span>events<span>:<br/></span>-<span> </span><span>http</span><span>:<br/></span>path<span>:</span><span> </span><span>handler<br/></span>method<span>:</span><span> </span><span>get</span></pre>
<p><span>The <kbd>handler.js</kbd> code phrase is the Node.js Lambda function for <kbd>Hello, World!</kbd>, which is referenced in the <kbd>serverless.yml</kbd> file. It is a pretty simple function that will just display the message</span> <kbd>My Serverless World</kbd> <span>on execution, as shown in the following code: </span></p>
<pre class="mce-root">$ cat handler.js<br/>'use strict'<span>;<br/></span>module<span>.</span><span>exports</span><span>.</span><span>hello</span><span> </span><span>=</span><span> </span><span>(</span><span>event</span><span>,</span><span> </span><span>context</span><span>,</span><span> </span><span>callback</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{<br/></span>const<span> </span><span>response</span><span> </span><span>=</span><span> </span><span>{<br/></span>statusCode:<span> </span><span>200</span><span>,<br/></span>body:<span> </span><span>JSON</span><span>.</span><span>stringify</span><span>({<br/></span>message:<span> </span><span>'My Serverless World'</span><span>,<br/></span>input:<span> </span><span>event</span><span>,<br/></span>}),<br/>};<br/>callback<span>(</span><span>null</span><span>,</span><span> </span><span>response</span><span>);<br/></span>// Use this code if you don't use the http event with the LAMBDA-PROXY integration<br/>// callback(null, { message: 'Go Serverless v1.0! Your function executed successfully!', event });<br/>};</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Invoking locally</h1>
                </header>
            
            <article>
                
<p>Pushing the code to AWS Lambda and testing every time would be expensive and time consuming. So with Serverless Framework, we can invoke or test functions locally and then deploy them to the cloud. We can have this as part of the continuous deployment pipeline, where we can set the local invocation for <kbd>dev</kbd> stage deployment, set up automated testing, and then move them further down the pipeline to deploy and test remotely. The following command is used to invoke the function locally: </p>
<pre>$ serverless invoke local --function hello<br/> {<br/> "statusCode": 200,<br/> "body": "{\"message\":\"My Serverless World\",\"input\":\"\"}"<br/> }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying and invoking locally </h1>
                </header>
            
            <article>
                
<p>As we are now able to successfully invoke and test the function locally, we should be fine to deploy and test it remotely. First, we need to make sure that we have retrieved and exported the access and secret access keys as environment variables, as shown in the following code: </p>
<pre>$ export AWS_ACCESS_KEY_ID=&lt;access-key-id&gt;<br/>$ export AWS_SECRET_ACCESS_KEY=&lt;secret-key-id&gt;<span> </span></pre>
<p><span>Now I am deploying the function and API to the AWS Cloud through a simple <kbd>deploy</kbd> command. Behind the scenes, the deployment process will create a <kbd>.serverless</kbd> folder with <kbd>CloudFormation</kbd> JSON templates. The serverless code is packaged into a <kbd>.zip</kbd> file and a serverless state JSON file. If we look into the <kbd>create-stack</kbd> JSON template, Serverless Framework will create an S3 bucket on the AWS Cloud and deploy the function and API package on to the bucket with the <kbd>CloudFormation</kbd> template JSON file. It will also keep the state of the deployment in the form of a JSON file. The successful deployment will provision an API endpoint that is tied to an AWS Lambda function and creates a service as mentioned in the provider: </span></p>
<pre>$ serverless deploy<br/><br/> Serverless: Packaging service...<br/> Serverless: Excluding development dependencies...<br/> Serverless: Creating Stack...<br/> Serverless: Checking Stack create progress...<br/> .....<br/> Serverless: Stack create finished...<br/> Serverless: Uploading CloudFormation file to S3...<br/> Serverless: Uploading artifacts...<br/> Serverless: Uploading service .zip file to S3 (417 B)...<br/> Serverless: Validating template...<br/> Serverless: Updating Stack...<br/> Serverless: Checking Stack update progress...<br/> ..............................<br/> Serverless: Stack update finished...<br/> Service Information<br/> service: my-serverless-service<br/> stage: dev<br/> region: us-east-1<br/> stack: my-serverless-service-dev<br/> api keys:<br/> None<br/> endpoints:<br/> GET - https://kn6esoolgi.execute-api.us-east-1.amazonaws.com/dev/handler</pre>
<pre> functions:<br/> hello: my-serverless-service-dev-hello</pre>
<p class="mce-root">Postdeployment, we will go to the AWS portal and see whether the function is deployed. Then we will invoke it through the portal and then again invoke the remote function through the serverless CLI, using the following steps: </p>
<ol>
<li class="mce-root">Log in to the AWS portal, then select the correct region where the function and API was deployed. </li>
<li class="mce-root">Select the service as <span class="packt_screen">Lambda</span>. The Lambda portal page will show the function name deployed. Select the function that you test using the radio button, then go to the drop-down marked <span class="packt_screen">Actions </span>and select the option marked <span class="packt_screen">Test</span>. The window will pop up to configure the event. You can add your own event or keep the default, and then click on <span class="packt_screen">Save</span>. The event will be saved and the page will be redirected to the <span class="packt_screen">Function</span> page. Now click on the <span class="packt_screen">Test</span> button. The function will be executed, and the execution status and results will be displayed.</li>
</ol>
<p class="mce-root">As I mentioned earlier, we can invoke the remote function locally as well. We will now look at the various commands for the remote Lambda function: </p>
<p class="mce-root">To invoke the function and get the logs, use the following command: </p>
<pre> $ serverless invoke -f hello -l<br/> {<br/> "statusCode": 200,<br/> "body": "{\"message\":\"My Serverless World\",\"input\":{}}"<br/> }<br/> --------------------------------------------------------------------<br/> START RequestId: c4bdc7f8-60e1-11e8-9846-f5267af11144 Version: $LATEST<br/> END RequestId: c4bdc7f8-60e1-11e8-9846-f5267af11144<br/> REPORT RequestId: c4bdc7f8-60e1-11e8-9846-f5267af11144 Duration: 44.37 ms Billed Duration: 100 ms Memory Size: 128 MB Max Memory Used: 20 MB</pre>
<p>To just get the logs for the previous invocation, enter the following code. We can do this in a separate console to test the working:</p>
<pre>$ serverless logs -f hello -t<br/>START RequestId: 75139847-60dc-11e8-8c0b-4f4996ceffb3 Version: $LATEST<br/> END RequestId: 75139847-60dc-11e8-8c0b-4f4996ceffb3<br/> REPORT RequestId: 75139847-60dc-11e8-8c0b-4f4996ceffb3 Duration: 9.04 ms Billed Duration: 100 ms Memory Size: 128 MB Max Memory Used: 20 MB<br/>START RequestId: 675574ec-60de-11e8-bbd5-8bf1c1e7f05c Version: $LATEST<br/> END RequestId: 675574ec-60de-11e8-bbd5-8bf1c1e7f05c<br/> REPORT RequestId: 675574ec-60de-11e8-bbd5-8bf1c1e7f05c Duration: 18.15 ms Billed Duration: 100 ms Memory Size: 128 MB Max Memory Used: 20 MB</pre>
<p>The command will undeploy the function from the Lambda and also remove the package details from the S3 bucket. Once <kbd>serverless remove</kbd> runs successfully (as shown in the following code), you can log in to the AWS portal and check the S3 bucket and the Lambda function for the specific region—it should be removed:  </p>
<pre>$ serverless remove<br/>Serverless: Getting all objects in S3 bucket...<br/> Serverless: Removing objects in S3 bucket...<br/> Serverless: Removing Stack...<br/> Serverless: Checking Stack removal progress...<br/> .........<br/> Serverless: Stack removal finished...<span class="packt_screen"><br/> <br/></span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about different frameworks, such as ClaudiaJS, Zappa, and Apex. We also looked into a few examples of using them, but we mostly covered Serverless Framework extensively. We will be using Serverless Framework extensively in most of our tutorials while going through the book, because Serverless Framework fairs far better than other frameworks because it has better community support and support for multiple cloud providers. This means that you don't have vendor locking, as you do with some other frameworks. It also has a huge list of plugins for different types of cloud service, good blog support, and finally, some really good features for easy deployment into various different cloud providers. </p>


            </article>

            
        </section>
    </body></html>