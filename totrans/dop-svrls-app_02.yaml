- en: Understanding Serverless Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked into the world of serverless computing, how
    it works, what the purpose of it is, the benefits of adopting it, the different
    service providers, and how they fare in terms of the services they offer. We also
    learned about the pros and cons of adopting a serverless architecture. The goal
    of this chapter is to teach us different serverless deployment frameworks, and
    how they will eventually help us to achieve continuous integration and continuous
    delivery. Furthermore, we will also look at the various features provided by the
    frameworks and talk in more detail about the serverless framework, learning what
    it does under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: In the world of application development, the process of developing an application
    is usually the same. The developer develops the code on their local machine, and
    compiles and pushes the changes to the source code management repository. The
    tester then tests and publishes reports, and the ops team plays the role of deploying
    the code into various different environments and manages the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there is a chance that the same code will fail on production. Now, to get
    this code working again, the developer, tester, and operations teams have to work
    overtime to get the production live again. During root-cause analysis, the developer
    will say that his code works fine on his PC, the tester will claim that she has
    tested everything and will provide reports supporting this fact, and the operations
    guy will say that his job is just to deploy the code. So the challenges we have
    here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Make the code run perfectly on production every time it is deployed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speed up the deployment cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the team work together and own their responsibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have tensionless production deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The solution to all these problems is adopting DevOps, automating both the process
    and team collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: '"DevOps is a set of practices that automate the processes between the software
    development and IT teams, so that they can build, test, and release software faster
    and more reliably."'
  prefs: []
  type: TYPE_NORMAL
- en: -Definition of DevOps on Atlassian
  prefs: []
  type: TYPE_NORMAL
- en: DevOps rides on the wheels of tools, people, processes, and feedback loops.
    But tools and processes are the front wheel of DevOps, and play a very important
    role in driving faster release cycles on non-production and production environments,
    and in continuous integration, continuous testing, and continuous deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Using serverless architecture to implement DevOps is much easier, as we do not
    have to worry about the underlying infrastructure. However, we still need continuous
    integration, monitoring, logging, and continuous deployment for smoother-sailing
    code to production. As serverless is still in its infancy,  there are quite a
    few newly developed tools and frameworks that are available, but these numbers
    will eventually grow. We will be looking at the more popular tools or frameworks,
    and finally focus on one framework, looking at it in detail and learning about
    the features that it offers.
  prefs: []
  type: TYPE_NORMAL
- en: All the tools that we will be looking at in this book are open source frameworks.
    They each serve a particular function on an as-per-need basis. We will consider
    four popular serverless frameworks and look at what they have to offer.
  prefs: []
  type: TYPE_NORMAL
- en: ClaudiaJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**ClaudiaJS** is one of the earliest of the deployment frameworks and tools.
    It is licensed under open source, and, at the time writing, it only supports AWS
    Lambda. ClaudiaJS is a Node.js library that helps to deploy Node.js projects on
    to AWS Lambda and API Gateway. It currently supports just the Node.js language.
    ClaudiaJS claims that it is not a framework, but a deployment tool, so the developer
    just calls it ClaudiaJS within their code and does not have to change their code
    structure. ClaudiaJS is built on top of AWS SDK and AWS CLI. It flags three types
    of JavaScript libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: Command-line library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API builder library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bot builder library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command-line library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first JavaScript library is a command-line tool or library. The command-line
    tool helps to deploy, update, roll back, package, invoke or test, and destroy
    Lambda functions, and it also works seamlessly with AWS API Gateway. It uses the
    standard npm packaging conventions, which just means that you can call it without
    making changes to your actual code structure. So the really interesting features
    with ClaudiaJs''s command-line library are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`claudia create `: This command will create a function and a related security
    role on the AWS portal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`claudia update `: This command will update the function by deploying a new
    version of the function and update the associated API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`claudia test-lambda`: This command will execute the Lambda function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`claudia set-version`: This command will point the Lambda API stage to the
    latest deployment version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`claudia add-scheduled-event`: This command can add the scheduled recurring
    events for the Lambda function to run, so through this, we can keep the Lambda
    function warm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`claudia destroy`: This command will destroy the function and associated API
    and security roles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API builder library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second type of library is the API builder library. It is the extension of
    the ClaudiaJS library, and it helps in setting up the AWS API Gateway endpoint.
    It also helps to route multiple API gateways to a single Lambda function. It automatically
    enables the CORS for the endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Bot builder library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This library is one of the most interesting libraries provided by ClaudiaJS.
    This library helps to create different types of bots within minutes. It has out-of-the-box
    features to integrate with Facebook Messenger, Telegram, and Skype. It is pretty
    easy to set up a bot using ClaudiaJS bot libraries.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, ClaudiaJS is great tool when using the AWS Cloud provider. It
    also supports Node.js. The documentation link provided in the following information
    box is up to date; the documentation explains each and every CLI command very
    well. There are lots of tutorials available, ranging from simple development to
    advanced tasks. The bot libraries are one of the best things that ClaudiaJS can
    provide. However, there is no support for multiple serverless providers, nor for
    multiple languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'More information on Claudia.JS can found at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://claudiajs.com](https://claudiajs.com)'
  prefs: []
  type: TYPE_NORMAL
- en: Apex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Apex** is yet another serverless framework that is built on the Go to manage
    AWS Lambda functions. It is an open source framework and uses Terraform for bootstrapping
    the resources, which makes it faster to execute. The features provided by the
    frameworks are the ability to deploy, test functions, roll back deployment, view
    metrics, and tail logs.'
  prefs: []
  type: TYPE_NORMAL
- en: Although it does not support invoking the function locally, it does support
    multiple languages, such as Node.js, Python, Java, Rust, and Go. We can create
    various environments through Apex. It has good documentation and helps you to
    quickly get started with using the frameworks. However, Apex currently only supports
    AWS Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'More information on Apex can be found at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://apex.run/#function-hooks](http://apex.run/#function-hooks)'
  prefs: []
  type: TYPE_NORMAL
- en: Zappa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you decide to write your functions in Python, then you can use Zappa to deploy
    them. **Zappa** is a CLI/command-line framework, and it is open source. Zappa
    currently supports Python WSGI applications, which are basically Flask and Django
    applications. It can deploy macro and micro applications. Zappa has a wide variety
    of features, such as the ability to deploy functions like API to AWS lambda and
    AWS API Gateway respectively. It can also configure AWS events sources.
  prefs: []
  type: TYPE_NORMAL
- en: Once deployed, we can also invoke the function through Zappa. It can fetch or
    tail the logs from the AWS. It also allows rollback to the previous version. We
    can set up multistage deployment (by **stage**, it means multiple environment
    deployments, such as `dev`, `qa`, `uat`, and `prod`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Zappa also has the cool feature of being able to keep the Lambda function warm.
    This makes for better performance and decreases latency, to an extent. It allows
    us to schedule deployment, which means that we can set up deployment earlier on
    in the day so that it does not interfere with regular traffic. It has the ability
    to undeploy the purging of logs from the CloudWatch. We can also use it to package
    the Lambda functions for future deployment. Post deployment status can also be
    checked through Zappa. Zappa allows us to deploy the Lambda function to any region
    in AWS. Let''s look at a few of Zappa''s features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Installation of Zappa:** To install Zappa, you need to make sure that you
    have Python 2.7 or older, and that you have PIP installed and configured on your
    local machine or laptop. You also need to make sure that your AWS credentials
    are set up ([https://aws.amazon.com/blogs/security/a-new-and-standardized-way-to-manage-credentials-in-the-aws-sdks/](https://aws.amazon.com/blogs/security/a-new-and-standardized-way-to-manage-credentials-in-the-aws-sdks/)). We
    need Python and pip to install Zappa on the local environment:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Zappa init:** The `init` code phrase will set up deployment settings. It
    should automatically detect the Flask/Django application and it will create a
    JSON file named `zappa_settings.json` within the project directory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Packaging and deployment:** Once the settings are configured, we can package
    and deploy the application using the following command. By default, it uses the
    production stage, but we can create multiple different stages:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Zappa is an awesome framework, but there are a few cons about it, such as the
    fact that it does not support other cloud providers, such as Azure, Google, and
    OpenWhisk. It only supports Python-WSGI-based applications and no other languages,
    such as Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information about the Zappa framework at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.zappa.io/](https://www.zappa.io/)'
  prefs: []
  type: TYPE_NORMAL
- en: Serverless Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Serverless Framework** is one of the most popular frameworks for building
    serverless architectures. It is an open source CLI, with about 23,000 stars on
    GitHub. There is also an enterprise edition that helps in setting up templates
    and providing support. This framework has been used by many companies, such as
    EA, Coca Cola, Expedia, and Reuters. It is a framework that supports lots of cloud
    service providers, such as AWS, Azure, Google, OpenWhisk, Kubeless, Oracle Fn,
    and many others. It has a very well-documented user guide containing quite a large
    number of examples to help you start using it. It supports lots of languages,
    such as Node.js, Python, Java, Scala, C#, Go, F#, Groovy, Kotlin, PHP, and Swift.'
  prefs: []
  type: TYPE_NORMAL
- en: It supports the life cycle of serverless architecture, which can build, deploy,
    update, and delete. It supports function grouping for easy management of code,
    processes, and resources across large projects, and also provides fairly good
    support for CD/CI. It has far better community support compared to other frameworks.
    It provides lots of plugins to support framework functionality. There are a lot
    of blogs to help us build the best practices in using the framework. It has a
    support forum and slack rooms for resolving issues and problems. It supports lots
    of features, such as deploying functions and events, invoking functions, tailing
    logs, integration testing, and packaging for future deployment. Let's take a closer
    look at the features of Serverless Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Framework features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many features available in Serverless Framework, although they vary
    with the cloud provider. I will list and describe a few of the more important
    and more common ones.
  prefs: []
  type: TYPE_NORMAL
- en: Services and deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A service is a project where we define the functions, the events that trigger
    them, and any infrastructure resources that are required for the function to perform.
    They are collected together into one file, which is called `serverless.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When we start using Serverless Framework for deployment, we will be using one
    single service. But as the application grows, it is recommended that you have
    multiple services as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Having multiple services can isolate the infrastructure resources that are to
    be used. But it also has a drawback, as currently each service creates a separate
    REST API on API Gateway. This is a limitation with API Gateway. But there is a
    workaround to resolve this, which we will look into in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the service, we have to use the `create` command, and we must pass
    the runtime language in which you would like to write the service. We can also
    provide the path, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The main purpose of Serverless Framework is to deploy functions, events, and
    infrastructure resources into the remote cloud without much hassle, and that is
    done through the `deploy` plugin. There are various features that this `deploy`
    plugin provides. Let us look at a few of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deploy to different stages and regions:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ serverless deploy --stage production --region us-east-1`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Deploying single function from the service:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ serverless deploy function <function_name> `'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Deploying package to cloud:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ serverless deploy --package <path to package>`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This `deploy` plugin works in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: The framework packages up the targeted AWS Lambda function into a `.zip` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The framework fetches the hash of the already uploaded function `.zip` file
    and compares it to the local `.zip` file hash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The framework terminates if both hashes are the same
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That .zip file is uploaded to your S3 bucket using the same name as the previous
    function, which is the CloudFormation stack it is pointing to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions and events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions are the properties that are defined within the service, and they
    are defined within the `serverless.yml`, so we name the function and provide the
    handler property to the function, and this property points to the function file,
    which could be Node.js or Python. We can add multiple functions within the property.
    The functions can inherit the properties from the provider or we can define the
    properties at function level. These function properties vary as per the cloud
    provider, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The functions can be listed as arrays if we create a separate file for each
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'An environment object property can also be added to the function within the
    service, and it should be a key–pair value. Also, the function-specific environment
    variable overrides the provider-specific environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Events are things that trigger the function, such as the S3 bucket upload.
    There are multiple events supported by Serverless Framework, but they vary as
    per the cloud provider. We can define multiple events for a single function, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The types of events provided for AWS Lambda by Serverless Framework are shown
    at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://serverless.com/framework/docs/providers/aws/events/](https://serverless.com/framework/docs/providers/aws/events/)'
  prefs: []
  type: TYPE_NORMAL
- en: Variables and plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Variables** are the values that can be passed to the configuration values
    within the `serverless.yml` while running the Serverless Framework command. They
    need to pass reference values enclosed in `${}` brackets, but you can use variables
    in property values rather than in the property keys. The following code shows
    how this is added in the `serverless.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following statement, we pass the parameter to the CLI and the `stage`
    value is populated in the `serverless.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The variables can be used recursively as reference properties—that is, we can
    combine multiple values and variable sources, as shown in the following environment
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can reference environment variables as well (as shown in the following code),
    but it is insecure to add sensitive data to environment variables, because they
    can be accessed through build logs or in the serverless CloudFormation templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at a few tutorials for doing this. Make sure that you have the
    latest Serverless Framework installed and working:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a simple `hello` project with the Serverless AWS template, then open
    this project in your favorite editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `serverless.yml` file and handler, as shown in the following code.
    Here, we are adding an environment variable by the name of `MY_VAR`, and in the
    handler, we display the environment variable in the message output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s invoke locally and look at the result. If you look in the message section,
    you can see the value of the environment variable that we defined, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As we discussed earlier for nonsensitive data, adding a variable into the `serverless.yml`
    file should be fine, but how do we add sensitive data into an environment variable,
    like a database connection. Let''s look into the steps needed to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file in the `env-variable-service` folder and name it **`serverless.env.yml`**.
    Then add the following details into it, as shown in the following code. Here,
    we are creating a secret variable as per the environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add one more environment variable in the `serverless.yml` file, but
    this time the value will be pulled from the file, so you need to add the highlighted
    line as the environment variable. This way, Serverless Framework will read through
    the file and refer it to the specific environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s change the response of the handler to display the secret through the
    message. Ideally, we should be displaying the secret over the screen, but for
    this tutorial, I am doing it manually.  So let''s replace the message body with
    the one displayed in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke the function locally and look at the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, like I said, we can have multiple environment variables for each deployment
    stage, such as `dev`, `sit`,`uat`, and `prod`. The following steps show us how
    we can add them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add one more environment variable for `prod` to the `serverless.env.yml` file.
    Then, we can use them dynamically within the `serverless.yml` file, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to makes changes to the `serverless.yml` file to dynamically pick
    up the environment variable on the basis of the stage that we set at the time
    of the invocation or deployment of the function, which is the replacement of the
    `MYSECRET_VAR` line with the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now invoke the function locally and look at the output for a different
    stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'I have uploaded the preceding tutorials into the following GitHub repository
    as well, so you can use them at your leisure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/shzshi/env-variable-service.git](https://github.com/shzshi/env-variable-service.git)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The plugins are custom JavaScript code that provide extension to existing CLI
    commands within Serverless Framework. The framework itself is a group of plugins
    that is provided in the core. We can build our own custom plugin; Serverless Framework
    provides documentation for this plugin as well. The plugin can be installed using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to call them within the `serverless` service, using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'A list of existing Serverless plugins can be found at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/serverless/plugins](https://github.com/serverless/plugins)'
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we create Lambda functions, they might be dependent on many different
    types of infrastructure resources, such as AWS, DynamoDB or AWS S3, so we can
    define these resources within the `serverless.yml` file and deploy them. When
    we add these resources, they get added to the `serverless.yml` file, and when
    they are deployed, they get added to the CloudFormation stack and are executed
    at serverless deploy.We can look at the following example to see how these resources
    are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can refer to the following link for more details on resources and to see
    which resources are available using only AWS Lambda: [https://serverless.com/framework/docs/providers/aws/guide/resources/](https://serverless.com/framework/docs/providers/aws/guide/resources/)
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a simple example of Serverless Framework using AWS Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need the following prerequisites for this:'
  prefs: []
  type: TYPE_NORMAL
- en: A free AWS account needs to be created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nodejs 4.0 and higher must be installed on the local machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CLI can also be installed, but this is optional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up AWS access keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the AWS account and go to the IAM (Identity & Access Management) page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Users on the left-hand side bar, then click on the Add User button and
    add the username `adm-serverless`. Then enable programmatic accessby clicking
    the checkbox. Then click on the Next:Premissionsbutton.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On this page, select Attach existing policies directly, search for and select
    the AdministratorAccess checkbox, then click on Next:Review.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now check whether everything is good, then click Create User. This will create
    a user and show us the access key IDand secret access key. Copy and store these
    keys somewhere, temporarily.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have the keys, we export them as an environment variable so that
    they will be accessed by the framework to perform their required function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Installation of Serverless Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Node.js 4.0 or higher from [https://nodejs.org/en/download/](https://nodejs.org/en/download/) .
    Once installed, we can verify installation through the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to install Serverless Framework globally through the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed successfully, we can verify the installation by using the following
    command. It will show all the framework commands and documentation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also see the version of Serverless Framework installed by using the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Lambda service and function deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following step, we will be create a simple Node.js service and Lambda
    function, and then deploy and invoke them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new service using the Node.js template by Serverless Framework. We
    need to make sure that the name is unique and add the path to the service, which
    is optional. This command will create two files—`handler.js` and `serverless.yml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: A service is the framework's unit of organization. It can be considered as a
    project file. It's where we can define functions, the events that trigger them,
    and the resources of the function that we will use. All of these are placed into
    one file `serverless.yml`. In this `.yaml` file, we define the service called `my-serverless-service`. Then
    we define the provider; as I mentioned earlier, Serverless Framework supports
    a lot of other cloud service providers. We can list the provider details in this
    tag and also mention the runtime, which in our case is Node.js. The runtime will
    change depending on the language we use to write the function. We can define the
    environment or stage we are deploying to—which in our case is `dev`—as well as
    the respective region. Then, in the `functions` section, we define the function
    name—which in our case is `hello`—which has an attribute called `handler`, and
    this handler will call the `handler.js` file. We can also define the memory size.
    Next, I have added an HTTP event, which, in addition to the Lambda function, provisions
    the AWS API Gateway. It will create and provide an endpoint for the handler. So,
    using one script, we can provision a Lambda function and an API endpoint. We can
    define various other attributes and parameters; we will look into these in more
    detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please make sure the `.yaml` files are properly indented, otherwise they will
    fail. You can also use the one that I have put on the following GitHub link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/shzshi/my-serverless-service.git](https://github.com/shzshi/my-serverless-service.git)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `handler.js` code phrase is the Node.js Lambda function for `Hello, World!`,
    which is referenced in the `serverless.yml` file. It is a pretty simple function
    that will just display the message `My Serverless World` on execution, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Invoking locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pushing the code to AWS Lambda and testing every time would be expensive and
    time consuming. So with Serverless Framework, we can invoke or test functions
    locally and then deploy them to the cloud. We can have this as part of the continuous
    deployment pipeline, where we can set the local invocation for `dev` stage deployment,
    set up automated testing, and then move them further down the pipeline to deploy
    and test remotely. The following command is used to invoke the function locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Deploying and invoking locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we are now able to successfully invoke and test the function locally, we
    should be fine to deploy and test it remotely. First, we need to make sure that
    we have retrieved and exported the access and secret access keys as environment
    variables, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now I am deploying the function and API to the AWS Cloud through a simple `deploy`
    command. Behind the scenes, the deployment process will create a `.serverless`
    folder with `CloudFormation` JSON templates. The serverless code is packaged into
    a `.zip` file and a serverless state JSON file. If we look into the `create-stack`
    JSON template, Serverless Framework will create an S3 bucket on the AWS Cloud
    and deploy the function and API package on to the bucket with the `CloudFormation`
    template JSON file. It will also keep the state of the deployment in the form
    of a JSON file. The successful deployment will provision an API endpoint that
    is tied to an AWS Lambda function and creates a service as mentioned in the provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Postdeployment, we will go to the AWS portal and see whether the function is
    deployed. Then we will invoke it through the portal and then again invoke the
    remote function through the serverless CLI, using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the AWS portal, then select the correct region where the function
    and API was deployed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the service as Lambda. The Lambda portal page will show the function
    name deployed. Select the function that you test using the radio button, then
    go to the drop-down marked Actions and select the option marked Test. The window
    will pop up to configure the event. You can add your own event or keep the default,
    and then click on Save. The event will be saved and the page will be redirected
    to the Function page. Now click on the Test button. The function will be executed,
    and the execution status and results will be displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As I mentioned earlier, we can invoke the remote function locally as well.
    We will now look at the various commands for the remote Lambda function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To invoke the function and get the logs, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To just get the logs for the previous invocation, enter the following code.
    We can do this in a separate console to test the working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will undeploy the function from the Lambda and also remove the
    package details from the S3 bucket. Once `serverless remove` runs successfully
    (as shown in the following code), you can log in to the AWS portal and check the
    S3 bucket and the Lambda function for the specific region—it should be removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about different frameworks, such as ClaudiaJS, Zappa,
    and Apex. We also looked into a few examples of using them, but we mostly covered
    Serverless Framework extensively. We will be using Serverless Framework extensively
    in most of our tutorials while going through the book, because Serverless Framework
    fairs far better than other frameworks because it has better community support
    and support for multiple cloud providers. This means that you don't have vendor
    locking, as you do with some other frameworks. It also has a huge list of plugins
    for different types of cloud service, good blog support, and finally, some really
    good features for easy deployment into various different cloud providers.
  prefs: []
  type: TYPE_NORMAL
