- en: DevOps with Azure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft Azure is the number two cloud service provider, just behind AWS. But,
    until 2015, they hadn't provided API services, but they were excelling in other
    cloud services like AWS and Google Cloud Functions. Then, eventually, they decided
    to invest in functions. So, Azure Functions is the answer to AWS Lambda, but the
    underlying technology is different, which we will cover in upcoming chapters.
    Azure Functions sit on top of the Azure app service and WebJobs SDK. Azure Functions
    support a lot of languages like F#, Python, Batch, PHP, and PowerShell, but C#
    and Node.js are officially supported. We will be using Node.js for all our tutorials
    throughout this chapter and more details on the Azure Functions can be found on
    Microsoft link: [https:/ / msdn. microsoft. com/ en- us/ magazine/ mt793269\.
    aspx](https:/%20/%20msdn.%20microsoft.%20com/%20en-%20us/%20magazine/%20mt793269.%20aspx).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple Azure function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration and continuous delivery with Azure Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous deployment to Azure Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blue green deployment in Azure Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring and logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a simple Azure function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will first try to create a simple Azure function through the portal and then
    we will automate the build and deployment process using S tools and framework.
    So, to start playing with Azure Functions, we need to create an Azure Cloud service
    account first. Microsoft provides one month of free subscription and we will be
    using the Node.js scripts for all the DevOps-related examples and demos.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Cloud account creation
  prefs: []
  type: TYPE_NORMAL
- en: '[https://azure.microsoft.com/free/?ref=microsoft.com&utm_source=microsoft.com&utm_medium=docs&utm_campaign=visualstudio](https://azure.microsoft.com/free/?ref=microsoft.com&utm_source=microsoft.com&utm_medium=docs&utm_campaign=visualstudio)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the account is created, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Log into the Azure portal (Azure portal: [https://portal.azure.com/](https://portal.azure.com/)).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On successful login, we will be redirected to the homepage of the Azure portal.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to create resources for Azure Function. So let's click on the button
    Create a Resource, which will take us to the Azure marketplace page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we need to create a Compute by clicking on the link Compute within the
    Azure marketplace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we can go ahead to create a function through the link Function App (which
    will open a new window where we have to feed details for the Function App.).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot gives us the details of how we move through the screen
    while creating a simple Azure Function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c306dcf6-46cf-4872-9eda-f48a31e022ef.png)'
  prefs: []
  type: TYPE_IMG
- en: After clicking the link, a page will open on which we need to feed in details
    about the Function App. So let's name it `mySampleAppName`. The Function App name
    must be unique, because the Azure Function does not allow a duplicate app name
    across the Azure Cloud. On acceptance of the app name, we will see a green tick
    mark on the App name column. Then we will add Subscription, Resource Group (we
    can use the default value or add an existing resource group), OS , Hosting Plan,
    Storage (we can create new storage or use the existing one).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s keep the other details as default and create a Function App:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a88e694c-6a49-409d-bcd0-c615dc3a3a09.png)'
  prefs: []
  type: TYPE_IMG
- en: This will create a Function App, where the function will be residing. After
    successful creation of the Function App, if you click on **All Resources**,youshould
    be able to see the Function App. We will go ahead and create the application,
    then Azure will create resources for the function which is a storage account and
    Function App.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now go to **Function Apps** and, on the right-hand side at the Function
    App tab, we should be able to see our function. Let''s click on it and hover the
    mouse and we should see **+**. We can create a new function by clicking on the
    +; we can only see + after hovering over the Functions tab. This will open a tab
    on the right-hand side which will provide multiple options to create an Azure
    Function. We will go ahead and choose Scenario as our **Webhook + API **and JavaScript as
    our language, and then click on **Create this function**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b8bf1b8f-ac14-422b-a800-511130384f61.png)'
  prefs: []
  type: TYPE_IMG
- en: At the click of the button, a UI will open with an embedded sample Node.js function
    in it. We can run the same Azure Function to check how it performs.
  prefs: []
  type: TYPE_NORMAL
- en: We can run the function with two methods, one is the POST method and another
    is the GET method. By default, the function runs with the POST method. So let's
    click on the **Run** button. In the next window, replace **Request Body **with
    the JSON value and click on **Run again**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the POST method, let''s add the following JSON details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Run will trigger the function and display the output in the request body, as
    displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2eca40b-52d4-48f0-adb1-00441742dd9b.png)'
  prefs: []
  type: TYPE_IMG
- en: And, as we change the **HTTP method** to GET,we need to feed in a query parameter.
    To do this, click on **+ Add Parameter** in Query and fill in the key as **name**
    and value as **DevOps **and then click on **Run**.After the successful execution
    of this, we can see the output log in the log window as **Hello DevOps. **
  prefs: []
  type: TYPE_NORMAL
- en: So, in the previous tutorial, we learned how to create a simple hello world
    azure function and execute the same with the POST and GET methods. In further
    chapters, we will looking at how to automate the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing continuous integration and continuous delivery with Azure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created a simple application through the Azure portal, the
    next question is how do we add a multiple number of functions, source code them
    and set up automated build and deployment. We do this, of course, through DevOps
    and automation. Let's start with continuous integration. As we know, continuous
    integration is an integral part of DevOps, where an application is integrated
    to work as one unit. We have to achieve the continuous integration, automated
    testing and continuous deployment for Azure Functions through automation.
  prefs: []
  type: TYPE_NORMAL
- en: To start, we will first create an assembly line. The assembly line starts with
    a code repository like GitHub or SVN and concludes with production deployment.
    Everything within this has to be automated with almost minimal manual intervention
    through a pipeline. We will be covering pipelines in detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve continuous integration, we need to start with pushing the code into
    the GitHub repository. The developer should start building the application by
    creating a featured branch for building each piece of a functions module, then
    all the featured branches should be reviewed and merged to develop branch and
    finally to master branch for clean code building. All the featured branches should
    go through a continuous integration process , that is, a functions code will go
    through unit testing , state code analysis and various other testing in an automated
    way. Then code from the featured branch should be merged into the master. The
    master branch is used to build and deploy to a UAT or OAT environment, where performance
    testing should be performed and further deployed into production.
  prefs: []
  type: TYPE_NORMAL
- en: The continuous delivery process kicks in at the moment the developer checks
    in code into the local or featured branch. The automated build will be triggered,
    which is followed by unit testing and integration testing. Even though the code
    is very well tested, it still needs to be tested for usability and acceptance
    testing. So, a successful exit from the continuous integration process will trigger
    a continuous delivery process and delivery to QA staging. The QA environment normally
    resembles a production environment. This is where automated and manual acceptance
    testing kicks in. Having continuous delivery in place, we should be able to release
    the environment daily, weekly or fortnightly, or whatever suits the business requirement.
    But we should be able to deploy to production without much effort or manual deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example which follows the continuous integration and delivery.
    In this example, we will be using open source DevOps tools to actually test and
    deploy the application on the Azure Cloud. We need tools like Jenkins, which is
    a popular open source orchestration tool, and the serverless framework which we
    used for AWS deployment, and the Node.js module for unit testing the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For my feasibility, I have used Docker for setting up the Jenkins instance
    with Node.js and npm installed on it. I have pushed the Dockerfile for this on
    the Git repository where all the example files reside on the GitHub link below,
    and also my tutorials are built on Linux: [https://github.com/shzshi/azure-helloworld-ci.git](https://github.com/shzshi/azure-helloworld-ci.git)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using the Dockerfile from the Git repository, then make sure Docker
    is installed on your laptop/PC. We will first clone the previous mentioned Git
    repository and build the Docker image with jenkins, serverless framework, and
    all the required dependencies for Azure Functions deployment, with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run the Docker container with the following command, this will create
    a container with Jenkins, Node.js 8.9, Serverless Framework 2.5 and npm 5.6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you already have Jenkins set up, then make sure you have Node.js 8.9, npm
    5.6, and serverless framework 2.5 installed on the server for the previous example
    to work.
  prefs: []
  type: TYPE_NORMAL
- en: Once Jenkins is up and running, we will create a job in Jenkins which will run
    the unit test and then deploy the Azure Function through a serverless framework
    to the Azure Cloud. Once successfully deployed, we will invoke the function through
    a serverless framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following steps in order:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the screenshot of the Jenkins homepage. We will create a new
    job, so click on the link New Item and create a new job:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c277d547-bf8b-4020-b284-389063b6bef7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a job name, whatever suits, and select Freestyle project and submit
    OK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cd91530d-4403-4866-a099-385c0dc43c97.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then we will redirect to the configure page for the job, where we will add
    the Git repository for cloning, click on the **Source Code Management** tab, and
    add details in the Git repository as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1490dd3e-1d32-4672-85cf-74c2ed53bfa2.png)'
  prefs: []
  type: TYPE_IMG
- en: Then click the **Build** tab and create an execute shell, and, through the **Add
    build step** drop-down menu, we add `npm install` to install the required Node.js
    modules from the internet, and then run the Node.js test, which will unit test
    the Azure library function and give us the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can add many unit tests to test our function, before deploying it to Azure
    Cloud, to make sure the app is unit tested before it goes on to the cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73314152-0c4e-4a49-a6a4-e9b91ced140c.png)'
  prefs: []
  type: TYPE_IMG
- en: Make sure you have the Publish HTML report plugin already installed through
    steps **Jenkins Home** | **Manage Jenkins** | **Manage Plugins**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we run the preceding job, then a unit test is performed and the report
    is generated for the unit test, which we can view by configuring post-build action.
    So, let''s click on the **Post-build Actions** tab, then click on the dropdown
    **Add post-build action** and select **Publish HTML reports**, click on **Add**
    and then configure it as per the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1579513f-2027-4f7c-b842-4f6de84343a9.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Save** the job and run the build. Once the job has built successfully, we
    should be able to view the code coverage HTML view, from the job''s homepage.
    The coverage will look like the following screenshot, which should give us a good
    view of how our unit test has performed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2052f9b0-1da3-45a0-a3df-4d91c32e8a3d.png)'
  prefs: []
  type: TYPE_IMG
- en: In the previous section, we unit tested our function and looked at coverage
    of the function. Next we will configure deployment onto the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration with Azure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, moving on to deploying to Azure Cloud Functions, we will be using a serverless
    framework. The framework will be doing all the heavy lifting, but it needs a few
    pre-requisites to make it work. They are: **serverless-azure-functions **and **cli
    az login** to get the required credentials and account details. Please use the
    following steps to do this in the pre-requisites section:'
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can install `serverless-azure-functions` through the npm. The following
    command will install the latest version of the plugin, but if you are using the
    docker image which is created above, it already has the plugin added to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'But, to interface with the Azure platform, we need to set up Azure subscription
    credentials locally.  For the `serverless-azure-functions` plugin to work we need
    to set up a service principal, which can done through the Azure portal URL as
    seen in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-create-service-principal-portal](https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-create-service-principal-portal)'
  prefs: []
  type: TYPE_NORMAL
- en: 'However,  if you are using PowerShell cmdlets, then use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-authenticate-service-principal](https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-authenticate-service-principal)'
  prefs: []
  type: TYPE_NORMAL
- en: 'I will be using CLI for our tutorial , but you are free to use whichever fits
    best.  or through Azure CLI , Please follow the given steps to get the Azure CLI
    locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can use the Azure Cloud Shell, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/cloud-shell/overview](https://docs.microsoft.com/en-us/azure/cloud-shell/overview)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the Azure CLI is successfully installed we should be able to access `login` by
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command  will prompt us to visit `https://aka.ms/devicelogin`
    and provide us with a code and with Azure identity. We will then be able to access
    our account through the CLI. We will be provided with account details like the
    following one on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to get subscription details through the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to create a service principal. We can do this by running the
    following command. It will provide us with a JSON object that we will need to
    authenticate with Azure Cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: And the last pre-requisite we need is for an **EnvInject **plugin to be installed
    in Jenkins to mask the Azure credentials. So please make sure that it is added.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we create environment variables with subscription ID, tenant, name,
    and password. We need to export this on the Jenkins node and set up a deployment.
    So let''s do that:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Jenkins in browser and add a new job with a click on **New Item**.
    Enter the item name **myAzureFunctionDeploy **and select **Freestyle project**,and
    click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the job configuration page, tick **This project is parameterised **and add
    **Password Parameter** below the name and default values retrieved from the Azure
    commands as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let's click on the **Source Code Management** tab and add the repository URL
    as [https://github.com/shzshi/azure-helloworld-ci.git](https://github.com/shzshi/azure-helloworld-ci.git),
    the repository has the required files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Build Environment** select **Inject passwords to the build as environment**
    **variables**. We are doing this to mask the Azure credentials and other details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on the **Build** tab and, in the execute shell, add the steps mentioned
    in the following example, and then click on **Save. **
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s click on **Build with parameters**.Then click on **Build **the job will
    build, create a package and deploy the functions onto the Azure portal. We can
    test the function on the cloud. Once the function is deployed we can invoke or
    run through a serverless command prompt. We can integrate this in smoke testing
    or functional testing, so we test the running of the function in actuality through
    command line or adding the same line into Jenkins job, as seen in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also stream the logs of the function, to check how functions got deployed,
    or how it performed while it ran:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can change the code in the source code repository and run these commands
    individually, or through orchestrating tools like Jenkins to perform perfect continuous
    integration and continuous delivery.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can integrate removal of the function from the Azure Function through the
    following command. This can be integrated within the Jenkins pipeline to undeploy
    or to rollback the function to a previous version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Continuous deployment to Azure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous deployment** means that every code we commit should go through
    an automated unit, integration, and performance testing, and also go through an
    automated source code analysis and be successfully deployed all the way to production
    without manual intervention. But, in some cases we should be able to roll back
    the deployment because of some bugs or issues in the production. Rollback can
    be automated, but usually rollback is done manually. We can set up a continuous
    delivery pipeline through the Azure portal. Let''s set up a simple continuous
    delivery pipeline. Azure Cloud has an out-of-the-box feature to set up a pipeline
    for Azure Function. It integrates with a good number of source code managements,
    such as Git, GitHub, Bitbucket, Visual Studio team services, and a few others.
    The continuous deployment is set up on a per function app basis and also a function
    code can be maintained through a source repository, and the code within the portal
    becomes read only. So, the moment the code is updated and committed into the source
    code repository, the function code is automatically built and deployed on the
    portal.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a continuous deployment Azure deployment tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here we will demonstrate to how to set up continuous delivery with a GitHub
    repository through the Azure portal:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Log into the Azure portal ([https://portal.azure.com](https://portal.azure.com)).
    On successful login click on the All resourceslink. We should be able to see the
    Function App created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dfaa8e44-2324-4872-b672-0a33cced3a1a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the app for which we need to set up the continuous deployment, as per
    my example. I will pick up **azure-helloword-ci** which takes me to the function
    apps windows. Then, on the function apps windows, we will select Platform features on
    the top right hand side tab and then click on Deployment options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7dfa0eac-c4ef-4686-b0fc-35a54c574271.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, in the deployment section, click on setup. Then another window will slide,
    with the heading Deployment option. Click on the link Choose source, then in the
    next window, we will see options to add the Source control. Let's select GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we will get options to configure GitHub repositories where we will be asked
    to authorize Azure Functions to access our private or public repositories.  Please
    make sure you use your own account's public repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once configured, we need to select the repository where we have to fill in choose
    source, authorization, choose your organization, choose project repository, branch
    and can configure performance test. We will be taken to the GitHub portal to put
    in our GitHub credentials to connect to the GitHub repository. After that, once
    we click OK, the repository will be configured with Azure Function and all the
    file changes in the GitHub are copied to the function app and a full site deployment
    is triggered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can set up performance testing with the button **Configure Performance Test**.
    We can create multiple environments by creating different branches, and by merging
    the code to the master branch for production deployment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Blue-green deployment in Azure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are multiple deployment patterns in DevOps: canary deployment and blue
    green deployments. We will be talking about blue green deployment for Azure Functions
    in this book. Blue green deployment technique reduces the downtime and risk by
    having two identical production environments with the names blue and green. One
    environment will go live whilst the other is used for staging new changes. And
    there is workflow designed to switch between live and staging. Initially, a new
    version of the application is deployed to the blue environment with all the user
    traffic being redirected to the blue environment. After the next version of application
    has been developed, it is deployed to a staging environment (green) for testing.
    After the testing of the new version of the software is considered satisfactory,
    then all the traffic is redirected to the green environment and is considered
    as live.'
  prefs: []
  type: TYPE_NORMAL
- en: The deployment dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The development team always need to keep track of deployment and the health
    of the development pipeline. It also needs to know the track of deployment failure,
    the number of releases done, the number of check-ins, and many other metrics which
    are very important for the development cycle.  There is one open source which
    can help to track all these details and it is Hygieia. Hygieia is an open source
    tool available for a holistic view on the single screen for tracking build, deployment,
    quality control, and application performance. It also helps to track deployment
    versions, and also the health of the application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hygieia** is a DevOps dashboard tool, developed by Capital One, and the company
    has open-sourced the tool.'
  prefs: []
  type: TYPE_NORMAL
- en: The Hygieia dashboard has two views, one is a widget and other is a pipeline.
    The widget view displays information about features in the current sprint, code
    contribution activities, continuous integration activities, code analysis, security
    analysis, unit and functional test results, deployment, and environment status.
    The pipeline view has components of the deployment life cycle which show progression
    through development, Int, QA, performance, and production. Hygieia also has product
    dashboard which displays a collaborative dashboard for multiple applications within
    each product.
  prefs: []
  type: TYPE_NORMAL
- en: Hygieia has lots of plugins which integrate or get the logs from many DevOps
    tools like Jira, Subversion, Jenkins, Sonar, IBM UrbanCode Deploy and, as Hygieia
    is an open source, we can build our own plugin and widget for the Hygieia.
  prefs: []
  type: TYPE_NORMAL
- en: Out of the box, the Hygieia dashboard application integrates with VersionOne,
    Jira, Subversion, GitHub, Hudson/Jenkins, Sonar, HP Fortify, Cucumber/Selenium
    and IBM Urbancode Deploy.
  prefs: []
  type: TYPE_NORMAL
- en: Hygieia is built on Java and plugins run through a Java command line. We can
    set up a whole Hygieia dashboard over the docker containers. Please follow the
    link for setup and integration: [https://github.com/capitalone/Hygieia](https://github.com/capitalone/Hygieia).
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring and logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serverless applications help speed up development and independence and allow
    the execution which triggers events, but when these function do not work as expected,
    how do we verify that events are activating the right functions? With serverless
    applications, the root cause analysis becomes more complicated, because services
    are small and their functionality is very precise. While trying to track down
    the fault source, neither the services involved nor any of the integration points
    actually exist, and when there is more than one function which takes part in the
    operation, the investigation becomes very difficult.
  prefs: []
  type: TYPE_NORMAL
- en: That is where the logs plays a vital role, but there are some unique considerations
    which need to be taken into account when logging into a serverless architecture.
  prefs: []
  type: TYPE_NORMAL
- en: And it is normal for several functions to fail and not to deliver the requested
    functionality, or for the logs contain a unified identifier for the transaction,
    so when function logs are analysed, the transaction failure can be detected easily
    and the failure problem can be fixed.
  prefs: []
  type: TYPE_NORMAL
- en: In Azure Functions we can get logs in many ways. The easiest way is to log in
    to the Azure portal, go to the respective function and select the Monitor tab. Here
    we will see a list of function invocations, their status, and last run with duration. If
    we select the invocation that has failed, then, on the right-hand side, we can
    see the exact log and other required information.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing logs through Kudu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can access the logs through Kudu. Kudu was developed to access the Microsoft
    Azure web apps environment. As Azure Function runs on a web app, we can use Kudu
    to access the logs of the Azure Functions. Kudu can access environment information,
    and also details of the actual filesystem which is attached to the function while
    running.
  prefs: []
  type: TYPE_NORMAL
- en: Kudu can be accessed through a web browser. The link for the same would be [https://myAzureFunction.scm.azurewebsites.net](https://myAzureFunction.scm.azurewebsites.net/). We
    have to replace the `myAzureFunction` with our web app name. The best part of
    Kudu, is that it will give us the actual file system access of our function environment,
    either through shell or through browsing, which makes it easier to get to root
    cause of the failure.
  prefs: []
  type: TYPE_NORMAL
- en: Logging information via table storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All logging and timing information of the function is stored in the storage
    account that we created earlier while creating our function app. We can access
    the log through Visual Studio if we have Azure SDK installed. We can also access
    the logs through  Cloud Explorer Window.  (If you have multiple Azure Function
    apps then it might be a bit tricky to remember which one belongs to which function
    app, but you can discover that by looking in your Application Settings at the
    contents of the `AzureWebJobsStorage` setting).
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the Azure Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Monitoring the function is essential. It will give a good view of how our function
    or app is performing with traffic and also when it scales and descales. Azure
    Function has built-in integration with Azure application insight.  Application
    insightis built in an APM (application performance management) service by Azure.
    We can configure application insight during the creation of a function app and send
    the telemetric data to Application Insights. Create a new function app and set
    the Application Insights switch On and the Application Insights Location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a704ec70-de78-4ace-9231-45ea43d6be50.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see the performance graph in the Metrics Explorer of the Azure Cloud
    portal to monitor the function health:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed017e46-6087-4837-b7ab-f97fb2644e1c.png)'
  prefs: []
  type: TYPE_IMG
- en: Integrating with New Relic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'New Relic provides integration for Azure Function that does the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Reports data from Azure Functions to New Relic products.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reports metric data, like the count of functions executed, bytes sent and received,
    and HTTP errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collects inventory data about the status and configuration of the service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can monitor and alert on your Azure Functions data from New Relic, and you
    can create custom queries and chart dashboards.
  prefs: []
  type: TYPE_NORMAL
- en: To activate the Azure Functions integration, follow the Azure Integration Activation
    through the link: [https://docs.newrelic.com/docs/integrations/microsoft-azure-integrations/getting-started/activate-azure-integrations](https://docs.newrelic.com/docs/integrations/microsoft-azure-integrations/getting-started/activate-azure-integrations).
  prefs: []
  type: TYPE_NORMAL
- en: Best practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'DevOps for serverless is pretty young and evolving. Serverless itself is emerging
    at a fast pace, and, within that framework, to automate deployment and integration
    with other DevOps, it is changing faster. Talking about best practice for smooth
    code deployment from development to production, we need to look at various tenants
    of DevOps for Azure Function and learn from the mistakes during implementation.
    But because serverless is still evolving, and DevOps with serverless is still
    niche, we would not be able to highlight every aspect of DevOps. However,  we
    will look at some of the main tenants and talk about them in detail here. So the
    main tenant for DevOps with serverless are: source code management, build, deployment,
    release management, monitoring, and logging, which is almost the same as application.
    But because serverless are micro services, there is bit of a change when we apply
    DevOps to it. So let''s look at each aspect of it and learn the best way of applying
    DevOps to the Azure Functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Source code management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developers write the code and work together to perform a task, but developers
    keep adding to the new features, or they update the code to perform better, or
    to enhance the functionality. This is why we need source code management. Git
    is one of most popular source code management tools available. So we have to set
    up various strategies for efficient management of the code. But before that we
    need to set up a folder structure for Azure Function.
  prefs: []
  type: TYPE_NORMAL
- en: Folder structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the functions codes of a specific function app would be located in the
    root folder with one or many subfolders and a host configuration file. The `host.json`
    file will contain runtime specific configurations. And each function folder will
    have one or more code files, `function.json`, configurations, and other function
    dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: With the folder structure we need to apply the best method of branching strategy
    for robust development and smooth deployment. The best practice is to have multiple
    branches with a master, which is a default branch, for easy development, and future
    easy release into production. Those branches are feature, develop, release, and hot
    fixes branches.
  prefs: []
  type: TYPE_NORMAL
- en: The feature branch helps easy tracking of a feature, as well as aiding parallel
    development between team members. A feature branch might branch from a develop
    branch, but should always merge back to a develop branch. The next main branch
    would be a develop branch and this branch lives through the life cycle of project
    development and support. When the source code from a develop branch is stable,
    then it is merged back to the master branch, after successful release, and every
    merge to the master will trigger a production release.
  prefs: []
  type: TYPE_NORMAL
- en: A release branch may be from a develop branch, but they must merge back to the
    develop and master branches. The release branch is used for preparation of new
    production release. The release branch is used for next big release. It provides
    with us room for minor bug fixes, and for setting up meta data for release. When
    the release branch is ready to be a real release then we need to make sure it
    is merged with the master and the commit must be tagged for future historical
    versions. Finally, the release branch should be merged with the develop branch,
    so that we get all the changes of this release in future releases.
  prefs: []
  type: TYPE_NORMAL
- en: Last of all is the hotfix branch. This is almost the same as the release branch,
    as it helps us in production release. Hotfix is actually useful when production
    deployment fails and you need to hotfix production, so that we can get it back
    live. So to resolve the production failure, we branch hotfix branch off a production
    tag from the master branch, so that one team can fix the production failure and rest
    of the team can continue development on the develop branch. The rule of thumb
    is that the hotfix branch might branch from a master and then, once hotfix is
    successful, the changes are merged back to the master. They also need to merge
    to the develop branch, to make sure we have these hotfix changes in future releases.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and static code analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is an essential part of development, it is must when we develop any
    application. It helps to mitigate most of the bugs and performance issues before
    going to production. There are many types of testing involved in application development.
    These include, unit testing, integration testing and performance testing. They
    integrated into different stages of the environment deployment. Unit testing is
    integrated in the development stage.
  prefs: []
  type: TYPE_NORMAL
- en: The serverless handler should always be a thin layer that uses modules out of
    your code library. And modules should be well-covered with unit tests; then testing
    of the serverless application will be easy during the integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: We should try to run unit tests and integration test the modules and function
    locally, this will help to run the tests faster, and find issues in code base
    easily, and without deploying to cloud. We should run them remotely as well, because
    remote infrastructure is a bit different from local infrastructure. We can achieve
    both by setting up a pipeline and staging them as different environments (development,
    stage, user acceptance testing, pre-production and production), where development
    and stage testing should be invoked locally, and same testing with better performance
    is tested remotely on the rest of the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Static code analysis is the process of analyzing source code to flag programming
    errors, bugs, stylistic errors, and suspicious constructs. We have to make sure
    we have to integrate linting tool for serverless function in the pipeline stage.
    This helps to keep the code clean, less buggy and perfectly indented.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment and release
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are various types of deployment pattern, but we should select one which
    fits our case, and which uses all the functions together in one go: blue-green
    and canaries, and also lots of complexities, such as redundancy, high availability,
    rollback, A/B testing and incremental roll outs. All these need to be considered
    during deployment, and deployment should be achieved with ease and flexibility.
    So it should always be better to decide on the pattern before starting the automation.'
  prefs: []
  type: TYPE_NORMAL
- en: We have to make sure deployment is constantly monitored and deployment failures
    are analysed and improved with time. All the deployment should be triggered through
    automated pipelines with minimal manual intervention, attached to a GitHub repository,
    with strict branching strategy. We can also package the function app and upload
    into Nexus to set up easier roll back. All the deployment should have a feedback
    loop all the way to project tracking tools like JIRA/rally. This will make it
    easier to trace the failure.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To summarize, we covered continuous integration, continuous deployment, logging,
    and monitoring of Azure Functions and also fleshed out best practices around how
    to manage the Azure Functions in a source code repository, the importance of testing
    and automated deployment. Serverless or functions with Azure Cloud are still an
    early development but improving as each day passes. There is still lots to achieve
    in terms of adoption and improvement. But once adoption of serverless grows, DevOps
    practices around it will improve and become robust. In the next chapter, we will
    learn how to apply DevOps to OpenWhisk, another serverless provider.
  prefs: []
  type: TYPE_NORMAL
