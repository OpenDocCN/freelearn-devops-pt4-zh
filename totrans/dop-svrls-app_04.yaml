- en: DevOps with Azure Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Azure Functions 进行 DevOps
- en: Microsoft Azure is the number two cloud service provider, just behind AWS. But,
    until 2015, they hadn't provided API services, but they were excelling in other
    cloud services like AWS and Google Cloud Functions. Then, eventually, they decided
    to invest in functions. So, Azure Functions is the answer to AWS Lambda, but the
    underlying technology is different, which we will cover in upcoming chapters.
    Azure Functions sit on top of the Azure app service and WebJobs SDK. Azure Functions
    support a lot of languages like F#, Python, Batch, PHP, and PowerShell, but C#
    and Node.js are officially supported. We will be using Node.js for all our tutorials
    throughout this chapter and more details on the Azure Functions can be found on
    Microsoft link: [https:/ / msdn. microsoft. com/ en- us/ magazine/ mt793269\.
    aspx](https:/%20/%20msdn.%20microsoft.%20com/%20en-%20us/%20magazine/%20mt793269.%20aspx).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Azure 是全球第二大云服务提供商，仅次于 AWS。但直到 2015 年，他们才提供 API 服务，之前在 AWS 和 Google
    Cloud Functions 等其他云服务领域表现出色。最终，他们决定投资于云函数。所以，Azure Functions 就是 AWS Lambda 的回应，但其底层技术不同，我们将在接下来的章节中详细介绍。Azure
    Functions 基于 Azure 应用服务和 WebJobs SDK。Azure Functions 支持多种语言，如 F#、Python、Batch、PHP
    和 PowerShell，但官方支持的语言是 C# 和 Node.js。我们将在本章节中使用 Node.js 进行所有的教程，并且有关 Azure Functions
    的更多详细信息可以参考微软链接：[https:/ / msdn. microsoft. com/ en- us/ magazine/ mt793269\.
    aspx](https:/%20/%20msdn.%20microsoft.%20com/%20en-%20us/%20magazine/%20mt793269.%20aspx)。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Building a simple Azure function
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个简单的 Azure 函数
- en: Continuous integration and continuous delivery with Azure Functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Azure Functions 进行持续集成和持续交付
- en: Continuous deployment to Azure Functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续部署到 Azure Functions
- en: Blue green deployment in Azure Functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Functions 的蓝绿部署
- en: Monitoring and logging
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控与日志记录
- en: Best practice
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Building a simple Azure function
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个简单的 Azure 函数
- en: We will first try to create a simple Azure function through the portal and then
    we will automate the build and deployment process using S tools and framework.
    So, to start playing with Azure Functions, we need to create an Azure Cloud service
    account first. Microsoft provides one month of free subscription and we will be
    using the Node.js scripts for all the DevOps-related examples and demos.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先尝试通过门户创建一个简单的 Azure 函数，然后使用 S 工具和框架自动化构建和部署过程。所以，为了开始使用 Azure Functions，我们需要首先创建一个
    Azure 云服务账户。微软提供一个月的免费订阅，我们将在所有 DevOps 相关的示例和演示中使用 Node.js 脚本。
- en: Azure Cloud account creation
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 云账户创建
- en: '[https://azure.microsoft.com/free/?ref=microsoft.com&utm_source=microsoft.com&utm_medium=docs&utm_campaign=visualstudio](https://azure.microsoft.com/free/?ref=microsoft.com&utm_source=microsoft.com&utm_medium=docs&utm_campaign=visualstudio)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://azure.microsoft.com/free/?ref=microsoft.com&utm_source=microsoft.com&utm_medium=docs&utm_campaign=visualstudio](https://azure.microsoft.com/free/?ref=microsoft.com&utm_source=microsoft.com&utm_medium=docs&utm_campaign=visualstudio)'
- en: 'Once the account is created, follow these steps:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 创建账户后，按照以下步骤操作：
- en: 'Log into the Azure portal (Azure portal: [https://portal.azure.com/](https://portal.azure.com/)).'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录 Azure 门户（Azure 门户：[https://portal.azure.com/](https://portal.azure.com/)）。
- en: On successful login, we will be redirected to the homepage of the Azure portal.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 登录成功后，我们将被重定向到 Azure 门户的主页。
- en: Now, we need to create resources for Azure Function. So let's click on the button
    Create a Resource, which will take us to the Azure marketplace page.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要为 Azure Function 创建资源。点击“创建资源”按钮，这将把我们带到 Azure 市场页面。
- en: Here, we need to create a Compute by clicking on the link Compute within the
    Azure marketplace.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们需要通过点击 Azure 市场中的 Compute 链接来创建一个计算资源。
- en: Then we can go ahead to create a function through the link Function App (which
    will open a new window where we have to feed details for the Function App.).
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以继续通过点击 Function App 链接来创建一个函数（这会打开一个新窗口，我们需要在其中输入 Function App 的详细信息）。
- en: 'The following screenshot gives us the details of how we move through the screen
    while creating a simple Azure Function:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了在创建简单的 Azure 函数时，我们如何在屏幕中进行操作：
- en: '![](img/c306dcf6-46cf-4872-9eda-f48a31e022ef.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c306dcf6-46cf-4872-9eda-f48a31e022ef.png)'
- en: After clicking the link, a page will open on which we need to feed in details
    about the Function App. So let's name it `mySampleAppName`. The Function App name
    must be unique, because the Azure Function does not allow a duplicate app name
    across the Azure Cloud. On acceptance of the app name, we will see a green tick
    mark on the App name column. Then we will add Subscription, Resource Group (we
    can use the default value or add an existing resource group), OS , Hosting Plan,
    Storage (we can create new storage or use the existing one).
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s keep the other details as default and create a Function App:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a88e694c-6a49-409d-bcd0-c615dc3a3a09.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: This will create a Function App, where the function will be residing. After
    successful creation of the Function App, if you click on **All Resources**,youshould
    be able to see the Function App. We will go ahead and create the application,
    then Azure will create resources for the function which is a storage account and
    Function App.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now go to **Function Apps** and, on the right-hand side at the Function
    App tab, we should be able to see our function. Let''s click on it and hover the
    mouse and we should see **+**. We can create a new function by clicking on the
    +; we can only see + after hovering over the Functions tab. This will open a tab
    on the right-hand side which will provide multiple options to create an Azure
    Function. We will go ahead and choose Scenario as our **Webhook + API **and JavaScript as
    our language, and then click on **Create this function**:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b8bf1b8f-ac14-422b-a800-511130384f61.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: At the click of the button, a UI will open with an embedded sample Node.js function
    in it. We can run the same Azure Function to check how it performs.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: We can run the function with two methods, one is the POST method and another
    is the GET method. By default, the function runs with the POST method. So let's
    click on the **Run** button. In the next window, replace **Request Body **with
    the JSON value and click on **Run again**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'In the POST method, let''s add the following JSON details:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Run will trigger the function and display the output in the request body, as
    displayed in the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2eca40b-52d4-48f0-adb1-00441742dd9b.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: And, as we change the **HTTP method** to GET,we need to feed in a query parameter.
    To do this, click on **+ Add Parameter** in Query and fill in the key as **name**
    and value as **DevOps **and then click on **Run**.After the successful execution
    of this, we can see the output log in the log window as **Hello DevOps. **
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: So, in the previous tutorial, we learned how to create a simple hello world
    azure function and execute the same with the POST and GET methods. In further
    chapters, we will looking at how to automate the deployment.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Implementing continuous integration and continuous delivery with Azure Functions
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created a simple application through the Azure portal, the
    next question is how do we add a multiple number of functions, source code them
    and set up automated build and deployment. We do this, of course, through DevOps
    and automation. Let's start with continuous integration. As we know, continuous
    integration is an integral part of DevOps, where an application is integrated
    to work as one unit. We have to achieve the continuous integration, automated
    testing and continuous deployment for Azure Functions through automation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通过 Azure 门户创建了一个简单的应用程序，接下来的问题是如何添加多个功能、源代码以及设置自动化构建和部署。当然，我们通过 DevOps
    和自动化来完成这些任务。让我们从持续集成开始。正如我们所知，持续集成是 DevOps 的核心部分，在这个过程中，应用程序会集成为一个整体。我们必须通过自动化实现
    Azure Functions 的持续集成、自动化测试和持续部署。
- en: To start, we will first create an assembly line. The assembly line starts with
    a code repository like GitHub or SVN and concludes with production deployment.
    Everything within this has to be automated with almost minimal manual intervention
    through a pipeline. We will be covering pipelines in detail in the next chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一条流水线。流水线从代码仓库（如 GitHub 或 SVN）开始，并以生产部署结束。在此过程中的每一环节都必须通过流水线实现自动化，几乎不需要人工干预。我们将在下一章详细讲解流水线的内容。
- en: To achieve continuous integration, we need to start with pushing the code into
    the GitHub repository. The developer should start building the application by
    creating a featured branch for building each piece of a functions module, then
    all the featured branches should be reviewed and merged to develop branch and
    finally to master branch for clean code building. All the featured branches should
    go through a continuous integration process , that is, a functions code will go
    through unit testing , state code analysis and various other testing in an automated
    way. Then code from the featured branch should be merged into the master. The
    master branch is used to build and deploy to a UAT or OAT environment, where performance
    testing should be performed and further deployed into production.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现持续集成，我们需要从将代码推送到 GitHub 仓库开始。开发人员应通过为每个功能模块创建一个特性分支来开始构建应用程序，然后所有的特性分支应当经过审核并合并到开发分支，最终再合并到主分支，以便进行干净的代码构建。所有的特性分支都应该经历持续集成过程，即，功能代码将通过单元测试、状态代码分析以及各种其他自动化测试。然后，特性分支的代码应当合并到主分支。主分支用于构建并部署到
    UAT 或 OAT 环境，在那里应进行性能测试，之后再进一步部署到生产环境。
- en: The continuous delivery process kicks in at the moment the developer checks
    in code into the local or featured branch. The automated build will be triggered,
    which is followed by unit testing and integration testing. Even though the code
    is very well tested, it still needs to be tested for usability and acceptance
    testing. So, a successful exit from the continuous integration process will trigger
    a continuous delivery process and delivery to QA staging. The QA environment normally
    resembles a production environment. This is where automated and manual acceptance
    testing kicks in. Having continuous delivery in place, we should be able to release
    the environment daily, weekly or fortnightly, or whatever suits the business requirement.
    But we should be able to deploy to production without much effort or manual deployment.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付过程从开发人员将代码提交到本地或特性分支的那一刻开始。自动化构建将被触发，紧接着是单元测试和集成测试。即使代码经过了非常充分的测试，它仍然需要进行可用性和验收测试。因此，成功完成持续集成过程将触发持续交付过程，并将代码交付到
    QA 阶段环境。QA 环境通常类似于生产环境。在这里，自动化和手动验收测试将开始执行。通过实现持续交付，我们应该能够每天、每周或每两周发布环境，或根据业务需求进行调整。但我们应该能够不费力或无需手动部署地将代码部署到生产环境。
- en: Let's look at an example which follows the continuous integration and delivery.
    In this example, we will be using open source DevOps tools to actually test and
    deploy the application on the Azure Cloud. We need tools like Jenkins, which is
    a popular open source orchestration tool, and the serverless framework which we
    used for AWS deployment, and the Node.js module for unit testing the code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个遵循持续集成和交付的示例。在这个示例中，我们将使用开源的 DevOps 工具，实际上在 Azure 云上测试和部署应用程序。我们需要像 Jenkins
    这样的工具，它是一个流行的开源编排工具，还有我们用于 AWS 部署的无服务器框架，以及用于单元测试代码的 Node.js 模块。
- en: 'For my feasibility, I have used Docker for setting up the Jenkins instance
    with Node.js and npm installed on it. I have pushed the Dockerfile for this on
    the Git repository where all the example files reside on the GitHub link below,
    and also my tutorials are built on Linux: [https://github.com/shzshi/azure-helloworld-ci.git](https://github.com/shzshi/azure-helloworld-ci.git)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证可行性，我使用 Docker 设置了带有 Node.js 和 npm 的 Jenkins 实例。我已经将这个 Dockerfile 推送到了 GitHub
    上的 Git 仓库中，所有示例文件也托管在这个仓库中，以下是我的教程链接，并且我的教程是基于 Linux 系统构建的：[https://github.com/shzshi/azure-helloworld-ci.git](https://github.com/shzshi/azure-helloworld-ci.git)
- en: 'If you are using the Dockerfile from the Git repository, then make sure Docker
    is installed on your laptop/PC. We will first clone the previous mentioned Git
    repository and build the Docker image with jenkins, serverless framework, and
    all the required dependencies for Azure Functions deployment, with the following
    command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Git 仓库中的 Dockerfile，那么确保你的笔记本电脑/PC 上已经安装了 Docker。我们将首先克隆前面提到的 Git 仓库，并使用以下命令构建
    Docker 镜像，镜像中包括 Jenkins、Serverless Framework 以及 Azure Functions 部署所需的所有依赖项：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then run the Docker container with the following command, this will create
    a container with Jenkins, Node.js 8.9, Serverless Framework 2.5 and npm 5.6:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用以下命令运行 Docker 容器，这将创建一个包含 Jenkins、Node.js 8.9、Serverless Framework 2.5 和
    npm 5.6 的容器：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you already have Jenkins set up, then make sure you have Node.js 8.9, npm
    5.6, and serverless framework 2.5 installed on the server for the previous example
    to work.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经设置了 Jenkins，那么确保服务器上已安装 Node.js 8.9、npm 5.6 和 Serverless Framework 2.5，以便上述示例能正常工作。
- en: Once Jenkins is up and running, we will create a job in Jenkins which will run
    the unit test and then deploy the Azure Function through a serverless framework
    to the Azure Cloud. Once successfully deployed, we will invoke the function through
    a serverless framework.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Jenkins 启动并运行，我们将创建一个 Jenkins 作业，它将运行单元测试，并通过 Serverless Framework 将 Azure
    Function 部署到 Azure 云。成功部署后，我们将通过 Serverless Framework 调用该函数。
- en: 'Use the following steps in order:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'The following is the screenshot of the Jenkins homepage. We will create a new
    job, so click on the link New Item and create a new job:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是 Jenkins 首页的截图。我们将创建一个新作业，点击链接 “New Item” 来创建一个新作业：
- en: '![](img/c277d547-bf8b-4020-b284-389063b6bef7.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c277d547-bf8b-4020-b284-389063b6bef7.png)'
- en: 'Create a job name, whatever suits, and select Freestyle project and submit
    OK:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个作业名称，随便取个名字，选择“Freestyle 项目”并提交 OK：
- en: '![](img/cd91530d-4403-4866-a099-385c0dc43c97.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd91530d-4403-4866-a099-385c0dc43c97.png)'
- en: 'Then we will redirect to the configure page for the job, where we will add
    the Git repository for cloning, click on the **Source Code Management** tab, and
    add details in the Git repository as shown here:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将跳转到作业的配置页面，在这里我们将添加用于克隆的 Git 仓库，点击 **Source Code Management** 标签，并按如下所示添加
    Git 仓库的详细信息：
- en: '![](img/1490dd3e-1d32-4672-85cf-74c2ed53bfa2.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1490dd3e-1d32-4672-85cf-74c2ed53bfa2.png)'
- en: Then click the **Build** tab and create an execute shell, and, through the **Add
    build step** drop-down menu, we add `npm install` to install the required Node.js
    modules from the internet, and then run the Node.js test, which will unit test
    the Azure library function and give us the result.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后点击 **Build** 标签页并创建一个执行 Shell，通过 **Add build step** 下拉菜单，添加 `npm install`
    来从互联网安装所需的 Node.js 模块，然后运行 Node.js 测试，这将单元测试 Azure 库功能并给出结果。
- en: 'We can add many unit tests to test our function, before deploying it to Azure
    Cloud, to make sure the app is unit tested before it goes on to the cloud:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在将应用部署到 Azure 云之前，我们可以添加许多单元测试来测试我们的功能，以确保应用在进入云端之前已通过单元测试：
- en: '![](img/73314152-0c4e-4a49-a6a4-e9b91ced140c.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73314152-0c4e-4a49-a6a4-e9b91ced140c.png)'
- en: Make sure you have the Publish HTML report plugin already installed through
    steps **Jenkins Home** | **Manage Jenkins** | **Manage Plugins**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经通过 **Jenkins Home** | **Manage Jenkins** | **Manage Plugins** 安装了 Publish
    HTML report 插件。
- en: 'Once we run the preceding job, then a unit test is performed and the report
    is generated for the unit test, which we can view by configuring post-build action.
    So, let''s click on the **Post-build Actions** tab, then click on the dropdown
    **Add post-build action** and select **Publish HTML reports**, click on **Add**
    and then configure it as per the following screenshot:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦运行了上述作业，就会执行单元测试并生成报告，我们可以通过配置构建后操作来查看该报告。所以，让我们点击 **Post-build Actions**
    标签页，然后点击下拉菜单 **Add post-build action** 并选择 **Publish HTML reports**，点击 **Add**，然后按照以下截图进行配置：
- en: '![](img/1579513f-2027-4f7c-b842-4f6de84343a9.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1579513f-2027-4f7c-b842-4f6de84343a9.png)'
- en: '**Save** the job and run the build. Once the job has built successfully, we
    should be able to view the code coverage HTML view, from the job''s homepage.
    The coverage will look like the following screenshot, which should give us a good
    view of how our unit test has performed:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**保存**该任务并运行构建。构建成功后，我们应该能够在任务主页上查看代码覆盖率的HTML视图。覆盖率会像下面的截图一样，给我们一个关于单元测试执行情况的良好视图：'
- en: '![](img/2052f9b0-1da3-45a0-a3df-4d91c32e8a3d.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2052f9b0-1da3-45a0-a3df-4d91c32e8a3d.png)'
- en: In the previous section, we unit tested our function and looked at coverage
    of the function. Next we will configure deployment onto the cloud.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们对函数进行了单元测试，并查看了函数的覆盖率。接下来，我们将配置部署到云端。
- en: Continuous integration with Azure Functions
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Azure Functions的持续集成
- en: 'Now, moving on to deploying to Azure Cloud Functions, we will be using a serverless
    framework. The framework will be doing all the heavy lifting, but it needs a few
    pre-requisites to make it work. They are: **serverless-azure-functions **and **cli
    az login** to get the required credentials and account details. Please use the
    following steps to do this in the pre-requisites section:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，进入部署到Azure Cloud Functions的步骤，我们将使用一个无服务器框架。框架将完成所有繁重的工作，但它需要一些前置条件才能正常工作。它们是：**serverless-azure-functions**和**cli
    az login**，用于获取所需的凭据和账户详情。请按照以下步骤在先决条件部分进行操作：
- en: Prerequisites
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'We can install `serverless-azure-functions` through the npm. The following
    command will install the latest version of the plugin, but if you are using the
    docker image which is created above, it already has the plugin added to it:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过npm安装`serverless-azure-functions`。以下命令将安装插件的最新版本，但如果你使用的是上面创建的docker镜像，它已经包含了这个插件：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'But, to interface with the Azure platform, we need to set up Azure subscription
    credentials locally.  For the `serverless-azure-functions` plugin to work we need
    to set up a service principal, which can done through the Azure portal URL as
    seen in the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，为了与Azure平台进行交互，我们需要在本地设置Azure订阅凭据。为了使`serverless-azure-functions`插件正常工作，我们需要设置一个服务主体，可以通过Azure门户网址完成，如下所示：
- en: '[https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-create-service-principal-portal](https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-create-service-principal-portal)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/zh-cn/azure/azure-resource-manager/resource-group-create-service-principal-portal](https://docs.microsoft.com/zh-cn/azure/azure-resource-manager/resource-group-create-service-principal-portal)'
- en: 'However,  if you are using PowerShell cmdlets, then use the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你使用的是PowerShell cmdlets，请使用以下命令：
- en: '[https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-authenticate-service-principal](https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-authenticate-service-principal)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/zh-cn/azure/azure-resource-manager/resource-group-authenticate-service-principal](https://docs.microsoft.com/zh-cn/azure/azure-resource-manager/resource-group-authenticate-service-principal)'
- en: 'I will be using CLI for our tutorial , but you are free to use whichever fits
    best.  or through Azure CLI , Please follow the given steps to get the Azure CLI
    locally:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用CLI进行教程，但你可以自由选择最合适的方式。或者通过Azure CLI，请按照以下步骤在本地获取Azure CLI：
- en: '[https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/zh-cn/cli/azure/install-azure-cli?view=azure-cli-latest](https://docs.microsoft.com/zh-cn/cli/azure/install-azure-cli?view=azure-cli-latest)'
- en: 'Alternatively, you can use the Azure Cloud Shell, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用Azure Cloud Shell，如下所示：
- en: '[https://docs.microsoft.com/en-us/azure/cloud-shell/overview](https://docs.microsoft.com/en-us/azure/cloud-shell/overview)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/zh-cn/azure/cloud-shell/overview](https://docs.microsoft.com/zh-cn/azure/cloud-shell/overview)'
- en: 'Once the Azure CLI is successfully installed we should be able to access `login` by
    using the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Azure CLI成功安装，我们应该能够通过以下命令访问`login`：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The previous command  will prompt us to visit `https://aka.ms/devicelogin`
    and provide us with a code and with Azure identity. We will then be able to access
    our account through the CLI. We will be provided with account details like the
    following one on the command line:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令会提示我们访问`https://aka.ms/devicelogin`并提供一个代码和Azure身份。然后我们就可以通过CLI访问我们的账户。我们将在命令行中看到如下的账户详情：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We also need to get subscription details through the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要通过以下命令获取订阅详情：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we need to create a service principal. We can do this by running the
    following command. It will provide us with a JSON object that we will need to
    authenticate with Azure Cloud:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个服务主体。我们可以通过运行以下命令来完成。这将提供一个 JSON 对象，我们需要使用该对象进行 Azure 云身份验证：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And the last pre-requisite we need is for an **EnvInject **plugin to be installed
    in Jenkins to mask the Azure credentials. So please make sure that it is added.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个前提是需要在 Jenkins 中安装**EnvInject**插件来掩盖 Azure 凭据。请确保已经添加该插件。
- en: Setting up environment variables
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境变量
- en: 'Finally, we create environment variables with subscription ID, tenant, name,
    and password. We need to export this on the Jenkins node and set up a deployment.
    So let''s do that:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建环境变量，包括订阅 ID、租户、名称和密码。我们需要将其导出到 Jenkins 节点，并设置部署。因此，让我们来完成这一步：
- en: Open the Jenkins in browser and add a new job with a click on **New Item**.
    Enter the item name **myAzureFunctionDeploy **and select **Freestyle project**,and
    click **OK**.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开 Jenkins，点击**新建项目**添加一个新作业。输入项目名称**myAzureFunctionDeploy**并选择**自由风格项目**，然后点击**确定**。
- en: 'On the job configuration page, tick **This project is parameterised **and add
    **Password Parameter** below the name and default values retrieved from the Azure
    commands as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工作配置页面，勾选**此项目是参数化的**，并在名称下方添加**密码参数**，默认值通过以下 Azure 命令获取：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's click on the **Source Code Management** tab and add the repository URL
    as [https://github.com/shzshi/azure-helloworld-ci.git](https://github.com/shzshi/azure-helloworld-ci.git),
    the repository has the required files.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**源代码管理**标签，添加仓库 URL：[https://github.com/shzshi/azure-helloworld-ci.git](https://github.com/shzshi/azure-helloworld-ci.git)，该仓库包含所需的文件。
- en: In **Build Environment** select **Inject passwords to the build as environment**
    **variables**. We are doing this to mask the Azure credentials and other details.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**构建环境**中选择**将密码注入为构建环境变量**。我们这样做是为了掩盖 Azure 凭据和其他详细信息。
- en: Next, click on the **Build** tab and, in the execute shell, add the steps mentioned
    in the following example, and then click on **Save. **
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击**构建**标签，在执行 Shell 中添加以下示例中的步骤，然后点击**保存**。
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s click on **Build with parameters**.Then click on **Build **the job will
    build, create a package and deploy the functions onto the Azure portal. We can
    test the function on the cloud. Once the function is deployed we can invoke or
    run through a serverless command prompt. We can integrate this in smoke testing
    or functional testing, so we test the running of the function in actuality through
    command line or adding the same line into Jenkins job, as seen in the following:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**使用参数构建**。然后点击**构建**，作业将构建，创建一个包并将函数部署到 Azure 门户。我们可以在云端测试该函数。函数部署后，我们可以通过无服务器命令提示符调用或运行该函数。我们可以将其集成到冒烟测试或功能测试中，因此我们可以通过命令行或将相同的命令行添加到
    Jenkins 作业中来测试函数的实际运行，如下所示：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can also stream the logs of the function, to check how functions got deployed,
    or how it performed while it ran:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以流式传输函数的日志，以查看函数如何被部署，或者它在运行时的表现：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can change the code in the source code repository and run these commands
    individually, or through orchestrating tools like Jenkins to perform perfect continuous
    integration and continuous delivery.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改源代码仓库中的代码，并单独运行这些命令，或者通过像 Jenkins 这样的编排工具来实现完美的持续集成和持续交付。
- en: 'We can integrate removal of the function from the Azure Function through the
    following command. This can be integrated within the Jenkins pipeline to undeploy
    or to rollback the function to a previous version:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令集成从 Azure 函数中移除该函数。这可以集成到 Jenkins 管道中，以取消部署或将函数回滚到先前版本：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Continuous deployment to Azure Functions
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续部署到 Azure 函数
- en: '**Continuous deployment** means that every code we commit should go through
    an automated unit, integration, and performance testing, and also go through an
    automated source code analysis and be successfully deployed all the way to production
    without manual intervention. But, in some cases we should be able to roll back
    the deployment because of some bugs or issues in the production. Rollback can
    be automated, but usually rollback is done manually. We can set up a continuous
    delivery pipeline through the Azure portal. Let''s set up a simple continuous
    delivery pipeline. Azure Cloud has an out-of-the-box feature to set up a pipeline
    for Azure Function. It integrates with a good number of source code managements,
    such as Git, GitHub, Bitbucket, Visual Studio team services, and a few others.
    The continuous deployment is set up on a per function app basis and also a function
    code can be maintained through a source repository, and the code within the portal
    becomes read only. So, the moment the code is updated and committed into the source
    code repository, the function code is automatically built and deployed on the
    portal.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续部署**意味着我们每次提交的代码都应经过自动化的单元测试、集成测试和性能测试，并且经过自动化的源代码分析后，能够成功部署到生产环境中，而无需人工干预。然而，在某些情况下，我们应能够因生产环境中的一些错误或问题回滚部署。回滚可以是自动化的，但通常是手动执行的。我们可以通过
    Azure 门户设置一个持续交付的流水线。让我们设置一个简单的持续交付流水线。Azure Cloud 提供了一个开箱即用的功能来设置 Azure Function
    的流水线。它与多种源代码管理工具集成，如 Git、GitHub、Bitbucket、Visual Studio Team Services 等。持续部署是按每个函数应用设置的，函数代码也可以通过源代码仓库进行管理，门户中的代码变为只读。因此，一旦代码更新并提交到源代码仓库，函数代码会自动构建并部署到门户。'
- en: Setting up a continuous deployment Azure deployment tool
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置一个持续部署的 Azure 部署工具
- en: 'Here we will demonstrate to how to set up continuous delivery with a GitHub
    repository through the Azure portal:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将演示如何通过 Azure 门户设置与 GitHub 仓库的持续交付：
- en: 'Log into the Azure portal ([https://portal.azure.com](https://portal.azure.com)).
    On successful login click on the All resourceslink. We should be able to see the
    Function App created:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到 Azure 门户 ([https://portal.azure.com](https://portal.azure.com))。登录成功后，点击“所有资源”链接。我们应该能看到已经创建的函数应用：
- en: '![](img/dfaa8e44-2324-4872-b672-0a33cced3a1a.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dfaa8e44-2324-4872-b672-0a33cced3a1a.png)'
- en: 'Select the app for which we need to set up the continuous deployment, as per
    my example. I will pick up **azure-helloword-ci** which takes me to the function
    apps windows. Then, on the function apps windows, we will select Platform features on
    the top right hand side tab and then click on Deployment options:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们需要设置持续部署的应用程序，根据我的示例，我会选择 **azure-helloword-ci**，这将带我们进入函数应用窗口。然后，在函数应用窗口中，我们会选择右上角的“平台功能”标签页，点击“部署选项”：
- en: '![](img/7dfa0eac-c4ef-4686-b0fc-35a54c574271.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7dfa0eac-c4ef-4686-b0fc-35a54c574271.png)'
- en: Then, in the deployment section, click on setup. Then another window will slide,
    with the heading Deployment option. Click on the link Choose source, then in the
    next window, we will see options to add the Source control. Let's select GitHub.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在部署部分，点击“设置”。接下来会出现一个窗口，标题为“部署选项”。点击链接“选择源”，在下一个窗口中，我们将看到添加源控制的选项。选择 GitHub。
- en: Then we will get options to configure GitHub repositories where we will be asked
    to authorize Azure Functions to access our private or public repositories.  Please
    make sure you use your own account's public repository.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着我们将看到配置 GitHub 仓库的选项，我们需要授权 Azure Functions 访问我们的私人或公共仓库。请确保使用自己的账户的公共仓库。
- en: Once configured, we need to select the repository where we have to fill in choose
    source, authorization, choose your organization, choose project repository, branch
    and can configure performance test. We will be taken to the GitHub portal to put
    in our GitHub credentials to connect to the GitHub repository. After that, once
    we click OK, the repository will be configured with Azure Function and all the
    file changes in the GitHub are copied to the function app and a full site deployment
    is triggered.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置完成后，我们需要选择仓库，填写选择源、授权、选择组织、选择项目仓库、分支，并可以配置性能测试。我们将被引导到 GitHub 门户，输入我们的 GitHub
    凭证以连接到 GitHub 仓库。之后，一旦点击确认，仓库将与 Azure Function 配置，并且 GitHub 中的所有文件更改都会被复制到函数应用中，触发完整站点部署。
- en: We can set up performance testing with the button **Configure Performance Test**.
    We can create multiple environments by creating different branches, and by merging
    the code to the master branch for production deployment.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过点击**配置性能测试**按钮来设置性能测试。我们可以通过创建不同的分支来创建多个环境，然后将代码合并到主分支以进行生产部署。
- en: Blue-green deployment in Azure Functions
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure Functions中的蓝绿部署
- en: 'There are multiple deployment patterns in DevOps: canary deployment and blue
    green deployments. We will be talking about blue green deployment for Azure Functions
    in this book. Blue green deployment technique reduces the downtime and risk by
    having two identical production environments with the names blue and green. One
    environment will go live whilst the other is used for staging new changes. And
    there is workflow designed to switch between live and staging. Initially, a new
    version of the application is deployed to the blue environment with all the user
    traffic being redirected to the blue environment. After the next version of application
    has been developed, it is deployed to a staging environment (green) for testing.
    After the testing of the new version of the software is considered satisfactory,
    then all the traffic is redirected to the green environment and is considered
    as live.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps中有多种部署模式：金丝雀部署和蓝绿部署。在本书中，我们将讨论Azure Functions的蓝绿部署。蓝绿部署技术通过使用两个相同的生产环境（分别命名为蓝色和绿色）来减少停机时间和风险。在这种模式下，一个环境用于线上运行，另一个用于新更改的预发布。在切换流程中，初始版本的应用程序部署到蓝色环境，所有用户流量都将重定向到蓝色环境。之后，新的应用程序版本被部署到预发布环境（绿色环境）进行测试。当新的软件版本测试合格后，所有流量将切换到绿色环境，并认为该环境为正式生产环境。
- en: The deployment dashboard
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署仪表板
- en: The development team always need to keep track of deployment and the health
    of the development pipeline. It also needs to know the track of deployment failure,
    the number of releases done, the number of check-ins, and many other metrics which
    are very important for the development cycle.  There is one open source which
    can help to track all these details and it is Hygieia. Hygieia is an open source
    tool available for a holistic view on the single screen for tracking build, deployment,
    quality control, and application performance. It also helps to track deployment
    versions, and also the health of the application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 开发团队需要始终跟踪部署情况和开发流水线的健康状态。它还需要跟踪部署失败的情况、已完成的发布次数、代码提交次数以及许多对开发周期至关重要的其他指标。有一个开源工具可以帮助跟踪所有这些细节，它就是Hygieia。Hygieia是一个开源工具，可以在单一界面上提供构建、部署、质量控制和应用性能的整体视图。它还帮助跟踪部署版本以及应用程序的健康状况。
- en: '**Hygieia** is a DevOps dashboard tool, developed by Capital One, and the company
    has open-sourced the tool.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**Hygieia**是由Capital One开发的DevOps仪表板工具，该公司已将其开源。'
- en: The Hygieia dashboard has two views, one is a widget and other is a pipeline.
    The widget view displays information about features in the current sprint, code
    contribution activities, continuous integration activities, code analysis, security
    analysis, unit and functional test results, deployment, and environment status.
    The pipeline view has components of the deployment life cycle which show progression
    through development, Int, QA, performance, and production. Hygieia also has product
    dashboard which displays a collaborative dashboard for multiple applications within
    each product.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Hygieia仪表板有两种视图，一种是小部件视图，另一种是流水线视图。小部件视图显示当前冲刺中的功能、代码贡献活动、持续集成活动、代码分析、安全分析、单元和功能测试结果、部署以及环境状态的信息。流水线视图显示部署生命周期的各个组件，展示从开发、集成、QA、性能到生产的进展。Hygieia还提供产品仪表板，显示各个产品中多个应用的协作仪表板。
- en: Hygieia has lots of plugins which integrate or get the logs from many DevOps
    tools like Jira, Subversion, Jenkins, Sonar, IBM UrbanCode Deploy and, as Hygieia
    is an open source, we can build our own plugin and widget for the Hygieia.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Hygieia有许多插件，可以与Jira、Subversion、Jenkins、Sonar、IBM UrbanCode Deploy等多个DevOps工具集成或获取日志。由于Hygieia是开源的，我们还可以为其构建自己的插件和小部件。
- en: Out of the box, the Hygieia dashboard application integrates with VersionOne,
    Jira, Subversion, GitHub, Hudson/Jenkins, Sonar, HP Fortify, Cucumber/Selenium
    and IBM Urbancode Deploy.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Hygieia仪表板应用程序开箱即用，能够与VersionOne、Jira、Subversion、GitHub、Hudson/Jenkins、Sonar、HP
    Fortify、Cucumber/Selenium和IBM Urbancode Deploy集成。
- en: Hygieia is built on Java and plugins run through a Java command line. We can
    set up a whole Hygieia dashboard over the docker containers. Please follow the
    link for setup and integration: [https://github.com/capitalone/Hygieia](https://github.com/capitalone/Hygieia).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Hygieia 基于 Java 构建，插件通过 Java 命令行运行。我们可以在 Docker 容器中搭建完整的 Hygieia 仪表盘。请访问以下链接进行设置和集成：[https://github.com/capitalone/Hygieia](https://github.com/capitalone/Hygieia)。
- en: Monitoring and logging
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控和日志记录
- en: Serverless applications help speed up development and independence and allow
    the execution which triggers events, but when these function do not work as expected,
    how do we verify that events are activating the right functions? With serverless
    applications, the root cause analysis becomes more complicated, because services
    are small and their functionality is very precise. While trying to track down
    the fault source, neither the services involved nor any of the integration points
    actually exist, and when there is more than one function which takes part in the
    operation, the investigation becomes very difficult.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器应用程序有助于加速开发和提高独立性，并允许触发事件的执行，但当这些功能未按预期工作时，我们如何验证事件是否正在激活正确的功能？在无服务器应用程序中，根本原因分析变得更加复杂，因为服务很小，功能也非常精确。在追踪故障源时，涉及的服务或任何集成点实际上并不存在，而且当有多个功能参与操作时，调查变得非常困难。
- en: That is where the logs plays a vital role, but there are some unique considerations
    which need to be taken into account when logging into a serverless architecture.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是日志发挥至关重要作用的地方，但在无服务器架构中进行日志记录时，有一些独特的考虑因素需要加以注意。
- en: And it is normal for several functions to fail and not to deliver the requested
    functionality, or for the logs contain a unified identifier for the transaction,
    so when function logs are analysed, the transaction failure can be detected easily
    and the failure problem can be fixed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 多个功能失败并未提供请求的功能，或者日志包含一个统一的事务标识符，这在无服务器应用中是正常现象，因此，当分析功能日志时，可以轻松检测到事务失败，并修复故障问题。
- en: In Azure Functions we can get logs in many ways. The easiest way is to log in
    to the Azure portal, go to the respective function and select the Monitor tab. Here
    we will see a list of function invocations, their status, and last run with duration. If
    we select the invocation that has failed, then, on the right-hand side, we can
    see the exact log and other required information.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure Functions 中，我们可以通过多种方式获取日志。最简单的方法是登录到 Azure 门户，进入相应的功能并选择“监视”选项卡。在这里，我们将看到一列功能调用记录、它们的状态，以及最后一次运行的时长。如果我们选择某个失败的调用，则在右侧可以看到准确的日志和其他相关信息。
- en: Accessing logs through Kudu
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 Kudu 访问日志
- en: We can access the logs through Kudu. Kudu was developed to access the Microsoft
    Azure web apps environment. As Azure Function runs on a web app, we can use Kudu
    to access the logs of the Azure Functions. Kudu can access environment information,
    and also details of the actual filesystem which is attached to the function while
    running.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 Kudu 访问日志。Kudu 是为访问 Microsoft Azure Web 应用环境而开发的。由于 Azure Function 运行在
    Web 应用中，我们可以使用 Kudu 来访问 Azure Functions 的日志。Kudu 可以访问环境信息，并且还可以查看运行时附加到功能的实际文件系统的详细信息。
- en: Kudu can be accessed through a web browser. The link for the same would be [https://myAzureFunction.scm.azurewebsites.net](https://myAzureFunction.scm.azurewebsites.net/). We
    have to replace the `myAzureFunction` with our web app name. The best part of
    Kudu, is that it will give us the actual file system access of our function environment,
    either through shell or through browsing, which makes it easier to get to root
    cause of the failure.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 Web 浏览器访问 Kudu。相关链接是 [https://myAzureFunction.scm.azurewebsites.net](https://myAzureFunction.scm.azurewebsites.net/)。我们只需要将
    `myAzureFunction` 替换为我们的 Web 应用名称。Kudu 的最大优点是，它可以通过 Shell 或浏览的方式让我们访问功能环境的实际文件系统，这使得追踪故障根源变得更容易。
- en: Logging information via table storage
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过表存储记录日志信息
- en: All logging and timing information of the function is stored in the storage
    account that we created earlier while creating our function app. We can access
    the log through Visual Studio if we have Azure SDK installed. We can also access
    the logs through  Cloud Explorer Window.  (If you have multiple Azure Function
    apps then it might be a bit tricky to remember which one belongs to which function
    app, but you can discover that by looking in your Application Settings at the
    contents of the `AzureWebJobsStorage` setting).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 所有函数的日志和时间信息都存储在我们之前创建函数应用时所创建的存储帐户中。如果我们安装了 Azure SDK，可以通过 Visual Studio 访问日志。我们还可以通过
    Cloud Explorer 窗口访问日志。（如果你有多个 Azure Function 应用，可能有点难记住哪个属于哪个函数应用，但你可以通过查看应用程序设置中的
    `AzureWebJobsStorage` 设置内容来找到它）。
- en: Monitoring the Azure Function
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控 Azure Function
- en: 'Monitoring the function is essential. It will give a good view of how our function
    or app is performing with traffic and also when it scales and descales. Azure
    Function has built-in integration with Azure application insight.  Application
    insightis built in an APM (application performance management) service by Azure.
    We can configure application insight during the creation of a function app and send
    the telemetric data to Application Insights. Create a new function app and set
    the Application Insights switch On and the Application Insights Location:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 监控函数非常重要。它能清楚地展示我们的函数或应用在处理流量时的表现，以及在扩展和收缩时的表现。Azure Function 与 Azure 应用程序洞察内置集成。应用程序洞察是由
    Azure 提供的 APM（应用程序性能管理）服务。我们可以在创建函数应用时配置应用程序洞察，并将遥测数据发送到应用程序洞察。创建一个新的函数应用，打开应用程序洞察开关并设置应用程序洞察位置：
- en: '![](img/a704ec70-de78-4ace-9231-45ea43d6be50.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a704ec70-de78-4ace-9231-45ea43d6be50.png)'
- en: 'We can see the performance graph in the Metrics Explorer of the Azure Cloud
    portal to monitor the function health:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Azure Cloud 门户的 Metrics Explorer 中查看性能图，以监控函数的健康状况：
- en: '![](img/ed017e46-6087-4837-b7ab-f97fb2644e1c.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed017e46-6087-4837-b7ab-f97fb2644e1c.png)'
- en: Integrating with New Relic
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 New Relic 集成
- en: 'New Relic provides integration for Azure Function that does the following functions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: New Relic 提供了 Azure Function 的集成，执行以下功能：
- en: Reports data from Azure Functions to New Relic products.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Azure Functions 的数据报告给 New Relic 产品。
- en: Reports metric data, like the count of functions executed, bytes sent and received,
    and HTTP errors.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告度量数据，如执行的函数数量、发送和接收的字节数以及 HTTP 错误。
- en: Collects inventory data about the status and configuration of the service.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集有关服务状态和配置的库存数据。
- en: You can monitor and alert on your Azure Functions data from New Relic, and you
    can create custom queries and chart dashboards.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 New Relic 监控并对 Azure Functions 数据设置告警，还可以创建自定义查询和仪表盘。
- en: To activate the Azure Functions integration, follow the Azure Integration Activation
    through the link: [https://docs.newrelic.com/docs/integrations/microsoft-azure-integrations/getting-started/activate-azure-integrations](https://docs.newrelic.com/docs/integrations/microsoft-azure-integrations/getting-started/activate-azure-integrations).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活 Azure Functions 集成，请通过以下链接进行 Azure 集成激活：[https://docs.newrelic.com/docs/integrations/microsoft-azure-integrations/getting-started/activate-azure-integrations](https://docs.newrelic.com/docs/integrations/microsoft-azure-integrations/getting-started/activate-azure-integrations)。
- en: Best practice
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'DevOps for serverless is pretty young and evolving. Serverless itself is emerging
    at a fast pace, and, within that framework, to automate deployment and integration
    with other DevOps, it is changing faster. Talking about best practice for smooth
    code deployment from development to production, we need to look at various tenants
    of DevOps for Azure Function and learn from the mistakes during implementation.
    But because serverless is still evolving, and DevOps with serverless is still
    niche, we would not be able to highlight every aspect of DevOps. However,  we
    will look at some of the main tenants and talk about them in detail here. So the
    main tenant for DevOps with serverless are: source code management, build, deployment,
    release management, monitoring, and logging, which is almost the same as application.
    But because serverless are micro services, there is bit of a change when we apply
    DevOps to it. So let''s look at each aspect of it and learn the best way of applying
    DevOps to the Azure Functions.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 面向无服务器的 DevOps 仍然是一个相对年轻且不断发展的领域。无服务器本身正在快速崛起，而在这个框架内，为了实现与其他 DevOps 的自动化部署和集成，变化速度更快。谈到从开发到生产的顺畅代码部署的最佳实践时，我们需要关注
    Azure Function 的 DevOps 的各个要素，并从实施过程中吸取经验教训。但由于无服务器技术仍在发展中，且无服务器的 DevOps 仍属于小众领域，我们可能无法涵盖
    DevOps 的所有方面。不过，我们将重点关注其中的一些关键要素，并在这里详细讨论。因此，面向无服务器的 DevOps 的主要要素包括：源代码管理、构建、部署、发布管理、监控和日志记录，这几乎与应用程序开发相同。但由于无服务器是微服务架构，因此在将
    DevOps 应用到它时有所不同。接下来，我们将探讨每个方面，并学习如何将 DevOps 最好地应用于 Azure Functions。
- en: Source code management
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码管理
- en: Developers write the code and work together to perform a task, but developers
    keep adding to the new features, or they update the code to perform better, or
    to enhance the functionality. This is why we need source code management. Git
    is one of most popular source code management tools available. So we have to set
    up various strategies for efficient management of the code. But before that we
    need to set up a folder structure for Azure Function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员编写代码并共同协作执行任务，但开发人员不断添加新功能，或者更新代码以提高性能，或增强功能性。这就是我们需要源代码管理的原因。Git 是目前最流行的源代码管理工具之一。因此，我们必须为高效管理代码设定不同的策略。但在此之前，我们需要为
    Azure Function 设置一个文件夹结构。
- en: Folder structure
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件夹结构
- en: 'All the functions codes of a specific function app would be located in the
    root folder with one or many subfolders and a host configuration file. The `host.json`
    file will contain runtime specific configurations. And each function folder will
    have one or more code files, `function.json`, configurations, and other function
    dependencies:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 特定功能应用程序的所有函数代码将位于根文件夹中，可能有一个或多个子文件夹，并且包含一个主机配置文件。`host.json` 文件将包含运行时特定的配置。每个函数文件夹将包含一个或多个代码文件、`function.json`
    配置文件以及其他函数依赖项。
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With the folder structure we need to apply the best method of branching strategy
    for robust development and smooth deployment. The best practice is to have multiple
    branches with a master, which is a default branch, for easy development, and future
    easy release into production. Those branches are feature, develop, release, and hot
    fixes branches.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件夹结构中，我们需要应用最好的分支策略，以实现稳健的开发和顺畅的部署。最佳实践是拥有多个分支，其中 master 分支是默认分支，方便开发，并便于未来顺利发布到生产环境。这些分支包括功能分支、开发分支、发布分支和热修复分支。
- en: The feature branch helps easy tracking of a feature, as well as aiding parallel
    development between team members. A feature branch might branch from a develop
    branch, but should always merge back to a develop branch. The next main branch
    would be a develop branch and this branch lives through the life cycle of project
    development and support. When the source code from a develop branch is stable,
    then it is merged back to the master branch, after successful release, and every
    merge to the master will trigger a production release.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 功能分支有助于轻松跟踪某个功能，并促进团队成员之间的并行开发。功能分支可能从开发分支派生，但应始终合并回开发分支。下一个主要分支是开发分支，该分支贯穿项目的开发和支持生命周期。当开发分支的源代码稳定时，它会被合并回
    master 分支，成功发布后，每次合并到 master 分支都会触发生产环境的发布。
- en: A release branch may be from a develop branch, but they must merge back to the
    develop and master branches. The release branch is used for preparation of new
    production release. The release branch is used for next big release. It provides
    with us room for minor bug fixes, and for setting up meta data for release. When
    the release branch is ready to be a real release then we need to make sure it
    is merged with the master and the commit must be tagged for future historical
    versions. Finally, the release branch should be merged with the develop branch,
    so that we get all the changes of this release in future releases.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 发布分支可能来自开发分支，但它们必须合并回开发和主分支。发布分支用于准备新的生产发布。发布分支用于下一个大版本发布。它为我们提供了进行次要错误修复的空间，并为发布设置元数据。当发布分支准备好进行实际发布时，我们需要确保它与主分支合并，并且提交必须被标记为未来的历史版本。最后，发布分支应与开发分支合并，以便我们在未来发布中获得此发布的所有更改。
- en: Last of all is the hotfix branch. This is almost the same as the release branch,
    as it helps us in production release. Hotfix is actually useful when production
    deployment fails and you need to hotfix production, so that we can get it back
    live. So to resolve the production failure, we branch hotfix branch off a production
    tag from the master branch, so that one team can fix the production failure and rest
    of the team can continue development on the develop branch. The rule of thumb
    is that the hotfix branch might branch from a master and then, once hotfix is
    successful, the changes are merged back to the master. They also need to merge
    to the develop branch, to make sure we have these hotfix changes in future releases.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是热修复分支。这与发布分支几乎相同，因为它帮助我们进行生产发布。当生产部署失败时，热修复实际上非常有用，因此我们可以快速修复生产问题，以便及时恢复生产。为了解决生产故障，我们从主分支的生产标签中分支出热修复分支，这样一个团队可以修复生产故障，而另一个团队可以继续在开发分支上开发。一般的经验法则是热修复分支可能从主分支分支出去，一旦热修复成功，变更将合并回主分支。它们还需要合并到开发分支，以确保我们在未来发布中拥有这些热修复变更。
- en: Testing and static code analysis
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和静态代码分析
- en: Testing is an essential part of development, it is must when we develop any
    application. It helps to mitigate most of the bugs and performance issues before
    going to production. There are many types of testing involved in application development.
    These include, unit testing, integration testing and performance testing. They
    integrated into different stages of the environment deployment. Unit testing is
    integrated in the development stage.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是开发的重要组成部分，当我们开发任何应用程序时，测试是必须的。它有助于在进入生产之前减少大部分错误和性能问题。在应用程序开发中涉及许多类型的测试。这些包括单元测试、集成测试和性能测试。它们集成到不同的环境部署阶段中。单元测试集成在开发阶段中。
- en: The serverless handler should always be a thin layer that uses modules out of
    your code library. And modules should be well-covered with unit tests; then testing
    of the serverless application will be easy during the integration tests.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器处理程序应始终是一个使用代码库中的模块的薄层。模块应该有很好的单元测试覆盖率；然后在集成测试期间测试无服务器应用程序将会更加容易。
- en: We should try to run unit tests and integration test the modules and function
    locally, this will help to run the tests faster, and find issues in code base
    easily, and without deploying to cloud. We should run them remotely as well, because
    remote infrastructure is a bit different from local infrastructure. We can achieve
    both by setting up a pipeline and staging them as different environments (development,
    stage, user acceptance testing, pre-production and production), where development
    and stage testing should be invoked locally, and same testing with better performance
    is tested remotely on the rest of the environment.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该尝试在本地运行单元测试和集成测试模块和函数，这样可以帮助更快地运行测试，并且更容易在代码库中找到问题，而无需部署到云端。我们也应该远程运行它们，因为远程基础设施与本地基础设施有所不同。我们可以通过设置流水线并将它们分阶段部署到不同的环境（开发、阶段、用户验收测试、预生产和生产），其中开发和阶段测试应在本地调用，而其他环境则通过远程测试以获得更好的性能。
- en: Static code analysis is the process of analyzing source code to flag programming
    errors, bugs, stylistic errors, and suspicious constructs. We have to make sure
    we have to integrate linting tool for serverless function in the pipeline stage.
    This helps to keep the code clean, less buggy and perfectly indented.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 静态代码分析是分析源代码，以标记编程错误、漏洞、风格错误和可疑构造的过程。我们必须确保在管道阶段集成服务器函数的 linting 工具。这有助于保持代码整洁、减少漏洞，并确保正确缩进。
- en: Deployment and release
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署和发布
- en: 'There are various types of deployment pattern, but we should select one which
    fits our case, and which uses all the functions together in one go: blue-green
    and canaries, and also lots of complexities, such as redundancy, high availability,
    rollback, A/B testing and incremental roll outs. All these need to be considered
    during deployment, and deployment should be achieved with ease and flexibility.
    So it should always be better to decide on the pattern before starting the automation.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 部署模式有多种类型，但我们应选择一个适合我们情况的模式，并将所有功能一次性组合使用：蓝绿部署和金丝雀发布，并且还涉及诸多复杂性，如冗余、高可用性、回滚、A/B
    测试和增量发布。所有这些都需要在部署过程中考虑，部署应实现轻松和灵活。因此，在开始自动化之前，最好先决定使用的部署模式。
- en: We have to make sure deployment is constantly monitored and deployment failures
    are analysed and improved with time. All the deployment should be triggered through
    automated pipelines with minimal manual intervention, attached to a GitHub repository,
    with strict branching strategy. We can also package the function app and upload
    into Nexus to set up easier roll back. All the deployment should have a feedback
    loop all the way to project tracking tools like JIRA/rally. This will make it
    easier to trace the failure.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保部署始终被监控，并且随着时间的推移，对部署失败进行分析和改进。所有部署应通过自动化管道触发，尽量减少人工干预，并附加到 GitHub 仓库，采用严格的分支策略。我们还可以将函数应用打包并上传到
    Nexus，以便更轻松地回滚。所有部署都应该有一个反馈环，直到项目追踪工具如 JIRA/rally。这将使故障追踪变得更加容易。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: To summarize, we covered continuous integration, continuous deployment, logging,
    and monitoring of Azure Functions and also fleshed out best practices around how
    to manage the Azure Functions in a source code repository, the importance of testing
    and automated deployment. Serverless or functions with Azure Cloud are still an
    early development but improving as each day passes. There is still lots to achieve
    in terms of adoption and improvement. But once adoption of serverless grows, DevOps
    practices around it will improve and become robust. In the next chapter, we will
    learn how to apply DevOps to OpenWhisk, another serverless provider.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们涵盖了 Azure Functions 的持续集成、持续部署、日志记录和监控，同时也详细讨论了如何在源代码仓库中管理 Azure Functions
    的最佳实践，测试和自动化部署的重要性。无服务器或基于 Azure 云的函数仍处于初期发展阶段，但随着每一天的过去，它们在不断改进。就采纳和改进而言，仍然有很多工作要做。但一旦无服务器的使用增多，围绕它的
    DevOps 实践也会逐渐改进并变得更加健壮。在下一章中，我们将学习如何将 DevOps 应用于 OpenWhisk，另一个无服务器提供商。
