<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Integrating DevOps with IBM OpenWhisk</h1>
                </header>
            
            <article>
                
<p><span>In this chapter, we will be looking at OpenWhisk, which is an open source on-cloud serverless provider. We will also be learning how to build, test, and deploy OpenWhisk functions, as well as how to manage logs and monitor the functions. We will also look at the best practices for DevOps with OpenWhisk.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OpenWhisk</h1>
                </header>
            
            <article>
                
<p><strong>OpenWhisk</strong> is an incubator project of Apache and IBM.<span> It offers an open source and on-cloud  serverless platform through the IBM Bluemix portal. </span>We can set this up on premises or directly use the cloud model. The commercial side of  OpenWhisk is provided by IBM on Bluemix, and the open source version can be provisioned as <span>on-premises</span><span> <strong>I</strong></span><strong>nfrastructure as a Service</strong> <span>(</span><strong>IaaS</strong><span>)</span><span>, </span><span>as well as on a cloud, such as Bluemix, Amazon EC2, Microsoft Azure, or GCP. The open source version is available on GitHub. It is been made public through the Apache license, and people can contribute to it. </span></p>
<div class="packt_infobox">For the open source OpenWhisk version on GitHub, go to <a href="https://github.com/apache/incubator-openwhisk/tree/master/docs#getting-started-with-openwhisk">https://github.com/apache/incubator-openwhisk/tree/master/docs#getting-started-with-openwhisk</a><span>. </span></div>
<p>Like any other serverless offering, OpenWhisk executes small chunks of codes that are called <strong>actions</strong> (that is, functions<strong>)</strong> at the triggering of events. Events can originate from Bluemix or external sources. It is also claimed by OpenWhisk that it allows the integration of a home-grown event provider, or any other event provider, rather than being limited to specific ones, as other serverless service providers do.</p>
<p><span>OpenWhisk provides many features, such as autoscaling and load balancing, out of the box without having to manually configure clusters, load balancers, and HTTP plugins. Let's look at the architecture diagram for OpenWhisk:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d15e8d94-eca9-4013-b37d-b95902459b62.png" style="width:33.08em;height:22.00em;"/></div>
<p>The actions/functions are performed at the triggering of events, which could be changes to database records, IoT sensor readings, code commits to a GitHub repository, or simple HTTP requests from web or mobile apps. Events from these sources are channelled through a trigger, and rules within the triggers allow actions to react to these events.</p>
<p><strong>Action</strong> is an OpenWhisk term for functions. Actions could be small snippets of JavaScript or Swift code, or custom binary code embedded in a Docker container.   </p>
<p>Actions are normally invoked in a sequence, and output from one action can be passed as input to the next action in the sequence. Actions can be invoked through multiple sources, such as the OpenWhisk API, CLI, and iOS SDK, in addition to triggers.</p>
<p>The languages supported by OpenShift are Node.js<span>, </span>Python<span>, </span>Swift<span>, </span>Java<span>, and </span>PHP, and it is claimed by OpenShift that one of their USPs supports the Swift language, which will come in handy while writing functions or actions for mobile apps. </p>
<p><span>Services and event provider integrations can be performed using packages. A <strong>package</strong> is a bundle of feeds and actions. A <strong>feed</strong> is a piece of code that configures an external event source to fire trigger events. For example, in a bank account transaction, a trigger is created when a debit or credit event takes place and a function/action will run to send the SMS to the user about the transaction that has taken place. The actions in the packages have reusable logic that service providers make available for the people to use the service. These service providers are event sources, and they can also be invoked through the API. </span></p>
<p>OpenWhisk is built on NGINX, Kafka, Docker, and CouchDB. All of these components work together to make a serverless service for OpenWhisk.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OpenWhisk setup and configuration</h1>
                </header>
            
            <article>
                
<p>OpenWhisk operates four important concepts, which are listed as follows:</p>
<ul>
<li>Triggers</li>
<li>Actions</li>
<li>Rules</li>
<li>Sequences</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Triggers</h1>
                </header>
            
            <article>
                
<p><strong>Triggers</strong> are like events that are created by data sources. Some examples include changing database records, new code commits to your repository, and HTTP requests from a web/mobile app. The events from the sources are channeled through a trigger.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Actions</h1>
                </header>
            
            <article>
                
<p>An <strong>action</strong> is a snippet of code written in Node.js or Swift, or embedded in Docker containers. The code is deployed and is executed at the firing of the trigger.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rules</h1>
                </header>
            
            <article>
                
<p><strong>Rules</strong> form a part of the triggers when combined with an action. So every time the trigger fires, the respective action is invoked by the rule. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sequences</h1>
                </header>
            
            <article>
                
<p>The chains of actions are called <strong>sequences</strong>. We can chain the actions, and they will be invoked in order. The output of one action can become the input for the next action.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building an OpenWhisk application</h1>
                </header>
            
            <article>
                
<p>In this book, I will not be setting up an open source version of OpenWhisk. Instead, we will be using tutorials through the Bluemix portal, so to do this, we need to sign up to the Bluemix portal. They give new members the option of a free subscription for a month. So let's register with Bluemix at <a href="https://bluemix.net">https://bluemix.net</a>. As I mentioned earlier, IBM Bluemix comes with a<span> </span>free trial<span> </span>that doesn't need credit card details for the first 30 days. Following the trial, we do not have to enroll using a credit card. All the users get access to around 400,000 GB-seconds of serverless computing time per month. Additional execution time would be charged at $0.000017 per GB-second of execution, rounded to the nearest 100 ms.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a hello world OpenWhisk action</h1>
                </header>
            
            <article>
                
<p><span>The prerequisites for this tutorial is an IBM cloud account (free trial) and knowledge of Node.js (which we have used throughout the book). We will be starting with a simple example first and then move towards applying automation to the tutorial code as we go on with the chapter. So, let's create a simple hello world application with Node.js on the user interface of IBM Bluemix Cloud and then execute/invoke it.</span></p>
<p>To create an OpenWhisk action, go through the following steps:</p>
<ol>
<li>Go to the<span> </span>OpenWhisk console at <a href="https://console.bluemix.net/openwhisk/">https://console.bluemix.net/openwhisk/</a> in the IBM Cloud.</li>
<li>Log into the IBM Cloud and click<span> </span><span class="packt_screen">Start Creating</span><span> </span>to use OpenWhisk from your browser and enter the editor.</li>
<li>Click<span> </span><span class="packt_screen">Create Action</span><span> from the multiple options</span>.</li>
</ol>
<ol start="4">
<li>Create a new action with the following parameters:</li>
</ol>
<div class="dataTables_wrapper no-footer">
<table border="1" style="border-collapse: collapse">
<thead>
<tr>
<th class="sorting_disabled" style="width: 156px">Field</th>
<th class="sorting_disabled" style="width: 177px">Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="width: 156px"><span class="packt_screen">Action Name</span></td>
<td style="width: 177px"><kbd>HelloWorld</kbd></td>
</tr>
<tr class="even">
<td style="width: 156px"><span><span class="packt_screen">Enclosing Package</span></span></td>
<td style="width: 177px"><span class="packt_screen">(Default Package)</span></td>
</tr>
<tr class="odd">
<td style="width: 156px"><span class="packt_screen">Runtime</span></td>
<td style="width: 177px"><span class="packt_screen">Node.js 6</span></td>
</tr>
</tbody>
</table>
</div>
<ol start="5">
<li> <span>Click </span><span class="packt_screen">Create</span><span>. This will open an editor interface for Nod</span><span>e.js.</span></li>
<li><span>By default, OpenWhisk actions are JavaScript. They receive an associative array in their input and return another as their output.<br/></span></li>
<li><span><span>Replace the existing Nodejs code with the following:</span></span></li>
</ol>
<pre style="padding-left: 60px">/**<br/>  *<br/>  * main() will be invoked when you Run This Action.<br/>  *<br/>  */<br/>function main(params) {<br/>    var myName;  <br/>    myName = params.name;<br/>    if (myName == undefined)<br/>        myName = "";     <br/>    return {<br/>        html: "&lt;b&gt;" + JSON.stringify(params) + "&lt;/b&gt;",<br/>        js: "alert('hello " + myName + "');"<br/>    };<br/>}</pre>
<ol start="8">
<li><span>Click on the</span> <strong><span class="packt_screen">Save</span></strong> button. T<span>his will save the action and redirect you to the page to invoke the action.</span></li>
<li>Let's click on <span class="packt_screen">Change Input</span> and add the following name input, and then click on the <span class="packt_screen">Apply </span>button: </li>
</ol>
<pre style="padding-left: 60px">{   <br/> "name": "Serverless"<br/>}</pre>
<ol start="10">
<li>Now let's click the <span><span class="packt_screen">Invoke</span> </span>button to execute the action/function. We should be able see the following output:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/d9931ef2-5492-404f-b7f6-ae2cf9505c46.png" style="width:45.00em;height:20.92em;"/></div>
<p>The output will be in the form of both JavaScript and HTML. In the preceding tutorial, we created an OpenWhisk action and deployed it through the Bluemix console. In the next section, we will use Serverless Framework to set up a deployment and automation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OpenWhisk with Serverless Framework</h1>
                </header>
            
            <article>
                
<p>To set up a deployment with Serverless Framework, we need to have a few things in place first. So, considering that you are already signed up, we need to retrieve the Bluemix endpoint and keys through the Bluemix CLI, and so first we need to set up and configure the Bluemix CLI, which can be done at <a href="https://console.bluemix.net/openwhisk/learn/cli" target="_blank">https://console.bluemix.net/openwhisk/learn/cli</a>.<a href="https://console.bluemix.net/OpenWhisk/learn/cli"/></p>
<p>Once the CLI is set up, we will then install the Cloud Function plugin through the Bluemix CLI, then log into Bluemix Cloud and deploy the action. Go through the following steps to do this:</p>
<ol>
<li class="mce-root"><span>First, we get the endpoint and authentication keys from the Bluemix portal using the following command:</span></li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>$ bx wsk property get --auth </strong><strong>whisk auth <br/>00700a7f-2b1a-4831-bf323a566263ed44:4TBcM7f8g0gj5UPgSVHXwNmMkfpbX36OdWximngOwqZYAJrDSkZwPjeSPjQ45Wm1</strong></pre>
<ol start="2">
<li>Once we get the authentication details through the preceding command, we can set <kbd>--apihost</kbd> and <kbd>--auth</kbd> through the <kbd>wsk</kbd> command line, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ wsk property set --apihost OpenWhisk.ng.bluemix.net --auth 00700a7f-2b1a-4831-bf32-3a566263ed44:4TBcM7f8g0gj5UPgSVHXwNmMkfpbX36OdWximngOwqZYAJrDSkZwPjeSPjQ45Wm1</strong><br/> <br/><strong>ok: whisk auth set. Run 'wsk property get --auth' to see the new value.</strong><br/><strong>ok: whisk API host set to OpenWhisk.ng.bluemix.net</strong></pre>
<p style="padding-left: 60px">Another way to get and set the keys would be through the portal. We can also configure the credentials through <kbd>bashrc</kbd> for the framework to use it. To do this, log into the Bluemix portal through the browser and go to the <span class="packt_screen">API Key</span> section the retrieve and then export them. So, let's log into the Bluemix portal at <a href="https://console.bluemix.net/openwhisk/">https://console.bluemix.net/openwhisk/</a>, then select the <span class="packt_screen">API Key</span> menu on the left-hand side bar to get the authentication keys, as shown in the following screenshot:<a href="https://console.bluemix.net/OpenWhisk/"/></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/df828d09-191a-4374-b170-59231e982687.png"/></div>
<ol start="3">
<li>Let's go to the Linux or macOS Terminal and add the authentication details to the user profile using the following code:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ vi ~/.bashrc</strong></pre>
<ol start="4">
<li>Copy the following export with the correct <kbd>auth</kbd> and <kbd>apihost</kbd> from the Bluemix portal:</li>
</ol>
<pre style="padding-left: 60px">export OW_AUTH=00700a7f-2b1a-4831-bf32-3a566263ed44:4TBcM7f8g0gj5UPgSVHXwNmMkfpbX36OdWximngOwqZYAJrDSkZwPjeSPjQ45Wm1<br/>export OW_APIHOST=OpenWhisk.eu-gb.bluemix.net</pre>
<ol start="5">
<li>The next step is to install Serverless Framework and the respective dependencies with the provider plugin, as shown in the following code:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ npm install --global serverless serverless-openwhisk</strong></pre>
<div class="packt_infobox"><span>The plugin has to be installed as a global module to work.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A simple OpenWhisk application</h1>
                </header>
            
            <article>
                
<p>Now let's create a simple service through the serverless Node.js template by going through the following steps:</p>
<ol>
<li><span class="hljs-comment">Create a new serverless service/project:</span></li>
</ol>
<pre style="padding-left: 60px"><strong>$ serverless create --template openwhisk-nodejs --path new-service</strong> </pre>
<ol start="2">
<li>Change into the newly created directory:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cd new-service</strong></pre>
<ol start="3">
<li>Install the npm dependencies:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ npm install</strong></pre>
<ol start="4">
<li>Once we finished, deploy the service and function to the Bluemix portal:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ serverless deploy -v</strong></pre>
<ol start="5">
<li>Then we invoke the function to check whether the function is deployed properly. Invoke the serverless application using the following code:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ serverless invoke --function hello</strong><br/><strong> {</strong><br/><strong> "payload": "Hello, World!"</strong><br/><strong> }</strong></pre>
<p>In the preceding tutorial, we got the <kbd>auth</kbd> keys, created an action, and deployed the function through Serverless Framework. In the next section, we will look into setting up CI and CD through different methodologies. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Continuous integration and continuous delivery with OpenWhisk</h1>
                </header>
            
            <article>
                
<p>For deployment, we will normally use the <kbd>wsk</kbd> command line. We will use it to do the following things: </p>
<ul>
<li>Git pull code from GitHub</li>
<li>Set up Bluemix space for running an app</li>
<li>Create the services for an application to run</li>
<li>Configure the environment variables, such as service credentials</li>
<li>Deploy OpenWhisk triggers and actions</li>
<li>Push the Node.js application</li>
</ul>
<p>We can do this with the IBM Bluemix toolchain or through open source tools, such as Jenkins and Serverless Framework. Let's look at both options, starting with the Bluemix toolchain. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the toolchain and repository integration</h1>
                </header>
            
            <article>
                
<p><span>Let's create a new blank toolchain by going through the following steps. This is easily done from the Bluemix home page at <a href="https://console.bluemix.net/devops/">https://console.bluemix.net/devops/</a></span><span>:</span></p>
<ol>
<li>Go to the preceding URL, and then click on <span class="packt_screen">Create a toolchain</span>. Then<span> you pick the</span> <span class="packt_screen"><span>B</span>uild your own toolchain</span> <span>template as shown in following screenshot, you give the toolchain a name, and you click </span><span class="packt_screen">Create</span><span>. Done!</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/943c0117-b171-42d0-8d7e-c65a6bb41a70.png" style="width:21.17em;height:10.42em;"/></div>
<ol start="2">
<li>You will redirected to the <span class="packt_screen">Build your own toolchain</span> page; fill in the details and click on the <span class="packt_screen">C</span><span class="packt_screen">reate </span><span>button</span><span>. </span></li>
<li><span>Once the toolchain is created, click on</span> <strong><span class="packt_screen">Add a Tool</span></strong><span>. Since the idea is to deploy it when the code is pushed to Git, the first thing to add is a</span><span class="packt_screen"><span> </span></span>GitHub <span>integration. So let's select</span> <span class="packt_screen">GitHub</span> <span>and then follow the steps. You will be prompted to authorize a GitHub account, and then give the URL of the repository you cloned earlier. Once this is done, an entry for your GitHub repository (and another for its issues, if you ticked that box) will appear in the toolchain, and we'll then add the deployment piece, which will respond to changes on our GitHub repository.</span></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the deployment</h1>
                </header>
            
            <article>
                
<p class="graf graf--p graf-after--h3">Next, click <span class="packt_screen">Add a Tool</span><span> </span>again to put a new entry into the pipeline, and then click <span class="packt_screen">Delivery Pipeline</span><span> </span>for the tool to add, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/21abbcfd-c8d9-493b-b52a-24ce4d29673c.png" style="width:44.83em;height:26.17em;"/></div>
<p class="graf graf--p graf-after--figure">Once the delivery pipeline tool is in place, click on it and then go ahead and click <span class="packt_screen">Add Stage</span>. There are three tabs at the top—<span class="packt_screen">Input</span>, <span class="packt_screen">Jobs</span>, and <span class="packt_screen">Environment properties</span>. These govern how the deployment activity itself is set up. Here's a quick overview of these tabs: </p>
<ul>
<li class="graf graf--p graf-after--figure"><span class="packt_screen">Input</span>:<span> This s</span>imply manages which repository and branch to use, and whether to run the deployment manually or change them as appropriate. </li>
<li class="graf graf--p graf-after--figure"><span class="packt_screen">Environment properties</span>: This manages the variables that we can use in our setup scripts. It's possible to add both plain text and a secret field. We can set the values that we will need here, such as database credentials, access tokens, and so on. This must include a Bluemix API key, which can be generated by using <kbd>bx iam api-key-create keyname</kbd>. In our case, we need to create a variable name<span> <kbd>APIKEY</kbd></span> , as shown in the following code:             </li>
</ul>
<pre style="padding-left: 60px"><strong> $ bx iam api-key-create myFunction</strong><br/><strong> Creating API key myFunction as user@email.com...</strong><br/><strong> OK</strong><br/><strong> API key myFunction was created</strong><br/><strong> Please preserve the API key! It cannot be retrieved after it's<br/> created.</strong><br/><strong> Name myFunction</strong><br/><strong> Description</strong><br/><strong> Created At 2018-02-24T19:16+0000</strong><br/><strong> API Key X4klg0XvNotJqN_haPWpPirPLhckCA9OFdZDufjcIxLY</strong></pre>
<ul class="postList">
<li class="graf graf--li graf-after--li"><span class="packt_screen">Jobs</span>: This tab is where the real work gets done. We'll use a single job, so click on <span class="packt_screen">ADD JOB</span>, type<span> </span><span class="packt_screen">Deploy, </span>and on the deployment page let's keep most of the details as their default settings, making sure that the account, organization, and space information looks correct.</li>
</ul>
<p class="graf graf--p graf-after--li">The following deploy job shell script will grab the Cloud Functions plugin for the<span> </span>command (find out more about the<span> </span>Bluemix command-line tool<span> in the documentation at <a href="https://console.bluemix.net/docs/cli/reference/bluemix_cli/get_started.html#getting-started">https://console.bluemix.net/docs/cli/reference/bluemix_cli/get_started.html#getting-started</a></span>), and then log in with the API key that we configured earlier and target the desired Bluemix organization and space. Add the following shell script to the <span class="packt_screen">Deploy Script</span> column of <span class="packt_screen">JOBS</span> and click on <span class="packt_screen">Save</span>: </p>
<pre>#!/bin/bash<br/>bx plugin install Cloud-Functions -r Bluemix -f<br/>#bx login -a https://api.ng.bluemix.net --apikey $APIKEY -o &lt;email_address&gt; -s development<br/>bx login -a api.eu-gb.bluemix.net --apikey $APIKEY -o &lt;email_address&gt; -s dev<br/># handy for debugging<br/>bx wsk action invoke /whisk.system/utils/echo -p message helloWorld --blocking --result<br/># now set up your actions etc<br/>zip helloWorld.zip index.js<br/>bx wsk action update helloWorld --kind nodejs:6 helloWorld.zip<br/># check everything is as expected<br/>bx wsk action list</pre>
<p class="graf graf--p graf-after--pre" style="color: black">After adding the Cloud Functions plugin to the Bluemix command-line tool, this script logs us in using the API key we created when configuring the deployment tool. Using the built in <kbd>/whisk.system/utils/echo</kbd> action will show us the output in the logs if everything is configured correctly to work with Cloud Functions, or cause a (hopefully helpful and informative) error if that's not the case. The <kbd>action update</kbd> command does the actual deployment, taking the newly zipped file and deploying it as an action. The final call to the action list simply shows us that the action is there as expected. </p>
<p class="graf graf--p graf-after--p" style="color: black">Check that everything works as expected by checking the green play button on this task, as depicted in the following screenshot. If it plays, you're all set!</p>
<div class="graf graf--p graf-after--p CDPAlignCenter CDPAlign" style="color: black"><img src="assets/cc26496c-315e-4263-b02f-6d7877b9054b.png"/></div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Continuous integration and continuous delivery with Serverless Framework</h1>
                </header>
            
            <article>
                
<p>Earlier, we set up continuous deployment using IBM Bluemix tools. Here, we will be using open source tools to set up continuous integration and continuous delivery for OpenWhisk functions. I will be setting up a Jenkins container with Serverless Framework installed on it. I have created a Dockerfile that does the heavy lifting for us by creating a Jenkins container with Node.js, Serverless Framework, and an OpenWhisk plugin installed. I have added this Dockerfile to the Git repository. We will be using the weather reporting OpenWhisk application, and we will code it, commit it on GitHub, and then deploy it on the Bluemix cloud through Serverless Framework. We will unit test the application and run a smoke test by invoking the function (see <a href="https://github.com/shzshi/OpenWhisk-weather-report-serverless.git">https://github.com/shzshi/OpenWhisk-weather-report-serverless.git</a>). Let's look at these steps in more detail:<a href="https://github.com/shzshi/OpenWhisk-weather-report-serverless.git"/></p>
<ol>
<li>Git clone the repository:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git clone https://github.com/shzshi/OpenWhisk-weather-report-serverless.git</strong></pre>
<ol start="2">
<li>Once it is successfully cloned, we need to build the OpenWhisk image using the following code: </li>
</ol>
<pre style="padding-left: 60px"><strong>$ docker build --rm -f OpenWhisk-weather-report-serverless/Dockerfile -t OpenWhisk-weather-report-serverless:latest OpenWhisk-weather-report-serverless</strong></pre>
<ol start="3">
<li>Once the Docker image is built, we will create a container for the <span><span><kbd>OpenWhisk-weather-report-serverless:latest</kbd></span></span> <span><span>image, using the following code: </span></span></li>
</ol>
<pre style="padding-left: 60px"><strong>$ docker run --rm -it -p 50000:50000 -p 8080:8080 -v /Users/HOST_PATH/OpenWhisk-weather-report-serverless/jenkins:/var/jenkins_home OpenWhisk-weather-report-serverless:latest</strong></pre>
<ol start="4">
<li>Now we will go to the browser, navigate to the Jenkins application, and create a job. As my Docker container is running on the localhost, my URL would be <kbd>http://localhost:8080/</kbd>.</li>
</ol>
<ol start="5">
<li>Open the Chrome/IE browser, paste the preceding localhost URL, and open Jenkins. At the first page, we will be asked for the administrator password. We can get this password from the logs of container run. It should look something like the following:</li>
</ol>
<pre style="padding-left: 60px"><strong>Jenkins initial setup is required. An admin user has been created and a password generated.</strong><br/><br/><strong>Please use the following password to proceed to installation: 7d4a4a91efb24f369bac95122686bd45</strong></pre>
<ol start="6">
<li>Once we enter the password, we will be asked to install a suggested plugin. Go ahead and do this. It will be a one-time activity, as we are saving the plugin on the Docker host, and once the plugin is added, we will be asked to create an admin user. Go ahead and create the user, and make sure that you remember the password. Then, once the user is created, go ahead and start using Jenkins.</li>
<li>Now let's create a job called <kbd>Serverless-OpenWhisk</kbd>. Click on <span class="packt_screen">New Item</span>; it will open a new page. Type in <kbd>Serverless-OpenWhisk</kbd> in the text box, select <span class="packt_screen">Freestyle project</span>, and click <span class="packt_screen">OK</span>.</li>
<li>Now select <span class="packt_screen">Git</span> in the <span class="packt_screen">Source Management</span> tab and add <kbd>https://github.com/shzshi/OpenWhisk-weather-report-serverless.git</kbd> in <span class="packt_screen">Repositories URL</span>. We won't feed in the credentials as this is a public repository. If we use the private GitHub repository, then we add can credentials for Jenkins to clone the repository.</li>
<li>Next, in the <span class="packt_screen">Build</span> tab in the <span class="packt_screen">Add build step</span> dropdown, select <span class="packt_screen">Execute shell</span>. A <span class="packt_screen">Command</span> text box will open up. Let's add the following code in the <span class="packt_screen">Execute shell</span> field. You need to replace the <span><kbd>OW_AUTH</kbd> and <kbd>OW_APIHOST</kbd> keys that are highlighted with one that we have created previously, or we can log into the OpenWhisk portal and get the details: </span></li>
</ol>
<pre style="padding-left: 60px">npm config set prefix '~/.npm-global'<br/>export PATH=~/.npm-global/bin:$PATH<br/>npm install<br/>./node_modules/mocha/bin/mocha test/test.js<br/>export OW_AUTH=00700a7f-2b1a-4831-bf32-3a566263ed44:4TBcM7f8g0gj5UPgSVHXwNmMkfpbX36OdWximngOwqZYAJrDSkZwPjeSPjQ45Wm1<br/>export OW_APIHOST=OpenWhisk.eu-gb.bluemix.net<br/>serverless deploy -v<br/>serverless invoke --function main -d '{"location":"Paris"}'</pre>
<ol start="10">
<li>Once that is done, save the job and then click on the <span class="packt_screen">Build Now</span> link. The job will then run. It will download and install the npm dependencies mentioned in <kbd>package.json</kbd>, then run the mocha unit test, deploy the action to the OpenWhisk cloud, and then invoke the function/action with a parameter to make sure that the deployment was successful. The output will look something like the following:</li>
</ol>
<pre class="console-output" style="padding-left: 60px">Building in workspace /var/jenkins_home/workspace/Serverless-OpenWhisk
Cloning the remote Git repository
Cloning repository https://github.com/shzshi/OpenWhisk-weather-report-serverless.git
 &gt; git init /var/jenkins_home/workspace/Serverless-OpenWhisk # timeout=10
Fetching upstream changes from https://github.com/shzshi/OpenWhisk-weather-report-serverless.git
 &gt; git --version # timeout=10
 &gt; git fetch --tags --progress https://github.com/shzshi/OpenWhisk-weather-report-serverless.git +refs/heads/*:refs/remotes/origin/*
 &gt; git config remote.origin.url https://github.com/shzshi/OpenWhisk-weather-report-serverless.git # timeout=10
 &gt; git config --add remote.origin.fetch +refs/heads/*:refs/remotes/origin/* # timeout=10
 &gt; git config remote.origin.url https://github.com/shzshi/OpenWhisk-weather-report-serverless.git # timeout=10
Fetching upstream changes from https://github.com/shzshi/OpenWhisk-weather-report-serverless.git
 &gt; git fetch --tags --progress https://github.com/shzshi/OpenWhisk-weather-report-serverless.git +refs/heads/*:refs/remotes/origin/*
 &gt; git rev-parse refs/remotes/origin/master^{commit} # timeout=10
 &gt; git rev-parse refs/remotes/origin/origin/master^{commit} # timeout=10
Checking out Revision af9511727c7610915701372a7d617e73a03825f5 (refs/remotes/origin/master)
 &gt; git config core.sparsecheckout # timeout=10
 &gt; git checkout -f af9511727c7610915701372a7d617e73a03825f5
Commit message: "updated jenkin host"
First time build. Skipping changelog.
[Serverless-OpenWhisk] $ /bin/sh -xe /tmp/jenkins660311873862513550.sh
+ npm config set prefix ~/.npm-global
+ export PATH=~/.npm-global/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+ npm install<br/>---<br/>---
Finished: SUCCESS</pre>
<p>This aim of this exercise was to show how we can set up continuous integration through Jenkins, Mocha, and Serverless Framework. In the next section, we will see how make it more robust, and learn how to set up a continuous delivery pipeline with the same set of tools. We will also set up automated deployment across the different environments using gates.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Continuous delivery pipeline to OpenWhisk</h1>
                </header>
            
            <article>
                
<p><span><strong>Continuous delivery</strong> is one of the essential features of DevOps. It not only helps in facilitating quicker deployment to production, but it also helps to create a bug-free application. We will be using Jenkins, Serverless Framework, and features of the OpenWhisk cloud to build a continuous delivery platform for OpenWhisk functions. We will be picking up the same weather system app that we built earlier with the freestyle job and enhance it to conform to the continuous delivery model. I have added the required files to the Git repository that I mentioned earlier in the chapter. By using </span><span>Jenkinsfile at the root, we define a multistage pipeline for this project. Jenkinsfile is a groovy script that is used by Jenkins to run pipelines.</span> <span>We will use master </span><span>branch to code for deploying and testing to various environments from the development stage all the way to production, provided that the deployment and tests passes within the pipeline.</span> <span>Integration tests run after each deployment (except production) and validate whether the deployed stack is functioning as expected</span><span>. The pipeline we are creating here will be using Jenkinsfile and Serverless Framework, creating multiple Cloud Foundry spaces for different environments, unit- testing sessions, and building promotions. Let's start with Cloud Foundry spaces by going through the following steps:<br/></span></p>
<ol>
<li>Log into Bluemix <a href="https://bluemix.net">at https://bluemix.net</a>.</li>
<li>Navigate to <span class="packt_screen">Manage</span> | <span class="packt_screen">Account</span> | <span class="packt_screen">Cloud Foundry Orgs</span>.</li>
<li>Click on the <span class="packt_screen">View details</span><strong> </strong>link and then on the link to add Cloud Foundry space. A popup should open.</li>
<li>Add four environments: development, SIT, preproduction, and production.</li>
</ol>
<p>Once the space is created, we will create API keys for the environment and push them as parameters in Jenkins to use them for deploying to different environments: </p>
<ol>
<li>Click on <span class="packt_screen">Three Line</span><strong> </strong>on the left-hand side of the Bluemix portal.</li>
<li>Then go to <span class="packt_screen">Functions</span> and click on it, and then click on the <span class="packt_screen">API Key </span>link.</li>
<li>We will copy the host and key for all environments. We can change and move to the environment from the <span class="packt_screen">CLOUD FOUNDRY SPACE </span>dropdown, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2ce833f4-a8b0-4f79-a527-35b65d51c1ba.png"/></div>
<p>Now we will move to Jenkins, where we will create a pipeline job. I have added the Jenkinsfile to the Git repository at <a href="https://github.com/shzshi/OpenWhisk-weather-report-serverless/blob/master/Jenkinsfile">https://github.com/shzshi/OpenWhisk-weather-report-serverless/blob/master/Jenkinsfile</a><span>, where we will use the same Git to set up the pipeline</span><span>.</span></p>
<p>We will use the same Jenkins Docker container that we created earlier in the previous tutorials. We will create a new job and work on it. Go through the following steps:</p>
<ol>
<li>Open Jenkins in the browser at <kbd>http://localhost:8080</kbd>. </li>
<li>Log into Jenkins and create a <span class="packt_screen">New item</span>. </li>
<li>Enter the item name as <kbd>OpenWhisk_serverless_pipeline</kbd>, select <span class="packt_screen">Pipeline</span>, and click <span class="packt_screen">OK</span>.</li>
<li>We will be redirected to another page, where we need to parameterize the pipeline with OpenWhisk <kbd>auth</kbd>, OpenWhisk <kbd>host</kbd>, and a Git path for the pipeline. For this, we will tick the <span class="packt_screen">This project is parameterised </span>checkbox.</li>
<li>Then, in the <span class="packt_screen">Add Parameter</span> dropdown, we need to select <span class="packt_screen">Credentials Parameter</span> as the parameter for the pipeline. The following screenshot shows the page for adding details into the credentials parameter. We have to add credentials parameters for all the environments that we created earlier in the chapter through the Azure portal. The <span class="packt_screen">Credential type</span> should be <span class="packt_screen">Secret text</span>, because this will help us to keep the authentication keys hidden, as they are passed as environment variables within the Jenkins pipeline. So, in total, we will create five credentials parameters: four for the different environments that are in development, SIT, preproduction, and production, and then the fifth for the OpenWhisk host. The secret text values should be populated from the Bluemix portal in the <span class="packt_screen">API Key</span><strong> </strong>section. The <span class="packt_screen">Default Value</span> should be filled by clicking the <span class="packt_screen">Add</span> button and then selecting J<span class="packt_screen">enkins</span>, which will help us to add <kbd>auth</kbd> keys into the Jenkins credentials provider. Look at the following screenshot for more information:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4cc41a30-e158-4ad1-85b7-b2804303e873.png" style="width:43.75em;height:56.50em;"/></div>
<ol start="6">
<li>We will set the credentials as <span class="packt_screen">Secret text</span>. Then the <span class="packt_screen">Secret</span> text box will be filled with the <span class="packt_screen">API Key</span> for each environment, which we can get from the Azure portal. Then the <span class="packt_screen">ID</span> and <span class="packt_screen">Description</span> fields would each be given a simple name, such as <kbd>OpenWhisk_DEV_AUTH</kbd>, as references, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1cb96237-1748-4d6b-b16a-9a9312e4329c.png" style="width:43.17em;height:22.83em;"/></div>
<ol start="7">
<li><span>Once all the parameters for each environment are added, we need to move to the</span> <span class="packt_screen">Pipeline</span> <span>tab and add the GitHub path. The following screenshot shows us adding the configuration for the Jenkins pipeline:</span></li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/f1ad4311-aede-4d51-95c8-c39cb269d3b3.png" style="text-align: center;color: black;font-size: 1em;width:51.33em;height:33.83em;"/></div>
<ol start="8">
<li>Once everything is set, then we need to run the job with the parameters. Once the job runs successfully, as shown in the following screenshot, Serverless Framework will package the functions files and they will be deployed on the different environments that we are testing through the serverless invoke:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/78b11044-f33e-4ae0-9de7-04d2bf122a6c.png" style="width:51.58em;height:26.42em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deployment patterns with OpenWhisk</h1>
                </header>
            
            <article>
                
<p>There are various deployment patterns available, but two patterns are quite popular in the DevOps world. One of them is canary and the other is blue–green. I tried my best to fit the serverless deployment to fit into this pattern, but there is always scope for improvement. Let's look at how we can fit OpenWhisk actions into these patterns. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Canary deployment</h1>
                </header>
            
            <article>
                
<p>The canary deployment pattern involves rolling out a new release in small chunks to subsets of users or servers. We then test it, and if it performs well, then we roll it out to the rest of the users or servers. The advantage here is that the percentage of failure is quite low, and we can analyze and fix the issues of the actions without disrupting all of the traffic. So, with respect to OpenWhisk, we can set <span>this</span><span> </span><span>up by using regions and routing a percentage of traffic to the newly released version into this region. If you do not want to create the region or organization, then you can set up a Cloud Foundry space as a </span><span><strong>disaster recovery</strong> (</span><strong>DR</strong><span>) environment on the Bluemix portal and shift the percentage of traffic into DR. The best part here is that if you discover that the released version is faulty, then you should be able to roll back to the previous version. </span></p>
<p>As of now, there is no provision to set up a percentage of the traffic to a specific action through the CLI or Serverless Framework. So we have to manually set this up through the action's code as we can do in Lambda. But once OpenWhisk matures further, we should see this feature added. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Blue–green deployment</h1>
                </header>
            
            <article>
                
<p>Although blue–green<span> </span>deployment is similar to canary deployment, the difference is that instead of routinizing the percentage of traffic, two separate identical environments are used in parallel to mitigate the risks of introducing new versions of <span>actions</span><span>. To do this, we create a new environment named staging. The production environment is used for going live and the staging environment is used for new changes. We then switch the environments back and forth between staging and production.</span></p>
<p>With respect to OpenWhisk, we can achieve this by creating a new staging environment using Cloud Foundry spaces. Then we deploy the current release version of our actions into the blue (production) environment and redirect traffic using an alias to the blue environment. Then, after the new versions of the actions are developed, we deploy them to the green (staging) environment for testing. Once the results of the testing are satisfactory, we redirect all the traffic to the green (staging) environment, and it is made live. Then the new version is deployed to the blue version for testing.</p>
<p>In case where the performance degrades or the release is buggy, we roll back the blue (go live) version to the current version and redirect the traffic again to blue and green environment becomes staging.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dynamic dashboard</h1>
                </header>
            
            <article>
                
<p>IBM Cloud has an out-of-the-box monitoring dashboard, which <span>provides a graphical summary of the function's invocation. It also helps to determine the performance and health of your Cloud Functions actions. The monitoring page is divided into three tabs—</span><span class="packt_screen"><span>A</span>ctivity Summary</span>, <span class="packt_screen">Activity Log</span>, and <span class="packt_screen">Activity Timeline</span>. L<span>et's look at each tab in more detail.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Activity Summary</h1>
                </header>
            
            <article>
                
<p class="style-scope doc-content">The <span class="packt_screen">Activity Summary</span> widget provides a high-level summary of the Cloud Functions environment. It helps us to understand and monitor the overall health and performance of the Cloud Functions-enabled service. The metrics provide us with the following details:</p>
<ul>
<li>The usage rate of the OpenWhisk actions, displaying the number of times they were invoked.</li>
<li>The overall rate of failure across all actions. We can spot an error and isolate the services that have the errors; we can do this using activity log widgets.</li>
<li>The performance of the actions, displaying the average completion time that is attached to each action.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Activity Timeline</h1>
                </header>
            
            <article>
                
<p class="style-scope doc-content">The<span> </span><span class="packt_screen">Activity Timeline</span><span> </span>widget shows a vertical bar graph that displays the activities of the <span class="packt_screen">Actions</span>. Red indicates errors within specific <span class="packt_screen">Actions</span>, and we can correlate this view with the<span> </span><span class="packt_screen">Activity Log</span><span> </span>to understand the exact error in the action.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Activity Log</h1>
                </header>
            
            <article>
                
<p class="style-scope doc-content">The <span class="packt_screen">Activity Log</span> widget displays activation logs in a format that we can use to view the details of every activation, as shown in the following screenshot. If we click on the <strong><span class="packt_screen">√</span></strong><strong> </strong>button to view the detailed log, then it will also display the time taken for each invocation as well as the date:</p>
<div class="style-scope doc-content CDPAlignCenter CDPAlign"><img src="assets/f059e0b1-740b-4f1d-86ff-255b00e3e766.png"/></div>
<p class="style-scope doc-content">We can also set up Hygiea as we did in previous chapter, and monitor the build, development, and testing of the OpenWhisk actions. We can also set up the deployment dashboard with Hygiea to track the deployment across different environments. As mentioned earlier, Hygiea would be an ideal dashboard to monitor DevOps' progress and performance. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OpenWhisk action logging management</h1>
                </header>
            
            <article>
                
<p><strong>Logging</strong> is pretty limited with serverless applications as there are no VMs, no OS, and no middleware packages. But we have to make the best use of what logging functionalities we do have in order to efficiently debug and resolve any issues we might have with OpenWhisk actions. The bright side is that we still have access to output logging for actions. So the only thing we have to do is it to push the files into Elasticsearch and index them for better use. We will be look at how to do this in this section.</p>
<p>We will be setting up ELK with Docker locally and pushing the OpenWhisk action logs into ELK. The OpenWhisk cloud has out-of-the-box ELK configuration, so we can view the aggregated logs on the portal itself. To do this, we need to log into the Bluemix portal. Go through the following steps:</p>
<ol>
<li>Log into the Bluemix portal at <a href="https://console.bluemix.net/">https://console.bluemix.net/</a>.</li>
<li>Click on the <span class="packt_screen">Functions </span>link; this will take you to the functions/actions portal. </li>
</ol>
<ol start="3">
<li>In the portal, click on <span class="packt_screen">Logs</span>. We will be taken to a page with a Kibana dashboard. There, we can search for the required logs. More details for viewing these logs can be followed at <a href="https://console.bluemix.net/docs/openwhisk/openwhisk_logs.html#viewing-activation-logs-in-the-ibm-cloud" target="_blank">https://console.bluemix.net/docs/openwhisk/openwhisk_logs.html#viewing-activation-logs-in-the-ibm-cloud</a>.</li>
</ol>
<p>However, it is quite expensive to maintain logs on the portal, and it is more difficult and costly to retain them for longer periods, so to save some infrastructure cost, we can pull the logs locally and retain them for a long period, and at much cheaper cost. Next, we will see how we can set up ELK locally and pull the logs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up ELK</h1>
                </header>
            
            <article>
                
<p>We will be setting up ELK locally using Docker. We have used Docker in many chapters, so it should be easy for us to set up ELK using it. We will be using the official Docker image that available on Docker Hub. We will be using <span>Elasticsearch 2.4.1, Logstash 2.4.0, and Kibana 4.6.1 for our setup. Enter the following command</span>:  </p>
<pre><strong>$ docker run -p 5601:5601 -p 5000:5000 -it --name elk sebp/elk:es241_l240_k461</strong></pre>
<p>The moment you run the preceding command, Docker will connect to Docker Hub, download the image, and then the container for the ELK stack will be created. Once the Docker container is loaded successfully, we should be able to access the Kibana dashboard through the browser using <kbd>localhost:5601</kbd>.</p>
<p>Now we need to <span>create a public hostname and port from the localhost port <kbd>5000</kbd>, for which we need to tunnel our localhost. For our example, we will use <a href="https://burrow.io">https://burrow.io</a></span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OpenWhisk actions</h1>
                </header>
            
            <article>
                
<p>We will be using the existing OpenWhisk action that we created earlier in the chapter. Let's log into the Bluemix portal. Go to <span class="packt_screen">Functions </span>|<span class="packt_screen">Actions</span> | <span class="packt_screen">On monitor</span>. We should be able to see the logs of the OpenWhisk functions/actions on the <span class="packt_screen">Activity Log</span> widget. We need to pull these logs on our local ELK. We will use the logs of the weatherReport <span>app for our example.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OpenWhisk log forwarder</h1>
                </header>
            
            <article>
                
<p>J Thomas has written an OpenWhisk forwarder, which is another OpenWhisk function. This function will push the OpenWhisk actions log to the local ELK stack. Let's see how this is done. First, we need to clone the public repository that he has created, make a few changes, and then deploy the function to the Bluemix portal for the particular space. This function will push the logs into the local ELK using burrow tunneled host and port: </p>
<ol>
<li>Git clone the <kbd>j thomas</kbd> repository using the following code:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git clone https://github.com/jthomas/OpenWhisk-logstash-forwarder.git</strong></pre>
<ol start="2">
<li>Export the OpenWhisk <kbd>auth</kbd> and <kbd>api</kbd> host for deploying to the Bluemix portal. You need to log into the portal to get the latest details using the following code:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ export OW_AUTH=00700a7f-2b1a-4831-bf32-3a566263ed44:4TBcM7f8g0gj5UPgSVHXwNmMkfpbX36OdWximngOwqZYAJrDSkZwPjeSPjQ45Wm1</strong><br/><strong>$ export OW_APIHOST=OpenWhisk.eu-gb.bluemix.net</strong> </pre>
<ol start="3">
<li>Install the serverless OpenWhisk plugin and the latest version of Serverless Framework (if it is not already installed) using the following code:</li>
</ol>
<pre style="padding-left: 60px"><br/><strong>$ npm install --global serverless serverless-openwhisk</strong><br/> <br/><strong>/usr/local/bin/serverless -&gt; /usr/local/lib/node_modules/serverless/bin/serverless</strong><br/><strong>/usr/local/bin/slss -&gt; /usr/local/lib/node_modules/serverless/bin/serverless</strong><br/><strong>/usr/local/bin/sls -&gt; /usr/local/lib/node_modules/serverless/bin/serverless</strong><br/><strong>&gt; serverless@1.26.1 postinstall /usr/local/lib/node_modules/serverless</strong><br/><strong>&gt; node ./scripts/postinstall.js</strong><br/><strong>serverless@1.26.1</strong><br/><strong> + serverless-OpenWhisk@0.12.0</strong><br/><strong> added 5 packages, removed 2 packages and updated 38 packages in 13.232s</strong></pre>
<ol start="4">
<li>Install the dependencies, as shown in the following code:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ npm install</strong><br/><strong> WARN registry Unexpected warning for https://registry.npmjs.org/: Miscellaneous Warning EINTEGRITY: sha512-lR3gD69osqm6EYLk9wB/G1W/laGWjzH90t1vEa2xuxHD5KUrSzp9pUSfTm+YC5Nxt2T8nMPEvKlhbQayU7bgFw== integrity checksum failed when using sha512: wanted sha512-lR3gD69osqm6EYLk9wB/G1W/laGWjzH90t1vEa2xuxHD5KUrSzp9pUSfTm+YC5Nxt2T8nMPEvKlhbQayU7bgFw== but got sha1-ygtl2gLtYpNYh4COb1EDgQNOM1Y=. (57090 bytes)</strong><br/><strong> ---<br/></strong><strong> ---<br/>&gt; fsevents@1.1.2 install /Users/shashi/Documents/packt/chapter5/ELK/OpenWhisk-logstash-forwarder/node_modules/fsevents</strong><br/><strong> &gt; node install</strong><br/><strong>[fsevents] Success: "/Users/shashi/Documents/packt/chapter5/ELK/OpenWhisk-logstash-forwarder/node_modules/fsevents/lib/binding/Release/node-v57-darwin-x64/fse.node" already installed</strong><br/><strong> Pass --update-binary to reinstall or --build-from-source to recompile</strong><br/><strong>&gt; OpenWhisk-logstash-forwarder@0.1.0 postinstall /Users/shashi/Documents/packt/chapter5/ELK/OpenWhisk-logstash-forwarder</strong><br/><strong> &gt; npm link serverless-OpenWhisk</strong><br/><strong>/Users/shashi/Documents/packt/chapter5/ELK/OpenWhisk-logstash-forwarder/node_modules/serverless-OpenWhisk -&gt; /usr/local/lib/node_modules/serverless-OpenWhisk</strong><br/><strong> added 606 packages in 9.933s  </strong><br/><br/><strong>Update available 5.5.1 → 5.8.0</strong><br/><strong>Run npm i -g npm to update</strong></pre>
<ol start="5">
<li>Deploy the action with serverless, as shown in the following code:</li>
</ol>
<pre style="padding-left: 60px"><strong> $ serverless deploy</strong><br/><strong> Serverless: Packaging service...</strong><br/><strong> Serverless: Excluding development dependencies...</strong><br/><strong> Serverless: Compiling Functions...</strong><br/><strong> Serverless: Compiling Packages...</strong><br/><strong> Serverless: Compiling API Gateway definitions...</strong><br/><strong> Serverless: Compiling Rules...</strong><br/><strong> Serverless: Compiling Triggers &amp; Feeds...</strong><br/><strong> Serverless: Deploying Functions...</strong><br/><strong> Serverless: Deploying Triggers...</strong><br/><strong> Serverless: Binding Feeds To Triggers...</strong><br/><strong> Serverless: Deploying Rules...</strong><br/><strong> Serverless: Deployment successful!<br/><br/></strong> <strong>Service Information</strong><br/><strong> platform: OpenWhisk.eu-gb.bluemix.net</strong><br/><strong> namespace: _</strong><br/><strong> service: logging</strong><br/><strong>packages:</strong><br/><strong> no packages deployed<br/>actions:</strong><br/><strong> logging-dev-logstash-forwarder myTEST weatherReport-dev-main</strong><br/><strong>triggers:</strong><br/><strong> logging_logstash-forwarder_schedule_trigger</strong><br/><strong>rules:</strong><br/><strong> logging_logstash-forwarder_schedule_rule</strong><br/><strong>endpoints (api-gw):</strong><br/><strong> **failed to fetch routes**</strong><br/><strong> api gateway key is wrong or has expired! if it has expired, please refresh with wsk bluemix login<br/>endpoints (web actions):</strong><br/><strong> no web actions deployed</strong></pre>
<p>Once the action or function is successfully deployed, we will see the logs following your local ELK stack, and we should be able to view them. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about what OpenWhisk is and looked into the various ways to simplify build, deploy, monitor, and log OpenWhisk functions. We also learned how to set up continuous delivery and created a pipeline to do this.</p>
<p>In the next chapter, we will learn about Google functions, look at what they are and how to start using simple functions to set up an automated pipeline with the Serverless Framework and other open source tools. </p>


            </article>

            
        </section>
    </body></html>