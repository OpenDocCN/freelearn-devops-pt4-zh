- en: Integrating DevOps with IBM OpenWhisk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be looking at OpenWhisk, which is an open source on-cloud
    serverless provider. We will also be learning how to build, test, and deploy OpenWhisk
    functions, as well as how to manage logs and monitor the functions. We will also
    look at the best practices for DevOps with OpenWhisk.
  prefs: []
  type: TYPE_NORMAL
- en: OpenWhisk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**OpenWhisk** is an incubator project of Apache and IBM. It offers an open
    source and on-cloud  serverless platform through the IBM Bluemix portal. We can
    set this up on premises or directly use the cloud model. The commercial side of 
    OpenWhisk is provided by IBM on Bluemix, and the open source version can be provisioned
    as on-premises **I****nfrastructure as a Service** (**IaaS**), as well as on a
    cloud, such as Bluemix, Amazon EC2, Microsoft Azure, or GCP. The open source version
    is available on GitHub. It is been made public through the Apache license, and
    people can contribute to it.'
  prefs: []
  type: TYPE_NORMAL
- en: For the open source OpenWhisk version on GitHub, go to [https://github.com/apache/incubator-openwhisk/tree/master/docs#getting-started-with-openwhisk](https://github.com/apache/incubator-openwhisk/tree/master/docs#getting-started-with-openwhisk).
  prefs: []
  type: TYPE_NORMAL
- en: Like any other serverless offering, OpenWhisk executes small chunks of codes
    that are called **actions** (that is, functions**)** at the triggering of events.
    Events can originate from Bluemix or external sources. It is also claimed by OpenWhisk
    that it allows the integration of a home-grown event provider, or any other event
    provider, rather than being limited to specific ones, as other serverless service
    providers do.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenWhisk provides many features, such as autoscaling and load balancing, out
    of the box without having to manually configure clusters, load balancers, and
    HTTP plugins. Let''s look at the architecture diagram for OpenWhisk:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d15e8d94-eca9-4013-b37d-b95902459b62.png)'
  prefs: []
  type: TYPE_IMG
- en: The actions/functions are performed at the triggering of events, which could
    be changes to database records, IoT sensor readings, code commits to a GitHub
    repository, or simple HTTP requests from web or mobile apps. Events from these
    sources are channelled through a trigger, and rules within the triggers allow
    actions to react to these events.
  prefs: []
  type: TYPE_NORMAL
- en: '**Action** is an OpenWhisk term for functions. Actions could be small snippets
    of JavaScript or Swift code, or custom binary code embedded in a Docker container.'
  prefs: []
  type: TYPE_NORMAL
- en: Actions are normally invoked in a sequence, and output from one action can be
    passed as input to the next action in the sequence. Actions can be invoked through
    multiple sources, such as the OpenWhisk API, CLI, and iOS SDK, in addition to
    triggers.
  prefs: []
  type: TYPE_NORMAL
- en: The languages supported by OpenShift are Node.js, Python, Swift, Java, and PHP,
    and it is claimed by OpenShift that one of their USPs supports the Swift language,
    which will come in handy while writing functions or actions for mobile apps.
  prefs: []
  type: TYPE_NORMAL
- en: Services and event provider integrations can be performed using packages. A
    **package** is a bundle of feeds and actions. A **feed** is a piece of code that
    configures an external event source to fire trigger events. For example, in a
    bank account transaction, a trigger is created when a debit or credit event takes
    place and a function/action will run to send the SMS to the user about the transaction
    that has taken place. The actions in the packages have reusable logic that service
    providers make available for the people to use the service. These service providers
    are event sources, and they can also be invoked through the API.
  prefs: []
  type: TYPE_NORMAL
- en: OpenWhisk is built on NGINX, Kafka, Docker, and CouchDB. All of these components
    work together to make a serverless service for OpenWhisk.
  prefs: []
  type: TYPE_NORMAL
- en: OpenWhisk setup and configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenWhisk operates four important concepts, which are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Triggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Triggers** are like events that are created by data sources. Some examples
    include changing database records, new code commits to your repository, and HTTP
    requests from a web/mobile app. The events from the sources are channeled through
    a trigger.'
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **action** is a snippet of code written in Node.js or Swift, or embedded
    in Docker containers. The code is deployed and is executed at the firing of the
    trigger.
  prefs: []
  type: TYPE_NORMAL
- en: Rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Rules** form a part of the triggers when combined with an action. So every
    time the trigger fires, the respective action is invoked by the rule.'
  prefs: []
  type: TYPE_NORMAL
- en: Sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chains of actions are called **sequences**. We can chain the actions, and
    they will be invoked in order. The output of one action can become the input for
    the next action.
  prefs: []
  type: TYPE_NORMAL
- en: Building an OpenWhisk application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, I will not be setting up an open source version of OpenWhisk.
    Instead, we will be using tutorials through the Bluemix portal, so to do this,
    we need to sign up to the Bluemix portal. They give new members the option of
    a free subscription for a month. So let's register with Bluemix at [https://bluemix.net](https://bluemix.net). As
    I mentioned earlier, IBM Bluemix comes with a free trial that doesn't need credit
    card details for the first 30 days. Following the trial, we do not have to enroll
    using a credit card. All the users get access to around 400,000 GB-seconds of
    serverless computing time per month. Additional execution time would be charged
    at $0.000017 per GB-second of execution, rounded to the nearest 100 ms.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a hello world OpenWhisk action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The prerequisites for this tutorial is an IBM cloud account (free trial) and
    knowledge of Node.js (which we have used throughout the book). We will be starting
    with a simple example first and then move towards applying automation to the tutorial
    code as we go on with the chapter. So, let's create a simple hello world application
    with Node.js on the user interface of IBM Bluemix Cloud and then execute/invoke
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an OpenWhisk action, go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the OpenWhisk console at [https://console.bluemix.net/openwhisk/](https://console.bluemix.net/openwhisk/) in
    the IBM Cloud.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log into the IBM Cloud and click Start Creating to use OpenWhisk from your browser
    and enter the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Create Action from the multiple options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new action with the following parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Field | Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Action Name | `HelloWorld` |'
  prefs: []
  type: TYPE_TB
- en: '| Enclosing Package | (Default Package) |'
  prefs: []
  type: TYPE_TB
- en: '| Runtime | Node.js 6 |'
  prefs: []
  type: TYPE_TB
- en: Click Create. This will open an editor interface for Node.js.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, OpenWhisk actions are JavaScript. They receive an associative array
    in their input and return another as their output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the existing Nodejs code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Save** button. This will save the action and redirect you to
    the page to invoke the action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s click on Change Input and add the following name input, and then click
    on the Apply button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s click the Invoke button to execute the action/function. We should
    be able see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d9931ef2-5492-404f-b7f6-ae2cf9505c46.png)'
  prefs: []
  type: TYPE_IMG
- en: The output will be in the form of both JavaScript and HTML. In the preceding
    tutorial, we created an OpenWhisk action and deployed it through the Bluemix console.
    In the next section, we will use Serverless Framework to set up a deployment and
    automation.
  prefs: []
  type: TYPE_NORMAL
- en: OpenWhisk with Serverless Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To set up a deployment with Serverless Framework, we need to have a few things
    in place first. So, considering that you are already signed up, we need to retrieve
    the Bluemix endpoint and keys through the Bluemix CLI, and so first we need to
    set up and configure the Bluemix CLI, which can be done at [https://console.bluemix.net/openwhisk/learn/cli](https://console.bluemix.net/openwhisk/learn/cli).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the CLI is set up, we will then install the Cloud Function plugin through
    the Bluemix CLI, then log into Bluemix Cloud and deploy the action. Go through
    the following steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we get the endpoint and authentication keys from the Bluemix portal
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we get the authentication details through the preceding command, we can
    set `--apihost` and `--auth` through the `wsk` command line, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to get and set the keys would be through the portal. We can also
    configure the credentials through `bashrc` for the framework to use it. To do
    this, log into the Bluemix portal through the browser and go to the API Key section
    the retrieve and then export them. So, let''s log into the Bluemix portal at [https://console.bluemix.net/openwhisk/](https://console.bluemix.net/openwhisk/),
    then select the API Key menu on the left-hand side bar to get the authentication
    keys, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df828d09-191a-4374-b170-59231e982687.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s go to the Linux or macOS Terminal and add the authentication details
    to the user profile using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the following export with the correct `auth` and `apihost` from the Bluemix
    portal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to install Serverless Framework and the respective dependencies
    with the provider plugin, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The plugin has to be installed as a global module to work.
  prefs: []
  type: TYPE_NORMAL
- en: A simple OpenWhisk application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s create a simple service through the serverless Node.js template
    by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new serverless service/project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Change into the newly created directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the npm dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we finished, deploy the service and function to the Bluemix portal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we invoke the function to check whether the function is deployed properly.
    Invoke the serverless application using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding tutorial, we got the `auth` keys, created an action, and deployed
    the function through Serverless Framework. In the next section, we will look into
    setting up CI and CD through different methodologies.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration and continuous delivery with OpenWhisk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For deployment, we will normally use the `wsk` command line. We will use it
    to do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Git pull code from GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up Bluemix space for running an app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the services for an application to run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure the environment variables, such as service credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy OpenWhisk triggers and actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Push the Node.js application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can do this with the IBM Bluemix toolchain or through open source tools,
    such as Jenkins and Serverless Framework. Let's look at both options, starting
    with the Bluemix toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the toolchain and repository integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a new blank toolchain by going through the following steps. This
    is easily done from the Bluemix home page at [https://console.bluemix.net/devops/](https://console.bluemix.net/devops/):'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the preceding URL, and then click on Create a toolchain. Then you pick
    the Build your own toolchain template as shown in following screenshot, you give
    the toolchain a name, and you click Create. Done!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/943c0117-b171-42d0-8d7e-c65a6bb41a70.png)'
  prefs: []
  type: TYPE_IMG
- en: You will redirected to the Build your own toolchain page; fill in the details
    and click on the Create button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the toolchain is created, click on **Add a Tool**. Since the idea is to
    deploy it when the code is pushed to Git, the first thing to add is a GitHub integration.
    So let's select GitHub and then follow the steps. You will be prompted to authorize a
    GitHub account, and then give the URL of the repository you cloned earlier. Once
    this is done, an entry for your GitHub repository (and another for its issues,
    if you ticked that box) will appear in the toolchain, and we'll then add the deployment
    piece, which will respond to changes on our GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring the deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, click Add a Tool again to put a new entry into the pipeline, and then
    click Delivery Pipeline for the tool to add, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21abbcfd-c8d9-493b-b52a-24ce4d29673c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the delivery pipeline tool is in place, click on it and then go ahead
    and click Add Stage. There are three tabs at the top—Input, Jobs, and Environment
    properties. These govern how the deployment activity itself is set up. Here''s
    a quick overview of these tabs:'
  prefs: []
  type: TYPE_NORMAL
- en: Input: This simply manages which repository and branch to use, and whether to
    run the deployment manually or change them as appropriate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Environment properties: This manages the variables that we can use in our setup
    scripts. It''s possible to add both plain text and a secret field. We can set
    the values that we will need here, such as database credentials, access tokens,
    and so on. This must include a Bluemix API key, which can be generated by using `bx
    iam api-key-create keyname`. In our case, we need to create a variable name `APIKEY`
    , as shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Jobs: This tab is where the real work gets done. We''ll use a single job, so
    click on ADD JOB, type Deploy, and on the deployment page let''s keep most of
    the details as their default settings, making sure that the account, organization,
    and space information looks correct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following deploy job shell script will grab the Cloud Functions plugin
    for the command (find out more about the Bluemix command-line tool in the documentation
    at [https://console.bluemix.net/docs/cli/reference/bluemix_cli/get_started.html#getting-started](https://console.bluemix.net/docs/cli/reference/bluemix_cli/get_started.html#getting-started)),
    and then log in with the API key that we configured earlier and target the desired
    Bluemix organization and space. Add the following shell script to the Deploy Script
    column of JOBS and click on Save:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: After adding the Cloud Functions plugin to the Bluemix command-line tool, this
    script logs us in using the API key we created when configuring the deployment
    tool. Using the built in `/whisk.system/utils/echo` action will show us the output
    in the logs if everything is configured correctly to work with Cloud Functions,
    or cause a (hopefully helpful and informative) error if that's not the case. The `action
    update` command does the actual deployment, taking the newly zipped file and deploying
    it as an action. The final call to the action list simply shows us that the action
    is there as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Check that everything works as expected by checking the green play button on
    this task, as depicted in the following screenshot. If it plays, you're all set!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc26496c-315e-4263-b02f-6d7877b9054b.png)'
  prefs: []
  type: TYPE_IMG
- en: Continuous integration and continuous delivery with Serverless Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier, we set up continuous deployment using IBM Bluemix tools. Here, we
    will be using open source tools to set up continuous integration and continuous
    delivery for OpenWhisk functions. I will be setting up a Jenkins container with
    Serverless Framework installed on it. I have created a Dockerfile that does the
    heavy lifting for us by creating a Jenkins container with Node.js, Serverless
    Framework, and an OpenWhisk plugin installed. I have added this Dockerfile to
    the Git repository. We will be using the weather reporting OpenWhisk application,
    and we will code it, commit it on GitHub, and then deploy it on the Bluemix cloud
    through Serverless Framework. We will unit test the application and run a smoke
    test by invoking the function (see [https://github.com/shzshi/OpenWhisk-weather-report-serverless.git](https://github.com/shzshi/OpenWhisk-weather-report-serverless.git)).
    Let''s look at these steps in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Git clone the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it is successfully cloned, we need to build the OpenWhisk image using
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the Docker image is built, we will create a container for the `OpenWhisk-weather-report-serverless:latest` image,
    using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now we will go to the browser, navigate to the Jenkins application, and create
    a job. As my Docker container is running on the localhost, my URL would be `http://localhost:8080/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the Chrome/IE browser, paste the preceding localhost URL, and open Jenkins.
    At the first page, we will be asked for the administrator password. We can get
    this password from the logs of container run. It should look something like the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Once we enter the password, we will be asked to install a suggested plugin. Go
    ahead and do this. It will be a one-time activity, as we are saving the plugin
    on the Docker host, and once the plugin is added, we will be asked to create an
    admin user. Go ahead and create the user, and make sure that you remember the
    password. Then, once the user is created, go ahead and start using Jenkins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's create a job called `Serverless-OpenWhisk`. Click on New Item; it
    will open a new page. Type in `Serverless-OpenWhisk` in the text box, select Freestyle
    project, and click OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now select Git in the Source Management tab and add `https://github.com/shzshi/OpenWhisk-weather-report-serverless.git` in Repositories
    URL. We won't feed in the credentials as this is a public repository. If we use
    the private GitHub repository, then we add can credentials for Jenkins to clone
    the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, in the Build tab in the Add build step dropdown, select Execute shell.
    A Command text box will open up. Let''s add the following code in the Execute
    shell field. You need to replace the `OW_AUTH` and `OW_APIHOST` keys that are
    highlighted with one that we have created previously, or we can log into the OpenWhisk
    portal and get the details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once that is done, save the job and then click on the Build Now link. The job
    will then run. It will download and install the npm dependencies mentioned in
    `package.json`, then run the mocha unit test, deploy the action to the OpenWhisk
    cloud, and then invoke the function/action with a parameter to make sure that
    the deployment was successful. The output will look something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This aim of this exercise was to show how we can set up continuous integration
    through Jenkins, Mocha, and Serverless Framework. In the next section, we will
    see how make it more robust, and learn how to set up a continuous delivery pipeline
    with the same set of tools. We will also set up automated deployment across the
    different environments using gates.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery pipeline to OpenWhisk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous delivery** is one of the essential features of DevOps. It not
    only helps in facilitating quicker deployment to production, but it also helps
    to create a bug-free application. We will be using Jenkins, Serverless Framework,
    and features of the OpenWhisk cloud to build a continuous delivery platform for
    OpenWhisk functions. We will be picking up the same weather system app that we
    built earlier with the freestyle job and enhance it to conform to the continuous
    delivery model. I have added the required files to the Git repository that I mentioned
    earlier in the chapter. By using Jenkinsfile at the root, we define a multistage
    pipeline for this project. Jenkinsfile is a groovy script that is used by Jenkins to
    run pipelines. We will use master branch to code for deploying and testing to
    various environments from the development stage all the way to production, provided
    that the deployment and tests passes within the pipeline. Integration tests run
    after each deployment (except production) and validate whether the deployed stack
    is functioning as expected. The pipeline we are creating here will be using Jenkinsfile
    and Serverless Framework, creating multiple Cloud Foundry spaces for different
    environments, unit- testing sessions, and building promotions. Let''s start with
    Cloud Foundry spaces by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log into Bluemix [at https://bluemix.net](https://bluemix.net).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to Manage | Account | Cloud Foundry Orgs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the View detailslink and then on the link to add Cloud Foundry space.
    A popup should open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add four environments: development, SIT, preproduction, and production.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the space is created, we will create API keys for the environment and
    push them as parameters in Jenkins to use them for deploying to different environments:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on Three Lineon the left-hand side of the Bluemix portal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then go to Functions and click on it, and then click on the API Key link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will copy the host and key for all environments. We can change and move
    to the environment from the CLOUD FOUNDRY SPACE dropdown, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2ce833f4-a8b0-4f79-a527-35b65d51c1ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we will move to Jenkins, where we will create a pipeline job. I have added
    the Jenkinsfile to the Git repository at [https://github.com/shzshi/OpenWhisk-weather-report-serverless/blob/master/Jenkinsfile](https://github.com/shzshi/OpenWhisk-weather-report-serverless/blob/master/Jenkinsfile),
    where we will use the same Git to set up the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the same Jenkins Docker container that we created earlier in the
    previous tutorials. We will create a new job and work on it. Go through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Jenkins in the browser at `http://localhost:8080`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log into Jenkins and create a New item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the item name as `OpenWhisk_serverless_pipeline`, select Pipeline, and
    click OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will be redirected to another page, where we need to parameterize the pipeline
    with OpenWhisk `auth`, OpenWhisk `host`, and a Git path for the pipeline. For
    this, we will tick the This project is parameterised checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, in the Add Parameter dropdown, we need to select Credentials Parameter
    as the parameter for the pipeline. The following screenshot shows the page for
    adding details into the credentials parameter. We have to add credentials parameters
    for all the environments that we created earlier in the chapter through the Azure
    portal. The Credential type should be Secret text, because this will help us to
    keep the authentication keys hidden, as they are passed as environment variables
    within the Jenkins pipeline. So, in total, we will create five credentials parameters:
    four for the different environments that are in development, SIT, preproduction,
    and production, and then the fifth for the OpenWhisk host. The secret text values
    should be populated from the Bluemix portal in the API Keysection. The Default
    Value should be filled by clicking the Add button and then selecting Jenkins,
    which will help us to add `auth` keys into the Jenkins credentials provider. Look
    at the following screenshot for more information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4cc41a30-e158-4ad1-85b7-b2804303e873.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will set the credentials as Secret text. Then the Secret text box will be
    filled with the API Key for each environment, which we can get from the Azure
    portal. Then the ID and Description fields would each be given a simple name,
    such as `OpenWhisk_DEV_AUTH`, as references, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1cb96237-1748-4d6b-b16a-9a9312e4329c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once all the parameters for each environment are added, we need to move to
    the Pipeline tab and add the GitHub path. The following screenshot shows us adding
    the configuration for the Jenkins pipeline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f1ad4311-aede-4d51-95c8-c39cb269d3b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once everything is set, then we need to run the job with the parameters. Once
    the job runs successfully, as shown in the following screenshot, Serverless Framework
    will package the functions files and they will be deployed on the different environments
    that we are testing through the serverless invoke:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/78b11044-f33e-4ae0-9de7-04d2bf122a6c.png)'
  prefs: []
  type: TYPE_IMG
- en: Deployment patterns with OpenWhisk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are various deployment patterns available, but two patterns are quite
    popular in the DevOps world. One of them is canary and the other is blue–green.
    I tried my best to fit the serverless deployment to fit into this pattern, but
    there is always scope for improvement. Let's look at how we can fit OpenWhisk
    actions into these patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Canary deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The canary deployment pattern involves rolling out a new release in small chunks
    to subsets of users or servers. We then test it, and if it performs well, then
    we roll it out to the rest of the users or servers. The advantage here is that
    the percentage of failure is quite low, and we can analyze and fix the issues
    of the actions without disrupting all of the traffic. So, with respect to OpenWhisk,
    we can set this up by using regions and routing a percentage of traffic to the
    newly released version into this region. If you do not want to create the region
    or organization, then you can set up a Cloud Foundry space as a **disaster recovery**
    (**DR**) environment on the Bluemix portal and shift the percentage of traffic
    into DR. The best part here is that if you discover that the released version
    is faulty, then you should be able to roll back to the previous version.
  prefs: []
  type: TYPE_NORMAL
- en: As of now, there is no provision to set up a percentage of the traffic to a
    specific action through the CLI or Serverless Framework. So we have to manually
    set this up through the action's code as we can do in Lambda. But once OpenWhisk
    matures further, we should see this feature added.
  prefs: []
  type: TYPE_NORMAL
- en: Blue–green deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although blue–green deployment is similar to canary deployment, the difference
    is that instead of routinizing the percentage of traffic, two separate identical
    environments are used in parallel to mitigate the risks of introducing new versions
    of actions. To do this, we create a new environment named staging. The production
    environment is used for going live and the staging environment is used for new
    changes. We then switch the environments back and forth between staging and production.
  prefs: []
  type: TYPE_NORMAL
- en: With respect to OpenWhisk, we can achieve this by creating a new staging environment
    using Cloud Foundry spaces. Then we deploy the current release version of our
    actions into the blue (production) environment and redirect traffic using an alias
    to the blue environment. Then, after the new versions of the actions are developed,
    we deploy them to the green (staging) environment for testing. Once the results
    of the testing are satisfactory, we redirect all the traffic to the green (staging)
    environment, and it is made live. Then the new version is deployed to the blue
    version for testing.
  prefs: []
  type: TYPE_NORMAL
- en: In case where the performance degrades or the release is buggy, we roll back
    the blue (go live) version to the current version and redirect the traffic again
    to blue and green environment becomes staging.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IBM Cloud has an out-of-the-box monitoring dashboard, which provides a graphical
    summary of the function's invocation. It also helps to determine the performance
    and health of your Cloud Functions actions. The monitoring page is divided into
    three tabs—Activity Summary, Activity Log, and Activity Timeline. Let's look at
    each tab in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Activity Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Activity Summary widget provides a high-level summary of the Cloud Functions
    environment. It helps us to understand and monitor the overall health and performance
    of the Cloud Functions-enabled service. The metrics provide us with the following
    details:'
  prefs: []
  type: TYPE_NORMAL
- en: The usage rate of the OpenWhisk actions, displaying the number of times they
    were invoked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The overall rate of failure across all actions. We can spot an error and isolate
    the services that have the errors; we can do this using activity log widgets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The performance of the actions, displaying the average completion time that
    is attached to each action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activity Timeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Activity Timeline widget shows a vertical bar graph that displays the activities
    of the Actions. Red indicates errors within specific Actions, and we can correlate
    this view with the Activity Log to understand the exact error in the action.
  prefs: []
  type: TYPE_NORMAL
- en: Activity Log
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Activity Log widget displays activation logs in a format that we can use
    to view the details of every activation, as shown in the following screenshot.
    If we click on the **√**button to view the detailed log, then it will also display
    the time taken for each invocation as well as the date:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f059e0b1-740b-4f1d-86ff-255b00e3e766.png)'
  prefs: []
  type: TYPE_IMG
- en: We can also set up Hygiea as we did in previous chapter, and monitor the build,
    development, and testing of the OpenWhisk actions. We can also set up the deployment
    dashboard with Hygiea to track the deployment across different environments. As
    mentioned earlier, Hygiea would be an ideal dashboard to monitor DevOps' progress
    and performance.
  prefs: []
  type: TYPE_NORMAL
- en: OpenWhisk action logging management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Logging** is pretty limited with serverless applications as there are no
    VMs, no OS, and no middleware packages. But we have to make the best use of what
    logging functionalities we do have in order to efficiently debug and resolve any
    issues we might have with OpenWhisk actions. The bright side is that we still
    have access to output logging for actions. So the only thing we have to do is
    it to push the files into Elasticsearch and index them for better use. We will
    be look at how to do this in this section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be setting up ELK with Docker locally and pushing the OpenWhisk action
    logs into ELK. The OpenWhisk cloud has out-of-the-box ELK configuration, so we
    can view the aggregated logs on the portal itself. To do this, we need to log
    into the Bluemix portal. Go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log into the Bluemix portal at [https://console.bluemix.net/](https://console.bluemix.net/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Functions link; this will take you to the functions/actions portal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the portal, click on Logs. We will be taken to a page with a Kibana dashboard.
    There, we can search for the required logs. More details for viewing these logs
    can be followed at [https://console.bluemix.net/docs/openwhisk/openwhisk_logs.html#viewing-activation-logs-in-the-ibm-cloud](https://console.bluemix.net/docs/openwhisk/openwhisk_logs.html#viewing-activation-logs-in-the-ibm-cloud).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, it is quite expensive to maintain logs on the portal, and it is more
    difficult and costly to retain them for longer periods, so to save some infrastructure
    cost, we can pull the logs locally and retain them for a long period, and at much
    cheaper cost. Next, we will see how we can set up ELK locally and pull the logs.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up ELK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be setting up ELK locally using Docker. We have used Docker in many
    chapters, so it should be easy for us to set up ELK using it. We will be using
    the official Docker image that available on Docker Hub. We will be using Elasticsearch
    2.4.1, Logstash 2.4.0, and Kibana 4.6.1 for our setup. Enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The moment you run the preceding command, Docker will connect to Docker Hub,
    download the image, and then the container for the ELK stack will be created.
    Once the Docker container is loaded successfully, we should be able to access
    the Kibana dashboard through the browser using `localhost:5601`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to create a public hostname and port from the localhost port `5000`,
    for which we need to tunnel our localhost. For our example, we will use [https://burrow.io](https://burrow.io).
  prefs: []
  type: TYPE_NORMAL
- en: OpenWhisk actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using the existing OpenWhisk action that we created earlier in the
    chapter. Let's log into the Bluemix portal. Go to Functions |Actions | On monitor.
    We should be able to see the logs of the OpenWhisk functions/actions on the Activity
    Log widget. We need to pull these logs on our local ELK. We will use the logs
    of the weatherReport app for our example.
  prefs: []
  type: TYPE_NORMAL
- en: OpenWhisk log forwarder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'J Thomas has written an OpenWhisk forwarder, which is another OpenWhisk function.
    This function will push the OpenWhisk actions log to the local ELK stack. Let''s
    see how this is done. First, we need to clone the public repository that he has
    created, make a few changes, and then deploy the function to the Bluemix portal
    for the particular space. This function will push the logs into the local ELK
    using burrow tunneled host and port:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Git clone the `j thomas` repository using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Export the OpenWhisk `auth` and `api` host for deploying to the Bluemix portal.
    You need to log into the portal to get the latest details using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the serverless OpenWhisk plugin and the latest version of Serverless
    Framework (if it is not already installed) using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the dependencies, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploy the action with serverless, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Once the action or function is successfully deployed, we will see the logs following
    your local ELK stack, and we should be able to view them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about what OpenWhisk is and looked into the various
    ways to simplify build, deploy, monitor, and log OpenWhisk functions. We also
    learned how to set up continuous delivery and created a pipeline to do this.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about Google functions, look at what they
    are and how to start using simple functions to set up an automated pipeline with
    the Serverless Framework and other open source tools.
  prefs: []
  type: TYPE_NORMAL
