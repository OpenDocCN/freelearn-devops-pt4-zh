- en: DevOps with Google Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Google Functions 的 DevOps
- en: Google decided to launch its serverless platform as Cloud Functions, but it
    is still in its maturing stage. At the time of writing this book, we can only
    write Google Cloud Functions with Node.js. The functions can be triggered through
    Google's internal event bus—Pub/Sub and through HTTP as mobile events from Firebase.
    I am not going to delve much into what Google Functions does, because we have
    already covered that in earlier chapters. So, in this chapter, we will be covering
    how we apply DevOps to Google Functions and what are the best practices of deployment,
    release management, monitoring, and logging. We will look into various examples
    and a demo with a `gcloud` command line, Serverless Framework, and Jenkins. So,
    let's jump in to DevOps.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Google 决定将其无服务器平台推出为 Cloud Functions，但它仍处于成熟阶段。在写这本书时，我们只能使用 Node.js 编写 Google
    Cloud Functions。这些函数可以通过 Google 内部的事件总线——Pub/Sub 和通过 HTTP 作为来自 Firebase 的移动事件触发。我不会深入讨论
    Google Functions 的功能，因为我们在前面的章节中已经讲解过了。因此，在本章中，我们将讨论如何将 DevOps 应用于 Google Functions，以及部署、发布管理、监控和日志记录的最佳实践。我们将通过
    `gcloud` 命令行、Serverless Framework 和 Jenkins 进行各种示例和演示。好了，让我们进入 DevOps 主题。
- en: CI and CD pipelines with Google Functions
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Google Functions 的 CI 和 CD 流水线
- en: As Google currently allows coding only with JavaScript, we will be using Node.js
    throughout this book, with examples and demos. Google terms its serverless functions
    as Cloud Functions, so we will be using this term throughout this chapter. So,
    Cloud Functions are to be written in JavaScript and executed in Node.js v6.11.5
    (at the time of writing this book) and the cloud function source must be exported
    in a Node.js module. The module will be loaded using a `require()` call. So, functions
    are contained within an `index.js` file. We can invoke the function from HTTP
    request methods such as `GET`, `POST`, `PUT`, `OPTIONS`, and `DELETE`. The deployment
    can be done through a command-line tool provided by Google Cloud CLI, through
    the cloud function UI on a GCP console, and can also be done through a serverless
    framework. We will be looking into each way throughout this chapter. The deployable
    is a ZIP file, which has functions packaged into it, and it is deployed on the
    Google Cloud storage bucket. Functions source code can be directly put into Cloud
    Functions as well, or we can reference it by uploading to the Google Cloud storage
    bucket. Let's look at various way to deploy function and further automate it through
    the Jenkins pipeline.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Google 目前只允许使用 JavaScript 编写代码，因此我们将在本书中使用 Node.js，并提供示例和演示。Google 将其无服务器函数称为
    Cloud Functions，因此我们将在本章中始终使用这个术语。因此，Cloud Functions 需要用 JavaScript 编写，并在 Node.js
    v6.11.5（在写这本书时）中执行，且云函数的源代码必须以 Node.js 模块形式导出。该模块将通过 `require()` 调用加载。因此，函数都包含在一个
    `index.js` 文件中。我们可以通过 HTTP 请求方法（如 `GET`、`POST`、`PUT`、`OPTIONS` 和 `DELETE`）来调用该函数。部署可以通过
    Google Cloud CLI 提供的命令行工具、GCP 控制台上的云函数 UI 或通过无服务器框架来完成。在本章中，我们将探讨每种方式。可部署的文件是一个
    ZIP 文件，其中包含打包的函数，并部署到 Google Cloud 存储桶中。函数的源代码也可以直接放入 Cloud Functions，或者通过上传到
    Google Cloud 存储桶来引用它。让我们看看如何通过 Jenkins 流水线进一步自动化函数的部署。
- en: Prerequisites for Cloud Functions
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云函数的前提条件
- en: 'Let''s look at how to create and deploy a Cloud Function using the GCP console.
    But before that prerequisite, we need to have access to the Google Function platform.
    At the time of writing, Google provides a free GCP account with $300 credit for
    a year to use for any product on the GCP. So let''s create one. Please follow
    the given steps:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何使用 GCP 控制台创建和部署云函数。但在此之前，我们需要先访问 Google Cloud Functions 平台。在写这本书时，Google
    提供了一个免费的 GCP 账户，内含 300 美元的信用额度，有效期为一年，可用于 GCP 上的任何产品。接下来让我们创建一个。请按照以下步骤操作：
- en: Go to the following link: [https://cloud.google.com/free/](https://cloud.google.com/free/).
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问以下链接：[https://cloud.google.com/free/](https://cloud.google.com/free/)。
- en: Click on the TRY IT FREE button, which will be redirected to the Google account
    page. If you already have a Google account, you can then use it or create a new
    Google account.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“免费试用”按钮，页面将重定向到 Google 账户页面。如果您已经有 Google 账户，可以直接使用它，或者创建一个新的 Google 账户。
- en: Feed in the credentials and you will be redirected to the GCP home page.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入凭据后，您将被重定向到 GCP 首页。
- en: As the account is already created, let's create a GCP project. So go to the MANAGE
    RESOURCES PAGE([https://console.cloud.google.com/cloud-resource-manager](https://console.cloud.google.com/cloud-resource-manager)).
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于帐户已创建，我们将创建一个 GCP 项目。请前往“管理资源页面”([https://console.cloud.google.com/cloud-resource-manager](https://console.cloud.google.com/cloud-resource-manager))。
- en: We will now create a project, so let's click on Create Project, enter the project
    name as `My Serverless Project` and click on Create. You will see that the project
    is getting created in the notification bell image on the top right-hand side of
    the page. Once it has stopped, refresh the page and you will see the project in
    the list.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将创建一个项目，点击“创建项目”，输入项目名称为 `My Serverless Project` 并点击“创建”。您将在页面右上角的通知铃铛图标中看到项目正在创建。创建完成后，刷新页面，您将看到该项目出现在列表中。
- en: 'Now enable the cloud API for the project by opening the link: [https://console.cloud.google.com/flows/enableapiapiid=cloudfunctions&redirect=https://cloud.google.com/functions/quickstart](https://console.cloud.google.com/flows/enableapi?apiid=cloudfunctions&redirect=https://cloud.google.com/functions/quickstart).
    The page will have a drop-down list for projects. Select My Serverless Project
    and click on Continue; then API will be enabled for the project.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过打开链接启用项目的云 API：[https://console.cloud.google.com/flows/enableapi?apiid=cloudfunctions&redirect=https://cloud.google.com/functions/quickstart](https://console.cloud.google.com/flows/enableapi?apiid=cloudfunctions&redirect=https://cloud.google.com/functions/quickstart)。页面会显示一个下拉列表，供您选择项目。选择“我的无服务器项目”并点击“继续”，然后该
    API 将为项目启用。
- en: 'We will now install and configure the Google Cloud SDK. The following link
    will guide you through this: [https://cloud.google.com/sdk/docs/](https://cloud.google.com/sdk/docs/).
    While doing the `gcloud init`, you will be prompted to select the project. Select
    the project My Serverless Project which we created, and we will be authenticated
    with GCP as well.'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将安装并配置 Google Cloud SDK。以下链接将引导您完成此过程：[https://cloud.google.com/sdk/docs/](https://cloud.google.com/sdk/docs/)。在执行
    `gcloud init` 时，您将被提示选择项目。选择我们创建的项目“我的无服务器项目”，并且我们也将完成 GCP 认证。
- en: Set up the Node.js environment.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 Node.js 环境。
- en: Cloud Functions through the GCP console
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 GCP 控制台使用云函数
- en: 'We will now create a cloud function through the GCP console:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将通过 GCP 控制台创建云函数：
- en: Go to the Cloud Functions overview page in the GCP console, select the project
    from the drop-down list for which the function is attached.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 GCP 控制台中的云函数概览页面，从下拉列表中选择关联的项目。
- en: Click on Create Function.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击创建函数。
- en: Name the function as `my-serverless-function`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将函数命名为 `my-serverless-function`。
- en: Select the trigger as an HTTP trigger.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择触发器为 HTTP 触发器。
- en: 'Let''s use the default code, so it should be checked by an inline editor. The
    text area will have two scripts, one is `index.js` and the other is `package.json`.
    This is a simple `helloworld` function provided by Google Functions. The function
    logs a message which you provide in a later step. When you finish the steps you
    will see something similar to the following screenshot:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用默认代码，因此它应该由内联编辑器检查。文本区域中会有两个脚本，一个是 `index.js`，另一个是 `package.json`。这是 Google
    Functions 提供的一个简单的 `helloworld` 函数。该函数会记录您在后续步骤中提供的消息。完成步骤后，您将看到类似下面的截图：
- en: '![](img/b7c56459-ac0a-4339-932f-35351b4a5b05.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7c56459-ac0a-4339-932f-35351b4a5b05.png)'
- en: Click on the Create button. Now the function will be deployed and the GCP console
    redirects to the Overview page. While the function is being deployed, the icon
    next to it is a small spinner. After deployment is complete, the spinner turns
    to a green check mark.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击创建按钮。现在，功能将被部署，GCP 控制台将重定向到“概览”页面。在功能部署过程中，旁边的图标是一个小的旋转图标。部署完成后，旋转图标将变为绿色勾号。
- en: 'We will test the function. Click on the three vertical dots on the right-hand
    side of the page for the particular function and click on the Test function:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将测试该功能。点击页面右侧特定功能旁边的三个竖点，然后点击“测试功能”：
- en: '![](img/725e0903-84b5-468d-b09c-e13add91db1d.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/725e0903-84b5-468d-b09c-e13add91db1d.png)'
- en: 'We will be redirected to a function test page. In the Triggered Event field,
    replace the text with `{"message":"Hello World!"}` and click on Test function.
    In the Output field we should see the Success: Hello World!. and in the Logs field
    the status code 200 will indicate that the function ran successfully. We can see
    detailed logs by clicking on the arrow for each log.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们将被重定向到一个函数测试页面。在触发事件字段中，将文本替换为 `{"message":"Hello World!"}` 并点击“测试函数”。在输出字段中，我们应该看到
    `Success: Hello World!`，在日志字段中，状态码 200 表示函数运行成功。我们可以通过点击每个日志的箭头查看详细日志。'
- en: 'We can see the logs history by click on VIEW LOGS on top right. So, this is
    how we create and deploy the function through the GCP console and also view the
    function logs and their history:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过点击右上角的“查看日志”来查看日志历史。因此，这就是我们通过 GCP 控制台创建和部署函数，并查看函数日志及其历史的方式：
- en: '![](img/49b170dc-c885-47cb-9b63-168d19285b4f.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49b170dc-c885-47cb-9b63-168d19285b4f.png)'
- en: Cloud Function using a gcloud command line
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `gcloud` 命令行部署云函数
- en: 'In this part of this chapter, we will be deploying the `helloworld` application
    through the `gcloud` command line. First, we need to have created a GCP project
    through the Manage resources page, enabled the Cloud Function API as a prerequisite,
    and, most importantly, to have installed the `gcloud` SDK locally:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的这一部分，我们将通过 `gcloud` 命令行部署 `helloworld` 应用程序。首先，我们需要通过“管理资源”页面创建一个 GCP 项目，启用云函数
    API 作为前提条件，最重要的是，已经在本地安装了 `gcloud` SDK：
- en: 'Let''s update the `gcloud` components. Go to your Command Prompt and add the
    following command. You will be prompted to install components using the `gcloud beta` commands.
    Go ahead and install them. The `gcloud` selected components will be installed
    and configured locally:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更新 `gcloud` 组件。打开命令提示符，输入以下命令。你将被提示使用 `gcloud beta` 命令安装组件。安装后，`gcloud` 选中的组件将被安装并在本地配置：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can follow the deployment steps with Google Cloud Shell ([https://console.cloud.google.com/?cloudshell=true](https://console.cloud.google.com/?cloudshell=true))
    as well. Google Cloud Shell is a command-line environment with `gcloud` SDK on
    the GCP console.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 Google Cloud Shell 来跟随部署步骤（[https://console.cloud.google.com/?cloudshell=true](https://console.cloud.google.com/?cloudshell=true)）。Google
    Cloud Shell 是一个命令行环境，GCP 控制台中预装了 `gcloud` SDK。
- en: 'Let''s create a function for this. We need to create a directory where our
    function will reside:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为此创建一个函数。我们需要创建一个目录，以便我们的函数放置在其中：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s create a file `index.js` in the `helloServerless` directory with the
    following content:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `helloServerless` 目录下创建一个文件 `index.js`，并填入以下内容：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will deploy the function using the following command. It will deploy the
    function into the GCP. The `--trigger-http`is the trigger we need to be specified.
    While deploying with the trigger, the function will be assigned an endpoint which
    can viewed by using the `describe` command. There are various different triggers
    which can be used for deployment:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用以下命令部署函数。该命令会将函数部署到 GCP 中。`--trigger-http` 是我们需要指定的触发器。通过此触发器部署时，函数将分配一个端点，可以使用
    `describe` 命令查看该端点。部署时可以使用多种不同的触发器：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the function has successfully deployed, we can execute the function through
    the URL property from the deployment output, or we can get the URL through the
    following command:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦函数成功部署，我们可以通过部署输出中的 URL 属性执行该函数，或者通过以下命令获取 URL：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Copy, paste, and run the URL on any browser and then we should be able to see
    the following message:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制、粘贴并运行 URL，在任何浏览器中打开后，我们应该能够看到以下信息：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, you can see how easy it is to deploy the function through `gcloud` on the
    GCP. But how do we make sure we unit test it, integrate test, and finally automate
    the deployment? That is what we are going to cover further on in the chapter.
    But we can do most of this locally by setting up a development environment.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如此，你可以看到通过 `gcloud` 在 GCP 上部署函数是多么简单。但我们如何确保对其进行单元测试、集成测试，最终实现自动化部署呢？这就是我们将在本章后续部分讨论的内容。不过，大部分工作我们可以通过设置本地开发环境来完成。
- en: Building and testing locally
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地构建和测试
- en: 'As the Cloud Functions run on a `Node.js` environment, we can build and test
    our application locally just using a `Node.js` emulator with development tools.
    The emulator is an open source and code is hosted on the GitHub. Let''s look at
    how to use it:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于云函数运行在 `Node.js` 环境中，我们可以仅使用带有开发工具的 `Node.js` 模拟器在本地构建和测试应用程序。该模拟器是开源的，代码托管在
    GitHub 上。让我们看看如何使用它：
- en: 'Install the emulator through npm or Yarn; you need to make sure you have `Node.js`
    installed on your machine:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 npm 或 Yarn 安装模拟器；你需要确保机器上已安装 `Node.js`：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s start the emulator. This command will start the emulator and wait for
    the prompt:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们启动模拟器。此命令将启动模拟器并等待提示：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Deploy the function locally; so go into a folder before the function folder
    and run the following command:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地部署函数；在函数文件夹之前进入一个文件夹并运行以下命令：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Open the URL mentioned in the output in the browser. You should see the message
    `Hello My Serverless World!` ; or execute it through the command line:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开输出中提到的 URL 在浏览器中查看。你应该看到消息 `Hello My Serverless World!`；或者通过命令行执行：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Also, you can see the following logs:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，你还可以查看以下日志：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: More details for the emulator can be found in the link below. We can integrate
    the emulator with the our favorite development tools and debug the Google Functions: [https://github.com/GoogleCloudPlatform/cloud-functions-emulator](https://github.com/GoogleCloudPlatform/cloud-functions-emulator).
    For debugging Cloud Functions:[https://github.com/GoogleCloudPlatform/cloud-functions-emulator/wiki/Debugging-functions](https://github.com/GoogleCloudPlatform/cloud-functions-emulator/wiki/Debugging-functions).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有关模拟器的更多细节可以在以下链接中找到。我们可以将模拟器与我们最喜欢的开发工具集成，并调试 Google 函数：[https://github.com/GoogleCloudPlatform/cloud-functions-emulator](https://github.com/GoogleCloudPlatform/cloud-functions-emulator)。关于调试
    Cloud Functions：[https://github.com/GoogleCloudPlatform/cloud-functions-emulator/wiki/Debugging-functions](https://github.com/GoogleCloudPlatform/cloud-functions-emulator/wiki/Debugging-functions)。
- en: CI and CD with testing
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成和持续部署（CI/CD）与测试
- en: Until now, we have just created a function and come up with a couple of ways
    to build and deploy. We have also learned how to run the function locally through
    emulator. But we cannot manually build and deploy every function each time, and
    we should also be versioning the code. We will looking into all those aspects
    within this part of the chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是创建了一个函数，并提出了几种构建和部署的方法。我们还学会了如何通过模拟器在本地运行函数。但是，我们不能每次手动构建和部署每个函数，而且我们还应该对代码进行版本控制。在本部分的章节中，我们将深入探讨这些方面。
- en: Source code management
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码管理
- en: '**Source code management** is a very important part of software development.
    It is always best to version and tag the code. Git is the most popular source
    code management tool, and we have been using it throughout this chapter. So, for
    a perfect deployment cycle, we should always create different branches. These
    are feature branch, develop branch, release branch, and then we have the default
    master branch. I have already covered best practice around this in earlier chapters,
    so I won''t talk here about the structuring of branches and how code flow across
    branches is managed. However, it is important to about the folder structure to
    be followed for Cloud Functions. In earlier chapters, we wrote function in `index.js`.
    If functions are limited then they can easily be managed within `index.js`. But
    if we have hundreds of functions then managing them within one file becomes really
    tedious and painful. So, one simple way to structure the functions would be as
    follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**源代码管理**是软件开发中非常重要的一部分。最佳做法是对代码进行版本控制和标签管理。Git 是最流行的源代码管理工具，我们在本章中一直在使用它。因此，为了实现完美的部署周期，我们应该始终创建不同的分支。包括功能分支、开发分支、发布分支，以及默认的主分支。我在之前的章节中已经讲解了有关最佳实践的内容，因此在这里不再讨论分支结构以及代码在分支间的流动管理。然而，关于
    Cloud Functions 的文件夹结构是非常重要的。在之前的章节中，我们将函数写在了 `index.js` 中。如果函数数量较少，完全可以将它们管理在
    `index.js` 文件中。但如果函数数量达到几百个，那么将它们集中在一个文件中管理就会变得非常繁琐和痛苦。因此，组织函数的一种简单方式如下所示：'
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are many ways to structure it, but I have kept it simple. However, I would
    let the developer decide over the structure.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化的方式有很多种，但我保持了简单。然而，我会让开发者自行决定结构。
- en: Continuous integration and testing
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成与测试
- en: 'Continuous integration and testing are other important aspects of the development
    cycle. Continuous integration clubs the codes together, and testing will make
    sure that the code which goes into production is bug free, and that most of the
    issues are mitigated in a lower environment. There are many different way of testing:
    unit testing, integration testing and system testing. We will be integrating this
    testing in an automated pipeline in the example. I will be using the examples
    provided by Google Cloud with a simple `hello world` function, and running them
    in an automated way, and then putting them into a pipeline for single-touch deployment.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成和测试是开发周期中另一个重要方面。持续集成将代码合并在一起，测试确保进入生产环境的代码没有错误，并且大多数问题在低环境中得到解决。测试有许多不同的方式：单元测试、集成测试和系统测试。我们将在示例中将这些测试集成到自动化流水线中。我将使用谷歌云提供的示例和一个简单的`hello
    world`函数，自动化运行它们，然后将它们放入流水线进行一键部署。
- en: 'I have created a `HelloWorld` function referencing from Google''s existing
    example repository. I have put them on my local repository, which we will be using
    for setting continuous integration and testing. I have also created a Dockerfile,
    which will help us to create a docker container for Jenkins, pre-installed `gcloud`,
    Node.js and the functions emulator which we will be using to set up our DevOps
    automation:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经创建了一个`HelloWorld`函数，参考了谷歌现有的示例代码库。我已将其放入我的本地代码库中，我们将使用这个库来设置持续集成和测试。我还创建了一个Dockerfile，它将帮助我们创建一个用于Jenkins的Docker容器，容器中预安装了`gcloud`、Node.js和我们将在设置DevOps自动化时使用的函数模拟器：
- en: 'Git clone the Git repository mentioned as follows. We are cloning this locally
    to get the Dockerfile, and you can play around with it by making changes to the
    script and testing the deployment:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆以下提到的Git代码库。我们将其克隆到本地，以获取Dockerfile，你可以通过修改脚本并测试部署进行尝试：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will build a Docker image locally and then start a Jenkins portal to enable
    us to set up the automation. You need to make sure Docker is installed on your
    local machine for this example.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在本地构建一个Docker镜像，然后启动Jenkins门户，以便我们能够设置自动化。你需要确保在本地机器上安装了Docker，以便运行此示例。
- en: 'We move to the Dockerfile directory:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们进入Dockerfile目录：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We create a Docker image with Jenkins, `gcloud`, a function emulator, Node.js
    and all other required libraries:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个包含Jenkins、`gcloud`、函数模拟器、Node.js和所有其他所需库的Docker镜像：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, run the Docker container with the image  created in the previous line.
    The Docker container will be hosted locally with port `8080` and `50000` exposed.
    We will also map the volume with a local host directory:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，运行前一行创建的Docker容器。Docker容器将在本地托管，暴露`8080`和`50000`端口。我们还将与本地主机目录映射卷：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once the container is running, we will browse the Jenkins portal through `http://localhost:8080`.
    If you are creating this container for the first time without mapped volume, you
    will be asked to copy and paste the password and install a default plugin.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦容器运行，我们将通过`http://localhost:8080`浏览Jenkins门户。如果这是第一次创建此容器且未映射卷，你将被要求复制并粘贴密码并安装默认插件。
- en: Log in to the Jenkins portal using the credentials you had created earlier,
    or you already had. Then click on New Item.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前创建的凭证登录Jenkins门户，或者使用已有的凭证。然后点击New Item。
- en: Enter the item name as `my-serverless-google-functions`, select the freestyle
    project and then click on OK.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入项目名称为`my-serverless-google-functions`，选择freestyle项目，然后点击OK。
- en: 'Go to the tab Source Code Management and select Git, then copy and paste the
    repository mentioned below into the Repository URL textbox and leave the rest
    as default: [https://github.com/shzshi/google-functions-helloworld.git](https://github.com/shzshi/google-functions-helloworld.git)[.](https://github.com/shzshi/google-functions-helloworld.git)'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入Source Code Management标签页，选择Git，然后将下面提到的代码库URL复制并粘贴到Repository URL文本框中，其他保持默认：[https://github.com/shzshi/google-functions-helloworld.git](https://github.com/shzshi/google-functions-helloworld.git)
- en: 'We need to create a Google service account for `gcloud` within Jenkins to authenticate
    with GCP:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在Jenkins中为`gcloud`创建一个Google服务账户，以便与GCP进行身份验证：
- en: Go to the OPEN THE LIST OF CREDENTIALS ([https://console.cloud.google.com/apis/credentials?_ga=2.77044693.-1734735492.1524930885](https://console.cloud.google.com/apis/credentials?_ga=2.77044693.-1734735492.1524930885))
    page
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问OPEN THE LIST OF CREDENTIALS页面 ([https://console.cloud.google.com/apis/credentials?_ga=2.77044693.-1734735492.1524930885](https://console.cloud.google.com/apis/credentials?_ga=2.77044693.-1734735492.1524930885))
- en: Click on Create Credentials
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击Create Credentials
- en: Select the Service Account Key
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择 Service Account Key
- en: Click on the drop-down for Service accountand select New Service Account
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击下拉菜单中的 Service account，并选择 New Service Account
- en: Enter a name for the service account in Name
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Name 中输入服务账户名称
- en: Use the default Service account ID or generate a different one
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用默认的服务账户 ID 或生成一个不同的 ID
- en: 'Select the Key type: JSON'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择密钥类型：JSON
- en: Click Create, the Service account created window is displayed, and the private
    key for the Key type you selected is downloaded automatically to our local machine
    which we will be using further.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击创建，显示服务账户创建窗口，并且您选择的密钥类型的私钥会自动下载到本地计算机，我们将在后续使用它。
- en: Click Close
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击关闭
- en: You need to fork your repository and copy the content of the `gcloud` service
    account key JSON file into the file `My-Serverless-Project-1d8bacd4886d.json`,because
    we will be using this JSON file in Jenkins to authenticate: [https://github.com/shzshi/google-functions-helloworld.git](https://github.com/shzshi/google-functions-helloworld.git).
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要分叉您的代码库，并将 `gcloud` 服务账户密钥 JSON 文件的内容复制到文件 `My-Serverless-Project-1d8bacd4886d.json`
    中，因为我们将在 Jenkins 中使用此 JSON 文件进行身份验证：[https://github.com/shzshi/google-functions-helloworld.git](https://github.com/shzshi/google-functions-helloworld.git)。
- en: 'Go to the Build tab, and from the drop-down menu''s Add build stepselect Execute
    Shell and then add the following steps into the Command text area:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 Build 选项卡，在下拉菜单的 Add build step 中选择 Execute Shell，然后将以下步骤添加到 Command 文本区域：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We need to parameterize the job, which means that we need to add two text parameters,
    one for the `gcloud` project id and another for the `gcloud` region. Add the parameters
    as mentioned in the following screenshot. The **Default Value** needs to be changed
    with your project name and region:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要对作业进行参数化，这意味着我们需要添加两个文本参数，一个是 `gcloud` 项目 ID，另一个是 `gcloud` 区域。按照以下截图添加参数。**默认值**需要更改为您的项目名称和区域：
- en: '![](img/de053287-d843-4dd4-ab7a-b0ee18a83465.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de053287-d843-4dd4-ab7a-b0ee18a83465.png)'
- en: Once everything looks fine, as mentioned in the previous 13 steps, click SAVE,
    and save the project.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一切看起来正常后，按照前面 13 个步骤中的说明，点击 SAVE，保存项目。
- en: To run the job, click Build with Parameters and run the job with a default parameter.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行作业，请点击 Build with Parameters 并使用默认参数运行作业。
- en: 'If the job runs successfully, we should see the following output and therefore
    Google Function has successfully passed the unit, integration and system tests:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果作业成功运行，我们应该看到以下输出，因此 Google Function 已成功通过单元测试、集成测试和系统测试：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So, through the previous example, we were able to build, test and deploy the
    function locally and on `gcloud`. But we did this just randomly on a project.
    Imagine that we need to have multiple environments, and performance systems, and
    performance testing with very minimal manual intervention. We need to set up a
    pipeline with approval gates which deploys to multiple environments, mitigating
    most of the problems before the function is actually in production. This is where
    continuous delivery comes in handy.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，通过前面的示例，我们能够在本地和 `gcloud` 上构建、测试和部署函数。但我们只是随意地在一个项目上做了这一切。想象一下，如果我们需要有多个环境、性能系统和性能测试，并且尽可能减少手动干预，我们需要设置一个包含审批环节的管道，将函数部署到多个环境，在函数实际投入生产之前解决大部分问题。这就是持续交付发挥作用的地方。
- en: Continuous delivery with Google Functions
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Google Functions 进行持续交付
- en: '**Continuous delivery** is about removing risk, delivering frequently and getting
    fast feedback, and it helps speed up the time to get the product to market. So,
    how do we do that for Cloud Functions? There are many ways of doing it, but I
    would like to use a serverless framework to achieve this. There are couple of
    reason for this. One reason for this is that a serverless framework is a very
    mature framework for serverless functions deployment. It supports many different
    vendors, as we have seen, and also has good community support. We can achieve
    continuous delivery even through `gcloud` and the Jenkins pipeline. We will be
    reusing most of the setup which we used in previous sections of this chapter.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续交付**是通过 减少风险、频繁交付并快速反馈，帮助加速产品上市的过程。那么，如何在 Google Cloud Functions 上做到这一点呢？有很多方法可以做到这一点，但我想使用无服务器框架来实现这一目标。这样做有几个原因。其中一个原因是，无服务器框架是一个非常成熟的无服务器功能部署框架。它支持许多不同的供应商，正如我们所看到的，并且有很好的社区支持。我们甚至可以通过
    `gcloud` 和 Jenkins 管道来实现持续交付。我们将重用本章前面部分中使用的大部分设置。'
- en: Google environments
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google 环境
- en: 'It is essential to have multiple environments for setting up continuous delivery
    for any type of application. But for a serverless world, there is no clear demarcation
    for the environment. So we always have to come up with alternatives. We have to
    do the same for Cloud Functions. We set up environment separation in two ways—first,
    we could separate the functions for the environment with separate names, for example,
    `my-serverless-dev`, `my-serverless-sit` or `my-serverless-prod`, but this will
    add unnecessary complications. So, the ideal way would be to separate the environment
    by creating a different project, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为任何类型的应用程序设置持续交付时，拥有多个环境是至关重要的。但对于无服务器架构，环境的划分并不明确。因此，我们总是需要想出替代方案。我们对 Cloud
    Functions 也需要做同样的事情。我们通过两种方式设置环境分离——首先，我们可以为环境使用不同的名称来分隔功能，例如 `my-serverless-dev`、`my-serverless-sit`
    或 `my-serverless-prod`，但这会增加不必要的复杂性。因此，理想的方式是通过创建不同的项目来分隔环境，如下所示：
- en: Log on to the GCP console, go to the **Manage Resource Page** ([https://console.cloud.google.com/cloud-resource-manager?_ga=2.108039562.-900655901.1524348645](https://console.cloud.google.com/cloud-resource-manager?_ga=2.108039562.-900655901.1524348645)),
    click on **CREATE PROJECT**, enter the project name as `Serverless-SIT` in the
    **Project Name** and click on **Create**. You will see that the project is being
    created in the notification bell image on the top right-hand side of the page.
    Once it has stopped, refresh the page and you will see the project in the list.
    Likewise, let's create `Serverless-UAT` and `Serverless-PROD` projects. I am not
    creating `dev` as we are using a local emulator for `dev` environment.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到 GCP 控制台，转到**管理资源页面**([https://console.cloud.google.com/cloud-resource-manager?_ga=2.108039562.-900655901.1524348645](https://console.cloud.google.com/cloud-resource-manager?_ga=2.108039562.-900655901.1524348645))，点击**创建项目**，在**项目名称**文本框中输入
    `Serverless-SIT`，然后点击**创建**。你会看到项目正在创建，页面右上角的通知铃铛图标会显示进度。创建完成后，刷新页面，你将看到项目出现在列表中。同样地，我们将创建
    `Serverless-UAT` 和 `Serverless-PROD` 项目。由于我们为 `dev` 环境使用的是本地模拟器，因此我不创建 `dev` 项目。
- en: Let's enable the cloud API for the project by opening the link: [https://console.cloud.google.com/flows/enableapi?apiid=cloudfunctions&redirect=https://cloud.google.com/functions/quickstart](https://console.cloud.google.com/flows/enableapi?apiid=cloudfunctions&redirect=https://cloud.google.com/functions/quickstart).
    The page will have a drop-down list for projects. Select **My Serverless Project** and
    click on **Continue**, then API will be enabled for the project.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过打开链接来为项目启用云 API：[https://console.cloud.google.com/flows/enableapi?apiid=cloudfunctions&redirect=https://cloud.google.com/functions/quickstart](https://console.cloud.google.com/flows/enableapi?apiid=cloudfunctions&redirect=https://cloud.google.com/functions/quickstart)。页面将显示一个项目下拉列表，选择**My
    Serverless Project**并点击**继续**，然后 API 将会为该项目启用。
- en: Log in to the Jenkins portal (`http://localhost:8080`), which we created in
    a previous section of the chapter. Then click on **New Item**.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到 Jenkins 门户 (`http://localhost:8080`)，这是我们在本章的前面部分创建的。然后点击**新建项目**。
- en: Enter the item name in the textbox as `my-serverless-google-function-pipeline` and
    then select **Pipeline** from the list and then click **OK**.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本框中输入项目名称为 `my-serverless-google-function-pipeline`，然后从列表中选择**管道**，再点击**确定**。
- en: Click on the checkbox **This project is parameterized** and, in the **Add Parameter**
    drop-down, select **String Parameter**. Then let's add `DEV_PROJECT_ID` in the
    Name textbox and the **Default Value** textbox should have `project id` for the
    `dev` which we created in Step 1\. Likewise, let's create a text parameter for
    each environment until PROD, and then the last text parameter should be `YOUR_GCF_REGION`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选**此项目为参数化**复选框，然后在**添加参数**下拉菜单中选择**字符串参数**。接着，在名称文本框中输入 `DEV_PROJECT_ID`，并在**默认值**文本框中输入我们在步骤
    1 中创建的 `dev` 项目的 `project id`。同样，针对每个环境，我们可以创建一个文本参数，直到 `PROD`，最后一个文本参数应为 `YOUR_GCF_REGION`。
- en: Click on the Pipeline tab, in the definition dropdown **Pipeline script from
    SCM**, and in the SCM dropdown select **Git**. Now, in the repository URL textbox
    add `https://github.com/shzshi/google-functions-helloworld.git` and then keep
    everything as default and click on **Save**.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击管道选项卡，在定义下拉菜单中选择**从 SCM 脚本管道**，在 SCM 下拉菜单中选择**Git**。现在，在仓库 URL 文本框中输入 `https://github.com/shzshi/google-functions-helloworld.git`，然后保持其他设置为默认，点击**保存**。
- en: Once the job is saved, we will build the pipeline, for which we need to click
    on **Build with Parameters**, so we will see default values for each parameter.
    In case you want to change the environment or add a different project id, we can
    feed it through the textbox.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦任务保存完成，我们将构建流水线，为此我们需要点击**Build with Parameters**，这样我们可以看到每个参数的默认值。如果你想更改环境或添加不同的项目ID，我们可以通过文本框输入。
- en: Now click on Build, the job should first init, which is setting up pre-requisites,
    then it will run a unit test, then the function is deployed on the local dev environment,
    then integrate test run. In the next stage, functions are deployed into the UAT
    environment and the same will happen to other environments. The gated approval
    is been setup for production deployment. This pipeline can be done in many ways.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击“Build”，该任务应该首先初始化，即设置先决条件，然后它会运行单元测试，接着功能会被部署到本地开发环境中，之后进行集成测试。接下来的阶段中，功能会被部署到UAT环境中，其他环境也会进行同样的操作。生产环境的部署已经设置了有条件的审批。这个流水线可以通过多种方式完成。
- en: Monitoring and logging
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控与日志记录
- en: 'Google has provided a dashboard to view the invocation and also view the logs
    of the invocation through the console. So, once you log in to the console and
    select the specific function, we should be able to see the invocation graph and
    also should be able to see the execution time and also the memory used. We can
    view the source code and also test the function. If we click on **View Logs**,as
    per the following screenshot, we should be able to see the logs of the invocation
    and also be able to drill down to a detailed log:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Google提供了一个仪表板，用于查看调用情况，并通过控制台查看调用日志。所以，一旦登录到控制台并选择特定的功能，我们应该能够看到调用图，并且能够查看执行时间和使用的内存。我们可以查看源代码并测试该功能。如果点击**View
    Logs**，如以下截图所示，我们应该能够看到调用日志，并且可以深入查看详细日志：
- en: '![](img/c0d77f3b-a187-4770-b170-fc184b7a63be.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0d77f3b-a187-4770-b170-fc184b7a63be.png)'
- en: With the dashboard, Google Cloud also has a monitoring and logging platform
    called **stackdriver**. It show us insights into the health, performance, and
    availability of Cloud Function. It is natively integrated with the Google Cloud
    platform. Stackdriver provides a wide variety of metrics, dashboards, alerting,
    log management, reporting, and tracing capabilities.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仪表板，Google Cloud还提供了一个监控和日志记录平台，称为**stackdriver**。它为我们展示了Cloud Function的健康、性能和可用性的洞察。它与Google
    Cloud平台原生集成。Stackdriver提供了各种各样的指标、仪表板、告警、日志管理、报告和跟踪功能。
- en: It has advanced alerting to help you identify issues quickly. Integrated logging,
    tracing, and error reporting enable rapid drill-down and root-cause analysis.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 它有先进的告警功能，帮助你快速识别问题。集成的日志记录、跟踪和错误报告能够快速深入分析并找出根本原因。
- en: Stackdriver gives you access to logs, metrics, traces, and other signals from
    your infrastructure platform(s), virtual machines, containers, middleware, and
    application tier, so that you can track issues all the way from your end user
    to your backend services and infrastructure. Native support for distributed systems,
    auto-scaling, and ephemeral resources means that your monitoring works seamlessly
    with your modern architecture.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Stackdriver让你可以访问日志、指标、跟踪和来自基础设施平台（如虚拟机、容器、中间件和应用层）的其他信号，帮助你从最终用户到后端服务和基础设施跟踪问题。对分布式系统、自动扩展和短暂资源的原生支持意味着你的监控能够无缝地与现代架构兼容。
- en: Best practice
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Google Function is still in beta and it is being evaluated and getting better
    day by day. In terms of best practice for DevOps, it would be pretty similar to
    what I suggested in the previous chapter, in that I would recommend using a serverless
    framework for automating deployment in Google Functions. A serverless framework
    also supplies a template for creating a basic function setup for Node.js.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Google Function仍在Beta阶段，正在评估并日益改进。在DevOps的最佳实践方面，它与我在上一章节中建议的内容相似，我会推荐使用无服务器框架来自动化Google
    Functions中的部署。无服务器框架还提供了一个模板，用于为Node.js创建基本的功能设置。
- en: Developing a DevOps culture across the organisation and moving from monolithic
    application to micro-services will have a huge impact. But we should be able to
    guide the team to follow the right path. This would call for some mentoring and
    educating the team with new processes and terms.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个组织中发展DevOps文化并将单体应用程序转向微服务会产生巨大影响。但我们应该能够引导团队走上正确的道路。这需要一些指导，并通过新流程和术语来教育团队。
- en: We must extend security to the DevOps tools and organization as well. Security
    should be part of every aspects of DevOps, right from the automated testing, continuous
    integration and continuous deployment processes on the cloud platform. It is good
    to look into monitor security within DevOps in the cloud, and you should have
    a dedicated person doing this.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须将安全性扩展到 DevOps 工具和组织中。安全性应该是 DevOps 每个方面的一部分，从自动化测试、持续集成到持续部署过程，涵盖云平台中的所有内容。关注云中
    DevOps 安全性监控是很有必要的，且应有专门的人负责此事。
- en: '**Vendor lock-in** is really is painful when we develop functions or projects
    on AWS and then want to move to Google Cloud. The code has to be modified as per
    the vendor requirements. But, in terms of deployment, I recommend using a serverless
    framework for DevOps as it mitigates vendor locking of the DevOps tools and framework.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**供应商锁定**在我们在 AWS 上开发功能或项目后，想要迁移到 Google Cloud 时，确实是很痛苦的。代码必须根据供应商要求进行修改。但在部署方面，我建议使用无服务器框架进行
    DevOps，因为它能够缓解 DevOps 工具和框架的供应商锁定问题。'
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to set up CI and CD with Google Functions and
    set up a dynamic dashboard for Google Functions. In the next chapter, we will
    talk about how to set up our own private serverless form. We will also will talk
    about setting up CI and CD for this serverless architecture, as well as monitoring
    and logging, and unit and integration testing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 Google Functions 设置 CI 和 CD，并为 Google Functions 设置动态仪表盘。在下一章，我们将讨论如何设置我们自己的私有无服务器表单。我们还将讨论如何为这个无服务器架构设置
    CI 和 CD，以及监控与日志记录、单元测试和集成测试。
