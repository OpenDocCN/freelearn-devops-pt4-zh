<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Adding DevOps Flavor to Kubeless</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we learned about Google Functions and how to automate deployment of Google Functions using various different tools and process. We also looked at how to monitor and log the service. <span>This chapter will look at yet another open source serverless framework—Kubeless. We will learn how to set up the Kubeless framework over the minikube, create, deploy, and invoke Kubeless functions, and how to build, deploy, log, and monitor the Kubeless functions.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is Kubeless?</h1>
                </header>
            
            <article>
                
<p><span><strong>Kubeless</strong> is an open source serverless framework based on Kubernetes. It allows us to deploy and execute a piece of code without worrying about the underlying infrastructure. It uses the resources of Kubernetes to provide autoscaling, routing, and monitoring. Post-deployment functions can be triggered with pub–sub, HTTP, and scheduling.  The pub–sub events are managed through a Kafka cluster, an out-of-the-box component within Kubeless, which consists of a basic Kafka cluster with a broker and a zookeeper. HTTP triggers are available through the Kubernetes services, and schedule functions translate to a cron job. The languages/runtime supported by Kubeless are <kbd>python2.7</kbd>, <kbd>python3.4</kbd>, <kbd>python3.6</kbd>, <kbd>nodejs6</kbd>, <kbd>nodejs8</kbd>, <kbd>nodejs_distroless8</kbd>, <kbd>ruby2.4</kbd>, <kbd>php7.2</kbd>, <kbd>go1.10</kbd>, <kbd>dotnetcore2.0</kbd>, <kbd>java1.8</kbd>, <kbd>ballerina0.980.0</kbd>, and <kbd>jvm1.8</kbd>. Kubeless also supports HTTP, NATS, Kafka, cron, and stream triggers. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Kubeless architecture</h1>
                </header>
            
            <article>
                
<p>Kubeless uses custom resource definition, which means that when you create a custom resource definition, then the Kubernetes API server creates a resource path for each version specified. Custom resource definition can be namespaced or cluster-scope, so CRD is called a function, which means that Kubeless functions can be created as normal Kubernetes resources in the background, and a controller is created. The controller will watch these custom resources, and will launch upon runtime demand. The following diagram shows how this architecture works:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bf9904a4-442b-4a8a-ac61-eb7da513da1e.png" style="width:48.67em;height:29.33em;"/></p>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to set up Kubeless</h1>
                </header>
            
            <article>
                
<p>It is pretty easy to set up Kubeless. First, we download Kubeless from the release page, create a namespace, and then, through the YAML manifest found on the release page, we create the functions' custom resource definition and launch a controller. If you are setting up Kubeless on your personal laptop, then we have to use minikube to do this. So, let's see how to set up minikube, as we will be using it for our tutorials.</p>
<p>First, let's set up minikube by going to <a href="https://github.com/kubernetes/minikube">https://github.com/kubernetes/minikube</a>. Once minikube is installed, we should be able to have a single node Kubernetes cluster inside a virtual machine. We should also be able to execute minikube commands through the Command Prompt. Let's create a cluster and then create Kubeless resources within this cluster. Then, we will create a simple Kubeless function and then deploy and invoke it. We will also set up a dashboard for minikube and see how the controller and function are created and deployed, respectively. Let's look at the how to implement this:</p>
<ol>
<li>Let's create a minikube local Kubernetes cluster, as shown in the following code:</li>
</ol>
<pre style="padding-left: 60px"><strong><span>$ minikube start<br/></span><span>Starting local Kubernetes v1.9.0 cluster...<br/></span>Starting VM...</strong><br/><strong>Getting VM IP address...</strong><br/><strong>Moving files into cluster...</strong><br/><strong>Setting up certs...</strong><br/><strong>Connecting to cluster...</strong><br/><strong>Setting up kubeconfig...</strong><br/><strong>Starting cluster components...</strong><br/><strong>Kubectl is now configured to use the cluster.</strong><br/><strong>Loading cached images from config file.</strong></pre>
<ol start="2">
<li>Next, create a minikube dashboard with the following command. The command trigger will open up a browser with the dashboard. The dashboard will show us the services, pods, and manager: </li>
</ol>
<pre style="padding-left: 60px"><strong>$ minikube dashboard</strong></pre>
<ol start="3">
<li>Now that we have a cluster, let's deploy Kubeless to it, as shown in the following code. There are several Kubeless manifests available for multiple Kubernetes environments (non-RBAC, RBAC, and OpenShift). We will be using the manifest for non-RBAC ( nonrole-based access control): </li>
</ol>
<pre style="padding-left: 60px">$ export RELEASE=$(curl -sk https://api.github.com/repos/kubeless/kubeless/releases/latest | grep tag_name | cut -d '"' -f 4)<br/>$ kubectl create ns kubeless<br/>$ echo $RELEASE<br/>$ kubectl create -f https://github.com/kubeless/kubeless/releases/download/v1.0.0-alpha.8/kubeless-non-rbac-v1.0.0-alpha.8.yaml<br/>serviceaccount "controller-acct" created<br/>customresourcedefinition "functions.kubeless.io" created<br/>customresourcedefinition "httptriggers.kubeless.io" created<br/>customresourcedefinition "cronjobtriggers.kubeless.io" created<br/>configmap "kubeless-config" created<br/>deployment "kubeless-controller-manager" created</pre>
<ol start="4">
<li>Now that we have deployed Kubeless, let's check whether it has deployed properly: </li>
</ol>
<pre style="padding-left: 60px">$ kubectl get pods -n kubeless<br/>NAME READY STATUS RESTARTS AGE<br/>kubeless-controller-manager-c6b69df76-65gsh 1/1 Running 0 2m<br/>$ kubectl get deployment -n kubeless<br/>NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE<br/>kubeless-controller-manager 1 1 1 1 3m<br/>$ kubectl get customresourcedefinition<br/>NAME AGE<br/>cronjobtriggers.kubeless.io 3m<br/>functions.kubeless.io 3m<br/>httptriggers.kubeless.io 3m</pre>
<ol start="5">
<li>Next, we need to install the Kubeless CLI locally for deploying, invoking, and deleting the Kubeless functions, as shown in the following code: </li>
</ol>
<pre style="padding-left: 60px"><span>$ export OS=$(uname -s| tr '[:upper:]' '[:lower:]') <br/></span><span>$ curl -OL https://github.com/kubeless/kubeless/releases/download/$RELEASE/kubeless_$OS-amd64.zip<br/></span><span>$ unzip kubeless_$OS-amd64.zip <br/>$ sudo mv bundles/kubeless_$OS-amd64/kubeless /usr/local/bin/</span></pre>
<ol start="6">
<li>Let's create a function and deploy it. The following is a simple Python function that we will deploy and invoke. Create a function named <kbd>test.py</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 60px">def hello(event, context):<br/> print event<br/> <span class="pl-k">return</span> event[<span class="pl-s"><span class="pl-pds">'</span>data<span class="pl-pds">'</span></span>]</pre>
<p>Functions in Kubeless have the same format, regardless of the language of the function or the event source. In general, every <span>function will do the following:</span></p>
<ul>
<li>Receive an object<span> <strong>event</strong></span><span> </span>as its first parameter. This parameter includes all the information regarding the event source. In particular, the <kbd>data </kbd>key should contain the body of the function request.</li>
<li><span>Receive a second object</span> <strong>context</strong><span> with general information about the function.</span></li>
<li>Return a string/object that will be used as a response for the caller.</li>
</ul>
<ol start="7">
<li>Now, let's deploy the function, and when we refresh the minikube dashboard, we should be able to see the <kbd>hello</kbd> function deployed there, as shown in the following code: </li>
</ol>
<pre style="padding-left: 60px">$ <span class="bash">kubeless <span class="hljs-keyword">function</span> deploy hello --runtime python2.7</span> <span>--from-file test.py --handler test.hello </span><span>--namespace kubeless<br/></span><span>INFO[0000] Deploying function...<br/>INFO[0000] Function hello submitted for deployment<br/>INFO[0000] Check the deployment status executing 'kubeless function ls hello'</span></pre>
<p><span>The following list explains the various elements of the preceding code:</span></p>
<ul>
<li class="mce-root"><kbd>kubeless function deploy hello</kbd><span> </span><span>tells Kubeless to register a new function named</span><span> </span><kbd>hello</kbd><span>. The function will be accessible over the web using this name. Note that this doesn't need to be the same as the function name used inside the code (we'll specify that a little further along using the</span><span> </span><kbd>--handler </kbd><span>option).</span></li>
<li><kbd>--trigger-http</kbd><span> </span>tells Kubeless that the function will be invoked over HTTP. It's also possible to trigger the function in other ways, but that is not covered here.</li>
<li><kbd>--runtime python2.7</kbd><span> </span>tells Kubeless to use Python 2.7 to execute the code. Node is also supported as a runtime, with more to come in the future.</li>
<li><kbd>--handler test.hello</kbd> tells Kubeless the name of the function to call inside the code module. You can see in the preceding Python code that the function is called <kbd><span>hello</span></kbd>.</li>
<li><kbd>--from-file /tmp/hello.py</kbd><span> </span>tells Kubeless to upload and use the<span> </span><kbd>/tmp/hello.py</kbd><span> </span>file as the source for the function. It is possible to pass a function in other ways as well.</li>
</ul>
<p style="padding-left: 90px">We will see the function custom resource being created through the following commands: </p>
<pre style="padding-left: 90px">$ kubectl get functions<br/>NAME AGE<br/>hello 2m<br/><br/>$ kubeless function ls <span>--namespace kubeless<br/></span>NAME NAMESPACE HANDLER RUNTIME DEPENDENCIES STATUS<br/>hello kubeless test.hello python2.7 1/1 READY</pre>
<ol start="8">
<li>Now, let's invoke the function, as follows: </li>
</ol>
<pre style="padding-left: 60px">$ kubeless function call hello --data 'Hello Serverless!' --namespace kubeless<br/>Hello Serverless!</pre>
<ol start="9">
<li>We can also <kbd>delete</kbd> the function, as follows:</li>
</ol>
<pre style="padding-left: 60px">$ kubeless function delete hello --namespace kubeless<br/>$ kubeless function ls --namespace kubeless<br/>NAME NAMESPACE HANDLER RUNTIME DEPENDENCIES STATUS</pre>
<p>So far, we have installed Kubeless locally, created a simple function, deployed it, invoked it, and undeployed it. In the next section, we will learn how to automate deployment using the Serverless Framework.  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up continuous integration and deployment</h1>
                </header>
            
            <article>
                
<p>We will be using the  Serverless Framework to kick-start the development and deployment of the Kubeless functions. The Serverless Framework has provided lots of feature to adopt Kubeless without much effort. Let's look at the various functionalities provided by Serverless. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creation of the service</h1>
                </header>
            
            <article>
                
<p>We will use the <kbd>create </kbd>command to create basic services using the passing of runtime and <kbd>path</kbd> to create a directory. Currently, two runtimes are provided—one is Python and the other is Node.js. So, if we run the following command with the <kbd>path</kbd> parameter, it will create a folder with a simple serverless function. The runtimes currently available are <kbd>kubeless-python</kbd> and<strong> </strong><kbd>kubeless-nodejs</kbd>:</p>
<pre><span>$ serverless create --template kubeless-python --path myKubelessFunc</span></pre>
<p>The <kbd>create</kbd> command will create a service, and each service configuration will have the following three files:</p>
<ul>
<li><kbd>serverless.yml</kbd>: The main responsibility of this file is to declare the service, define the provider, custom plugin (in our case, the serverless-kubeless plugin), and events or triggers that the function will execute, and configure files using serverless variables. </li>
<li><kbd>handler.py</kbd>: This file will contain function code. The function definition with <kbd>serverless.yml</kbd> will point to the <kbd>handler.py</kbd>.</li>
<li><kbd>package.json</kbd>: This is the file for the npm package definition of our functions, containing all the dependencies and the <kbd>kubeless-serverless</kbd> plugin. </li>
</ul>
<p>Let's update these files with our function and configuration, as shown in the following code. We are updating a function to search a bike station from the station feed exposed through JSON. I have also put the code on the GitHub repository at <a href="https://github.com/shzshi/kubeless-serverless.git">https://github.com/shzshi/kubeless-serverless.git</a>: </p>
<pre>#handler.py<br/><span class="hljs-keyword">import</span><span> urllib2 <br/></span><span class="hljs-keyword">import</span><span> json <br/></span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span><span class="hljs-params">(event, context)</span>:</span><span>     <br/>    term = event[</span><span class="hljs-string">'data'</span><span>][</span><span class="hljs-string">'term'</span><span>]     <br/>    url = </span><span class="hljs-string">"https://feeds.capitalbikeshare.com/stations/stations.json"</span><span>     response = urllib2.urlopen(url)     <br/>    stations = json.loads(response.read())     <br/>    hits = []     <br/>    </span><span class="hljs-keyword">for</span><span> station </span><span class="hljs-keyword">in</span><span> stations[</span><span class="hljs-string">"stationBeanList"</span><span>]:         <br/>        </span><span class="hljs-keyword">if</span><span> station[</span><span class="hljs-string">"stAddress1"</span><span>].find(term) &gt; </span><span class="hljs-number">-1</span><span>:             hits.append(station)     <br/>    <br/>    </span><span class="hljs-keyword">return</span><span> json.dumps(hits)</span></pre>
<p>Replace the <kbd>serverless.yaml</kbd> with the following content: </p>
<pre><span class="hljs-comment"># serverless.yml</span><span> <br/></span><span class="hljs-attr">service:</span><span> </span><span class="hljs-string">bikesearch</span><span> <br/></span><span class="hljs-attr">provider:</span><span> </span><span class="hljs-attr"> <br/>    name:</span><span> </span><span class="hljs-string">kubeless</span><span> </span><span class="hljs-attr"> <br/>    runtime:</span><span> </span><span class="hljs-string">python2.7</span><span> <br/></span><span class="hljs-attr">plugins:</span><span> </span><span class="hljs-bullet"> <br/>    -</span><span> </span><span class="hljs-string">serverless-kubeless</span><span> <br/></span><span class="hljs-attr">functions:</span><span> </span><span class="hljs-attr"> <br/>    bikesearch:</span><span> </span><span class="hljs-attr"> <br/>        handler:</span><span> </span><span class="hljs-string">handler.find</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying the function</h1>
                </header>
            
            <article>
                
<p>As the required files were created through a template, we can modify them as per our needs and then simply deploy and invoke them when we need them. Let's go ahead and deploy them using serverless, then <kbd>npm install</kbd> will get the required dependencies for serverless, such as the <kbd>kubeless-serverless</kbd> plugin, and then we can deploy the function, as shown in the following code: </p>
<pre>$ npm install<br/>$ serverless deploy -v<br/>Serverless: Packaging service...<br/>Serverless: Excluding development dependencies...<br/>Serverless: Deploying function bikesearch...<br/>Serverless: Pods status: {"waiting":{"reason":"PodInitializing"}}<br/>Serverless: Function bikesearch successfully deployed<br/>Serverless: Skipping ingress rule generation</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Invoking the function</h1>
                </header>
            
            <article>
                
<p class="mce-root">The Kubeless function can be invoked through the command line or through a UI provided by Kubeless. The Kubeless UI can be provisioned by downloading the file locally and running it, or by using a Docker image and Dockerfile, or through the Kubernetes manifest that's available with the repository. For our tutorials, I will be using the Kubernetes manifest, as shown in the following code:</p>
<div class="mce-root packt_infobox">Currently, the UI works perfectly fine with minikube, but it might need a <span>few tweaks if you have an RBAC cluster, or it could just work without any tweaks.</span></div>
<pre>$ kubectl create -f https://raw.githubusercontent.com/kubeless/kubeless-ui/master/k8s.yaml<br/>serviceaccount "ui-acct" created<br/>clusterrole "kubeless-ui" created<br/>clusterrolebinding "kubeless-ui" created<br/>deployment "ui" created<br/>service "ui" created<br/>$ minikube service ui -n kubeless</pre>
<p>The <kbd>minikube</kbd> command will pop a browser <span>up</span><span> </span><span>and open a UI. The UI has the ability to create, edit, invoke, and delete the function, so invoke the function that we deployed. Let's add</span> <kbd>{"term":"New York"} </kbd><span>in the <kbd>textarea</kbd></span> <span>request, select the <span class="packt_screen">Request</span> as</span> <span class="packt_screen">POST, </span><span>and click on</span> <span class="packt_screen">Run Function</span><span>. The function will be executed successfully, with the station data response output displayed, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5299053d-f7c7-45a0-85d1-2c74f15642cf.png"/></p>
<p class="mce-root"/>
<p>We can invoke the same function through the Serverless Framework as well, and the function will execute and get the required data, as shown in the following code: </p>
<pre>$ serverless invoke --function bikesearch --data '{"term":"Albemarle"}' -l<br/>Serverless: Calling function: bikesearch...<br/>--------------------------------------------------------------------<br/>[ { availableDocks: 12,<br/> totalDocks: 15,<br/> city: '',<br/> altitude: '',<br/> stAddress2: '',<br/> longitude: -77.079382,<br/> lastCommunicationTime: '2018-08-15 04:16:15 PM',<br/> postalCode: '',<br/> statusValue: 'In Service',<br/> testStation: false,<br/> stAddress1: 'Tenleytown / Wisconsin Ave &amp; Albemarle St NW',<br/> stationName: 'Tenleytown / Wisconsin Ave &amp; Albemarle St NW',<br/> landMark: '',<br/> latitude: 38.947607,<br/> statusKey: 1,<br/> availableBikes: 1,<br/> id: 80,<br/> location: '' } ]</pre>
<div class="packt_infobox">The Kubeless UI repository is listed at <a href="https://github.com/kubeless/kubeless-ui">https://github.com/kubeless/kubeless-ui</a><span>. </span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Serverless logs</h1>
                </header>
            
            <article>
                
<p>What happens if something goes wrong? We do not have error handling in place, but we can test the logging just by feeding the error while invoking the function. So, let's invoke the function with an error in the data, as shown in the following code: </p>
<pre>$serverless invoke --function bikesearch --data '{"trm":"Albemarle"}' -l<br/>Serverless: Calling function: bikesearch...<br/><br/>  Error --------------------------------------------------<br/><br/>  Internal Server Error<br/><br/>     For debugging logs, run again after setting the "SLS_DEBUG=*" environment variable.<br/><br/>  Get Support --------------------------------------------<br/>     Docs: docs.serverless.com<br/>     Bugs: github.com/serverless/serverless/issues<br/>     Forums: forum.serverless.com<br/>     Chat: gitter.im/serverless/serverless<br/><br/>  Your Environment Information -----------------------------<br/>     OS: darwin<br/>     Node Version: 6.10.3<br/>     Serverless Version: 1.26.1</pre>
<p><span>Serverless returned an error message with a 500 server code, which is what you would expect from a web framework. However, it would be useful to see the Python stack trace in order to better debug the source of the error. So, let's get the logs to see what the error was:</span></p>
<pre><span>$ serverless logs -f bikesearch<br/></span><span>Hit Ctrl-C to quit.<br/>172.17.0.1 - - [15/Aug/2018:20:17:18 +0000] "POST / HTTP/1.1" 200 460 "" "" 0/934928<br/>172.17.0.1 - - [15/Aug/2018:20:17:18 +0000] "GET /healthz HTTP/1.1" 200 2 "" "kube-probe/." 0/133<br/>172.17.0.1 - - [15/Aug/2018:20:17:48 +0000] "GET /healthz HTTP/1.1" 200 2 "" "kube-probe/." 0/72<br/>172.17.0.1 - - [15/Aug/2018:20:18:18 +0000] "GET /healthz HTTP/1.1" 200 2 "" "kube-probe/." 0/108<br/>172.17.0.1 - - [15/Aug/2018:20:18:48 +0000] "GET /healthz HTTP/1.1" 200 2 "" "kube-probe/." 0/123<br/>172.17.0.1 - - [15/Aug/2018:20:19:18 +0000] "GET /healthz HTTP/1.1" 200 2 "" "kube-probe/." 0/74<br/>172.17.0.1 - - [15/Aug/2018:20:19:48 +0000] "GET /healthz HTTP/1.1" 200 2 "" "kube-probe/." 0/138<br/>172.17.0.1 - - [15/Aug/2018:20:20:18 +0000] "GET /healthz HTTP/1.1" 200 2 "" "kube-probe/." 0/75<br/>172.17.0.1 - - [15/Aug/2018:20:20:48 +0000] "GET /healthz HTTP/1.1" 200 2 "" "kube-probe/." 0/149<br/>172.17.0.1 - - [15/Aug/2018:20:21:18 +0000] "GET /healthz HTTP/1.1" 200 2 "" "kube-probe/." 0/187<br/>172.17.0.1 - - [15/Aug/2018:20:21:48 +0000] "GET /healthz HTTP/1.1" 200 2 "" "kube-probe/." 0/147<br/>172.17.0.1 - - [15/Aug/2018:20:22:18 +0000] "GET /healthz HTTP/1.1" 200 2 "" "kube-probe/." 0/71<br/>172.17.0.1 - - [15/Aug/2018:20:22:47 +0000] "POST / HTTP/1.1" 200 2131 "" "" 1/232988<br/>Traceback (most recent call last):<br/></span> File "/usr/local/lib/python2.7/dist-packages/bottle.py", line 862, in _handle <span>return route.call(**args)<br/> File "/usr/local/lib/python2.7/dist-packages/bottle.py", line 1740, in wrapper<br/> rv = callback(*a, **ka)<br/> File "/kubeless.py", line 76, in handler<br/> raise res<br/><strong>KeyError: 'term'</strong><br/></span></pre>
<p>It is clear from the <kbd>KeyError</kbd> phrase that the function failed because of the wrong key name, so this gives us a view of what is going wrong. But in a production-like environment, we need to have more <span>sophisticated error-handling methods. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Continuous integration with Jenkins</h1>
                </header>
            
            <article>
                
<p><span>Throughout this book, w</span>e have looked at continuous integration and continuous deployment for different serverless providers<span>, but with respect to Kubeless (as it is still developing) there is still a lot that needs to be improved. While writing this book, I found that, using the Serverless Framework, we can only set up deployment if our Kubernetes cluster (minikube), Serverless Framework, and Jenkins are set up locally. There is no provision to set up a remote deployment with the Serverless Framework. But as the Serverless Framework and Kubeless mature over time, these features will be added. In the following tutorials, I have created files to set up deployment locally.</span></p>
<div class="packt_infobox">You can find out how to set up remote deployment by reading the following article at <a href="https://aws.amazon.com/blogs/opensource/running-faas-on-kubernetes-cluster-on-aws-using-kubeless/">https://aws.amazon.com/blogs/opensource/running-faas-on-kubernetes-cluster-on-aws-using-kubeless/</a><span>.</span></div>
<p>If you clone the repository at <a href="https://github.com/shzshi/kubeless-continuous-integration.git">https://github.com/shzshi/kubeless-continuous-integration.git</a><span>, then you should be able to use this template to set up continuous integration locally. </span></p>
<p>However, we can run the files locally on the laptop, provided we have the Serverless Framework installed and configured. Let's look how do this: </p>
<pre>$ git clone https://github.com/shzshi/kubeless-continuous-integration.git<br/>$ cd <span>kubeless-continuous-integration</span></pre>
<p>We should see six files and one directory in this folder, but we won't be using Dockerfiles and Jenkinsfiles in this tutorial. They can be used once remote deployment is possible with the Serverless Framework for Kubeless, as shown in the following code: </p>
<pre>$ npm install<br/>$ npm test<br/>&gt; kubeless-nodejs@1.0.0 test /Users/shashi/Documents/packt/chapter7/kubeless-continuous-integration<br/>&gt; mocha ./test/*.js<br/>kubelesshello<br/>✓ should return 0 when "Hello Kubeless" is present<br/>1 passing (8ms)</pre>
<p class="mce-root">We ran <kbd>npm install</kbd> to get the required dependencies for the Serverless Framework and Node.js application and test. Post that we ran the npm test, for which I created a simple unit test to check the sanity of our function before we deployed them to the cluster, as shown in the following code: </p>
<pre class="mce-root">$ serverless deploy -v<br/>Serverless: Packaging service...<br/>Serverless: Excluding development dependencies...<br/>Serverless: Deploying function kubelesshello...<br/>Serverless: Pods status: {"waiting":{"reason":"PodInitializing"}}<br/>Serverless: Pods status: {"waiting":{"reason":"PodInitializing"}}<br/>Serverless: Function kubelesshello successfully deployed<br/>Serverless: Skipping ingress rule generation</pre>
<p>So, our Node.js function will be deployed successfully, and we can invoke it locally or through the Kubeless UI and test it. Post-invocation, we should get the output of <kbd>Hello Kubeless</kbd>, as shown in the following code:</p>
<pre>$ serverless invoke -f kubelesshello -l<br/>Serverless: Calling function: kubelesshello...<br/>--------------------------------------------------------------------<br/>Hello Kubeless</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Monitoring Kubeless</h1>
                </header>
            
            <article>
                
<p>We can monitor the <kbd>kubeless</kbd> function using Prometheus. There is in-built runtime support for Prometheus; the runtime will automatically collect metrics for each function. Prometheus will show those metrics on the default dashboard. </p>
<p>The Prometheus metrics can be visualized through Grafana. The Grafana dashboard can be configured through the sample dashboard JSON file provided by Kubeless at <a href="https://github.com/kubeless/kubeless/blob/master/docs/misc/kubeless-grafana-dashboard.json">https://github.com/kubeless/kubeless/blob/master/docs/misc/kubeless-grafana-dashboard.json</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Kubeless pros and cons</h1>
                </header>
            
            <article>
                
<p>In the world of serverless, Kubeless has just started its journey; it has as a long way to go to be a biggie, like AWS Lambda, Azure Function, or Google Functions. However, it still has a good number of brownie points, and it will definitely grow to be one of the leading Serverless Frameworks. Let's look at some of its pros:</p>
<ul>
<li>No provisioning of servers </li>
<li>Can run the code in parallel and scale easily </li>
<li>Not vendor-agnostic, like other service providers, such as AWS Lambda, Azure Function, or Google Functions</li>
<li>Integration with the serverless deployment framework</li>
<li>UI to create, update, delete, and invoke the functions</li>
</ul>
<p class="mce-root"/>
<p>The following are some of its cons:</p>
<ul>
<li>The testing and integration of functions still needs improvement</li>
<li>Remote deployment is not in place </li>
<li><span>Requests that use a lot of memory </span><span>state, cache, queue, and persistence storage are provided by other systems</span></li>
<li>Environment management (dev, QA, UAT, or PROD) is not documented or not in place </li>
</ul>
<p> So, in terms of applying automation, the framework still needs lots of improvement and features to be added in order to have adequate functionality. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary </h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about the Kubeless serverless framework. We learned how to set up Kubeless, deploy, remove, and invoke Python and Node.js functions. We also learned how to monitor or log the functions. In the next chapter, we will learn the best practices for using serverless and for setting up automation and DevOps. </p>


            </article>

            
        </section>
    </body></html>