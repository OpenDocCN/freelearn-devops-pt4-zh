- en: Adding DevOps Flavor to Kubeless
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about Google Functions and how to automate
    deployment of Google Functions using various different tools and process. We also
    looked at how to monitor and log the service. This chapter will look at yet another
    open source serverless framework—Kubeless. We will learn how to set up the Kubeless
    framework over the minikube, create, deploy, and invoke Kubeless functions, and
    how to build, deploy, log, and monitor the Kubeless functions.
  prefs: []
  type: TYPE_NORMAL
- en: What is Kubeless?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Kubeless** is an open source serverless framework based on Kubernetes. It
    allows us to deploy and execute a piece of code without worrying about the underlying
    infrastructure. It uses the resources of Kubernetes to provide autoscaling, routing,
    and monitoring. Post-deployment functions can be triggered with pub–sub, HTTP,
    and scheduling.  The pub–sub events are managed through a Kafka cluster, an out-of-the-box
    component within Kubeless, which consists of a basic Kafka cluster with a broker
    and a zookeeper. HTTP triggers are available through the Kubernetes services,
    and schedule functions translate to a cron job. The languages/runtime supported
    by Kubeless are `python2.7`, `python3.4`, `python3.6`, `nodejs6`, `nodejs8`, `nodejs_distroless8`,
    `ruby2.4`, `php7.2`, `go1.10`, `dotnetcore2.0`, `java1.8`, `ballerina0.980.0`,
    and `jvm1.8`. Kubeless also supports HTTP, NATS, Kafka, cron, and stream triggers.'
  prefs: []
  type: TYPE_NORMAL
- en: Kubeless architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubeless uses custom resource definition, which means that when you create
    a custom resource definition, then the Kubernetes API server creates a resource
    path for each version specified. Custom resource definition can be namespaced
    or cluster-scope, so CRD is called a function, which means that Kubeless functions
    can be created as normal Kubernetes resources in the background, and a controller
    is created. The controller will watch these custom resources, and will launch
    upon runtime demand. The following diagram shows how this architecture works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf9904a4-442b-4a8a-ac61-eb7da513da1e.png)'
  prefs: []
  type: TYPE_IMG
- en: How to set up Kubeless
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is pretty easy to set up Kubeless. First, we download Kubeless from the release
    page, create a namespace, and then, through the YAML manifest found on the release
    page, we create the functions' custom resource definition and launch a controller.
    If you are setting up Kubeless on your personal laptop, then we have to use minikube
    to do this. So, let's see how to set up minikube, as we will be using it for our
    tutorials.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s set up minikube by going to [https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube).
    Once minikube is installed, we should be able to have a single node Kubernetes
    cluster inside a virtual machine. We should also be able to execute minikube commands
    through the Command Prompt. Let''s create a cluster and then create Kubeless resources
    within this cluster. Then, we will create a simple Kubeless function and then
    deploy and invoke it. We will also set up a dashboard for minikube and see how
    the controller and function are created and deployed, respectively. Let''s look
    at the how to implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a minikube local Kubernetes cluster, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a minikube dashboard with the following command. The command trigger
    will open up a browser with the dashboard. The dashboard will show us the services,
    pods, and manager:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a cluster, let''s deploy Kubeless to it, as shown in the following
    code. There are several Kubeless manifests available for multiple Kubernetes environments
    (non-RBAC, RBAC, and OpenShift). We will be using the manifest for non-RBAC (
    nonrole-based access control):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have deployed Kubeless, let''s check whether it has deployed properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to install the Kubeless CLI locally for deploying, invoking,
    and deleting the Kubeless functions, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a function and deploy it. The following is a simple Python function
    that we will deploy and invoke. Create a function named `test.py` with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions in Kubeless have the same format, regardless of the language of the
    function or the event source. In general, every function will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Receive an object **event** as its first parameter. This parameter includes
    all the information regarding the event source. In particular, the `data `key
    should contain the body of the function request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receive a second object **context** with general information about the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return a string/object that will be used as a response for the caller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s deploy the function, and when we refresh the minikube dashboard,
    we should be able to see the `hello` function deployed there, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following list explains the various elements of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubeless function deploy hello` tells Kubeless to register a new function
    named `hello`. The function will be accessible over the web using this name. Note
    that this doesn''t need to be the same as the function name used inside the code
    (we''ll specify that a little further along using the `--handler `option).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--trigger-http` tells Kubeless that the function will be invoked over HTTP.
    It''s also possible to trigger the function in other ways, but that is not covered
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--runtime python2.7` tells Kubeless to use Python 2.7 to execute the code.
    Node is also supported as a runtime, with more to come in the future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--handler test.hello` tells Kubeless the name of the function to call inside
    the code module. You can see in the preceding Python code that the function is
    called `hello`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--from-file /tmp/hello.py` tells Kubeless to upload and use the `/tmp/hello.py` file
    as the source for the function. It is possible to pass a function in other ways
    as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will see the function custom resource being created through the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s invoke the function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also `delete` the function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have installed Kubeless locally, created a simple function, deployed
    it, invoked it, and undeployed it. In the next section, we will learn how to automate
    deployment using the Serverless Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up continuous integration and deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using the  Serverless Framework to kick-start the development and
    deployment of the Kubeless functions. The Serverless Framework has provided lots
    of feature to adopt Kubeless without much effort. Let's look at the various functionalities
    provided by Serverless.
  prefs: []
  type: TYPE_NORMAL
- en: Creation of the service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the `create `command to create basic services using the passing
    of runtime and `path` to create a directory. Currently, two runtimes are provided—one
    is Python and the other is Node.js. So, if we run the following command with the
    `path` parameter, it will create a folder with a simple serverless function. The
    runtimes currently available are `kubeless-python` and`kubeless-nodejs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `create` command will create a service, and each service configuration
    will have the following three files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`serverless.yml`: The main responsibility of this file is to declare the service,
    define the provider, custom plugin (in our case, the serverless-kubeless plugin),
    and events or triggers that the function will execute, and configure files using
    serverless variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handler.py`: This file will contain function code. The function definition
    with `serverless.yml` will point to the `handler.py`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package.json`: This is the file for the npm package definition of our functions,
    containing all the dependencies and the `kubeless-serverless` plugin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s update these files with our function and configuration, as shown in
    the following code. We are updating a function to search a bike station from the
    station feed exposed through JSON. I have also put the code on the GitHub repository
    at [https://github.com/shzshi/kubeless-serverless.git](https://github.com/shzshi/kubeless-serverless.git):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `serverless.yaml` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Deploying the function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the required files were created through a template, we can modify them as
    per our needs and then simply deploy and invoke them when we need them. Let''s
    go ahead and deploy them using serverless, then `npm install` will get the required
    dependencies for serverless, such as the `kubeless-serverless` plugin, and then
    we can deploy the function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Invoking the function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Kubeless function can be invoked through the command line or through a
    UI provided by Kubeless. The Kubeless UI can be provisioned by downloading the
    file locally and running it, or by using a Docker image and Dockerfile, or through
    the Kubernetes manifest that''s available with the repository. For our tutorials,
    I will be using the Kubernetes manifest, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the UI works perfectly fine with minikube, but it might need a few
    tweaks if you have an RBAC cluster, or it could just work without any tweaks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `minikube` command will pop a browser up and open a UI. The UI has the
    ability to create, edit, invoke, and delete the function, so invoke the function
    that we deployed. Let''s add `{"term":"New York"} `in the `textarea` request,
    select the Request as POST, and click on Run Function. The function will be executed
    successfully, with the station data response output displayed, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5299053d-f7c7-45a0-85d1-2c74f15642cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can invoke the same function through the Serverless Framework as well, and
    the function will execute and get the required data, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The Kubeless UI repository is listed at [https://github.com/kubeless/kubeless-ui](https://github.com/kubeless/kubeless-ui).
  prefs: []
  type: TYPE_NORMAL
- en: Serverless logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What happens if something goes wrong? We do not have error handling in place,
    but we can test the logging just by feeding the error while invoking the function.
    So, let''s invoke the function with an error in the data, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Serverless returned an error message with a 500 server code, which is what
    you would expect from a web framework. However, it would be useful to see the
    Python stack trace in order to better debug the source of the error. So, let''s
    get the logs to see what the error was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It is clear from the `KeyError` phrase that the function failed because of the
    wrong key name, so this gives us a view of what is going wrong. But in a production-like
    environment, we need to have more sophisticated error-handling methods.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration with Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we have looked at continuous integration and continuous
    deployment for different serverless providers, but with respect to Kubeless (as
    it is still developing) there is still a lot that needs to be improved. While
    writing this book, I found that, using the Serverless Framework, we can only set
    up deployment if our Kubernetes cluster (minikube), Serverless Framework, and
    Jenkins are set up locally. There is no provision to set up a remote deployment
    with the Serverless Framework. But as the Serverless Framework and Kubeless mature
    over time, these features will be added. In the following tutorials, I have created
    files to set up deployment locally.
  prefs: []
  type: TYPE_NORMAL
- en: You can find out how to set up remote deployment by reading the following article
    at [https://aws.amazon.com/blogs/opensource/running-faas-on-kubernetes-cluster-on-aws-using-kubeless/](https://aws.amazon.com/blogs/opensource/running-faas-on-kubernetes-cluster-on-aws-using-kubeless/).
  prefs: []
  type: TYPE_NORMAL
- en: If you clone the repository at [https://github.com/shzshi/kubeless-continuous-integration.git](https://github.com/shzshi/kubeless-continuous-integration.git),
    then you should be able to use this template to set up continuous integration
    locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can run the files locally on the laptop, provided we have the Serverless
    Framework installed and configured. Let''s look how do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see six files and one directory in this folder, but we won''t be
    using Dockerfiles and Jenkinsfiles in this tutorial. They can be used once remote
    deployment is possible with the Serverless Framework for Kubeless, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We ran `npm install` to get the required dependencies for the Serverless Framework
    and Node.js application and test. Post that we ran the npm test, for which I created
    a simple unit test to check the sanity of our function before we deployed them
    to the cluster, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'So, our Node.js function will be deployed successfully, and we can invoke it
    locally or through the Kubeless UI and test it. Post-invocation, we should get
    the output of `Hello Kubeless`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Monitoring Kubeless
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can monitor the `kubeless` function using Prometheus. There is in-built runtime
    support for Prometheus; the runtime will automatically collect metrics for each
    function. Prometheus will show those metrics on the default dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: The Prometheus metrics can be visualized through Grafana. The Grafana dashboard
    can be configured through the sample dashboard JSON file provided by Kubeless
    at [https://github.com/kubeless/kubeless/blob/master/docs/misc/kubeless-grafana-dashboard.json](https://github.com/kubeless/kubeless/blob/master/docs/misc/kubeless-grafana-dashboard.json).
  prefs: []
  type: TYPE_NORMAL
- en: Kubeless pros and cons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the world of serverless, Kubeless has just started its journey; it has as
    a long way to go to be a biggie, like AWS Lambda, Azure Function, or Google Functions.
    However, it still has a good number of brownie points, and it will definitely
    grow to be one of the leading Serverless Frameworks. Let''s look at some of its
    pros:'
  prefs: []
  type: TYPE_NORMAL
- en: No provisioning of servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can run the code in parallel and scale easily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not vendor-agnostic, like other service providers, such as AWS Lambda, Azure
    Function, or Google Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with the serverless deployment framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI to create, update, delete, and invoke the functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some of its cons:'
  prefs: []
  type: TYPE_NORMAL
- en: The testing and integration of functions still needs improvement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote deployment is not in place
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requests that use a lot of memory state, cache, queue, and persistence storage
    are provided by other systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment management (dev, QA, UAT, or PROD) is not documented or not in place
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, in terms of applying automation, the framework still needs lots of improvement
    and features to be added in order to have adequate functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the Kubeless serverless framework. We learned
    how to set up Kubeless, deploy, remove, and invoke Python and Node.js functions.
    We also learned how to monitor or log the functions. In the next chapter, we will
    learn the best practices for using serverless and for setting up automation and
    DevOps.
  prefs: []
  type: TYPE_NORMAL
