- en: Best Practices and the Future of DevOps with Serverless
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DevOps 与无服务器的最佳实践及未来
- en: In the previous chapters, we learned what serverless is and the multiple different
    service providers for serverless features. We also looked at how to build, test,
    and deploy a serverless application, as well as how to monitor and log the execution.
    But this chapter is pretty interesting, because in this chapter, we will go one
    step further to learn some best practices for serverless. We will also learn the
    best practices for building, deploying, monitoring, logging, and securing our
    serverless application. We will also examine how DevOps works with serverless.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们了解了无服务器（serverless）是什么，以及无服务器功能的多个不同服务提供商。我们还探讨了如何构建、测试和部署无服务器应用程序，以及如何监控和记录执行过程。但是本章非常有趣，因为我们将进一步深入，学习一些关于无服务器的最佳实践。我们还将学习如何构建、部署、监控、记录和保护我们的无服务器应用程序的最佳实践。我们还将研究
    DevOps 如何与无服务器一起工作。
- en: Important aspects of DevOps
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DevOps 的重要方面
- en: The two important tenets of DevOps are automation and process. We have to automate
    every bit of development from the nonproduction environment to production, and
    at the same time we have to maintain continuous feedback, with information moving
    back and forth, while also logging everything. Let's look at some best practices
    of how to do this.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 的两个重要原则是自动化和流程。我们必须自动化从非生产环境到生产环境的每一部分开发，同时要保持持续的反馈，信息在各个环节之间往返流动，同时也要记录一切。让我们看看如何实现这一点的一些最佳实践。
- en: Collaboration and tools strategy
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协作与工具策略
- en: The DevOps team needs to come up with a common tool strategy across the organization,
    and they should collaborate with different teams—such as development, testing,
    and infrastructure—and agree upon the business objectives of DevOps. There should
    be seamless collaboration and integration between the teams. The objective is
    to automate everything, so the ideal goal should be one-click deployment from
    development to production, with very minimal human intervention.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 团队需要制定一个跨组织的统一工具策略，并且应该与不同团队（如开发、测试和基础设施）进行协作，共同商定 DevOps 的业务目标。团队之间应该实现无缝协作和集成。目标是实现一切自动化，因此理想的目标是从开发到生产的“一键部署”，并尽量减少人为干预。
- en: Agile development
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敏捷开发
- en: There are many Agile methodologies available. Scrum, XP, and Kanban are a few
    of the more popular ones. You can use one of these development methodologies to
    give you a more flexible option to plan, create a faster output, and give you
    clear focus and transparency throughout the development of your project. Agile
    methodologies help to limit the work in progress, which in turn helps maintain
    a balanced flow so that we don't attempt to do too much at once.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多敏捷方法论可供选择。Scrum、XP 和 Kanban 是其中一些更受欢迎的选择。你可以选择这些开发方法之一，给你提供一个更灵活的选项来规划、创造更快的输出，并在项目开发过程中保持清晰的聚焦和透明度。敏捷方法论有助于限制进行中的工作，这反过来有助于保持平衡的流程，以避免我们一次性做得过多。
- en: Version control everything
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制所有内容
- en: When we talk about version control, the first thing that comes to our mind is
    application source code versioning, which is a practice that we are well accustomed
    to. But with source code versioning, we should version control the database, the
    build artifacts, the dependencies, and everything that is involved in the application.
    This ensures that every aspect of the application can be historically tracked
    through the single origin that is the repository.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈到版本控制时，首先浮现在我们脑海中的往往是应用程序源代码的版本管理，这是我们非常熟悉的一项实践。但在源代码版本控制的基础上，我们还应该对数据库、构建产物、依赖项以及与应用程序相关的所有内容进行版本控制。这确保了应用程序的各个方面都可以通过存储库这一单一来源进行历史追踪。
- en: Capture every request
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获每一个请求
- en: We should make sure that no ad hoc work or changes happen outside of DevOps,
    and that there should be a change request raised and maintained for every functional
    and nonfunctional requirement. These change requests should be captured and maintained
    within the tool.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该确保没有临时的工作或变更发生在 DevOps 之外，并且每个功能和非功能需求都应提出并维护变更请求。这些变更请求应该在工具中进行捕获和管理。
- en: Automate test and source code analysis
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试和源代码分析
- en: When we talk about automating the test, this does not mean just automating the
    testing. The test automation should include provisioning test data and running
    the standard test to ensure that the standard of the code meets the enterprise
    service level agreement. The testing must be continuous and should run 100 or
    1,000 times, and then, upon successful completion, should automatically be promoted
    to a higher environment. The quality of the code should be checked regularly and
    returned back to the developer to be reworked if the code coverage, source code
    analysis, and performance of the code are not up to the baseline.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论自动化测试时，这并不仅仅意味着测试的自动化。测试自动化应该包括预置测试数据并运行标准测试，以确保代码符合企业服务水平协议的标准。测试必须是持续的，应运行
    100 次或 1,000 次，然后在成功完成后，自动提升到更高的环境。代码的质量应定期检查，并在代码覆盖率、源代码分析和代码性能未达到基准时返回给开发人员进行重构。
- en: Continuous feedback
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续反馈
- en: The feedback loop is very a important aspect of DevOps. It plays a very important
    role for the success of DevOps. The feedback loop consists of automated communication
    between an issue registered during development and the human element of the DevOps
    process. It should be managed by a tool, through which issues must be registered
    manually or via an automated mechanism. The issue should also be tagged with an
    artifact that developers can use to trace what occurred, why it occurred, and
    where in the process it occurred. The tool should help to define the chain of
    communication with all automated and human elements in the loop.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 反馈循环是 DevOps 的一个非常重要的方面，它对 DevOps 成功起着至关重要的作用。反馈循环由开发过程中注册的一个问题与 DevOps 流程中的人类元素之间的自动化通信组成。它应由工具管理，通过该工具，问题必须手动或通过自动化机制进行注册。问题还应该标记一个工件，开发人员可以利用它追踪问题发生的原因、发生的时机以及发生的位置。该工具应有助于定义所有自动化和人类元素在循环中的沟通链条。
- en: Time to market and the cycle time
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 市场上线时间和周期时间
- en: During the DevOps process, we will get a rich array of metrics and real-time
    reports about our process, and we will want to measure the time to market and
    the cycle time of the application, because these two metrics play a very important
    role in how fast and efficiently we make new features available to customers.
    Time to market measures end-to-end efficiency in bringing valuable new features
    to market, and the cycle time is the measurement of the engineering team's process,
    which, once the feature is defined, indicates when it becomes available to move
    to production. It helps in understanding the efficiency of the team and improving
    it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DevOps 流程中，我们将获得丰富的指标和实时报告，帮助我们衡量应用的市场上线时间和周期时间，因为这两个指标在我们将新功能提供给客户的速度和效率上起着至关重要的作用。市场上线时间衡量的是从头到尾将有价值的新功能推向市场的效率，而周期时间是衡量工程团队流程的指标，一旦功能定义完成，它就表示功能何时可以进入生产环境。它有助于理解团队的效率并加以改进。
- en: Log metrics
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志指标
- en: We should always track the productivity of DevOps processes, both automated
    and manual, and determine whether they working in favor of the organization. We
    need to define which metrics are relevant for the DevOps process, such as the
    deployment speed, the testing errors found, or the build time. With this definition,
    automated processes can correct these issues without manual intervention.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应始终跟踪 DevOps 流程的生产力，包括自动化和手动流程，并确定这些流程是否有利于组织。我们需要定义哪些指标与 DevOps 流程相关，比如部署速度、测试中发现的错误或构建时间。通过这个定义，自动化流程可以在没有人工干预的情况下解决这些问题。
- en: We skimmed through general DevOps practices that can be applied to application
    development, but when it comes to serverless applications, we need to add more
    specific best practices in terms of tools and process. We will look into each
    service provider and funnel the best practices for the serverless applications,
    as well for DevOps with serverless.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经简要介绍了可以应用于应用开发的一般 DevOps 实践，但当涉及到无服务器应用时，我们需要在工具和流程方面增加一些更具体的最佳实践。我们将深入了解每个服务提供商，并筛选出适用于无服务器应用的最佳实践，以及
    DevOps 与无服务器架构的最佳实践。
- en: Best practices for Serverless
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器架构的最佳实践
- en: As we know, the serverless architecture consists of a small piece of code called
    a function, which runs in a stateless container. One major purpose of this architecture
    is to scale and descale as and when required. So, bearing this in mind, our best
    practices are more or less focused on this aspect of serverless. So let's look
    at a few of the best practices involved with the serverless concept.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，无服务器架构由一个称为“函数”的小段代码组成，函数运行在一个无状态的容器中。这个架构的一个主要目的是根据需要进行弹性伸缩。因此，考虑到这一点，我们的最佳实践几乎都集中在无服务器架构的这一方面。那么，让我们看看与无服务器概念相关的一些最佳实践。
- en: One function, one task
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一函数，一任务
- en: When we start building functions, we might end up with monolithic functions
    behind the proxy route and use a `switch` statement. So, if we have one or a few
    functions to run our whole app, then we are actually scaling the whole application
    instead of scaling a specific element of the application. This should be avoided,
    as scaling would be a problem in this instance, and we also might end up with
    large and complex functions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始构建函数时，可能会遇到在代理路由后面有单体函数，并使用`switch`语句的情况。因此，如果我们只有一个或几个函数来运行整个应用，那么我们实际上是在对整个应用进行扩展，而不是扩展应用的某个特定部分。这是应该避免的，因为在这种情况下，扩展会成为问题，我们还可能最终得到大型且复杂的函数。
- en: Functions call other functions
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数调用其他函数
- en: We should avoid calling a function within another function because we will end
    up paying more for this, and debugging would be a headache. We lose the value
    of isolating the functions. If required, it would be ideal to trigger another
    function if more work has to be done.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该避免在一个函数内调用另一个函数，因为这样会增加成本，且调试也会变得更加困难。我们失去了隔离函数的价值。如果需要的话，理想的做法是触发另一个函数来完成更多工作。
- en: Minimize libraries
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化库的使用
- en: When we write a function, we might need libraries to make it run. But adding
    a huge set of libraries to the function would make it really slow. There are two
    types of starts when using functions—one is the cold start, which is function
    that is started for the first time, and the other is the warm start, which is
    function that has already been started and is ready to be executed from the pool.
    So in theory, a larger number of libraries will be slower during the cold start
    and will also impact the scaling of the application. With each increase in scale,
    the function has to perform a cold start, and so, as the cold start is slower,
    the scaling is slower.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写一个函数时，可能需要一些库来让它运行。但将大量的库添加到函数中会让它变得非常慢。使用函数时有两种启动方式——一种是冷启动，即函数第一次启动，另一种是热启动，即函数已经启动并准备好从池中执行。因此，理论上来说，更多的库会使冷启动变慢，并且还会影响应用的扩展。随着规模的增加，函数必须执行冷启动，冷启动速度较慢，因此扩展速度也会变慢。
- en: Also, as the number of libraries rises, the less secure our code will be, so
    security testing has to be performed for each set of libraries added. They also
    need to be trusted before you actually start using them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，随着库数量的增加，我们的代码安全性会降低，因此每添加一组库都必须进行安全测试。在实际使用之前，这些库还需要被信任。
- en: With HTTP –  one function per route
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HTTP 时——每个路由对应一个函数
- en: We should avoid using single-function proxy if possible while using http route,
    as this hinders in scaling of the function, and also makes debugging tedious.
    There are occasions where we can avoid it, where a functionality of a series of
    routes is tied to a single table, and it's very much decoupled from the rest of
    the application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该尽量避免在使用 HTTP 路由时使用单一函数代理，因为这会阻碍函数的扩展，并且还会让调试变得繁琐。有些情况下我们可以避免这样做，比如某些路由的功能与单一表格相关，并且与应用的其他部分解耦。
- en: Database connection to RDBMS
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 RDBMS 的数据库连接
- en: The concept of a serverless application is designed to work very well with services,
    so establishing the connection to RDMBS within the function could be troublesome,
    as the parts of the services are still relied upon to provide the fast responses.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器应用的概念非常适合与服务配合使用，因此在函数中建立与 RDBMS 的连接可能会遇到问题，因为服务的各个部分仍然依赖于提供快速响应。
- en: As function scales with RDBMS connections, the number of connections grows with
    the scale,  and we might end up introducing a bottleneck and an I/O wait into
    the cold start of the function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 随着函数与 RDBMS 连接的规模增大，连接数也会随着规模增长，我们可能会引入瓶颈并在函数冷启动时出现 I/O 等待。
- en: So Serverless architecture makes us rethink the data layer, so if we try using
    serverless with the existing data layer (RDBMS), then you will see a performance
    lag in your overall application performance. This might also be the reason why
    DynamoDB works so well with Serverless.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无服务器架构让我们重新思考数据层。如果我们尝试将无服务器架构与现有的数据层（如RDBMS）结合使用，那么你会发现整体应用性能会出现延迟。这也可能是为什么DynamoDB与无服务器架构结合得如此良好的原因。
- en: Use messages and queues
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用消息和队列
- en: A serverless application works efficiently when the application is asynchronous,
    but with web applications, this is not that simple, because web applications require
    lots of request–response interactions and lots of querying. Going back to functions
    not calling other functions, it’s important to point out that this is how you
    chain functions together. Queues act as circuit breakers in the chaining scenario,
    so if the function fails, we can easily drill down to the failed queue and investigate
    the failure, which could be the result of pushing messages that failed to a dead-letter
    queue.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序是异步时，无服务器应用程序运行非常高效，但对于Web应用程序来说，这并不简单，因为Web应用需要大量的请求–响应交互和查询。回到函数不直接调用其他函数这一点，重要的是要指出这就是如何将函数串联在一起的。队列在函数串联的场景中充当断路器，因此如果某个函数失败，我们可以轻松追踪到失败的队列并调查故障，这可能是由于推送失败消息到死信队列所导致的。
- en: With applications that have serverless as the backend, it would be ideal to
    use CQRS, which separates out the conceptual model of input and output in a single
    model into separate models for the purposes of updates and displaying changes
    to the user.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以无服务器架构为后台的应用程序，使用**CQRS**（命令查询责任分离）是理想的选择，它将输入和输出的概念模型在一个模型中分离成多个模型，用于更新和向用户显示变更。
- en: Data in motion
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据流动
- en: In a serverless system, the data is in motion. It flows through the system,
    but it might end up in a datalake. Nevertheless, while in a serverless system
    it should in flow, so make sure that you keep all the data in motion instead of
    a datalake. Avoid querying from the datalake while using the serverless environment.
    It is not always possible to keep data in motion, but it is best to try.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在无服务器系统中，数据处于流动状态。它通过系统流动，但最终可能进入数据湖。然而，在无服务器系统中，它应该保持流动状态，因此，确保将所有数据保持在流动中，而不是存储在数据湖中。在使用无服务器环境时，避免从数据湖中查询数据。虽然保持数据流动并非总是可能，但最好尽量做到。
- en: Measure the scale
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量规模
- en: The main feature of serverless is efficient scaling, but we should code it so
    that it scales efficiently. We could avoid calling a direct data connection within
    the function, or avoid adding huge numbers of dependency libraries. So, in short,
    the lighter the function, the faster the cold start is, and eventually it will
    scale much faster. Also make sure that functions are load tested before they reach
    production for efficient scaling.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器架构的主要特点是高效的扩展性，但我们应该以便于扩展的方式进行编码。我们可以避免在函数内部直接调用数据连接，或者避免添加大量的依赖库。简而言之，函数越轻量，冷启动越快，最终扩展也会更快。同时，确保在函数进入生产环境之前进行负载测试，以确保高效的扩展。
- en: In this section, we looked into the various best practices that make serverless
    functions perform and scale very efficiently. Although this is not the complete
    list, these are a few of the very important ones. In the next section, we will
    learn the best practices for each cloud provider and also understand how best
    practices with DevOps will help make serverless development and deployment faster
    and more efficient.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了使无服务器函数高效执行和扩展的各种最佳实践。虽然这不是完整的列表，但这些是一些非常重要的实践。在下一节中，我们将学习每个云服务提供商的最佳实践，并理解DevOps的最佳实践如何帮助加速无服务器开发和部署，使其更加高效。
- en: DevOps best practices and troubleshooting for AWS Lambda
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS Lambda的DevOps最佳实践与故障排除
- en: So far, we have learned the best practices for using DevOps and designing the
    architecture of a serverless application. We also looked at the best ways of writing
    functions to make them scalable and have a faster cold start. Going forward, we
    will learn how to apply the best practices for a specific cloud provider.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了使用DevOps的最佳实践以及设计无服务器应用架构的最佳方式。我们还探讨了编写可扩展函数的最佳方法，并确保它们有更快的冷启动时间。接下来，我们将学习如何为特定云服务提供商应用最佳实践。
- en: AWS Lambda is a very popular and mature serverless platform. Because of this,
    most serverless best practices are aligned with Lambda, and there are a number
    of tools and processes that align functions perfectly well with AWS Lambda. In
    this section, when we talk about DevOps, we will look at the source code versioning,
    building, testing, the package itself, releasing, monitoring, security, and controlling
    the cost aspects of DevOps. All of these aspects of DevOps are stitched together
    to perform as a single platform. This needs a lot of hard work and patience from
    us if we are to reach the nirvana of DevOps.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda是一个非常流行且成熟的无服务器平台。正因如此，大多数无服务器的最佳实践都与Lambda保持一致，并且有许多工具和流程能够很好地将功能与AWS
    Lambda对接。在本节中，当我们谈论DevOps时，我们将关注源代码版本控制、构建、测试、打包、发布、监控、安全性以及成本控制等DevOps方面。这些DevOps的各个方面被整合在一起，作为一个统一的平台运行。如果我们想要达到DevOps的极乐境界，这需要我们付出大量的努力和耐心。
- en: Source code versioning
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码版本控制
- en: Source code versioning is a very important part of development. If the code
    is not versioned, then it might as well not exist. There are many tools available
    for source code versioning, but these days, Git and Apache Subversion are the
    most popular ones. It is always good to have one repository for each application
    and then create multiple branches for development. With respect to Git, when we
    create a repository, there is already a master branch. The master holds the golden
    copy of the code, which is usually used as a benchmark and can also be used as
    a production copy. We can also create many other branches for the feature, release,
    and development versions of the code for efficient development and deployment.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码版本控制是开发中的一个非常重要的部分。如果代码没有版本控制，那它就等同于不存在。现在有许多工具可用于源代码版本控制，但如今Git和Apache Subversion是最受欢迎的工具。通常，最好为每个应用创建一个代码库，然后为开发创建多个分支。关于Git，当我们创建一个代码库时，已经有了一个主分支（master）。主分支保存着代码的黄金副本，通常用于基准参考，也可以作为生产副本。我们还可以为代码的功能、发布和开发版本创建其他多个分支，以实现高效的开发和部署。
- en: So the best practices concerning the source code management is to commit often
    and also make sure that you raise the pull request every time you start your day.
    This allows us to avoid wasting time on merging the code and also prevents us
    from breaking the build. Usually, we have a huge team of developers in various
    parts of the globe building different modules for the application. If we forgot
    to commit one day, then the next morning we would have to waste lots of time merging
    our code before we actually started development. We should also make sure that
    we always inspect before we commit, because otherwise we might commit a whole
    bunch of junk, unwanted libraries, or JAR or debug files into the repository,
    which will clog the repository, as well as make our function bigger, eventually
    degrading the performance.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，关于源代码管理的最佳实践是经常提交，并且每次开始工作时都确保发起拉取请求（pull request）。这样可以避免浪费时间进行代码合并，并且防止我们破坏构建。通常，我们有一个庞大的开发团队，分布在全球不同的地方，为应用构建不同的模块。如果我们某天忘记提交代码，那么第二天早晨我们就得浪费大量时间合并代码，才能开始开发。我们还应确保在提交前始终进行检查，否则我们可能会将一大堆垃圾、不需要的库、JAR文件或调试文件提交到代码库，这会导致代码库被塞满，并且让我们的功能变得更庞大，最终降低性能。
- en: We should also make sure that we add the commit message while we commit the
    code. The comment should explain why we committed the code because this will help
    us to easily trace whether something failed, and also makes it easier for us to
    roll back if we committed buggy code, or if some functionality changes. When we
    add the commit message, we should make sure that it is not too generic or lacking
    in information. We should also ensure that it is fixed, that it works, and that
    it has no typos, because this won't help us to trace it back if we have introduced
    a bug or an issue. In addition, it is not good practice to have the same commit
    message appear after a previous commit, as we usually commit because something
    has changed in the code compared to the previous commit.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该确保在提交代码时添加提交信息。评论应该解释我们为什么提交这段代码，因为这将帮助我们轻松追踪问题是否出现，也使得我们在提交了有bug的代码或某些功能发生变化时，能够更容易地回滚。当我们添加提交信息时，应该确保信息不太笼统或缺乏内容。我们还应确保它是固定的、有效的，并且没有拼写错误，因为如果我们引入了bug或问题，这将无法帮助我们追溯。除此之外，在前一次提交后再出现相同的提交信息也不是一种好习惯，因为我们通常提交代码是因为与前一次提交相比，代码发生了变化。
- en: We should avoid committing a build artifact or compiled dependencies like `.dll`
    or `.jar` into the source control as this could well irritate your coworkers,
    as they will have to check out a huge list of files or have his on local environment
    corrupted by downloading these dependencies. Another way to avoid commit issues
    would be to write precommit hooks, which can mitigate most of the commit issues.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应避免将构建产物或编译的依赖项（如 `.dll` 或 `.jar`）提交到源代码控制中，因为这可能会惹恼你的同事，因为他们需要检出大量文件，或者因为下载这些依赖项而导致本地环境被破坏。另一种避免提交问题的方法是编写预提交钩子，这可以缓解大多数提交问题。
- en: We have talked about versioning, but we should also talk about the version database
    component. Like the UI, application, and testing code, the database component
    should be versioned for stable deployment and application. If we don't version
    the database, then we might run the application with old data or an old configuration.
    It is also easier to track what DDL and DML statement were used in a particular
    release version.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经谈到过版本控制，但我们还应该讨论版本数据库组件。像 UI、应用程序和测试代码一样，数据库组件也应该进行版本控制，以确保稳定的部署和应用。如果我们不对数据库进行版本控制，可能会导致应用程序使用旧数据或旧配置运行。通过版本控制，我们也能更容易地追踪特定版本发布中使用了哪些
    DDL 和 DML 语句。
- en: So, in short, we should always remember to commit regularly, know what are we
    committing, add a valid commit message, and ensure that sure we do it ourselves.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们应该始终记住定期提交，知道我们在提交什么，添加有效的提交信息，并确保我们自己执行这些操作。
- en: 'AWS also supports the versioning of the functions. The Lambda function is versioned
    through publishing. One of the AWS Lambda consoles is specifically dedicated to
    publishing the new version of the Lambda function, and we can create multiple
    versions of the same function. Each Lambda function version is provided with a
    unique ARN, and becomes immutable postpublishing. Lambda also allows us to create
    aliases (as shown in the following screenshot), which are pointers to specific
    Lambda function versions. Each alias will have a unique ARN and can only point
    to one function version, and not to another alias:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 还支持 Lambda 函数的版本控制。Lambda 函数通过发布来进行版本控制。AWS Lambda 控制台中有一个专门用于发布新版本的界面，我们可以为同一个函数创建多个版本。每个
    Lambda 函数版本都有一个唯一的 ARN，并且发布后是不可变的。Lambda 还允许我们创建别名（如下图所示），这些别名指向特定的 Lambda 函数版本。每个别名将拥有一个唯一的
    ARN，并且只能指向一个函数版本，而不能指向另一个别名：
- en: '![](img/01781fec-f67b-44c9-bc46-5cdaa3281039.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01781fec-f67b-44c9-bc46-5cdaa3281039.png)'
- en: Let's look at an example of AWS Lambda versioning. Say that we have an AWS S3
    bucket that is an event source for a Lambda function, so whenever any new item
    is added to the bucket, the Lambda function is triggered and executed. The event
    source mapping information is stored in the bucket notification configuration,
    and in that configuration, we can identify the Lambda function ARN that S3 can
    invoke. But the newly published version is not automatically updated, so we have
    to make sure that this is updated every time a new version of the function is
    created.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个 AWS Lambda 版本管理的例子。假设我们有一个 AWS S3 桶，它是 Lambda 函数的事件源，因此每当桶中添加新的项目时，Lambda
    函数会被触发并执行。事件源映射信息存储在桶的通知配置中，在该配置中，我们可以识别 S3 可以调用的 Lambda 函数 ARN。但是，新发布的版本不会自动更新，因此每当创建新版本的函数时，我们必须确保更新这个版本。
- en: 'If we are using the Serverless Framework, the new version is created through
    the deployment. There is also the provision to roll back to a previous version
    through the following command line:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的是 Serverless 框架，新的版本是通过部署来创建的。还可以通过以下命令行回滚到先前的版本：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Build
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建
- en: In programming terms, the build is the version of the program or product, but
    the term is also used to refer to the continuous integration of DevOps. So we
    should be sure of the build of the code is built each time code is committed into
    the Git repository. The reason for this is because there are many developers involved
    in such projects, working individually on their own machines, which might work
    fine. But until the code is committed and built on the continuous integration
    server, which will trigger source code analysis and unit testing on the committed
    code, we won't know if we have pushed broken code. So it is essential to trigger
    a build with every commit.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程术语中，构建是程序或产品的版本，但这个术语也用于指代 DevOps 的持续集成。因此，我们应该确保每次代码提交到 Git 仓库时都会触发构建。之所以这么做，是因为许多开发人员参与了这些项目，各自在自己的机器上独立工作，这可能没问题。但直到代码提交并在持续集成服务器上构建后，这将触发源代码分析和提交代码的单元测试，我们才能知道是否推送了有问题的代码。所以，确保每次提交时都触发构建是至关重要的。
- en: The artifact of a successful build should always be versioned. The best practice
    is to version them on the Nexus repository, so that all the nonproduction builds
    should be pushed into snapshot repositories of the nexus and the release candidate
    should be pushed into the release repository of the nexus. This process will help
    us to keep the release build separate from the snapshot build, which is temporary
    and should be regularly purged, as it is created for each build and will not be
    needed later.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 成功构建的工件应始终进行版本控制。最佳做法是在 Nexus 仓库中对其进行版本控制，以便所有非生产环境的构建应推送到 Nexus 的快照仓库，而发布候选版本则应推送到
    Nexus 的发布仓库。这个过程将帮助我们将发布构建与临时的快照构建分开，后者应该定期清除，因为每次构建时都会创建，并且以后不再需要。
- en: The build should also trigger source code analysis, which could be linting for
    a Node.js and Python application, and if you are using Java or C#, then there
    are lots of tools available for source code analysis. The source code analysis
    will make sure that the proper coding standards are followed by developers. It
    also performs security checks and checks for cyclomatic complexity within the
    code. The tools will generate reports as well, and we can also set a threshold
    for the source code analysis pass parameters that will eventually pass the build. So
    if the source code analysis checks are below the baseline set, then the build
    will fail and then the developer will have to fix the issue.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 构建应该触发源代码分析，这可以是针对 Node.js 和 Python 应用的 linting，如果你使用的是 Java 或 C#，那么也有许多工具可用于源代码分析。源代码分析确保开发人员遵循适当的编码标准。它还会执行安全检查并检查代码中的圈复杂度。这些工具还会生成报告，我们还可以为源代码分析的通过参数设置一个阈值，最终使构建通过。所以如果源代码分析检查的结果低于设定的基准，构建将会失败，开发人员必须修复问题。
- en: If we are using Java as a language for serverless, then there are many open
    source tools available for us to use, such as PMD, Checkmarx, Checkstyle, FindBugs,
    and SonarQube. **SonarQube** is a popular tool for source code analysis. It supports
    lots of languages, such as Java, C# , Node.js, and Python. It also has a lovely
    dashboard and is pretty easy to install and configure. The SonarQube official
    image is there on Docker Hub. You can set it up and give it a try.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 Java 作为无服务器架构的编程语言，那么有许多开源工具可供我们使用，例如 PMD、Checkmarx、Checkstyle、FindBugs
    和 SonarQube。**SonarQube** 是一个流行的源代码分析工具，支持多种语言，例如 Java、C#、Node.js 和 Python。它还拥有一个漂亮的仪表板，安装和配置也非常简单。SonarQube
    官方镜像已经发布在 Docker Hub 上。你可以设置并试试看。
- en: You can find the SonarQube image on Docker Hub at [https://hub.docker.com/_/sonarqube/](https://hub.docker.com/_/sonarqube/).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Docker Hub 上找到 SonarQube 镜像，地址是 [https://hub.docker.com/_/sonarqube/](https://hub.docker.com/_/sonarqube/)。
- en: Test
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Testing is one of the essential parts of the development cycle. Testing ensures
    that bug-free and secure code is deployed to the higher environment, and we should
    make sure that the testing should be automated as much as possible. Testing should
    be combined with the continuous integration process and eventually with continuous
    deployment. The benefit of testing is that it saves lots time and money for organizations
    because it mitigates most of the bugs and errors at the initial stage of development.
    There are many different levels of testing, such as unit testing, integration
    testing, functional testing, and performance testing.  Let's look at the best
    practices around these levels.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是开发周期中的重要部分。测试确保无错误且安全的代码被部署到更高的环境，我们应该尽可能地将测试自动化。测试应与持续集成过程结合，并最终与持续部署相结合。测试的好处在于它为组织节省了大量时间和金钱，因为它能在开发初期阶段减少大多数
    bug 和错误。测试有许多不同的层次，例如单元测试、集成测试、功能测试和性能测试。让我们看看这些层次的最佳实践。
- en: Unit testing
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit testing is the foundation level of testing when testing software. It basically
    means testing the units of your code to check the correctness of its functioning.
    During unit testing, the code is tested in a test environment using simulated
    input. The output of the execution is then compared with the expected output,
    and if the output matches the expected output, then the test passes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是测试软件时的基础层次。它基本上是指测试代码单元，以检查其功能的正确性。在单元测试过程中，代码在测试环境中使用模拟输入进行测试。然后将执行的输出与预期的输出进行比较，如果输出与预期输出匹配，则测试通过。
- en: 'With respect to the serverless concept, we do not have to worry about Lambda
    functions or handlers or events; we just need to organize our code base for easy
    integration of unit testing. If you look at the following code, you can see that
    we are separating our core logic into separate modules instead of within the handler
    so that they can be unit tested individually:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 就无服务器概念而言，我们不需要担心 Lambda 函数、处理程序或事件；我们只需要组织好代码库，以便于单元测试的集成。如果你查看以下代码，你会看到我们将核心逻辑分离成独立的模块，而不是放在处理程序内，这样它们就可以单独进行单元测试：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, it always better to separate your business logic so that it is independent
    of the service provider, reusable, and more easily testable. With this separation
    of business logic, the unit testing would be easier to write and run, and it would
    also take less effort to move to a different provider.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，最好将业务逻辑分离，使其独立于服务提供商、可重用，并且更容易进行测试。通过这种业务逻辑的分离，单元测试将更容易编写和运行，而且迁移到不同的提供商时也会花费更少的精力。
- en: There are many unit-testing frameworks available for Node.js and Python, but
    the ones we will look at are **Mocha** and **Jest**. There are serverless framework
    plugins available for these two frameworks.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 和 Python 都有许多单元测试框架，但我们将要讨论的是 **Mocha** 和 **Jest**。这两个框架都有可用的无服务器框架插件。
- en: 'The following code shows the Mocha serverless plugin installation and usage.
    It can be installed locally as a service or included within the `serverless.yml`,
    as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了 Mocha 无服务器插件的安装和使用。它可以作为服务本地安装，也可以包含在 `serverless.yml` 中，如下所示：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Likewise, we can add the Jest serverless plugin into the `serverless.yml`,
    as shown in the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以将 Jest 无服务器插件添加到 `serverless.yml` 中，如以下代码所示：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Similarly, **Nose** is a popular framework for Python serverless applications.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，**Nose** 是一个流行的 Python 无服务器应用框架。
- en: In addition to this, we can use **LocalStack **for mocking an AWS environment.
    LocalStack helps us to create a local testing environment that is similar to AWS.
    It spins up a core Cloud API for us to test our functions locally.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们还可以使用 **LocalStack** 来模拟 AWS 环境。LocalStack 帮助我们创建一个类似于 AWS 的本地测试环境，它为我们启动核心云
    API，以便我们在本地测试我们的函数。
- en: Integration testing
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration testing is basically when tests cover more than one unit. Our Lambda
    function must be integrated with third-party code dependencies, which have to
    be tested thoroughly. That's where integration testing comes into play. Integration
    testing plays a very important role in the serverless world, but it is also expensive
    if you are always doing it over the cloud. But we can reduce the cost by mocking,
    as we talked about when looking at the LocalStack framework. Using this method,
    we can put it to use mocking a large number of AWS resources.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can invoke the Lambda function locally using the `serverless invoke
    local`, and if our functions need to read/ write from DynamoDB, then this can
    also be mocked using `dynamodb-local` Node.js libraries.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: While these methods don’t emulate Lambda 100%, we’ll still be able to find issues
    in our code base quickly without having to wait for a deployment.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Performance testing
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance testing is a type of testing where we check how our application
    is performing with an expected workload. This is a very essential type of testing
    for our type of application because performance testing will provide us with an
    opportunity to improve the performance of our functions, and will also help to
    improve the speed of scaling. Scaling is a very important feature of functions,
    but it is our responsibility to code it in a fashion that will help it scale faster.
    This is where performance testing will help.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: One of the very popular tools for performance testing is **Jmeter**. It is widely
    used across the industry. The Jmeter stress test will examine load-testing KPIs,
    such as the response time, error rate, memory leaks, slowness, security issues,
    and data corruption. Jmeter requires a performance parameter script. We can start
    creating the script with the BlazeMeter Chrome extension.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Another popular tool is **Artillery**, which can be used for performance testing,
    load testing, and functional testing. It is an open source tool, and is built
    over Node.js. It can generate a load for an application and can simulate virtual
    users. You can run through this simple installation using the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There is also a combination of Serverless Framework and Artillery, called `serverless-artillery`.
    This package will help us to deploy the function and run the performance test
    through a single Node.js package, and makes it easier to integrate it into our
    CI/CD pipeline. More information can be found at: [//github.com/Nordstrom/serverless-artillery](http://://github.com/Nordstrom/serverless-artillery).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing is very important in order to weed out defects and errors in the early
    stages of development, but we have to make sure that it is introduced very early
    in the development cycle, and should be performed until production. But it is
    equally important to automate it, and it should be integrated with the continuous
    integration and continuous delivery cycle. But serverless testing has its challenges,
    as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Serverless architecture is actually an integration of separate, distributed
    services that need to be tested both together and independently.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器架构实际上是独立分布式服务的集成，这些服务需要同时和独立地进行测试。
- en: We can test the serverless functions locally, but it is hard to emulate them
    completely locally, and it is equally important to test them over the cloud. This
    process should be automated.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在本地测试无服务器函数，但完全在本地模拟它们很困难，因此在云上测试它们同样重要。这个过程应该是自动化的。
- en: The serverless architecture can feature event-driven, asynchronous workflows,
    and testing them thoroughly is not that easy.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器架构可以具有事件驱动、异步的工作流，彻底测试这些工作流并非易事。
- en: Monitoring
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控
- en: When we think of monitoring, the first thing that comes into our mind is observing
    and tracking the operations and activities of the software application regularly
    and setting up an alarm to trigger upon a system or application failure. Monitoring
    should begin right from the start of the development, in such instances as the
    monitoring of the speed of the application or monitoring how many resources a
    developed piece of code is using. This monitoring system should be coupled with
    a notification system, triggering a notification such as an email when memory
    is used beyond a defined threshold.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想到监控时，首先浮现在我们脑海中的就是定期观察和追踪软件应用程序的操作和活动，并在系统或应用程序失败时设置触发报警。监控应该从开发的开始就启动，例如监控应用程序的速度或监控已开发的代码片段使用了多少资源。这个监控系统应与通知系统相结合，当内存使用超过定义的阈值时触发通知，比如发送电子邮件。
- en: But monitoring serverless functions is more tricky. In server monitoring, we
    monitor the performance of the server, network latency, and CPU, but these details
    are irrelevant with respect to serverless as the infrastructure is completely
    managed by the service provider. But then what should we monitor with respect
    to serverless? We can still monitor memory and concurrency rate. Although the
    service provider handles the provisioning and execution of Lambda functions, there
    is still a limit to the amount of memory that can be used and the concurrent executions
    allocated to the function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 但是监控无服务器函数更加棘手。在服务器监控中，我们监控服务器的性能、网络延迟和CPU，但这些细节对于无服务器而言是无关紧要的，因为基础设施完全由服务提供商管理。那么我们在无服务器中应该监控什么呢？我们仍然可以监控内存和并发率。尽管服务提供商处理Lambda函数的资源分配和执行，但仍然有内存使用和函数分配的并发执行次数的限制。
- en: To perform serverless monitoring, there are number of tools available. There
    are a few out-of-the-box tools from AWS, such as **AWS CloudWatch**, which involves
    all the AWS resources feeding into AWS CloudWatch. CloudWatch will be our first
    tool to monitor the Lambda functions. CloudWatch tracks metrics such as the latency
    of execution, number of functions executed, and errors made during the execution.
    But we can go beyond this by setting up custom metrics within CloudWatch. We also
    looked at the CloudWatch dashboard for use with the Lambda function.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行无服务器监控，有很多工具可用。AWS提供了几个开箱即用的工具，例如**AWS CloudWatch**，它将所有AWS资源输入到AWS CloudWatch中。CloudWatch将是我们监控Lambda函数的第一个工具。CloudWatch跟踪执行延迟、执行的函数数量以及执行过程中的错误等指标。但我们可以通过在CloudWatch中设置自定义指标来超越这些。我们还查看了与Lambda函数一起使用的CloudWatch仪表板。
- en: AWS provides another powerful tool for the application performance of the lambda
    function, and that tool is X-ray. X-ray is a tracing tool that is integrated with
    AWS Lambda out of the box. It provides an end-to-end view of requests as they
    move. With X-ray, we can analyse how lambda functions and their connected services
    are performing. We can identify and troubleshoot the root causes of performance
    issues and errors, and with the map view of the application, we can see all of
    its components.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: AWS为Lambda函数的应用性能提供了另一个强大的工具，那就是X-ray。X-ray是一个与AWS Lambda开箱即用集成的追踪工具。它提供了请求流动的端到端视图。通过X-ray，我们可以分析Lambda函数及其关联服务的性能。我们可以识别并排除性能问题和错误的根本原因，并且通过应用程序的地图视图，我们可以看到它的所有组件。
- en: Thundra is another monitoring tool that can be used as an application performance
    monitoring tool for AWS Lambda. It asynchronously publishes the data from CloudWatch
    into Thundra using functions and agents to send the monitoring data into the application.
    It has some really good charts that cover many metrics, such as the invocation
    counts, cold-start invocation counts and durations, error counts by error types
    and function names, and many more.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Thundra是另一个可以用作AWS Lambda应用程序性能监控工具的工具。它通过异步发布数据，将CloudWatch的数据通过函数和代理发送到应用程序中。它提供了一些非常好的图表，涵盖了许多指标，如调用次数、冷启动调用次数和持续时间、按错误类型和函数名称统计的错误次数等。
- en: Deployment
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: To get the latest version of the Lambda function for execution, they should
    be deployed on the cloud. In this way, if our deployment package is heavier, then
    deployment will be slower. This will eventually degrade the performance of the
    function as it unpacks when it is invoked. The packing of our function also affects
    our execution. For example, if we are using Java, then packaging the function
    with all the dependencies grouped together as one function is slower compared
    to putting the dependencies within the `lib` folder.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取最新版本的Lambda函数进行执行，它们应该部署在云中。通过这种方式，如果我们的部署包更大，则部署会更慢。最终，当函数被调用时，解压缩过程将导致性能下降。我们的函数打包方式也会影响执行。例如，如果我们使用Java，将所有依赖项打包成一个函数会比将依赖项放在`lib`文件夹中单独打包更慢。
- en: There are many tools that are available for deployment, but Serverless Framework
    is one of the main candidates for this job. Of course, there is lot that we still
    have to achieve, but this is still a far more mature solution than any other open
    source option available on the market.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可用于部署的工具，但Serverless Framework是这项工作的主要候选者之一。当然，我们仍有许多事情需要完成，但这仍然比市场上任何其他开源选项更为成熟。
- en: Also with respect to deployment , it should be orchestrated and should go through
    lots of approval and change request process with respect to UAT and prod environment.
    Deployment in production should be managed through service-now change request
    and CAB approvals.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 同样关于部署，应该进行编排，并且应通过大量的审批和变更请求流程，尤其是在UAT和生产环境中。生产环境中的部署应通过ServiceNow变更请求和CAB审批进行管理。
- en: Logging
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录
- en: The runtime language for Lambda provides a mechanism for your function to deliver
    logged statements to CloudWatch logs. We need any type of application to make
    the best use of its logs, not just serverless applications. With other applications,
    we can retrieve the logs from the server in which the application is deployed.
    However, with serverless applications that is not possible, as there is no server,
    and present, we don't have the ability to "step through" the code of a live, running
    lambda function. As a result, we are heavily dependent on the logs that we create
    to inform our investigation of our functions' behavior. Because of this, we have
    to make sure that any logs generated should have the right balance of verbosity
    to triage the issues without demanding too much computing time. It is recommended
    that we use an environment variable to create a `loglevel` variable.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda的运行时语言提供了一种机制，使您的函数能够将日志语句传递到CloudWatch日志中。我们需要让任何类型的应用程序都能够充分利用其日志，而不仅仅是无服务器应用程序。对于其他应用程序，我们可以从部署应用程序的服务器中检索日志。然而，对于无服务器应用程序，这是不可能的，因为没有服务器，而且目前我们无法“逐步执行”一个正在运行的Lambda函数。因此，我们在调查函数行为时，极度依赖我们创建的日志。因此，我们必须确保生成的日志具有适当的详细程度，能够帮助我们进行问题排查，同时又不会过度消耗计算时间。建议使用环境变量来创建一个`loglevel`变量。
- en: The appropriate use of log levels can ensure that we have the ability to selectively
    incur the additional compute and storage cost only during an operational triage that
    our function can refer to so that it can determine which log statements to create
    during runtime.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 适当使用日志级别可以确保我们在运行时仅在操作性排查期间选择性地承担额外的计算和存储成本，供我们的函数参考，从而确定在运行时应创建哪些日志语句。
- en: Security
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性
- en: Security should be first in our list of priorities while designing and implementing
    functions. One of the major differences between serverless applications and server-based
    applications is that with a serverless application, we do not have control over
    the servers, so we must bake in most of the securities within our code. So while
    coding the serverless application, we should make sure that we write a secure
    code so that all the third-parties' security configuration is validated. Let's
    look at some of the best practices that are essential for implementing this secure
    code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性应该是我们设计和实现函数时的首要优先事项。无服务器应用和基于服务器的应用之间的一个主要区别是，在无服务器应用中，我们无法控制服务器，因此我们必须将大部分安全措施嵌入到代码中。因此，在编写无服务器应用时，我们应该确保编写安全的代码，以验证所有第三方的安全配置。让我们来看看一些实现安全代码所必需的最佳实践。
- en: An IAM role per function
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个函数一个 IAM 角色
- en: It is advisable that you create a role for each function, because this would
    decouple the IAM roles. This would also enable least privilege to be provided
    to individual functions. Say, for example, that a function is using a KMS key
    within its code. If we have a common role for the KMS key, then all the other
    functions would have access to the KMS key.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 建议为每个函数创建一个角色，因为这将解耦 IAM 角色。这还将使我们能够为各个函数提供最小权限。例如，假设一个函数在其代码中使用 KMS 密钥。如果我们为
    KMS 密钥使用一个公共角色，那么所有其他函数都将能够访问该 KMS 密钥。
- en: No long-lived credentials
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不使用长期凭证
- en: Using temporary AWS credentials with lambda function code is always secure. This
    is where static analysis configuration plays an important role. It best to create
    an AWS service client within the function code through AWS SDK without providing
    any credentials. The SDK should automatically manage the retrieval and rotation
    of the credentials for the alloted role.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lambda 函数代码中使用临时 AWS 凭证始终是安全的。这时，静态分析配置起着重要作用。最好通过 AWS SDK 在函数代码中创建一个 AWS
    服务客户端，而不提供任何凭证。SDK 应该自动管理凭证的获取和轮换，适用于分配的角色。
- en: Do not persist secrets
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不持久化秘密信息
- en: It is best practice to not persist the secrets. However, our function might
    need some secrets to be long lived, such as database credentials and dependency
    service access keys. Because of this requirement, it is recommended that you encrypt
    these secrets. There are a few options available to us, such as using the lambda
    environment variable with encryption and the Amazon EC2 systems manager's parameter
    store.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是不持久化秘密信息。然而，我们的函数可能需要某些长时间有效的秘密信息，例如数据库凭证和依赖服务的访问密钥。由于这一需求，建议对这些秘密信息进行加密。我们有几种选择，例如使用带加密的
    Lambda 环境变量和 Amazon EC2 系统管理器的参数存储。
- en: Secrets should not be saved or persisted on memory. Instead, the function should
    retrieve temporary credentials and keep rotating them, revoking them from time
    to time. API interaction with the lambda function should be authenticated and
    authorized.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密信息不应保存在内存中或持久化。相反，函数应该获取临时凭证并保持其轮换，定期撤销它们。与 Lambda 函数的 API 交互应该经过身份验证和授权。
- en: Lambda in VPC
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda 在 VPC 中
- en: When using Lambda functions in VPC, we should follow the best practices of using network
    security by using least-privilege security groups, lambda-function-specific subnets,
    and route tables to allow traffic specific to our lambda function, if we have
    used resources from the VPC.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 VPC 中使用 Lambda 函数时，我们应该遵循使用网络安全的最佳实践，通过使用最小权限的安全组、特定于 Lambda 函数的子网和路由表来允许特定于
    Lambda 函数的流量，如果我们使用了来自 VPC 的资源。
- en: AWS Lambda best practices
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS Lambda 最佳实践
- en: So far we learned about the best practice for DevOps with respect to AWS Lambda,
    but I feel that this chapter cannot end without knowing the best practices for
    the lambda function. These best practices will eventually help us to develop efficient
    lambda functions, and will also help us to achieve faster deployment. Let's look
    at these best practices individually.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们了解了关于 AWS Lambda 的 DevOps 最佳实践，但我认为本章不能结束，而不讨论 Lambda 函数的最佳实践。这些最佳实践最终将帮助我们开发高效的
    Lambda 函数，并帮助我们实现更快的部署。让我们逐一来看这些最佳实践。
- en: Keep the handler independent of business logic
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持处理程序独立于业务逻辑
- en: It is always advisable to keep business logic outside the handler because this
    will decouple our business logic from the lambda function runtime environment,
    reuse the business logic functions, and make it easier to test our written unit
    test, as we discussed earlier in the chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常建议将业务逻辑放在处理程序之外，因为这样可以将我们的业务逻辑与 lambda 函数的运行环境解耦，重用业务逻辑函数，并且使我们更容易测试编写的单元测试，正如我们在本章早些时候讨论的那样。
- en: Keep warm containers alive
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持温暖容器的存活
- en: When we code, we have to make sure that our code is be written in such a way
    that it uses the resources of a warm container instead of doing a cold start.
    This means that we have to scope our variables in such a way that they can be
    reused multiple times on subsequent invocations wherever possible. We should reuse
    our connection (such as an HTTP or a database connection) that was established
    in a previous invocation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码时，我们必须确保我们的代码编写方式能够利用温暖容器的资源，而不是进行冷启动。这意味着我们需要对变量的作用域进行设计，使其在随后的调用中尽可能多次重用。我们应该重用在先前调用中建立的连接（例如
    HTTP 或数据库连接）。
- en: Dependency control
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖控制
- en: Lambda needs many libraries during invocation. Lambda will always look for the
    latest libraries and security updates, but this will also bring changes in the
    behavior of the lambda function. As a result, it is best to package the dependencies
    along with the functions and deploy them. They should also be controlled and managed
    for the sake of performance within the lower environments.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 在调用时需要许多库。Lambda 会始终寻找最新的库和安全更新，但这也会带来 lambda 函数行为的变化。因此，最好将依赖项与函数一起打包并部署。为了提高性能，这些依赖项也应该在低环境中进行控制和管理。
- en: Shorter timeout for dependencies
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩短依赖的超时
- en: We need to configure a shorter timeout for all external dependencies. We cannot
    allow them to run while they are continuously looking for dependencies because
    Lambda is billed based on the duration of the execution of the function. The larger
    the execution time, the higher the are charges.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为所有外部依赖配置较短的超时时间。我们不能允许它们在持续查找依赖时继续运行，因为 Lambda 是按函数执行的持续时间计费的。执行时间越长，费用就越高。
- en: Exception handling
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: We should evaluate what the failure behavior of our functions should be, and
    accordingly, our functions should throw the correct exceptions back for faster
    resolution.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该评估函数的故障行为应该是什么，因此，我们的函数应抛出正确的异常，以便更快地解决问题。
- en: Recursive coding
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归编程
- en: We should avoid recursive code within our lambda function because the function
    will call itself recursively until a criteria is met. But this will lead to multiple
    volumes of invocation and increased cost. If we still accidentally do it, then
    we should set the function's concurrent execution limit to `0` to immediately
    throttle all invocations to the function while you update the code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应避免在 lambda 函数中使用递归代码，因为函数会递归调用自身直到满足某个条件。但这会导致多次调用并增加成本。如果我们不小心这样做了，那么我们应该将函数的并发执行限制设置为
    `0`，以便在更新代码时立即限制所有对该函数的调用。
- en: High availability
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高可用性
- en: When we go into production, high availability becomes essential, and with respect
    to serverless applications, high availability depends on the number of zones in
    which the lambda functions can be executed. If our function uses the default network,
    then it is automatically able to execute within all available zones in that region.
    Nothing else is required to configure the high availability for the function in
    the default network environment. Therefore, while designing the VPC, it is important
    to include the subnets from multiple availability zones.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入生产环境时，高可用性变得至关重要，对于无服务器应用程序而言，高可用性取决于 lambda 函数能够执行的区域数量。如果我们的函数使用默认网络，那么它会自动在该区域内的所有可用区域中执行。无需做其他配置来为函数在默认网络环境中配置高可用性。因此，在设计
    VPC 时，重要的是要包括来自多个可用区的子网。
- en: Runtime language
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时语言
- en: Choosing a runtime language is quite tricky when we start designing a serverless
    application. But we can always seek comfort in our skills sets when we decide
    on the runtime language. But the runtime language also determines the performance
    of our application. For example, if we use Java or .NET (the compiled language)
    as our runtime language, then this incurs the largest initial startup cost for
    a container's first invocation, but the performance will improve for subsequent
    invocations. Interpreted languages, such as Node.js or Python, have very fast
    initial invocation times compared to compiled languages, but they cannot output
    the maximum performance compared to complied languages. So if the application
    is latency sensitive or very spiky, then it is recommended that you use an interpreted
    language, and if the application does not experience large peaks or valleys within
    its traffic, or if user experience is not blocked with the lambda functions response
    time, then we can choose any language as the runtime language.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计无服务器应用程序时，选择运行时语言是相当棘手的。但当我们决定运行时语言时，我们总是可以依赖我们的技能组合来获得一些舒适感。不过，运行时语言也决定了我们应用程序的性能。例如，如果我们选择
    Java 或 .NET（编译语言）作为运行时语言，那么容器的首次调用会产生最大的启动成本，但随后的调用性能会有所提升。相比之下，像 Node.js 或 Python
    这样的解释型语言，初次调用时间非常快，但与编译型语言相比，它们无法输出最大性能。因此，如果应用程序对延迟敏感或负载波动较大，建议使用解释型语言；而如果应用程序的流量没有大幅波动，或者用户体验不受
    Lambda 函数响应时间的影响，那么我们可以选择任何语言作为运行时语言。
- en: Code for cold and warm containers
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 针对冷启动和热启动的代码
- en: The performance of the lambda function is dictated by the logic that we code
    within it and the dependencies we call. So the best practice to code the lambda
    function would be to consider the cold and warm start of the containers.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数的性能取决于我们在其中编写的逻辑和我们调用的依赖项。因此，编写 Lambda 函数的最佳实践是考虑容器的冷启动和热启动。
- en: For improved performance for warm starting the container, make sure that you
    store and reference any externalized configurations or dependencies that your
    code retrieves locally. Limit the reinitialization of the variables/objects on
    every invocation that uses global and static variables. Keep the HTTP and database
    connections alive.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高热启动容器的性能，确保将任何外部化的配置或依赖项存储并引用到本地，以便你的代码能快速获取。限制每次调用时对全局和静态变量的变量/对象重新初始化。保持
    HTTP 和数据库连接的活跃状态。
- en: For better performance for cold starting the container, it is always better
    to use the default network environment, unless connectivity to a resource within
    a VPC via a private IP is required. Choose an interpreted runtime language over
    a complied language. Keep the function code package as small as possible, as this
    will reduce the time to download, unpack the code from the S3 bucket, and invoke
    it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好的冷启动容器性能，最好使用默认的网络环境，除非需要通过私有 IP 与 VPC 内的资源连接。选择解释型运行时语言而非编译型语言。尽量保持函数代码包尽可能小，因为这将减少从
    S3 桶下载、解压代码并调用它的时间。
- en: Cost optimizing
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成本优化
- en: It’s an antipattern to assume that the smallest resource size available to your
    function will provide the lowest total cost. If your function’s resource size
    is too small, you could pay more because of a longer execution time than if more
    resources were available that allowed your function to complete more quickly.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 假设函数使用的最小资源大小能够提供最低的总成本是一种反模式。如果你的函数资源大小太小，可能因为执行时间过长而支付更多费用，而如果使用更多的资源，函数可以更快完成，反而可能节省成本。
- en: You don’t need to implement all use cases through a series of blocking/synchronous
    API requests and responses. If you are able to design your application to be asynchronous,
    you might find that each decoupled component of your architecture takes less compute
    time to conduct its work than tightly coupled components that spend CPU cycles
    awaiting responses to synchronous requests. Many of the Lambda event sources fit
    well with distributed systems, and can be used to integrate your modular and decoupled
    functions in a more cost-effective manner.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要通过一系列阻塞/同步的 API 请求和响应来实现所有的用例。如果你能够将应用程序设计为异步的，你可能会发现架构中的每个解耦组件执行其工作所需的计算时间比那些紧密耦合并花费
    CPU 周期等待同步请求响应的组件要少。许多 Lambda 事件源与分布式系统非常契合，并且可以以更具成本效益的方式将你的模块化和解耦函数集成在一起。
- en: Some Lambda event sources allow you to define the batch size for the number
    of records that are delivered on each function invocation (for example, Kinesis
    and DynamoDB). You should run tests to find the optimal number of records for
    each batch size so that the polling frequency of each event source is tuned to
    how quickly your function can complete its task.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Lambda 事件源允许您定义每次函数调用时传递的记录数的批量大小（例如，Kinesis 和 DynamoDB）。您应该进行测试，找到每个批量大小的最佳记录数，以便调整每个事件源的轮询频率，使其与您的函数完成任务的速度相匹配。
- en: The variety of event sources available to integrate with Lambda means that you
    often have a variety of solutions available to meet your requirements. Depending
    on your use case and requirements (request scale, volume of data, latency required,
    and so on), there might be a nontrivial difference in the total cost of your architecture
    based on which AWS services you choose as the components that surround your Lambda
    function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 可供 Lambda 集成的各种事件源意味着您通常有多种解决方案可以满足您的需求。根据您的用例和需求（请求规模、数据量、所需延迟等），根据选择的 AWS
    服务组件，您的架构的总体成本可能会有显著不同。
- en: Best practices for Azure functions
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure 函数的最佳实践
- en: With respect to other cloud providers, such as Azure, the best practices should
    align with the Lambda function. In this section, we will look at a few of these
    best practices for Azure that are closely related to Lambda functions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他云提供商（如 Azure），最佳实践应与 Lambda 函数保持一致。在本节中，我们将介绍一些与 Lambda 函数密切相关的 Azure 最佳实践。
- en: Avoid large and long-running functions
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免大型且长时间运行的函数
- en: Large and long-running functions can cause unexpected timeout issues  and A
    function can become large because of many Node.js dependencies. Specially Importing
    dependencies can also cause increased load times that result in unexpected timeouts.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 大型且长时间运行的函数可能会导致意外的超时问题，且函数可能因为许多 Node.js 依赖而变得庞大。特别是导入依赖项可能还会导致加载时间增加，从而引发意外的超时。
- en: Whenever possible, we should refactor large functions into smaller function
    sets that work together and return responses fast.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，我们应将大型函数重构为较小的函数集，使其协同工作并快速返回响应。
- en: Cross-function communication
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨函数通信
- en: If we are not using durable functions or logic apps to integrate multiple functions,
    it is generally a best practice to use storage queues for cross-function communication.
    The storage queues are cheaper and much easier to provision.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有使用持久化函数或逻辑应用程序来集成多个函数，通常的最佳实践是使用存储队列进行跨函数通信。存储队列更便宜且更易于配置。
- en: Individual messages in a storage queue are limited in size to 64 KB. If we need
    to pass larger messages between functions, an Azure Service Bus queue could be
    used to support message
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 存储队列中的单个消息大小限制为 64 KB。如果我们需要在函数之间传递更大的消息，可以使用 Azure 服务总线队列来支持消息传递。
- en: functions should be be stateless
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数应保持无状态
- en: It is recommended that functions are stateless and idempotent where ever possible.
    Associate any required state information with your data. For example, an order
    that is being processed will likely have an associated state member. A function
    could process an order based on that state while the function itself remains stateless.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐尽可能使函数保持无状态且幂等。将任何必要的状态信息与您的数据关联。例如，正在处理的订单可能会有一个相关的状态成员。函数可以根据该状态处理订单，同时函数本身保持无状态。
- en: and very importantly it is recommended that idempotent functions have timer
    triggers. For example, if you have something that absolutely must run once a day,
    we should write it so that it can run at any time during the day with the same
    results. The function can skip when there is no work for a particular day. Also,
    if a previous run failed to complete, then the next run should pick up where it
    left off.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是，推荐幂等函数使用定时触发器。例如，如果您有必须每天运行的任务，我们应该编写使其可以在一天中的任何时间运行并得到相同结果的代码。如果某一天没有工作，函数可以跳过。另外，如果上次运行未能完成，下一次运行应该从上次停止的地方继续。
- en: functions is defensive
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数应具有防御性
- en: It is always good to design our functions with the ability to continue from
    a previous fail point during the next execution.  It is recommended to write the
    function with proper error handling considering networking outages, reached quota
    limits, or made any other kind of mistake. All of these issues can affect our
    function at any time. we need to design our functions to be prepared for such
    things.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 设计我们的函数时，最好具备在下一次执行时从上次失败点继续执行的能力。建议编写具有适当错误处理的函数，考虑到网络故障、配额限制或其他错误。所有这些问题都可能随时影响我们的函数。我们需要设计函数以应对这些情况。
- en: Let assume our code fails after inserting 2000 items into the a queue for processing,
    we should be able to track the items in a set that is been completed or else we
    might end up inserting them again.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的代码在将 2000 个项目插入队列进行处理后失败，我们应该能够追踪已完成的项目集合，否则我们可能会再次插入这些项目。
- en: How does your code react if a failure occurs after inserting 5,000 of these
    items into a queue for processing? You should track items in a set that you’ve
    completed. Otherwise, you might insert them again next time. This can have a serious
    impact on your work flow.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在将 5000 个项目插入队列进行处理后发生故障，您的代码如何反应？你应该追踪已完成的项目集合。否则，下次可能会再次插入这些项目。这可能会严重影响你的工作流程。
- en: The same function app should not have code for test and production
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同一个函数应用中不应同时包含测试和生产的代码
- en: We should not mix, test and production functions or resources within the same
    function app, the performance might be degraded because functions within the function
    app shares resources, for example memory is shared. So we should be careful what
    we load in our production function apps as memory is averaged across each function
    in the function app
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应在同一个函数应用中混合测试和生产函数或资源，因为函数应用中的函数共享资源，比如内存共享，这可能导致性能下降。因此，我们在生产环境的函数应用中加载的内容要小心，因为内存会在函数应用内的每个函数间进行平均分配。
- en: Use asynchronous code, but avoid blocking calls
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步代码，但避免阻塞调用
- en: Asynchronous programming is a recommended best practice. However, always avoid
    referencing the `Result` property, or calling the `Wait` method on a `Task` instance.
    This approach can lead to thread exhaustion.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程是推荐的最佳实践。然而，始终避免引用 `Result` 属性，或者在 `Task` 实例上调用 `Wait` 方法。这种做法可能会导致线程耗尽。
- en: Configure host behaviors to better handle concurrency
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置主机行为以更好地处理并发性
- en: The `host.json` file in the function app allows for the configuration of the
    host runtime and trigger behaviors. In addition to batching behaviors, you can
    manage concurrency for a number of triggers. Often, adjusting the values in these
    options can help each instance scale appropriately for the demands of the invoked
    functions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`host.json` 文件在函数应用中用于配置主机运行时和触发器行为。除了批处理行为外，你还可以管理多个触发器的并发性。通常，调整这些选项中的值有助于每个实例根据调用的函数的需求进行适当的扩展。'
- en: The settings in the `hosts` file apply across all functions within the app,
    within a *single instance* of the function. For example, if you had a function
    app with 2 HTTP functions and concurrent requests set to 25, a request to either
    HTTP trigger would count towards the shared 25 concurrent requests. If that function
    app scaled to 10 instances, the 2 functions would effectively allow 250 concurrent
    requests (10 instances X 25 concurrent requests per instance).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`hosts` 文件中的设置适用于应用中的所有函数，且在函数的 *单实例* 中生效。例如，如果你有一个包含两个 HTTP 函数的函数应用，并将并发请求设置为
    25，那么对任何一个 HTTP 触发器的请求都会计入共享的 25 个并发请求。如果该函数应用扩展到 10 个实例，那么这两个函数实际上将允许 250 个并发请求（10
    个实例 X 每个实例 25 个并发请求）。'
- en: Best practices for Google Functions
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Functions 的最佳实践
- en: Most of the best practices are same across the Serverless functions even though
    the service providers are different , but I would still like to list some of them
    here.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 即使服务提供商不同，大多数最佳实践在无服务器函数中是相同的，但我仍然想在这里列出一些。
- en: Code idempotent functions
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写幂等函数
- en: The functions should produce the same result even after calling them multiple
    times. This helps in retrying an invocation if the previous invocation fails partway
    through our code.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应该在多次调用后仍能产生相同的结果。这有助于在先前的调用在代码执行过程中失败时重试调用。
- en: Signal the completion of function calls
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号函数调用完成
- en: Signal the completion of your function, failing to do so can result in your
    function executing until a timeout is hit. If a timeout occurs, you will be charged
    for the entire timeout time. Timeouts may also cause subsequent invocations to
    require a cold start, which results in additional latency.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 发出函数完成的信号，未能这样做可能导致函数执行直到超时为止。如果发生超时，您将为整个超时时间付费。超时也可能导致后续调用需要冷启动，从而增加延迟。
- en: Do not start background activities
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要启动背景活动
- en: A function invocation finishes once termination is signaled. Any code run after
    graceful termination cannot access the CPU, and will not make any progress. In
    addition, when a subsequent invocation is executed in the same environment, your
    background activity resumes, interfering with the new invocation. This may lead
    to unexpected behavior and errors that are hard to diagnose. Accessing the network
    after a function finishes usually leads to connections being reset (and the `ECONNRESET`
    error code).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用一旦发出终止信号即结束。终止后的任何代码无法访问 CPU，也无法继续执行。此外，当在同一环境中执行后续调用时，您的后台活动会恢复，干扰新的调用。这可能导致意外行为和难以诊断的错误。函数结束后访问网络通常会导致连接被重置（以及`ECONNRESET`错误代码）。
- en: Background activity is anything that happens after your function has terminated.
    It can often be detected in logs from individual invocations by finding anything
    that is logged after the line saying that the invocation finished. Background
    activity can sometimes be buried deeper in the code, especially when asynchronous
    operations such as callbacks or timers are present. Review your code to make sure
    that all asynchronous operations finish before you terminate the function.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 背景活动是指函数终止后发生的任何事情。通常可以通过检查日志中在调用结束后记录的任何内容来检测背景活动。背景活动有时可能隐藏在代码更深处，特别是在存在回调或定时器等异步操作时。请检查代码，确保所有异步操作在终止函数之前完成。
- en: Always delete temporary files
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 始终删除临时文件
- en: Local disk storage in the temporary directory is an in-memory filesystem. Files
    that you write consume memory available to your function, and sometimes persist
    between invocations. Failing to explicitly delete these files may eventually lead
    to an out-of-memory error and a subsequent cold start.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 临时目录中的本地磁盘存储是一个内存文件系统。您写入的文件会占用可用内存，并且有时会在调用之间保持存在。如果没有显式删除这些文件，最终可能会导致内存不足错误，并触发随后的冷启动。
- en: You can see the memory used by an individual function by selecting it in the
    list of functions ([https://console.cloud.google.com/getting-started](https://console.cloud.google.com/getting-started))
    in the GCP console and choosing the Memory usage plot.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在 GCP 控制台中选择函数列表中的函数（[https://console.cloud.google.com/getting-started](https://console.cloud.google.com/getting-started)）并选择内存使用情况图，查看单个函数使用的内存。
- en: Do not attempt to write outside of the temporary directory, and be sure to use
    platform/OS-independent methods to construct file paths.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 不要尝试在临时目录之外写入文件，并确保使用平台/操作系统独立的方法来构建文件路径。
- en: You can bypass the size restrictions on temporary files by using `pipelining`.
    For example, you can process a file on Cloud Storage by creating a read stream,
    passing it through a stream-based process, and writing the output stream directly
    to Cloud Storage.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`pipelining`绕过临时文件的大小限制。例如，您可以通过创建读取流，传递给基于流的处理，并将输出流直接写入云存储来处理云存储中的文件。
- en: Local development
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地开发
- en: Function deployment takes a bit of time, so it is often faster to test the code
    of your function locally using a **shim**.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 函数部署需要一些时间，因此通常在本地使用**shim**测试函数代码会更快。
- en: Error reporting
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误报告
- en: Do not throw uncaught exceptions, because they force cold starts in future invocations.
    See the **Error Reporting guide** ([https://cloud.google.com/functions/docs/monitoring/error-reporting](https://cloud.google.com/functions/docs/monitoring/error-reporting))
    for information on how to properly report errors.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 不要抛出未捕获的异常，因为它们会导致后续调用时发生冷启动。有关如何正确报告错误，请参阅**错误报告指南**（[https://cloud.google.com/functions/docs/monitoring/error-reporting](https://cloud.google.com/functions/docs/monitoring/error-reporting)）。
- en: Use SendGrid to send emails
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SendGrid 发送电子邮件
- en: Cloud Functions does not allow outbound connections on port 25, so you cannot
    make nonsecure connections to an SMTP server. Instead, you should use `SendGrid`
    to send emails.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Functions 不允许通过端口 25 进行外部连接，因此无法与 SMTP 服务器建立非安全连接。您应该使用`SendGrid`来发送电子邮件。
- en: Use dependencies wisely
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 明智地使用依赖项
- en: Because functions are stateless, the execution environment is often initialized
    from scratch (during a cold start). When a cold start occurs, the global context
    of the function is evaluated.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因为函数是无状态的，执行环境通常会从头开始初始化（在冷启动期间）。当冷启动发生时，函数的全局上下文被评估。
- en: If your functions import modules, the load time for those modules can add to
    the invocation latency during a cold start. You can reduce this latency, as well
    as the time needed to deploy your function, by loading the dependencies correctly
    and not loading dependencies that your function doesn't use.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的函数导入模块，则这些模块的加载时间可能会增加冷启动时的调用延迟。通过正确加载依赖项并不加载函数不使用的依赖项，可以减少此延迟以及部署函数所需的时间。
- en: Use global variables to reuse objects in future invocations
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用全局变量来在未来调用中重用对象。
- en: There is no guarantee that the state of a Cloud function will be preserved for
    future invocations. However, Cloud Functions often recycles the execution environment
    of a previous invocation. If you declare a variable with a global scope, its value
    can be reused in subsequent invocations without having to be recomputed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 不能保证云函数的状态将被保留以供将来调用。然而，云函数通常会重用先前调用的执行环境。如果您使用全局范围声明变量，则其值可以在后续调用中重用，而无需重新计算。
- en: This way, you can cache objects that may be expensive to recreate on each function
    invocation. Moving such objects from the function body to a global scope may result
    in significant performance improvements.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此方式，您可以缓存可能在每次函数调用时昂贵重新创建的对象。将这些对象从函数体移动到全局范围可能会显著提升性能。
- en: Do lazy initialization of global variables
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对全局变量进行惰性初始化
- en: If you initialize variables with a global scope, the initialization code will
    always be executed via a cold start invocation, increasing your function's latency.
    If some objects are not used in all code paths, consider initializing them lazily
    on demand.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在全局范围内初始化变量，则初始化代码将始终通过冷启动调用执行，增加函数的延迟。如果某些对象在所有代码路径中都未使用，则考虑按需惰性初始化它们。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As its name implies, this chapter was all about learning the troubleshooting
    techniques and best practices to apply when using DevOps to construct serverless
    architecture. In the next chapter, we will talk about the various use cases of
    AWS Lambda, Azure Functions, and open source versions, and how DevOps fits in
    to it all.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，本章节主要介绍了在使用DevOps构建无服务器架构时应用的故障排除技术和最佳实践。在下一章中，我们将讨论AWS Lambda、Azure
    Functions以及开源版本的各种用例，以及DevOps如何适应其中。
