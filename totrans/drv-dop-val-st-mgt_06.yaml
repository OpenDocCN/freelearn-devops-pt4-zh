- en: '[*Chapter 5*](B17087_05_Final_PD_epub.xhtml#_idTextAnchor126): Driving Business
    Value through a DevOps Pipeline'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous four chapters, you learned there are many different ways to
    define the term *value* and the importance of understanding its use in context.
    Therefore, we spent some time learning about these terms to ensure that we have
    a common semantic understanding when communicating about using **value stream
    management** (**VSM**) and DevOps to deliver customer-centric value.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how Lean and Agile practices complement each other to help an organization
    deliver customer-centric value. You also learned why we need to take a systems-thinking
    view to improve value delivery within large and complex organizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter explains how and why IT organizations represent very complex systems
    across two primary functions: **development** and **operations**. In a traditional
    IT shop, the development and operations organizations function as separate departments
    with different activities, and each has a different focus and culture. This type
    of separation of people and responsibilities only adds to the complexity of the
    IT organization.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explain why this functional split in the IT organization can
    become a problem. You will also learn about a collaboration and integration strategy
    that can be used to resolve such issues. That strategy is called **DevOps**, which
    is a concatenation of development and operations.
  prefs: []
  type: TYPE_NORMAL
- en: The topics presented in this chapter are a necessary precursor to our discussions
    on the implementation of VSM tools and methods, which we'll cover in *Section
    2* of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down barriers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving flows with DevOps pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding virtualization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining **continuous integration** (**CI**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining **continuous delivery** (**CD**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling CI/CD and DevOps pipeline flows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the scope of DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating **IT service management** (**ITSM**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving beyond projects and into products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this last chapter of *Section 1* of this book, you will gain an appreciation
    of the disparate technologies, portfolio-level investments, and genuine complexities
    involved in developing a competitive DevOps pipeline capability. Let's start this
    introduction to DevOps by understanding the business drivers that led to its evolution
    in the software industry.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down barriers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, with a quick search on the internet, you will find many industry analysts
    and other commentators who will agree that DevOps has become the table stakes
    to effectively compete in our modern digital economy (Dietrich, 2019). Those organizations
    that master the integration and automation of tools of activities across the IT
    value streams of development and operations have orders of magnitude better velocity
    in software delivery and better quality and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Just as Lean practices transformed the competitive landscape in manufacturing
    and other services-based companies, DevOps has similarly transformed the IT industry.
    Specifically, DevOps pipelines implement a software development strategy that
    is equivalent to the Lean production flow concepts in manufacturing and other
    industries. As a result, those organizations that effectively implement DevOps
    pipelines have significant competitive advantages when responding to new market
    opportunities, evolving competitive pressures, and changing customer needs.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, DevOps is an amalgamation of Lean and Agile practices or, for short,
    Lean-Agile. Agile provides values and principles to guide customer-centric software
    development practices; Lean production concepts provide proven approaches to eliminate
    waste and achieve efficient software value delivery. As you will learn in *Section
    2* of this book, modern VSM methods and tools enable organizations to implement
    Lean transformations across their IT value streams.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps concepts began to emerge in 2008\. Specifically, Andrew Shafer and Patrick
    Debois were given credit for initially discussing these concepts in a private
    meeting during the Agile Conference held in Toronto that same year. DevOps then
    became popularized a bit later when Patrick Debois organized the first *DevOpsDays*
    conference, held in Belgium in 2009.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that DevOps began as a collaboration strategy in **Agile
    systems administration**. The goal was to overcome conflicts between Agile-based
    software development teams, who could now deliver new software products and features
    with increased frequency (that is, increased *velocity*), and the traditionally
    risk-averse system administration organizations.
  prefs: []
  type: TYPE_NORMAL
- en: CI capabilities, which we'll introduce later in this chapter (see *Defining
    CI*), allowed developers to increase the velocity of application delivery to the
    IT operations' function. However, there was very little in the way of integrated
    processes or cultures of collaboration to facilitate the frequent releases of
    new software products into an organization's test and production environments.
  prefs: []
  type: TYPE_NORMAL
- en: In a traditional IT organization, development and operations are two separate
    functions. They have different goals and objectives. They also have different
    mindsets. Software developers thrive in a world of change, delivering new features
    and capabilities continuously. That's a good thing because customers and users
    want new features that add value, and the sooner the better.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, systems administrators don't care for change because they
    are responsible for ensuring all networks, systems, and applications are running,
    stable, and secure. In short, changes can break their systems, infrastructures,
    and security. And their hesitancy is a good thing, as we need our networks and
    software to work and be secure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of the difference in cultures like this: developers thrive in making
    changes, and they are rewarded when they release new functionality that supports
    the needs of customers and users. In contrast, any changes in operations are scary
    – as those changes can break their deployed networks, systems, and applications.
    Even worse than this is that the systems administrators will receive the blame
    when the systems go down, and they alone feel all of the pressure until the systems
    are back up and running.'
  prefs: []
  type: TYPE_NORMAL
- en: Sharing accountability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First and foremost, DevOps is a communications and collaboration strategy. In
    this context, DevOps' objective is to get the two teams working together in a
    coordinated manner, with information flowing both ways. Developers need to know
    why their new releases fail in production. In contrast, an operations team needs
    detailed information regarding installation configurations, system administration
    and support information, and whether the product releases have been thoroughly
    tested via systems testing, security testing, performance testing, load testing,
    and stress testing. However, such collaborations are nearly impossible when the
    development and operations teams remain separated by responsibilities, desired
    outcomes, and their differing measurements of success.
  prefs: []
  type: TYPE_NORMAL
- en: Development teams frequently want to put out new releases that they've built
    and tested and believe are ready for release. But since the operations team traditionally
    works apart from the development team, the operations group will be reluctant
    to put out a new release until they have confirmed the product won't fail or cause
    other issues with systems configurations, performance, or security in their production
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: While the development team implements the new changes, the operations department
    is held accountable for ensuring everything works properly in deployment. For
    example, the operations team might conduct tests, such as **user acceptance testing
    (UAT)**, that should have been completed earlier in development. If the software
    fails, the operations team has to go back to development with bug and defect lists,
    and then try to make them a development priority.
  prefs: []
  type: TYPE_NORMAL
- en: Other tests, such as **performance testing**, **load testing**, **stress testing**,
    and **systems testing**, require the duplication of the organization's production
    environments. If the development team cannot fully replicate the production environments
    in their testing environments, they might fail to discover potential problems
    with scaling the applications. That means performance and integration issues might
    not be uncovered until after the application has been moved into production. Even
    then, it could take some time before a set of events triggers a failure. As a
    result, it might look to be a failure of the operations team when, in fact, it
    was a failure to thoroughly test the system in a production-like environment.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, the development or operations team will build a preproduction or staging
    environment to mimic its production environments. When that's not possible, the
    operations team could be forced to run a limited set of tests directly on their
    production environments, and by doing so, hope for the best but be prepared for
    the worst.
  prefs: []
  type: TYPE_NORMAL
- en: All of the operation team's testing takes time to plan and execute. In addition
    to this, those tests won't occur until after the development team has already
    moved on to develop new features and functions during their next set of sprints.
    Any bugs or defects discovered by the operations team have to flow back into the
    product backlog for reprioritization and scheduling, potentially delaying the
    release of new features that customers are expecting. Moreover, the responsibility
    and blame for any failed releases tend to shift to the operations department.
  prefs: []
  type: TYPE_NORMAL
- en: This cultural logjam cannot be fixed if the development and operations teams
    remain separated in any fashion. Leveraging the Lean-Agile concepts you learned
    in [*Chapter 2*](B17087_02_Final_PD_epub.xhtml#_idTextAnchor062), *Building on
    a Lean-Agile Foundation*, the organization needs to integrate, streamline, and
    orchestrate the flow of work and information across both the IT development and
    operations groups.
  prefs: []
  type: TYPE_NORMAL
- en: Organizations must remove the barriers that keep these functions apart. For
    smaller organizations, eliminating communication barriers can be as simple as
    getting the two teams to communicate together well before each release. However,
    larger organizations might have multiple product lines, multiple software product
    development teams, and even different operations support teams. In those situations,
    communication, integration, and synchronization challenges grow exponentially.
    The only practical way to remove the wedges between development and operations
    in larger organizations is to integrate the two functions within product teams
    or product lines and have everyone on the product teams be equally responsible
    for each release's velocity and quality.
  prefs: []
  type: TYPE_NORMAL
- en: The practical ramifications of such a strategy are that the activities across
    development and operations must be linked, streamlined, and synchronized to each
    product under development. In other words, development and operations need to
    interoperate as a single product team.
  prefs: []
  type: TYPE_NORMAL
- en: Product team members share accountability for each new feature release from
    ideation to delivery. The product teams are also accountable for effectively supporting
    operations-oriented activities across the product's life.
  prefs: []
  type: TYPE_NORMAL
- en: Another set of issues arises from the two IT organizations – development and
    operations – having different velocities. Traditionally, an operations team requires
    more time to manage the risks associated with deploying a new release into the
    organization's production environments. This mismatch in velocities creates a
    bottleneck that slows down the release of new features into the organization's
    production environments.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how modern **CI** and **CD** capabilities
    address these issues.
  prefs: []
  type: TYPE_NORMAL
- en: Improving flows with CI/CD pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B17087_06_Final_PD_epub.xhtml#_idTextAnchor165)*, Launching
    the VSM Initiative (VSM Steps 1-3),* through to [*Chapter 11*](B17087_11_Final_PD_epub.xhtml#_idTextAnchor291),
    *Identifying VSM Tool Types and Capabilities*, we will use the concepts you learn
    in this section as a use case to introduce how you can use an eight-step VSM methodology
    to improve work and information flow across a CI/CD pipeline. However, before
    we get to that use case, we need to have a basic understanding of the purpose
    of a CI/CD pipeline, its component activities, and the complexities of implementing
    a fully integrated and automated toolchain. Those are the topics that we'll cover
    in this subsection.
  prefs: []
  type: TYPE_NORMAL
- en: 'CI/CD toolchains enable the pipeline flows of work items and information during
    the software development life cycle. Another helpful way to think about CI/CD
    pipelines is that they enable the implementation of Lean-oriented production concepts
    across IT value streams. Before we discuss the components of a CI/CD pipeline,
    let''s review the purposes of its two constituent elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CI**: This provides the infrastructure that allows several software developers
    or even different development teams to implement and test code changes to a software
    product under development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CD**: This enables the automated provisioning of development, test, and production
    environments as **configurable items**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are three critical capabilities and related tools that support the implementation
    of CI/CD pipelines. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuration management** (**CM**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task management/automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containerization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at these three enabling technologies and tools in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Tooling to establish CI/CD pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CM helps us to track and manage the proper versions of CI that make up each
    software release. A configurable item is a system component or associated information
    artifact that has been uniquely identified for version and change control and
    identification purposes. **Source control management** (**SCM**) tools help developers
    maintain version control of source code and other CIs.
  prefs: []
  type: TYPE_NORMAL
- en: Git and GitHub are two of the better-known SCM tools. But there are other tools,
    such as **Apache Subversion** (**SVN**), Azure DevOps Server (formerly Team Foundation
    Server), Bazaar, Bitbucket Server, CVS, GitLab, Gerrit, Kallithea, Mercurial,
    Monotone, Perforce Helix Core, Rational ClearCase, and **Revision Control System**
    (**RCS**).
  prefs: []
  type: TYPE_NORMAL
- en: '**Task management** tools facilitate the automation of CI/CD and DevOps workflows.
    In both CI/CD and DevOps platforms, the software industry refers to automated
    workflows as pipelines. Typically, a CI/CD workflow automates the pipeline activities
    of planning, designing, developing, testing, provisioning, and delivering software
    releases. In addition, task management supports tracking a work item''s progress,
    monitoring and analyzing key metrics across the pipeline, and reporting the results.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the better-known task management tools is Jenkins, which lauds its community
    as providing the industry-leading open source automation server. Jenkins is used
    to automate software build, test, and deployment processes in a CI/CD environment.
    Though free, Jenkins is considered by some to be outdated and cumbersome to use.
    There are alternatives to Jenkins, including AutoRABIT, Bamboo, Bitrise, Buddy,
    Buildkite, CircleCI, CruiseControl, FinalBuilder, GitLab CI, GoCD, Integrity,
    Strider, TeamCity, UrbanCode, and Werker.
  prefs: []
  type: TYPE_NORMAL
- en: '**Containerization** is a mechanism that is used to package an application''s
    code and its related configuration files, libraries, and other dependencies to
    run an application in its target hardware environments. Conceptually, containers
    implement a virtualization strategy to maximize the utilization of computing resources.'
  prefs: []
  type: TYPE_NORMAL
- en: Before virtualization, organizations had to dedicate servers to run specific
    applications, such as email, web-based applications, and backend business applications.
    Having dedicated application servers is extraordinarily inefficient and inflexible.
  prefs: []
  type: TYPE_NORMAL
- en: Two of the better-known container technologies are **Docker** and **Kubernetes**,
    and they work together. Docker is a software tool that developers use to build
    and deploy containers, while **Kubernetes** (that is, **k8s** or **Kube**) orchestrates
    and manages multiple containers in clusters. Orchestration is necessary to schedule
    and automate the deployment, management, and scaling of containerized applications.
  prefs: []
  type: TYPE_NORMAL
- en: As with SCM and task management, there are alternative tools available in the
    industry for both Docker and Kubernetes. Docker alternatives include Canonical
    (Ubuntu), **Linux Containers** (**LXD**), CoreOS rkt, **Open Container Initiative**
    (**OCI**), LXC Linux Containers, Mesos Containerizer, and OpenVZ. The Kubernetes
    alternatives include **Amazon ECS** (**Elastic Container Service**), AWS Fargate,
    AZK, **Azure Kubernetes Service** (**AKS**), Cloudify, Containership, **Google
    Kubernetes Engine** (**GKE**), OpenShift, Marathon, Minikube, Nomad, and Rancher.
  prefs: []
  type: TYPE_NORMAL
- en: If you think the number of tools available to support these three technologies
    is daunting, just wait until we examine the larger tool options that are available
    to support the entire DevOps toolchain. These tools are a small subset of the
    DevOps pipeline tools that are available as commercial and open source offerings.
    Later, in [*Chapter 11*](B17087_11_Final_PD_epub.xhtml#_idTextAnchor291), *Identifying
    VSM Tool Types and Capabilities*, you will learn that there are 17 categories
    of tools and more than 400 offerings available to support the full scope of a
    DevOps **value stream delivery platform** (**VSDP**).
  prefs: []
  type: TYPE_NORMAL
- en: We'll revisit all three of these technologies later in this chapter. However,
    before we get into the details of containerization, you need to understand the
    basic concepts behind virtualization.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding virtualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IT organizations, especially larger ones, need to maximize their computing resources'
    flexibility, utilization, and scalability. These goals are difficult, if not impossible,
    to achieve without virtualization. Virtualization is an approach taken by IT organizations
    to simplify their operations and respond faster to changing business demands.
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization offers a practical approach to distribute an application across
    any number of computing devices. For example, in many cases, one computing device
    is not sufficient to run a business application due to the high demand loads.
    In a related example, application demand loads can vary over time across the organization's
    applications. Virtualization offers an approach to reapportion loads across servers
    as demands vary, enabling high availability for demand-critical applications while
    also streamlining the process to deploy and migrate applications.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, modern data centers employ servers deployed in racks to maximize
    their computing resource utilization. Virtualization makes it possible to coordinate
    the use of rack-mounted servers to utilize those resources maximally. These rack-based
    server strategies reduce power consumption for the computing devices and air conditioning
    needs; additionally, they reduce the land and facility space requirements of the
    data centers.
  prefs: []
  type: TYPE_NORMAL
- en: Virtualizing data center resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Virtualization creates a logical (virtual) computing environment that sits on
    top of a physical computing environment. Each virtualized environment mimics the
    hardware, **operating systems** (**OSes**), storage devices, and other system
    and security components that are necessary to run a specific software application.
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization allows IT organizations to partition a single physical computer
    or racks of servers into **virtual machines** (**VMs**). Each VM operates independently
    and can run different OSes or applications while sharing a single host machine's
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: The primary benefit of virtualization is that each physical computing system
    can manage multiple virtual environments, thereby maximizing its utilization.
    Moreover, the IT department can automate building and taking down virtual environments
    to match demand loads and business application needs, maximizing the IT organization's
    responsiveness and flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization concepts employ a specific semantic description to distinguish
    between physical versus virtualized environments, as hosts versus guest machines.
    Host machines are the physical machines used for virtualization, and guest machines
    are the VMs. The host versus guest machine terminology makes it easier to distinguish
    the OS that runs on the physical machine from the OSes that run on its VMs.
  prefs: []
  type: TYPE_NORMAL
- en: Employing hypervisor software for virtualization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Figure 5.1* shows a traditional application server architecture on the left
    and a virtualized server on the right. The diagram clearly shows that the traditional
    model requires a separate computer as a server for each application requirement.
    In contrast, the virtualized host machine shares its resources among all the virtualized
    guest machines and their applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17087_Figure_5.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Traditional (left) versus virtualized (right) servers
  prefs: []
  type: TYPE_NORMAL
- en: In the original virtualization model, **hypervisor** software (that is, *virtual
    machine monitor*, *VMM*, or *virtualizer*) is installed on a host machine to enable
    multiple VMs to operate as guest machines on one physical server. The hypervisor
    software is a lightweight OS that serves as an abstraction layer separating the
    applications and their required OS from the server's OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hypervisors work in two types of operating modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bare-metal hypervisors** run multiple OSes on top of one hardware server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hosted hypervisors** are installed on top of the hardware''s standard OS
    but isolate the virtualized applications'' OSes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 5.2* depicts the two standard hypervisor software implementation models,
    that is, bare-metal and hosted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17087_Figure_5.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Hypervisor software implementation models
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits of using hypervisor software for virtualization include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It offers greater speed, efficiency, and flexibility in provisioning VMs instead
    of installing one or more physical servers for every software application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows multiple OSes to reside on the same host machine. Therefore, software
    applications do not need to be rewritten to run on the host machine's OS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All virtualized applications share the same virtual computing, storage, and
    memory resources, thereby reducing computing equipment needs, computer room space,
    energy costs, and equipment maintenance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It improves disaster recovery by making it simpler and faster to create and
    recover snapshot images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It simplifies the process of creating test environments as VMs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To put the virtualization's power into perspective, it's not unusual to have
    thousands of servers dedicated to supporting just one critical business application
    in large enterprises. Indeed, the largest commercial data centers might have more
    than a million servers deployed on tens of thousands of racks running any number
    of applications for any number of customers.
  prefs: []
  type: TYPE_NORMAL
- en: These data centers offer a network of remote servers hosted on the internet
    as a cloud-based service. Over time, the data centers could employ different technologies.
    The virtualization of servers is critical to the efficient storage, management,
    and processing of data for external customers regardless of the underlying physical
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: However, as it turns out, hypervisor-based virtualization is not a perfect solution.
    Since the hypervisor software emulates virtual hardware, the hypervisor must include
    all the guest machines' application OS and system functionality, making them relatively
    inefficient.
  prefs: []
  type: TYPE_NORMAL
- en: In the following subsection, you will learn how containers resolve these issues
    by sharing a lightweight OS.
  prefs: []
  type: TYPE_NORMAL
- en: Using containers for virtualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both containers and hypervisors make applications faster, more portable, and
    more efficient to deploy. However, they achieve those objectives differently.
    You've already learned that hypervisor software implements a light OS over a host
    machine's environment. In contrast, a container's OS is smaller and more efficient
    than hypervisor software. Containers package an application and its dependencies
    and run them as an OS process on the host machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'A container package can run anywhere a container engine is installed. For example,
    please refer to *Figure 5.2* for a graphical depiction of the container-based
    architecture, and then compare it with the hypervisor virtualization architectures
    shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Container-based virtualization'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17087_Figure_5.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – Container-based virtualization
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, the container-based virtualization model looks relatively similar
    to the hosted hypervisor model. They both provide an abstraction layer between
    the host OS and the applications. However, VMs with hypervisors isolate the hardware
    and its OS to run the virtualized applications' full OSes. In contrast, the container
    engines provide an abstraction layer on top of the hardware's OSes in order to
    run the applications directly with their OS of preference without utilizing the
    OS installed on the VMs.
  prefs: []
  type: TYPE_NORMAL
- en: A commercial OS, such as Linux, Windows, or macOS, needs to provide numerous
    common services to support computer applications that are running on the hardware
    where the OS is installed. However, most of those services are not required by
    any single application. Therefore, containers do not contain a complete OS – only
    the bare-bones elements that are necessary to run the application it supports.
  prefs: []
  type: TYPE_NORMAL
- en: The container-based virtualization approach is much more lightweight and flexible
    than hypervisor-based VMs. For example, where a VM might take up tens of gigabytes
    of space, a container might only require tens of megabytes. Additionally, containers
    tend to be more secure since each container's OS is self-contained, thereby offering
    fewer entry points for malicious actors (for instance, through malware or intrusion
    attacks).
  prefs: []
  type: TYPE_NORMAL
- en: Metaphorically, containers serve a transport function that mimics the shipping
    containers used to move physical products by ships, trains, and trucks (for instance,
    one container type from the origin to the final destination). In the software-based
    analogy, developers build products and deploy them to their target host environments
    via their containers. But in our software-based variant, the containers transport
    the application together with just the resources it needs to execute during runtime
    as virtualized guests on the targeted host's physical environment.
  prefs: []
  type: TYPE_NORMAL
- en: These resources include the code, runtime, system libraries, system tools, and
    configuration settings. The containers are constructed as *images* that are separate
    from their runtime environment. Thus, they can be deployed anywhere – just as
    long as the target environment has a container engine installed, such as Docker
    Engine.
  prefs: []
  type: TYPE_NORMAL
- en: A modern approach to software development, especially in DevOps-oriented pipelines,
    defines and creates very small pieces of code as independent services, called
    microservices. The microservices-based development strategy allows the rapid coding,
    testing, and deployment of new functionality into production – often, this can
    be multiple times per day. Conceptually, the microservices approach mimics the
    concept of single-piece flow concepts in Lean production practices.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn about the value of implementing single-piece flows in [*Chapter
    7*](B17087_07_Final_PD_epub.xhtml#_idTextAnchor183), *Mapping the Current State
    (VSM Step 4)*, and [*Chapter 8*](B17087_08_Final_PD_epub.xhtml#_idTextAnchor209),
    *Identifying Lean Metrics (VSM Step 5)*, of this book. For now, it's essential
    to understand that single-piece flows represent the most efficient Lean development
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Container engines perform two critical services: **clustering** and **orchestration**.
    Clustering connects two or more servers as a single virtualized computer. The
    clustering of servers allows them to operate in parallel, and the container engines
    manage load balancing and fault tolerance activities across the cluster of servers.'
  prefs: []
  type: TYPE_NORMAL
- en: Container orchestration automates the deployment, management, scaling, and networking
    of containers. Orchestration is critical when scheduling between hundreds or thousands
    of individual containers consisting of microservices that operate across multiple
    clusters.
  prefs: []
  type: TYPE_NORMAL
- en: When using software containers, software developers do not need to worry about
    deployments across multiple types of production environments nor the virtualization
    of hardware resources; the containers have everything they need to run the application
    on a desktop, an organization's backend servers, or computing environments available
    in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Having it both ways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Still, an IT organization could deploy both hypervisor and container-based virtualization
    strategies to maximize their flexibility when deploying and managing applications.
    Both hypervisors and container engines can live on the same physical server.
  prefs: []
  type: TYPE_NORMAL
- en: Containers do well in cloud-based environments and when developers want to build
    fine-grained services, called microservices. IT shops without many legacy applications
    might prefer to go down this route right from the beginning as microservices offer
    the greatest speed and flexibility to build, test, and deploy new IT services.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, VMs provide all the management capabilities and security
    tools available within a mature OS. VMs provide a **hardware abstraction layer**
    (**HAL**) that eliminates software application compatibility issues with the underlying
    hardware. VMs effectively utilize memory capacities and multiple cores in CPUs
    that allow the consolidation of numerous applications and tasks across each physical
    system. In fact, VMs are optimal for running applications requiring persistent
    and high-transaction volume workloads. For example, applications with large transactional
    databases – think of bank ATMs that require resilient and persistent backends
    – cannot lose data, and have high **input/output** (**I/O**) transaction requirements.
    Finally, some third-party applications have not and might not adopt the container
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the necessary tooling required to support CI/CD, we
    can introduce the types of activities included in CI and CD processes. We'll start
    by defining the activities of CI.
  prefs: []
  type: TYPE_NORMAL
- en: Defining CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fundamentally, CI is a development approach that speeds up the velocity of software
    development. CI enforces a discipline that merges all developers' working copies
    of their code to a shared repository several times a day on a technical level.
    The purpose of this is to verify each incremental code integration's functionality
    through software build and test processes when developing the code. The goal is
    to ensure the main software code is always in a working and potentially deployable
    state.
  prefs: []
  type: TYPE_NORMAL
- en: A mature CI pipeline includes automated build and automated test capabilities;
    though, these two capabilities were not part of the original definition. Today,
    CI workflows encompass the process of taking each new code *commit* from the main
    branch (that is, the mainline code, trunk, or master) and running the appropriate
    steps to verify that commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic CI pipeline spans the following software development activities, as
    shown in *Figure 5.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – CI pipeline flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17087_Figure_5.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – CI pipeline flow
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram is a high-level view of a more complicated process. As
    an example of the complexities, the following tasks are usually marshaled via
    a CI automation server, such as Jenkins:'
  prefs: []
  type: TYPE_NORMAL
- en: Move the source code to the version control system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage the version control system's push, pull, and merge functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute the software build process (for example, compiling the source code,
    linking the object files and libraries, and packaging the libraries and tools).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute static code analysis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run automated unit tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute code coverage analysis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provision test servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up test fixtures (for example, code that sets up the test environment and
    then returns it to its original state once the test is complete).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run automated tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publish logs and reports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send information to the developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CI process appears to be a lot of work and a highly complex process – and
    it is when implemented as a manual process. However, as an automated CI process,
    the complete feedback loop should run for less than 10–20 minutes. The goal is
    to make the process so quick and straightforward that developers won't hesitate
    to initiate the process several times per day.
  prefs: []
  type: TYPE_NORMAL
- en: The CI strategy addresses two fundamental problems. The first is to make sure
    every new piece of code implements its functionality correctly, according to its
    requirements and acceptance criteria, before making the change part of the main
    code. The second is to ensure the newly integrated code doesn't cause problems
    or bugs in the application's mainline code.
  prefs: []
  type: TYPE_NORMAL
- en: Encouraging frequent testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It should be pretty clear that, fundamentally, CI is a process used to develop
    and test small increments of new software functionality rapidly and frequently.
    This strategy supports the first and seventh principles of the *Manifesto for
    Agile Software Development* (Beck et al., 2001).
  prefs: []
  type: TYPE_NORMAL
- en: The Agile Manifesto principles 1 and 2
  prefs: []
  type: TYPE_NORMAL
- en: 1) Our highest priority is to satisfy the customer through early and continuous
    delivery of valuable software.
  prefs: []
  type: TYPE_NORMAL
- en: 2) Working software is the primary measure of progress.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to [https://agilemanifesto.org/principles.html](https://agilemanifesto.org/principles.html)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: While the first principle is valuable, it turns out the seventh principle is
    often more important, at least in terms of the benefits of CI. Let's take a moment
    to understand why.
  prefs: []
  type: TYPE_NORMAL
- en: In the traditional waterfall model, software developers create all of the code
    that is necessary to implement all identified requirements before initiating any
    testing. A significant problem with that development strategy is that the source
    of the software bugs becomes increasingly challenging to locate and resolve in
    larger code sets. A much better strategy is to test small increments, or units,
    of new code every step of the way. The advantage of this is that the developers
    know more precisely what they changed in the code when an error or bug shows up
    in testing.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, frequent code updates can help identify code merge conflicts,
    diverging code strategies, and duplication attempts. In other words, with CI and
    automated testing, developers are forced to address these issues as they arise
    and not wait until they become exceedingly complex, time-consuming, and expensive
    to fix.
  prefs: []
  type: TYPE_NORMAL
- en: This section ends our discussion on CI. Next, we will learn how CD capabilities
    both augment and improve the velocity of the CI phase of software delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Defining CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CD capabilities allow product teams to stand up new environments to test new
    code updates with minimal manual labor and rapidly. CD's primary goal is to turn
    new updates into routine and high-velocity tasks that a development team can perform
    on-demand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as CI has a sequential sequence of steps, so does the CD process, as depicted
    in *Figure 5.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – CD pipeline flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17087_Figure_5.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – CD pipeline flow
  prefs: []
  type: TYPE_NORMAL
- en: 'The CD pipeline view depicted in the preceding diagram provides a high-level
    view, and similarly to the CI pipeline, it can be decomposed into a lengthier
    list of related activities. These activities might include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Conducting static code analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conducting unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conducting API tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Staging to test environment(s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel testing (for instance, useability/accessibility, exploratory, UI, and
    performance testing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Staging to preproduction environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing application tests (for example, acceptance, exploratory, capacity,
    load, and stress testing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing software and network security tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conducting UAT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the application to production environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, this list is not meant to be an exhaustive summary of all the possible
    tests that a team might need to execute.
  prefs: []
  type: TYPE_NORMAL
- en: One final comment is that there is no definitive place where CI as a process
    ends and CD begins. For example, some analysts put the merge code process – a
    source code integration activity – in the CI pipeline, while others view it as
    a CD pipeline activity. In reality, CI/CD pipelines represent a continuous flow
    across the entire **systems development life cycle** (**SDLC**). There's no reason
    to make the distinction except to communicate the type of work that occurs in
    each section of the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Once the development team determines which tests to run and which tools they
    require, they can automate the tests' execution by writing configuration instructions
    in machine-readable code.
  prefs: []
  type: TYPE_NORMAL
- en: Automating configuration tasks via code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before the advent of CD methods and tools, development teams had to ask the
    operations staff to set up testing and preproduction staging environments. Then,
    the operations staff manually followed the instructions in the configuration documentation
    to set up networks, computing equipment, and software. Such manual processes are
    expensive and time-consuming.
  prefs: []
  type: TYPE_NORMAL
- en: In a modern CD environment, developers can deploy software and systems configuration
    instructions as machine-readable code. Moreover, these configurations can be managed
    in a source control repository and made available for rapid deployment as a self-service
    offering. The infrastructure and software resources are provisioned on demand
    in a cloud environment and are made available within minutes after executing the
    machine-readable code.
  prefs: []
  type: TYPE_NORMAL
- en: The term used in the software industry to describe automated deployment configurations
    is Infrastructure as Code (IaC). However, you might have also come across the
    term Configuration as Code (CaC), which individual IT practitioners and vendors
    use to connote the general implementation of configurations as source code. We'll
    discuss the semantic differences between IaC and CaC later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For now, it's essential to understand that IaC and CaC implement configuration
    instructions as machine-readable code to stand up and configure environments and
    software on demand. Before we get into the details of IaC and CaC, first, let's
    understand why CM is so important and why some configuration items cannot be deployed
    as code.
  prefs: []
  type: TYPE_NORMAL
- en: Both infrastructure and software configurations broadly fall under the discipline
    of **software configuration management**, as described in the following subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting our software assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Complex software releases involve deploying and configuring a lot of hardware,
    network and application security, software components, and other related information
    artifacts. CM ensures that we have a complete understanding of the state and artifacts
    that make up each unique software release. Without that information, it's challenging,
    if not impossible, to go back to fix bugs and defects, sustain the product, or
    enhance previous software releases.
  prefs: []
  type: TYPE_NORMAL
- en: As the software evolves, each new release has a unique configuration. With each
    release, some of the components will have changed, while others will not. Although
    all the components might start with the same version control number, those version
    control IDs will vary across the software components and other information-oriented
    artifacts over time. Therefore, assigning a version control ID to the release
    is not enough. We need to know the specific versions of each of the information
    artifacts and software components that make up the release.
  prefs: []
  type: TYPE_NORMAL
- en: Modern version control repositories, such as Git (a local repo) and GitHub (a
    web-based collaboration SCM platform and repository), use a tree structure as
    a metaphor for managing the configuration items associated with each software
    release.
  prefs: []
  type: TYPE_NORMAL
- en: Getting back to the tree metaphor applied to SCM repositories, developers create
    (and evolve), integrate, and test components as separate *branches* of an application
    before merging them with the main *trunk* of code. The main code is the closest
    code set available for release at any given time. That's not to say the main code
    is releasable, but it is the furthest along in terms of integrated capabilities
    and testing.
  prefs: []
  type: TYPE_NORMAL
- en: However, besides tracking our source code, we also need to track all the other
    information artifacts that go with each release, which is the purpose of SCM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Information and software artifacts under SCM encompass the entire SDLC processes,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Software requirements**: This includes functional and nonfunctional requirements
    specified in specifications, use cases, epics, and user stories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment**: This includes network switches, firewalls, routers, servers,
    OSes, cybersecurity systems, databases, and other critical infrastructure elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software builds**: This includes instructions to compile, link, and otherwise
    convert source code files into a standalone software artifact(s) so they can run
    on a computer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software release plan**: This provides instructions on how to release the
    product into production, its timelines, delivery dates, and production-oriented
    testing requirements such as **UAT**, QA testing, preproduction testing (for instance,
    stress, load, and performance), and field testing, as applicable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software reviews**: This could include peer reviews, **software quality assurance**
    (**SQA**) reviews, or **independent verification and validation** (**IV&V**) testing
    by third parties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version control**: This includes information on the current and past versions
    of all software system components and related artifacts, which are usually managed
    within a source control repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration items**: This includes all the software components and artifacts,
    as identified by their independent names and version control IDs and belonging
    to a specific release.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing information**: This includes test cases, test scripts, test scenarios,
    and test results associated with each software release.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User support**: The support team''s information provides user assistance
    guidance and helps troubleshoot user problems during the product''s implementation
    and use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation**: This can include training aids, systems administration documentation,
    and architecture and design documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Issue tracking**: This is used to document information related to bugs and
    defects. A bug results from a coding error, while a defect is an identified deviation
    from the requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Task management**: This is used to maintain information on activities across
    the development and delivery life cycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the preceding information-based components that go with a release are
    not part of the application's source code. Therefore, the product team must implement
    processes and systems that will record and maintain this information for each
    product release. We need to manage all this information by release to ensure operability
    and sustainability in the production environments, fix bugs or defects upon discovery,
    and enhance the product over its life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the more significant software configuration issues, let's
    examine the differences between managing and executing CaC and IaC. We'll start
    with a description of CaC.
  prefs: []
  type: TYPE_NORMAL
- en: CaC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CaC is a broad term that implies implementing configuration files in a source
    code repository, but the term is more generally applied to application configuration
    information. The purpose of CaC is to facilitate the versioned migration of application
    configurations between different environments.
  prefs: []
  type: TYPE_NORMAL
- en: CaC configurations are implemented as machine-readable code via configuration
    files that focus on the settings and parameters that are required to install software
    applications, servers, and OSes. Developers specify configuration settings in
    CaC with parameters that can be changed to affect the target information system's
    remote hardware, software, or firmware components. These configuration settings
    and parameters affect the security levels and functionality of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'A virtually unending list of potential configurations must be implemented and
    maintained across IT products, especially for those in which security-related
    configuration settings can be defined. The US **National Institute of Standards
    and Technology** (**NIST**) *Special Publication 800-53 (Rev. 4)* documents the
    following examples of configurable items:'
  prefs: []
  type: TYPE_NORMAL
- en: Mainframe computers, servers (for example, database, email, authentication,
    web, proxy, file, domain name), workstations, I/O devices (for example, scanners,
    copiers, and printers), network components (for example, firewalls, routers, gateways,
    voice and data switches, wireless access points, network appliances, sensors),
    OSes, middleware, and applications ([https://nvd.nist.gov/800-53/Rev4/control/CM-6](https://nvd.nist.gov/800-53/Rev4/control/CM-6)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The NIST publication also lists standard security-related parameters, as noted
    in the passage that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Security-related parameters impact the security state of information systems,
    including the parameters required to satisfy other security control requirements.
  prefs: []
  type: TYPE_NORMAL
- en: (i) registry settings,
  prefs: []
  type: TYPE_NORMAL
- en: (ii) account, file, directory permission settings,
  prefs: []
  type: TYPE_NORMAL
- en: (iii) settings for functions, ports, protocols, services, and remote connections.
  prefs: []
  type: TYPE_NORMAL
- en: Established settings become part of the system's configuration baseline parameters.
    In a manual process, the software developers create security configuration checklists,
    lockdown and hardening guides, security reference guides, and security technical
    implementation guides. The operations staff follow these guides to configure the
    systems and applications properly. The value of CaC is that it automates and streamlines
    the process of establishing the configuration settings and parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast with CaC, IaC is about configuring IT infrastructures, including
    servers, networks, load balancing, and security, as described in the following
    subsection.
  prefs: []
  type: TYPE_NORMAL
- en: IaC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As its name implies, IaC allows developers to use a programming or scripting
    language to generate a repeatable set of code or scripted instructions to provision
    IT infrastructures. With IaC capabilities, developers do not need to manually
    provision or change the configurations of infrastructure components, such as servers,
    OSes, database connections, storage, networks, VMs, load balancers, and network
    topologies.
  prefs: []
  type: TYPE_NORMAL
- en: Without IaC capabilities, the developers must manually set up and configure
    new system environments every time they want to develop, test, or deploy a software
    application. From the perspective of Lean, and therefore our customers, these
    activities are unnecessarily repetitive and non-value-added. That's not to say
    they are not necessary. However, automating such processes improve cycle times
    and eliminate waste in the form of human, or other errors.
  prefs: []
  type: TYPE_NORMAL
- en: The issue of human error is especially concerning as the accumulation of configuration
    errors leads to **environmental drift** where each new environment configuration
    becomes uniquely different to previous configurations. Developers call the new
    configurations *snowflakes* because they share a similar characteristic in that
    each is unique from the others.
  prefs: []
  type: TYPE_NORMAL
- en: Managing environmental drift
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The problem with environmental drift is that each new change in the system's
    configuration can affect previously deployed assets. Recall that the function
    of operations is to maintain stable, secure, and available environments and applications.
    However, let's suppose a developer fails to communicate a new configuration change
    to the infrastructure or applications. In that case, those modifications cause
    the production environments to fail or expose them to security-related risks.
  prefs: []
  type: TYPE_NORMAL
- en: The same situation is valid for engineering and test environments. Changes in
    configurations make it increasingly difficult to isolate and fix errors that result
    from the configuration changes, as opposed to bugs or defects in the code. Again,
    each new configuration change can introduce waste in the form of defects that
    are time-consuming and expensive to resolve.
  prefs: []
  type: TYPE_NORMAL
- en: There are innumerable issues that contribute to environmental drift. However,
    most often, these configuration changes result from improper documentation, communication,
    or the implementation of new or modified parameters when setting up servers, configuring
    networks, or other computing resources.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding examples show human error as the root cause. Computers are better
    at executing rote instructions with accurately described configurations defined
    via code. But those types of errors can be discovered during the testing process,
    thereby avoiding any negative consequences and limiting any risks when new releases
    move into production.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding configuration errors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As with the CaC concepts, development teams employ IaC write scripts or code
    to describe the configuration settings and parameters. Each configuration file
    represents a single and authoritative source of defining and setting up an environment
    or updating an environment over time.
  prefs: []
  type: TYPE_NORMAL
- en: The code or scripts are saved as standalone configuration files and checked
    into the development team's version control and SCM systems. The advantage of
    managing IaC files in an SCM system is that the executable routines become freely
    available to all developers and operations staff via a self-service model.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, both CaC and IaC help to improve the velocity of software deliveries
    while simultaneously reducing errors.
  prefs: []
  type: TYPE_NORMAL
- en: Improving velocities while reducing errors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With CaC and IaC, IT staff can download and execute configuration files on demand
    and set up a new environment in minutes without introducing manual errors. The
    self-service model means that developers don't need to involve the operations
    team to stand up and provision new testing environments. Moreover, the operations
    team can ensure the code and configurations for new releases are appropriately
    tested before releasing new updates to the production environments.
  prefs: []
  type: TYPE_NORMAL
- en: IaC enables high velocities for CD to match the same types of velocities developers
    have available via their CI tools. With a CI/CD pipeline, developers can change
    both the code and configurations on the fly and stand up test environments to
    quickly determine that everything is working correctly. Moreover, high-performing
    shops can deploy new functionality multiple times per day with lead times of less
    than 1 hour (Forsgren et al., Accelerate, 2018).
  prefs: []
  type: TYPE_NORMAL
- en: IaC is the critical enabler for specifying CI/CD and DevOps pipeline configurations
    and flows. Manual configuration processes are simply too slow and too inefficient.
    As you will discover in the chapters on VSM, CI/CD and DevOps pipelines implement
    Lean production concepts across all IT value streams when they are adequately
    implemented.
  prefs: []
  type: TYPE_NORMAL
- en: However, before we get to those chapters, we need to understand how CI/CD and
    DevOps pipelines support work and information flow across all IT value streams.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling CI/CD and DevOps pipeline flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This book makes a clear distinction between CI/CD and DevOps toolchains and
    pipelines:'
  prefs: []
  type: TYPE_NORMAL
- en: A toolchain is a combination of tools that collectively perform a specific set
    of IT tasks or functions. This term may or may not imply an integration or automation
    strategy and is somewhat vague.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevOps pipelines and CI/CD pipelines include a series of integrated tools to
    streamline and automate IT tasks or functions across an IT value stream. Pipelines
    are more equivalent to the Lean and VSM concepts presented later in this book.
    For now, let's understand CI/CD and DevOps pipelines as improving the speed and
    reliability of software value delivery.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The term **toolchain** specifies a scope of tools that support IT value stream
    activities. Again, by itself, the term toolchain does not necessarily imply an
    integration or automation strategy. Although not ideal, developers can manually
    set up the following tool in line with the previous tools' outputs.
  prefs: []
  type: TYPE_NORMAL
- en: A better strategy is to improve efficiencies by integrating and automating the
    toolchains to coordinate and streamline work and information flows. In this context,
    the word **pipeline** connotes a flow. In the case of Lean-oriented production
    philosophies, we want streamlined and efficient flows of both work and information
    across our IT value streams.
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD and DevOps toolchains are integrated and automated to support the efficient
    and streamlined flow of work and information across all IT value streams. CI/CD
    and DevOps toolchains are called *pipelines* when the tools are integrated and
    automated to support streamlined and efficient work and information flows.
  prefs: []
  type: TYPE_NORMAL
- en: Improving pipeline flows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The distinction between toolchains versus pipelines is an important one. For
    example, an Agile-based software development team can procure a set of tools that
    collectively make up a toolchain. However, when chartered under a project-based
    operating model, it is unlikely that the team has the time or budget to implement
    an integrated or automated toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: In such scenarios, Agile teams never achieve the same production efficiencies
    that are available to the product-oriented teams that implement a complete pipeline.
    Since the product team lives across its product's life cycle, they can justify
    and amortize the CI/CD and DevOps pipeline toolchain investments.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a workaround for Agile teams. For example, the Agile team
    can access an integrated and automated toolchain as a cloud-based service via
    a commercial or internal DevOps platform provider. You will learn more about those
    options in *Section 3* of this book. For the remainder of this chapter, we will
    go beyond the CI/CD activities to look at the full scope of DevOps-related activities.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the full scope of DevOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CI/CD activities only take us as far as traditional SDLC processes, that is,
    from concept to deployment. But the IT organization must also maintain and support
    its software applications. For the remainder of this chapter, you will learn that
    DevOps goes beyond software development and delivery to ensure the proper life
    cycle support of deployed software products.
  prefs: []
  type: TYPE_NORMAL
- en: 'While DevOps still includes the base CI/CD activities you''ve learned so far
    in this chapter, the overall scope of work in DevOps expands to encompass all
    software life cycle stages. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Build automation and CI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CD and provisioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating, monitoring, supporting, and providing feedback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release coordination and automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss what these activities are beyond the CI/CD phase of software development
    and delivery. In the following subsection, we will begin to define the boundaries
    between CI/CD pipelines and DevOps pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Defining CI/CD and DevOps pipeline boundaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you learned at the beginning of this chapter, DevOps began as a collaboration
    strategy to enable Agile systems administration. The primary goal was to improve
    information flows between IT development and operations teams as a risk management
    strategy. However, DevOps necessarily evolved to address the issues related to
    mismatched velocities. In other words, the velocity of operations-oriented services
    needs to match the velocities of the Agile-based development teams.
  prefs: []
  type: TYPE_NORMAL
- en: In traditional IT vernacular, we use the term SDLC to refer to IT value stream
    activities and tools implemented by the development teams. In contrast, the operations
    team uses the term **ITSM** to describe all the activities and supporting tools
    involved in designing, creating, delivering, supporting, and managing IT services-related
    activities.
  prefs: []
  type: TYPE_NORMAL
- en: It should be no surprise that the term **DevOps pipeline** encompasses both
    SDLC and ITSM activities and tools, ultimately forming an integrated DevOps pipeline.
    In the following subsection, we'll take a look at how the CI/CD model is expanded
    to become a DevOps pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding the CI/CD model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The CI/CD model spans the activities customarily performed by a software development
    team spanning an iterative SDLC. DevOps expands the CI/CD pipeline concepts to
    include the IT operations team's activities. In other words, DevOps seeks to merge
    the activities of development and operations, ideally at the product team level.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an article titled *8 CI/CD best practices to set you up for success*, Taz
    Brown created the following diagram to show the larger complexities of implementing
    and supporting Lean value streams across the IT function. This diagram breaks
    the value stream into three distinct flows, that is, **Software Development**,
    **User Support**, and **Incident Management**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – IT value streams'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17087_Figure_5.6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – IT value streams
  prefs: []
  type: TYPE_NORMAL
- en: '[https://opensource.com/article/20/5/cicd-best-practices (Taz Brown, CC BY-SA
    4.0)](https://opensource.com/article/20/5/cicd-best-practices)'
  prefs: []
  type: TYPE_NORMAL
- en: This diagram simplifies the view of the activities needed to build, deploy,
    and support a product. While this model is incomplete from a DevOps perspective,
    it does highlight the separations between development and support-related activities.
  prefs: []
  type: TYPE_NORMAL
- en: The first line of the diagram, which is within the boundary line, depicts a
    standard CI/CD pipeline set of activities. Note that there is a decision point
    within the boundary to decide whether the development and operations teams are
    ready to deploy the software into the organization's production environments.
  prefs: []
  type: TYPE_NORMAL
- en: Given its presence outside the boundary line, the **Deploy Product** node suggests
    a manual decision and process. However, that doesn't have to be the case. With
    a mature CI/CD pipeline capability, the software release is automated.
  prefs: []
  type: TYPE_NORMAL
- en: The development and operations teams might still prefer some manual review process
    before release. However, even that requirement becomes unnecessary when releasing
    tiny increments of new functionality with increased velocity, using automated
    testing capabilities, and perhaps automating UAT across a small segment of users
    before deploying the releases to the larger community of users.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at lines two and three in *Figure 5.6*, we move into the operations
    team's traditional IT support and incident management functions. These activities
    fall under the ITSM processes.
  prefs: []
  type: TYPE_NORMAL
- en: However, this model is still missing the operations-oriented **IT operations
    management** (**ITOM**) processes. ITOM spans IT operations' control and facilities
    management but also overlaps with technical management and application management.
    A very mature DevOps pipeline integrates and automates these activities at the
    product team level.
  prefs: []
  type: TYPE_NORMAL
- en: We will dive into ITOM and ITSM in the last part of this chapter. But before
    we get to those topics, let's examine how the mismatched velocities between development
    and operations became the driver for evolving DevOps strategies and, later, DevOps
    toolchains and pipelines. That is the topic of our following subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving issues of mismatched velocities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As noted in the previous subsection, the speed of development often exceeds
    the ability of operations to manage the risks associated with effectively deploying
    new releases frequently. However, all of these issues can go away with CD and
    continuous deployment capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Many Agile-based IT developers employ innovative practices to deploy small increments
    of new functionality frequently using CI methods and tools. CI capabilities automate
    the frontend SDLC development processes to perform automated code integrations,
    builds, and integration tests every time developers check their code into the
    source code repository.
  prefs: []
  type: TYPE_NORMAL
- en: CD initially evolved to support automation testing needs, which sits at the
    boundaries between development and operations. Development teams should thoroughly
    test all new software releases before deployment, including systems, acceptance,
    load, stress, performance, and other critical tests. It takes time, computing
    resources, and human effort to manually set up the test environments to support
    these testing requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Put simply, manual testing processes cannot approach the velocities of CI. CD
    automates the activities that are required to read application and infrastructure
    configurations in code, provision testing servers, install and configure the applications,
    and then run all of the necessary tests.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous deployment takes the provisioning process one step further to automate
    the deployment process in the production environments. Moreover, continuous deployment
    can automate infrastructure resource provisioning in near real time to meet changing
    production demands.
  prefs: []
  type: TYPE_NORMAL
- en: The operations function can match the Agile-based development teams' velocities
    using CI methods and tools with CD and deployment capabilities. With its emphasis
    on the rapid delivery of high-quality products and services and just-in-time deliveries,
    Lean production processes offer a way to integrate the IT DevOps pipeline activities
    within a single IT value stream.
  prefs: []
  type: TYPE_NORMAL
- en: When you get to *Section 2* of this book, which is on *implementing VSM*, you
    will learn how to implement Lean production concepts across the IT value stream
    to create Lean pipeline flows. But before we move on to that part of the book,
    we need to look at the full scope of DevOps activities.
  prefs: []
  type: TYPE_NORMAL
- en: Scoping DevOps pipeline activities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As it turns out, a fully evolved DevOps pipeline encompasses quite a few integrated
    activities beyond CI/CD pipeline flows. In this section, we will explore the higher-level
    activities and how they operate as a continuous iterative and incremental development
    and support process.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you read this section, bear in mind what you learned in [*Chapter 1*](B17087_01_Final_PD_epub.xhtml#_idTextAnchor014),
    *Delivering Customer-Centric Value*, about organizations having two types of value
    streams: development and operations. As a reminder, operations-oriented value
    streams deliver products and services to an organization''s external customers,
    while development value streams create things used by the organization''s operations-oriented
    value streams.'
  prefs: []
  type: TYPE_NORMAL
- en: The DevOps acronym is confusing as the term implies operations and development
    are part of the same value stream, and they are. But the semantic meanings of
    development and operations in the DevOps acronym are different from Lean's contextual
    meanings. The DevOps paradigm includes the iterative SDLC activities associated
    with CI/CD pipelines, plus the operations activities include the product's ITSM
    activities.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.7* is a standard display for a DevOps pipeline. Although a DevOps
    pipeline can be displayed as a linear-sequential flow, the more common approach
    is to show it as an infinity loop. The infinity loop implies that iterative and
    incremental DevOps delivery activities operate as a continuous flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Infinite DevOps pipeline flows'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17087_Figure_5.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – Infinite DevOps pipeline flows
  prefs: []
  type: TYPE_NORMAL
- en: Modern Agile and Lean-Agile practices both implement iterative development cycles
    that deliver frequent increments of customer value. DevOps simply expands the
    iterative and incremental development model to encompass the IT service's management
    activities.
  prefs: []
  type: TYPE_NORMAL
- en: This DevOps model is overly simplistic, as its focus is only on conveying high-level
    pipeline processes. Just as we discovered with the CI/CD pipeline activities,
    the DevOps pipeline's ITSM portion includes many more activities than portrayed
    in the DevOps infinity loop diagram.
  prefs: []
  type: TYPE_NORMAL
- en: You already know how to implement CI/CD activities as pipelines into the DevOps
    pipeline model. In the next section, we will take a look at the activities associated
    with ITSM and their flows.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating ITSM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B17087_01_Final_PD_epub.xhtml#_idTextAnchor014), *Delivering
    Customer-Centric Value*, you learned that organizational value streams support
    development or operations and are often linked. You also learned that IT-based
    development-oriented value streams often create software products that support
    the operations-oriented value streams.
  prefs: []
  type: TYPE_NORMAL
- en: For example, an insurance company's internal software development team might
    create web-based services to support the company's insurance products' promotion,
    sales, and delivery. Similarly, health care software providers have development
    teams supporting multiple value streams. These can include patient registrations,
    claims management, financial management, accounting, diagnostic and billing codes,
    patient health data, appointment scheduling, compliance, and reporting.
  prefs: []
  type: TYPE_NORMAL
- en: However, as you already know, IT value streams go beyond the implementation
    of software development and delivery activities. Besides these capabilities, the
    IT organization or software product team must install ITOM capabilities and ITSM
    processes and platforms.
  prefs: []
  type: TYPE_NORMAL
- en: ITSM focuses on how IT teams deliver services. In contrast, ITOM focuses on
    the activities and tools used for event management, performance monitoring, and
    the operations processes depicted in the **OPS** portion of the DevOps pipeline
    (please refer to *Figure 5.7*). Ideally, the IT organization installs ITOM and
    ITSM activities at the product team level as part of their DevOps pipeline flows.
  prefs: []
  type: TYPE_NORMAL
- en: Conveniently, ITIL 4 already addresses ITOM and ITSM from a **service value
    s****ystem** (**SVS**) perspective. If the organization has implemented ITIL 4
    practices or equivalent, the VSM team needs to assess the operations-oriented
    work within the DevOps pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Delivering service value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previously displayed *Figure 5.7*, the DevOps pipeline's **OPS** portion
    includes **Release**, **Deploy**, **Operate**, and **Monitor** as its primary
    activities. Two of these activities, **Release** and **Deploy**, are transition
    activities that require support from both the development and operations side
    of the product teams.
  prefs: []
  type: TYPE_NORMAL
- en: However, in this section, you will learn that these 4 operations-oriented processes
    decompose into at least 34 separate ITSM domains spanning 3 management practices.
    The word domain implies a specified area of activity or knowledge. In the context
    of ITSM, you can presume the term domain includes specific areas of knowledge
    and related sets of activities.
  prefs: []
  type: TYPE_NORMAL
- en: The term service management broadly describes the practices and activities designed
    to improve a company's customer service processes. Service management includes
    activities spanning strategy, design, development, integration, operation, and
    service improvements. ITSM then includes the practices and activities to support
    customers using software and related infrastructure and security components produced
    or acquired by an IT organization.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple ITSM frameworks that a product team can choose to use, such
    as ISO/IEC 20000-1, ITIL 4®, COBIT 5, FitSM, **Microsoft Operations Framework**
    (**MOF**), The Open Group IT4IT Reference Architecture, VeriSM™, SIAM®, and YaSM®.
    Given its leadership position, this chapter evaluates how ITIL 4® defines its
    **service value chain** as part of its best practices to deliver ITSM in the context
    of DevOps, Agile, and Lean approaches.
  prefs: []
  type: TYPE_NORMAL
- en: ITIL 4® defines a *service value chain* as a set of "joined-up practices, activities,
    and actions used across the ITSM value stream." In other words, the ITIL 4® service
    value chain represents a flow. Of course, we know an ITSM value stream is only
    a component of the larger IT value stream work and information flows that are
    encompassed within a DevOps pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into the service value chain activities and flows, first, let's
    quickly take a look at the four dimensions of ITSM that help deliver value.
  prefs: []
  type: TYPE_NORMAL
- en: Encompassing the four dimensions of ITSM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ITIL 4 describes four dimensions of service management as the foundations of
    an ITSM provider''s capabilities. From a systems-thinking perspective, these four
    dimensions are elements that participate in value-based ITSM deliveries. They
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Organizations and People**: This is to build the right organizational structures
    and competencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Information and Technology**: This is to build IT systems and infrastructures
    with the right technologies to support service deliveries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partners and Suppliers**: This is to implement third-party service delivery
    contracts that are financially and technically appropriate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Value Streams and Processes**: This is to develop efficient and customer-centric
    service value delivery capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All four dimensions of service management help the product team deliver service
    value. Software product teams must coordinate their service value chain responses
    to involve all four dimensions. If not, the service delivery function does not
    operate optimally and will fail to deliver value to its customers and product
    users.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final note, external factors such as the following can impact a service
    delivery''s four dimensions: economic, environmental, legal, political, social,
    and technological. All of these factors must be considered when deciding how to
    deploy the four dimensions of service management.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the foundational elements of service management, let's
    explore the activity flows associated with ITSM.
  prefs: []
  type: TYPE_NORMAL
- en: Defining ITSM delivery flows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with any value stream, the ITIL 4® service value chain represents an activity
    flow; although it is described at a high level, as we''ll see in the following
    subsection. The service value chain includes six primary activities to respond
    to the IT service demands from a value delivery perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Plan**: This is to define an as-is/to-do assessment of the service capabilities,
    requirements, and policies to develop a common vision of what services are required
    and how they will be delivered.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Value delivered: New service identification and provisioning plan.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Improve**: This is to ensure the continual improvement of all products, services,
    and practices across all four dimensions of service management.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Value delivered: Attainment of service-level targets.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Engage**: This is to confirm our understanding of stakeholder needs, plus
    ensure timely engagement and positive outcomes with our stakeholders.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Value delivered: Managing and resolving a user''s complaint.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Design and transition**: This is to ensure that new releases of products
    and related services repeatedly meet stakeholder expectations for quality, cost,
    and time to market.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Value delivered: Enable upgrades to the next version of a business application.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Obtain/build**: This is to ensure that service components are available when
    and where they are needed and that they meet agreed specifications.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Value delivered: Timely and accurate fulfillment of a user request.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Deliver and support**: This is to ensure services are delivered and supported
    according to the agreed specifications or service-level agreement while meeting
    stakeholder expectations.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Value delivered: Successful resolution of all incident reports.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These six activities express the general flow of work to define, create, and
    deliver customer-centric services. So, just as software development has a flow
    that defined ideation through delivery, ITSM provides a value stream flow to define
    and deliver IT services. In DevOps, we need to integrate the two flows, as shown
    in *Figure 5.7*. Now, let's define the total potential scope of work involved
    in delivering value-based ITSM.
  prefs: []
  type: TYPE_NORMAL
- en: Delivering ITSM value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in this section, we mentioned, though not explicitly attributed to ITIL
    4®, the service value chain document's 34 separate ITSM domains spanning 3 management
    practices. Again, the term domains refers to both knowledge areas and related
    sets of activities. The scope of this book limits our abilities to dive deeper
    into describing each domain. However, ITIL 4® provides detailed guidance on planning,
    managing, and improving these management practices and domain-related activities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three groups of management practices include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**General Management Practices**: This group spans 14 service management domains
    from general business management that helps support work or accomplishing specific
    objectives. The domains include the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B17087_05_Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Service Management Practices**: This group spans 17 domains to ensure that
    services deliver agreed availability levels to meet customers'' and users'' needs.
    The domains include the following:![](img/B17087_05_Table_02.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technical Management Practices**: This group spans three domains to implement
    service management practices that expand or shift the focus from technology solutions
    to IT services. The domains include the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B17087_05_Table_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It should be apparent that ITSM brings in a much broader host of practices and
    activities to implement, improve, and support in a DevOps-oriented value stream.
    However, it's not necessary to go into the details of ITSM in this book. This
    chapter's primary goal is to introduce the scope of work involved in building
    and streamlining DevOps as orchestrated pipeline flows.
  prefs: []
  type: TYPE_NORMAL
- en: We are approaching the end of this chapter. By now, you should appreciate the
    complex challenges that lie ahead in developing a streamlined DevOps production
    flow. There are investments required in toolchains and innumerable activities
    to implement, integrate, automate, and orchestrate.
  prefs: []
  type: TYPE_NORMAL
- en: This book does not attempt to solve your specific CI/CD and DevOps pipeline
    flow issues but instead gives you the tools to do so. Specifically, *Section 2*
    of this book introduces an eight-step VSM methodology, modern VSM tools, and their
    capabilities. In this context, VSM encompasses the methods and tools you can use
    to improve Lean production flows across your CI/CD and DevOps pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Before we finish this chapter and this part of the book, there is one other
    topic we need to address, which is moving from a project-oriented development
    paradigm to a product-oriented development strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Moving beyond projects and into products
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The traditional waterfall model for software development is project-based. In
    the industry's early days, the project-oriented approach seemed to make sense
    due to the high costs, complexities, and risks involved in software development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the type of work that is best suited to traditional project management
    practices. For example, the characteristics of project-based work include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Projects have definable *deliverables* or outputs in the form of *products*,
    *services*, or *results*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project-based deliverables are relatively unique, and, therefore, the work has
    significant risks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project constraints are defined in project charters, approved by customers or
    executive sponsors, with specific boundaries on authorized *scope*, *schedule*,
    *costs*, and *quality*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project-oriented work is highly tailored to support each product's unique requirements,
    and, therefore, the work is relatively non-repetitive from one project to another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given that software product requirements are relatively unique, the work's full
    details and scope might only become apparent as the project progresses (this is
    also true for Agile-based work).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project teams employ formal change management practices to minimize scope creep,
    budget shortfalls, and schedule overruns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schedules help enforce the temporary nature of projects with defined start and
    delivery dates and predefined activities, dependencies, and durations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project-based work often crosses organizational boundaries, thereby involving
    multiple skills.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing highly customized work under a dictated set of constraints seems like
    an odd dichotomy – and it is. That said, we should understand why customers place
    constraints on project-related work. Specifically, our paying customers establish
    project constraints to ensure the projected ROI is achievable in the timeline
    and at a cost at which the investments make economic sense.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, developing software under project-based constraints creates a
    host of problems, three of which are critical. First, given each software product's
    unique nature, the development team cannot foresee all of the issues they might
    encounter. Second, customers and users often don't know what they want or need
    until they have a version of the software product in hand to evaluate. Third,
    customer needs evolve, and their priorities change over time.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that no matter how much time and effort the project team
    applies to project planning, it will be outdated before it can be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Modern software methods and tools have evolved to support the unique needs of
    software development, such as being responsive to customer demands and changes
    in priorities. That type of responsiveness was not possible under the traditional
    waterfall project management model. With fully developed CI/CD and DevOps pipelines,
    the most mature software development teams can iteratively, incrementally, and
    rapidly deliver new functionality, perhaps multiple times per day. Therefore,
    the CI/CD and DevOps pipelines have the functional equivalence of modern manufacturing
    facilities.
  prefs: []
  type: TYPE_NORMAL
- en: In *Section* *2* of this book, we'll explore how VSM helps improve Lean production
    flows across DevOps pipelines. But before we get to that, first, let's take a
    moment to understand why a product-based development and delivery model is superior
    to the traditional project-based waterfall model in software development.
  prefs: []
  type: TYPE_NORMAL
- en: Funding product teams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no need to constrain software development activities to a specific
    scope, schedule, cost, or quality metric. Instead, just as a manufacturing plant
    operates for as long as they have new customers' orders, the modern software factory
    continues to operate for as long as their customers have evolving product needs.
  prefs: []
  type: TYPE_NORMAL
- en: Physical products tend to wear out, forcing customers to replace them. In contrast,
    software products do not physically wear out. On the other hand, the requirements
    that drove the initial software development objectives tend to have a shelf life.
    In that context, customers eventually need to replace or update their software
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, it makes sense to move beyond the project model to implement
    a product-oriented development model. In a product-oriented development model,
    product teams replace project teams, and the teams stay together for as long as
    customers use the product.
  prefs: []
  type: TYPE_NORMAL
- en: The composition of the teams could change over time to support evolving requirements.
    At the beginning of the product's life cycle, development has an outsized role
    in efforts and costs. Toward the end of life, the development resources could
    dwindle, and the resource emphasis moves toward operations-oriented support.
  prefs: []
  type: TYPE_NORMAL
- en: A product-based funding model is different than a project-based funding model.
    Project-based funding builds on projected future returns on investments. The risk
    of project-based funding is twofold. First, there is a question of whether the
    product can be built within the authorized constraints. Second, there is a question
    of whether the market will exist in the future to support the investment.
  prefs: []
  type: TYPE_NORMAL
- en: Product-based funding is less risky as it turns the project-based model upside
    down. Instead of asking whether the product will eventually pay back the investment,
    product-based funding models evaluate current costs and revenues to assess how
    much money to invest in development and operations support.
  prefs: []
  type: TYPE_NORMAL
- en: There is still risk in the initial development cost investments. However, those
    risks move to the portfolio level, where corporate executives determine what investments
    they need to make to best position the company for future business. Those investments
    can develop new products or investments as enhancements to existing products to
    attract customers in new market niches. Portfolio-level investments are strategic,
    while ongoing adjustments to product team budgets are tactical decisions based
    on actual costs compared to actual revenues.
  prefs: []
  type: TYPE_NORMAL
- en: This section completes our final chapter of *Section 1* of this book. We'll
    close with a summary section and a set of 10 questions that will help you to analyze
    your comprehension of this chapter's content.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced the complexities of implementing CI/CD and DevOps pipeline
    flows. The information is a precursor to *Section 3* of this book, where you learn
    how to employ the methods and tools of VSM to implement and improve Lean production
    flows across your IT value streams.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, in this chapter, you learned the complexities of implementing
    mature CI/CD and DevOps pipelines. You learned that virtualization, primarily
    through container-based technologies, is crucial in order to support the efficient
    use of IT infrastructure resources and enable the rapid delivery of small increments
    of new software capabilities. Finally, you learned that CI/CD pipelines integrate
    and automate the traditional SDLC processes, but DevOps extends the CI/CD pipeline
    to include service management functions.
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, you are now well prepared to understand how to use VSM
    methods and tools to implement and improve DevOps activities as Lean production-oriented
    flows. VSM methods and tools form the next part of this book's subject – *Section
    2*, *Implementing Value Stream Management (VSM) Methods and Tools* – to improve
    IT value streams.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What drove the development of DevOps concepts and later its methods and tools?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three critical capabilities and related tools that support the
    implementation of CI/CD pipelines?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is CI, and what is its purpose?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the significant cultural differences between a software development
    team and an IT operations team?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is CD, and what is its goal?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between IaC and CaC?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the primary difference when using the term "toolchains" compared to
    "pipelines"?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using two terms only, what is the best way to describe the IT value streams
    that make up a DevOps pipeline?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you differentiate ITOM from ITSM?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are project-oriented teams funded differently from product-oriented teams?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dietrich, E. (June 2019) *DevOps Table Stakes: The Minimum Amount Required
    to Play the Game*. DZone/DevOps Zone. [https://dzone.com/articles/devops-table-stakes-the-minimum-amount-required-to](https://dzone.com/articles/devops-table-stakes-the-minimum-amount-required-to).
    Accessed 2nd February 2021.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**US National Institute of Standards and Technology** (**NIST**) Information
    Technology Laboratory. NATIONAL VULNERABILITY DATABASENIST. Special Publication
    800-53 (Rev. 4). *Security and Privacy Controls for Federal Information Systems
    and Organizations*. [https://nvd.nist.gov/800-53/Rev4/control/CM-6](https://nvd.nist.gov/800-53/Rev4/control/CM-6).
    Accessed 2nd February 2021.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forsgren, N., Humble, J., Kim, G. (2018) *Accelerate. Building and Scaling High-Performance
    Technology Organizations*. IT Revolution. Portland, OR.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
