<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer135">
			<h1 id="_idParaDest-150"><em class="italic"><a id="_idTextAnchor261"/>Chapter 9</em>: Using the Datadog REST API</h1>
			<p>In the previous chapter, you learned how platform components, mainly made up of third-party software products and cloud services, are integrated with Datadog, by way of Datadog-supported integrations and custom checks. The main objective of those integrations is to monitor third-party tools used in the application stacks from Datadog. The integration with Datadog can be done in the other direction also. Tools and scripts can use Datadog HTTP REST APIs to access the Datadog platform programmatically. For example, if you need to post a metric value or an event to Datadog from an application, that can be done using the related REST APIs. </p>
			<p>The Datadog REST API set is a comprehensive programmatic interface to access the Datadog monitoring platform. The APIs can be used to post custom metrics, create monitors and dashboards, tag various resources, manage logs, and create and manage users and roles. Essentially, anything that you can perform from the Datadog UI and by making configuration changes at the agent level. </p>
			<p>In this chapter, you will learn the basics of using Datadog APIs from command-line tools and programming languages, with the help of tutorials. Specifically, the following topics are covered:</p>
			<ul>
				<li>Scripting Datadog</li>
				<li>Reviewing Datadog APIs</li>
				<li>Programming with Datadog APIs</li>
			</ul>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor262"/>Technical requirements</h1>
			<p>To try out the examples in this book, you need to have the following tools installed and resources available:</p>
			<ul>
				<li>A Datadog account with an API key provisioned</li>
				<li>style, check throughout</li>
				<li><strong class="bold">Python 2.7</strong> or <strong class="bold">Python 3.8</strong> or higher</li>
			</ul>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor263"/>Scripting Datadog</h1>
			<p>In this section, you will learn how to make calls to Datadog APIs using the curl command-line tool and how to use the APIs from Python. An important prerequisite to access the <a id="_idIndexMarker508"/>Datadog platform programmatically is to set up user access for that purpose. While authentication is done with the use of dedicated user credentials or SAML when the Datadog UI is accessed, a pair of application and API keys is used with Datadog APIs. Let's see how those keys are set up.</p>
			<p>By navigating to <strong class="bold">Team</strong> | <strong class="bold">Applications Keys</strong>, a new application key pair can be created on the <strong class="bold">Application Keys</strong> page as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer127" class="IMG---Figure">
					<img src="Images/Figure_9.1_B16483.jpg" alt="Figure 9.1 – Generating application keys&#13;&#10;" width="537" height="330"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – Generating application keys</p>
			<p>A new key can be created by clicking on the <strong class="bold">New Key</strong> button and providing it with a new name. The newly generated key will be listed on the same <strong class="bold">Application Keys</strong> page. It can be viewed and copied to the clipboard by clicking on a specific key listed in the preceding table, as in the following screenshot:</p>
			<div>
				<div id="_idContainer128" class="IMG---Figure">
					<img src="Images/Figure_9.2_B16483.jpg" alt="Figure 9.2 – Viewing an application key&#13;&#10;" width="282" height="196"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – Viewing an application key</p>
			<p>By navigating to <strong class="bold">Integrations</strong> | <strong class="bold">APIs</strong> on the Datadog dashboard, you can get to the APIs page <a id="_idIndexMarker509"/>where the API key can be created or an existing one can be copied, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="Images/Figure_9.3_B16483.jpg" alt="Figure 9.3 API Keys page&#13;&#10;" width="614" height="259"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3 API Keys page</p>
			<p>By providing a name in the <strong class="bold">New API key</strong> field and clicking on the <strong class="bold">Create API Key</strong> button, a new key can be generated. The generated keys are listed as shown in the preceding screenshot.</p>
			<p>An application key is unique to the Datadog organization where it is set up. The API key is tied to the Datadog user and so it inherits the related privileges. For authenticating from a program, an application key and an API key must be used, identifying the organization and the user. We will see how an application and API key pair is used in the sample programs, further illustrating the use of keys.</p>
			<p>The Datadog APIs <a id="_idIndexMarker510"/>can be called from a command-line tool such as curl as part of an ad hoc shell script or such calls can be invoked using a programming language such as <strong class="bold">'Python', 'Go', and 'Java'</strong><em class="italic">.</em> In this section, you will learn how API calls are made from curl and Python.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor264"/>curl</h2>
			<p>In the following example, we will see how a simple <strong class="source-inline">curl</strong> API call can be used to query for the hosts <a id="_idIndexMarker511"/>monitored by Datadog. As you can see, the JSON output <a id="_idIndexMarker512"/>is verbose and that is usually meant for some automated processing and not meant for manual consumption of any sort:</p>
			<p class="source-code">$ curl -s -X GET https://app.datadoghq.com/api/v1/hosts -H "Content-Type: application/json" -H "DD-API-KEY: cd5bc9603bc23a2d97beb118b75f7b11" -H "DD-APPLICATION-KEY: 21f769cbd8f78e158ad65b5879a36594c77eb076" |python -m json.tool</p>
			<p class="source-code">            "metrics": {</p>
			<p class="source-code">                "cpu": 15.446295,</p>
			<p class="source-code">                "iowait": 0,</p>
			<p class="source-code">                "load": 1.0077666</p>
			<p class="source-code">            },</p>
			<p class="source-code">            "mute_timeout": null,</p>
			<p class="source-code">            "name": "thomass-mbp-2.lan",</p>
			<p class="source-code">            "sources": [</p>
			<p class="source-code">                "agent"</p>
			<p class="source-code">            ],</p>
			<p class="source-code">            "tags_by_source": {</p>
			<p class="source-code">                "Datadog": [</p>
			<p class="source-code">                    "host:thomass-mbp-2.lan"</p>
			<p class="source-code">                ]</p>
			<p class="source-code">            },</p>
			<p class="source-code">            "up": true</p>
			<p class="source-code">        }</p>
			<p class="source-code">    ],</p>
			<p class="source-code">    "total_matching": 1,</p>
			<p class="source-code">    "total_returned": 1</p>
			<p class="source-code">}</p>
			<p><em class="italic">(Only an excerpt of the output is provided here. The full version can be found in the GitHub repository for this chapter.)</em></p>
			<p>The output is verbose, and the preceding code is only an excerpt of it. The result provides detailed information about the hosts where the Datadog agents run.</p>
			<p>Though this is a simple API call, there are multiple things you can learn about the Datadog APIs and curl from this example, so let's look at those one by one.</p>
			<p>Not only does <a id="_idIndexMarker513"/>the command-line tool curl need to be installed in the local environment, typically in some Unix shell depending on the operating system that <a id="_idIndexMarker514"/>you are working on, but Python must also be available. Python is needed because the output from the API call is piped into the Python module <strong class="source-inline">json.tool</strong>, which formats the output to look better. So, it's optional in this case, but you will need Python to run the other sample programs.</p>
			<p>Let's look at each piece in the <strong class="source-inline">curl</strong> call:</p>
			<ul>
				<li>The <strong class="source-inline">-s</strong> switch passed to curl silences the tool from outputting messages about its own working. That is a good practice when the output is supposed to be parsed by another tool or code to avoid mixing it with the result from the API call.</li>
				<li><strong class="source-inline">-X GET</strong> is the HTTP verb or method used and the <strong class="source-inline">-X</strong> option of curl is used for specifying that. The <strong class="source-inline">GET</strong> method allows the reading of resources and it's the default method when making REST API calls from any tool, including curl. So, in this case, there is no need to use <strong class="source-inline">-X GET</strong> as <strong class="source-inline">GET</strong> is the default verb. The other important methods are <strong class="source-inline">POST</strong> (for creating new resources), <strong class="source-inline">PUT</strong> (for updating new resources), and <strong class="source-inline">DELETE</strong> (for deleting existing resources). We will see the use of all these methods in this chapter; note that <strong class="source-inline">POST</strong> and <strong class="source-inline">PUT</strong> are used interchangeably.</li>
				<li><a href="https://app.datadoghq.com">https://app.datadoghq.com</a> is the URL to access the Datadog backend.</li>
				<li><strong class="source-inline">/api/v1/hosts</strong> is the API endpoint that is used to list the hosts. An API endpoint corresponds to a resource that could be accessed via the REST API. The HTTP method used along with the API endpoint determines the nature of the action. (These conventions are not always followed strictly.) For example, <strong class="source-inline">GET</strong> returns details about the existing hosts, and a <strong class="source-inline">POST</strong> or <strong class="source-inline">PUT</strong> call could be used to make some change to the same resource.</li>
				<li>The <strong class="source-inline">-H</strong> option of curl lets you pass in an HTTP header as part of the API call. In this example, three such headers, <strong class="source-inline">Content-Type</strong>, <strong class="source-inline">DD-API-KEY</strong>, and <strong class="source-inline">DD-APPLICATION-KEY</strong>, are passed. Practically, the headers can be considered inputs to the API call. With the <strong class="source-inline">POST</strong> and <strong class="source-inline">PUT</strong> methods, data can be passed to the call as input <a id="_idIndexMarker515"/>using the <strong class="source-inline">-d</strong> option of curl (which is akin to passing in input for a web form), but with a <strong class="source-inline">GET</strong> call, a header is the only option. In this case, <strong class="source-inline">Content-Type</strong> tells the API to return the result in JSON format.</li>
				<li>As the names <a id="_idIndexMarker516"/>suggest, the headers <strong class="source-inline">DD-API-KEY</strong> and <strong class="source-inline">DD-APPLICATION-KEY</strong> are used to specify the API key and application key pair for authentication. The keys used in this example were those generated earlier in this section.</li>
				<li><strong class="source-inline">python -m json.tool</strong> is used to format the JSON output from the API call for better readability. Note that this is not part of the API call. The <strong class="source-inline">|</strong> symbol (known as a pipe in Unix shell terminology) is used to combine both the commands to generate the preceding output.</li>
			</ul>
			<p>Now, let's make the same API call with a different set of options to illustrate the usage of <strong class="source-inline">curl</strong> with the Datadog REST<a id="_idTextAnchor265"/> API:</p>
			<p class="source-code">$ curl -i https://app.datadoghq.com/api/v1/hosts  -H "DD-API-KEY: cd5bc9603bc23a2d97beb118b75f7b11" -H "DD-APPLICATION-KEY: 21f769cbd8f78e158ad65b5879a36594c77eb076"</p>
			<p class="source-code">HTTP/2 200 </p>
			<p class="source-code">date: Sun, 24 Jan 2021 22:48:05 GMT</p>
			<p class="source-code">content-type: application/json</p>
			<p class="source-code">content-length: 2687</p>
			<p class="source-code">vary: Accept-Encoding</p>
			<p class="source-code">pragma: no-cache</p>
			<p class="source-code">cache-control: no-cache</p>
			<p class="source-code">set-cookie: DD-PSHARD=134; Max-Age=604800; Path=/; expires=Sun, 31-Jan-2021 22:48:05 GMT; secure; HttpOnly</p>
			<p class="source-code">x-dd-version: 35.3760712</p>
			<p class="source-code">x-dd-debug: V1SoipvPhHDSfl6sDy+rFcFwnEIiS7Q6PT</p>
			<p class="source-code">TTTi5csh65nTApZwN4YpC1c2B8H0Qt</p>
			<p class="source-code">x-content-type-options: nosniff</p>
			<p class="source-code">strict-transport-security: max-age=15724800;</p>
			<p class="source-code">content-security-policy: frame-ancestors 'self'; report-uri https://api.datadoghq.com/csp-report</p>
			<p class="source-code">x-frame-options: SAMEORIGIN</p>
			<p>In this <a id="_idIndexMarker517"/>version of the <strong class="source-inline">curl</strong> call, the output is not formatted, but a very useful <strong class="source-inline">curl</strong> option <strong class="source-inline">-i</strong> is used. It adds <a id="_idIndexMarker518"/>header information to the result that can be used to process the output better. Important header information available in the first line of the output is the HTTP status code <strong class="source-inline">HTTP/2 200</strong>. A status code in the <strong class="source-inline">200</strong> range indicates that the API call was successful. Looking at the HTTP status code is important for an automated script to take appropriate action if the REST API call fails. The <strong class="source-inline">200</strong> range of codes indicates various success statuses, the <strong class="source-inline">300</strong> range of codes are related to URL redirection, the <strong class="source-inline">400</strong> range of codes point to issues with client calls such as bad URLs and authentication issues, and the <strong class="source-inline">500</strong> range of codes indicate server-side issues. In general, looking at the information available in the header of an API call result is important to make your script robust.</p>
			<p>Now let's see how a <strong class="source-inline">POST</strong> API call can be done using <strong class="source-inline">curl,</strong> which would make some change to a <a id="_idIndexMarker519"/>resource. In the following example, the selected <a id="_idIndexMarker520"/>host is muted programmatically from sending out any alert notifications:</p>
			<p class="source-code">$ curl -i -X POST https://app.datadoghq.com/api/v1/host/thomass-mbp-2.lan/mute  -H "DD-API-KEY: cd5bc9603bc23a2d97beb118b75f7b11" -H "DD-APPLICATION-KEY: 21f769cbd8f78e158ad65b5879a36594c77eb076" -d @mute.json</p>
			<p class="source-code">HTTP/2 200 </p>
			<p class="source-code">date: Mon, 25 Jan 2021 01:21:59 GMT</p>
			<p class="source-code">content-type: application/json</p>
			<p class="source-code">content-length: 74</p>
			<p class="source-code">vary: Accept-Encoding</p>
			<p class="source-code">pragma: no-cache</p>
			<p class="source-code">cache-control: no-cache</p>
			<p class="source-code">set-cookie: DD-PSHARD=134; Max-Age=604800; Path=/; expires=Mon, 01-Feb-2021 01:21:59 GMT; secure; HttpOnly</p>
			<p class="source-code">x-dd-version: 35.3760712</p>
			<p class="source-code">x-dd-debug: HbtaOKlJ6OCrx9tMXO6ivMTrEM+g0c93H</p>
			<p class="source-code">Dp08trmOmgdHozC5J+vn10F0H4WPjCU</p>
			<p class="source-code">x-content-type-options: nosniff</p>
			<p class="source-code">strict-transport-security: max-age=15724800;</p>
			<p class="source-code">content-security-policy: frame-ancestors 'self'; report-uri https://api.datadoghq.com/csp-report</p>
			<p class="source-code">x-frame-options: SAMEORIGIN</p>
			<p class="source-code">{"action":"Muted","downtime_id":1114831177,"hostname":"thomass-mbp-2.lan"}</p>
			<p>The following <a id="_idIndexMarker521"/>are the new points you need to note from the preceding example:</p>
			<ul>
				<li><strong class="source-inline">POST</strong> is used as the API call method using the <strong class="source-inline">curl</strong> option <strong class="source-inline">-X</strong>.</li>
				<li>The API endpoint <strong class="source-inline">/api/v1/host/thomass-mbp-2.lan/mute</strong> contains the hostname that is changed by the API call and the action taken.</li>
				<li>The input is provided using the <strong class="source-inline">curl</strong> option <strong class="source-inline">-d</strong>. The <strong class="source-inline">@</strong> symbol indicates that the string it precedes is the name of a file and the input must be read from it. Without the <strong class="source-inline">@</strong> qualifier, the string is considered a literal input. See the content of the input file <strong class="source-inline">mute.json</strong> used in the sample program:<p class="source-code">{</p><p class="source-code">  "action": "Muted",</p><p class="source-code">  "end": 1893456000,</p><p class="source-code">  "message": "Muting my host using curl"</p><p class="source-code">}</p><p>The input <a id="_idIndexMarker522"/>parameters are specific to an API endpoint and the required information must be provided.</p></li>
				<li>The JSON message from the Datadog backend is the last part of the output. While that would provide some indication of the outcome of an API call, its success must be determined in conjunction with the HTTP status code as you learned from the previous example:<p class="source-code">HTTP/2 200 </p><p class="source-code">{"action":"Muted","downtime_id":1114831177,"hostname":"thomass-mbp-2.lan"}</p></li>
			</ul>
			<p>If you look up the same host on the Datadog UI, you can verify that it's muted as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="Images/Figure_9.4_B16483.jpg" alt="Figure 9.4 – A host muted programmatically&#13;&#10;" width="1639" height="664"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4 – A host muted programmatically</p>
			<p>curl is a very <a id="_idIndexMarker523"/>useful tool to make calls to Datadog APIs from <a id="_idIndexMarker524"/>scripts. However, for more robust automation, you need to use a programming language such as Python.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor266"/>Python</h2>
			<p>Now, let's see how Datadog REST API calls can be made from Python. While the utility of curl cannot <a id="_idIndexMarker525"/>be discounted, serious automation <a id="_idIndexMarker526"/>projects tend to use a full-featured programming language such as Python to build programs used in production. Similarly, other programming languages such as Go, Java, and Ruby are also supported by Datadog, by providing language-specific wrappers to the REST APIs.</p>
			<p>In the following sample Python program, a custom event is posted to the Datadog backend:</p>
			<p class="source-code"># post-event.py</p>
			<p class="source-code">from datadog import initialize, api</p>
			<p class="source-code">options = {</p>
			<p class="source-code">    "api_key": "cd5bc9603bc23a2d97beb118b75f7b11",</p>
			<p class="source-code">    "app_key": "21f769cbd8f78e158ad65b5879a36594c77eb076",</p>
			<p class="source-code">}</p>
			<p class="source-code">initialize(**options)</p>
			<p class="source-code">title = "Event from Datadog tutorial book"</p>
			<p class="source-code">text = "Hello World! My test program finally worked and posted an event!"</p>
			<p class="source-code">tags = ["application:pymonitor"]</p>
			<p class="source-code">api.Event.create(title=title, text=text, tags=tags)</p>
			<p>The test program is self-explanatory. All the inputs needed are hardcoded in it, including the key pair <a id="_idIndexMarker527"/>needed for user authentication. In a real-life program used in production, the use of keys will be parameterized for flexibility <a id="_idIndexMarker528"/>and security. Anticipated exceptions in the program will be handled for robustness.</p>
			<p>You need to have Python installed in your local environment to run this program and the Datadog client library. The Datadog client library can be installed as a Python module using the <strong class="source-inline">pip</strong> utility, which is normally installed with Python:</p>
			<p class="source-code">$ pip install datadog</p>
			<p>The preceding sample Python code can be saved in <strong class="source-inline">post-event.py</strong> and can be run by invoking it with Python as follows:</p>
			<p class="source-code">$ python post-event.py</p>
			<p>The success of running this program can be verified on the <strong class="bold">Events</strong> dashboard of the Datadog UI also, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="Images/Figure_9.5_B16483.jpg" alt="Figure 9.5 – An event posted by a Python program&#13;&#10;" width="1257" height="391"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5 – An event posted by a Python program</p>
			<p>Note how <a id="_idIndexMarker529"/>the title, body, and tags information <a id="_idIndexMarker530"/>provided by the program is translated into corresponding attributes of the newly published event.</p>
			<p>With these examples, you learned the basics of calling Datadog APIs using curl and Python. In the next section, you will get an overview of important APIs that you can use to integrate applicati<a id="_idTextAnchor267"/>ons with Datadog.</p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor268"/>Reviewing Datadog APIs</h1>
			<p>In this section, we will discuss the main Datadog features that can be accessed and managed <a id="_idIndexMarker531"/>programmatically using the REST API. As mentioned earlier, anything that you can do on the Datadog UI can be accomplished from code using Datadog APIs. In a highly automated environment, that option would be very handy as all the monitoring-related activities could be consolidated on the Datadog platform. If integration from an application is not directly supported readily, then custom integration using REST APIs is one of the best options available. (There are special cases in <a id="_idIndexMarker532"/>which monitoring standards such as <strong class="bold">StatsD</strong> and <strong class="bold">JMX</strong> could be <a id="_idIndexMarker533"/>used and we will look at how to use those in the next chapter, <em class="italic">Working with Monitoring Standards</em>.)</p>
			<p>Let's look at the broad categor<a id="_idTextAnchor269"/>ies of Datadog APIs.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor270"/>Public cloud integration</h2>
			<p>By integrating with the leading public cloud platforms, <strong class="bold">AWS</strong>, <strong class="bold">Azure</strong>, and <strong class="bold">GCP</strong>, Datadog can import <a id="_idIndexMarker534"/>infrastructure information without the help of any agent. The related configuration changes can be done programmatically using the Datadog APIs.</p>
			<p>A typical <a id="_idIndexMarker535"/>use case would be the provisioning of a new public cloud account that needs to be integrated with Datadog. In a mature environment, public cloud <a id="_idIndexMarker536"/>resources are provisioned automatically using tools <a id="_idIndexMarker537"/>such as <strong class="bold">Terraform</strong> or <strong class="bold">custom scripts</strong>, or a combination of both, and the Datadog APIs would be handy for adding support for Datadog integration as part of the infrastructu<a id="_idTextAnchor271"/>re provisioning process.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor272"/>Dashboards</h2>
			<p>The dashboard <a id="_idIndexMarker538"/>tasks that you perform from the Datadog UI can be done using APIs also. The following are some of the important API endpoints that cover the entire life cycle of a dashboard:</p>
			<ul>
				<li>Creating a dashboard</li>
				<li>Listing existing dashboards</li>
				<li>Getting details about a dashboard</li>
				<li>Updating and deleting an existing dashboard</li>
				<li>Sending invitations to share a dashboard with other users</li>
				<li>Revoking t<a id="_idTextAnchor273"/>he sharing of a dashboard</li>
			</ul>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor274"/>Downtime</h2>
			<p>Downtime is <a id="_idIndexMarker539"/>set on a monitor to stop it from sending out alert notifications. As discussed earlier, such configurations are needed for some operational reasons, such as when pushing code to a production environment. The life cycle of downtime, starting from scheduling through cancelation, can be m<a id="_idTextAnchor275"/>anaged using related APIs.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor276"/>Events</h2>
			<p>In the previous <a id="_idIndexMarker540"/>section, you saw that events can be posted to the Datadog events stream by using an API call. APIs are also available to get the details of an event and to query events <a id="_idTextAnchor277"/>using filters such as tags.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor278"/>Hosts</h2>
			<p>Details about <a id="_idIndexMarker541"/>hosts monitored by Datadog can be gathered using APIs, and some of the important details are these:</p>
			<ul>
				<li>Total number of active hosts</li>
				<li>Details of all hosts monitored by Datadog</li>
				<li>Details for muting/unmuting a host</li>
			</ul>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor279"/>Metrics</h2>
			<p>Using the <a id="_idIndexMarker542"/>Datadog APIs, these tasks related to metrics can be performed:</p>
			<ul>
				<li>Posting metrics data to the Datadog backend</li>
				<li>Querying metrics data already posted to the Datadog backend</li>
			</ul>
			<p>The APIs to post and query metrics data are widely used for integrating with Datadog. As Datadog has excellent charting, dashboarding, and monitoring management features, making monitoring data available in the form of time-series data on the Datadog platform is very attractive. </p>
			<p>In the next section, you will learn how custom metrics data is published to Datadog and use it later <a id="_idTextAnchor280"/>for building useful monitors.</p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor281"/>Monitors</h2>
			<p>Monitors watch <a id="_idIndexMarker543"/>metrics data and check and notify based on the thresholds set. The entire life cycle of a monitor can be managed using APIs, including these tasks:</p>
			<ul>
				<li>Life cycle stages such as creating, updating, and deleting a monitor</li>
				<li>Getting the details of a monitor</li>
				<li>Searching monitors</li>
				<li>Muting a monitor</li>
			</ul>
			<p>In the next <a id="_idIndexMarker544"/>section, you will learn how to use some of the specific API endpoint<a id="_idTextAnchor282"/>s related to managing monitors.</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor283"/>Host tags</h2>
			<p>You have already learned that a tag is an important resource type in Datadog for organizing <a id="_idIndexMarker545"/>and filtering information, especially metrics data. Datadog provides excellent API support for applying and managing host-level tags. These are the main endpoints:</p>
			<ul>
				<li>Add, update, and remove a host-level tag.</li>
				<li>List tags defined at the host level.</li>
			</ul>
			<p>In general, Datadog API endpoints to manage resources provide the option to apply tags to them. Also, tags can be used as one of the filtering options with the APIs used for querying these resources. You will learn how to do that in sample programs in the next section.</p>
			<p>We have only looked at the important resources and related API endpoints in this section. To obtain the most complete and latest information on Datadog APIs, the starting point is the <a id="_idIndexMarker546"/>official Datadog APIs page at <a href="https://docs.datadoghq.com/api/">https://docs.datadoghq.com/api/</a>.</p>
			<p>The next section is a tutorial to explain the use of Datadog APIs further<a id="_idTextAnchor284"/> by using sample Python programs.</p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor285"/>Programming with Datadog APIs</h1>
			<p>In this tutorial section, you will learn how to publish a custom metric and use that custom <a id="_idIndexMarker547"/>metric to set up a monitor programmatically. You will also learn how to publish an event in the Datadog events stream and search the event stream using keywords. Then a monitor will be set up that is based on the newly created custom metric. You will also learn how these events, the creation of the custom metric and monitor, are posted to the events stream. Finally, you will learn <a id="_idIndexMarker548"/>how the events stream is queried using a known tag that helps to locate the events programmatically p<a id="_idTextAnchor286"/>osted to the events stream earlier.</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor287"/>The problem</h2>
			<p>For the tutorial, let's assume that you are maintaining an e-commerce site and you need to monitor <a id="_idIndexMarker549"/>the performance of the business on an hourly basis, which management might be interested in tracking. There is a custom program to query the hourly order from the company's order management system, which will also post the metric data to Datadog, and it is scheduled to run every hour.</p>
			<p>Once the metrics data is available in Datadog, that could be used in building monitors and dashboards. Also, whenever the hourly run of the custom program is completed, it will post an event in the Datadog events stream indicating the completion of the hourly job. This will make sure that if something goes wrong with the scheduled job, you can get detail<a id="_idTextAnchor288"/>s about that from the events stream.</p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor289"/>Posting metric data and an event</h2>
			<p>The following <a id="_idIndexMarker550"/>Python program will post the hourly <a id="_idIndexMarker551"/>count of orders and a <a id="_idTextAnchor290"/>related event to the Datadog platform:</p>
			<p class="source-code"># post-metric-and-event.py</p>
			<p class="source-code">import sys</p>
			<p class="source-code">import time</p>
			<p class="source-code">from datadog import initialize, api</p>
			<p class="source-code">options = {</p>
			<p class="source-code">    "api_key": "cd5bc9603bc23a2d97beb118b75f7b11",</p>
			<p class="source-code">    "app_key": "21f769cbd8f78e158ad65b5879a36594c77eb076",</p>
			<p class="source-code">}</p>
			<p class="source-code">initialize(**options)</p>
			<p class="source-code"># Get the hourly count as a parameter.</p>
			<p class="source-code">orders_count=int(sys.argv[1])</p>
			<p class="source-code">ts=time.time()</p>
			<p class="source-code">tag_list=["product:cute-game1","fulfillment_type:download"]</p>
			<p class="source-code"># Post metric data</p>
			<p class="source-code">api.Metric.send(</p>
			<p class="source-code">   metric='mycompany.orders.hourly_count', </p>
			<p class="source-code">   points=(ts,orders_count),</p>
			<p class="source-code">   tags=tag_list)</p>
			<p class="source-code"># Set event info for posting</p>
			<p class="source-code">title = "Posted hourly sales count"</p>
			<p class="source-code">text = "Hourly sales count has been queried from order fulfillment system and posted to Datadog for tracking.\nHourly Count: "+sys.argv[1]</p>
			<p class="source-code"># Post event</p>
			<p class="source-code">api.Event.create(title=title, text=text, tags=tag_list)</p>
			<p class="source-code">The Python code provided here can be saved in a file named post-metric-and-event.py and it could be executed as follows from a UNIX shell with Python installed:</p>
			<p class="source-code">$ python post-metric-and-event.py SALES_ORDERS_COUNT </p>
			<p>Let's look at this program closely. The first part is related to authentication and app client initialization, which you have seen already in the first Python sample program. The <strong class="source-inline">orders_count</strong> value is passed into this program as a parameter, which is mentioned on the command line as <strong class="source-inline">SALES_ORDERS_COUNT,</strong> and that should be replaced with a real number when the program is executed. In real life, another program would estimate that <a id="_idIndexMarker552"/>number and pass it on to this Python program. The sales orders count could be estimated within the Python program also, in which case there is no need to pass in <strong class="source-inline">orders_count</strong> as a parameter.</p>
			<p>The current <a id="_idIndexMarker553"/>timestamp is stored in a variable and used with the publishing time-series metrics data later, as follows:</p>
			<p class="source-code">ts=time.time()</p>
			<p><strong class="source-inline">ts</strong> stores the Unix timestamp that pertains to the current time, which is passed along with the metric value:</p>
			<p class="source-code">tag_list=["product:cute-game1","fulfillment_type:download"]</p>
			<p><strong class="source-inline">tag_list</strong> sets up an array of tags that are applied to the metric data posted to Datadog.</p>
			<p>The following is the API call that posts the metric data to Datadog:</p>
			<p class="source-code">api.Metric.send(</p>
			<p class="source-code">   metric='mycompany.orders.hourly_count', </p>
			<p class="source-code">   points=(ts,orders_count),</p>
			<p class="source-code">   tags=tag_list)</p>
			<p><strong class="source-inline">metric</strong> should be the name of the metric and it is not created explicitly – posting it with a data point is enough. <strong class="source-inline">points</strong> has to be a tuple consisting of the timestamp and a scalar value that represents the metric value at the point in time represented by the timestamp. </p>
			<p>The metric value must be a number and that's why, earlier in the sample program, <strong class="source-inline">orders_count</strong> was converted as an integer from the value passed in from the command line:</p>
			<p class="source-code">orders_count=int(sys.argv[1]) </p>
			<p>The second part of the program is setting the text for the event and posting it to Datadog. After this program is executed, the results can be verified on the Datadog UI.</p>
			<p>The metric <a id="_idIndexMarker554"/>and the metric time-series data can be <a id="_idIndexMarker555"/>looked up using <strong class="bold">Metrics Explorer</strong> as in the following screenshot:</p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="Images/Figure_9.6_B16483.jpg" alt="Figure 9.6 – Custom metrics listed on Metrics Explorer&#13;&#10;" width="1645" height="669"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.6 – Custom metrics listed on Metrics Explorer</p>
			<p>In the <strong class="bold">Graph</strong> field, the custom metric <strong class="source-inline">mycompany.orders.hourly_count</strong> can be pulled up. The tags applied on the custom metric could be looked up in the <strong class="bold">Over</strong> field. If the same metric is tracked for different products and fulfillment types, you can easily differentiate those by applying appropriate values to the tags.</p>
			<p>The events posted could be viewed on the <strong class="bold">Events stream</strong> dashboard as in the following screenshot:</p>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="Images/Figure_9.7_B16483.jpg" alt="Figure 9.7 – Custom event posted to Events stream&#13;&#10;" width="1503" height="707"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.7 – Custom event posted to Events stream</p>
			<p>You can <a id="_idIndexMarker556"/>visually verify that the details posted from the <a id="_idIndexMarker557"/>program appear in the events stream as expected. If the hourly aggregation of sales count fails for some reason, that status could be posted to the events stream as well, and that would be a good piece of informati<a id="_idTextAnchor291"/>on for those who would triage the failure.</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor292"/>Creating a monitor</h2>
			<p>Let's try to set up a monitor programmatically using the custom metric just created. There might <a id="_idIndexMarker558"/>be a need for management to know if the hourly order count falls below <strong class="source-inline">100</strong>. The monitor can be set up for alerting in that simple scenario:</p>
			<p class="source-code"># create-monitor.py</p>
			<p class="source-code">from datadog import initialize, api</p>
			<p class="source-code">  </p>
			<p class="source-code">options = {</p>
			<p class="source-code">    "api_key": "cd5bc9603bc23a2d97beb118b75f7b11",</p>
			<p class="source-code">    "app_key": "21f769cbd8f78e158ad65b5879a36594c77eb076",</p>
			<p class="source-code">}</p>
			<p class="source-code">initialize(**options)</p>
			<p class="source-code">tag_list=["product:cute-game1"]</p>
			<p class="source-code"># Create a new monitor</p>
			<p class="source-code">monitor_options = {</p>
			<p class="source-code">   "notify_no_data": True,</p>
			<p class="source-code">   "no_data_timeframe": 20</p>
			<p class="source-code">}</p>
			<p class="source-code">api.Monitor.create(</p>
			<p class="source-code">    type="metric alert",</p>
			<p class="source-code">    query="avg(last_5m):avg:mycompany.orders.hourly_count{*} &lt; 100",</p>
			<p class="source-code">    name="Hourly order count fell below 100",</p>
			<p class="source-code">    message="The order count dropped dramatically during the last hour. Check if everything is alright, including infrastructure",</p>
			<p class="source-code">    tags=tag_list,</p>
			<p class="source-code">    options=monitor_options</p>
			<p class="source-code">)</p>
			<p>The first part <a id="_idIndexMarker559"/>of this Python program is like the Python programs you have seen earlier. The main thing to look at in this program is the call to <strong class="source-inline">api.Monitor.create</strong>. This API takes several options that finely configure a monitor. For clarity, only the required parameters are used in this example.</p>
			<p>If the program is executed successfully, the new monitor will be listed on the <strong class="bold">Monitors</strong> dashboard in the Datadog UI.</p>
			<p>To generate data for triggering an alert, run the <strong class="source-inline">post-metric-and-event.py</strong> program with the sales count under <strong class="source-inline">100</strong> a few times. After waiting for 5 minutes, you will see that the newly created monitor turns red, indicating the critical status of the monitor, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="Images/Figure_9.8_B16483.jpg" alt="Figure 9.8 – The monitor &quot;Hourly order count fell below 100&quot; triggers an alert &#13;&#10;" width="1620" height="890"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.8 – The monitor "Hourly order count fell below 100" triggers an alert </p>
			<p>Creating monitors <a id="_idIndexMarker560"/>programmatically is usually needed as part of some provisioning process in which the newly provisioned resources m<a id="_idTextAnchor293"/>ust be monitored using related metrics data.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor294"/>Querying the events stream</h2>
			<p>As part of posting custom metric values to the Datadog backend, an event to the events stream was <a id="_idIndexMarker561"/>also posted from the script. We have verified that from the <strong class="bold">Events</strong> dashboard also. The following script demonstrates how the events stream can be queried for events that meet certain conditions. In the sample case, we will try to list the events that are tagged with <strong class="source-inline">fulfillment_type:download</strong> and not older than <strong class="source-inline">500</strong> seconds:</p>
			<p class="source-code"># query-events.py </p>
			<p class="source-code">import time</p>
			<p class="source-code">import json</p>
			<p class="source-code">from datadog import initialize, api</p>
			<p class="source-code">options = {</p>
			<p class="source-code">    "api_key": "cd5bc9603bc23a2d97beb118b75f7b11",</p>
			<p class="source-code">    "app_key": "21f769cbd8f78e158ad65b5879a36594c77eb076",</p>
			<p class="source-code">}</p>
			<p class="source-code">initialize(**options)</p>
			<p class="source-code">end_time = time.time()</p>
			<p class="source-code">start_time = end_time - 500</p>
			<p class="source-code">result = api.Event.query (</p>
			<p class="source-code">    start=start_time,</p>
			<p class="source-code">    end=end_time,</p>
			<p class="source-code">    priority="normal",</p>
			<p class="source-code">    tags=["fulfillment_type:download"],</p>
			<p class="source-code">    unaggregated=True</p>
			<p class="source-code">)</p>
			<p class="source-code">print (json.dumps(result, sort_keys=True, indent=4))</p>
			<p>The script <a id="_idIndexMarker562"/>is self-explanatory: <strong class="source-inline">start</strong> and <strong class="source-inline">end</strong>, two parameters of the API <strong class="source-inline">api.Event.query</strong>, set the timeframe for the events to be considered and further filtering is done using the tag <strong class="source-inline">fulfillment_type:download</strong>, which is one of the tags applied on the custom events posted earlier. Basically, this program will be able to locate the recent events published by the custom events.</p>
			<p>The last line <a id="_idIndexMarker563"/>of the program prints the<a id="_idTextAnchor295"/> result in a highly readable format as follows:</p>
			<p class="source-code">$ python query-events.py </p>
			<p class="source-code">{</p>
			<p class="source-code">    "events": [</p>
			<p class="source-code">        {</p>
			<p class="source-code">            "alert_type": "info", </p>
			<p class="source-code">            "comments": [], </p>
			<p class="source-code">            "date_happened": 1611721000, </p>
			<p class="source-code">            "device_name": null, </p>
			<p class="source-code">            "host": "thomass-mbp-2.lan", </p>
			<p class="source-code">            "id": 5829380167378283872, </p>
			<p class="source-code">            "is_aggregate": false, </p>
			<p class="source-code">            "priority": "normal", </p>
			<p class="source-code">            "resource": "/api/v1/events/5829380167378283872", </p>
			<p class="source-code">            "source": "My Apps", </p>
			<p class="source-code">            "tags": [</p>
			<p class="source-code">                "fulfillment_type:download", </p>
			<p class="source-code">                "product:cute-game2"</p>
			<p class="source-code">            ], </p>
			<p class="source-code">            "text": "Hourly sales count has been queried from order fulfillment system and posted to Datadog for tracking.\nHourly Count: 300", </p>
			<p class="source-code">            "title": "Posted hourly sales count", </p>
			<p class="source-code">            "url": "/event/event?id=5829380167378283872"</p>
			<p class="source-code">        }</p>
			<p class="source-code">    ]</p>
			<p class="source-code">}</p>
			<p>As you can see in the output, the JSON result contains all the attributes of the event that can be viewed on the <strong class="bold">Events</strong> dashboard and more. Typically, a program like this would be a part of another automation in which the events will be queried for tracking the status of the <a id="_idIndexMarker564"/>scheduled program that posts an hourly sales order estimate as a metric to the Datadog platform.</p>
			<p>Though the examples we looked at in this section are simple, they can easily be expanded into useful programs for implementing various integration and automation requirements.</p>
			<p>Next, let's look at the b<a id="_idTextAnchor296"/>est practices related to using the Datadog APIs.</p>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor297"/>Best practices</h1>
			<p>We reviewed the Datadog APIs and learned the basics of how they are called from curl and Python. Now, let's see what the best practices are for using the APIs for automating monitoring tasks:</p>
			<ul>
				<li>As mentioned earlier, try to leverage existing integrations as much as possible before writing your own code using Datadog APIs. This is mainly because the maintenance of custom code in the long term is expensive in general.</li>
				<li>If you must write code using APIs, start maintaining it in a source code control system from the very beginning.</li>
				<li>As we have seen with the sample programs, consider pulling useful monitoring information from other internal systems and publishing it on the Datadog platform as metrics and events using the APIs. Datadog is an excellent platform for aggregating information from disparate sources and it should be leveraged to extend the overall monitoring capability of the organization.</li>
				<li>APIs can be used to pull data out of Datadog for loading into popular reporting tools to meet custom reporting requirements. The same approach could be used to post infrastructure-related stat<a id="_idTextAnchor298"/>uses to <a id="_idTextAnchor299"/>other internal systems programmatically.</li>
			</ul>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor300"/>Summary</h1>
			<p>In this chapter, you mainly learned how to use curl and Python to interact with the Datadog platform using Datadog APIs. Also, we looked at major categories of APIs provided by Datadog. The important thing to remember here is that almost anything you can do on the Datadog UI can be performed programmatically using an appropriate API.</p>
			<p>We will continue looking at the Datadog integration options and in the next chapter, you will learn specifically about some important monitoring standards that are implemented by all major monitoring applications, including Datadog.</p>
		</div>
	</div></body></html>