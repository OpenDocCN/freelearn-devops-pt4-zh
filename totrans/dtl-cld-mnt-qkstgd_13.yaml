- en: '*Chapter 11*: Integrating with Datadog'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about some of the important monitoring
    standards and how they are implemented in Datadog, with the objective of extending
    the features of the Datadog monitoring platform. So far, in this part of the book,
    we have been looking only at extending the monitoring capabilities of an organization
    focused on Datadog. The integration with Datadog can happen both ways – in addition
    to populating Datadog with monitoring related data for use with various Datadog
    features, the information available in Datadog could be utilized by other internal
    applications also.
  prefs: []
  type: TYPE_NORMAL
- en: To roll out such general-purpose integrations between applications, a rich set
    of APIs should be available. We have already seen that the Datadog REST API is
    a comprehensive programming interface that other applications can use to access
    the Datadog platform to publish and extract information. We have also looked at
    DogStatsD as one of the methods to publish information to the Datadog platform,
    and we will learn more about how that interface can be used from other applications.
    We will also review other methods, which are mainly community-based efforts that
    are not officially shipped with the Datadog product suite but are very useful
    in rolling out custom integrations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the commonly used libraries for Datadog
    integration and cover these topics specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: Using client libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating community projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing integrations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement the examples given in this chapter, you need to have an environment
    with the following tools installed:'
  prefs: []
  type: TYPE_NORMAL
- en: The Datadog Agent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pip3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python 2.7** (optional)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Datadog developer toolkit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Git client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using client libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at two different client libraries – the first
    group consists of libraries that are wrappers for the Datadog REST API, and the
    second group of libraries are native **DogStatsD** client libraries. Both these
    groups of libraries are available for popular programming languages such as **C++**,
    **Java**, **Python**, **Java**, and **Go**.
  prefs: []
  type: TYPE_NORMAL
- en: Datadog provides both categories of libraries for most programming languages.
    While a lot of community libraries are listed on the official Datadog website,
    we will only look at those that are actively maintained.
  prefs: []
  type: TYPE_NORMAL
- en: REST API-based client libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basic Datadog client library is the REST API set, and the programming language-specific
    libraries are essentially wrappers on top of the REST APIs that facilitate the
    usage of APIs. In this section, we will look at some of the important client libraries
    specific to programming languages, and wherever relevant, we will look at sample
    code also.
  prefs: []
  type: TYPE_NORMAL
- en: The Datadog Python library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already seen this library in action earlier in the sample programs in
    [*Chapter 9*](B16483_09_Final_VK_ePub.xhtml#_idTextAnchor261)*, Using the Datadog
    API*. This official library supports both REST APIs and DogStatsD to interact
    with Datadog programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The library can be installed into your Python environment using the Python
    installation tool `pip` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is available on GitHub at [https://github.com/DataDog/datadogpy](https://github.com/DataDog/datadogpy)
    and the library can be installed from the source code as well. To do that, clone
    the code repository to your local environment and run the setup program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once installed, the REST API-specific calls can be done from the program by
    importing the `API` module, and the DogStatsD specific calls can be done by importing
    the `statsd` module into the Python environment.
  prefs: []
  type: TYPE_NORMAL
- en: The Python API client for Datadog
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is an official Python library that maps to a collection of all public
    Datadog REST APIs. On GitHub, it is available at [https://github.com/DataDog/datadog-api-client-python](https://github.com/DataDog/datadog-api-client-python).
    Using `pip`, this library can be installed in a compatible Python environment
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As of now, it is compatible only with **Python 3.6** and above.
  prefs: []
  type: TYPE_NORMAL
- en: The Java client for Datadog
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When it comes to developing enterprise applications, Java is one of the most
    popular programming languages. Therefore, if a Java application needs to be integrated
    directly with Datadog, this official Java client library, which is a wrapper for
    the core Datadog REST API, is the default choice.
  prefs: []
  type: TYPE_NORMAL
- en: The code repository related to this client library is available on GitHub at
    [https://github.com/DataDog/datadog-api-client-java](https://github.com/DataDog/datadog-api-client-java).
    Review the documentation available there to understand how this Java library can
    be built and installed in Java development environments using build tools such
    as **Maven** and **Gradle**.
  prefs: []
  type: TYPE_NORMAL
- en: The Go API client for Datadog
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go is a modern, compiled language that is fast but has the flexibility of an
    interpreted language such as Python. While it's a general-purpose programming
    language, it has been popular with systems programming and is used for building
    **Command-Line Interface** (**CLI**) tools in the DevOps space. For example, part
    of the latest version of the Datadog Agent itself is developed in Go.
  prefs: []
  type: TYPE_NORMAL
- en: The officially supported Go client library for the Datadog REST API is maintained
    on GitHub at [https://github.com/DataDog/datadog-api-client-go](https://github.com/DataDog/datadog-api-client-go).
    The details of building and installing the library are available at the same location.
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js client for Datadog
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Node.js platform is for running JavaScript on the server side, and it has
    been popular for developing web browser-based user interfaces. Datadog doesn't
    have an official client library to support this platform, and the `node-dogapi`
    code repository by *Brett Langdon* that is available on GitHub at [https://github.com/brettlangdon/node-dogapi](https://github.com/brettlangdon/node-dogapi)
    could be used instead. The code base has not been updated recently and its compatibility
    with the Datadog API has to be verified for the intended uses.
  prefs: []
  type: TYPE_NORMAL
- en: WebService-DataDog – a Perl client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before the widespread use of Python, **Perl** used to be the default scripting
    language for building systems tools, especially where the processing of logs and
    textual data was concerned. This Perl client library, maintained by Jennifer Pinkham,
    has not been updated recently, yet it's worth it for Perl enthusiasts to try out.
    The code repository is available on GitHub at [https://github.com/jpinkham/webservice-datadog](https://github.com/jpinkham/webservice-datadog),
    with steps on how to install the related Perl module.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby client for Datadog API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Ruby** is a scripting language mostly used for building web applications,
    especially with the development framework **Ruby on Rails**. However, it''s a
    general-purpose programming language like Python, PHP, and Perl. Datadog has an
    official client library for Ruby that is an abstraction on top of the Datadog
    REST API.'
  prefs: []
  type: TYPE_NORMAL
- en: The code repository is available at [https://github.com/DataDog/dogapi-rb](https://github.com/DataDog/dogapi-rb)
    with steps for installing the library and code samples for how to use the Datadog
    API in Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: DogStatsD client libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in [*Chapter 10*](B16483_10_Final_VK_ePub.xhtml#_idTextAnchor302),
    *Working with Monitoring Standards*, DogStatsD is an implementation of the monitoring
    standard StatsD. Therefore, a general-purpose implementation of StatsD would work
    with the DogStatsD interface provided by the Datadog Agent. The community-based
    libraries reviewed here take advantage of that feature and thus provide a wrapper
    for the targeted programming language.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ DataDog StatsD client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using this library, metrics and events can be published into the Datadog backend
    via the StatsD interface. The code base is available at [https://github.com/BoardiesITSolutions/cpp-datadogstatsd](https://github.com/BoardiesITSolutions/cpp-datadogstatsd)
    on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: The code can be built into a shared library for the target operating system,
    typically a Linux distribution. Some Windows platforms are also supported. The
    custom application that needs to publish metrics data and events can be dynamically
    linked to this shared library.
  prefs: []
  type: TYPE_NORMAL
- en: The Java DogStatsD client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For **Java**, Datadog provides an official DogStatsD client library and it's
    available at [https://github.com/DataDog/java-dogstatsd-client](https://github.com/DataDog/java-dogstatsd-client)
    on GitHub. It supports more features than a standard StatsD library that is limited
    to publishing metrics data. Using the Java DogStatsD client, you can also maintain
    events and service checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'A specific version of the client JAR file could be imported into your project
    using Maven, through a configuration setting as given in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The StatsD APIs can be called from the Java application and can be built once
    the preceding configuration is added to the Maven setting.
  prefs: []
  type: TYPE_NORMAL
- en: The DogStatsD client for C#
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**C#** is a general-purpose programming language like Java and **C++** and
    it is part of the **.NET** application development framework originally promoted
    by Microsoft. It is supported on Windows platforms and multiple distributions
    of Linux. This library is maintained by Datadog and its source code repository
    is available on GitHub at [https://github.com/DataDog/dogstatsd-csharp-client](https://github.com/DataDog/dogstatsd-csharp-client).'
  prefs: []
  type: TYPE_NORMAL
- en: This popular client library could be installed using the packages available
    at **NuGet** or using the source available on GitHub. As with the rest of the
    official DogStatsD client libraries, support is available for events and service
    checks in addition to the standard support for metrics. The details of installation
    and library usage are available with the code repository on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: datadog-go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**datadog-go** is a DogStatsD client library for the Go programming language
    and it is maintained by Datadog at [https://github.com/DataDog/datadog-go](https://github.com/DataDog/datadog-go)
    on GitHub. As with other official DogStatsD client libraries, this also supports
    events and service checks in addition to metrics.'
  prefs: []
  type: TYPE_NORMAL
- en: The library officially supports **Go** versions **1.12** and above. The details
    of the installation and usage of the library are available in the code repository
    on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: dogstatsd-ruby
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**dogstatsd-ruby** is a DogStatsD client library for the Ruby programming language
    and it''s maintained by Datadog at [https://github.com/DataDog/dogstatsd-ruby](https://github.com/DataDog/dogstatsd-ruby)
    on GitHub. As with other official DogStatsD client libraries, this also supports
    events and service checks in addition to metrics.'
  prefs: []
  type: TYPE_NORMAL
- en: The details of the installation and usage of the library are available with
    the code repository on GitHub. Full API documentation is available at [https://www.rubydoc.info/github/DataDog/dogstatsd-ruby/master/Datadog/Statsd](https://www.rubydoc.info/github/DataDog/dogstatsd-ruby/master/Datadog/Statsd).
  prefs: []
  type: TYPE_NORMAL
- en: Community DogStatsD client libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While there are DogStatsD client libraries available for popular programming
    languages that are maintained by Datadog, as with REST API-based client libraries,
    community efforts have been active to support other languages such as Node.js
    and Perl. In general, the community-based libraries are wrappers over the general-purpose
    StatsD libraries and they support only metrics. The following are some of the
    notable libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Host-shots client library for Node.js**: This is available at [https://github.com/brightcove/hot-shots](https://github.com/brightcove/hot-shots)
    on GitHub. It''s a general-purpose client library that supports other monitoring
    tools that provide a StatsD interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NodeDogStatsD**: This is another Node.js client library and the code repository
    and documentation are available at [https://github.com/mrbar42/node-dogstatsd](https://github.com/mrbar42/node-dogstatsd)
    on GitHub.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataDog DogStatsD – A Perl module for DogStatsd**: Using this module, metrics
    data can be published to Datadog from Perl programs. The code and documentation
    are available at [https://github.com/binary-com/dogstatsd-perl](https://github.com/binary-com/dogstatsd-perl)
    on GitHub.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a complete and up-to-date list of client libraries, check out the official
    compilation at [https://docs.datadoghq.com/developers/libraries/](https://docs.datadoghq.com/developers/libraries/).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have become familiar with two groups of client libraries
    that could be used with major programming languages to access Datadog resources.
    Those client libraries are useful in building Datadog-specific features from a
    program or a script from the ground up, as part of integrating with the Datadog
    SaaS backend. In the next section, we will look at some of the tools that provide
    either well-integrated features or building blocks to develop such integrations.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating community projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are tools developed by other companies and community groups that make
    your life easier with Datadog-related integration and automation. In this section,
    we will look at some of the useful tools and frameworks available in that category.
  prefs: []
  type: TYPE_NORMAL
- en: dog-watcher by Brightcove
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a large-scale environment with several dashboards and monitors built on Datadog
    for operational use, maintaining them could quickly become a major chore. This
    Node.js utility can be used to take backup of Datadog dashboards and monitors
    in JSON format and save it into a Git repository. Such backups are also very useful
    in recreating similar resources in the same account or elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: The utility needs to be run as a Node.js service. The code and the details of
    configuring it to run are available on GitHub at [https://github.com/brightcove/dog-watcher](https://github.com/brightcove/dog-watcher).
    It could be scheduled to take periodic backups or take backups as and when there
    would be changes to the Datadog resources being tracked for backing up.
  prefs: []
  type: TYPE_NORMAL
- en: kennel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**kennel** is a utility developed in Ruby that can be used to manage Datadog
    monitors, dashboards, and **Service Level Objects** (**SLOs**) as code. Managing
    all kinds of infrastructure resources as code is a DevOps tenet and this tool
    is useful in implementing that. The code and detailed documentation on the utility
    are available on GitHub at [https://github.com/grosser/kennel](https://github.com/grosser/kennel).'
  prefs: []
  type: TYPE_NORMAL
- en: Managing monitors using Terraform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Terraform** is a general-purpose tool to stand up and maintain **infrastructure
    as code** (**IaC**). It can be used to manage Datadog monitors by defining the
    monitors in a Terraform configuration language.'
  prefs: []
  type: TYPE_NORMAL
- en: Terraform maintains the state of a resource it manages by bringing the current
    status of the resource to match with its definition in the code. If the resource
    doesn't exist, it will be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'A variety of Datadog resources and integrations can be managed using Terraform,
    and some of the important ones are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dashboards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downtimes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrations with public cloud platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard Terraform documentation about these resources is available at [https://registry.terraform.io/providers/DataDog/datadog/latest/docs](https://registry.terraform.io/providers/DataDog/datadog/latest/docs).
  prefs: []
  type: TYPE_NORMAL
- en: Ansible modules and integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Ansible** is a configuration management tool that is very popular with DevOps
    engineers due to its general-purpose utility in addition to its core configuration
    management features. When it comes to managing infrastructure, it''s very similar
    to Terraform, with direct support for Datadog resources.'
  prefs: []
  type: TYPE_NORMAL
- en: In general, Ansible provides modules to support a certain type of infrastructure
    resource. Currently, there are Ansible modules available to publish events and
    manage monitors. Using these modules, Ansible playbooks can be built to manage
    events and monitors in a Datadog account.
  prefs: []
  type: TYPE_NORMAL
- en: Datadog ships an official integration for Ansible also. It can be used to track
    the execution of Ansible playbooks using a callback mechanism. However, this is
    not very useful in terms of the information published to the Datadog platform.
  prefs: []
  type: TYPE_NORMAL
- en: Datadog ships integrations for a lot of applications and public cloud platforms
    and services. It's possible to develop one if one is not available for a third-party
    tool of your choice or an internal application that needs to be monitored by Datadog.
    We will learn the basics of developing and deploying a custom integration in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Developing integrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 8*](B16483_08_Final_VK_ePub.xhtml#_idTextAnchor248), *Integrating
    with Platforms Components*, you learned how to configure an integration. Datadog
    ships official integrations with a lot of third-party applications that are used
    to build the cloud platform where a software application runs. The best thing
    about using an official integration is that the metrics specific to that integration
    will be available for use in dashboards, monitors, and other Datadog resources
    after minimal configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Datadog lets you build custom integrations that would work exactly like the
    official ones. It would require DevOps expertise, especially coding skills in
    Python, and it''s not easy to learn the procedure Datadog lays out to build an
    integration that would be compatible with the Datadog Agent. However, it might
    make sense to build an integration for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Building an integration for an internal application**: Even though it is
    internally used, the application might be deployed at large scale in production,
    and a Datadog integration would help to standardize the monitoring requirements
    of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Building an integration for a third-party application**: The monitoring requirement
    is similar to that of an internal application as described in the last use case,
    but no official or community-level integration is available yet or the requirements
    aren''t met.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Providing monitoring support for an application intended for external use**:
    You may have an application that is intended for an external audience as third-party
    software, and providing Datadog with an integration could be part of the monitoring
    support strategy for that application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, you will learn the steps to build an integration from scratch.
    Building a full-fledged integration is beyond the scope of this chapter, but you
    will learn the general steps to do so with some hands-on work.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some setup is needed in your local development environment for the integration
    to be developed, tested, built, packaged, and deployed:'
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.8 and above, and optionally Python 2.7 installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The developer toolkit. This can be installed using the `pip3` utility as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will install a lot of things in the local Python 3 environment and the
    output will look like the following if everything goes well:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Docker, to run unit and integration tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the integration is to be tested by deploying with a Datadog Agent, have the
    Agent installed. Note that an integration package can be deployed anywhere, and
    so the Datadog Agent doesn't have to run locally where the integration is developed
    and tested for compatibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The commands and output provided here are verified on a Unix-like system such
    as Linux or Mac. The development could be done on Windows as well; refer to the
    official documentation for platform-specific directions.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the tooling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `integrations-extras` code repository needs to be cloned from GitHub to
    the local environment to have all the scaffolding in place for developing and
    building the integration. Follow these steps to set that up:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory for the development work in your home directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Clone the `integrations-extras` repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set `integrations-extras` as the default repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we will set up a dedicated folder for the integration.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an integration folder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the new integration, the development kit can create the whole directory
    structure populated with template files. You can try a dry run to see the directory
    structure and files that would be created.
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of describing the steps better, let's assume that you have an
    application named *CityWeather* that supplies a bunch of weather-related information
    for a specific city at any time of day. The objective of the integration is to
    get some of that weather info to be published into Datadog.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dry run of creating the directory can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The output would show a hierarchical list of directories and files in the scaffolding;
    for brevity, it is not provided here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The directory structure can be created by running the same command without
    the `-n` option. Though the name used has mixed characters, the top-level directory
    name will be all lowercase. So, you can change directory into the newly created
    directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In that directory, you will find these files and directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`README.md`: The README file used for documenting the new integration in Git.
    The template provided has the correct headers and formatting for the documentation
    to be standard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`manifest.json`: The manifest describing the integration and file locations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tests`: The directory where unit and integration tests will be configured
    and maintained.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metadata.csv`: Maintains the list of all collected metrics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tox.ini`: Now, `tox` is used to run the tests. Make sure that the Python version
    specified in this configuration file used by `tox` matches the Python versions
    available locally. For example, if Python 2.7 and Python 3.9 are used, the content
    of this file would look like the following and you would make changes as needed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, with the tooling for developing an integration in place locally, let's
    try running the rest of the steps using an existing integration that is available
    in the repository. Note that there are about 100 extra integrations available
    in this repository and you could use them by building the corresponding related
    package, a trick that you will learn soon.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of testing and deployment practice, let's select an integration
    available for **Zabbix**. This is a popular on-premises monitoring tool and is
    widely used in both data centers and cloud platforms. Many companies that are
    migrating to using Datadog might have Zabbix installations to deal with, and a
    more practical strategy would be to integrate with Zabbix rather than trying to
    replace it, with a focus on rolling out Datadog for monitoring any new infrastructure.
    In such scenarios, you will see Datadog and Zabbix (or another on-premises monitoring
    application) running side by side.
  prefs: []
  type: TYPE_NORMAL
- en: Running tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the code developed for the integration, both unit and integration tests
    can be run locally with the help of Docker. In the case of Zabbix integration,
    Zabbix will be run locally as a microservice on Docker and the tests will be run
    against that instance. The Zabbix deployment details are provided in a `docker-compose.yml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to deploy Zabbix and test the integration:'
  prefs: []
  type: TYPE_NORMAL
- en: Change directory to the top level of the Git repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change directory to that of Zabbix integration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Look up the `docker-compose.yml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output is not provided here for brevity.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is verbose and it would end with messages similar to the following,
    indicating the success of the tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's see how to build a configuration file for the integration.
  prefs: []
  type: TYPE_NORMAL
- en: Building a configuration file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The example configuration file available with an integration, `conf.yaml.example`,
    is generated from the template file available at `assets/configuration/spec.yaml`.
    After making changes to the template file, the sample configuration file can be
    generated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's look at how the integration code can be packaged for installation.
  prefs: []
  type: TYPE_NORMAL
- en: Building a package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To deploy the integration, it needs to be packaged into a wheel, a format used
    for packing and distributing Python programs. The wheel will have only those files
    needed for the working of the integration, and it will not contain most of the
    source files used to build the integration. The integration can be built as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The wheel file can be found at the location mentioned in the build command
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's look at how the integration is installed using the package just
    built.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the Datadog Agent runs locally, you can install it by pointing to the wheel
    built in the last step. The wheel must be copied to other locations wherever it
    is planned to be installed. Once the wheel file is available locally, it can be
    installed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This will basically make the integration available to the Datadog Agent to
    be enabled as an official integration shipped with the Datadog Agent. Now if you
    check under the `conf.d` directory of the Datadog Agent home directory, you can
    see that `zabbix.d` is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As with any other standard integration, to enable it, `conf.yaml` needs to be
    created from the sample file provided and the Datadog Agent service needs to be
    restarted.
  prefs: []
  type: TYPE_NORMAL
- en: The complete procedure to build a Datadog integration is officially documented
    at [https://docs.datadoghq.com/developers/integrations/new_check_howto](https://docs.datadoghq.com/developers/integrations/new_check_howto).
    Refer to that documentation for finer details and updates. Now, let's look at
    the best practices related to the topics you have just looked at.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The availability of client libraries and the option to build custom integrations
    add a lot of flexibility to your toolbox for integrating Datadog with another
    application or even a batch job. However, there are certain best practices that
    you need to look at before starting to implement automation or customization using
    one or more of those options:'
  prefs: []
  type: TYPE_NORMAL
- en: If you can choose the programming language, pick a language that is better supported
    and popular, such as Python for scripting and Java for enterprise applications.
    If the application to be integrated runs primarily runs on Microsoft Windows platforms,
    choosing C# would be wise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose a client library that is officially maintained. It's a no-brainer – you
    need to rely on a library that will keep up with the enhancements made to the
    Datadog platform and REST API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plan to manage Datadog resources as code using Terraform. Ansible can help there
    too, but its support for Datadog is limited as of now.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you build an integration and if it has an external use, publish it to Datadog's
    **integrations-extras** repository on GitHub. Use by others can help to get valuable
    feedback and fixes to make it more robust and useful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following these best practices and related patterns will help you choose the
    right approach for implementing your integration requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you should be aware of all the important integration options available
    in Datadog for a variety of use cases; let's recap what we covered in this chapter
    specifically.
  prefs: []
  type: TYPE_NORMAL
- en: Many Datadog client libraries targeting popular programming languages are available,
    both officially maintained and at the community level. There are two types of
    client libraries – ones that provide a language wrapper to the Datadog REST API
    and libraries that provide support interfacing with Datadog via the StatsD-compatible
    DogStasD service. Also, there are community-level efforts to integrate with Datadog
    that are available on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: There are other types of Datadog client libraries that are not discussed here,
    such as **APM** and **distributed tracing libraries**, libraries that support
    serverless computing resources such as **AWS Lambda**, and client libraries that
    specifically target the log management feature of Datadog. The usage of these
    libraries is not different from how the core API and DogStatsD libraries are used,
    and you should check those out if you have any related use cases.
  prefs: []
  type: TYPE_NORMAL
- en: With this chapter, *Part 3* of this book, *Extending Datadog*, has been completed.
    In the next part of the book, you will learn more advanced monitoring concepts
    and features that are implemented by Datadog. We looked at monitoring microservices
    briefly earlier, and, in the next chapter, you will learn more about monitoring
    microservices, especially how this is done in an environment orchestrated by Kubernetes.
  prefs: []
  type: TYPE_NORMAL
