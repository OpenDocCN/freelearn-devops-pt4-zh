- en: '*Chapter 2*: Managing DevOps from Architecture'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about the different DevOps components, which
    comprise automation, collaboration, integration, and configuration management
    components. In this chapter, we will learn in more detail how to design these
    components and how to manage the **DevOps cycle** from these components. We will
    learn that automation and integration start with standardizing building blocks,
    called **artifacts**. These artifacts are linked with a portfolio that is defined
    by the **enterprise architecture**. Before we get to launch **DevOps projects**
    using automation and integration, we need to understand the business strategy
    and demand for architecture.
  prefs: []
  type: TYPE_NORMAL
- en: After completing this chapter, you will be able to identify the different components
    of demand management and how this drives portfolio management. You will also learn
    what the various stages are in **continuous integration** (**CI**) and how automation
    can help enterprises in speeding up deployment processes. In the last section,
    you will see that collaboration in these processes is crucial, and we will look
    at how you can enable teams in working together, introducing (as an example) **Kanban**
    and other frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Assessing demand as input for the architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing and managing automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing and managing configuration management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing and managing integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing and managing collaboration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assessing demand as input for the architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can't just start with a DevOps project—a business will need to know what
    they want to achieve before they launch projects. For that matter, there's no
    difference between a traditional Waterfall project and DevOps in an *Agile* way
    of working—you need to know where you're going. That's a very simple explanation
    of something that is called **demand management**. In this section, we will learn
    about demand as input for an architecture and how this leads to projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Demand management can be defined as a process wherein an enterprise collects
    and prioritizes ideas to improve business outcomes. To be able to do that, the
    enterprise needs to assess the demands from the *outside*, meaning the market—in
    other words: *What do customers want?* But it also needs to assess whether the
    current portfolio is still up to date and that ongoing projects will still deliver
    the desired outcome. **Portfolio management** is a constant evaluation of market
    demands and ongoing activities. The modern challenge is that this evaluation has
    to be done at a higher speed than, let''s say, a decade ago. Demands are changing
    fast and that does impact portfolio management drastically.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Portfolio management includes at least the following components and processes
    (Romano, L., Grimaldi, R., & Colasuonno, F. S. (2016). *Demand management as a
    critical success factor in portfolio management*. Paper presented at PMI® Global
    Congress 2016—EMEA, Barcelona, Spain. Newtown Square, PA: Project Management Institute):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition of **enterprise vision** and **strategy**: This is part of the enterprise
    architecture and defines the strategy for the enterprise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Demand management**: The processes to collect ideas and identify opportunities
    for future products and services that are in the portfolio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ongoing components**: Validation of whether existing products and services
    are still relevant for the enterprise and its customers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Components assessment**: This concerns the business case. What will be the
    investment in developing new products and services or changing existing components,
    and what is the expected revenue after the release or change?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Budgeting**: The calculation of the required amount of resources needed to
    start development or realize upgrades of existing components in the portfolio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prioritization and selection**: Development and changes need to be prioritized
    against the strategy of the enterprise. What is a must-do and what is a nice-to-have,
    and in what timeframe?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portfolio governance and communication**: This relates to who''s responsible
    for what in demand and portfolio management. A recommended approach is to have
    a **Responsible, Accountable, Consulted, and Informed** (**RACI**) matrix for
    portfolio management: Who''s responsible for which component? Who is accountable?
    Who should be consulted? Who should be informed?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portfolio implementation**: Adding the new or changed components to the portfolio
    in a structured acceptance process. Are the components documented in an appropriate
    way? Are the components signed off by the responsible owner? Have all acceptance
    criteria been met?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portfolio reporting and review**: The reports should reflect whether the
    portfolio is aligned with the business strategy. Is the portfolio still relevant
    to the strategy and the desired business outcomes? Or, does the enterprise need
    to change components, or maybe even consider adapting the whole portfolio (for
    instance, by divesting parts of the portfolio)?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Benefits realization**: What has been the real value of the portfolio and
    the benefits to the enterprise and its business?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The portfolio drives the projects in an enterprise, and also DevOps. The key
    to DevOps is automation so that projects can keep up with the speed of business
    changes and demands to **Information Technology** (**IT**). Crucial in automation
    is the creation of standardized building blocks. From the portfolio, we need to
    define these building blocks, called artifacts. **Configuration management** is
    about managing these artifacts so that they fit to the portfolio. To manage this,
    we need version control. We will discuss this in the *Implementing and managing
    configuration management* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have the cycle of creating a portfolio to manage configuration items
    and enable automation. This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – The configuration management cycle'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_02_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – The configuration management cycle
  prefs: []
  type: TYPE_NORMAL
- en: The **code repository** holds the standard building blocks that are under version
    control. This is a requirement for enabling automation. In the next section, we
    will learn more about automation.
  prefs: []
  type: TYPE_NORMAL
- en: Designing and managing automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss **automation** for DevOps. For starters, automation
    is not only about tools, although we will discuss tools at the end of this section.
    The first questions that architects will need to answer regard *what* they need
    to automate and *why*. It's not about the tools but about the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to answer the following question: *Why would we need automation?*
    The answer to that question is because of *standardization*. The reason for businesses
    to adapt DevOps is because they want to speed up delivery processes. The only
    way to do that is by standardization of building blocks, workflows, processes,
    and technologies. By implementing and adhering consistently to standards, companies
    will limit varieties in the delivery chain and can then start automating it. The
    big trick in automation is cutting down the waiting time.'
  prefs: []
  type: TYPE_NORMAL
- en: Before companies turned to DevOps, IT delivery was driven by waiting time. Developers
    had to wait for a server. In a worst-case scenario, the server needed to be ordered
    first, then installed and configured before it could be released to the development
    team. Then, developers could do their work and deliver the software to testers,
    but then had to wait for the testers to come back with results. Finally, the product
    was ready for release, but now the team would have to wait for the final *go*/*no-go*
    decision.
  prefs: []
  type: TYPE_NORMAL
- en: 'In DevOps and automated **CI/CD pipelines** (where **CD** is an acronym for
    **Continuous Delivery**), the waiting time is strongly reduced by standardization,
    if done well. Architects will have to keep in mind that a pipeline consists of
    two major components: *software* and *infrastructure*, even though infrastructure
    has become code too. Typically, we will work in a cloud where we''re not deploying
    physical servers, but **Infrastructure as Code** (**IaC**).'
  prefs: []
  type: TYPE_NORMAL
- en: Everything has become code. Automation of infrastructure, configuration, and
    deployment of software is the core of DevOps. Only by using automation can a company
    speed up delivery to periods of weeks, days, or even hours.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the automation process for the CI/CD pipeline.
    There are two major components in this pipeline: the **deployment pipeline** and
    the **infrastructure pipeline**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Deployment pipeline and infrastructure pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_02_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – Deployment pipeline and infrastructure pipeline
  prefs: []
  type: TYPE_NORMAL
- en: The software is developed, tested, and deployed in the deployment pipeline.
    That software needs to land on infrastructure—for example, on a **virtual machine**
    (**VM**) in a public cloud such as **Amazon Web Services** (**AWS**) or Azure.
    At a certain point, we will have to merge the software code with the infrastructure
    and configuration packages for that infrastructure. That whole package is tested,
    validated, and eventually pushed to the production stage.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2.2* shows how important testing is. There are a couple of touchpoints
    that include testing procedures. In the *Designing and managing integration* section,
    we will explain more about the various tests in CI, such as static and dynamic
    analysis. [*Chapter 3*](B17492_03_ePub_RK.xhtml#_idTextAnchor040), *Architecting
    for DevOps Quality* also has a section about executing tests.'
  prefs: []
  type: TYPE_NORMAL
- en: So, the deployment pipeline is used to convert code to a deployable application
    package, deploying the package, validating the package, and releasing the package
    to production.
  prefs: []
  type: TYPE_NORMAL
- en: In the infrastructure pipeline, we provision the environments on which the application
    package can be deployed. In *Figure 2.2*, VMs are mentioned as an example, but
    infrastructure can also consist of **containers** or **serverless components**.
    In fact, native applications will use containers and serverless environments over
    VMs.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding pipeline components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a better look at the diagram shown in *Figure 2.2* and comment on
    the different components. The pipeline starts with **version control** and **configuration
    items**. In the next section, *Implementing and managing configuration management*,
    we will discuss this in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The actual deployment starts with the package containing all the files that
    we need to run the application. This package can be deployed to an environment.
    *To any environment?* Well, that's the reason to abstract the deployment pipeline
    from the infrastructure. Ideally, we would like to be able to run code on different
    platforms, so we need to code in such a way that it can run on infrastructure
    in—for instance—AWS, Azure, or on a private stack, or even using different operating
    systems such as Windows or Linux distributions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have the package, we can start deployment: this is an automated series
    of tasks to deploy our application on a test or staging environment. Here, we
    can run automated simple tests—often referred to as smoke tests—to verify that
    the code is actually running. This simple test will not be sufficient to validate
    all the required functions and to detect bugs: this is done in the test phase.
    We will learn more about testing in the *Designing and managing integration* section.'
  prefs: []
  type: TYPE_NORMAL
- en: If all tests have been successfully executed, we have a validated application
    package that is ready to be pushed to the production stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following aspects need to be considered in terms of automation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code development**: Automation in DevOps starts as soon as developers begin
    developing the code. The code needs to be "automation ready," meaning that from
    the moment the code is checked in, the actual build is triggered and runs through
    automated tests and code validation. Next, the code is compiled and brought under
    version control. Ultimately, when all tests have been executed and the full package
    is validated, it will be pushed to production. Developers need to take this automation
    sequence into account when they develop the code. After the code is deployed into
    production, it needs to be monitored. So, as soon as the package is "prepared"
    for go-live, scripts will be merged to the package to enable it to be monitored,
    and for logs to be collected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous testing**: In DevOps cycles, software will constantly be evaluated
    and improved. That''s what DevOps is about, after all: increasing agility and
    CD. Code will therefore be changed regularly. Every time code is changed, it needs
    to be tested and validated. That''s where continuous testing comes in. Automated
    testing is used to track and predict issues in code changes, run multiple tests,
    and ultimately release approved automated builds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring**: It''s a misunderstanding that monitoring is only needed when
    applications are pushed to production. Monitoring is relevant during the whole
    CI/CD life cycle and is a crucial component in automation. Monitoring is required
    to track events, identify causes for why code is malfunctioning, prioritize events,
    and proactively suggest actionable improvements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, by applying automation, we can bring release timelines down from months
    or weeks to just a few days, or even hours. This is only possible if we automate
    as much as we can. But automation does more than just speed up delivery; it also
    reduces the risk of manual errors and will enable companies to achieve more consistency
    and higher reliability for the products they release. DevOps is not only about
    agility and speed but maybe even more about quality, by creating products with
    more accuracy in a repeatable process that can be delivered at a high pace.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the DevOps automation toolset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, so far, we haven't talked about **tooling**. The selection of the right
    tools is indeed very important. The challenge, however, is that there are so many
    tools available on the market. One of the tasks of an architect would be to guide
    the selection. The first decision that an architect will have to make is whether
    they want the automation to be "single-stack" or whether to opt for multiple tools
    for different automation areas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just look at the **periodic table** of **DevOps tools** (by *Digital.ai*) in
    the following screenshot. For each of the DevOps domains, there''s a huge choice
    of toolsets. There are tools for managing the code, creating packages, automating
    the merging of pipelines, testing code, bug fixing, provisioning of infrastructure,
    managing infrastructure, and monitoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – The idea of having a periodic table of DevOps tools'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_02_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – The idea of having a periodic table of DevOps tools
  prefs: []
  type: TYPE_NORMAL
- en: Organizations will need tools to manage the DevOps process from end to end.
    There are tools that promise this end-to-end capability, but a set of tools is
    typically required, from the code build and commit to testing, deployment, and
    operations. One important thing to keep in mind is the level of integration between
    the tools. This depends not only on the source code that developers use, but also
    on the target platform. If the target platform is Azure, it makes perfect sense
    to use **Azure DevOps** and **Azure Resource Manager** (**ARM**) to deploy infrastructure
    on that platform. If the main platform is AWS, then tools such as Chef and Puppet,
    in combination with **AWS CodeDeploy**, are probably a better choice.
  prefs: []
  type: TYPE_NORMAL
- en: Then again, there's a major shift going on from using VMs to containers and
    serverless technology. A lot of DevOps projects use containers to deploy code,
    by using Docker and Kubernetes as the container *orchestration platform*. Containers
    are much more agnostic to the underlying infrastructure or cloud platforms than
    VMs, but also here, platforms all have their own Kubernetes engines. Think of
    **Azure Kubernetes Services** (**AKS**) on Azure and **Elastic Kubernetes Services**
    (**EKS**) on AWS.
  prefs: []
  type: TYPE_NORMAL
- en: 'One more important thing to consider is the type of tool that will be chosen.
    Open source tooling is very popular, but it''s good to consider whether these
    tools meet the enterprise requirements. That differs per domain. Azure DevOps
    Pipelines and AWS CodePipeline are perceived as enterprise tools, but tools for
    version control (Git, GitHub, GitLab, **Subversion** (**SVN**), Cloud Foundry)
    are mainly open source. There can be good reasons for an enterprise to go for
    open source, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Community driven**: Large communities constantly improving the software.
    Enterprises can benefit from this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cost-effective**: There are typically licenses required for open source software,
    but looking at the total costs, open source is often a very good deal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No risk of lock-in**: This is becoming more and more important for organizations.
    They don''t want to be completely locked into the solutions of one software provider
    or the ecosystem of that provider. Open source allows an organization a great
    amount of freedom.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The negative side of open source that is often cited is that this software would
    be less secure and less stable than enterprise software. However, because the
    software is constantly reviewed and improved by a community, we find that open
    source software is just as secure and stable as non-open source software.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing and managing configuration management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned that automation starts with version control
    and configuration items that form an application package in an artifact's repository.
    In this section, we will study how we can manage these artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Automation can only be done when **building blocks** (artifacts) and processes
    are standardized. **Standardization** requires three components, outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Portfolio** and **portfolio management**: A portfolio is the translation
    of the business strategy and the products that a business delivers to its customers.
    Those products consist of several artifacts: product components and processes.
    So, a portfolio is at the strategic level of an enterprise, whereas products and
    artifacts sit at a tactical level. A portfolio is defined by the enterprise architecture,
    products, and artifacts that are managed at a business-unit and project level.
    In short, products can''t exist without a definition in the portfolio, but a portfolio
    is not something that we can automate in projects and pipelines. We can automate
    artifacts and even products, as long they are standardized and managed through
    version control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version control**: In the first section of this chapter, we learned that
    artifacts are derived from a portfolio. Artifacts need to be put under version
    control. A centralized version control repository is absolutely the number-one
    priority in CI/CD. This repository is a **single source of truth** (**SSOT**)
    for all configuration items that will be used for the development and building
    of the deployment packages. Creating packages with configuration items is done
    using the file versions in the **version control system** (**VCS**). Version control
    is mandatory to keep all configuration items consistent. A build produces a versioned
    package that can be retrieved from the repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration items**: The term *configuration item* comes from the **IT
    Infrastructure Library** (**ITIL**), which is an IT library for IT service management.
    Configuration items are assets that need to be managed in order to deliver an
    IT service—basically, everything that is needed to execute a build and deliver
    an IT service. It includes building blocks for the application code, but also
    images for the operating systems, configurations for network settings, security
    packages, licenses, database settings, and test scripts. All these items need
    to be managed. Configuration items are defined by a **unique identifier** (**UUID**),
    the type of an item (hardware, software, script, license, and so on), a clear
    description, and the relationship that the item has with other items. To keep
    configuration items consistent, they need to be verified and validated at regular
    intervals or even in "real time." A best practice is to automate this, as we have
    already seen in the previous section. Agents will constantly monitor all assets
    in an environment and update the status of configuration items in the repository,
    commonly referred to as the **Configuration Management Database** (**CMDB**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How is this linked to the enterprise architecture and the portfolio? Let's take
    security as an example. From the enterprise strategy, the security standards must
    be defined—for instance—to which industry framework the enterprise should be compliant
    with. That is translated into security policies that need to be set in the security
    packages. These packages containing security policies and rules are known as configuration
    items. In the third part of this book, about **DevSecOps**, we will learn more
    about this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make this a little bit more tangible. We have an application that runs
    on a VM and is attached to a database. The different configuration items could
    then be listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Application code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VM template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating system image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security settings for the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security settings for the VM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Licenses for the operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Licenses for database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network settings (**Internet Protocol** (**IP**) address allocation; network
    ports; routing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list is by no means exhaustive—these are just examples. All these items
    need to be managed to keep them consistent. The CMDB enables verification and
    validation of all items. By applying version control, we make sure that new builds
    only use verified configuration items—for example, a certain version of an operating
    system or a specific version of the application code.
  prefs: []
  type: TYPE_NORMAL
- en: A key takeaway here is that every configuration item is linked to the business
    strategy, portfolio, and enterprise architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've learned what configuration items are and how we manage
    these items from a single repository (CMDB) so that they remain consistent. In
    the next section, we will see why version control and consistency are so important.
  prefs: []
  type: TYPE_NORMAL
- en: Designing and managing integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn more about **CI**. First, we will look at the
    development and deployment of **application code**. Next, we will learn about
    the integration of **code pipelines** for applications and the infrastructure.
    Somewhere, the application code and the IaC have to merge together with specific
    configuration packages. Only then will we have a fully integrated model.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a definition of integration first. This refers to an automated
    series of tasks to version, compile, package, and publish an application. This
    includes testing, whereby **unit tests** are used to validate that existing code
    performs well without interruptions. **Integration tests** run to ensure no integration
    issues occur. Additional checks, such as **static code analysis**, can be included
    as well to increase quality and feedback.
  prefs: []
  type: TYPE_NORMAL
- en: The CI/CD pipeline—and with that, the automation—starts with a merge of **source
    code**. This code is transformed to a build, as a product of an executable package
    that integrates with other executable packages. Code is pulled from the repository,
    analyzed, and committed to a build server, where a series of automated tasks will
    be executed to push to code into production, including the merge with the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: As stated, testing and validation of the code is a crucial part of the build.
    Code is tested to verify that all risks are identified and mitigated so that the
    build meets enterprise compliance, defined in the enterprise architecture and,
    subsequently, the security policies. The next step is that the code is deployed
    to a development or test environment. As we have seen, this is preferably done
    in an automated way. The code is brought under version control and committed back
    to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Although it requires a lot of manual tasks, it's important to maintain a wiki—a
    collection of documents that are maintained by the developers—as part of the version
    control, containing the release notes with the build number, and issues that have
    been encountered and mitigated after the tests. The outcomes of the tests should
    be listed in the release notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, the CI process consists of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Detecting new committed code**: The source code in the application repository
    is forked, which means that the code is committed to the automated pipeline. This
    starts a sequence of build tasks. The next step is to validate the code. This
    is the **pull process**, whereby the code is checked out and placed on a **build
    environment**—in most cases, a **development server**. Static analysis is executed,
    which is a test without actually running the code. This step is also referred
    to as **linting**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Source code quality analysis**: The code is looked at to check it meets security
    and compliance requirements.. Part of this quality analysis is also a scan of
    the software used: is it licensed and is it compliant with the enterprise standards
    and software portfolio?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Build**: This is the step where code is compiled and packages are assembled.
    The actual build begins with pulling the executable packages from the artifact''s
    repository. This repository holds all the standards and policies that an enterprise
    uses to deploy code. The source code is merged with these packages. As an example,
    these packages contain the images for the operating systems, but also the security
    policies, such as hardening templates to protect systems from attacks. Packages
    for infrastructure are often stored in a repository that holds the images: the
    trusted image registry. These images are used to assemble an executable package
    to final deployment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Unit tests**: Unit tests ensure that the executable package runs without
    issues.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Integration tests**: In the code validation, we executed a **static analysis**;
    now, a dynamic analysis is performed. The assembled package is tested to verify
    that it runs without errors, and test reports are generated.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Creating a runtime executable file**: We''re getting close to the final steps,
    which is the release of the code to the next phase. Before we can do that, runtime
    executables are generated so that the code can be started in a specific runtime
    order or routine. These runtime executables are often stored in a separate runtime
    library.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Build notification**: The last step before deployment is notification that
    the build is ready, meaning the code and the executable packages have passed all
    tests. The package is ready for deployment. If the integration is stopped at any
    time during the automation sequence, developers will be notified so that they
    can fix any issues and then recommit the code. Every step, as described, is then
    repeated.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The integration process is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – The CI process'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_02_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – The CI process
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2.4* shows that the output of the CI path is directed toward something
    called a **promotion path**. Applications are seldom pushed directly to production
    environments. The application release is usually "staged" in a few steps before
    it actually lands on production. The next section explains this promotion path.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the promotion path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although eventually code will be pushed to production, it's good practice to
    run the deployment to a development , staging, or pre-production environment.
    This is called a promotion path, which involves **development**, **test**, **acceptance**
    and **production** (**DATP**). In some cases, an acceptance environment is part
    of the promotion path. Acceptance environments sit between the test and production
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – A promotion path for IT systems'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_02_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – A promotion path for IT systems
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance environments are strongly recommended for business-critical applications.
    In fact, enterprises use acceptance environments often as the **disaster recovery**
    (**DR**) system when production fails. Production is then switched to acceptance,
    with a minimal loss of data. Acceptance environments should be identical to production
    systems in terms of configuration.
  prefs: []
  type: TYPE_NORMAL
- en: A promotion path containing DTAP is recommended as a minimal setup. The executable
    package is the outcome of the integration pipeline and is now pushed to development,
    pre-production, and testing or staging. Here, the packages are tested to verify
    that they will run without issues in production. The application needs to be robust,
    stable, secured, and compliant at a minimum. Also, cloud-native features such
    as scalability—and maybe even self-healing—are tested, with load and performance
    tests. Ultimately, the final product will go live against the specifications that
    were originally collected from the business. We are then back at the beginning
    of the cycle, which started with demand management.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why would we run such an intensive process to release code? Because there are
    several benefits a business could gain from this. The five main benefits are listed
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: Code changes are more controlled and can be smaller since this is a continuous
    process where improvements can be made in small iterations of that code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of automation, code release can be done much faster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of automation, the costs for development will be significantly lower—this
    will be reflected in the overall costs to the enterprise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated tests will lead to more reliable tests and test results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Management and updates are easy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this section, we learned about CI: what the requirements are, how we initiate
    integration from automated pipelines, and why enterprises should implement CI
    in projects. There''s one more thing we need to discuss as part of the full DevOps
    setup, and that is collaboration. DevOps is not only about technology and tools;
    it''s a *mindset*. We will discuss collaboration in the last section of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Designing and managing collaboration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To put it very simply, DevOps only succeeds if teams work together. Teams can
    collaborate if they use the same processes and, indeed, the same toolsets. In
    DevOps, **collaboration** ties processes and technology together to enable teams
    to join forces.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B17492_01_ePub_RK.xhtml#_idTextAnchor013), *Defining the Reference
    Architecture for Enterprise DevOps*, we saw that a lot of enterprises have outsourced
    major parts of their IT. This makes collaboration hard, every now and then. DevOps
    requires that teams carrying out operations and that are part of a certain sourcing
    partner or vendor work together with developers that come from a different company.
    It's up to the enterprise to set the scene, engagement rules, and co-working principles.
    The ownership of that can only be at an enterprise level.
  prefs: []
  type: TYPE_NORMAL
- en: In enterprises, it's very rare that only one team is completely responsible
    for an application. Often, there are more teams involved, and—even—more than one
    supplier. DevOps, however, assumes that there's one DevOps team responsible end
    to end. The main goal of this is to reduce overhead and manage waiting time in
    handovers between teams. This requires constant communication between team members
    since these members will have different skills and tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Don't be fooled by the **T-shaped** dogma. Yes—a cloud engineer will probably
    know how to attach storage to a VM, and maybe they also know how to build network
    configurations in Azure or AWS, yet configuring databases or a firewall are specific
    tasks that typically require a database or a network engineer. A DevOps team will
    have to onboard these **subject-matter experts** (**SMEs**), but they work together
    in one team and not in separate silos.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing is that an enterprise needs to enable collaboration. This is
    the task of a project leader or, in an agile way of working, a *Scrum* master.
    One of their key tasks is to "remove barriers" and help team members to achieve
    a common goal. Setting the objectives and priorities for the team are step one.
  prefs: []
  type: TYPE_NORMAL
- en: How do we define the objectives and the priorities? This is the task of an architect.
    Their responsibility is to lay out a clear roadmap, pointing out how to reach
    each objective, and in what order. That roadmap is derived from the end-state
    architecture, also referred to as "**soll**", or **target architecture**. This
    architecture defines how the environment should eventually look, containing the
    application architecture, the required infrastructure components, and the **application
    programming interfaces** (**APIs**).
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a roadmap is shown in the following diagram. The example has
    been taken from *ProductPlan* and shows perfectly how a simple roadmap helps create
    visibility and clarity in tasks that have been foreseen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Example of an architecture roadmap by ProductPlan'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_02_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – Example of an architecture roadmap by ProductPlan
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the roadmap shows the roles and responsibilities of team members:
    who needs to do what, and how much time will it consume? A good way to create
    clear overviews of roadmaps, timelines, and tasks is to use **Kanban boards**.
    Kanban, originally a Japanese invention that was first introduced at Toyota, shows
    when certain components are needed in the production process. Both Scrum and Kanban
    are tools to implement Agile as a development method for applications.'
  prefs: []
  type: TYPE_NORMAL
- en: To a lot of enterprises, this still sounds very new, but the truth is that they
    probably have been working with a similar planning methodology for years, since
    that's what Kanban does in essence. It helps teams to plan complex projects in
    achievable chunks and, with that, improve the quality of the end product.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, *Architecting for DevOps Quality*, we will learn more about
    implementing quality measures.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter started with an overview of demand management as input for an architecture.
    We learned that assessing business demand is the key driver for portfolios. In
    turn, a portfolio defines the artifacts and building blocks that we use to develop
    products, services, and, as such, applications. Since demand is changing fast,
    enterprises will need to speed up deployment processes. This can be achieved by
    automating as much as possible. Automation is done through pipelines, and in this
    chapter, we've learned what the different components are in architecting both
    application deployment and infrastructure pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section, we discussed collaboration that is crucial in CI/CD, using
    DevOps. Teams will be formed by engineers with different skill sets, and they
    even may be hired from different companies, something we see frequently at large
    enterprises that have outsourced their IT. Therefore, enterprises will need to
    encourage strong collaboration, based on a clear roadmap with clear objectives
    and planning that states exactly who is responsible for which task. For this,
    Kanban boards are a good approach.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive deeper into the quality measures of DevOps
    projects and learn about **Definition of Ready** (**DoR**) and **Definition of
    Done** (**DoD**), as well as looking at how to execute tests for quality assurance.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Demand management is a process of collecting ideas and identifying opportunities
    for future products and services that are in a portfolio. Rate the following statement
    true or false: the business case is not relevant for demand management.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One of the first tests is a test without actually running the code. What do
    we call this test?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The promotion path contains various stages. What are these stages, and in what
    order are they set?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Demand management as a critical success factor in portfolio management*. Paper
    presented at PMI® Global Congress 2016 by Romano, L., Grimaldi, R., & Colasuonno,
    F. S. (2016):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: https://www.pmi.org/learning/library/demand-management-success-factor-[portfolio-10189](http://portfolio-10189)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Kanban and Scrum – Making the Most of Both*, Henrik Kniberg and Mattias Skarin:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.infoq.com/minibooks/kanban-scrum-minibook/](https://www.infoq.com/minibooks/kanban-scrum-minibook/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
