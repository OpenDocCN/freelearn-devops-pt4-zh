- en: '*Chapter 3*: Architecting for DevOps Quality'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The overall aim of **DevOps** is to deliver high performance and quality to
    IT projects. In this chapter, you will learn how DevOps can add value to the quality
    of **IT delivery**. In this chapter, we will learn how to define test strategies,
    proving that quality has been delivered according to the **Definition of Done**
    (**DOD**). But what happens if something breaks? The golden rule in DevOps is
    you build it, run it, break it, and then you fix it. But then, we must detect
    what the issue is by executing a **root cause analysis** (**RCA**). In the final
    section, we will discuss **remediation** and, with that, **continuous improvement**.
  prefs: []
  type: TYPE_NORMAL
- en: After completing this chapter, you will be able to identify and implement quality
    measures in DevOps projects. You will have learned what tests can be included,
    how the are organized, and what the value of these tests is, thus continuously
    improving the product or service.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining test strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing quality measures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing test automation and execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding root cause analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing for remediation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining test strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we concluded that testing is a crucial step in the
    CI/CD process to ensure the quality of the build. In this section, we will learn
    how to define test strategies in DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, DevOps requires a different approach to testing: it''s part of the continuous
    deployment and integration of *builds*. The reason we should adopt DevOps is because
    enterprises want to speed up releases so that they can act much quicker to changing
    demands. For testing, this means that there is a shift from testing the end product
    to continuous testing, with a focus on reducing build and test times.'
  prefs: []
  type: TYPE_NORMAL
- en: In other words, testing is no longer just a matter of detecting the faults in
    the end product; it has become part of the full life cycle of the build, collecting
    feedback during this whole cycle.
  prefs: []
  type: TYPE_NORMAL
- en: '**Testers** should be members of the DevOps team. Their responsibility is to
    constantly collect feedback, measure the cycle time, and find ways to reduce these
    times. Testers should be invited to monitor code during the whole build process
    so that they can look at errors and bugs as soon as they appear. This will give
    the team opportunities to fix issues before code is released to the next stage.
    The big benefit of this approach is that the end product will already have fewer
    issues and the total cycle time will be decreased during every iteration.'
  prefs: []
  type: TYPE_NORMAL
- en: Overall, we can say that the role of quality assurance is changing in DevOps.
    In traditional IT projects, quality assurance was done as soon as the product
    – for instance, an application – was delivered at the final stage. Testers would
    execute functional testing and involve a group of users to perform **user acceptance
    tests** (**UAT**). This was done for a given period, usually a week or two. Then,
    the results were handed back to the developers that would go over the findings
    and fix the issues. Then, the whole thing was submitted to testers again so that
    they could retest and validate whether all the findings had been addressed. In
    DevOps, we don't work that way anymore. Firstly, this is because it takes too
    much time, and secondly, there's hardly any interaction between the testers and
    the developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'What are the requirements for a test strategy in DevOps that ensures quality
    through the whole development cycle? They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create user story awareness**: First, there needs to be a clear **user story**.
    The user story will drive the test scenarios. This means that the team scopes
    the testing topics. **TMAP**, the most used testing framework, divides the topics
    into two categories: *organizing* and *performing*. Organizing topics cover the
    way tests are planned, prepared, and managed. Performing topics concern the tests
    themselves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Create the strategy**: In DevOps, the **strategy** should be that tests are
    executed throughout the whole build, which means that testers need to run automated
    test scripts on iterations of the build. In other words, code is constantly tested
    to verify it performs well without issues. This requires strong cooperation between
    the developers and the testers: during the build, developers will have to supply
    code to testers, as well as to interim builds, until the code is stable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obviously, there has to be a balance between the number of tests, the testing
    time, and the goals of the tests. Enterprises run tests to avoid risks such as
    materializing and causing damage. One of the first topics that needs to be addressed
    in defining a test strategy is creating a clear view of risks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Be aware that this is not just something technical. It also involves soft skills
    in collaboration and communication. Where testers were used to get the whole package
    delivered at the end of the development cycle and then run their tests, they are
    now part of the DevOps team, continuously communicating about timing, the way
    of testing, and what will be tested. This is crucial for the success of DevOps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Define tools and environments**: Honestly, it''s not about the tools – it''s
    about the code and the level of **standardization**. Testers need to make sure
    they capture all the code: we refer to this as code coverage, which should be
    100% or very near that at the least. Test cases must be automated. **Automation**
    requires standardization: code needs to be automatically deployed to standardized
    test environments where the pre-testing, cleanup, and post-testing tasks are automated.
    This will increase efficiency and reliability, preventing human errors in repetitive
    tasks, assuming that a number of tests will be executed more than once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A first test, very early in the development process, includes *static analysis*
    to check whether the code is complete. With static analysis, the code is not executed:
    tools validate that the code is complete and consistent. An example is when testers
    can use tools and scripts to validate that security policies have been applied
    to the code and that the code is compliant with industry standards. Reviewing
    the static analysis process should provide a detailed overview of the quality
    of the code and the surrounding documentation.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Execute**: Test scenarios must be very well structured. This needs to be
    defined in the test design, which we will discuss in the *Designing test automation
    and execution* section. There, we will look at various executing techniques:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '- Process focused'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Condition focused'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Data focused'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Experience focused'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: An important goal of DevOps is to speed up delivery by reducing waiting times
    between process steps. This also includes testing. We already noted that testers
    do not have to wait until the code is finally delivered, but that they can run
    automated tests in subsequent iterations of the build cycle. To reduce the test
    time – and with that, the whole build – *parallel execution* of tests is advised.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more that can be done to improve quality and tests and that's not the
    sole responsibility of quality engineers and testers. DevOps really is a team
    effort, encouraging all members to contribute to various steps and stages. Developers
    are therefore also invited to contribute and add test cases. It's good practice
    to collect cases, scripts, runbooks, reports, and other documentation in a quality
    repository. From this repository, quality engineers and testers can pick up cases
    and further automate these in the development and deployment process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Creating and interpreting reports**: Test results must be evaluated. At the
    beginning of this section, we stated that tests are executed to identify, analyze,
    and mitigate risks. Test outcomes must match these risks, meaning that they should
    result in expected outcomes. If the outcomes are completely different, then the
    risks need to be investigated further. Only then will the tests really contribute
    to the quality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, testing is much more than just detecting bugs. Tests must be focused on
    the overall desired outcome of the build. Consequently, testers need to report
    on much more than purely the issues. Reporting is now really focusing on improving
    the quality of both the build and the build process. An example is when the test
    results may show where automation can be improved or code can be enhanced. The
    overall goal is to reduce risks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Blocking issues – issues that inflict a big risk – must be reported instantly
    and looped back to the start of the development chain.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Setting exit criteria**: Results matter in tests and they lead to decisions
    about if and how to proceed. That''s what **exit criteria** are for. If all the
    necessary tests have been conducted, the results should give you enough information
    to do a *go*/*no go* and push the software to the next stage, typically production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, you learned how to compose a quality and test strategy. Before
    we learn how to implement quality measures, we will briefly look at different
    types of tests.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding types of tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will introduce the different, most commonly known types
    of tests. There are three tiers of testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Level 1**: **Small tests** that focus on separate components. Unit tests
    are an example where small pieces of the code are tested.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Level 2**: **Integration tests** that involve more than one component. Integration
    itself is tested, but also how components interact and if the integrated packages
    perform well. Integration and performance tests are executed at this level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Level 3**: **Usability tests** that focus on how easy the end product can
    be used – for example, using the graphical interface – and if it''s easy to manage.
    The **User Acceptance Test** (**UAT**) is typically the final test at this level.
    To be clear, the UAT also involves performance testing from the end user''s perspective.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These three levels are shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Levels of testing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_03_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Levels of testing
  prefs: []
  type: TYPE_NORMAL
- en: The complexity increases as testing moves from single components to a usability
    test, which involves the full stack of the solution.
  prefs: []
  type: TYPE_NORMAL
- en: In the test strategy, the teams will define, based on the business requirements,
    what tests must be conducted and what the expected outcome must be to deploy a
    build successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of specific tests have not been mentioned yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Regression test**: These tests were very common in the traditional approach
    of software development. Functional and technical tests were re-executed to make
    sure that software – code – that was changed during the development cycle still
    performed without issues after the change. As we have seen, DevOps has changed
    the way we approach testing. It''s not a one-time exercise anymore, where we run
    a regression test, find bugs, fix these, and rerun the tests. In DevOps, code
    is continuously tested and improved throughout the build. Regression tests have
    become *less important*. In some cases, it still might be valuable to execute
    regression tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security test**: The same applies to security tests that were often executed
    once the build was delivered. In DevOps, we check for vulnerabilities and compliancy
    issues during the first static analysis stage. In [*Chapter 14*](B17492_14_ePub_RK.xhtml#_idTextAnchor168),
    *Integrating DevSecOps with DevOps*, we will go into this in more detail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing is about validating quality. In the next section, we will learn about
    quality measures and how to implement them in our DevOps projects.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing quality measures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, it should be clear that everything in DevOps is about being **continuous**,
    which, in other words, means **continuous deployment**, **continuous integration**,
    **continuous testing**, and **continuous quality** engineering. DevOps projects
    constantly focus on **quality** at every stage of development and operations.
    It's different from traditional approaches where teams have a separate phase to
    fix issues. In DevOps, teams constantly measure the products and fix issues as
    soon as they occur. One of the six DevOps principles is **continuous improvement**,
    which refers to the feedback loop wherein products are improved in every iteration,
    but also to the DevOps process itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common practice in IT projects was to have a fixing phase, something that
    Gerald Weinberg describes in his book *Perfect Software and other illusions about
    testing*. The fixing phase was put at the end of the development phase before
    software was handed over to operations. In DevOps, we don''t have a fixing phase
    because quality is measured and tested as teams go along, during the whole development
    and operations cycle. This can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Continuous testing (based on TMAP)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_03_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Continuous testing (based on TMAP)
  prefs: []
  type: TYPE_NORMAL
- en: How do you measure quality? First, what is quality? We started this book by
    saying that it all starts with the business. That's why **enterprise architects**
    have such an important role to play in DevOps. Enterprise architects have a major
    task in translating business needs into solutions. From business demand, the product
    portfolio should be clear about what standards these products should be delivered
    to. That's quality. It's a product or service that meets the needs and expectations
    of the user. Quality is a product or service that satisfies the users. Hence,
    testing is about validating if the user can be satisfied with the delivered product
    or service.
  prefs: []
  type: TYPE_NORMAL
- en: 'What do enterprises measure in terms of DevOps quality? Two main things: the
    build itself and its *functional validation*. For the build itself, topics such
    as the number of successful builds, the total number of defects, and code coverage
    are important. For functional validation, the main topics are whether all the
    requirements have been tested and if all the identified risks have been covered.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections, we will learn what instruments we can use to define
    quality and how to measure it, starting with acceptance criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Defining acceptance criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can start testing, we need to know what we will be testing. That''s
    why we need to define **acceptance criteria**. To put it very simply: when is
    good, *good enough?* Again, it starts with the user story, which defines what
    a product or service should include. The user story sets the scope and the specific
    functionality a product or service must have.'
  prefs: []
  type: TYPE_NORMAL
- en: 'How do you set acceptance criteria? The question is, *what is it that we''re
    building?* "It" must be specified and with that, "it" must become tangible. The
    DevOps team looks at specifications from four angles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Business**: What does the business require?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Development**: How can we build a solution that meets the business requirements?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quality**: How can we test the solution and validate that it meets the requirements?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operations**: How can we manage the solution so that it keeps meeting these
    requirements?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In DevOps, we''re not building the whole package at once, as in a waterfall
    type of project. The team starts with a minimal viable product and then iterates
    the product, continuously improving it. Acceptance criteria are set per requirement
    and thus, following the logic of DevOps and quality measures, each requirement
    is tested. This is what **test-driven development** (**TTD**) does. In TDD, the
    team writes the test case first and then the code. The code is written to the
    specifications of the test case, proving that the requirements have been met.
    The TDD flow is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Test-driven development'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_03_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Test-driven development
  prefs: []
  type: TYPE_NORMAL
- en: TDD is nothing new and has existed since the mid-fifties, but the most commonly
    used version is described by Kent Beck (refer to the *Further reading* section).
    The team picks a requirement, writes the test case, develops the code, and runs
    the test. When the tests are successful, the code is refactored or rewritten,
    meaning that the code is cleaned and remediated to the standards the architect
    has set for the code. After this step, the code is tested once more with the test
    case. This cycle is repeated for every requirement.
  prefs: []
  type: TYPE_NORMAL
- en: The next steps are assessing the Definition of Ready and agreeing on the Definition
    of Done. We will study them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Definition of Ready and Definition of Done
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we learned how to set acceptance criteria and how TDD
    can help in making sure that we meet a specific requirement. However, a product
    or service likely has many requirements before it can really be launched into
    production.
  prefs: []
  type: TYPE_NORMAL
- en: In DevOps, we use two important processes to validate if a fully developed product
    or service is ready for production. These processes are the **Definition of Ready**
    (**DoR**) and the **Definition of Done** (**DoD**).
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid mistakes, bear in mind that the acceptance criteria are not the same
    in both DoR and DoD:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Definition of Ready**: To understand DoR, it''s important to know how *Agile
    Scrum* works. DevOps teams typically work in sprints, a short period of time in
    which a piece of the product is developed. The work that needs to be done is defined
    in **product backlog items** (**PBIs**). The whole product or service is defined
    in a user story and then broken down into PBIs – tasks that a team can work on
    during a specific sprint and that can be completed during that sprint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agile Scrum actually doesn't mention DoR. Yet, it has become a common practice
    to have a set of agreements to define when PBIs are ready to be picked up by the
    team. The problem with user stories is that, in some cases, they don't contain
    enough concrete information to start the build. The DoR contains entry criteria
    so that the team knows what to build. The process of defining the DoR is referred
    to as refinement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Definition of Done**: In contrast to DoR, the DoD is part of Agile Scrum
    and describes exactly what a **Product Backlog Items** (**PBI)** looks like when
    it''s finished. So, the DoD is a very strong instrument for validating the quality
    of the builds. Developers commit to the DoD. They commit to the fact that they
    must be absolutely clear about what they need to build. In IT projects, the DoD
    must contain the following topics as a minimum:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '- All the code has been written.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- All the code has been reviewed and validated.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- The relevant documentation has been written and made available.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- All the tests have been executed and signed off.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- All functionality has been proven to be delivered.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Where the DoR takes care of the entry criteria, the DoD contains the exit criteria
    – the statement of completion. All team members must agree upon the DoD: the business,
    developers, testers, and operations. Don''t forget the last group, where operations
    need to sign off the DoD and run the software. For them, it''s crucial to validate
    that the code and relevant documentation are completed. Furthermore, in true DevOps,
    we will not have separate developers, testers, or members doing operations. Instead,
    we will have members with skills in development or testing.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So far, we have discussed the test strategy, the quality measures, and the acceptance
    criteria. In the next section, we will learn how to design test automation and
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: Designing test automation and execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to design and implement tests. We will study
    the most common different test varieties and learn where we can use them. When
    we start discussing testing in IT, we need to discuss and agree upon a test management
    approach. In this book, we will use TMAP, introduced by ICT service provider Sogeti
    in 1995 and widely accepted as the standard in software testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The traditional phases of TMAP are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Planning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In DevOps, this is not a one-off exercise; we will be working with continuous
    testing. One major difference with the traditional way of working is that there's
    no separate test unit with a manager and testers. These professionals are now
    part of the DevOps team and they do their work alongside the developers. Next,
    in DevOps, we are working according to the *everything as code* principle, thus
    allowing teams to automate as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we learn more about continuous testing, we need to understand the various
    types of testing. The most important ones are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process focused**: The test focuses on the paths and flows in software. In
    TMAP, this is called **path coverage**. The test covers the path that a transaction
    follows to reach a certain end stage. This can become very complicated when lots
    of paths need to be followed. In that case, the test covers all possible paths
    and various decision points.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Condition focused**: A condition can be a decision point. The test covers
    the decision points and the conditions that it points to be either *true* or *false*.
    The question is how that will influence the outcome of the test. Be aware that
    this is a very simple explanation. In theory, software will have many decision
    points with specific conditions, thus influencing the outcome of the test. In
    a **Condition Decision Coverage** (**CDC**) test, all decision points and decision
    outcomes will be tested against the condition *true* or *false*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data focused**: This test uses data input to verify the test results. This
    type of test is commonly done through **boundary value analysis** (**BVA**). In
    the test, we enter the minimum and the maximum values, known as the *boundaries*.
    These can be numeric, but also *statements*. If we then, as a test case, enter
    a value that''s outside these boundaries, the result should be "invalid." Any
    input within the range that is specified should lead to the result "valid."'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Experience focused**: These are more often referred to as **user experience**
    (**UX**) tests. All of the previous tests are binary. The software follows the
    expected paths, the conditions of the decision points lead to expected results,
    and the entered data gives the expected results. Experience is something completely
    different since it''s very subjective by nature. Yet, testers would like to know
    how the software "feels." Is it responsive enough, does it perform well, and is
    it easy to use? The basic question is: *is there a way to test experience in an
    objective manner?* There are some methodologies that aim for this, with one of
    them being the "experience honeycomb," which was developed in 2004 by Peter Morville.
    This can be seen in the following diagram:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.4 – The experience honeycomb'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_03_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – The experience honeycomb
  prefs: []
  type: TYPE_NORMAL
- en: Still, experience remains a bit intangible. It's very useful for finding out
    whether software is meeting the user's expectations, but to find faults and issues
    in the software, testers will need to perform more exact tests. Note that experience-oriented
    tests are very hard to automate.
  prefs: []
  type: TYPE_NORMAL
- en: Again, testing in DevOps is not a one-off. In the next section, we will discuss
    continuous testing.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the principles of continuous testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 2*](B17492_02_ePub_RK.xhtml#_idTextAnchor027), *Managing DevOps
    from Architecture*, we learned about the CI/CD pipeline. We saw that testing was
    an integrated part of the pipeline. This assumes that all software is developed
    using CI/CD, which, in enterprises, is often not the case. There will still be,
    as an example, legacy systems that are not integrated in CI/CD. The same applies
    to **Software as a Service** (**SaaS**) applications: these are purchased as a
    service, and for that reason, not "developed" within the enterprise. However,
    they need to be tested.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in continuous testing is automating the **test cases**. This
    is easier said than done, but it''s feasible if tests have been set up from known
    patterns – for instance, simulating how a user would use the application. If we
    have an application that processes purchases, we could think of three use patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Place an order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cancel an order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the order's status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Steps can be automated and with that, we can create a test case that can be
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the test cases and the code that needs to be tested, we need an
    environment where we can execute the tests. This can also be automated. By using
    the public cloud, it's easy to create a (temporary) test environment on demand
    and decommission it automatically when the tests have run. It could even be part
    of the full test scenario, where you can spin up an environment in Azure, AWS,
    or any other cloud, deploy the code (or rather, a copy of the source code), run
    the tests, and decommission the environment after completion. This does require
    automated infrastructure to set up and **Infrastructure as Code** (**IaC**) to
    be implemented, something that we will discuss later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, continuous testing requires the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Integrated quality engineering and testing*: Testing is an integrated part
    of the DevOps team – meaning that every member of the team is involved in testing.
    However, in large enterprises running multiple DevOps projects, it is recommended
    to have a quality team that helps implement quality measures and tests the strategies
    in these projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Automated test cases*: It''s recommended to start small. Pick one test case
    and automate that. Set the baseline for this test case: what data is absolutely
    required to run a successful test? What metrics will be used and for how long
    will a test need to run? Don''t make tests too big; use small test sets and run
    them for a short period of time. Evaluate and, if needed, adjust the test sets
    and their duration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Test tools*: These tools need to integrate with the CI/CD pipelines. This
    book is not about test tooling, but some popular tools are **Selenium** and **Micro
    Focus Unified Functional Testing** (**UFT**). How do you pick the right tools?
    That really depends on your approach. Some enterprises prefer a single stack solution,
    meaning that one tool covers the whole testing strategy. Others have a toolset,
    using separate tools for test modeling and test execution. Again, integration
    with the CI/CD pipeline is crucial.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Automated test environments*: Automate how the test data is provisioned, how
    the test case is executed, and how the test environments are provisioned using
    cloud services. Automating environments requires that we define everything as
    code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a) **Infrastructure as Code** (**IaC**): Virtual machines, network components,
    containers, firewalls – everything is defined as code. In Azure, we use **Azure
    Resource Manager** (**ARM**) templates, and in AWS, the preferred way of working
    is to use **CloudFormation**.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'b) **Configuration as Code** (**CaC**): As soon as infrastructure components
    are deployed, they need to be configured so that they match the standards and
    policies of the enterprise. Think of DNS settings, certificates, and security
    policies such as hardening and patching. Once the configuration has been applied,
    we reach the **Desired State Configuration** (**DSC**).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: DSC is a term that is typically associated with Microsoft Azure. In this book,
    we will use DSC as a generic term to explain that the cloud infrastructure needs
    to meet specific requirements, as defined by the architecture, in order to be
    compliant.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'c) **Pipeline as Code** (**PaC**): Every step in the CI/CD process is defined
    in code, from pulling the source code to its actual deployment, including the
    test procedures.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'd) **Test as Code** (**TaC**): Test as code refers to the test automation process
    itself, from collecting, assessing, and deploying test data to actually executing
    (running) the various tests and collecting the results. We can also validate the
    results automatically using *artificial intelligence* and *machine learning*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In this section, we learned all about testing as a methodology to validate
    quality in DevOps projects. We saw that automation can bring a lot of value to
    our testing strategy. One important remark must be made as a conclusion: *it''s
    not about automation itself*. The goal should be to optimize the builds and improve
    their quality. It''s the quality value that matters, not the test itself. Tests
    will help teams improve the quality of their work by identifying risks and helping
    them understand how to mitigate issues. That''s what we will talk about in the
    next section. We''ve found a problem – *now what?*'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding root cause analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we discussed quality measures and testing to validate
    these criteria in a highly structured and automated way. Still, things can go
    wrong. The golden rule in DevOps is *you build it, you run it*, often followed
    by the statement *you break it, you fix it*. Or even it could be *you destroy
    it, you rebuild it better*. If something breaks, the team will need to find out
    what exactly happened. In this section, we will talk about **root cause analysis**
    (**RCA**) as one of the most important instruments for finding the cause of a
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'RCA is the methodology for finding the exact cause of an issue. With that,
    RCA provides insights on how the team can improve products or services. These
    can be quick fixes or long-term enhancements. RCA is more than just a way to find
    problems; it''s the start of improvement. Important questions that need to be
    addressed in RCA are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the problem?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where was it found?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why did the problem occur?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What caused the problem?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What improvements can we make to avoid the problem in the future?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are several ways to conduct an RCA. Popular methods are the *5 whys* and
    the *fishbone* diagram (also known as the *Ishikawa* diagram). The 5 whys method
    is an easy way to literally drill down to the root cause of a problem, simply
    by asking "why" five times. It's a bit like a little child that constantly repeats
    the same question up until the point where it's satisfied with the answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fishbone, invented by Professor Ishikawa, is more suitable for drilling
    down to more complex issues. Again, it starts with the problem and then the team
    identifies what could contribute to that problem: infrastructure, code, programmers,
    and so on. These are the "fish bones." Each of the bones is then analyzed. The
    basic diagram for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Fishbone diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_03_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – Fishbone diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of the methodology, the basic steps for RCA are always the same,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Steps of RCA'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_03_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – Steps of RCA
  prefs: []
  type: TYPE_NORMAL
- en: 'The RCA starts by gathering data to find out what exactly happened. The next
    step is the problem statement: when did it happen, where, and what is the impact
    of the problem? The last question in particular – *what is the impact?* – is important.
    It drives prioritization in the project and the business case. If the impact is
    low but the mitigation solution will require a huge investment in time and thus
    costs, the team might decide to give it a low priority and put it on the backlog
    of the project. If the problem has a high impact, it might become an impediment.
    It needs to be solved before the team picks up any new tasks. It''s one of the
    main principles in *Site Reliability Engineer*, which we will discuss in detail
    in [*Chapter 5*](B17492_05_ePub_RK.xhtml#_idTextAnchor066), *Architecting Next-Level
    DevOps with SRE*.'
  prefs: []
  type: TYPE_NORMAL
- en: After analyzing the cause and the impact, the team can work on solutions to
    mitigate the problem. The last step is the final report. It's a common practice
    to test the solution first and validate if the solution is really solving the
    problem. RCA is a quality measure and quality measures need to be tested, as we
    learned in the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have discussed testing and how to handle RCA to improve the product
    by finding solutions for problems. But as with everything in DevOps, we are aiming
    for continuous improvement. That also includes roadmaps for improving the building
    blocks themselves, known as the infrastructure, the coding framework, and the
    DevOps environment. That's the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Designing for remediation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've talked about coding the software, implementing the required infrastructure,
    automating it all through CI/CD pipelines, testing the environments, detecting
    issues, and, if needed, fixing the problems. But there's something that we haven't
    been discussing yet and that's the speed of software development and DevOps itself.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps is about learning. As the team and projects grow, they learn how to improve.
    They learn from the product itself and how it's used, and they learn from looking
    at other projects, technologies, and methodologies. These lessons are adopted
    and injected into their own project. The team doesn't need to start over, though
    – they can adopt and adapt as they proceed. We call this **remediation**, which
    is the process of improving an existing situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remediation can take place on three levels, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Infrastructure*: Assuming that we build everyone according to the "everything
    as code" principles in public clouds such as Azure or AWS, teams will have to
    take into account that these platforms evolve rapidly. It''s the responsibility
    of the architect to "track" the roadmap of the cloud services, and then decide
    whether to include new features in the roadmap of the project and improve the
    infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Software/application code*: Software developers work in code frameworks or
    versions, such as *.NET*. The framework contains the **Framework Class Library**
    (**FCL**), which holds the languages that code can be written in to ensure interoperability
    between different platforms. By using compilers, code written in C#, VB.net, and
    J# (Java) is translated into **Common Language Infrastructure** (**CLI**) so that
    it runs on Windows platforms without us having to write machine code directly.
    CIL produces executables that can run on Windows and various Linux distributions
    such as **Red Hat Enterprise Linux** (**RHEL**), Ubuntu, Debian, Fedora, CentOS,
    Oracle, and SUSE. .NET is just one example. Other frameworks include ASP.NET,
    Java, Python, PHP, and JavaScript. They all run specific versions and developers
    must make sure that their code is running a supported version. Again, it''s recommended
    to have the framework versions set out in a technology roadmap to keep track of
    the life cycles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*DevOps*: Finally, DevOps itself has various implementations, typically in
    combination with a specific way of agile working. In other words, it''s not only
    the tool or toolsets that change, although it''s important to keep track of the
    DevOps tool roadmaps. It''s crucial for source control. For example, Azure DevOps
    – widely used to run DevOps projects in Azure – currently runs Azure DevOps Server
    2020 as a version control system, allowing developers to work together on code
    and track changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key takeaway from this section is basically to never stop learning and never
    stop improving. IT is changing rapidly and so is DevOps. DevOps teams have a great
    responsibility in staying ahead so that the business really can benefit from new
    developments. It's the architect that has the responsibility of guiding the teams
    in this and making the right decisions. With that, the architect should focus
    on *quality*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was all about quality. We learned how to identify quality measures
    and that this is more than just about fixing bugs. Quality is about meeting expectations,
    but DevOps teams need to be able to measure these expectations. That's why businesses,
    developers, and operators need to be clear on the acceptance criteria. In this
    chapter, we discussed the DoR as an entry point to working on a project and DoD
    for measuring whether a product is really complete.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring means that teams have to test. In a traditional way of working, testing
    is done as soon as the whole product is delivered. In DevOps, we work with continuous
    testing. In other words, all the team members are involved in testing and validating
    the quality of the product. In this chapter, we discussed different ways and types
    of testing that are common in DevOps. Lastly, we talked about continuous improvement
    using remediation. Cloud platforms, software development technology, and DevOps
    tools are constantly evolving, and DevOps teams need to adapt and adopt these
    changes in their projects to allow businesses to benefit.
  prefs: []
  type: TYPE_NORMAL
- en: The role of the architect is crucial in that they need to guide in these developments
    and enable the team to make the right decisions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss scaling DevOps. We start small, but in
    enterprises, we need to scale out if we want an entire business to start working
    agile and work in DevOps teams. On this note, what do we do with existing programs
    and projects? Let's find out!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed different types of tests. One of them is unit
    tests. Give a short description of a unit test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a data-oriented test, we enter the minimum and the maximum values. If we
    enter a value within these boundaries, the test result should be valid. What is
    this test method called?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To decide if a product is complete, DevOps uses a certain technique. What is
    this technique called?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*True or False*: A fishbone diagram is a good practice for analyzing the root
    cause of a problem.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Quality for DevOps Teams*, by Rik Marselis, Berend van Veenendaal, Dennis
    Geurts and Wouter Ruigrok, Sogeti, 2020'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Test-Driven Development: By Example*, by Kent Beck, 2002'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
