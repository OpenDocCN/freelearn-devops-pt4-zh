- en: '*Chapter 4*: Scaling DevOps'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DevOps started—and is in some companies still done—with a lot of manual tasks,
    scripts, and ad hoc tests. A lot of enterprises focus on the applications and
    tend to forget about the platform itself—the infrastructure—but this is also crucial
    to the scaling. This chapter focuses on the scaling of DevOps, both from a technical
    and an organizational perspective.
  prefs: []
  type: TYPE_NORMAL
- en: After completing this chapter, you will have learned how to handle scaling.
    First, we will learn about modern DevOps, which adopts cloud and cloud-native
    technology as target platforms to run applications. Before we can do that, we
    probably need to transform the applications; otherwise, we will develop new applications.
    In DevOps, we need a development method that fits to the way of working; therefore,
    we will discuss **rapid- application development** (**RAD**). Next, we will look
    at adopting DevOps throughout a whole enterprise, starting small and then expanding.
    Finally, we will have a look at mission-critical environments and how we can manage
    them in a DevOps mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding modern DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with RAD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling infrastructure with DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling DevOps in enterprise environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing mission-critical environments with DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding modern DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of DevOps is not new. Basically, the idea was that teams could improve
    their work if developers and operators were really working together as one team.
    The reason for that was easy to find, as we've already seen in [*Chapter 1*](B17492_01_ePub_RK.xhtml#_idTextAnchor013),
    *Defining the Reference Architecture for Enterprise DevOps*. In this section,
    we will learn how DevOps has evolved over the years and what the impact of modern
    DevOps has been on enterprise **information technology** (**IT**). We will also
    study how DevOps helps in transforming legacy applications by app modernization.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of enterprises decided in the 1990s that IT was not a core business and
    could be outsourced to suppliers. Typically, all management—operations—of commodity
    IT was outsourced. It created not only silos within enterprises, but also outside
    of them. Over time, IT got more complex, demands increased, and enterprises found
    themselves in a position of having to find ways to get back into the driving seat
    of IT, which had become core for the business.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2009, the first **DevOps Days** conference was held in Belgium. The base
    idea: break down the silos, put developers and operations back in one team, and
    increase the quality and velocity of software development. These are still the
    goals of DevOps. That hasn''t changed over the years.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But it doesn''t mean that DevOps hasn''t changed at all. The main differentiators
    are cloud technology and automation. These are the two most important pillars
    of modern DevOps and are outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cloud**: One of the main issues in early DevOps was the availability of development
    and test systems. In modern cloud platform deployments, even temporary systems
    have become much easier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud native**: Silos between developers and operations have been broken
    down, but the same applies for technical silos in different platforms. Interoperability
    between systems has become the standard in cloud native, with the entrance and
    emergence of **Platform as a Service** (**PaaS**), **Software as a Service** (**SaaS**),
    container technology, and serverless functions. The major two developments in
    IT for the near future are likely software to services and **virtual machines**
    (**VMs**) to containers, increasing portability across cloud platforms and even
    between on-premises systems and cloud systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automation**: Automate as much as possible. This means that in modern DevOps,
    we should perceive everything as code—not only the application code, but infrastructure,
    configuration, and integration as well. In [*Chapter 2*](B17492_02_ePub_RK.xhtml#_idTextAnchor027),
    *Ma**naging DevOps from Architecture*, we discussed pipelines for the deployment
    of applications and infrastructure, but in modern DevOps everything is built through
    pipelines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**All code is stored in a repository**: Applications, infrastructure, tools,
    governance, and security are translated into code, and with everything as code,
    we can have everything in pipelines. So, besides a deployment pipeline for application
    code and a pipeline for infrastructure, we will also have pipelines for tool configurations,
    integrations, reports, and security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrated security**: For security, we will have DevSecOps, which starts
    with Security as Code. The security posture of enterprises is translated into
    code and managed from a single repository. The development of the security posture
    is handled in the same way as the development of applications and infrastructure,
    by continuous improvement and not solely by reacting to attacks, threats, or breaches.
    Code that has been developed will immediately be merged with the security code,
    integrating the security posture. Security is developed at the same speed as applications
    and infrastructure. *Section 3* of this book, *Bridging Security with DevSecOps*,
    is entirely about implementing DevSecOps, starting with [*Chapter 12*](B17492_12_ePub_RK.xhtml#_idTextAnchor145),
    *Architecting for DevSecOps*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced technology**: Modern DevOps is sometimes referred to as *accelerated*
    or intelligent DevOps. With enhanced technologies such as **artificial intelligence**
    (**AI**), **machine learning** (**ML**), and **robotic process automation** (**RPA**),
    automation can really be leveraged. Examples are self-healing systems or code
    and pipelines that *learn* autonomously from previous deployments. With RPA, processes
    can be highly automated and, if combined with AI/ML, think about logical next
    steps in deployments—for instance, by learning from test results or system behavior.
    **Artificial Intelligence IT Operations** (**AIOps)** is a good example of this
    development. [*Chapter 8*](B17492_08_ePub_RK.xhtml#_idTextAnchor095), *Architecting
    AIOps,* and [*Chapter 9*](B17492_09_ePub_RK.xhtml#_idTextAnchor111), *Integrating
    AIOps in DevOps*, will provide deep dives into AIOps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To summarize, modern DevOps is more about this:'
  prefs: []
  type: TYPE_NORMAL
- en: Involving all stakeholders—it's not only about developers and operations, but
    also about business managers, security specialists, quality and assurance managers,
    and procurement (think of licenses).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud and cloud-native adoption, including containers, functions, and automated
    services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thinking in code, and therefore in pipelines. Keep in mind that with everything
    as code and deep automation, we also need to think about the principle of trust.
    We need to make sure that the code and assets we have in our pipelines are trusted.
    Next, who is mandated to state that assets are trusted and may be applied to the
    pipeline? Is that the security engineer, or can it be delegated to the developer?
    Or, can delegation even be automated if we have systems that adhere to the **principle
    of least privilege** (**POLP**)? Segregation of duties becomes very important—controls
    are required to protect code from unauthorized changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we discussed changes to DevOps over the years. The reason for
    enterprises adapting DevOps is to modernize IT as a whole. Enterprises have a
    long history (also in IT), and therefore typically have complex, large IT ecosystems
    with legacy applications. App modernization has become an important topic in modern
    DevOps, and the next section will talk about that.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing and understanding app modernization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'DevOps, the cloud, automation, and code are all key principles of digital transformation.
    But many enterprises will have core applications that they have been running for
    a long time: legacy systems not fit to adopt DevOps or even ready to migrate to
    the cloud. In this section, we will discuss the process of application modernization:
    the process of transforming these applications to systems that we can run in the
    cloud, keeping up to date with modern technologies, and supporting the business
    by being able to adapt to new demands faster.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: App modernization is a huge market. A number of companies such as IBM and Fujitsu
    have massive programs to transform mainframe applications to cloud providers such
    as **Amazon Web Services** (**AWS**), even running **common business-oriented
    language** (**COBOL**). The reason for enterprises *shifting* their old mainframe
    applications to the cloud is easy to understand. The original code is left intact
    as much as possible, but it's moved from expensive on-premises equipment to pay-as-you-go
    cloud environments, where risks are fairly low. The downside is that companies
    will still need to have resources with COBOL programming skills to maintain the
    app itself. In other words, the application itself is still legacy and will probably
    not be able to adopt and benefit from new cloud-native technology. The next step
    would be to also modernize the application by, for instance, rewriting the code
    or rebuilding the functionality in a completely new application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enterprises can follow a number of strategies in app modernization, such as
    the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rehosting**: This is the lift and shift of existing systems *as they are*.
    The application is picked up and moved to another target platform. The application
    is not changed in any way whatsoever. However, moving an application from—for
    instance—an on-premises environment to AWS or Azure will imply some modifications,
    especially in connectivity. These modifications will be very minimal and will
    not impact the application itself. A common way of rehosting is exporting the
    VM, including the operating system and application code as a whole, to the new
    cloud environment. It''s a fast way to migrate applications to the cloud, but
    by doing so, enterprises will not experience real benefits from cloud services.
    They simply run their machines in another data center—in this case, the cloud
    data centers of AWS, Azure, or any other public cloud provider.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replatforming**: With replatforming, applications are optimized to run in
    the cloud. A very common example is replatforming databases to PaaS. Database
    instances are moved to AWS **Relational Database Service** (**RDS**) or Azure
    **Structured Query Language** (**SQL**), both native database services managed
    by the platforms. Developers will still be able to program databases the way they''re
    used to, but they don''t need to worry anymore about the database platform itself.
    That is taken care of by the provider.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refactoring**: Sometimes referred to as rearchitecturing. In this case, the
    application code is modified to run in an optimized way in the cloud. Cloud-native
    services are applied. Application code might be rewritten to run in containers
    or with serverless functions. The functionality of the application remains as
    it is: only the underlying technology is changed. Take the COBOL example at the
    beginning of this section: COBOL could be rewritten to C# or Java. However, architects
    and engineers would first need to decouple the business logic from the code itself.
    If the business requires the business logic to be modified as well, then the strategy
    changes to rebuilding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rebuilding**: In the case of a rebuild, architects start with revalidating
    the functionality of the application. What is the functionality that the business
    requires, which data will be used, and how does it translate into the usage of
    an application? Next, the application is rebuilt on the validated business and
    technical requirements. The functionality returns, the technology is completely
    revisited, and the application is rebuilt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, rehosting will not bring real benefits in terms of costs. Cost savings
    might be achieved when applications are replatformed or refactored, since the
    use of cloud resources will be optimized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rebuilding is a different story. This might lead to major projects that will
    inflict project costs. As soon as the application is ready to be pushed to production
    in the cloud, substantial savings might be achieved. However, enterprises need
    to take the total cost of ownership into account, thus including the project costs
    and possible risks in rebuilding an application. Enterprise architects play an
    important role in advising and supporting decisions. The following screenshot
    shows a very simple overview of cloud cost components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Simple overview of cloud and DevOps costs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_04_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Simple overview of cloud and DevOps costs
  prefs: []
  type: TYPE_NORMAL
- en: 'What are the steps an enterprise—and a responsible architect—should take to
    start with app modernization? Let''s have a look at these here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing**: The architect gathers all relevant data about the applications.
    They can do so through analyzing information from the **configuration management
    database** (**CMDB**) by using tools to scan the applications, and through workshops
    with stakeholders such as business and application owners.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assessing and architecting**: The next step is assessing all the data. What
    does the architecture look like and how could it map to a modern—cloud—architecture?
    At this stage, the target architecture is defined as well as the *future mode
    of operations*, meaning the way the application is executed and managed. The DevOps
    mode of working and the use of **continuous integration/continuous development**
    (**CI/CD**) pipelines are included in the future architecture. This defines the
    method of transformation. In short: at this stage, the architect defines the *what*
    (what the application and the architecture will look like) and the *how* (how
    we transform the current application to a modern app). The *what* and *how* together
    form a solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deciding**: Stakeholders are informed on all relevant aspects: functionality
    of the application, technical realization, risks, and costs. The business case
    is validated and, based on this, a go/no-go decision is taken to proceed or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Executing**: The project starts. Deliverables and technical roadmaps have
    been defined in features, product backlog items, and tasks. Components are refined
    and pulled into build sprints. Tests are executed, acceptance criteria are validated,
    and **definitions of done** (**DoDs**) are signed off as the project evolves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the high-level process of app modernization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – High-level process of app modernization'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_04_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – High-level process of app modernization
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, app modernization is about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A compelling business case. Is it worthwhile to modernize an application? How
    *core* is the application to the business?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A compelling strategy. Replatform, refactor, or rebuild? Or, is it wise to do
    a simple lift and shift to the cloud first and start the transformation on the
    new platform?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A compelling plan. Have risks been identified? Does the team have the right
    skills and tools to mitigate these risks? Knowing the risks, is the plan feasible
    in a number of sprints?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've discussed legacy applications and what enterprises can do to modernize
    these applications, but enterprises will also develop new code and launch new
    or improved services. Since we are working in a DevOps mode, we have to look at
    a development methodology that keeps track with that. RAD is a solution. We will
    learn about RAD in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with RAD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we discussed how DevOps breaks down silos between developers and operations
    and how it helps in speeding up the development of products, services, and systems.
    Implementing DevOps will increase the velocity of development, but DevOps in itself
    is merely a way of structuring planning of development. It helps in planning in
    iterations: starting with a **minimal viable product** (**MVP**) and then iterating
    improvements in next versions. DevOps is not about the development of code itself.
    We need a development methodology for writing the code, but that methodology should
    *fit* with DevOps. In this section, we will look at RAD.'
  prefs: []
  type: TYPE_NORMAL
- en: Why does RAD fit to DevOps and the agile way of working? The main reason is
    that RAD is agile in itself. RAD starts with prototyping (the MVP) and then focuses
    on iterations. The emphasis is on the fulfillment of requirements, rather than
    on planning. It allows developers to realize quick improvements and adjustments
    during the development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key principles in RAD are furthermore reuse of code and intensive collaboration
    between the stakeholders: business representatives, architects, developers, testers,
    engineers, and the end customer that will use the software. Code is constantly
    reviewed, tested, and validated against the requirements, which are implemented
    in small improvements. This way, risks that the end product is not meeting the
    specifications are less likely to occur. The team is in full control of every
    single small step.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To develop according to RAD, the team needs to follow the following five basic
    steps. These steps completely align with the principles of DevOps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Define requirements**: Gather the business requirements and set the scope,
    budget, timelines, and the acceptance criteria. Have all stakeholders sign off
    to ensure that everyone is in agreement of the deliverables and the final product.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Build**: The development starts with the MVP. Next, the MVP is improved in
    iterations up until the final product is delivered. Keep in mind that in DevOps,
    developers and operations need to be aligned on the product, so they will have
    to work closely together. Can operations manage the application or can it be improved?
    In [*Chapter 5*](B17492_05_ePub_RK.xhtml#_idTextAnchor066), *Architecting Next-Level
    DevOps with SRE*, we will learn how operations can drive improvements such as
    automation in development.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Collect feedback**: We learned in the previous chapter that DevOps embraces
    continuous testing as a quality measurement. This means that feedback is constantly
    collected. This is technical feedback and feedback on the functionality. Developers
    use this feedback to improve the next iteration or version. This is also a matter
    of the DevOps culture: feedback should not be seen as criticism or even a verdict.
    Feedback is really an instrument to improve quality throughout the project.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Test**: In conjunction with collecting feedback, software is continuously
    tested. Does the code work properly and is it meeting the requirements? Testing
    is probably one of the most important things in DevOps projects. In [*Chapter
    3*](B17492_03_ePub_RK.xhtml#_idTextAnchor040), *Architecting for DevOps Quality*,
    we discussed testing strategies and different types of tests.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Publish**: If the product has reached its final state, it''s ready for go-live
    so that it can be used. Two topics that need attention in a launch are the user
    training and the period of after-care. Users will need to learn how to use the
    product and the software, and be prepared that as soon as products go into production
    and are actually used, issues still might arise. In after-care mode, teams can
    still pick up these issues fast.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, DevOps already takes care of this in itself. Issues create feedback
    that is looped back into the project, driving improvements. In practice, teams
    will create *fast lanes* to pick up issues in production with high priority. This
    might halt the further development of products and the development of new features.
    Exactly this is addressed in **site reliability engineering** (**SRE**), the main
    topic of the next chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To summarize, the RAD process is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – RAD'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_04_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – RAD
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to integrate software development in a DevOps
    project. Software needs infrastructure to run. In the next section, we will discuss
    scaling infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling infrastructure with DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key features in modern DevOps is the use of cloud technology. In
    this section, we will discuss why enterprises gain a lot of benefit by moving
    infrastructure in cloud platforms such as AWS and Azure. First, we will study
    the principles of scaling, since this is one of the major benefits of using cloud
    infrastructure. At the end of the section, we will also touch upon next-level
    scaling with containers, given the fact that in the coming years, there will be
    a big shift from VMs to containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In DevOps projects, developers use pipelines, as we have seen in the previous
    chapter. Code is pulled from a repository, changed, tested, and pushed to the
    next stage. Code follows a promotion path: from development to test, acceptance,
    and—eventually—production systems. Development and test systems might not always
    be needed; they simply have to be there whenever they are required in the process.
    If the work is done, then these systems might be suspended or even decommissioned.
    The benefit of the cloud is that enterprises don''t pay for these systems if they''re
    not in use, in contradiction with on-premises hardware that has been purchased
    as a one-off investment. So, the scaling up of development and test systems on
    demand is a huge advantage of cloud infrastructure.'
  prefs: []
  type: TYPE_NORMAL
- en: Another important feature of modern DevOps is automation. A major benefit in
    using cloud infrastructure is the ability to have automatic scaling. However,
    architects and engineers might want to be a bit careful with automated scaling.
    It's true that enterprises pay for what they use in the cloud, whereas in the
    traditional way of working enterprises would need to buy physical machines whenever
    extra capacity was needed. The good side about that was that architects really
    needed to think about the required capacity.
  prefs: []
  type: TYPE_NORMAL
- en: In the cloud, there might not be a driver anymore to worry about capacity. Nothing
    could be further from the truth, though. In cases of peak demand and automated
    scaling without setting limits, the cloud bill will turn out to be a surprise.
    Enterprises, especially financial officers, should therefore not completely rely
    on scaling. In other words, architects will still have a responsibility to plan
    capacity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s study the different varieties of scaling, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertical or scale-up**: Let''s take a server as an example to explain this.
    The server has one processor, 2 **gigabytes** (**GB**) of memory, and 100 GB of
    disk storage. If we scale up, we add processors, memory, or disk storage to that
    server. We are adding resources to the same machine and increasing its capacity.
    That can be done as long as there''s room in the server to add resources. We can
    imagine that this is easier in a coded, virtual world than with a physical machine
    where engineers really need to take out their screwdrivers and mount, for instance,
    extra memory cards in that server. The following diagram shows the principle of
    vertical scaling:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Scale-up or vertical scaling'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_04_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Scale-up or vertical scaling
  prefs: []
  type: TYPE_NORMAL
- en: '**Horizontal or scale-out**: Now, we''re adding more servers to our environment,
    instead of increasing resources within the server. This is very common in the
    public cloud, especially when we''re using load balancers to handle traffic and
    spreading the workloads among the available servers. With automatic scaling, servers
    or pools of servers can be added automatically whenever the load is increasing
    and existing servers can''t handle it anymore without degrading the performance.
    As soon as the load decreases, the environment is scaled down again. Load balancers—an
    example is **Elastic Load Balancing** (**ELB**) in AWs—make sure that the load
    is evenly spread across available resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, keep in mind that applications need to be *scale-aware*. Some applications
    can''t handle scaling at all, while some can scale out but can''t be scaled down
    without impacting the availability of the application. The following diagram shows
    the principle of horizontal scaling:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Scale-out or horizontal scaling'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_04_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – Scale-out or horizontal scaling
  prefs: []
  type: TYPE_NORMAL
- en: '**Full or dynamic scaling**: This is a combination of vertical and horizontal
    scaling. As soon as limits are reached in scaling up, environments can be scaled
    out. In most cases, the scaling out is done by a cloning server. In Azure, we
    can use Azure Automation to do this. In AWS, we can copy the image of the server
    and then spin up a new machine with that image in **Elastic Compute Cloud** (**EC2**),
    using AWS Systems Manager Automation. Off course, there are a lot of third-party
    tools too that can help in automating scaling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are clear benefits of scaling in the cloud. We can have resources available
    on demand, scaling to the capacity that we need at a certain time. Since we're
    only paying for what we use, we could save money by scaling down resources if
    we don't need them anymore. For example, development and test systems might not
    be needed all the time and can be suspended when the work is done. Maybe teams
    can completely decommission these systems and simply spin up new ones as soon
    as the project requires it.
  prefs: []
  type: TYPE_NORMAL
- en: The best part is that DevOps teams can control this completely by themselves—they
    are no longer dependent on purchase departments that need to order hardware or
    require engineers to install it in the data center. It's all code, including the
    scale sets, and it can be fully integrated in the pipelines, ready at their disposal.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling with containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A major forthcoming change in IT infrastructure is moving from VMs to containers.
    The driver behind this is interoperability of systems between different platforms.
    Containers seem to be a very good solution to have software interoperable across
    platforms, with ultimate scalability. There are, however, a few things that an
    architect needs to consider. To start with, they must understand that containers
    also need infrastructure to land on. Containers do not run by themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Containers are operated on compute clusters with a management layer that enables
    the sharing of resources and the scheduling of tasks to workloads that reside
    within the containers. Resources are compute clusters, a group of servers—commonly
    referred to as nodes—that host the containers. The management or orchestration
    layer makes sure that these nodes work as one unit to run containers and execute
    processes—the tasks—that are built inside the containers.
  prefs: []
  type: TYPE_NORMAL
- en: The cluster management tracks the usage of resources in the cluster such as
    memory, processing power, and storage, and next assigns containers to these resources
    so that the cluster nodes are utilized in an optimized way and applications run
    well.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, scaling containers is not so much about the containers themselves,
    but more about scaling the underlying infrastructure. To make this a bit easier,
    Google invented the orchestration platform Kubernetes that takes care of cluster
    management. Kubernetes uses pods, enabling the sharing of data and application
    code among different containers, acting as one environment. Take the last sentence
    quite literally. Pods work with the **share fate** principle, meaning that if
    one container dies in the pod, all containers go with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The workflow in the following screenshot shows the basics of Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – High-level architecture of Kubernetes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_04_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – High-level architecture of Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: The good news, though, is that pods can be replicated using replication controllers.
    Kubernetes polls whether the specified number of pods is running within the cluster
    nodes. If required, pods are replicated, making sure that the specified number
    of containers is running.
  prefs: []
  type: TYPE_NORMAL
- en: Containers are a good solution, but there are still some shortcomings. The most
    important one is that containers and clusters might be interoperable, but typically,
    networks and storage layers are not. In order to scale container solutions, we
    also need networks and storage layers to be *integrated*. For example, Azure Blob
    is a different beast from AWS **Simple Storage Service** (**S3**), yet Kubernetes
    runs on both platforms using **Azure Kubernetes Services** (**AKS**) and **Elastic
    Kubernetes Services** (**EKS**) on AWS. There will be solutions to overcome this,
    but it's definitely something to take into account when planning container platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling DevOps in an enterprise environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve discussed the benefits of DevOps and what cloud adoption, automation,
    and an agile way of working could bring to an enterprise. The big question is:
    *How and where to start?* Opinions differ here, from a **big-bang approach** to
    step-by-step adoption.'
  prefs: []
  type: TYPE_NORMAL
- en: Enterprises that have a lot of their IT muscles outsourced to different IT suppliers
    and that have been working for decades in a certain way are not easily changed.
    For one, there will be a lot of pushback from staff—remember that DevOps is also
    about changing a mindset or a culture. In this section, we're taking the approach
    of step-by-step adoption, or evolution instead of revolution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start small**: Don''t start by implementing DevOps on large projects. Organize
    a small team and a simple project to learn and—even more important—to identify
    possible bottlenecks in the processes. What is possibly hindering the DevOps way
    of working? Do resources have the right skills, and is the team composed of the
    right resources? Does the team have the required tools? Are the requirements clear,
    even if it''s a simple build? Are processes aligned with DevOps? Learn from the
    bottlenecks and improve in each step.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start with the end in mind**: Know where you are going and what the end product
    will look like. Working in small iterations doesn''t mean that the team will not
    need a clear picture of the end goal of the project. The same applies for implementing
    DevOps in an enterprise. From enterprise architecture, it must be clear what the
    strategy is for that enterprise: where will it be in 1, 3, or 5 years? Defining
    an enterprise roadmap can help in setting goals. An example is presented in the
    following diagram:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Enterprise roadmap for adopting DevOps'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_04_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 – Enterprise roadmap for adopting DevOps
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screenshot shows three basic stages, outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '- **Foundation**: The architect defines the target operating model, based on
    a reference architecture covering the applications, technology, security, services,
    and governance. At this stage, the cloud adoption is an important topic: the major
    cloud platforms, Azure, AWS, and Google Cloud, have **Cloud Adoption Frameworks**
    (**CAFs**) that will help in setting up the basics to operate systems in the cloud.'
  prefs: []
  type: TYPE_NORMAL
- en: '- **Adopt**: This stage is about adopting the foundation and the target operating
    model. The cloud environments are set up and the first—small—projects are initiated
    in DevOps mode. Concepts such as **Infrastructure as Code** (**IaC**) and RAD
    can be introduced. A way to do this is by installing a **Center of Excellence**
    (**CoE**) with **subject-matter experts** (**SMEs**) that can guide in the adoption
    of the model, including the cloud technology, use of DevOps tooling, and agile
    coaches to help implement the agile way of working. In the next section, *Scaling
    using a CoE*, we will discuss the setup of the CoE.'
  prefs: []
  type: TYPE_NORMAL
- en: '- **Expand**: We have referenced architecture, have defined a target operating
    model, and assigned a group of experts to take part in a CoE to help in adopting
    the new models and delivering the first projects. At this stage, the model can
    be expanded in the enterprise.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Make sure all steps are visible**: Transparency is key in DevOps. It applies
    to the way of working within the teams and the delivery process of products. Tools
    must enable full visibility as to what happens in the development and release
    chain, the CI/CD pipelines. Ideally, teams have a single-pane-of-glass view on
    events in the release chain: tools that collect real-time data from the pipelines
    and the systems. But also, team members need to know exactly what other members
    are doing, since DevOps is in essence mainly about close cooperation. Team members
    need to be able to track activities, anticipate, and—if needed—correct steps.
    The end goal is a better product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Be ready for change—at all times**: This one seems obvious, but in DevOps
    nothing is set in stone. If something can be improved, teams should be motivated
    to adopt the change that enables this improvement. It applies to DevOps teams
    and their projects, but also to the enterprise as a whole. Even the biggest enterprises
    in the world every now and then have to hit the refresh button, to quote the book
    of Microsoft''s **Chief Executive Officer** (**CEO**) Satya Nadella.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've introduced the CoE. In the next section, we will elaborate on that.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling using a CoE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A starting point could be a CoE. Again, it sounds like a big thing, but it doesn't
    have to be. On the contrary—a CoE can be a good entry point to start transforming
    a business. The CoE is a team that leads or supports employees and organizations
    in the adoption, migration, and operations of new technology, or even a new way
    of working. In short, the CoE can be the starting point of the digital transformation
    of an enterprise. Instead of trying to change the enterprise as a whole at once,
    we assign a team to guide this. The main goal of a CoE is to define and help implement
    best practices for implementing architecture, transforming and optimizing operations,
    and implementing governance.
  prefs: []
  type: TYPE_NORMAL
- en: The installation of a CoE should also be done in steps, starting with a CoE
    that defines the standards and policies. For that reason, the architect should
    be a member of the CoE. Next, the CoE defines the *guardrails*, ensuring the usage
    of best practices. Don't reinvent the wheel, but use what's out there and has
    been proven to work well in other enterprises. But there's a risk in that too.
    The risk is that the team is making it too big.
  prefs: []
  type: TYPE_NORMAL
- en: A commonly used framework to enroll an agile way of working is **SAFe**, the
    **Scaled Agile Framework**. It might include the implementation of the Spotify
    model, with the instalment of tribes and squads. Those are huge changes for any
    company, even if it's done in just one team. It will impact the whole enterprise,
    especially when IT is outsourced and resources from suppliers need to be involved
    in newly formed teams such as squads. Does the contract between the enterprise
    and the supplier even cater for the new way of working? Before you know it, we
    are implementing a world-conquering plan.
  prefs: []
  type: TYPE_NORMAL
- en: It doesn't mean that we can't use principles of SAFe, but we need to make sure
    that it *fits* and that it is adopted. The CoE can help in defining and controlling
    the adoption toll gates and suggest improvements. This type of CoE—still a small
    team—is referred to as prescriptive.
  prefs: []
  type: TYPE_NORMAL
- en: The next level of the CoE is the advisory level. At this stage, the CoE is formed
    as a (virtual) team of SMEs in different domains, actively helping DevOps teams
    in executing projects. The CoE guards the standards and policies, and controls
    and validates whether these are followed. From this point, the implementation
    of DevOps and agile is accelerated, breaking down the original organization silos.
    However, this is done step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with simple projects in small teams, it doesn't sound like DevOps and
    agile are really suitable to develop and run mission-critical environments. That's
    not the case. An enterprise might want to start with mission-critical, but if
    DevOps is scaled right and there's a clear plan on app modernization, we can also
    start managing critical environments in a DevOps way. The final section, *Managing
    mission-critical environments with DevOps,* of this chapter will explain more
    on this.
  prefs: []
  type: TYPE_NORMAL
- en: Managing mission-critical environments with DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss DevOps for mission-critical environments and
    why it can be done to manage core applications. Let's first define **mission-critical**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very straightforward definition would be: any software that an enterprise
    needs to remain in business. If a mission-critical system were to fail, the enterprise
    would potentially lose a lot of money, either due to direct missed transactions
    or through things that are less tangible, such as reputation damage. These systems
    are identified through the process of **business impact analysis** (**BIA**).'
  prefs: []
  type: TYPE_NORMAL
- en: When we start with DevOps projects, the first thing that an architect does is
    gather the business and technical requirements. That would include the outcomes
    of the BIA process, which is typically done in cooperation with internal auditors
    and business stakeholders. From the BIA, critical systems or system components
    are identified that need to be restored very quickly in case these systems fail.
    This is a very cumbersome process that will cause of lot of discussion.
  prefs: []
  type: TYPE_NORMAL
- en: The enterprise architect will need to understand that stakeholders might have
    different views on what critical systems are. Financial systems in banks will
    be business-critical, but a car factory will not immediately lose business if
    the **Chief Financial Officer** (**CFO**) can't access financial reports for—let's
    say—an hour or so. Production at that factory, however, will stop immediately
    if the assembly robots fail.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprises are still reluctant to host critical systems in public clouds because
    they think that they will lose control over the systems if these are not sitting
    in a privately owned on-premises data center that engineers can immediately enter
    in the case of an emergency. Yet, the public cloud might be the best place to
    host these systems. Because of the vast capacity that these platforms have, it's
    easy to have a copy of critical systems in different regions and zones. If one
    cloud data center fails, there's a second data center that can take over. Using
    cloud technology, this can be done with a minimal loss of data. Cloud technology
    offers tools to build more resilient environments.
  prefs: []
  type: TYPE_NORMAL
- en: Where does DevOps come in? In drafting the **business continuity plan** (**BCP**)
    for which the BIA is the input. There's no real technical reason why mission-critical
    systems can't be cloud-hosted and developed and managed through DevOps, but given
    the fact that these systems need to be highly resilient, there are a couple of
    things to consider—for instance, in planning and applying changes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a nuance to the statement that there''s no real technical reason why
    mission-critical systems can''t be hosted in the cloud. Latency can be an issue:
    the time that information needs to travel between systems. One other reason can
    be compliancy set by law and regulations. Some organizations are simply not allowed
    to host systems in a cloud data center that is not residing in the country or
    region where the organization itself is based. These are aspects that need to
    be taken into account too as part of the BIA.'
  prefs: []
  type: TYPE_NORMAL
- en: An ongoing theme within DevOps is CI. That comes with changes, and changes have
    impact, also on business continuity. With critical systems, we have to make sure
    that the release process is designed in such way that business continuity is safeguarded.
    Quality assurance is, therefore, crucial.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, test the code as soon as it's created. With critical systems,
    tests must be focused on ensuring that as code is pushed to production, the vital
    processes of the enterprise are not impacted or are only very limited, at an explicitly
    prior-accepted risk level. Next, be sure that there's a fallback, rollback, or
    restore mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can teams be sure that what they''re planning to release is *safe to go*?
    The answer to that one is a go-live run. Here''s where the promotion path that
    we discussed in [*Chapter 3*](B17492_03_ePub_RK.xhtml#_idTextAnchor040), *Architecting
    for DevOps Quality,* plays a crucial role. The go-live run is a real practice
    with the tested code on an acceptance system. That system should have exactly
    the same specifications as the production systems. Better: acceptance systems
    are an exact copy of production; they are production-like. The go-live run is
    done from the CI/CD pipelines, using the code as it''s processed and pushed to
    acceptance. But it''s not only about the code. Processes, security, failover to
    different systems, and restore procedures must be tested as well. DevOps tools
    need to be able to support this, as part of the BCP or framework.'
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the chapter. In the last section, we touched upon resilience
    and reliability. In [*Chapter 5*](B17492_05_ePub_RK.xhtml#_idTextAnchor066), *Architecting
    Next-Level DevOps with SRE*, we go deeper into architecting for reliability with
    SRE.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covered a lot of ground. It''s not easy to start with DevOps in
    large, traditional enterprises, but it is possible. In this chapter, we learned
    that we can start small and then slowly expand. Starting small doesn''t mean that
    an enterprise doesn''t need to have an end goal in mind: the enterprise architect
    has a key role in defining the target operating model and the way the enterprise
    will develop and operate products in the future. A CoE with SMEs can guide in
    this transformation.'
  prefs: []
  type: TYPE_NORMAL
- en: There's a good chance that the company has legacy environments that will need
    to be transformed. We've discussed modern DevOps and using cloud and cloud-native
    technology. We also learned about different transformation strategies for applications
    and how we can develop new applications in DevOps mode using RAD.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section, we also learned that even mission-critical systems can
    be developed and managed in a DevOps way, if we focus on resilience and reliability
    of these systems. SRE is a method to cover this. We will learn about architecture
    in SRE in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are migrating an application from an on-premises system to Azure. The SQL
    database is migrated to Azure SQL as a PaaS solution. What do we call this migration
    strategy?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the Kubernetes services that Azure and AWS offer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To assess business-critical systems, we need to analyze the requirements of
    these systems. What is the methodology for this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The Modern DevOps Manifesto* ([https://medium.com/ibm-garage/the-modern-devops-manifesto-f06c82964722](https://medium.com/ibm-garage/the-modern-devops-manifesto-f06c82964722))
    by Christopher Lazzaro and Andrea C. Crawford, 2020'
  prefs: []
  type: TYPE_NORMAL
