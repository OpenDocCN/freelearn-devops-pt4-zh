- en: '*Chapter 12*: Architecting for DevSecOps'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with everything in the enterprise IT domain, DevSecOps requires an architectural
    foundation. In this chapter, you will learn how to compose the reference architecture
    for DevSecOps practices and design the pipelines for DevSecOps. We will also discuss
    the best DevSecOps practices for the major public cloud providers; that is, AWS,
    Azure, and GCP. For that, we will elaborate on some of the leading tools in the
    market. In the last section, you will learn what steps the enterprise should take
    to implement DevSecOps.
  prefs: []
  type: TYPE_NORMAL
- en: After completing this chapter, you will be able to name the different components
    in a DevSecOps architecture and how to include these in a DevSecOps pipeline.
    You will have also learned how to secure containers and what the best practices
    are in various public clouds. Most importantly, you will be able to explain why
    including security in DevOps is crucial for enterprises.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the DevSecOps ecosystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the reference architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing the DevSecOps pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying DevSecOps to AWS, Azure, and GCP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the DevSecOps ecosystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed security principles and how this impacts
    the DevOps way of working. We concluded that security must be at the heart of
    every step in the development and deployment cycle, from the moment where code
    is pulled from a repository to the actual code commit and push to production.
    In this chapter, we will look at the foundation of **DevSecOps**, **DevOps that
    has security embedded**.
  prefs: []
  type: TYPE_NORMAL
- en: 'DevSecOps consists of three layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Culture**: This is not a technical layer, but it''s often forgotten that
    DevOps is much more than just applying tools and creating CI/CD pipelines. Obviously,
    the same applies to DevSecOps. Within DevSecOps, every team member feels responsible
    for security and acts accordingly, taking ownership of it. This doesn''t mean
    that security specialists have become obsolete, though. It''s a good practice
    to have a security engineer or professional in the team, sometimes referred to
    as the security champion. This person must lead all processes in terms of applying
    security standards and policies, ensuring compliance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security by design**: Security is embedded at every layer of the system.
    This typically means that an enterprise has a defined architecture that covers
    every aspect of security and enforcing security postures onto systems: authentication,
    authorization, confidentiality, data integrity, privacy, accountability, and availability,
    including remediation and corrective actions when systems are under attack. Software
    developers do not need to think of security every time they design and build new
    applications or features – the posture is applied as soon as development starts.
    The security architecture, frameworks, rules, and standards are centrally managed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automation**: In DevSecOps, we want to automate as much as we can, and this
    includes security. The rationale for automating security is that we can prevent
    human error, and also have automated tollgates where code is scanned for possible
    vulnerabilities or non-compliant components such as unlicensed code. The security
    lead also takes responsibility for automating security, but does so with the team.
    Automation also implies automated audits and collection of evidence in case of
    attacks or breaches. Next, the automation process makes sure that security metrics
    are collected and sent back for feedback in the DevSecOps practice. For example,
    if, when you scan, a vulnerability in the code is discovered or a license has
    been breached, evidence will be collected and sent for feedback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To manage these layers, DevSecOps relies on the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: Harnessing repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application (code) security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud platform security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulnerability assessments and testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevSecOps should not be mixed up with **security as a service** (**SECaaS**).
    SECaaS can be a component of the DevSecOps practice, but the concept of SECaaS
    is mainly about shifting security as a responsibility to a service provider. It's
    a sourcing model that allows enterprises to get cybersecurity delivered from a
    service provider on a subscription base. There are good reasons for implementing
    SECaaS, and one of them is that a provider is responsible for all security updates,
    based on the latest insights. Enterprises can define service-level agreements
    for incident response times and the timely application of security practices.
    As we mentioned previously, it can be integrated into DevSecOps, but SECaaS also
    means that an enterprise has to rely upon a third party for implementing and managing
    the security baseline.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss the DevSecOps components and define the
    reference architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the reference architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we discuss the reference architecture of DevSecOps, we need to understand
    what the role of DevOps is and how security fits in. DevOps is about the software
    development life cycle. An important note that we have to make is the fact that
    developers increasingly use open source components. This makes sense since this
    provides great flexibility when developing new code.
  prefs: []
  type: TYPE_NORMAL
- en: Open source is community-driven, so developers can contribute to each other's
    code and speed up the process. Projects can and are shared in open Git and GitHub
    repositories, but also internally in enterprises. InnerSource type projects are
    a good example of this. InnerSource uses open source best practices for software
    development, within the boundaries of an organization. Typically, InnerSource
    projects make use of shielded, access restricted repositories in GitHub or alike.
  prefs: []
  type: TYPE_NORMAL
- en: Yet, there are some risks associated with open source that need to be addressed
    from a security perspective. Because of its open, community character – the strength
    of open source – there's an increased risk of introducing vulnerabilities to the
    code base. A second risk is license compliance. Licenses are not at the top of
    everyone's mind in open source, but be aware that even open source software and
    tools require licensing.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the process first. The software development life cycle is a repetitive
    process. The developer pulls source code out of a repository and a build is triggered.
    After the code has been written, the code is packaged and enabled for deployment
    to the next stage in the promotion path; that is, test, acceptance, and eventually
    production. The whole process is facilitated through CI/CD pipelines and monitored.
    As we have concluded in the previous chapters, it's essential to test the code
    throughout the whole process. We also scan the code for security and compliance.
    This should be done at every single step in the process.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we need security from the start of the DevOps process. In practice,
    this means that we start scanning for security issues from the moment the code
    is pulled from the repositories. The repositories are indeed part of the software
    development life cycle too, so these must be protected from unauthorized access.
    This calls for **role-based access control** (**RBAC**) and **Identity and Access
    Management** (**IAM**) on repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, we can create the reference architecture for DevSecOps with
    the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: Repository access with RBAC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static Application Security Testing (SAST)**: This will detect errors in
    the source code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software Composition Analysis (SCA)**: This will detect dependencies in code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic Application Security Testing (DAST)**: This will dynamically scan
    the code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These components are embedded in the DevSecOps pipeline, which we will discuss
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Composing the DevSecOps pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at a common DevOps pipeline first. The basic pipeline is shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – DevOps pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_12_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.1 – DevOps pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic steps in the pipeline are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Pull code from the repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In DevSecOps, we are embedding security into the pipeline, making security
    standards and policies an integrated part of it. Security is a layer that is applied
    to every step in the pipeline, but it does include several steps. This is shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – DevSecOps pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_12_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.2 – DevSecOps pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pipenv` for Python code and `npm` for Node.js. The commands that are used
    for the checks here are `pipenv check` and `npm audit`, respectively.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Check the `pipenv` website for scripts and tutorials on [https://pipenv.pypa.io/en/latest/](https://pipenv.pypa.io/en/latest/).
    Take a look at [https://docs.npmjs.com/cli/v6/commands/npm-audit](https://docs.npmjs.com/cli/v6/commands/npm-audit)
    for npm code checks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Static analysis**: This checks for bad coding practices, such as bad configurations.
    There are open source tools for almost every coding language. Some examples of
    tools are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '- ArchUnitNet and Puma Scan for C#'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Go vet for Go'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Checkstyle and **Open Web Application Security Project** (**OWASP**) dependency
    checks for Java'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Flow for JavaScript'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Parse for PHP'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Bandit for Python'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This list is by no means exhaustive. On [https://github.com/analysis-tools-dev/static-analysis](https://github.com/analysis-tools-dev/static-analysis),
    you will find a list of the current, most used tools.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Scanning**: Developers will likely use containers and thus container images
    to build and package their applications. These images need to be scanned for vulnerabilities
    in used binaries and libraries. This scanning is done with base lists of known
    vulnerabilities; these lists are provided by institutes such as the **National
    Institute of Standards and Technology** (**NIST**), but also software providers
    in the form of **Common Vulnerability and Exposures** (**CVE**) notifications.
    As soon as a new CVE is reported, the lists are updated, and the scanning tools
    are automatically updated and triggered to redo the scan. Clair ([https://github.com/quay/clair](https://github.com/quay/clair))
    is an open source tool that performs these scans, also for Docker images. Scanning
    involves **linting**, which we will explain in more detail when we talk about
    hardening containers in the next section.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Dynamic analysis**: In the case of web applications, developers can run an
    automated web application scan to check for bad headers or missing tokens for
    **cross-site request forgery** (**CSRF** or **XSRF**). These tokens prevent exploits
    of unauthorized commands that come from a trusted user – this can also be a function
    on a different website. These automated dynamic scans can be integrated into the
    pipeline. The OWASP Zed Attack Proxy is a free web security tool ([https://owasp.org/www-project-zap/](https://owasp.org/www-project-zap/)).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we have a security-embedded CI/CD pipeline that will automatically cover
    most commonly recognized vulnerabilities in code. There's one specific item that
    we didn't touch on in this section, though, and that's the use of containers and
    how we can secure these. We will study secured container builds in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using secured containers in the pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most developers will use containers to wrap and deploy their code, typically
    Docker containers. There are some best practices when it comes to using and securing
    containers. To keep containers consistent and secured, they should be scanned
    regularly, even when the application has reached a steady state and updates are
    done less frequently or active development has stopped. If the application still
    runs with its underlying containers hosting the different application components,
    these containers must be scanned since there's always a possibility that a dependency
    is creating a new vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applications consisting of containers are defined by Dockerfiles. **Linting**
    – analyzing the code for errors or bad syntaxes used in the code – can be used
    to do **Static Code Analyzer** (**SCA**) of the Dockerfiles and make sure that
    these files remain secure. A popular linting tool to do this is **Haskell Dockerfile
    Linter** (**Hadolint**). It''s available as a Docker image and can easily be executed
    through the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Hadolint will scan the code and if everything is all right, it will return an
    exit code of `0`. When it discovers errors or bad practices, it will present a
    **Hadolint error** (**DL**) or **SellCheck error** (**SC**) key.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: An overview of common errors is collected at [https://github.com/hadolint/hadolint#rules](https://github.com/hadolint/hadolint#rules).
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides linting, Docker recommends some best practices for keeping containers
    secure. Docker already takes care of namespaces and network stacks to provide
    isolation so that containers can''t obtain privileged access to other containers,
    unless specifically specified in the configuration. Next, there are some important
    things to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker uses the Docker daemon. This daemon requires root access, which implies
    security risks. First, only trusted users should be allowed to set controls for
    the daemon. Next, you will need to take action and limit the attack surface of
    the daemon by setting access rights to the Docker host and the guest containers,
    especially when containers can be provisioned through an API from a web server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of Docker Content Trust Signature Verification is strongly recommended.
    It's a feature that is available from the `dockerd` binary and allows you to set
    the Docker engine to only run signed images. For the signing itself, you can use
    Notary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use hardened templates for Linux hosting systems such as AppArmor and SELinux.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we follow up on all the recommendations of Docker, we will have tested,
    immutable images that we can use to deploy containers on Kubernetes, for instance.
    Kubernetes will use the trusted image repository and takes care of provisioning,
    scaling, and load balancing the containers. One of the security features of Kubernetes
    is its support for rolling updates: if the image repository is updated with patches
    or enhancements, Kubernetes will deploy the new versions and destroy the previous
    ones. With this feature, developers will always be sure that only the latest,
    hardened versions of images are used.'
  prefs: []
  type: TYPE_NORMAL
- en: Applying secrets management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Database credentials, API keys, certificates, and access tokens must be stored
    in a safe place at all times. The use of CI/CD and containers doesn''t change
    that. It''s strongly recommended to use a vault outside the repositories that
    the pipelines access for CI/CD. The best practices for secret management are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Encryption at rest and in transit. AES-256 encryption keys are recommended.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secrets, such as keys, must never be stored in Git/GitHub repositories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's advised that secrets are injected into the application via a secure string
    as an environment variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hashicorp (Terraform) offers Vault as an open source solution for securely accessing
    secrets. The service allows us to easily rotate, manage, and retrieve database
    credentials, API keys, and other secrets throughout their life cycles.
  prefs: []
  type: TYPE_NORMAL
- en: A more robust solution is provided by CyberArk. CyberArk Conjur is a platform-independent
    secrets management solution, specifically architected for securing containers
    and microservices. The solution is platform-agnostic, meaning that it can be deployed
    to any cloud or on-premises system.
  prefs: []
  type: TYPE_NORMAL
- en: Both tools integrate with native environments for key management in, for example,
    Azure and AWS, which use Azure Key Vault and AWS Secrets Manager, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Applying DevSecOps to AWS, Azure, and GCP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we discussed the DevSecOps principles and how the
    pipeline is built with embedded security. In this section, we will look at the
    best practices of applying DevSecOps to the major public cloud platforms, that
    is, AWS, Azure, and **Google Cloud Platform** (**GCP**).
  prefs: []
  type: TYPE_NORMAL
- en: Working with DevSecOps in AWS CodePipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start exploring DevSecOps in AWS, we need to understand that deployments
    in AWS should be based on the principles of the **Cloud Adoption Framework** (**CAF**).
    That framework covers specific security tasks and responsibilities, grouped into
    the four categories or principles for enterprise security that we discussed in
    [*Chapter 11*](B17492_11_ePub_RK.xhtml#_idTextAnchor131), *Understanding Security
    in DevOps*:'
  prefs: []
  type: TYPE_NORMAL
- en: Prevention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Correction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Direction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: AWS refers to these principles with different terminology for correction and
    direction. In CAF, these are subsequently called detective and responsive.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'AWS offers native solutions to provide controls for managing security postures
    in CI/CD pipelines: Amazon CloudWatch Alarms, AWS CloudTrail, Amazon CloudWatch
    Events, AWS Lambda, and AWS Config. The following diagram shows the CI/CD pipeline
    for DevSecOps using these solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Using CodePipeline and security groups in AWS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_12_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.3 – Using CodePipeline and security groups in AWS
  prefs: []
  type: TYPE_NORMAL
- en: 'AWS CodePipeline is used to orchestrate the different steps in the pipeline.
    An important artifact is the security groups: these are the *bins* where the security
    posture of all the components that are developed and deployed in the pipeline
    is defined. It contains the templates, guardrails, and policies that have to be
    applied to these components. We can define three stages in the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source or commit**: Static code analysis is performed on the code that is
    pulled from an S3 bucket. In the case of security group breaches, the build will
    be stopped.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Test**: In this stage, CloudFormation is used to create a stack that contains
    a **Virtual Private Cloud** (**VPC**) in AWS to run the tests. Next, AWS Lambda
    is used to run the code in the stack and validate the build. AWS calls this stack
    validation: Lambda functions will validate the stack against the security groups.
    If a breach is detected, a Lambda function will delete the stack and send out
    an error message. This is to prevent the stack and the code from entering the
    next stage.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Production**: After a successful stack validation, a Lambda function is triggered
    to prepare the stack for production using CloudFormation templates. This *change
    set* – translating the test stack into production with production templates –
    is then executed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: AWS provides samples for CloudFormation templates and pipelines at [https://github.com/awslabs/automating-governance-sample/tree/master/DevSecOps-Blog-Code](https://github.com/awslabs/automating-governance-sample/tree/master/DevSecOps-Blog-Code).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Examples of items that are checked against security groups can be validating
    user access and permissions, access controls to the S3 buckets, and the policies
    to create instances using, for example, EC2 compute resources. CloudWatch and
    CloudTrail are used to monitor the components, the access levels, and their usage,
    and will collect logs from events that are triggered during the execution of the
    various steps in the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Working with DevSecOps using GitHub and Azure services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Microsoft Azure uses a different approach to DevSecOps: it leverages the scan
    possibilities of GitHub and the features of **Azure Kubernetes Services** (**AKS**),
    next to Azure Pipelines, which is integrated into Azure DevOps and Azure Security
    Center for storing the security postures. The following diagram shows a high-level
    architecture for a security embedded CI/CD pipeline using GitHub and Azure services:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – DevSecOps with GitHub and Azure services'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_12_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.4 – DevSecOps with GitHub and Azure services
  prefs: []
  type: TYPE_NORMAL
- en: The numbers in the preceding diagram represent the order in which steps are
    taken. As soon as the containers are pushed to **Azure Container Registry** (**ACR**),
    they are scanned against the policies that are stored in Azure Policies. Next,
    the appropriate security keys are fetched to authenticate the containers to **Azure
    Kubernetes Service** (**AKS**). Only when all the checks have passed will the
    code be pushed to the application gateway.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at this in a bit more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source**: The solution starts with code analysis in GitHub, which involves
    using CodeQL and Dependabot to detect vulnerabilities in the source code and dependencies,
    respectively.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Test**: Once the code has been validated, it''s packaged in a Docker container
    and deployed to a test environment using Azure Dev Spaces. This orchestration
    is done through Azure Pipelines. Azure Dev Spaces will build an isolated test
    environment using AKS. This is comparable to how CloudFormation in AWS builds
    stacks.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Scan**: Containers are stored in the ACR, where they are scanned against
    the security posture. For this, Azure uses Azure Security Center, which is a huge
    library that holds all security policies for environments that are enrolled in
    Azure.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Production**: Scanned containers are pushed to a Kubernetes cluster using
    AKS. Azure Policies are used to validate the compliance of provisioned clusters
    and containers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Just like AWS, Azure uses several different solutions to provide an end-to-end
    solution that embeds security rules, policies, and postures throughout the whole
    CI/CD process. However, all these solutions start with a repository where these
    security guardrails and guidelines are stored and managed: security groups managed
    through AWS Security Hub or, in Azure, the Azure Security Center.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with DevSecOps in Google Cloud using Anthos and JFrog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GCP offers an interesting best practice solution for implementing DevSecOps
    pipelines using Anthos and JFrog. With this, it doesn't only provide a cloud-native
    pipeline, but also a solution to develop and deploy for hybrid environments, using
    GCP and on-premises systems.
  prefs: []
  type: TYPE_NORMAL
- en: This is interesting for enterprises since a lot of enterprises will not move
    their IT systems completely to public clouds. Most enterprises are expected to
    move more and more systems to the cloud, but some of their systems will remain
    on private stacks. CI/CD pipelines that cater for both cloud and on-premises solutions
    are favorable and with Kubernetes, they are relatively easy to set up.
  prefs: []
  type: TYPE_NORMAL
- en: 'The architecture is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – High-level architecture of using JFrog Artifactory and Google
    Anthos'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_12_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.5 – High-level architecture of using JFrog Artifactory and Google
    Anthos
  prefs: []
  type: TYPE_NORMAL
- en: 'GCP advocates the use of JFrog Artifcatory and JFrog Xray:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JFrog Artifactory** takes care of storing artifacts that are used when building
    applications. In this chapter, we saw that a pipeline starts by pulling code from
    source repositories. Developers need to be able to rely on the tooling that stores
    and orders artifacts – code building blocks – comprehensively and safely so that
    software delivery to the pipelines can be automated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JFrog XRay** scans the artifacts – the code building blocks – through Artifactory
    against known vulnerabilities and license compliance. XRay advocates the shift-left
    mentality by already scanning the source artifacts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The solution is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – DevSecOps in Google Cloud using JFrog XRay'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_12_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.6 – DevSecOps in Google Cloud using JFrog XRay
  prefs: []
  type: TYPE_NORMAL
- en: In this solution, JFrog XRay is the security solution that is embedded in the
    pipeline. Builds are then pushed to production, using Kubernetes in GCP, and on
    Anthos. Anthos, however, ensures a consistent layer for deploying and managing
    Kubernetes clusters across the native cloud with **Google Kubernetes Engine**
    (**GKE**) and on-premises. This solution is not only feasible with GCP, but it
    can be used on top of VMWare stacks on-premises, as well as on AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Planning for deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we've discussed the reference architecture for DevSecOps pipelines and
    the best practices for AWS, Azure, and GCP. If we have the architecture, the next
    step would be planning to deploy DevSecOps and the pipelines in our enterprise.
    That's the topic of this final section.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three major steps that enterprises will need to follow to implement
    DevSecOps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Assess the enterprise security**: Enterprises will likely already have adopted
    security policies and taken measures to protect their systems. They will also
    need to adhere to security standards and frameworks, because of governmental or
    industry regulations. Security specialists will have conducted risk assessments
    and analyzed possible threats. These specialists understand and manage the security
    controls. This is, by default, the starting point of merging security into the
    DevOps practice. A very strong recommendation is that DevOps teams should not
    start without including security policies and standards for developing and deploying
    new code, not even in pilot projects or Proof of Concepts. Security must be a
    top priority from day 1\.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Embed security into DevOps**: Security policies and standards are integrated
    into the development process. The DevOps workflows are matched against the security
    guidelines and guardrails. This includes vulnerability testing and code scanning,
    which we discussed extensively in this chapter. Without processes and tools in
    place, DevOps teams can''t start developing new code. The risk of increasing the
    attack surface of systems and, ultimately, causing immense damage to the enterprise
    is too big. Companies, both big and small, are under the constant threat of hackers
    and security threats. That brings us to step three.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Train, train, train**: DevOps and DevSecOps aren''t only about technology
    – it''s a way of working and even thinking. Maybe even better formulated: it''s
    a culture, and people need to be trained in adopting that culture. That training
    is not a one-off. Staff, developers, and operators need to be trained constantly
    and consistently. Developers, operators, and security engineers need to be fully
    committed to applying the security controls throughout their work, and that implies
    that they always need to be aware of the risks an enterprise is facing in terms
    of security breaches and hacks.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Of course, proper tooling is essential. Enterprises are recommended to include
    the following tools as a minimum:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing**: This is the crucial element in DevSecOps. The market provides
    a massive number of tools for performing tests. Examples are Chef Inspec, Haikiri,
    and Infer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alerting**: When security threats are detected, alerts need to be raised
    and sent out. Elastalert is an example of an alerting tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated remediation**: Tools such as StackStorm can help in providing remediation
    as soon as security issues are detected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visualization**: Developers and operators need to be able to see what''s
    going on in systems. Grafana and Kibana are popular tools that help in visualizing
    and sharing security information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list is by no means intended to be exhaustive. The tools mentioned are
    third-party tools that integrate well with DevOps tooling and native tooling in
    AWS, Azure, and Google Cloud. Of course, the public cloud platforms themselves
    offer extensive security tooling. Examples are Sentinel and Azure Security Center
    in Azure, Security Hub in AWS, and the Security Command Center in GCP.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits of DevSecOps should be clear after reading this chapter, but we
    will summarize this with a conclusion: with DevSecOps enterprises, we can achieve
    better collaboration between developers, operators, and security engineers and
    with that, ensure that security threats and vulnerabilities are detected at an
    early stage of development so that risks for the enterprise are minimized.'
  prefs: []
  type: TYPE_NORMAL
- en: We will elaborate on implementing security in DevOps in [*Chapter 14*](B17492_14_ePub_RK.xhtml#_idTextAnchor168),
    *Integrating DevSecOps with DevOps*, where we will also discuss DevSecOps governance.
    But first, we will learn how to work with and integrate industry security standards
    in DevOps in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we studied the different components of DevSecOps. We learned
    that DevSecOps is not only about tooling and automation, but also very much about
    culture: DevOps teams have to collaborate with the security specialists in the
    enterprise and together, they must be fully committed to embracing and embedding
    security guidelines into developing and deploying new code. Tools can certainly
    help in achieving maximum security in DevOps. A larger part of this chapter was
    about architecting the DevSecOps practice.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we discussed the best practices for DevSecOps in the major public cloud
    providers; that is, AWS, Azure, and Google Cloud. These practices typically include
    the use of Docker containers and Kubernetes as container orchestration platforms.
    We also learned how to scan code and secure the containers before deploying them
    to a production platform. Important activities include static code analysis and
    dynamic scanning.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section of this chapter, we discussed the steps an enterprise must
    take to implement the DevSecOps practice and provided some recommendations for
    the necessary tools.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprises must typically adhere to governmental and industry security standards
    and frameworks. The next chapter is all about working with these standards in
    DevSecOps.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the function of **software composition analysis** (**SCA**)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What technique is used to keep containers secure?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the native tool in AWS that's used to create stacks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The AWS, Azure, and GCP public cloud providers offer their own Kubernetes services
    to run containers. Name their respective services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Blog on using AWS CodePipeline in DevSecOps: [https://aws.amazon.com/blogs/devops/implementing-devsecops-using-aws-codepipeline/#:~:text=%20Implementing%20DevSecOps%20Using%20AWS%20CodePipeline%20%201,%206%20Create%20change%20set%3A.%20%20More%20](https://aws.amazon.com/blogs/devops/implementing-devsecops-using-aws-codepipeline/#:~:text=%20Implementing%20DevSecOps%20Using%20AWS%20CodePipeline%20%201,%206%20Create%20change%20set%3A.%20%20More%20)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Documentation on applying DevSecOps practices in Azure: [https://azure.microsoft.com/en-us/solutions/devsecops/](https://azure.microsoft.com/en-us/solutions/devsecops/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Documentation on DevSecOps CI/CD using GCP, Anthos, and JFrog: https://cloud.google.com/architecture/partners/a-hybrid-cloud-native-devsecops-pipeline-with-jfrog-artifactory-and-gke-on-prem#best_practices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Documentation on security in Docker: [https://docs.docker.com/engine/security/trust/](https://docs.docker.com/engine/security/trust/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
