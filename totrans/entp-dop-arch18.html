<html><head></head><body>
		<div id="_idContainer105">
			<h1 id="_idParaDest-177"><em class="italic"><a id="_idTextAnchor179"/>Chapter 15</em>: Implementing Zero Trust Architecture</h1>
			<p>Digital transformation is the new paradigm in enterprises. Enterprises are adopting data-driven architectures and using more and more native services in the cloud and, through this, accelerating the development of their products and services. Under this pressure, security has to keep up and be sure that environments, in a lot of cases even mission-critical environments, remain resilient. This is the domain of zero trust.</p>
			<p>This chapter explains what zero trust is and why it is important to DevOps. Zero trust assumes that everything is secured inside a corporate network and that includes the DevOps pipelines. Some of the technologies used in zero trust environments are service meshes and microservices, a topic that we will discuss in the final section of this chapter.</p>
			<p>After completing this chapter, you will have learned what zero trust means and the impact it has on DevOps. You will have learned how microservices and secure service mesh drive secure digital transformation. In the final section, we will briefly discuss some solutions that are available from cloud platforms.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Understanding zero trust principles</li>
				<li>Architecting for zero trust security</li>
				<li>Including microservices in architecture</li>
				<li>Integrating zero trust in pipelines</li>
			</ul>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor180"/>Understanding zero trust principles</h1>
			<p>Zero trust<a id="_idIndexMarker838"/> really means zero trust, for starters. The principles of zero trust have gained a lot of traction in IT security over the past few years, and for a good reason. Attacks don't just come from the outside, but also from the internal networks in enterprises. Zero trust advocates that any user, or maybe every identity, is authenticated, regardless of whether the user is inside or outside the enterprise's network. When authenticated, the user must be validated against security policies and authorized before access to applications is granted. Data access should only be granted through verified applications to which users are authenticated and authorized.</p>
			<p>Before we learn how this would work<a id="_idIndexMarker839"/> in DevSecOps, and particularly in <strong class="bold">Continuous Integration</strong>/<strong class="bold">Continuous Deployment</strong> (<strong class="bold">CI</strong>/<strong class="bold">CD</strong>) pipelines, we need to have a deeper look at the principles of zero trust.</p>
			<p>Zero trust<a id="_idIndexMarker840"/> starts with knowing who's in the enterprise's network. There's one important thing to note at this point: in the cloud, everything is an identity. It can be a real user, a person, but also a service that is triggered to execute a specific action. Also, services have certain rights: they are allowed to perform a specific action or fetch a defined dataset and are prohibited from taking other actions. Therefore, all identities, or more accurately accounts, must be known and, on top of that, it must be clear what rights they have. It means that an enterprise has to constantly monitor and validate all its accounts, along with their credentials and their rights. This must be done in real time. </p>
			<p>Now, you might think that zero trust is mainly about monitoring accounts. But there's more. Zero trust also implies that an enterprise has put measures in place to prevent authenticated users from doing more than they are authorized to. You may be thinking of setting least privileges to accounts, but you also need to consider network segmentation and restricting specific protocols on networks. Basically, you need to consider everything that contains an account so it can only perform the tasks it's authorized to do in the place where the account is authorized. This must be enforced by strong <strong class="bold">Identity and Access Management</strong> (<strong class="bold">IAM</strong>) policies, network segmentation, external<a id="_idIndexMarker841"/> and internal firewalls, gateways, and strict routing policies such as <em class="italic">deny all</em> and <em class="italic">allow only</em> whitelisted addresses.</p>
			<p>Principles that must be included in zero trust are as follows:</p>
			<ul>
				<li>Account types and credentials are always based on least privilege .</li>
				<li>Specified privileged rights and rules of the application of these rights.</li>
				<li>Defined endpoints for services and applications.</li>
				<li>Authentication protocols.</li>
				<li>Security monitoring includes intrusion detection, intrusion prevention, and anomaly detection.</li>
				<li>Operating system hardening with the latest versions and the most recent patches.</li>
				<li>Software life cycle<a id="_idIndexMarker842"/> with the most recent versions and the most recent patches.</li>
			</ul>
			<p>How does this affect DevOps? The answer to that question is: zero trust has a huge impact on DevOps and the agile way of working. DevOps is all about gaining speed in the development and deployment of application code. This requires flexibility and a great deal of responsibility for the DevOps teams. It's true that very strict security rules can hinder the speedy process of development and deployment. Yet there's no other way to protect the assets of the enterprise. DevOps teams also have a responsibility in protecting these assets.</p>
			<p>The consequence is that DevOps teams must adhere to zero trust too. Teams can only use accounts that are allowed to enter the code repositories, work with builds that are contained in a specific segment of the enterprise network in the cloud, use only approved operating systems, software, and tools, and apply security policies that are enforced by routing and firewall rules.</p>
			<p>Zero trust doesn't mean that the DevOps process is slowed down by default, though. That only happens if responsibility for applying zero trust is placed outside the teams. For example: the team has code ready for deployment, but now has to wait for a specific firewall port to be opened. That can be done quickly if the port is already whitelisted, and automated security scans have verified that the code is compliant with the firewall rules. If the approval has to go through a security department that needs to validate everything manually, then it will slow down the process heavily.</p>
			<p>Hence, we need to include zero trust in DevOps. We will discuss this in the upcoming sections.</p>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor181"/>Architecting for zero trust security</h1>
			<p>With a good understanding<a id="_idIndexMarker843"/> of the concept of zero trust, we can define architectures that apply the principles of zero trust. The following guidelines will help define the architecture. Some of these principles might be obvious, and others may lead to constraints in the way developers develop and deploy applications. But, at the end<a id="_idIndexMarker844"/> of the day, we need to be sure that the enterprise assets are secured:</p>
			<ul>
				<li>Assess and analyze all access controls. Strict policies on IAM must be in place. Least privilege must be part of those policies. This<a id="_idIndexMarker845"/> is the backbone of zero trust according to the <strong class="bold">National Institute of Standards and Technology</strong> (<strong class="bold">NIST</strong>). They defined a set of principles for zero trust architectures, all involving the way enterprises handle IAM. The key principle is to have a single source<a id="_idIndexMarker846"/> of identities. In most cases, enterprises will use <strong class="bold">Active Directory</strong> (<strong class="bold">AD</strong>) for this. In short, any user or identity must be <em class="italic">known</em> by the AD.</li>
				<li>Next, there must strong authentication. Is the identity really who it's claiming to be? <strong class="bold">Multi-factor authentication</strong> (<strong class="bold">MFA</strong>) is strongly recommended. NIST also stresses<a id="_idIndexMarker847"/> the need to verify and validate the context in which users are authorized and authenticated. For example: from which machine is a repository accessed, and is the device compliant with the enterprise's standards? A lot of developers have their own machines with their own preferred tools. This must be assessed to clarify whether this is compliant with the security policies.</li>
				<li>Specific access policies to applications must be defined and controlled. A developer working on a marketing website likely won't need access to the application that controls the supply chain of an enterprise. In that case, access to that application should be restricted. Zero trust therefore means that every application has its own set of policies: who is eligible to access it, to what level, and what are the rights in that application?</li>
				<li>Data classification and data security are the next building blocks for zero trust architecture. Data must be protected. The challenge in modern, cloud-based IT is that data can be anywhere, and it's shared across platforms, applications, and services. Enterprises need to know exactly where their data is, what type of data it is, and who or what is allowed to access it under strict conditions. Data must be identified and classified: is it, for instance, confidential, or may it be publicly accessed? Strict<a id="_idIndexMarker848"/> privacy regulations, such as the <strong class="bold">General Data Protection Regulation</strong> (<strong class="bold">GDPR</strong>) in the European Union, are guidelines for classifying data; applying these guidelines is the responsibility of the enterprise.</li>
				<li>NIST and the <strong class="bold">National Cybersecurity Center of Excellence</strong> (<strong class="bold">NCCoE</strong>) also define the <em class="italic">trusted cloud</em> as a building block. That's because of the dynamic character<a id="_idIndexMarker849"/> that clouds have by default. Now we are really at the heart of DevOps, where we go by the rule of autonomous working teams that can spin up environments the instant they need them, modify them, and even delete them. These environments will use data, but some of these environments may only be short-lived, while others will eventually be pushed to production. Cloud technology, where everything is code, facilitates this. This is a huge challenge for security, especially in keeping environments consistent with security policies. Hence, security must be embedded in DevOps. Monitoring should be in real time and enable controls to identify any breach of the security policies, even if it does mean that development is halted by that.</li>
			</ul>
			<p>In summary, we could say that zero trust<a id="_idIndexMarker850"/> is mainly about separating network segments, applications, data, and services as much as possible and only allowing access to these different components to authenticated and authorized users with least privileges. Microservices will help the architects achieve this. However, microservices do come with challenges. These challenges can be overcome with s<a id="_idTextAnchor182"/>ervice meshes.</p>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor183"/>Including microservices in architecture</h1>
			<p>DevOps<a id="_idIndexMarker851"/> is about gaining higher productivity with faster releases of code. DevOps teams can focus on specific tasks and code that is designed to only perform that task. They develop the code independently from other services to increase focus, the speed of delivery, and customer experience. Security principles are applied to these services and continuously validated by the means of automated scanning. DevOps is by default distributed architecture, in contrast with monolithic architectures where systems are designed and built as a whole. In DevOps, the architecture<a id="_idIndexMarker852"/> will be driven by microservices: an application is defined as a collection of independent services that will communicate with each other over specified protocols. The following figure shows the principle of microservices:</p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B17492_15_001.jpg" alt="Figure 15.1 – Principle of microservices&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.1 – Principle of microservices</p>
			<p>In terms of security, we can assume<a id="_idIndexMarker853"/> that microservice architectures are more secure than monolith systems. If one of the services is breached, it doesn't automatically mean that the whole application stack is breached, as long as the affected service is contained well enough. Unfortunately, it's not as simple as that. The reason for that is that microservices do need to be able to communicate with each other. The next question is: how can we enable that in a secure way? The answer is a service mesh. </p>
			<p>First, let's look at the best practices for microservices architecture:</p>
			<ul>
				<li><strong class="bold">Defense strategy</strong>: Microservices<a id="_idIndexMarker854"/> allow various defense layers or security tiers. As an example, a web portal needs to be publicly accessible, but the application and the data should be protected. A good example is mobile banking apps. The app is accessible on any smartphone: the user can download it from an app store and install it on the phone. To access the application that retrieves and presents account information, the user will need to have several things: an account with that specific bank and an account that allows them to use the mobile app. These are two separate things. Obviously, the account<a id="_idIndexMarker855"/> data is protected too, for instance, by encryption. </li>
				<li><strong class="bold">DevSecOps</strong>: As we have seen in the previous chapters, this is all about embedding security<a id="_idIndexMarker856"/> practices into DevOps. Code is scanned automatically during the entire build against policies and industry security and compliance frameworks. But it's not only during the build; post-deployment, applications and code should continuously be monitored for vulnerabilities.</li>
				<li><strong class="bold">MFA</strong>: Every application<a id="_idIndexMarker857"/> should be accessed only with MFA. A username and a password are simply not sufficient; authentication should be done using a second factor, for instance, using an authentication app on a different device than the device someone uses to log in. Even when MFA is already used to access an application, re-authentication might be desirable when specific, highly confidential data is accessed from that application. Having access to an application doesn't mean by default that a user should have access to all the data that can be retrieved by that application. Applications and data are separate tiers or layers.</li>
				<li><strong class="bold">Dependencies</strong>: In cloud environments, we will likely<a id="_idIndexMarker858"/> use cloud services such as <strong class="bold">Platform as a Service</strong> (<strong class="bold">PaaS</strong>) and <strong class="bold">Software as a Service</strong> (<strong class="bold">SaaS</strong>). We will need <strong class="bold">application programming interfaces</strong> (<strong class="bold">APIs</strong>) to enable interaction between these services. These are dependencies<a id="_idIndexMarker859"/> and they might lead to vulnerabilities<a id="_idIndexMarker860"/> and security threats<a id="_idIndexMarker861"/> if not verified and configured well. Source code must be scanned for vulnerable dependencies.</li>
			</ul>
			<p>Dependencies are probably the biggest challenge in terms of security. How do we deal with that in modern architecture, using microservices?</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor184"/>Understanding and applying a service mesh</h2>
			<p>DevOps<a id="_idIndexMarker862"/> is served well by microservices. It's the perfect<a id="_idIndexMarker863"/> way to develop and deploy new features into code without affecting other, running services. Because of the granularity of microservices, development and deployment can also be secured at a low level, resulting in a low risk of services being disrupted for the users. Using microservices means that misconfigurations or badly programmed implementations are minimized to only specific services that are being developed and deployed, also minimizing the attack surface of the entire application stack. To enable this way of working, containers play a major role. Services and features are wrapped and deployed as containers.</p>
			<p>The next challenge is to have these containerized services and features interact with each other securely. That's what a service mesh is about. To establish the interaction, developers need to configure these within the application code. They will integrate libraries that can communicate<a id="_idIndexMarker864"/> with services outside the application, such as service discovery, load balancing, and setting up internal <strong class="bold">Transport Layer Security</strong> (<strong class="bold">TLS</strong>) traffic to other services. First of all, the configuration strings and the services they call from the application code need to share a common language. But more importantly, when a service changes, it needs to be adjusted in the application code as well. This makes the application code complex.</p>
			<p>A service mesh tackles this problem by removing the complexity from the application and moving it to a service proxy. This proxy now takes care of a lot of <em class="italic">third-party services</em> that applications use to interact with other functional components. Think of traffic management including load balancing, authentication, and of course, security and monitoring. The services are now abstracted from the application code as a separate component.</p>
			<p>Developers will only have to worry about the application code since all other services are taken care of by the service proxy. With this, we have strict segregation of responsibilities.</p>
			<p>That sounds like a good solution, but how does it work in practice? We will learn that in the last section of this chapter.</p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor185"/>Integrating zero trust in pipelines</h1>
			<p>In the previous sections, we discussed the principles of zero trust architectures and how microservices<a id="_idIndexMarker865"/> can help us with zero trust. Next, we learned how we can have microservices interact by means of a secure service mesh. In this section, we will learn how we can achieve this with containerized applications and using cloud services that we target from CI/CD pipelines. Platforms such as AWS and Azure offer solutions for this, and we will discuss these solutions.</p>
			<p>First, we need to understand how we add security to a service mesh. One way to do this is with sidecars. Explained in a very simple way, a sidecar is a point in a container cluster where security postures are inserted. You could envisage it as a main road where cars are driving. A car carrying specific security policies comes from a side road and inserts itself in the line of cars on the main road. However, the point where this happens is fixed.</p>
			<p>There are various tools that offer a sidecar service mesh. Popular ones are Istio, Linkerd, and Envoy. What these tools have in common is that they put the desired functionality in a separate container that is inserted close to the application containers, just like we described with inserting cars. Since most developers that work with containers work with Kubernetes, it's important to know that the sidecar containers have to be placed in the same Kubernetes pod as the application containers. This is because the namespace of the pods needs to be the same. The application containers and the sidecars can be integrated from the CI/CD pipeline.</p>
			<p>The whole principle<a id="_idIndexMarker866"/> of a service mesh<a id="_idIndexMarker867"/> and sidecar proxies is shown in the following figure:</p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B17492_15_002.jpg" alt="Figure 15.2 – Principles of a service mesh and sidecars&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.2 – Principles of a service mesh and sidecars</p>
			<p>As noted, cloud<a id="_idIndexMarker868"/> platforms offer service meshes as well. AWS has AWS App Mesh, which allows services to interact with each other regardless of the underlying infrastructure, when it uses the Envoy sidecar proxy. Native App Mesh works with the serverless infrastructure services of AWS Fargate, the compute engine EC2, and the container<a id="_idIndexMarker869"/> orchestration services of <strong class="bold">Elastic Container Services</strong> (<strong class="bold">ECS</strong>) and <strong class="bold">Elastic Kubernetes Services</strong> (<strong class="bold">EKS</strong>). The high-level architecture<a id="_idIndexMarker870"/> of AWS App Mesh is shown in the following figure:</p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B17492_15_003.jpg" alt="Figure 15.3 – Architecture of AWS App Mesh&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.3 – Architecture of AWS App Mesh</p>
			<p>In Azure, we work with Azure Service Fabric, Microsoft's container orchestrator for deploying and managing microservices. The fully managed mesh service called Azure Service Fabric Mesh that was launched in 2018 has been retired by Microsoft from April 2021. Companies that use Azure<a id="_idIndexMarker871"/> can use Azure Container Services, <strong class="bold">Azure Kubernetes Services</strong> (<strong class="bold">AKS</strong>), or Azure Service Fabric managed<a id="_idIndexMarker872"/> clusters to create the mesh functionality. The principles of Azure Service Fabric are shown in the following figure:</p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/B17492_15_004.jpg" alt="Figure 15.4 – High-level architecture of Azure Service Fabric&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.4 – High-level architecture of Azure Service Fabric</p>
			<p>This concludes our journey through enterprise DevOps, AIOps, and DevSecOps. In this age of digital transformation, architects have a big task ahead of understanding how these methodologies help enterprises in modernizing their IT environments, becoming more agile in software development, while ensuring maximum security during development and deployment. This book is just a starting point. The proof of the pudding is in the eating, so go out and try to make it work.</p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor186"/>Summary</h1>
			<p>In this chapter, we first studied the principles of zero trust architecture, and we learned that DevOps teams need to adhere to these principles too. Zero trust starts by knowing exactly who may access code repositories, and knowing that builds can only be deployed to strictly contained network segments so that other services are not impacted. Next, we learned that microservices architecture can serve DevOps really well. They allow independent development and deployment of features in code without affecting other services.</p>
			<p>We learned that microservices are a secure type of architecture. The challenge, however, is to establish interaction between these microservices. We studied service mesh as a solution for that and learned how to integrate security postures as a containerized microservice, using the technology of sidecar proxies. We learned that sidecars can be used to insert secure services and monitoring next to our microservices.</p>
			<p>In the final section, we introduced some mesh services that are offered by the cloud providers Azure and AWS. This concluded the journey through enterprise architecture for DevOps, DevSecOps, and AIOps, all of which are becoming increasingly important to understand and to implement, eventually to successfully drive digital transformation in enterprises.</p>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor187"/>Questions</h1>
			<ol>
				<li>What basic rule do we apply with respect to the privileges of accounts in a zero trust environment?</li>
				<li>What type of service do we use to insert separate containers with security postures next to application containers?</li>
				<li>What does AWS offer to enable service mesh?</li>
			</ol>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor188"/>Further reading</h1>
			<ul>
				<li>Website of the <strong class="bold">National Cybersecurity Center of Excellence</strong> (<strong class="bold">NCCoE</strong>) on zero trust architecture: <a href="https://www.nccoe.nist.gov/projects/building-blocks/zero-trust-architecture">https://www.nccoe.nist.gov/projects/building-blocks/zero-trust-architecture</a></li>
				<li><em class="italic">Hands-On Microservices with Kubernetes</em>, by Gigi Sayfan, Packt Publishing, 2019</li>
				<li>Documentation on Microsoft Azure Service Fabric: <a href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-overview#:~:text=%20Overview%20of%20Azure%20Service%20Fabric%20%201,application%20lifecycle...%204%20Next%20steps.%20%20More%20">https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-overview#:~:text=%20Overview%20of%20Azure%20Service%20Fabric%20%201,application%20lifecycle...%204%20Next%20steps.%20%20More%20</a></li>
				<li>Blog post on AWS App Mesh: <a href="https://aws.amazon.com/app-mesh/?aws-app-mesh-blogs.sort-by=item.additionalFields.createdDate&amp;aws-app-mesh-blogs.sort-order=desc&amp;whats-new-cards.sort-by=item.additionalFields.postDateTime&amp;whats-new-cards.sort-order=desc">https://aws.amazon.com/app-mesh/?aws-app-mesh-blogs.sort-by=item.additionalFields.createdDate&amp;aws-app-mesh-blogs.sort-order=desc&amp;whats-new-cards.sort-by=item.additionalFields.postDateTime&amp;whats-new-cards.sort-order=desc</a></li>
			</ul>
		</div>
	</body></html>