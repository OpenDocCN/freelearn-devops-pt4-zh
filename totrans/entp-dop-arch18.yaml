- en: '*Chapter 15*: Implementing Zero Trust Architecture'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Digital transformation is the new paradigm in enterprises. Enterprises are adopting
    data-driven architectures and using more and more native services in the cloud
    and, through this, accelerating the development of their products and services.
    Under this pressure, security has to keep up and be sure that environments, in
    a lot of cases even mission-critical environments, remain resilient. This is the
    domain of zero trust.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explains what zero trust is and why it is important to DevOps.
    Zero trust assumes that everything is secured inside a corporate network and that
    includes the DevOps pipelines. Some of the technologies used in zero trust environments
    are service meshes and microservices, a topic that we will discuss in the final
    section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: After completing this chapter, you will have learned what zero trust means and
    the impact it has on DevOps. You will have learned how microservices and secure
    service mesh drive secure digital transformation. In the final section, we will
    briefly discuss some solutions that are available from cloud platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding zero trust principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecting for zero trust security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including microservices in architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating zero trust in pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding zero trust principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Zero trust really means zero trust, for starters. The principles of zero trust
    have gained a lot of traction in IT security over the past few years, and for
    a good reason. Attacks don't just come from the outside, but also from the internal
    networks in enterprises. Zero trust advocates that any user, or maybe every identity,
    is authenticated, regardless of whether the user is inside or outside the enterprise's
    network. When authenticated, the user must be validated against security policies
    and authorized before access to applications is granted. Data access should only
    be granted through verified applications to which users are authenticated and
    authorized.
  prefs: []
  type: TYPE_NORMAL
- en: Before we learn how this would work in DevSecOps, and particularly in **Continuous
    Integration**/**Continuous Deployment** (**CI**/**CD**) pipelines, we need to
    have a deeper look at the principles of zero trust.
  prefs: []
  type: TYPE_NORMAL
- en: 'Zero trust starts with knowing who''s in the enterprise''s network. There''s
    one important thing to note at this point: in the cloud, everything is an identity.
    It can be a real user, a person, but also a service that is triggered to execute
    a specific action. Also, services have certain rights: they are allowed to perform
    a specific action or fetch a defined dataset and are prohibited from taking other
    actions. Therefore, all identities, or more accurately accounts, must be known
    and, on top of that, it must be clear what rights they have. It means that an
    enterprise has to constantly monitor and validate all its accounts, along with
    their credentials and their rights. This must be done in real time.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you might think that zero trust is mainly about monitoring accounts. But
    there's more. Zero trust also implies that an enterprise has put measures in place
    to prevent authenticated users from doing more than they are authorized to. You
    may be thinking of setting least privileges to accounts, but you also need to
    consider network segmentation and restricting specific protocols on networks.
    Basically, you need to consider everything that contains an account so it can
    only perform the tasks it's authorized to do in the place where the account is
    authorized. This must be enforced by strong **Identity and Access Management**
    (**IAM**) policies, network segmentation, external and internal firewalls, gateways,
    and strict routing policies such as *deny all* and *allow only* whitelisted addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Principles that must be included in zero trust are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Account types and credentials are always based on least privilege .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specified privileged rights and rules of the application of these rights.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defined endpoints for services and applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication protocols.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security monitoring includes intrusion detection, intrusion prevention, and
    anomaly detection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating system hardening with the latest versions and the most recent patches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software life cycle with the most recent versions and the most recent patches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How does this affect DevOps? The answer to that question is: zero trust has
    a huge impact on DevOps and the agile way of working. DevOps is all about gaining
    speed in the development and deployment of application code. This requires flexibility
    and a great deal of responsibility for the DevOps teams. It''s true that very
    strict security rules can hinder the speedy process of development and deployment.
    Yet there''s no other way to protect the assets of the enterprise. DevOps teams
    also have a responsibility in protecting these assets.'
  prefs: []
  type: TYPE_NORMAL
- en: The consequence is that DevOps teams must adhere to zero trust too. Teams can
    only use accounts that are allowed to enter the code repositories, work with builds
    that are contained in a specific segment of the enterprise network in the cloud,
    use only approved operating systems, software, and tools, and apply security policies
    that are enforced by routing and firewall rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Zero trust doesn''t mean that the DevOps process is slowed down by default,
    though. That only happens if responsibility for applying zero trust is placed
    outside the teams. For example: the team has code ready for deployment, but now
    has to wait for a specific firewall port to be opened. That can be done quickly
    if the port is already whitelisted, and automated security scans have verified
    that the code is compliant with the firewall rules. If the approval has to go
    through a security department that needs to validate everything manually, then
    it will slow down the process heavily.'
  prefs: []
  type: TYPE_NORMAL
- en: Hence, we need to include zero trust in DevOps. We will discuss this in the
    upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Architecting for zero trust security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With a good understanding of the concept of zero trust, we can define architectures
    that apply the principles of zero trust. The following guidelines will help define
    the architecture. Some of these principles might be obvious, and others may lead
    to constraints in the way developers develop and deploy applications. But, at
    the end of the day, we need to be sure that the enterprise assets are secured:'
  prefs: []
  type: TYPE_NORMAL
- en: Assess and analyze all access controls. Strict policies on IAM must be in place.
    Least privilege must be part of those policies. This is the backbone of zero trust
    according to the **National Institute of Standards and Technology** (**NIST**).
    They defined a set of principles for zero trust architectures, all involving the
    way enterprises handle IAM. The key principle is to have a single source of identities.
    In most cases, enterprises will use **Active Directory** (**AD**) for this. In
    short, any user or identity must be *known* by the AD.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, there must strong authentication. Is the identity really who it''s claiming
    to be? **Multi-factor authentication** (**MFA**) is strongly recommended. NIST
    also stresses the need to verify and validate the context in which users are authorized
    and authenticated. For example: from which machine is a repository accessed, and
    is the device compliant with the enterprise''s standards? A lot of developers
    have their own machines with their own preferred tools. This must be assessed
    to clarify whether this is compliant with the security policies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Specific access policies to applications must be defined and controlled. A
    developer working on a marketing website likely won''t need access to the application
    that controls the supply chain of an enterprise. In that case, access to that
    application should be restricted. Zero trust therefore means that every application
    has its own set of policies: who is eligible to access it, to what level, and
    what are the rights in that application?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data classification and data security are the next building blocks for zero
    trust architecture. Data must be protected. The challenge in modern, cloud-based
    IT is that data can be anywhere, and it''s shared across platforms, applications,
    and services. Enterprises need to know exactly where their data is, what type
    of data it is, and who or what is allowed to access it under strict conditions.
    Data must be identified and classified: is it, for instance, confidential, or
    may it be publicly accessed? Strict privacy regulations, such as the **General
    Data Protection Regulation** (**GDPR**) in the European Union, are guidelines
    for classifying data; applying these guidelines is the responsibility of the enterprise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NIST and the **National Cybersecurity Center of Excellence** (**NCCoE**) also
    define the *trusted cloud* as a building block. That's because of the dynamic
    character that clouds have by default. Now we are really at the heart of DevOps,
    where we go by the rule of autonomous working teams that can spin up environments
    the instant they need them, modify them, and even delete them. These environments
    will use data, but some of these environments may only be short-lived, while others
    will eventually be pushed to production. Cloud technology, where everything is
    code, facilitates this. This is a huge challenge for security, especially in keeping
    environments consistent with security policies. Hence, security must be embedded
    in DevOps. Monitoring should be in real time and enable controls to identify any
    breach of the security policies, even if it does mean that development is halted
    by that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, we could say that zero trust is mainly about separating network
    segments, applications, data, and services as much as possible and only allowing
    access to these different components to authenticated and authorized users with
    least privileges. Microservices will help the architects achieve this. However,
    microservices do come with challenges. These challenges can be overcome with service
    meshes.
  prefs: []
  type: TYPE_NORMAL
- en: Including microservices in architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'DevOps is about gaining higher productivity with faster releases of code. DevOps
    teams can focus on specific tasks and code that is designed to only perform that
    task. They develop the code independently from other services to increase focus,
    the speed of delivery, and customer experience. Security principles are applied
    to these services and continuously validated by the means of automated scanning.
    DevOps is by default distributed architecture, in contrast with monolithic architectures
    where systems are designed and built as a whole. In DevOps, the architecture will
    be driven by microservices: an application is defined as a collection of independent
    services that will communicate with each other over specified protocols. The following
    figure shows the principle of microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1 – Principle of microservices'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_15_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.1 – Principle of microservices
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of security, we can assume that microservice architectures are more
    secure than monolith systems. If one of the services is breached, it doesn''t
    automatically mean that the whole application stack is breached, as long as the
    affected service is contained well enough. Unfortunately, it''s not as simple
    as that. The reason for that is that microservices do need to be able to communicate
    with each other. The next question is: how can we enable that in a secure way?
    The answer is a service mesh.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at the best practices for microservices architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Defense strategy**: Microservices allow various defense layers or security
    tiers. As an example, a web portal needs to be publicly accessible, but the application
    and the data should be protected. A good example is mobile banking apps. The app
    is accessible on any smartphone: the user can download it from an app store and
    install it on the phone. To access the application that retrieves and presents
    account information, the user will need to have several things: an account with
    that specific bank and an account that allows them to use the mobile app. These
    are two separate things. Obviously, the account data is protected too, for instance,
    by encryption.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DevSecOps**: As we have seen in the previous chapters, this is all about
    embedding security practices into DevOps. Code is scanned automatically during
    the entire build against policies and industry security and compliance frameworks.
    But it''s not only during the build; post-deployment, applications and code should
    continuously be monitored for vulnerabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MFA**: Every application should be accessed only with MFA. A username and
    a password are simply not sufficient; authentication should be done using a second
    factor, for instance, using an authentication app on a different device than the
    device someone uses to log in. Even when MFA is already used to access an application,
    re-authentication might be desirable when specific, highly confidential data is
    accessed from that application. Having access to an application doesn''t mean
    by default that a user should have access to all the data that can be retrieved
    by that application. Applications and data are separate tiers or layers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependencies**: In cloud environments, we will likely use cloud services
    such as **Platform as a Service** (**PaaS**) and **Software as a Service** (**SaaS**).
    We will need **application programming interfaces** (**APIs**) to enable interaction
    between these services. These are dependencies and they might lead to vulnerabilities
    and security threats if not verified and configured well. Source code must be
    scanned for vulnerable dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies are probably the biggest challenge in terms of security. How do
    we deal with that in modern architecture, using microservices?
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and applying a service mesh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DevOps is served well by microservices. It's the perfect way to develop and
    deploy new features into code without affecting other, running services. Because
    of the granularity of microservices, development and deployment can also be secured
    at a low level, resulting in a low risk of services being disrupted for the users.
    Using microservices means that misconfigurations or badly programmed implementations
    are minimized to only specific services that are being developed and deployed,
    also minimizing the attack surface of the entire application stack. To enable
    this way of working, containers play a major role. Services and features are wrapped
    and deployed as containers.
  prefs: []
  type: TYPE_NORMAL
- en: The next challenge is to have these containerized services and features interact
    with each other securely. That's what a service mesh is about. To establish the
    interaction, developers need to configure these within the application code. They
    will integrate libraries that can communicate with services outside the application,
    such as service discovery, load balancing, and setting up internal **Transport
    Layer Security** (**TLS**) traffic to other services. First of all, the configuration
    strings and the services they call from the application code need to share a common
    language. But more importantly, when a service changes, it needs to be adjusted
    in the application code as well. This makes the application code complex.
  prefs: []
  type: TYPE_NORMAL
- en: A service mesh tackles this problem by removing the complexity from the application
    and moving it to a service proxy. This proxy now takes care of a lot of *third-party
    services* that applications use to interact with other functional components.
    Think of traffic management including load balancing, authentication, and of course,
    security and monitoring. The services are now abstracted from the application
    code as a separate component.
  prefs: []
  type: TYPE_NORMAL
- en: Developers will only have to worry about the application code since all other
    services are taken care of by the service proxy. With this, we have strict segregation
    of responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: That sounds like a good solution, but how does it work in practice? We will
    learn that in the last section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating zero trust in pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we discussed the principles of zero trust architectures
    and how microservices can help us with zero trust. Next, we learned how we can
    have microservices interact by means of a secure service mesh. In this section,
    we will learn how we can achieve this with containerized applications and using
    cloud services that we target from CI/CD pipelines. Platforms such as AWS and
    Azure offer solutions for this, and we will discuss these solutions.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to understand how we add security to a service mesh. One way
    to do this is with sidecars. Explained in a very simple way, a sidecar is a point
    in a container cluster where security postures are inserted. You could envisage
    it as a main road where cars are driving. A car carrying specific security policies
    comes from a side road and inserts itself in the line of cars on the main road.
    However, the point where this happens is fixed.
  prefs: []
  type: TYPE_NORMAL
- en: There are various tools that offer a sidecar service mesh. Popular ones are
    Istio, Linkerd, and Envoy. What these tools have in common is that they put the
    desired functionality in a separate container that is inserted close to the application
    containers, just like we described with inserting cars. Since most developers
    that work with containers work with Kubernetes, it's important to know that the
    sidecar containers have to be placed in the same Kubernetes pod as the application
    containers. This is because the namespace of the pods needs to be the same. The
    application containers and the sidecars can be integrated from the CI/CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole principle of a service mesh and sidecar proxies is shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2 – Principles of a service mesh and sidecars'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_15_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.2 – Principles of a service mesh and sidecars
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted, cloud platforms offer service meshes as well. AWS has AWS App Mesh,
    which allows services to interact with each other regardless of the underlying
    infrastructure, when it uses the Envoy sidecar proxy. Native App Mesh works with
    the serverless infrastructure services of AWS Fargate, the compute engine EC2,
    and the container orchestration services of **Elastic Container Services** (**ECS**)
    and **Elastic Kubernetes Services** (**EKS**). The high-level architecture of
    AWS App Mesh is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3 – Architecture of AWS App Mesh'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_15_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.3 – Architecture of AWS App Mesh
  prefs: []
  type: TYPE_NORMAL
- en: 'In Azure, we work with Azure Service Fabric, Microsoft''s container orchestrator
    for deploying and managing microservices. The fully managed mesh service called
    Azure Service Fabric Mesh that was launched in 2018 has been retired by Microsoft
    from April 2021\. Companies that use Azure can use Azure Container Services, **Azure
    Kubernetes Services** (**AKS**), or Azure Service Fabric managed clusters to create
    the mesh functionality. The principles of Azure Service Fabric are shown in the
    following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4 – High-level architecture of Azure Service Fabric'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17492_15_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.4 – High-level architecture of Azure Service Fabric
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our journey through enterprise DevOps, AIOps, and DevSecOps.
    In this age of digital transformation, architects have a big task ahead of understanding
    how these methodologies help enterprises in modernizing their IT environments,
    becoming more agile in software development, while ensuring maximum security during
    development and deployment. This book is just a starting point. The proof of the
    pudding is in the eating, so go out and try to make it work.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we first studied the principles of zero trust architecture,
    and we learned that DevOps teams need to adhere to these principles too. Zero
    trust starts by knowing exactly who may access code repositories, and knowing
    that builds can only be deployed to strictly contained network segments so that
    other services are not impacted. Next, we learned that microservices architecture
    can serve DevOps really well. They allow independent development and deployment
    of features in code without affecting other services.
  prefs: []
  type: TYPE_NORMAL
- en: We learned that microservices are a secure type of architecture. The challenge,
    however, is to establish interaction between these microservices. We studied service
    mesh as a solution for that and learned how to integrate security postures as
    a containerized microservice, using the technology of sidecar proxies. We learned
    that sidecars can be used to insert secure services and monitoring next to our
    microservices.
  prefs: []
  type: TYPE_NORMAL
- en: In the final section, we introduced some mesh services that are offered by the
    cloud providers Azure and AWS. This concluded the journey through enterprise architecture
    for DevOps, DevSecOps, and AIOps, all of which are becoming increasingly important
    to understand and to implement, eventually to successfully drive digital transformation
    in enterprises.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What basic rule do we apply with respect to the privileges of accounts in a
    zero trust environment?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type of service do we use to insert separate containers with security postures
    next to application containers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does AWS offer to enable service mesh?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Website of the **National Cybersecurity Center of Excellence** (**NCCoE**)
    on zero trust architecture: [https://www.nccoe.nist.gov/projects/building-blocks/zero-trust-architecture](https://www.nccoe.nist.gov/projects/building-blocks/zero-trust-architecture)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hands-On Microservices with Kubernetes*, by Gigi Sayfan, Packt Publishing,
    2019'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Documentation on Microsoft Azure Service Fabric: [https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-overview#:~:text=%20Overview%20of%20Azure%20Service%20Fabric%20%201,application%20lifecycle...%204%20Next%20steps.%20%20More%20](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-overview#:~:text=%20Overview%20of%20Azure%20Service%20Fabric%20%201,application%20lifecycle...%204%20Next%20steps.%20%20More%20)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Blog post on AWS App Mesh: [https://aws.amazon.com/app-mesh/?aws-app-mesh-blogs.sort-by=item.additionalFields.createdDate&aws-app-mesh-blogs.sort-order=desc&whats-new-cards.sort-by=item.additionalFields.postDateTime&whats-new-cards.sort-order=desc](https://aws.amazon.com/app-mesh/?aws-app-mesh-blogs.sort-by=item.additionalFields.createdDate&aws-app-mesh-blogs.sort-order=desc&whats-new-cards.sort-by=item.additionalFields.postDateTime&whats-new-cards.sort-order=desc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
