<html><head></head><body>
		<div id="_idContainer018">
			<h1 id="_idParaDest-15"><em class="italic"><a id="_idTextAnchor014"/>Chapter 1</em>: DevOps, SRE, and Google Cloud Services for CI/CD</h1>
			<p><strong class="bold">DevOps</strong> is a mindset change­ that tries to balance release velocity with system reliability. It aims to increase an organization's ability to continuously deliver reliable applications and services at a high velocity when compared to traditional software development processes.</p>
			<p>A common misconception about DevOps is that it is a technology. Instead, DevOps is a set of supporting practices (such as, build, test, and deployment) that combines software development and IT operations. These practices establish a culture that breaks down the metaphorical wall between developers (who aim to push new features to production) and system administrators or operators (who aim to keep the code running in production).</p>
			<p><strong class="bold">Site Reliability Engineering</strong> (<strong class="bold">SRE</strong>) is Google's approach to align incentives between development and operations that are key to building and maintaining reliable engineering systems. SRE is a prescriptive way to implement DevOps practices and principles. Through these practices, the aim is to increase overall observability and reduce the level of incidents. The introduction of a <strong class="bold">Continuous Integration/Continuous Delivery</strong> (<strong class="bold">CI/CD</strong>) pipeline enables a robust feedback loop in support of key SRE definitions such as toil, observability, and incident management.</p>
			<p><strong class="bold">CI/CD</strong> is a key DevOps practice that helps to achieve this mindset change. CI/CD requires a strong emphasis on automation to <em class="italic">build reliable software faster</em> (in terms of delivering/deploying to production). Software delivery of this type requires agility, which is often achieved by breaking down existing components.</p>
			<p>A <strong class="bold">cloud-native development</strong> paradigm is one where complex systems are decomposed into multiple services (such as microservices architecture). Each service can be independently tested and deployed into an isolated runtime. <strong class="bold">Google Cloud Platform</strong> (<strong class="bold">GCP</strong>) has well-defined services to implement cloud-native development and apply SRE concepts to achieve the goal of <em class="italic">building reliable software faster</em>.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>DevOps 101 – evolution and life cycle</li>
				<li>SRE 101 – evolution; technical and cultural practices</li>
				<li>GCP's cloud-native approach to implementing DevOps</li>
			</ul>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Understanding DevOps, its evolution, and life cycle</h1>
			<p>This section focuses on the evolution of DevOps and lists phases or critical practices that form the DevOps life cycle.</p>
			<h2 id="_idParaDest-17"><a id="_idTextAnchor016"/>Revisiting DevOps evolution</h2>
			<p>Let's take a step back and think <a id="_idIndexMarker000"/>about how DevOps has evolved. <strong class="bold">Agile software development methodology</strong> refers to a <a id="_idIndexMarker001"/>set of practices based on iterative development where requirements and solutions are built through collaboration between cross-functional teams and end users. DevOps can be perceived as a logical extension of Agile. Some might even consider DevOps as an offspring of Agile. This is because DevOps starts where Agile logically stops. Let's explore what this means in detail.</p>
			<p>Agile was <a id="_idIndexMarker002"/>introduced as a holistic approach for end-to-end software delivery. Its core principles are defined in the <a id="_idIndexMarker003"/>Agile Manifesto (<a href="https://agilemanifesto.org/">https://agilemanifesto.org/</a>), with specific emphasis on interaction with processes and tools, improving collaboration, incremental and iterative development, and flexibility in response to changes to a fixed plan. The initial Agile teams primarily had developers, but it quickly extended to product management, customers, and quality assurance. If we factor in the impact of the increased focus on iterative testing and user acceptance testing, the result is a new capacity to deliver software faster to production.</p>
			<p>However, Agile methodology creates a new problem that has resulted in a need for a new evolution. Once software is delivered to production, the operations team are primarily focused on system stability and upkeep. At the same time, development teams continue to add new features to a delivered software to meet customers' dynamic needs and to keep up with the competition.</p>
			<p>Operators were always cautious for the fear of introducing issues. Developers always insist on pushing changes since these were tested in their local setup, and developers always thought that it is the responsibility of the operators to ensure that the changes work in production. But from an operator's standpoint, they have little or no understanding of the code base. Similarly, developers have little or no understanding of the operational practices. So essentially, developers were focused on shipping new features faster and operators were focused on stability. This forced developers to move slower in pushing the new features out to production. This misalignment often caused tensions within an organization.</p>
			<p>Patrick Debois, an IT consultant <a id="_idIndexMarker004"/>who was working on a large data center migration project in 2007, experienced similar challenges when trying to collaborate with developers and operators. He coined the term DevOps and later continued this movement with Andrew Shafer. They considered DevOps as an extension of Agile. In fact, when it came to <a id="_idIndexMarker005"/>naming their first Google group for DevOps, they called it <strong class="bold">Agile System Administration</strong>. </p>
			<p>The DevOps movement enabled better communication between software development and IT operations and effectively led to improved software with continuity being the core theme across operating a stable environment, consistent delivery, improved collaboration, and enhanced operational practices with a focus on innovation. This led to the evolution of the DevOps life cycle, which is detailed in the upcoming sub-section. </p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>DevOps life cycle</h2>
			<p>DevOps constitutes phases or practices <a id="_idIndexMarker006"/>that in their entirety form the DevOps life cycle. In this section, we'll look at these phases in detail, as shown in the following diagram:</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/B15587_01_01.jpg" alt="Figure 1.1 – Phases of the DevOps life cycle&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – Phases of the DevOps life cycle</p>
			<p>There are six primary phases in a <a id="_idIndexMarker007"/>DevOps life cycle. They are as follows:</p>
			<ul>
				<li>Plan and build</li>
				<li>Continuous integration</li>
				<li>Continuous delivery</li>
				<li>Continuous deployment</li>
				<li>Continuous monitoring and operations</li>
				<li>Continuous feedback</li>
			</ul>
			<p>The keyword here is <strong class="bold">continuous</strong>. If code is developed continuously, it will be followed with a need to continuously test, provide feedback, deploy, monitor, and operate. These phases will be introduced in the following sections.</p>
			<h3>Phase 1 – plan and build</h3>
			<p>In the <strong class="bold">planning</strong> phase, the core <a id="_idIndexMarker008"/>focus is to understand the vision and convert it into a <a id="_idIndexMarker009"/>detailed plan. The plan can be split into phases, otherwise <a id="_idIndexMarker010"/>known as <strong class="bold">epics</strong> (in Agile terminology). Each phase or epic can be scoped to achieve a specific set of functionalities, which could be further groomed as one or multiple user stories. This requires a lot of communication and collaboration between various stakeholders.</p>
			<p>In the <strong class="bold">build</strong> phase, code is <a id="_idIndexMarker011"/>written in the language of choice and appropriate build artifacts are created. Code is maintained in a source code repository such as GitHub, Bitbucket, and others.</p>
			<h3>Phase 2 – continuous integration</h3>
			<p><strong class="bold">CI</strong> is a software <a id="_idIndexMarker012"/>development practice where <a id="_idIndexMarker013"/>developers frequently integrate their code changes to the main branch of a shared repository. This is done, preferably, several times in a day, leading to several integrations.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout"><strong class="bold">Code change</strong> is considered the <a id="_idIndexMarker014"/>fundamental unit of software development. Since development is incremental in nature, developers keep changing their code.</p>
			<p>Ideally, each integration is <a id="_idIndexMarker015"/>triggered by an automated build that also initiates automated unit tests, to detect any issues as quickly as possible. This <a id="_idIndexMarker016"/>avoids <em class="italic">integration hell</em>, or in other words, ensures that the application is not broken by introducing a code change or delta into the main branch.</p>
			<h3>Phase 3 – continuous delivery</h3>
			<p><strong class="bold">Continuous delivery</strong> is a software development <a id="_idIndexMarker017"/>practice to build <a id="_idIndexMarker018"/>software such that a set of code changes can be delivered or released to production at any time. It can be considered an extension of CI and its core focus is on automating the release process to enable hands-free or single-click deployments.</p>
			<p>The core purpose is to ensure that the code base is releasable and there is no regression break. It's possible that the newly added code might not necessarily work. The frequency to deliver code to production is very specific to the organization and could be daily, weekly, bi-weekly, and so on.</p>
			<h3>Phase 4 – continuous deployment</h3>
			<p><strong class="bold">Continuous deployment</strong> is a software development <a id="_idIndexMarker019"/>practice where the core focus is to release automated deployments to production without the <a id="_idIndexMarker020"/>user's intervention. It aims to minimize the time elapsed between developers writing new line(s) of code and this new code being used by live users in production.</p>
			<p>At its core, continuous deployment incorporates robust testing frameworks and encourages code deployment in a testing/staging environment post the continuous delivery phase. Automated tests can be run as part of the pipeline in the test/stage environment. In the event of no issues, the code can be deployed to production in an automated fashion. This removes the need for a formal release day and establishes a feedback loop to ensure that added features are useful to the end users.</p>
			<h3>Phase 5 – continuous monitoring and operation</h3>
			<p><strong class="bold">Continuous monitoring</strong> is a practice that <a id="_idIndexMarker021"/>uses analytical <a id="_idIndexMarker022"/>information to identify issues with the application or its underlying <a id="_idIndexMarker023"/>infrastructure. Monitoring can be classified into two <a id="_idIndexMarker024"/>types: <strong class="bold">server monitoring</strong> and <strong class="bold">application monitoring</strong>.</p>
			<p><strong class="bold">Continuous operations</strong> is a practice where <a id="_idIndexMarker025"/>the core focus is to <a id="_idIndexMarker026"/>mitigate, reduce, or eliminate the impact of planned downtime, such as scheduled maintenance, or in the case of unplanned downtime, such as an incident.</p>
			<h3>Phase 6 – continuous feedback</h3>
			<p><strong class="bold">Continuous feedback</strong> is a practice where the <a id="_idIndexMarker027"/>core focus is to collect feedback that improves the applica/service. A common misconception is that <a id="_idIndexMarker028"/>continuous feedback happens only as the last phase of the DevOps cycle.</p>
			<p>Feedback loops are present at every phase of the DevOps pipeline such that feedback is conveyed if a build fails due to a specific code check-in, a unit/integration test or functional test fails in a testing deployment, or an issue is found by the customer in production.</p>
			<p><strong class="bold">GitOps</strong> is one of the <a id="_idIndexMarker029"/>approaches to implement continuous feedback where a version control system has the capabilities to manage operational workflows, such as Kubernetes deployment. A failure at any point in the workflow can be tracked directly in the source control and that creates a direct feedback loop.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Key pillars of DevOps</h2>
			<p>DevOps can be <a id="_idIndexMarker030"/>categorized into five key pillars or areas:</p>
			<ul>
				<li><strong class="bold">Reduce organizational silos</strong>: Bridge the gap between teams by encouraging them to work together toward a shared company vision. This reduces friction between teams and increases communication and collaboration.</li>
				<li><strong class="bold">Accept failure as normal</strong>: In the <em class="italic">continuous</em> aspect of DevOps, failure is considered an opportunity to continuously improve. Systems/services are bound to fail, especially when more features are added to improve the service. Learning from failures mitigates reoccurrence. Fostering failure as the normal culture will make team members more forthcoming.</li>
				<li><strong class="bold">Implement gradual change</strong>: Implementing gradual change falls in line with the continuous aspect of DevOps. Small, gradual changes are not only easier to review but in the event of an incident in production, it is easier to roll back and reduce the impact of the incident by going back to a last known working state.</li>
				<li><strong class="bold">Leverage tooling and automation</strong>: Automation is key to implement the continuous aspect of CI/CD pipelines, which are critical to DevOps. It is important to identify manual work and automate it in a way that eventually increases speed and adds consistency to everyday processes.</li>
				<li><strong class="bold">Measure everything</strong>: Measuring is a <a id="_idIndexMarker031"/>critical gauge for success. Monitoring is one way to measure and observe that helps to get important feedback to continuously improve the system.</li>
			</ul>
			<p>This completes our introduction to DevOps where we discussed its evolution, life cycle phases, and key pillars. At the end of the day, DevOps is a set of practices. The next section introduces site reliability engineering, or SRE, which is essentially Google's practical approach to implementing DevOps key pillars.</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>SRE's evolution; technical and cultural practices</h1>
			<p>This section tracks back the evolution of SRE, defines SRE, discusses how SRE relates to DevOps by elaborating DevOps key pillars, details critical jargon, and introduces SRE's cultural practices.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>The evolution of SRE</h2>
			<p>In the early 2000s, Google <a id="_idIndexMarker032"/>was building massive, complex systems to run their search and other critical services. Their main challenge was to <em class="italic">reliably</em> run their services. At the time, many companies historically had system administrators deploying software components as a service. The use of system administrators, otherwise known as the <em class="italic">sysadmin</em> approach, essentially focused on running the service by responding to events or updates as they occur. This means that if the service grew in traffic or complexity, there would be a corresponding increase in events and updates.</p>
			<p>The sysadmin approach has its pitfalls, and these are represented by two categories of cost:</p>
			<ul>
				<li><strong class="bold">Direct costs</strong>: Running a <a id="_idIndexMarker033"/>service with a team of system administrators included manual intervention. Manual intervention at scale is a major downside to change management and event handling. However, this manual approach was adopted by multiple organizations because there wasn't a recognized alternative</li>
				<li><strong class="bold">Indirect costs</strong>: System <a id="_idIndexMarker034"/>administrators and developers widely differed in terms of their skills, the vocabulary used to describe situations, and incentives. Development teams always want to launch new features and their incentive is to drive adoption. System administrators or ops teams want to ensure that the service is running reliably and often with a thought process of <em class="italic">don't change something that is working</em>.</li>
			</ul>
			<p>Google did not want to pursue a <a id="_idIndexMarker035"/>manual approach because at their scale and traffic, any increase in demand would make it impractical to scale. The desire to regularly push more features to their users would ultimately cause conflict between developers and operators. Google wanted to reduce this conflict and remove the confusion with respect to desired outcomes. With this knowledge, Google considered an alternative approach. This new approach is what became known as SRE.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Understanding SRE</h2>
			<p class="author-quote">SRE is what happens when you ask a software engineer to design an operations team.</p>
			<p>(<em class="italic">Betsy Beyer</em>, <em class="italic">Chris Jones</em>, <em class="italic">Jennifer Petoff</em>, &amp; <em class="italic">Niall Murphy</em>, <em class="italic">Site Reliability Engineering</em>, <em class="italic">O'REILLY</em>)</p>
			<p>The preceding is a quote <a id="_idIndexMarker036"/>from Ben Treynor Sloss, who in 2003 started the first SRE team at Google with seven software engineers. Ben himself was a software engineer up until that point, and joined Google as the site reliability Tsar in 2003, led the development and operations of Google's production software infrastructure, network, and user-facing services, and is currently the VP of engineering at Google. At that point in 2003, neither Ben nor Google had any formal definition for SRE.</p>
			<p>SRE is a software engineering approach to IT operations. SRE is an intrinsic part of Google's culture. It's the key to running their massively complex systems and services at scale. At its core, the goal of SRE is to end the age-old battle between development and operations. This section introduces SRE's thought process and the upcoming chapters on SRE give deeper insights into how SRE achieves its goal.</p>
			<p>A primary difference <a id="_idIndexMarker037"/>in Google's approach to building the SRE practice or team is the composition of the SRE team. A typical SRE team consists of 50-60% Google software engineers. The other 40-50% are personnel who have software engineering skills but in addition, also have skills related to UNIX/Linux system internals and networking expertise. The team composition forced two behavioral patterns that propelled the team forward:</p>
			<ul>
				<li>Team members were quickly bored of performing tasks or responding to events manually.</li>
				<li>Team members had the capability to write software and provide an engineering solution to avoid repetitive manual work even if the solution is complicated.</li>
			</ul>
			<p>In simple terminology, SRE practices evolved when a team of software engineers ran a service reliably in production and automated systems by using engineering practices. This raises some critical questions. How is SRE different from DevOps? Which is better? This will be covered in the upcoming sub-sections.</p>
			<p>From Google's viewpoint, DevOps is a philosophy rather than a development methodology. It aims to close the gap between software development and software operations. DevOps' key pillars clarify what needs to be done to achieve collaboration, cohesiveness, flexibility, reliability, and consistency.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>SRE's approach toward DevOps' key pillars</h2>
			<p>DevOps doesn't put <a id="_idIndexMarker038"/>forward a clear path or mechanism <a id="_idIndexMarker039"/>for how it needs to be done. Google's SRE approach is a concrete or prescriptive way to solve problems that the DevOps philosophy addresses. Google describes the relationship between SRE and DevOps using an analogy:</p>
			<p class="author-quote">If you think of DevOps like an interface in a programming language, class SRE implements DevOps.</p>
			<p>(<em class="italic">Google Cloud</em>, <em class="italic">SRE vs. DevOps: competing standards or close friends?</em>, <a href="https://cloud.google.com/blog/products/gcp/sre-vs-devops-competing-standards-or-close-friends">https://cloud.google.com/blog/products/gcp/sre-vs-devops-competing-standards-or-close-friends</a>)</p>
			<p>Let's look at how <a id="_idIndexMarker040"/>SRE implements <a id="_idIndexMarker041"/>DevOps and approaches the DevOps key pillars:</p>
			<ul>
				<li><strong class="bold">Reduces organizational silos</strong>: SRE reduces organizational silos by sharing ownership between developers and operators. Both teams are involved in the product/service life cycle from the start. Together <a id="_idIndexMarker042"/>they define <strong class="bold">Service-Level Objectives</strong> (<strong class="bold">SLOs</strong>), <strong class="bold">Service-Level Indicators</strong> (<strong class="bold">SLIs</strong>), and <strong class="bold">error budgets</strong> and share the <a id="_idIndexMarker043"/>responsibility to <a id="_idIndexMarker044"/>determine the reliability, work priority, and release cadence of new features. This promotes a shared vision and improves communication and collaboration.</li>
				<li><strong class="bold">Accepts failure as normal</strong>: SRE accepts failure as normal by conducting blameless postmortems, which includes detailed analysis without any reference to a person. <strong class="bold">Blameless postmortems</strong> help to understand <a id="_idIndexMarker045"/>the reasons for failure, identifying preventive actions, and ensuring that a failure for the same reason doesn't re-occur. The goal is to identify the root cause and process but not to focus on individuals. This helps to promote psychological safety. In most cases, failure is the result of a missing SLO or targets and incidents are tracked using specific indicators as a function of time or SLI.</li>
				<li><strong class="bold">Implements gradual change</strong>: SRE implements gradual changes by limited <strong class="bold">canary rollouts</strong> and eventually <a id="_idIndexMarker046"/>reduces the cost of failures. Canary rollouts refer to the process of rolling out changes to a small percentage of users in production before making them generally available. This ensures that the impact is limited to a small set of users and gives us the opportunity to capture feedback on the new rollouts.</li>
				<li><strong class="bold">Leverages tooling and automation</strong>: SRE leverages tooling and automation to reduce <strong class="bold">toil</strong> or the <a id="_idIndexMarker047"/>amount of manual repetitive work, and it eventually promotes speed and consistency. Automation is a force multiplier. However, this can create a lot of resistance to change. SRE recommends handling this resistance to change by understanding the psychology of change.</li>
				<li><strong class="bold">Measures everything</strong>: SRE promotes data-driven decision making, encourages goal <a id="_idIndexMarker048"/>setting by measuring and monitoring critical factors tied to the health and reliability of the <a id="_idIndexMarker049"/>system. SRE also measures the amount of manual, repetitive work spent. Measuring everything is key <a id="_idIndexMarker050"/>for setting up SLOs and <strong class="bold">Service-Level Agreements</strong> (<strong class="bold">SLAs</strong>) and reducing toil.</li>
			</ul>
			<p>This wraps up our introduction to SRE's approach to DevOps key pillars; we referred to jargon such as SLI, SLO, SLA, error budget, toil, and canary rollouts. These will be introduced in the next sub-section.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Introducing SRE's key concepts</h2>
			<p>SRE implements the DevOps philosophy via <a id="_idIndexMarker051"/>several key concepts, such as SLI, SLO, SLA, error budget, and toil.</p>
			<h3>Becoming familiar with SLI, SLO, and SLA</h3>
			<p>Before diving into the definitions of SRE terminology – specifically SLI, SLO, and SLA – this sub-section attempts to introduce this terminology through a relatable example.</p>
			<p>Let's consider that you are a paid consumer for a video streaming service. As a paid consumer, you will have certain expectations from the service. A key aspect of that expectation is that the service needs to be available. This means when you try to access the website of the video streaming service via any permissible means, such as mobile device or desktop, the website needs to be accessible and the service should always work.</p>
			<p>If you frequently encounter issues while accessing the service, either because the service is experiencing high traffic or the service provider is adding new features, or for any other reason, you will not be a happy consumer. Now, it is possible that some users can access this service at a moment in time but some users are unable to access it at the same moment in time. Those users who are able to access it are happy users and users who are unable to access it are sad users.</p>
			<p class="callout-heading">Availability</p>
			<p class="callout">The first and most critical feature that a <a id="_idIndexMarker052"/>service should provide is <strong class="bold">availability</strong>. Service availability can also be referred to as its uptime. Availability is the ability of an application or service to run when needed. If a system is not running, then the system will fail.</p>
			<p>Let's assume that you are a <a id="_idIndexMarker053"/>happy user. You can access the service. You can create a profile, browse titles, filter titles, watch reviews for specific titles, add videos to your watchlist, play videos, or add reviews to viewed videos. Each of these actions performed by you as a user can be categorized <a id="_idIndexMarker054"/>as a <strong class="bold">user journey</strong>. For each user journey, you will have certain expectations:</p>
			<ul>
				<li>If you try to browse titles under a specific category, say <em class="italic">comedy</em>, you would expect that the service loads the titles <em class="italic">without any delay</em>.</li>
				<li>If you select a title that you would like to watch, you would expect to watch the video <em class="italic">without any buffering</em>.</li>
				<li>If you would like to watch a livestream, you would expect the stream contents to be as <em class="italic">fresh</em> as possible.</li>
			</ul>
			<p>Let's explore the first expectation. When you as a user tries to browse titles under <em class="italic">comedy</em>, how fast is fast enough?</p>
			<p>Some users might expect to display the results within 1 second, and some might expect it in 200 ms and some others in 500 ms. So, the expectation needs to be quantifiable and for it to be quantifiable, it needs to be measurable. The expectation should be set to a value where most of the users will be happy. It should also be measured for a specific duration (say 5 minutes) and should be met over a period (say 30 days). It should not be a one-time event. If the expectation is not met over a period users expect, the service provider takes on some accountability and addresses the users' concerns either by issuing a refund or adding extra service credits.</p>
			<p>For a service to be reliable, the service needs to have key characteristics based on expectations <a id="_idIndexMarker055"/>from user journeys. In this example, the <a id="_idIndexMarker056"/>key characteristics that the <a id="_idIndexMarker057"/>user expects are <strong class="bold">latency</strong>, <strong class="bold">throughput</strong>, and <strong class="bold">freshness</strong>.</p>
			<p class="callout-heading">Reliability</p>
			<p class="callout"><strong class="bold">Reliability</strong> is the ability of an <a id="_idIndexMarker058"/>application or service to perform a specific function within a specific time without failures. If a system cannot perform its intended function, then the system will fail.</p>
			<p>So, to summarize the <a id="_idIndexMarker059"/>example of a video streaming service, as a user you will expect the following:</p>
			<ul>
				<li>The service is available.</li>
				<li>The service is reliable.</li>
			</ul>
			<p>Now, let's introduce SRE terminology with respect to the preceding example before going into their formal definitions:</p>
			<ul>
				<li>Expecting the service to be available or expecting the service to meet a specific amount of latency, throughput, or freshness, or any other characteristic that is critical to the user journey, is <a id="_idIndexMarker060"/>known as SLI.</li>
				<li>Expecting the service to be available or reliable for a certain target level over a specific <a id="_idIndexMarker061"/>period is SLO.</li>
				<li>Expecting the service to meet a pre-defined customer expectation, the failure of which results in a <a id="_idIndexMarker062"/>refund or credits, is SLA.</li>
			</ul>
			<p>Let's move on from this general understanding of these concepts and explore how Google views them by introducing SRE's technical practices.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>SRE's technical practices</h2>
			<p>SRE specifically prescribes the <a id="_idIndexMarker063"/>usage of specific technical tools or practices that will help to define, measure, and track service characteristics such as availability and reliability. These are referred to as SRE technical practices and specifically refer to SLIs, SLOs, SLAs, error budget, and toil. These are introduced in the following sections with significant insights.</p>
			<h3>Service-Level Indicator (SLI)</h3>
			<p>Google SRE has the <a id="_idIndexMarker064"/>following definition for SLI:</p>
			<p class="author-quote">SLI is a carefully defined quantitative measure of some aspect of the level of service that is provided. </p>
			<p>(<em class="italic">Betsy Beyer</em>, <em class="italic">Chris Jones</em>, <em class="italic">Jennifer Petoff</em>, &amp; <em class="italic">Niall Murphy</em>, <em class="italic">Site Reliability Engineering</em>, <em class="italic">O'REILLY</em>)</p>
			<p>Most services <a id="_idIndexMarker065"/>consider latency or throughput as key aspects of a service based on related user journeys. SLI is a specific measurement of these aspects where raw data is aggregated or collected over a measurement window and represented as a rate, average, or percentile</p>
			<p>Let's now look at the characteristics of SLIs:</p>
			<ul>
				<li>It is a direct measurement of a service performance or behavior.</li>
				<li>Refers to measurable metrics over time.</li>
				<li>Can be aggregated and turned to rate, average, or percentile.</li>
				<li>Used to determine the level of availability. SRE considers availability as the prerequisite to success.</li>
			</ul>
			<p>SLI can be represented as a formula:</p>
			<p><img src="image/Formula_01_001.png" alt=""/></p>
			<p>For <a id="_idIndexMarker066"/>systems serving requests over HTTPS, validity is often determined by request parameters such as hostname or requested path to scope the SLI to a particular set of serving tasks, or response handlers. For data processing systems, validity is usually determined by the selection of inputs to scope the SLI to a subset of data. Good events refer to the expectations from the service or system.</p>
			<p>Let's look at some <a id="_idIndexMarker067"/>examples of SLIs:</p>
			<ul>
				<li><strong class="bold">Request latency</strong>: The time taken to return a response for a request should be less than 100 ms.</li>
				<li><strong class="bold">Failure rate</strong>: The ratio of unsuccessful requests to all received requests should be greater than 99%.</li>
				<li><strong class="bold">Availability</strong>: Refers to the uptime check on whether a service is available or not at a particular point in time.</li>
			</ul>
			<h3>Service-Level Objective (SLO)</h3>
			<p>Google SRE uses the <a id="_idIndexMarker068"/>following definition for SLO:</p>
			<p class="author-quote">Service level objectives (SLOs) specify a target level for the reliability of your service.</p>
			<p>(<em class="italic">Betsy Beyer</em>, <em class="italic">Chris Jones</em>, <em class="italic">Jennifer Petoff</em>, &amp; <em class="italic">Niall Murphy</em>, <em class="italic">Site Reliability Engineering</em>, <em class="italic">O'REILLY</em>)</p>
			<p>Customers have specific <a id="_idIndexMarker069"/>expectations from a service and these expectations are characterized by specific indicators or SLIs that are tailored per the user journey. SLOs are a way to measure customer happiness and their expectations by ensuring that the SLIs are consistently met and are potentially reported before the customer notices an issue.</p>
			<p>Let's now look at the characteristics of SLOs:</p>
			<ul>
				<li>Identifies whether a service is reliable enough.</li>
				<li>Directly tied to SLIs. SLOs are in fact measured by using SLIs.</li>
				<li>Can either be a single target or a range of values for the collection of SLIs.</li>
				<li>If the SLI refers to metrics over time, which details the health of a service, then SLOs are agreed-upon bounds on how often the SLIs must be met.</li>
			</ul>
			<p>Let's see how they are represented as a formula:</p>
			<p><img src="image/Formula_01_002.png" alt=""/> target OR <img src="image/Formula_01_003.png" alt=""/></p>
			<p>SLO can best be <a id="_idIndexMarker070"/>represented either as a specific target value or as a range of values for an SLI for a specific aspect of a service, such as latency or throughput, representing the acceptable lower bound and possible upper bound that is valid over a specific period. Given that SLIs are used to measure SLOs, SLIs should be within the target or between the range of acceptable values</p>
			<p>Let's look at some <a id="_idIndexMarker071"/>examples of SLOs:</p>
			<ul>
				<li><strong class="bold">Request latency</strong>: 99.99% of all requests should be served under 100 ms over a period of 1 month or 99.9% of all requests should be served between 75 ms and 125 ms for a period of 1 month.</li>
				<li><strong class="bold">Failure rate</strong>: 99.9% of all requests should have a failure rate of 99% over 1 year.</li>
				<li><strong class="bold">Availability</strong>: The application should be usable for 99.95% of the time over 24 hours.</li>
			</ul>
			<h3>Service-Level Agreement (SLA)</h3>
			<p>Google SRE uses the <a id="_idIndexMarker072"/>following <a id="_idIndexMarker073"/>definition for SLAs:</p>
			<p class="author-quote">SLA is an explicit or implicit contract with your users that includes consequences of meeting (or missing) the SLOs they contain.</p>
			<p>(<em class="italic">Betsy Beyer</em>, <em class="italic">Chris Jones</em>, <em class="italic">Jennifer Petoff</em>, &amp; <em class="italic">Niall Murphy</em>, <em class="italic">Site Reliability Engineering</em>, <em class="italic">O'REILLY</em>)</p>
			<p>An SLA is an external-facing agreement that is provided to the consumer of a service. The agreement clearly lays out the minimum expectations that the consumer can expect from the service and calls out the consequences that the service provider needs to face if found in violation. The <a id="_idIndexMarker074"/>consequences are generally applied in terms of refund or additional credits to the service consumer.</p>
			<p>Let's now look at the characteristics of SLAs:</p>
			<ul>
				<li>SLAs are based on SLOs.</li>
				<li>Signifies the business factor that binds the customer and service provider.</li>
				<li>Represents the consequences of what happens when availability or customer expectation fails.</li>
				<li>Are more lenient than SLOs to trigger early alarms as these are the minimum expectations that the service should meet.</li>
			</ul>
			<p>SLAs' priority in comparison to SLOs can be represented as follows:</p>
			<p><img src="image/Formula_01_004.png" alt=""/></p>
			<p>Let's look at some <a id="_idIndexMarker075"/>examples of SLAs:</p>
			<ul>
				<li><strong class="bold">Latency</strong>: 99% of all requests per day should be served under 150 ms; otherwise, 10% of the daily subscription fee will be refunded.</li>
				<li><strong class="bold">Availability</strong>: The service should be available with an uptime commitment of 99.9% in a 30-day period; else 4 hours of extra credit will be added to the user account.</li>
			</ul>
			<h3>Error budgets</h3>
			<p>Google SRE <a id="_idIndexMarker076"/>defines <a id="_idIndexMarker077"/>error budgets as follows:</p>
			<p class="author-quote">A quantitative measurement shared between the product and the SRE teams to balance innovation and stability.</p>
			<p>(<em class="italic">Betsy Beyer</em>, <em class="italic">Chris Jones</em>, <em class="italic">Jennifer Petoff</em>, &amp; <em class="italic">Niall Murphy</em>, <em class="italic">Site Reliability Engineering</em>, <em class="italic">O'REILLY</em>)</p>
			<p>While a service needs to be reliable, it should also be mindful that if new features are not added to the service, then users might not continue to use it. A 100% reliable service will imply that the service will not have any downtime. This means that it will be increasingly difficult to add innovation via new features that could potentially attract new customers and lead to an increase in revenue. Getting to 100% reliability is expensive and complex. Instead, it's recommended to find the unique value for service reliability where customers feel that the service is reliable enough.</p>
			<p>Unreliable systems can <a id="_idIndexMarker078"/>quickly erode users' confidence. So, it's critical to reduce the chance of system failure. SRE aims to balance the risk of unavailability with the goals of rapid innovation and efficient service operations so that users' overall happiness – with features, service, and performance – is optimized.</p>
			<p>The error budget is basically the <a id="_idIndexMarker079"/>inverse of availability, and it tells us how unreliable our service is allowed to be. If your SLO says that 99.9% of requests should be successful in a given quarter, your error budget allows 0.1% of requests to fail. This unavailability can be generated because of bad pushes by the product teams, planned maintenance, hardware failures, and so on:</p>
			<p><img src="image/Formula_01_005.png" alt=""/></p>
			<p class="callout-heading">Important note </p>
			<p class="callout">The relationship between the error budget and actual allowed downtime for a service is as follows:</p>
			<p class="callout">If SLO = 99.5%, then error budget = 0.5% = 0.005</p>
			<p class="callout">Allowed downtime per month = 0.005 * 30 days/month * 24 hours/day * 60 minutes/hour = 216 minutes/month</p>
			<p>The following table represents the allowed downtime for a specific time period to achieve a certain level of availability. For downtime information calculation for a specific availability level (other than the following mentioned), refer to <a href="https://availability.sre.xyz/">https://availability.sre.xyz/</a>:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B15587_01_Table-01.jpg" alt=""/>
				</div>
			</div>
			<p>There are <a id="_idIndexMarker080"/>advantages to defining the error budget:</p>
			<ul>
				<li>Release new features while keeping an eye on system reliability.</li>
				<li>Roll out infrastructure updates.</li>
				<li>Plan for inevitable failures in networks and other similar events.</li>
			</ul>
			<p>Despite planning <a id="_idIndexMarker081"/>error budgets, there are times when a system can overshoot it. In such cases, there are a few things that occur:</p>
			<ul>
				<li>Release of new features is temporarily halted.</li>
				<li>Increased focus on dev, system, and performance testing.</li>
			</ul>
			<h3>Toil</h3>
			<p>Google SRE <a id="_idIndexMarker082"/>defines toil as follows:</p>
			<p class="author-quote">Toil is the kind of work tied to running a production service that tends to be manual, repetitive, automatable, tactical, devoid of enduring value and that scales linearly as a service grows.</p>
			<p>(<em class="italic">Betsy Beyer</em>, <em class="italic">Chris Jones</em>, <em class="italic">Jennifer Petoff</em>, &amp; <em class="italic">Niall Murphy</em>, <em class="italic">Site Reliability</em> <em class="italic">Engineering</em>, <em class="italic">O'REILLY</em>)</p>
			<p>Here are the <a id="_idIndexMarker083"/>characteristics of toil:</p>
			<ul>
				<li><strong class="bold">Manual</strong>: Act of manually initiating a script that automates a task.</li>
				<li><strong class="bold">Repetitive</strong>: Tasks that are repeated multiple times.</li>
				<li><strong class="bold">Automatable</strong>: Human executing a task instead of a machine, especially if a machine can execute with the same effectiveness.</li>
				<li><strong class="bold">Tactical</strong>: Reactive tasks originating out of an interruption (such as pager alerts), rather than strategy-driven proactive tasks, are considered toil.</li>
				<li><strong class="bold">No enduring value</strong>: Tasks that do not change the effective state of the service after execution.</li>
				<li><strong class="bold">Linear growth</strong>: Tasks that grow linearly with an increase in traffic or service demand.</li>
			</ul>
			<p>Toil is generally confused with <strong class="bold">overhead</strong>. Overhead is <a id="_idIndexMarker084"/>not the same as toil. Overhead is referred to as administrative work that is not tied to running a service, but toil refers to repetitive work that can be reduced by automation. Automation helps to lower burnout, increase team morale, increase engineering standards, improve technical skills, standardize processes, and reduce human error. Examples of tasks that represent overhead and not toil are email, commuting, expense reports, and meetings.</p>
			<h3>Canary rollouts</h3>
			<p>SRE <a id="_idIndexMarker085"/>prescribes implementing <a id="_idIndexMarker086"/>gradual change by using canary rollouts, where the concept is to introduce a change to a small portion of users to detect any imminent danger.</p>
			<p>To elaborate, when there is a large service that needs to be sustained, it's preferable to employ a production change with unknown impact to a small portion to identify any potential issue. If any issues are found, the change can be reversed, and the impact or cost is much less than if the change was rolled out to the whole service.</p>
			<p>The following two factors should be considered when selecting the canary population:</p>
			<ul>
				<li>The size of the canary population should be small enough that it can be quickly rolled back in case an issue arises.</li>
				<li>The size of the canary population should be large enough that it is a representative subset of the total population.</li>
			</ul>
			<p>This concludes a <a id="_idIndexMarker087"/>high-level overview of <a id="_idIndexMarker088"/>important SRE technical practices. The next section details SRE cultural practices that are key to embrace SRE across an organization and are also critical to efficiently handle change management.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>SRE's cultural practices</h2>
			<p>Defining SLIs, SLOs, and SLAs for a service, using error budgets to balance velocity (the rate at which changes are delivered to production) and reliability, identifying toil, and using automation to <a id="_idIndexMarker089"/>eliminate toil forms SRE's technical practices. In addition to these technical practices, it is important to understand and build certain cultural practices that eventually support the technical practices. Cultural practices are equally important to reduce silos within IT teams, as they can reduce the incompatible practices used by individuals within the team. The first cultural practice that will be discussed is the need for a unifying vision.</p>
			<h3>Need for a unifying vision</h3>
			<p>Every company needs a vision and a team's vision needs to align with the company's vision. The company's vision is a combination of core values, the purpose, the mission, strategies, and goals:</p>
			<ul>
				<li><strong class="bold">Core values</strong>: Values refer to a team member's commitment to personal/organizational goals. It also reflects on how members operate within a team by building trust and psychological safety. This creates a culture where the team is open to learning and willing to take risks.</li>
				<li><strong class="bold">Purpose</strong>: A team's purpose refers to the core reason that the team exists in the first place. Every team should have a purpose in the larger context of the organization.</li>
				<li><strong class="bold">Mission</strong>: A team's mission refers to a well-articulated, clear, compelling, and unified goal.</li>
				<li><strong class="bold">Strategy</strong>: A team's strategy refers to a plan on how the team will realize its mission.</li>
				<li><strong class="bold">Goals</strong>: A team's goal gives more detailed and specific insights into what the team wants to achieve. Google recommends the use of <strong class="bold">Objectives and Key Results</strong> (<strong class="bold">OKRs</strong>), which are a <a id="_idIndexMarker090"/>popular goal-setting tool in large companies.</li>
			</ul>
			<p>Once a vision statement is established for the company and the team, the next cultural practice is to ensure there is efficient collaboration and communication within the team and across cross-functional teams. This will be discussed next.</p>
			<h3>Collaboration and communication</h3>
			<p>Communication and collaboration are <a id="_idIndexMarker091"/>critical given the complexity of services and the need for these services to be globally accessible. This also means that SRE teams should be globally distributed to support services in an effective manner. Here are some SRE prescriptive guidelines:</p>
			<ul>
				<li><strong class="bold">Service-oriented meetings</strong>: SRE teams frequently review the state of the service and identify opportunities to improve and increase awareness among stakeholders. The meetings are mandatory for team members and typically last 30-60 minutes, with a defined agenda such as discussing recent paging events, outages, any required configuration changes.</li>
				<li><strong class="bold">Balanced team composition</strong>: SRE teams are spread across multiple countries and multiple time zones. This enables them to support a globally available system or service. The SRE team composition typically includes a technical lead (to provide technical guidance), a manager (who runs performance management), and a project manager, who collaborate across time zones.</li>
				<li><strong class="bold">Involvement throughout the service life cycle</strong>: SRE teams are actively involved throughout the service life cycle across various stages such as <em class="italic">architecture and design</em>, <em class="italic">active development</em>, <em class="italic">limited availability</em>, <em class="italic">general availability</em>, and <em class="italic">depreciation</em>.</li>
				<li><strong class="bold">Establish rules of engagement</strong>: SRE teams should clearly describe what channels should be used for what purpose and in what situations. This brings in a sense of clarity. SRE teams should use a common set of tools for creating and maintaining artifacts</li>
				<li><strong class="bold">Encourage blameless postmortem</strong>: SRE encourages a blameless postmortem culture, where the theme is to learn from failure and the focus is on identifying the root cause of the issue rather than on individuals. A well-written postmortem report can act as an effective tool for driving positive organizational changes since the <a id="_idIndexMarker092"/>suggestions or improvements mentioned in the report can help to tune up existing processes</li>
				<li><strong class="bold">Knowledge sharing</strong>: SRE teams prescribe knowledge sharing through specific means such as encouraging cross-training, creation of a volunteer teaching network, and sharing postmortems of incidents in a way that fosters collaboration and knowledge sharing.</li>
			</ul>
			<p>The preceding guidelines, such as knowledge sharing along with the goal to reduce paging events or outages by creating a common set of tools, increase resistance among individuals and team members. This might also create a sense of insecurity. The next cultural practice elaborates on how to encourage psychological safety and reduce resistance to change.</p>
			<h3>Encouraging psychological safety and reducing resistance to change</h3>
			<p>SRE prescribes automation as an essential cornerstone to apply engineering principles and reduce manual work such as toil. Though eliminating toil through automation is a technical practice, there will be huge resistance to performing automation. Some may resist automation more than others. Individuals may feel as though their jobs are in jeopardy, or they may disagree that certain tasks need not be automated. SRE prescribes a cultural practice to reduce the resistance to change by building a psychologically safe environment.</p>
			<p>In order to build a psychologically safe environment, it is first important to communicate the importance of a specific change. For example, if the change is to automate this year's job away, here are some reasons on how automation can add value:</p>
			<ul>
				<li>Provides consistency.</li>
				<li>Provides a platform that can be extended and applied to more systems.</li>
				<li>Common faults can be easily identified and resolved more quickly.</li>
				<li>Reduces cost by identifying problems as early in the life cycle as possible, rather than finding them in production.</li>
			</ul>
			<p>Once the reason for the <a id="_idIndexMarker093"/>change is clearly communicated, here are some additional pointers that will help to build a <em class="italic">psychologically safe environment</em>:</p>
			<ul>
				<li>Involve team members in the change. Understand their concerns and empathize as needed.</li>
				<li>Encourage critics to openly express their fears as this adds a sense of freedom to team members to freely express their opinions.</li>
				<li>Set realistic expectations.</li>
				<li>Allow team members to adapt to new changes.</li>
				<li>Provide them with effective training opportunities and ensure that training is engaging and rewarding.</li>
			</ul>
			<p>This completes an introduction to key SRE cultural practices that are critical to implementing SRE's technical practices. Subsequently, this also completes the section on SRE where we introduced SRE, discussed its evolution, and elaborated on how SRE is a prescriptive way to practically implement DevOps key pillars. The next section discusses how to implement DevOps using Google Cloud services.</p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Cloud-native approach to implementing DevOps using Google Cloud</h1>
			<p>This section elaborates on how to <a id="_idIndexMarker094"/>implement DevOps using Google Cloud services with a focus on a cloud-native approach – an approach that <a id="_idIndexMarker095"/>uses cloud computing at its core to build highly available, scalable, and resilient applications.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>Focus on microservices</h2>
			<p>A <strong class="bold">monolith application</strong> has a <a id="_idIndexMarker096"/>tightly coupled architecture and implements all possible features in a single code base along with the database. Though monolith applications can be designed with modular components, the components are still packaged at deployment time and deployed together as a single unit. From a CI/CD standpoint, this will potentially result in a single build pipeline. Fixing an issue or adding a new feature is an extremely time-consuming process since the impact is on the entire application. This decreases the release velocity and essentially is a nightmare for production support teams dealing with service disruption.</p>
			<p>In contrast, a <strong class="bold">microservice application</strong> is <a id="_idIndexMarker097"/>based on service-oriented architecture. A microservice application divides a large program into several smaller, independent services. This allows the components to be managed by smaller teams as the components are more isolated in nature. The teams, as well as the service, can be independently scaled. Microservices fundamentally support the concept of incremental code change. With microservices, the individual components are deployable. Given that microservices are feature-specific, in the event of an issue, fault detection and isolation are much easier and hence service disruptions can be handled quickly and efficiently. This also <a id="_idIndexMarker098"/>makes it much more suitable for CI/CD processes and works well with the theme of <em class="italic">building reliable software faster</em>!</p>
			<p class="callout-heading">Exam tip</p>
			<p class="callout">Google Cloud provides several compute services that facilitate the deployment of microservices as containers. These <a id="_idIndexMarker099"/>include App Engine flexible environment, Cloud Run, <strong class="bold">Google Compute Engine</strong> (<strong class="bold">GCE</strong>), and <strong class="bold">Google Kubernetes Engine</strong> (<strong class="bold">GKE</strong>). From a <a id="_idIndexMarker100"/>Google Cloud DevOps exam perspective, the common theme is to build containers and deploy containers using GKE. GKE will be a major focus area and will be discussed in detail in the upcoming chapters.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Cloud-native development</h2>
			<p>Google promotes and recommends <a id="_idIndexMarker101"/>application development using the <a id="_idIndexMarker102"/>following cloud-native principles:</p>
			<ul>
				<li><strong class="bold">Use microservice architectural patterns</strong>: As discussed in the previous sub-section, the essence is to build smaller independent services that could be managed separately and be scaled granularly. </li>
				<li><strong class="bold">Treat everything as code</strong>: This principle makes it easier to track, roll back code if required, and see the version of change. This includes source code, test code, automation code, and infrastructure as code.</li>
				<li><strong class="bold">Build everything as containers</strong>: A container image can include software dependencies needed by the application, specific language runtimes, and other software libraries. Containers can be run anywhere, making it easier to develop and deploy. This allows developers to focus on code and ops teams will spend less time debugging and diagnosing differences in environments.</li>
				<li><strong class="bold">Design for automation</strong>: Automated processes can repair, scale, and deploy systems faster than humans. As a critical first step, a comprehensive CI/CD pipeline is required that can automate the build, testing, and deployment process. In addition, the services that are deployed as containers should be configured to scale up or down based on outstanding traffic. Real-time monitoring and logging should be used as a source for automation since they provide insights into potential issues that could be mitigated by building proactive actions. The idea of automation can also be extended to automate the entire infrastructure using <a id="_idIndexMarker103"/>techniques such as <strong class="bold">Infrastructure as Code</strong> (<strong class="bold">IaC</strong>).</li>
				<li><strong class="bold">Design components to be stateless wherever possible</strong>: Stateless components are easy to scale up or down, repair a failed instance by graceful termination and potential replacement, roll back to an older instance in case of issues, and make load <a id="_idIndexMarker104"/>balancing a lot simpler since any instance can handle any request. Any need to store persistent data should happen outside the container, such as storing files using Cloud Storage, storing user sessions through Redis or Memcached, or using persistent disks for block-level storage.</li>
			</ul>
			<p>Google Cloud provides two approaches for cloud-native development – <strong class="bold">serverless</strong> and <strong class="bold">Kubernetes</strong>. The choice comes down to focus on infrastructure versus business logic:</p>
			<ul>
				<li><strong class="bold">Serverless</strong> (via Cloud Run, Cloud Functions, or App Engine): Allows <a id="_idIndexMarker105"/>us to focus on the business logic of the application by providing a <a id="_idIndexMarker106"/>higher level of abstraction from an infrastructure standpoint.</li>
				<li><strong class="bold">Kubernetes</strong> (via GKE): Provides higher <a id="_idIndexMarker107"/>granularity and control on how multiple microservices can be deployed, how <a id="_idIndexMarker108"/>services can communicate with each other, and how external clients can interact with these services.<p class="callout-heading">Managed versus serverless service</p><p class="callout">Managed services allow operations related to updates, networking, patching, high availability, automated backups, and redundancy to be managed by the cloud provider. Managed services are not serverless as it is required to specify a machine size and the service mandates to have a minimal number of VMs/nodes. For example, it is required to define the machine size while creating a cloud SQL instance, but updates and patches can be configured to be managed by Google Cloud.</p><p class="callout">Serverless services are <strong class="bold">managed</strong> but do not require reserving a server upfront or keeping it running. The focus is on the business logic of the application with the possibility of running or executing code only when needed. Examples are <em class="italic">Cloud Run</em>, <em class="italic">Cloud Storage</em>, <em class="italic">Cloud Firestore</em>, and <em class="italic">Cloud Datastore</em>.</p></li>
			</ul>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Continuous integration in GCP</h2>
			<p><strong class="bold">Continuous integration</strong> forms the <strong class="bold">CI</strong> of the CI/CD process and at its heart is the culture of submitting smaller units of <a id="_idIndexMarker109"/>change frequently. Smaller changes minimize the risk, help to resolve issues quickly, increase development velocity, and provide <a id="_idIndexMarker110"/>frequent feedback. The following are the building blocks that make up the CI process:</p>
			<ul>
				<li><strong class="bold">Make code changes</strong>: By using the IDE of choice and possible cloud-native plugins</li>
				<li><strong class="bold">Manage source code</strong>: By using a single shared code repository</li>
				<li><strong class="bold">Build and create artifacts</strong>: By using an automated build process</li>
				<li><strong class="bold">Store artifacts</strong>: By storing artifacts such as container images in a repository for a future deployment process</li>
			</ul>
			<p>Google Cloud has an appropriate service for each of the building blocks that allows us to build a GCP-native CI pipeline (refer to <em class="italic">Figure 1.2</em>). The following is a summary of these services, which will be discussed in detail in upcoming chapters:</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B15587_01_02.jpg" alt="Figure 1.2 – CI in GCP&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 1.2 – CI in GCP</p>
			<p>Let's look at <a id="_idIndexMarker111"/>these <a id="_idIndexMarker112"/>stages in detail.</p>
			<h3>Cloud Code</h3>
			<p>This is the GCP service <a id="_idIndexMarker113"/>to write, debug, and deploy cloud-native applications. Cloud Code <a id="_idIndexMarker114"/>provides extensions to <a id="_idIndexMarker115"/>IDEs such as <em class="italic">Visual Studio Code</em> and the <em class="italic">JetBrains suite</em> of IDEs <a id="_idIndexMarker116"/>that allows to rapidly iterate, debug, and run code on Kubernetes and Cloud Run. Key features include the following:</p>
			<ul>
				<li>Speed up <a id="_idIndexMarker117"/>development and simplify local development</li>
				<li>Extend to production <a id="_idIndexMarker118"/>deployments on GKE or Cloud Run and allow debugging deployed applications</li>
				<li>Deep integration with Cloud Source Repositories and Cloud Build</li>
				<li>Easy to add and configure Google Cloud APIs from built-in library manager</li>
			</ul>
			<h3>Cloud Source Repositories</h3>
			<p>This is the GCP service to <a id="_idIndexMarker119"/>manage source code. It <a id="_idIndexMarker120"/>provides Git version control to support the collaborative development of any application or service. Key features include the following:</p>
			<ul>
				<li>Fully managed private Git repository</li>
				<li>Provides one-way sync with Bitbucket and GitHub source repositories</li>
				<li>Integration with GCP services such as Cloud Build and Cloud Operations</li>
				<li>Includes universal code search within and across repositories</li>
			</ul>
			<h3>Cloud Build </h3>
			<p>This is the GCP service to <a id="_idIndexMarker121"/>build and create <a id="_idIndexMarker122"/>artifacts based on commits made to source code repositories such as GitHub, Bitbucket, or Google's Cloud Source Repositories. These artifacts can be container or non-container artifacts. The GCP DevOps exam's primary focus will be on container artifacts. Key features include the following:</p>
			<ul>
				<li>Fully serverless platform with no need to pre-provision servers or pay in advance for additional capacity. Will scale up and down based on load</li>
				<li>Includes Google and community builder images with support for multiple languages and tools</li>
				<li>Includes custom build <a id="_idIndexMarker123"/>steps and pre-created extensions to third-party apps that enterprises can easily integrate into their build process</li>
				<li>Focus on security with <a id="_idIndexMarker124"/>vulnerability scanning and the ability to define policies that can block the deployment of vulnerable images</li>
			</ul>
			<h3>Container/Artifact Registry</h3>
			<p>This is the GCP construct to <a id="_idIndexMarker125"/>store artifacts that include both container (Docker images) and non-container artifacts (such as Java and Node.js packages). Key <a id="_idIndexMarker126"/>features include the following:</p>
			<ul>
				<li>Seamless integration with Cloud Source Repositories and Cloud Build to upload artifacts to Container/Artifact Registry.</li>
				<li>Ability to set up a secure private build artifact storage on Google Cloud with granular access control.</li>
				<li>Create multiple regional repositories within a single Google Cloud project.</li>
			</ul>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Continuous delivery/deployment in GCP</h2>
			<p><strong class="bold">Continuous delivery</strong>/<strong class="bold">deployment</strong> forms <a id="_idIndexMarker127"/>the <strong class="bold">CD</strong> of the CI/CD process and at its heart is the culture of continuously delivering production-ready code or deploying code to production. This allows us to release software at <a id="_idIndexMarker128"/>high velocity without sacrificing quality.</p>
			<p>GCP offers multiple services to deploy code, such as <em class="italic">Compute Engine</em>, <em class="italic">App Engine</em>, <em class="italic">Kubernetes Engine</em>, <em class="italic">Cloud Functions</em>, and <em class="italic">Cloud Run</em>. The focus of this book will be on GKE and Cloud Run. This is in alignment with the Google Cloud DevOps exam objectives.</p>
			<p>The following figure summarizes the different stages of continuous delivery/deployment from the viewpoint of appropriate GCP services:</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B15587_01_03.jpg" alt="Figure 1.3 – Continuous delivery/deployment in GCP&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – Continuous delivery/deployment in GCP</p>
			<p>Let's look at the <a id="_idIndexMarker129"/>two container-based deployments in <a id="_idIndexMarker130"/>detail.</p>
			<h3>Google Kubernetes Engine (GKE)</h3>
			<p>This is the GCP service <a id="_idIndexMarker131"/>to deploy containers. GKE is <a id="_idIndexMarker132"/>Google Cloud's <a id="_idIndexMarker133"/>implementation of the <strong class="bold">CNCF Kubernetes project</strong>. It's a managed environment for deploying, managing, and scaling containerized applications using Google's infrastructure. Key features include the following:</p>
			<ul>
				<li>Automatically provisions and manages a cluster's master-related infrastructure and abstracts away the need for a separate master node</li>
				<li>Automatic scaling of a cluster's node instance count</li>
				<li>Automatic upgrades of a cluster's node software</li>
				<li>Node auto-repair to maintain the node's health</li>
				<li>Native integration with <a id="_idIndexMarker134"/>Google's Cloud <a id="_idIndexMarker135"/>Operations for logging and monitoring</li>
			</ul>
			<h3>Cloud Run</h3>
			<p>This is a GCP-managed <a id="_idIndexMarker136"/>serverless platform that can deploy and run Docker containers. These containers can be deployed in either Google-managed Kubernetes <a id="_idIndexMarker137"/>clusters or on-premises workloads using <em class="italic">Cloud Run for Anthos</em>. Key features include the following:</p>
			<ul>
				<li>Abstracts away infrastructure management by automatically scaling up and down</li>
				<li>Only charges for exact resources consumed</li>
				<li>Native GCP integration with Google Cloud services such as Cloud Code, Cloud Source Repositories, Cloud Build, and Artifact Registry</li>
				<li>Supports event-based invocation via web requests with Google Cloud services such as Cloud Scheduler, Cloud Tasks, and Cloud Pub/Sub</li>
			</ul>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>Continuous monitoring/operations on GCP</h2>
			<p><strong class="bold">Continuous Monitoring/Operations</strong> forms the feedback loop of the CI/CD process and at its heart is the culture of <a id="_idIndexMarker138"/>continuously <a id="_idIndexMarker139"/>monitoring or observing the performance of the service/application.</p>
			<p>GCP offers a suite of <a id="_idIndexMarker140"/>services that provide different aspects of Continuous Monitoring/Operations, aptly <a id="_idIndexMarker141"/>named <strong class="bold">Cloud Operations</strong> (formerly known as <strong class="bold">Stackdriver</strong>). Cloud Operations includes <strong class="bold">Cloud Monitoring</strong>, <strong class="bold">Cloud Logging</strong>, <strong class="bold">Error Reporting</strong>, and <strong class="bold">Application Performance Management</strong> (<strong class="bold">APM</strong>). APM further includes <strong class="bold">Cloud Debugger</strong>, <strong class="bold">Cloud Trace</strong>, and <strong class="bold">Cloud Profiler</strong>. Refer to the following diagram:</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/B15587_01_04.jpg" alt="Figure 1.4 – Continuous monitoring/operations&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – Continuous monitoring/operations</p>
			<p>Let's look at these <a id="_idIndexMarker142"/>operations- and monitoring-specific <a id="_idIndexMarker143"/>services in detail.</p>
			<h3>Cloud Monitoring</h3>
			<p>This is the GCP service that <a id="_idIndexMarker144"/>collects metrics, events, and metadata from Google Cloud and other providers. Key features <a id="_idIndexMarker145"/>include the following:</p>
			<ul>
				<li>Provides out-of-the-box default dashboards for many GCP services</li>
				<li>Supports uptime monitoring and alerting to various types of channels</li>
				<li>Provides easy navigation to drill down from alerts to dashboards to logs and traces to quickly identify the root cause</li>
				<li>Supports non-GCP environments with the use of agents</li>
			</ul>
			<h3>Cloud Logging</h3>
			<p>This is the GCP service that <a id="_idIndexMarker146"/>allows us to store, search, analyze, monitor, and alert on logging data and events from <strong class="bold">Google </strong><strong class="bold"><a id="_idIndexMarker147"/></strong><strong class="bold">Cloud</strong> and <strong class="bold">Amazon Web Services</strong>. Key features <a id="_idIndexMarker148"/>include the following:</p>
			<ul>
				<li>A fully managed service that performs at scale with sub-second ingestion latency at terabytes per second</li>
				<li>Analyzes log data across multi-cloud environment from a single place</li>
				<li>Ability to ingest application and system log data from thousands of VMs</li>
				<li>Ability to create metrics from streaming logs and analyze log data in real time using BigQuery</li>
			</ul>
			<h3>Error Reporting</h3>
			<p>This is the GCP service that aggregates, counts, analyzes, and displays application errors produced from running cloud services. Key features include the following:</p>
			<ul>
				<li>Dedicated view of error details that include a time chart, occurrences, affected user count, first and last seen dates, and cleaned exception stack trace</li>
				<li>Lists out the top or new errors in a clear dashboard</li>
				<li>Constantly analyzes exceptions and aggregates them into meaningful groups</li>
				<li>Can translate the <a id="_idIndexMarker149"/>occurrence of an <a id="_idIndexMarker150"/>uncommon error into an alert for immediate attention</li>
			</ul>
			<h3>Application Performance Management</h3>
			<p>This is the GCP service that <a id="_idIndexMarker151"/>combines monitoring and troubleshooting capabilities of Cloud Logging and Cloud Monitoring with <a id="_idIndexMarker152"/>Cloud Trace, Cloud Debugger, and Cloud Profiler, to help reduce latency and cost and enable us to run applications more efficiently. Key features include the following:</p>
			<ul>
				<li>A distributed tracing <a id="_idIndexMarker153"/>system (via Cloud Trace) that collects latency data from your applications to identify performance bottleneck</li>
				<li>Inspects a production <a id="_idIndexMarker154"/>application by taking a snapshot of the application <a id="_idIndexMarker155"/>state in real time, without stopping or slowing down (via Cloud Debugger), and provides the <a id="_idIndexMarker156"/>ability to inject log messages as part of debugging</li>
				<li>Low-impact <a id="_idIndexMarker157"/>production profiling (via Cloud Profiler) using statistical techniques, to present the call hierarchy and resource consumption of relevant function in an interactive flame graph</li>
			</ul>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>Bringing it all together – building blocks for a CI/CD pipeline in GCP</h2>
			<p>The following figure represents the <a id="_idIndexMarker158"/>building blocks that are required to build a CI/CD pipeline in GCP:</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/B15587_01_05.jpg" alt="Figure 1.5 – GCP building blocks representing the DevOps life cycle&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 1.5 – GCP building blocks representing the DevOps life cycle</p>
			<p>In the preceding figure, the section for <strong class="bold">Continuous Feedback/Analysis</strong> represents the GCP services that are used to analyze or store information obtained during Continuous Monitoring/Operations either from an event-driven or compliance perspective. This completes the section on an overview of <a id="_idIndexMarker159"/>Google Cloud services that can be used to implement the key stages of the DevOps life cycle using a cloud-native approach with emphasis on decomposing a complex system into microservices that can be independently tested and deployed.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Summary</h1>
			<p>In this chapter, we learned about DevOps practices that break down the metaphorical wall between developers (who constantly want to push features to production) and operators (who want to run the service reliably).</p>
			<p>We learned about the DevOps life cycle, key pillars of DevOps, how Google Cloud implements DevOps through SRE, and Google's cloud-native approach to implementing DevOps. We learned about SRE's technical and cultural practices and were introduced to key GCP services that help to build the CI/CD pipeline. In the next chapter, we will take an in-depth look at SRE's technical practices such as SLI, SLO, SLA, and error budget.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>Points to remember</h1>
			<p>The following are some important points:</p>
			<ul>
				<li>If DevOps is a philosophy, SRE is a prescriptive way of achieving that philosophy: <em class="italic">class SRE</em> implements DevOps.</li>
				<li>SRE balances the velocity of development features with the risk to reliability.</li>
				<li>SLA represents an external agreement and will result in consequences when violated.</li>
				<li>SLOs are a way to measure customer happiness and their expectations.</li>
				<li>SLIs are best expressed as a proportion of all successful events to valid events.</li>
				<li>Error budget is the inverse of availability and depicts how unreliable a service is allowed to be.</li>
				<li>Toil is manual work tied to a production system but is not the same as overhead.</li>
				<li>The need for unifying vision, communication, and collaboration with an emphasis on blameless postmortems and the need to encourage psychological safety and reduce resistance to change are key SRE cultural practices.</li>
				<li>Google emphasizes the use of microservices and cloud-native development for application development.</li>
				<li>Serverless services are managed but managed services are necessarily not serverless.</li>
			</ul>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Further reading</h1>
			<p>For more information on GCP's approach toward DevOps, read the following articles:</p>
			<ul>
				<li>DevOps: <a href="https://cloud.google.com/devops">https://cloud.google.com/devops</a></li>
				<li>SRE: <a href="https://landing.google.com/sre/">https://landing.google.com/sre/</a></li>
				<li>CI/CD on Google Cloud: <a href="https://cloud.google.com/docs/ci-cd">https://cloud.google.com/docs/ci-cd</a></li>
			</ul>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>Practice test</h1>
			<p>Answer the following questions:</p>
			<ol>
				<li value="1">Which of the following represents a sequence of tasks that is central to user experience and is crucial to service?<p>a) User story </p><p>b) User journey</p><p>c) Toil</p><p>d) Overhead</p></li>
				<li>If the SLO for the uptime of a service is set to 99.95%, what is the possible SLA target?<p>a) 99.99</p><p>b) 99.95</p><p>c) 99.96</p><p>d) 99.90</p></li>
				<li>Which of the following accurately describes the equation for SLI?<p>a) Good events / Total events</p><p>b) Good events / Total events * 100</p><p>c) Good events / Valid events</p><p>d) Good events / Valid events * 100</p></li>
				<li>Which of the following represents a carefully defined quantitative measure of some aspect of the level of service?<p>a) SLO</p><p>b) SLI</p><p>c) SLA</p><p>d) Error budget</p></li>
				<li>Select the option used to calculate the error budget.<p>a) (100 – SLO) * 100</p><p>b) 100 – SLI</p><p>c) 100 – SLO </p><p>d) (100 – SLI) * 100</p></li>
				<li>Which set of Google services accurately depicts the continuous feedback loop?<p>a) Monitoring, Logging, Reporting</p><p>b) Bigtable, Cloud Storage, BigQuery</p><p>c) Monitoring, Logging, Tracing</p><p>d) BigQuery, Pub-Sub, Cloud Storage</p></li>
				<li>In which of the following "continuous" processes are changes automatically deployed to production without manual intervention?<p>a) Delivery</p><p>b) Deployment</p><p>c) Integration</p><p>d) Monitoring</p></li>
				<li>Select the option that ranks the compute services from a service that requires the most management needs with the highest customizability to a service with fewer management needs and the lowest customizability.<p>a) Compute Engine, App Engine, GKE, Cloud Functions</p><p>b) Compute Engine, GKE, App Engine, Cloud Functions</p><p>c) Compute Engine, App Engine, Cloud Functions, GKE</p><p>d) Compute Engine, GKE, Cloud Functions, App Engine</p></li>
				<li>Awesome Incorporated is planning to move their on-premises CI pipeline to the cloud. Which of the following services provides a private Git repository hosted on GCP?<p>a) Cloud Source Repositories</p><p>b) Cloud GitHub</p><p>c) Cloud Bitbucket</p><p>d) Cloud Build</p></li>
				<li>Your goal is to adopt SRE cultural practices in your organization. Select two options that could help to achieve this goal.<p>a) Launch and iterate.</p><p>b) Enable daily culture meetings.</p><p>c) Ad hoc team composition.</p><p>d) Create and communicate a clear message.</p></li>
			</ol>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>Answers</h1>
			<ol>
				<li value="1">(b) – User journey</li>
				<li>(d) – 99.90</li>
				<li>(d) - Good events / Valid events * 100</li>
				<li>(b) - SLI</li>
				<li>(c) – 100 – SLO</li>
				<li>(d) – BigQuery, Pub-Sub, Cloud Storage</li>
				<li>(b) – Deployment (forming continuous deployment)</li>
				<li>(b) – Compute Engine, GKE, App Engine, Cloud Functions</li>
				<li>(a) – Cloud Source Repositories</li>
				<li>(a) and (d) – Launch and iterate. Create and communicate a clear message.</li>
			</ol>
		</div>
	</body></html>