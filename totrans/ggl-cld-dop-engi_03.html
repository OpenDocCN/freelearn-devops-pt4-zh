<html><head></head><body>
		<div id="_idContainer029">
			<h1 id="_idParaDest-39"><em class="italic"><a id="_idTextAnchor038"/>Chapter 2</em>: SRE Technical Practices – Deep Dive</h1>
			<p><strong class="bold">Reliability</strong> is the most critical feature of a service or a system and should be aligned with business objectives. This alignment should be tracked constantly, meaning that the alignment needs measurement. <strong class="bold">Site reliability engineering</strong> (<strong class="bold">SRE</strong>) prescribes specific technical tools or practices that will help in measuring characteristics that define and track reliability. These tools are <strong class="bold">service-level agreements</strong> (<strong class="bold">SLAs</strong>), <strong class="bold">service-level objectives</strong> (<strong class="bold">SLOs</strong>), <strong class="bold">service-level indicators</strong> (<strong class="bold">SLIs</strong>), and <strong class="bold">error budgets</strong>.</p>
			<p>SLAs represent an external agreement with customers about the reliability of a service. SLAs should have consequences if violated (that is, the service doesn't meet the reliability expectations), and the consequences are often monetary in nature. To ensure SLAs are never violated, it is important to set thresholds. Setting these thresholds ensures that an incident is caught and potentially addressed before repeated occurrences of similar or the same events breach the SLA. These thresholds are referred to as SLOs.</p>
			<p>SLOs are specific numerical targets to define reliability of a system, and SLOs are measured using SLIs. SLIs are a quantitative measure of the level of service provided over a period. Error budgets are calculated based on SLOs (that are based on SLIs) and essentially are the inverse of availability, representing a quantifiable target as to how much a service can be unreliable. All these tools or technical practices need to work in tandem, and each one is dependent on the other. SRE uses these technical practices to maintain the balance between innovation and system reliability and thus achieve the eventual goal—<em class="italic">build reliable software faster</em>.</p>
			<p><a href="B15587_01_Final_ASB_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">DevOps, SRE, and Google Cloud Services for CI/CD</em>, introduced SRE technical practices—SLAs, SLOs, SLIs, and error budgets. This chapter will deep dive into these technical practices. In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Defining SLAs </li>
				<li>Defining reliability expectations via SLOs</li>
				<li>Exploring SLIs</li>
				<li>Understanding error budgets</li>
				<li>Eliminating toil through automation</li>
				<li>Illustrating the impact of SLAs, SLOs, and error budgets relative to SLI</li>
			</ul>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Defining SLAs</h1>
			<p>An SLA is a promise made to a <a id="_idIndexMarker160"/>user of a service to indicate that the availability and reliability of the service should meet a certain level of expectation. An SLA details a certain level of performance or expectation from the service.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Key jargon</h2>
			<p>There are certain components <a id="_idIndexMarker161"/>that go into defining which agreements can be considered as an SLA. These are referred to with specific jargon and are elaborated, as mentioned, in the following sections.</p>
			<h3>Service provider and service consumer</h3>
			<p>The party that represents the <a id="_idIndexMarker162"/>service provider and service consumer <a id="_idIndexMarker163"/>can differ based on the context and nature of the service. For a consumer-facing service such as <a id="_idIndexMarker164"/>video streaming or web browsing, a service consumer refers to the end user consuming the service and a service <a id="_idIndexMarker165"/>provider refers to the organization providing the service. On the other hand, for an enterprise-grade <a id="_idIndexMarker166"/>service such as a <strong class="bold">human resource</strong> (<strong class="bold">HR</strong>) planning system, a service consumer refers to the organization consuming the service and a service provider refers to the organization providing the service.</p>
			<h3>Service performance or expectations</h3>
			<p>An <a id="_idIndexMarker167"/>organization or end user <a id="_idIndexMarker168"/>consuming a <a id="_idIndexMarker169"/>service <a id="_idIndexMarker170"/>will have certain expectations in terms of service behavior, such as <strong class="bold">availability</strong> (or <strong class="bold">uptime</strong>), <strong class="bold">responsiveness</strong>, <strong class="bold">durability</strong>, and <strong class="bold">throughput</strong>.</p>
			<h3>Agreement – implicit or explicit</h3>
			<p>An agreement or contract can be either implicit or explicit in nature. An example of an implicit contract is a non-commercial service such as Google Search. Google has a goal to provide a fluid search <a id="_idIndexMarker171"/>experience to all its users but hasn't signed an explicit agreement with the end user. If Google misses its goal, then users will not have a <a id="_idIndexMarker172"/>good experience. A repeat of such incidents will impact Google's reputation, as users might prefer to use an alternate search engine.</p>
			<p>An example of an <a id="_idIndexMarker173"/>explicit contract is a commercial service such as <em class="italic">Netflix</em> or a paid enterprise-grade service such as <em class="italic">Workday</em>. In such scenarios, legal agreements are written <a id="_idIndexMarker174"/>that include consequences in case the service expectations are not met. Common consequences include financial implications or service credits.</p>
			<p>This concludes an introduction to key jargon with respect to SLAs. The next subsection elaborates on the blueprint for a well-defined SLA.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>Blueprint for a well-defined SLA</h2>
			<p>Having a well-defined SLA is critical to its success. Here are some factors that could be used as a <a id="_idIndexMarker175"/>blueprint for a well-defined SLA:</p>
			<ul>
				<li><strong class="bold">Involve the right parties</strong>: SLAs are usually written by people who are not directly tied to the implementation of the service and hence might result in promises that are difficult to measure. <em class="italic">SLAs should be set between business and product owners</em>. However, SRE recommends that before SLAs are set, product owners should work with development and SRE teams to identify the expectation threshold that can be delivered by the service. This ensures that product owners work closer with the implementation teams and know what's acceptable and what's not realistic from a service viewpoint.</li>
				<li><strong class="bold">Expectations need to be measurable</strong>: Service expectations such as availability or reliability characteristics in terms of stability, responsiveness, and durability should be quantifiable and measurable. Service expectations should be monitored by configuring monitoring systems and tracking specific metrics, and alerting should be configured to trigger alerts in case the expectations are violated.</li>
				<li><strong class="bold">Avoid ambiguity</strong>: The jargon used while defining SLAs can sometimes be ambiguous. For example, consider an SLA that promises a client-initiated incident to be resolved within <em class="italic">X</em> hours from the time it's reported. If the client or customer either provided the details long after the incident was first reported or never provided the <a id="_idIndexMarker176"/>details at all, then it is possible that the service provider will not be able to resolve the incident. In this situation, the SLA should clearly state the stipulations that qualify for not meeting the SLA, and such scenarios should be excluded. This provides a clearer approach.</li>
			</ul>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>SLIs drive SLOs, which inform SLAs</h2>
			<p>SLAs should focus on the minimum level of objectives a service should meet to keep customers happy. However, SLAs are strictly external targets and should not be used as internal targets by the implementation teams.</p>
			<p>To ensure that SLAs are not violated, implementation teams should have target objectives that reflect user's expectations from the service. The target objectives from implementation teams are used as internal targets, and these are generally stricter than the external targets that were potentially set by product teams. The internal targets are referred to as SLOs and are used as a prioritization signal to balance release velocity and system reliability. These internal targets need to be specifically measured and quantified at a given point of time. The measurement should be done using specific indicators that reflects users' expectations, and such indicators are referred to as SLIs.</p>
			<p>To summarize, for a service to <a id="_idIndexMarker177"/>perform reliably, the following criteria needs to be met:</p>
			<ul>
				<li>A specific condition should be met—represented by an SLI.</li>
				<li>The condition should be met for a specific period within a specific target range—represented by an SLO.</li>
				<li>If met, customers are happy, or else there will be consequences—represented by an SLA.</li>
			</ul>
			<p>Let's look at a hypothetical <a id="_idIndexMarker178"/>example. Consider a requirement where a user's request/response time falls within a minimum time period. A latency metric can be used to represent the user's expectation. A sample SLA in this scenario can state that every customer will get a response within 1,000 <strong class="bold">milliseconds</strong> (<strong class="bold">ms</strong>). In this case, the SLO for this SLA must be stricter and can be set at 800 ms.</p>
			<p>This completes the section on SLAs. We looked at the key constructs of an SLA, factors that could impact a well-defined SLA, and its impact on setting internal target objectives or SLOs, using specific indicators or SLIs that impact customer satisfaction. The next section transitions from an SLA to an SLO and its respective details.</p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/>Defining reliability expectations via SLOs</h1>
			<p>Service consumers (users) need a <a id="_idIndexMarker179"/>service to be reliable, and the reliability of the service can be captured by multiple characteristics such as availability, latency, freshness, throughput, coverage, and so on. From a user's perspective, a service is reliable if it meets their expectations. A critical goal of SRE is to measure everything in a quantitative manner. So, to measure, there is a need to represent user expectations quantitatively.</p>
			<p>SRE recommends a specific technical practice called a SLO to specify a target level (numerical) to represent these expectations. Each service consumer can have a different expectation. These expectations should be measurable, and for that they should be quantifiable over a period. SLOs help to define a consistent level of user expectations where the measured user expectation should be either within the target level or should be within a range of values. In addition, SLOs are referred to as internal agreements and are often stricter than SLAs promised to the end users. This ensures that any potential issues are resolved before their repetitive occurrence results in violating the SLA.</p>
			<p>SLOs are key to driving business decisions by providing a quantifiable way to balance release cadence of service features versus service reliability. This emphasis will be covered in the upcoming subsection.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/>SLOs drive business decisions</h2>
			<p>The need for revenue <a id="_idIndexMarker180"/>growth puts businesses under constant pressure to add new features and attract new users to their service. So, product managers usually dictate the requirement of these new features to development teams. Development teams build these requirements and hand them over to the operations team to stabilize. Development teams continue their focus on adding new features to a service rather than stabilizing existing ones. Operations teams tend to get overloaded since they are constantly firefighting to maintain the reliability of the existing service, in addition to rolling out new features. So, the most important question is: <em class="italic">If reliability is a feature of a system, then how can you balance reliability along with the release of other features?</em></p>
			<p>SLOs are the answer to how to maintain a balance between reliability and release velocity. SLOs allow us to define target levels for a reliable service. These target levels should be decided by all the stakeholders across an organization, including engineering teams (development and operations) and the product team. The agreed-upon target levels should reflect users' experiences while using the service. This allows monitoring systems to identify existing problems before users register complaints. SLOs should be treated more as a prioritization signal rather than an operational concern.</p>
			<p>SLOs should be used as a primary driver for decision making. SLOs represent a common language for all reliability conversations that is based on actual metrics. This will allow a business to decide when to release new features versus when to continue their focus on the reliability of an existing service. It will also allow operations teams to have a streamlined set of goals, preventing ad-hoc actions to run the service, and eventually avoiding <strong class="bold">operational overload</strong>.</p>
			<p>Operational overload is a <a id="_idIndexMarker181"/>term that describes the ongoing maintenance tasks that keep systems and services running at optimal performance. If a team is constantly interrupted by operations load and cannot make progress toward their key priorities, then the team is in a state of operational overload.</p>
			<p>The main reason for a team to be in a state of operational overload is a lack of consensus on the level of reliability a service should support. This lack of consensus is apparent from development teams' focus on adding new features to a service rather than stabilizing existing ones.</p>
			<p>SLOs must have strong <a id="_idIndexMarker182"/>backing from the executive team. In the case of missed SLO targets, there should be well-documented consequences that prioritize engineering efforts toward stabilizing the reliability of a service rather than working or releasing new features. SLOs are key to removing organization silos and create a sense of shared responsibility and ownership. SLOs drive incentives that organically invoke a thought process whereby developers start to care about service reliability and operators start to care about pushing new features out as quickly as possible. The recommended guidelines to set SLOs will be detailed in the upcoming subsection.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>Setting SLOs – the guidelines</h2>
			<p>The journey or process to identify the right SLOs for a service is very complex. There are multiple aspects or guidelines that need to be considered. Each of these aspects is critical to set or define an <a id="_idIndexMarker183"/>SLO for a service.</p>
			<h3>The happiness test</h3>
			<p>SLO targets are always driven by <a id="_idIndexMarker184"/>quantifiable and measurable user expectations called SLIs. <strong class="bold">The happiness test</strong> is a good starting point to set SLO targets for a service. As per the test, the service should have <a id="_idIndexMarker185"/>target SLOs that barely meet the availability and reliability expectations of the users, as the following applies:</p>
			<ul>
				<li>If the service meets the target SLOs, then users are happy.</li>
				<li>If the service misses the target SLOs, then users are sad.</li>
			</ul>
			<p>A target SLO for an average response time is defined as a range between 600 and 800 ms. If the average response time is less than 800 ms, then the service meets the target SLO, and users are happy. If the average response time is greater than 800 ms (even though it is less than stipulated in the SLA), then the service misses the target SLO and the users are sad. The following diagram illustrates an example where an SLA with respect to average response time for a request is set to 1,000 ms:</p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B15587_02_01.jpg" alt="Figure 2.1 – Happy versus sad users based on target SLOs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – Happy versus sad users based on target SLOs</p>
			<h3>100% reliability is the wrong target</h3>
			<p>Reliability is the <a id="_idIndexMarker186"/>most important feature of a <a id="_idIndexMarker187"/>service and reflects user happiness. However, setting 100% as the SLO or reliability target is not a realistic and reasonable goal for the following reasons:</p>
			<ul>
				<li><strong class="bold">Unable to improve or add new features to the service</strong>: Maintaining customer happiness is tricky. Customers always look forward to new feature sets but also expect that the stability of the existing service will not be impacted. Adding new features to a running service can have the potential to introduce some amount of risk or unreliability. If SLO targets for a service are set to 100%, this implies that the service is always reliable, resulting in zero downtime. As a result, the service cannot tolerate any risk in terms of downtime, and inherently new features cannot be added to the service. If new features are not added to the service, users will be unhappy and will move to competitors that offers similar services with more feature sets.</li>
				<li><strong class="bold">Technologically unfeasible</strong>: Running a service includes multiple components and dependencies. Some of these are internal, while some are external to the service. Though these components can be made redundant to achieve high availability, the dependencies result in complexities that would result in potential downtime. In addition, external components impact the availability of a service—for example, a mobile user cannot access a service if the mobile network provider has a dead zone at that specific location.</li>
				<li><strong class="bold">Exponentially expensive</strong>: For every additional nine of reliability, the cost increases by 10 times. It's expensive to make a reliable system even more reliable. Being reliable enough is the wiser option.</li>
			</ul>
			<h3>Understanding reliability targets and their implications</h3>
			<p>As 100% is the wrong <a id="_idIndexMarker188"/>reliability target, it is important to <a id="_idIndexMarker189"/>find the optimal reliability target where the <em class="italic">service is reliable enough</em> for the user and there is an opportunity to update or add new features to the service.</p>
			<p>Another perspective with which to look at reliability targets for a service is the amount of unreliability the service is willing to tolerate. Unreliability of the service is also referred to <a id="_idIndexMarker190"/>as the <strong class="bold">downtime</strong>.</p>
			<p>Let's consider some reliability targets, as follows:</p>
			<ul>
				<li>A reliability target of 99.9% (also known as three nines of reliability) over a 30-day period will result in a maximum possible downtime of 42 minutes. This is enough time for a monitoring system to detect the issue, and is also enough time for a human to get involved and probably mitigate or resolve the issue.</li>
				<li>A reliability target of 99.99% (also known as four nines of reliability) over a 30-day period will result in a maximum possible downtime of 4.2 minutes. This is enough time for a monitoring system to detect the issue but is not enough time for a human to get involved, but probably enough time for a system to self-heal a complete outage.</li>
				<li>A reliability target of 99.999% (also known as five nines of reliability) over a 30-day period will result in a maximum possible downtime of 24 seconds. This extremely short duration is not enough to detect an issue or even attempt to self-heal.</li>
			</ul>
			<p>The following table summarizes the possibility of detecting an issue and the possibility to self-heal based on a reliability target over a 30-day period:</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/B15587_02_Table-01.jpg" alt=""/>
				</div>
			</div>
			<p>To summarize, a <a id="_idIndexMarker191"/>reliability target should be set to a level that is realistic where an issue can be detected and addressed. An automated self-healing process is recommended over a human involvement—for example, redirecting traffic to a new <strong class="bold">availability zone</strong> (<strong class="bold">AZ</strong>) in case <a id="_idIndexMarker192"/>of an existing AZ failure.</p>
			<p>Setting a reliability target <a id="_idIndexMarker193"/>too low means that issues could frequently occur, leading to large duration of downtimes, and customers will be impacted regularly. Setting a reliability target too high at 99.999% or even 100% means that the system cannot practically fail, and that makes it difficult to add new features to the service or application.</p>
			<h3>Setting SLOs is an iterative process</h3>
			<p>Reliability is the most important feature of a service, and setting SLOs allow monitoring systems to capture how the <a id="_idIndexMarker194"/>service is performing. When setting SLOs for the first time, it's possible to set SLOs based on past performance, taking an assumption that users are happy to start with. SLIs for these SLOs are based on existing monitoring systems and are considered as an initial baseline that must be met. Such <a id="_idIndexMarker195"/>SLOs are known as <strong class="bold">achievable SLOs</strong>, and any misses below the initial base line should result in directing engineering efforts to focus on getting reliability back to the initial baseline.</p>
			<p class="callout-heading">How to get started with setting achievable SLOs</p>
			<p class="callout">Metrics to set achievable SLOs can either be taken from the load balancer or backfilled from the logs. Both approaches give an insight into historical performance.</p>
			<p>If SLOs need to be set in the absence of historical data or if historical data does not accurately reflect users' expectations, it is recommended to set an achievable target and then refine the target to closely match users' expectations and business needs. Such SLOs are <a id="_idIndexMarker196"/>known as <strong class="bold">aspirational SLOs</strong>. Monitoring systems will then use these metrics to track these SLOs.</p>
			<p>Once either achievable or aspirational SLOs are set, it's possible that new features are introduced to the service, but the probability for a service to be unreliable also increases. This can result in customers being unhappy even after meeting SLOs. This is an indication that monitoring metrics need to be revisited. SLOs need to be iteratively set and periodically re-evaluated. These metrics might have worked when originally set, but might not anymore.</p>
			<p>Here are a few possible scenarios that call for SLOs to be re-evaluated:</p>
			<ul>
				<li>New features were not considered in the metric calculation.</li>
				<li>Service usage is now extended from desktop to mobile.</li>
				<li>Service usage is now extended to multiple geographies.<p class="callout-heading">How frequently should SLOs be revisited or re-evaluated?</p><p class="callout">It's recommended that SLOs be revisited or re-evaluated every 6 to 12 months to ensure that defined SLOs continue to match business changes and users' expectations.</p></li>
			</ul>
			<p>In addition to <a id="_idIndexMarker197"/>periodically revisiting SLOs, there are scenarios where a different SLO—more precisely, a tighter SLO—can be used when a spike in traffic is anticipated. For example, during holiday shopping, many businesses expect a significant spike in traffic, and in such scenarios, businesses can come up with a temporary strategy of tightening the SLO from 99.9% to 99.99%. This means system reliability is prioritized over a need or urge to release new features. The SLO targets are set back to their original value (in this example, back to 99.9%) when normal traffic resumes.</p>
			<p>This completes the <a id="_idIndexMarker198"/>section on SLOs, with a deep insight into the need for reliability, setting reliability targets, and the way SLOs drive business decisions using SLIs. The next subsection introduces why SLOs need SLIs and is also a precursor before exploring SLIs in detail.</p>
			<h3>SLOs need SLIs</h3>
			<p>SLOs are specific <a id="_idIndexMarker199"/>numerical targets to define the reliability of a system. <em class="italic">SLOs are also used as a prioritization signal</em> to determine the balance between <a id="_idIndexMarker200"/>innovation and reliability. SLOs also help to differentiate happy and unhappy users. But the striking question is: <em class="italic">How do we measure SLOs</em>?</p>
			<p>SLOs are measured using SLIs. These are defined as a quantifiable measure of service reliability and specifically give an indication on how well a service is performing at a given moment of time. Service consumers have certain expectations from a service and SLIs are tied directly to those expectations. Examples of quantifiable SLIs are <strong class="bold">latency</strong>, <strong class="bold">throughput</strong>, <strong class="bold">freshness</strong>, and <strong class="bold">correctness</strong>. SLIs are expressed as a percentage of good events across valid events. SLOs are SLI targets aggregated over a period.</p>
			<p>We'll get into more details about SLIs in the next section, <em class="italic">Exploring SLIs</em>. This includes categorizing SLIs by types of user journeys and elaborating on the ways to measure SLIs.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor046"/>Exploring SLIs</h1>
			<p>An SLI is a quantitative <a id="_idIndexMarker201"/>measure of the level of service provided with respect to some aspect of service reliability. Aspects of a service are directly dependent on potential user journeys, and each user journey can have a different set of SLIs. Once the SLIs are identified per user journey, the next critical step is to determine how to measure the SLI. </p>
			<p>This section describes the details around how to identify the right measuring indicators or SLIs by categorizing user journeys, the equation to measure SLIs, and ways to measure SLIs.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>Categorizing user journeys</h2>
			<p>The reliability of a <a id="_idIndexMarker202"/>service is <a id="_idIndexMarker203"/>based upon the user's perspective. If a service offers multiple features, each feature will involve a set of user interactions or a sequence of tasks. This sequence of tasks that is critical to the user's experience offered by the service is defined as a <strong class="bold">user journey</strong>.</p>
			<p>Here are some examples of <a id="_idIndexMarker204"/>user journeys when using a video streaming service:</p>
			<ul>
				<li>Browsing titles under a specific category—for example, <em class="italic">fiction</em></li>
				<li>Viewing an existing title from a user library</li>
				<li>Purchasing an on-demand show or a live stream</li>
				<li>Viewing a live stream</li>
			</ul>
			<p>Each user journey can have a different expectation. These expectations can vary, from the speed at which the service responds to a user's request to the speed at which data is processed, to the freshness of the data displayed or to the durability at which data can be stored.</p>
			<p>There could be a myriad user journeys across multiple services. For simplicity, user journeys can be classified into two popular categories, as follows:</p>
			<ul>
				<li><strong class="bold">Request</strong>/<strong class="bold">response</strong> user journey</li>
				<li><strong class="bold">Data processing</strong>/<strong class="bold">pipeline</strong>-based user journey</li>
			</ul>
			<p>Each category defines specific characteristics. Each specific characteristic can represent an SLI type that defines the reliability of the service. These are specified in the following sections.</p>
			<h3>Request/response user journey </h3>
			<p>Availability, latency, and quality are the <a id="_idIndexMarker205"/>specific aspects or <a id="_idIndexMarker206"/>characteristics of SLIs that need to be evaluated as part of a request/response user journey.</p>
			<h4>Availability</h4>
			<p><strong class="bold">Availability</strong> is defined as the <a id="_idIndexMarker207"/>proportion of valid <a id="_idIndexMarker208"/>requests served successfully. It's critical for a service to be available to meet user's expectations.</p>
			<p>To convert an availability SLI definition into an implementation, a key choice that needs to be made is: <em class="italic">How to categorize requests served as successful</em>?</p>
			<p>To categorize requests served as successful, error codes can be used to reflect users' experiences of the service—for example, searching a video title that doesn't exist should not result in a <strong class="source-inline">500</strong> series error code. However, being unable to execute a search to check if a video title is present or not, should result in a <strong class="source-inline">500</strong> series error code.</p>
			<h4>Latency</h4>
			<p><strong class="bold">Latency</strong> is defined as the <a id="_idIndexMarker209"/>proportion of valid requests served faster than a threshold. It's an important indication of reliability when serving user-interactive <a id="_idIndexMarker210"/>requests. The system needs to respond within a timely fashion to consider it as interactive.</p>
			<p>Latency for a given request is calculated as the time difference between when the timer starts and when the timer stops. To convert a latency SLI definition into an implementation, a key choice that need to be made is: <em class="italic">How to determine a threshold to classify responses as fast enough</em>?</p>
			<p>To determine a threshold that classifies responses as fast enough, it's important to first identify the different categories of user interactions and set thresholds accordingly per category. There are three ways to <a id="_idIndexMarker211"/>bucketize user interactions, outlined as follows:</p>
			<ul>
				<li><strong class="bold">Interactive</strong>—Refers to interactions where a user waits for the system to respond after clicking an element. Can also be referred to as <strong class="bold">reads</strong>, and a typical threshold is 1,000 ms.</li>
				<li><strong class="bold">Write</strong>—Refers to user interactions that make a change to the underlying service. A typical threshold is 1,500 ms.</li>
				<li><strong class="bold">Background</strong>—Refers to user <a id="_idIndexMarker212"/>interactions that are asynchronous in nature. A typical threshold is 5,000 ms.</li>
			</ul>
			<h4>Quality</h4>
			<p><strong class="bold">Quality</strong> is defined as the <a id="_idIndexMarker213"/>proportion of valid requests <a id="_idIndexMarker214"/>served without degrading the service. It's an important indication on how a service can fail gracefully when its dependencies are unavailable.</p>
			<p>To convert a quality SLI into an implementation, a key choice that needs to be made is: <em class="italic">How to categorize if responses are served with degraded quality</em>? To categorize responses served with degraded quality, consider a distributed system with multiple backend servers. If the incoming request is served by all backend services, then the request is processed without service degradations. However, if the incoming request is processed by all backend servers except one, then it indicates responses with degraded quality.</p>
			<p>If a request is processed with service degradation, the response should be marked as degraded, or a counter should be used to increment the count of degraded responses. As a result, a quality SLI can be <a id="_idIndexMarker215"/>expressed as a <a id="_idIndexMarker216"/>ratio of <strong class="bold">bad events</strong> to <strong class="bold">total events</strong> instead <a id="_idIndexMarker217"/>of a <a id="_idIndexMarker218"/>ratio of <strong class="bold">good events</strong> to <strong class="bold">total events</strong>.</p>
			<p class="callout-heading">How to categorize a request as valid</p>
			<p class="callout">To categorize a request as valid, different methodologies can be used. One such method is to use <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) response <a id="_idIndexMarker219"/>codes. For example, <strong class="source-inline">400</strong> errors are client-side errors and should be discarded while measuring the reliability of the service. <strong class="source-inline">500</strong> errors are server-side errors and should be considered as failures from a service-reliability perspective.</p>
			<h3>Data processing/pipeline-based user journey</h3>
			<p>Freshness, correctness, coverage, and throughput <a id="_idIndexMarker220"/>are <a id="_idIndexMarker221"/>the specific aspects or characteristics of SLIs that need to be evaluated as part of a data processing/pipeline-based user journey. This is also applicable for batch-based jobs.</p>
			<h4>Freshness</h4>
			<p><strong class="bold">Freshness</strong> is defined as the proportion of valid data updated more recently than a threshold. Freshness is an <a id="_idIndexMarker222"/>important indicator of reliability while processing a batch of data, as it is possible that the output might <a id="_idIndexMarker223"/>become less relevant over a period of time. This is primarily because new input data is generated, and if the data is not processed regularly or rebuilt to continuously process in small increments, then the system output will not effectively reflect the new input.</p>
			<p>To convert a freshness SLI into an implementation, a key choice that needs be made is: <em class="italic">When to start and stop the timer to measure the freshness of data?</em> To categorize that the data processed is valid for SLI calculation, the correct source of input data or the right data processing pipeline job must be considered. For example, to calculate the freshness of weather-streaming content, data from a sports-streaming pipeline cannot be considered. This level of decision making can be achieved by implementing code and a rule-processing system to map the appropriate input source.</p>
			<p>To determine when to start and stop times to measure the freshness of data, it is important to include timestamps while generating and processing data. In the case of a batch processing system, data is considered fresh if the next set of data is not processed and generated. In other words, freshness is the time elapsed since the last time the batch processing system completed.</p>
			<p>In the case of an incremental streaming system, freshness refers to the age of the most recent record that has been fully processed. Serving stale data is a common way to degrade the response quality. Measuring stale data as degraded response quality is a useful strategy. If no user accesses the stale data, no expectations around the freshness of the data can have been missed. For this to be feasible, one option is to include a timestamp along with generating data. This allows the serving infrastructure to check the timestamp and accurately determine the freshness of the data.</p>
			<h3>Correctness</h3>
			<p><strong class="bold">Correctness</strong> is defined as the <a id="_idIndexMarker224"/>proportion of valid data producing a correct output. It's an <a id="_idIndexMarker225"/>important indication of reliability whereby processing a batch of data results in the correct output. To convert a correctness SLI into an implementation of it, a key choice that needs to be made is: <em class="italic">How to determine if the output records are correct</em>?</p>
			<p>To determine if the output records produced are correct, a common strategy is to use golden input data, also known as a set of input data that consistently produces the same output. This way, the produced output can be compared to the expected output from the golden input data.</p>
			<p>Proactive testing practices—both manual and automated—are strongly recommended to determine correctness.</p>
			<h4>Coverage</h4>
			<p><strong class="bold">Coverage</strong> is defined as the <a id="_idIndexMarker226"/>proportion of valid data processed successfully. It's an <a id="_idIndexMarker227"/>important indication of reliability, whereby the user expects that data will be processed and outputs will subsequently also be available.</p>
			<p>To convert a coverage SLI into an implementation, the choice that needs to be made is: <em class="italic">How to determine that a specific piece of data was processed successfully</em>? The logic to determine if a specific piece of data was processed successfully should be built into the service, and the service should also track the counts of success and failure.</p>
			<p>The challenge comes when a certain set of records that were supposed to be processed are skipped. The proportion of the records that are not skipped can be known by identifying the total number of records that should be processed.</p>
			<h4>Throughput</h4>
			<p><strong class="bold">Throughput</strong> is defined as the <a id="_idIndexMarker228"/>proportion of time where the data processing rate is faster than a threshold. It's an important indicator of reliability of a data <a id="_idIndexMarker229"/>processing system, whereby it accurately represents user happiness and operates continuously on streams or small batches of data.</p>
			<p>To convert a throughput SLI into an implementation, a key choice that needs to be made is: <em class="italic">What is the unit of measurement for data processing?</em> The most common unit of measurement for <a id="_idIndexMarker230"/>data processing is <strong class="bold">bytes per second</strong> (<strong class="bold">B/s</strong>).</p>
			<p>It is not necessary that all sets of inputs have the same throughput rate. Some inputs need to be processed faster and hence require higher throughput, while some inputs are typically queued and can be processed later.</p>
			<p class="callout-heading">SLIs recommended for a data storage-based user journey</p>
			<p class="callout">Systems processing data can also be further classified into systems responsible for only storing data. So, a <strong class="bold">data storage</strong> user-based journey is another possible classification of a user journey where availability, durability, and end-to-end latency are additional recommended SLIs. Availability refers to data that could be accessed on demand from a storage system. <strong class="bold">Durability</strong> refers to the <a id="_idIndexMarker231"/>proportions of records written that could be successfully read from a storage system as and when required at that moment. <strong class="bold">End-to-end latency</strong> refers to <a id="_idIndexMarker232"/>the time taken to process a data request, from ingestion to completion.</p>
			<p>The following table <a id="_idIndexMarker233"/>summarizes specific characteristics to represent an <a id="_idIndexMarker234"/>SLI type, grouped by the type of user journey:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/B15587_02_Table-02.jpg" alt=""/>
				</div>
			</div>
			<p>Given that there is a <a id="_idIndexMarker235"/>wide choice of SLIs to select from, Google recommends the following specific SLIs based on the type of systems:</p>
			<ul>
				<li><strong class="bold">User-facing serving systems</strong>: Availability (<em class="italic">Is it possible to respond to a request?</em>), latency (<em class="italic">How long will it take to respond?</em>), and throughput (<em class="italic">How many requests can be handled?</em>)</li>
				<li><strong class="bold">Storage systems</strong>: Latency (<em class="italic">How long does it take to read or write data?</em>), availability (<em class="italic">Can the data be accessed on demand?</em>), and <a id="_idIndexMarker236"/>durability (<em class="italic">Is the data still available when there is a need?</em>)</li>
				<li><strong class="bold">Big data systems</strong>: Throughput (<em class="italic">How much data can be processed?</em>) and end-to-end latency (<em class="italic">What is the time duration for data to progress from ingestion to completion?</em>)</li>
			</ul>
			<p>Given that we have looked at <a id="_idIndexMarker237"/>various factors that impact on determining <a id="_idIndexMarker238"/>SLIs specific to a user journey, the upcoming subsection will focus on the methodology and sources to measure SLIs.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>SLI equation</h2>
			<p>An SLI equation is defined as the <a id="_idIndexMarker239"/>proportion of valid events that were good, as illustrated here:</p>
			<p><img src="image/Formula_02_001.png" alt=""/></p>
			<p>This equation has the following properties:</p>
			<ul>
				<li>SLIs are expressed as a percentage and fall between 0% and 100%. 100% refers to everything working, and 0% refers to everything being broken.</li>
				<li>SLIs consistently translate to percentage reliability, SLOs, and error budgets, and are also <a id="_idIndexMarker240"/>key inputs to <strong class="bold">alerting logic</strong>.</li>
				<li>SLIs allow us to build common tooling to reflect the reliability of a service or system.</li>
				<li>Valid events are determined as follows: for requests related to <strong class="bold">HTTP Secure</strong> (<strong class="bold">HTTPS</strong>), valid events are <a id="_idIndexMarker241"/>determined based on request parameters or response handlers. Request parameters can include hostname or request path. For requests related to data processing systems, valid events refer to the selection of specific inputs that scope to a subset of data.</li>
			</ul>
			<p>This completes our summary of <a id="_idIndexMarker242"/>SLI equation and its associated properties. The next subsection details various popular sources to measure SLIs.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>Sources to measure SLIs</h2>
			<p>Identifying potential user journeys for a <a id="_idIndexMarker243"/>service is the first important step to identify SLIs. Once SLIs to measure are identified, the next key step is to measure the SLIs so that corresponding alerts can be put in place. The key question in this process is: <em class="italic">How to measure and where to measure</em>?</p>
			<p>There are five popular sources or ways to measure SLIs, outlined as follows:</p>
			<ul>
				<li>Server-side logs</li>
				<li>Application server</li>
				<li>Frontend infrastructure</li>
				<li>Synthetic clients</li>
				<li>Telemetry</li>
			</ul>
			<h3>Server-side logs</h3>
			<p>Here are some details on how <a id="_idIndexMarker244"/>information from <a id="_idIndexMarker245"/>server-side logs can be used to measure SLIs:</p>
			<ul>
				<li>Logs capture multiple request-response interactions over a long-running session. Stored logs give an option to get insights into historical performance of the service.</li>
				<li>If starting out with setting SLOs (<em class="italic">SLOs need SLIs</em>), for a service, log data can be used to analyze historical events, reconstruct user interactions, and retroactively backfill the SLI information.</li>
				<li>Complex logic can be added to the code itself where good events are clearly identified, and the information is captured in logs. (<em class="italic">This requires significant engineering efforts.</em>)</li>
			</ul>
			<p>Here are details of the <a id="_idIndexMarker246"/>limitations of using server-side logs to measure SLIs:</p>
			<ul>
				<li>If an SLI needs to be used to trigger an emergency response, the time between the event occurrence and the event actually being measured should be minimal. Given that logs need to be ingested and processed, capturing SLIs from logs will add significant latency.</li>
				<li>Log-based SLIs cannot capture the requests that did not make it to the application server.</li>
			</ul>
			<h3>Application server</h3>
			<p>Here are details on how information from the <a id="_idIndexMarker247"/>application server can be used to measure SLIs:</p>
			<ul>
				<li>Metrics captured at the <a id="_idIndexMarker248"/>application server are known as application-level metrics. These metrics are helpful in diagnosing issues with respect to the application.</li>
				<li>Application metrics can capture the performance of individual requests without measurement latency. In addition, these events could be aggregated over time.</li>
			</ul>
			<p>Here are details of the <a id="_idIndexMarker249"/>limitations of using the application server to measure SLIs:</p>
			<ul>
				<li>Application metrics cannot capture complex multi-request user journeys.</li>
				<li>Application-based SLIs cannot capture requests that do not make it to the application server.<p class="callout-heading">What is a complex multi-request user journey?</p><p class="callout">A complex multi-request user journey <a id="_idIndexMarker250"/>will include a sequence of requests, which is a core part of a user consuming a service such as searching a product, adding a product to a shopping cart, and completing a purchase. Application metrics cannot capture metrics for the user journey but can capture metrics related to individual steps.</p></li>
			</ul>
			<h3>Frontend infrastructure</h3>
			<p>Here are details of how <a id="_idIndexMarker251"/>information from frontend infrastructure can be used to measure SLIs:</p>
			<ul>
				<li>Frontend infrastructure <a id="_idIndexMarker252"/>refers to load balancers. This could be a vendor-based load balancer (such as <em class="italic">F5</em>) or a cloud-provider based load balancer (such as <em class="italic">Google Cloud Load Balancer</em>).</li>
				<li>Most of the distributed applications use a load balancer, and this is the first point of interaction for a user's request before it is sent to the actual application. This makes the load balancer the closest point to the user and fewer requests go unmeasured. </li>
				<li>Cloud providers typically capture multiple metrics for the incoming requests to the load balancer out of the box. This information might be readily available, including historical data too. If the capture of data was not configured for some reason, it can be easily configured. Either way, information will be available without investing engineering efforts (<em class="italic">as compared to capturing metrics from application logs</em>).</li>
				<li>Load balancers capture metrics related to requests that do not make it to the application server.</li>
			</ul>
			<p>Here are details of the <a id="_idIndexMarker253"/>limitations of using a frontend infrastructure to measure SLIs:</p>
			<ul>
				<li>Load balancers can either be <strong class="bold">stateful</strong> or <strong class="bold">stateless</strong>. If stateless, then the load balancers cannot track user sessions and hence cannot be used to capture metrics tied to user interactions.</li>
				<li>Given that load balancers typically act as a <strong class="bold">traffic cop</strong>, routing user requests to application servers that are capable of handling the requests, load balancers do not inherently have control over the response data returned by the application. Instead, load balancers are dependent on the application to set the metadata accurately on the response envelope.</li>
				<li>The dependency on the <a id="_idIndexMarker254"/>application to set the right metadata on the response envelope is a conflict of interest because it is the same application that is generating the metrics.</li>
			</ul>
			<h3>Synthetic clients</h3>
			<p>Here are details of how <a id="_idIndexMarker255"/>information from synthetic clients can be used to measure SLIs:</p>
			<ul>
				<li>Synthetic clients <a id="_idIndexMarker256"/>provide <strong class="bold">synthetic monitoring</strong>, a monitoring technique <a id="_idIndexMarker257"/>that monitors the application by emulating or simulating user interactions based on a recorded set of transactions.</li>
				<li>Synthetic clients can emulate user interactions that constitute a user journey from a point outside the infrastructure, and hence can verify the responses.</li>
			</ul>
			<p>Here are details of the <a id="_idIndexMarker258"/>limitations of using synthetic clients to measure SLIs:</p>
			<ul>
				<li>Synthetic clients simulate a user's behavior, and hence it's an approximation.</li>
				<li>Synthetic clients need complex integration tests that could cover multiple edge cases, thus resulting in a significant engineering effort.</li>
				<li>Synthetic clients need maintenance to add new user simulations if new user behavior patterns emerge that were not previously accounted for.</li>
			</ul>
			<h3>Telemetry</h3>
			<p>Telemetry refers to remote <a id="_idIndexMarker259"/>monitoring from multiple data sources and is not restricted to capture metrics related to application health, but can be extended to capture security analytics such as suspicious user activity, unusual <a id="_idIndexMarker260"/>database activity, and so on. Here are details of how information from telemetry can be used to measure SLIs:</p>
			<ul>
				<li>Instrumenting clients to implement telemetry metrics helps to measure the reliability of third-party integration <a id="_idIndexMarker261"/>systems such as a <strong class="bold">content delivery network</strong> (<strong class="bold">CDN</strong>).</li>
				<li>O<strong class="bold">penTelemetry</strong> is the <a id="_idIndexMarker262"/>most popular instrumentation mechanism to capture traces and metrics. It <a id="_idIndexMarker263"/>replaces <strong class="bold">OpenTracing</strong> and <strong class="bold">OpenCensus</strong>, which <a id="_idIndexMarker264"/>were individually focused <a id="_idIndexMarker265"/>on capturing tracing and metrics respectively.<p class="callout-heading">What is OpenTelemetry?</p><p class="callout"><strong class="bold">OpenTelemetry</strong> is a unified standard for service instrumentation. It provides a set of <strong class="bold">application programming interfaces</strong> (<strong class="bold">APIs</strong>)/libraries <a id="_idIndexMarker266"/>that are vendor-agnostic and standardizes how to collect and send data to compatible backends. OpenTelemetry is an open source project that is <a id="_idIndexMarker267"/>part of the <strong class="bold">Cloud Native Computing Foundation</strong> (<strong class="bold">CNCF</strong>).</p></li>
			</ul>
			<p>Here are details of the <a id="_idIndexMarker268"/>limitations of using telemetry to measure SLIs:</p>
			<ul>
				<li>Ingesting metrics from different sources increases latency and will pose the same issues encountered when capturing metrics from processing logs, thus this is not a good fit for triggering emergency responses.</li>
				<li>If telemetry is implemented in-house, it requires a significant engineering effort. However, there are vendors that provide the same capability, but there is a risk of vendor lock-in.</li>
			</ul>
			<p>This completes an elaboration of five different sources to measure SLIs. Given that each source has its own limitations, there is no best source to measure SLIs. In most cases, a combination of sources is always preferred. For example, if an organization is getting started with their SRE practice, usage of server-side logs to backfill SLIs and frontend infrastructure to readily <a id="_idIndexMarker269"/>use the metrics from the load balancer might be a good way to start. It can later be extended to capturing metrics from the application server, but given it doesn't support complex multi-request user journeys, an organization can later shift to the use of telemetry or synthetic clients based on their need. The next subsection summarizes a few SLI best practices as recommended by Google.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>SLI best practices (Google-recommended)</h2>
			<p>It's a tedious task for an <a id="_idIndexMarker270"/>organization that would like to start on their SRE journey, and a key aspect of this journey is to identify, define, and measure SLIs. Here is a list of Google-recommended best practices:</p>
			<ul>
				<li><strong class="bold">Prioritize user journeys</strong>: Select user journeys that reflect features offered by the service and the user's affinity to those features.</li>
				<li><strong class="bold">Prioritize user journeys from the selected list</strong>: The user journey to purchase or watch a streaming event is more important than rating a video.</li>
				<li><strong class="bold">Limit number of SLIs</strong>: Keep it to three to five SLIs per user journey. More SLIs will make it complex to manage for the operators.</li>
				<li><strong class="bold">Collect data via frontend infrastructure</strong>: Collecting at load balancer level is closer to a user's experience and requires less engineering effort.</li>
				<li><strong class="bold">Aggregate similar SLIs</strong>: Collect data over a period. Convert metric information captured into rate, average, or percentile.</li>
				<li><strong class="bold">Keep it simple</strong>: Complex metrics require significant engineering effort but might also increase response time. If response time increases, then the metric will not be suitable for emergency situations.</li>
			</ul>
			<p>This completes a comprehensive deep dive on SLIs, with a focus on categorizing user journeys, identifying specific aspects that impact a user journey, various sources to measure, and recommended best practices to define SLIs. To summarize, there are four critical steps for <a id="_idIndexMarker271"/>choosing SLI, listed as follows:</p>
			<ol>
				<li value="1">Choose an SLI specification based on a suitable user journey.</li>
				<li>Refine a specification into a detailed SLI implementation.</li>
				<li>Walk through the user journey and identify implementation gaps.</li>
				<li>Set aspirational SLO targets based on business needs.</li>
			</ol>
			<p>The upcoming section focusses on error budgets, which are used to achieve reliability by maintaining a balance with release velocity.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor051"/>Understanding error budgets</h1>
			<p>Once SLOs are set <a id="_idIndexMarker272"/>based on SLIs specific to user journeys that define system availability and reliability by quantifying users' expectations, it is important to understand how unreliable the service is allowed to be. This acceptable level of unreliability or unavailability is called an <strong class="bold">error budget</strong>.</p>
			<p>The unavailability or unreliability of a service can be caused due to several reasons, such as planned maintenance, hardware failure, network failures, bad fixes, and new issues introduced while introducing new features.</p>
			<p>Error budgets put a quantifiable target on the amount of unreliability that could be tracked. They create a common incentive between development and operations teams. This target is used to balance the urge to push new features (<em class="italic">thereby adding innovation to the service</em>) against ensuring service reliability.</p>
			<p>An error budget is basically the inverse of availability, and it tells us how unreliable your service is allowed to be. If your SLO says that 99.9% of requests should be successful in a given quarter, your error budget allows 0.1% of requests to fail. This unavailability can be generated because of bad pushes by the product teams, planned maintenance, hardware failures, and other issues:</p>
			<p><img src="image/Formula_01_005.png" alt=""/></p>
			<p>Here's an example. If SLO says that 99.9% of requests should be successful in a given quarter, then 0.1% is the error budget.</p>
			<p>Let's calculate the error budget, as follows:</p>
			<p><em class="italic">If SLO = 99.9%, then error budget = 0.1% = 0.001</em></p>
			<p><em class="italic">Allowed downtime per month = 0.001 * 30 days/month * 24 hours/day * 60 minutes/hour = 43.2 minutes/month</em></p>
			<p>This introduces the <a id="_idIndexMarker273"/>concept of an error budget. The next subsection introduces the concept of an error budget policy and details the need for executive buy-in with respect to complying with the error budget policy.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/>Error budget policy and the need for executive buy-in</h2>
			<p>If reliability is the most important feature of a system, an <strong class="bold">error budget policy</strong> represents how a <a id="_idIndexMarker274"/>business balances reliability against other features. Such a policy helps a business to take appropriate actions when the reliability of the service is at stake. The key to defining an error budget policy is to actually decide the SLO for the service. If the service is missing SLO targets, which means the error budget policy is violated, then there should be consequences. These consequences should be enforced by <a id="_idIndexMarker275"/>generating executive buy-in. Operations teams should have an influence on the impact of the development team's practices by halting the release of new features if the service is getting very close to exhausting the error budget or has exceeded the error budget. </p>
			<p>Error budgets can be thought of as funds that are meant to be spent across a given time period. These funds can be spent on releasing new features, rolling out software updates, or managing incidents. An error budget is basically the inverse of availability, and it tells us how unreliable your service is allowed to be. If your SLO says that 99.9% of requests should be successful in a given quarter, your error budget allows 0.1% of requests to fail. This unavailability can be generated because of bad pushes by the product teams, planned maintenance, hardware failures, and so on. The next subsection lists out the characteristics of an effective error budget policy.</p>
			<h3>Characteristics of an effective error budget policy</h3>
			<p>An <a id="_idIndexMarker276"/>error budget policy should have the following characteristics:</p>
			<ul>
				<li>An overview of the service</li>
				<li>A list of intended goals</li>
				<li>A list of non-goals; also referred to as a potential requirement that has been specifically excluded</li>
				<li>A list of <em class="italic">DO</em>s and <em class="italic">DON'T</em>s based on whether a service performs above its SLO or misses its SLO</li>
				<li>A list of consequences when a service misses its SLO</li>
				<li>A detailed outage policy that defines the criteria to call out an incident and a need for a follow-up to ensure the incident doesn't happen again</li>
				<li>A clearly laid-out escalation policy that identifies the decision maker in the event of a disagreement</li>
			</ul>
			<p>The preceding list of characteristics clearly calls out the fact that it is extremely necessary to have well-documented SLOs to define an effective error budget policy. This will be discussed in the next subsection.</p>
			<h3>Error budgets need well-documented SLOs</h3>
			<p>The key to defining an <a id="_idIndexMarker277"/>error budget is to actually to decide the SLOs for the service. SLOs clearly differentiate between reliable services and unreliable services, thus extending it to identify happy versus unhappy users. SLOs should be clearly defined without any ambiguity and should be agreed by product owners, developers, SREs, and executives.</p>
			<p>In addition to implementing an SLO and configuring a monitoring system to alert on the SLO, the following characteristics are recommended for a well-documented SLO in terms of metadata:</p>
			<ul>
				<li>The need for an SLO and thought process behind the specific SLO target</li>
				<li>A list of owners for SLOs</li>
				<li>The impact in case of SLO miss</li>
				<li>SLIs tied with the SLOs</li>
				<li>Any specific events <a id="_idIndexMarker278"/>that are included or excluded from the calculation</li>
				<li>Version control of the SLO documentation (<em class="italic">this gives an insight into reasons for changing SLOs as they get refined over a period</em>)</li>
			</ul>
			<p>The next subsection discusses multiple options to set error budgets.</p>
			<h3>Setting error budgets</h3>
			<p>Error budgets can be <a id="_idIndexMarker279"/>thought as funds that are meant to be spent across a given time period. These funds can be spent on releasing new features or rolling out software updates or managing incidents. But this raises several questions, such as the following:</p>
			<ul>
				<li>What is the right time to spend error budgets? At the start of the month or the end of the month?</li>
				<li>What happens if the error budget gets exhausted and there is an emergency?</li>
				<li>What happens if the error budget is not exhausted? Can it be carried over?</li>
			</ul>
			<p>Different strategies can be used to determine the right time to spend error budgets within a time period. Let's assume the time period is 28 days. There could be three potential options, listed as follows:</p>
			<ul>
				<li><strong class="bold">Option #1</strong> is to spend a portion of the error budget at the start (of the 28 days) to push new features or updates and use the remaining error budget for potential reliability maintenance in the event of an incident.</li>
				<li><strong class="bold">Option #2</strong> is to spend an error budget to push new features or updates after elapsing half of the time period (say, 14 days), since it gives an idea on how much error budget was used in the first half for maintaining system reliability.</li>
				<li><strong class="bold">Option #3</strong> is to spend any remaining error budget toward the latter part of the time period in pushing new features or updates to ensure focus is on system reliability till then.</li>
			</ul>
			<p>Any of the preceding options or a combination of the three can be used to define a dynamic release process, and it all depends on what developers and operations team agree upon based on current business needs and past performance. The dynamic release process can be implemented by setting alerts based on error budget exhaustion rates.</p>
			<p>If the error budget of a service is exhausted but the development team needs to push a new feature as an exception scenario, SRE provisions this <a id="_idIndexMarker280"/>exception using <strong class="bold">silver bullets</strong>.</p>
			<p>Envision silver bullets as tokens that could be given to the operations team to facilitate an exception to release new features when having exceeded the error budget. These tokens reside with a senior stakeholder and the development team needs to pitch the need to use silver bullets to the stakeholder. A fixed number of such tokens are given to the stakeholder and these are not carried over to the next time period. In addition to the use of silver bullets, SRE also recommends the use of rainy-day funds whereby a certain amount of the error budget is additionally provided to handle unexpected events.</p>
			<p>Error budgets <a id="_idIndexMarker281"/>cannot be carried over to the next time period. So, in all practicality, the goal is to spend the error budget by the end of the time period. Constantly exhausting error budgets and repeated use of silver bullets should call for a review, where engineering efforts should be invested in making the service more reliable by improving the service code and by adding integration tests.</p>
			<p>The use of dynamic release cadence, error budget exhaustion rates, silver bullets, and rainy-day funds are advanced techniques prescribed by SRE to manage error budgets. This completes the subsection on defining characteristics for an effective error budget policy, listing out characteristics for well-documented SLOs and discussing options to set error budgets. The next subsection details factors that are critical in ensuring that a service stays reliable and does not exhaust the error budget.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>Making a service reliable</h2>
			<p>When a service exhausts its <a id="_idIndexMarker282"/>error budget or repeatedly comes close to exhausting the same, engineering teams should focus on making a service reliable. This raises the next obvious question: <em class="italic">How can the engineering teams make a service more reliable to meet users' expectations?</em> </p>
			<p>To get deeper insights into this, it's critical to consider the following key factors essential to determine the <a id="_idIndexMarker283"/>potential impact on the service:</p>
			<ul>
				<li><strong class="bold">Time to detect</strong> (<strong class="bold">TTD</strong>)—Defined as the <a id="_idIndexMarker284"/>difference in time from when the issue first occurred to the time that the issue was first observed or reported. Example: If an issue occurred at 10 a.m. but was reported or observed at 10:30 a.m., then the TTD in this scenario is 30 minutes.</li>
				<li><strong class="bold">Time to resolve</strong> (<strong class="bold">TTR</strong>)—Defined as the <a id="_idIndexMarker285"/>difference in time from when the issue was first observed or reported to the time that the issues was resolved. Example: If an issue was first observed or reported at 10:30 a.m. but was resolved at 10:45 a.m., then the TTR in this scenario is 15 minutes.</li>
				<li><strong class="bold">Time to fail</strong> (<strong class="bold">TTF</strong>)—Defined as <a id="_idIndexMarker286"/>how frequently the service is expected to fail. TTF is <a id="_idIndexMarker287"/>also known as <strong class="bold">Time Between Failures</strong>, or <strong class="bold">TBF</strong>.</li>
				<li><strong class="bold">Impact %</strong>—Percentage of impact in terms of impacted users or impacted functional areas.</li>
				<li>The expected impact is proportional to the following expression:</li>
			</ul>
			<p><img src="image/Formula_02_003.png" alt=""/></p>
			<p>Reliability can be improved by implementing the following options:</p>
			<ul>
				<li>Reducing detection time: Reduce TTD</li>
				<li>Reducing repair time: Reduce TTR</li>
				<li>Reduce impact %: Reduce the impacted users/functional areas</li>
				<li>Reduce <a id="_idIndexMarker288"/>frequency: Increasing TTF</li>
				<li>Operational improvement</li>
			</ul>
			<p>Let's discuss each option in detail, next.</p>
			<h3>Reduce detection time (TTD)</h3>
			<p>TTD can be reduced by the <a id="_idIndexMarker289"/>following approaches:</p>
			<ul>
				<li>Add automated alerting that alerts a user rather than the user manually detecting an issue by noticing an abnormality from the metrics dashboard.</li>
				<li>Add monitoring to measure SLO compliance. This helps to know how quickly the error budget is being consumed or whether the service is performing within its target SLOs.</li>
			</ul>
			<h3>Reduce repair time (TTR)</h3>
			<p>TTR can be reduced by the <a id="_idIndexMarker290"/>following approaches:</p>
			<ul>
				<li>Develop a playbook that makes it easier to parse and collate server debug logs. This will help the onsite engineers to quickly address the problem at hand. If a new pattern was detected, then the playbook should be updated.</li>
				<li>Automate manual tasks such as increasing disk space to an acceptable percentage of current disk space, draining zone or rerouting traffic.</li>
				<li>Collect relevant information for a specific scenario, which will save time for the on-call team and will allow them to get a head start with their investigation.</li>
			</ul>
			<h3>Reduce impact %</h3>
			<p>Impact % can be <a id="_idIndexMarker291"/>reduced by the following approaches:</p>
			<ul>
				<li>Roll out a new feature to a limited number of users through a percentage-based rollout within a given amount of time. This reduces the impact percentage to that specific user group. The rollout percentage can be gradually increased from 0.1% of users to 1%, then later to 10%, and eventually 100%. In this way, the releases are staggered.</li>
				<li>Engineer a service to <a id="_idIndexMarker292"/>run in a degraded mode during a failure, such as switching to allow read-only actions and not writes, thus reducing the impact.</li>
			</ul>
			<h3>Reduce frequency</h3>
			<p>Frequency can be <a id="_idIndexMarker293"/>reduced by the following approaches:</p>
			<ul>
				<li>Run the service or application in multiple zones or regions. Direct the traffic away from the zone or region that failed to an alternate working zone or region.</li>
				<li>Create a self-healing automated script that reduces the impact and frequency, but also report the issue so that it can be addressed later.</li>
			</ul>
			<h3>Operational improvements</h3>
			<p>Here are some options from an <a id="_idIndexMarker294"/>operational standpoint to make a service reliable:</p>
			<ul>
				<li>Increase availability by adding redundancy and thereby remove single points of failure.</li>
				<li>Identify a common category between failures that can point to a specific region or a specific set of customers who consume a majority of the error budget.</li>
				<li>Standardize the infrastructure or minimize the differences to achieve similar results when testing a service against running it in production.</li>
				<li>Use design patterns that allow the service to be rolled back in case of an issue.</li>
				<li>Create alerts by tracking the error budget burndown rate.</li>
				<li>Use post-mortems to identify the issues at hand and create actionable items to fix those issues.</li>
			</ul>
			<p>This completes a complete deep dive into potential factors that needs to be considered and feasible options that can be <a id="_idIndexMarker295"/>implemented to make a service reliable, thus not consuming the error budget. The next subsection summarizes the section on error budgets.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Summarizing error budgets</h2>
			<p>Error budgets can be <a id="_idIndexMarker296"/>summarized by the following key pointers:</p>
			<ul>
				<li>Error budgets help development and SRE teams balance release velocity and stability. Management buys into SLO and gives executive backing.</li>
				<li>Error budgets need SLOs, and SLOs need SLIs to monitor service reliability.</li>
				<li>The difference between the actual and targeted SLO is calculated to determine if it is below the error budget, and if so, the release of new features is allowed.</li>
				<li>If not, engineering efforts should be focused on the reliability of the service.</li>
				<li>An error budget policy is an <a id="_idIndexMarker297"/>effective way to implement the concepts of an error budget.</li>
			</ul>
			<p>This completes the section on error budgets, with a deep dive into multiple aspects that include how to define an effective error budget policy, how to set error budgets, the impact of having an executive buy-in that helps to make a service reliable, and how to effectively balance the release velocity of new features.</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor055"/>Eliminating toil through automation</h1>
			<p><strong class="bold">Toil</strong> was introduced in <a href="B15587_01_Final_ASB_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">DevOps, SRE, and Google Cloud Services for CI/CD</em>, and is defined as the work tied to a production service where the characteristic of that work is manual, repetitive, automatable, tactical, lacks enduring value, and linearly grows with the service. Toil is <a id="_idIndexMarker298"/>often confused with overhead, but overhead refers to administrative work that includes email, commute, filing expense reports, and attending meetings. Toil can be both good and bad—it really depends on the amount of toil. </p>
			<p>Here are some of the <a id="_idIndexMarker299"/>positive sides of performing toil, but in very short and limited amounts:</p>
			<ul>
				<li>Produces a sense of gratification or a sense of accomplishment</li>
				<li>Can act as a low-stress or low-risk activity</li>
				<li>Can be used to train new recruits, especially providing them a chance to learn by being hands-on with the system to learn the inner workings</li>
			</ul>
			<p>However, excessive toil can lead to the <a id="_idIndexMarker300"/>following problems or issues:</p>
			<ul>
				<li><strong class="bold">Career stagnation</strong>: Solving production issues is gratifying, but solving the same issue manually in a repetitive manner doesn't help from a career standpoint. This takes away learning time and intent away from the SRE engineer, leading to stagnation.</li>
				<li><strong class="bold">Burnout and boredom</strong>: Excessive toil leads to burnout and boredom. An SRE engineer will be bored doing the same task every day. Sometimes, manual tasks might also be tedious and laborious, leading to burnout.</li>
				<li><strong class="bold">Low feature velocity</strong>: If the SRE team is engaged in lot of toil, then they will have less time to work on releasing new features, thus leading to lower feature velocity and reduced release cadence.</li>
				<li><strong class="bold">Wrong precedence</strong>: If the SRE team engages in more toil than required, it's possible that development teams will make SRE teams do further toil, especially on items that need to be addressed truly by the development team instead to remove the root cause. This will create confusion on the role of the SRE engineer.</li>
			</ul>
			<p>All the aforementioned problems or issues can potentially lead to attrition, as SRE engineers might not be happy with their everyday work and might look elsewhere for better work and challenges. SRE <a id="_idIndexMarker301"/>recommends that toil should be bounded and that an SRE engineer should not work more than 50% of their time on toil. Anything more than 50% blurs the line between an SRE engineer and a system administrator. SRE engineers are recommended to spend the remaining 50% on supporting engineering teams in achieving reliability goals for the service.</p>
			<p>Eliminating toil allows SRE engineers to add service features to improve the reliability and performance of the service. In addition, focus can continue to remain on removing toil as identified, thus clearing out a backlog of any manual repetitive work. SRE encourages the use of engineering concepts to remove manual work. This also allows SRE engineers to scale up and manage services better than a development or an operations team.</p>
			<p>SRE recommends removing toil through automation. Automation provides consistency and eliminates the occurrence of oversights and mistakes. Automation helps to perform a task much faster than humans and can also be scheduled. Automation also ensures to prevent a problem before reoccurring. Automation is usually done through code, and this also provides a chance for SRE engineers to use engineering concepts to implement the required logic.</p>
			<p>This concludes the section on <a id="_idIndexMarker302"/>toil: its characteristics, the good and bad aspects, and the advantages of using automation to eliminate toil. The next section illustrates how SLAs, SLOs, and error budgets are impacted based on SLI performance.</p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor056"/>Illustrating the impact of SLAs, SLOs, and error budgets relative to SLI</h1>
			<p>In this section, we will go <a id="_idIndexMarker303"/>through two hands-on scenarios to illustrate how SLO targets are met or missed based on SLI performance over time. SLOs <a id="_idIndexMarker304"/>performance will have direct impact on SLAs and error budgets. Changes in the error budget will specifically <a id="_idIndexMarker305"/>dictate the priority between the release of new features versus service reliability. For ease of explanation, a 7-day period is taken as the measure of time (ideally, a 28-day period is preferred).</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>Scenario 1 – New service features introduced; features are reliable; SLO is met</h2>
			<p>Here are the expectations for this scenario:</p>
			<ul>
				<li><strong class="bold">Expected SLA</strong>—95%</li>
				<li><strong class="bold">Expected SLO</strong>—98%</li>
				<li><strong class="bold">Measured SLI</strong>—Service availability or uptime</li>
				<li><strong class="bold">Measure duration</strong>—7 days</li>
			</ul>
			<p>Given that the anticipated SLO for service is 98%, here is how the allowed downtime or error budget is calculated (you can use this downtime calculator for reference: <a href="https://availability.sre.xyz">https://availability.sre.xyz</a>):</p>
			<ul>
				<li><strong class="bold">Error budget</strong> = <em class="italic">100% - SLO = 100% - 98% = 2%</em></li>
				<li><strong class="bold">Allowed downtime for 7 days with 98% availability</strong> = <em class="italic">3.36 hours = 3.36 * 60 = 201.6 minutes</em> </li>
			</ul>
			<p>So, if total downtime across 7 days is less than 201.6 minutes, then the service is within SLO compliance of 98%, else the service is out of SLO compliance.</p>
			<p>Now, let's illustrate how the <a id="_idIndexMarker306"/>SLO is impacted based on SLI measurements. Assume that new features are introduced for the service (across the 7-day period) and the features are stable, with minimal issues.</p>
			<p>The following table represents <a id="_idIndexMarker307"/>the SLI measurements of availability, respective <a id="_idIndexMarker308"/>downtime based on SLI performance, and the reduction in error budget on a per-day basis:</p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B15587_02_Table-03.jpg" alt=""/>
				</div>
			</div>
			<p>The following screenshot represents the SLI performance for service uptime (top) and the error budget burndown rate (bottom) based on the values from the preceding table:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B15587_02_02.jpg" alt="Figure 2.2 – Illustration of SLI performance and error budget burndown rate&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – Illustration of SLI performance and error budget burndown rate</p>
			<p>Here are some <a id="_idIndexMarker309"/>critical observations:</p>
			<ul>
				<li>Remaining error <a id="_idIndexMarker310"/>budget = 84.95 minutes, which is less than 201.6 minutes. Hence, the SLO is in compliance and the SLA is met.</li>
				<li>The SLO performance <a id="_idIndexMarker311"/>can be calculated based on the remaining error budget. Since the remaining error budget is 84.95 minutes, then SLO performance is 99.25%.</li>
				<li>The introduction of new features did not unevenly or suddenly decrease the error budget.</li>
			</ul>
			<p>This completes a detailed illustration of a scenario where the SLO is met based on the SLI performance over a 7-day period. The next scenario illustrates the opposite, where the SLO is missed based on SLI performance.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Scenario 2 – New features introduced; features are not reliable; SLO is not met</h2>
			<p>Here are the expectations for this scenario:</p>
			<ul>
				<li><strong class="bold">Expected SLA</strong>—95%</li>
				<li><strong class="bold">Expected SLO</strong>—98%</li>
				<li><strong class="bold">Measured SLI</strong>—Service availability or uptime</li>
				<li><strong class="bold">Measure duration</strong>—7 days</li>
			</ul>
			<p>As calculated in <em class="italic">Scenario 1</em>, the allowed downtime for a 98% SLO is 201.6 minutes. So, the SLO is out of compliance if downtime is greater than 201.6 minutes over a 7-day period. </p>
			<p>Now, let's illustrate how the <a id="_idIndexMarker312"/>SLO is impacted based on SLI measurements. Assume that new features are introduced for the service (across the 7-day period) but <a id="_idIndexMarker313"/>the introduced features are not stable, causing major issues resulting in longer downtimes.</p>
			<p>The following table represents <a id="_idIndexMarker314"/>the SLI measurements of availability, respective downtime based on SLI performance, and the reduction in error budget on a per-day basis:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B15587_02_Table-04.jpg" alt=""/>
				</div>
			</div>
			<p>The following screenshot represents the SLI performance for service uptime (left-hand side) and the error budget burndown rate (right-hand side) based on the values from the preceding table:</p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B15587_02_03.jpg" alt="Figure 2.3 – Illustration of SLI performance and error budget burndown rate&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – Illustration of SLI performance and error budget burndown rate</p>
			<p>Here are some <a id="_idIndexMarker315"/>critical observations:</p>
			<ul>
				<li>Remaining <a id="_idIndexMarker316"/>error budget = 0 minutes on <a id="_idIndexMarker317"/>day 4. So, the SLO is not in compliance.</li>
				<li>Total downtime across 7-day period is 253.44 minutes.</li>
				<li>The corresponding SLO performance is approximately at 97.48, which is below 98%.</li>
				<li>The SLA is violated since the SLO is not in compliance. This will result in consequences.</li>
				<li>The SRE team should not add new features after day 3 and instead focus on system reliability.</li>
			</ul>
			<p>This brings an end to a detailed rundown of <em class="italic">Scenario 2</em>. This completes our illustration of how SLAs, SLOs, and error budgets are impacted based on SLI performance. This also means we have reached the end of this chapter.</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor059"/>Summary</h1>
			<p>In this chapter, we discussed in detail the key SRE technical practices: SLAs, SLOs, SLIs, error budgets, and eliminating toil. This included several critical concepts such as factors that can be used for a well-defined SLA, providing guidelines to set SLOs, categorizing user journeys, detailing sources to measure SLIs along with their limitations, elaborating on error budgets, detailing out factors that can make a service reliable, understanding toil's consequences, and elaborating on how automation is beneficial to eliminate toil. These concepts allow us to achieve SRE's core principle, which is to maintain the balance between innovation and system reliability and thus achieve the eventual goal: <em class="italic">build reliable software faster</em>.</p>
			<p>In the next chapter, we will focus on concepts required to track SRE technical practices: monitoring, alerting, and time series. These concepts will include monitoring as a feedback loop, monitoring sources, monitoring strategies, monitoring types, alerting strategies, desirable characteristics of an alerting system, time-series structures, time-series cardinality, and metric types of time-series data. </p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor060"/>Points to remember</h1>
			<p>Here are some important points to remember:</p>
			<ul>
				<li>100% is an unrealistic reliability target.</li>
				<li>Log-based SLIs and ingesting telemetry adds latency.</li>
				<li>App metrics are not good for complex use journeys.</li>
				<li>SLOs must be set based on conversations with engineering and product teams.</li>
				<li>If there is no error budget left, the focus should be on reliability.</li>
				<li>TTD is the time taken to identify that an issue exists or is reported.</li>
				<li>TTR is the time taken to resolve an issue.</li>
				<li>To improve the reliability of a service, reduce TTD, reduce TTR, reduce impact %, and increase TTF/TBF.</li>
				<li>SLIs should have a predictable relationship with user happiness and should be aggregated over time.</li>
				<li>User expectations are strongly tied to past performance.</li>
				<li>Setting values for SLIs and SLOs should be an iterative process.</li>
				<li>Advanced techniques to manage error budgets are dynamic release cadence, setting up error budget exhaustion rates, rainy-day funds, and the use of silver bullets.</li>
				<li>Identify repetitive tasks that contribute to toil and automate them.</li>
			</ul>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor061"/>Further reading</h1>
			<p>For more information on <strong class="bold">Google Cloud Platform's</strong> (<strong class="bold">GCP's</strong>) approach toward DevOps, read the following articles:</p>
			<ul>
				<li><strong class="bold">SRE</strong>: <a href="https://landing.google.com/sre/">https://landing.google.com/sre/</a></li>
				<li><strong class="bold">SRE fundamentals</strong>: <a href="https://cloud.google.com/blog/products/gcp/sre-fundamentals-slis-slas-and-slos">https://cloud.google.com/blog/products/gcp/sre-fundamentals-slis-slas-and-slos</a></li>
				<li><strong class="bold">SRE YouTube playlist</strong>: <a href="https://www.youtube.com/watch?v=uTEL8Ff1Zvk&amp;list=PLIivdWyY5sqJrKl7D2u-gmis8h9K66qoj">https://www.youtube.com/watch?v=uTEL8Ff1Zvk&amp;list=PLIivdWyY5sqJrKl7D2u-gmis8h9K66qoj</a></li>
			</ul>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/>Practice test</h1>
			<p>Answer the following questions:</p>
			<ol>
				<li value="1">Which from the following indicates work that is not tied to a production service?<p>a) Toil </p><p>b) Manual</p><p>c) Overhead</p><p>d) Automation</p></li>
				<li>Which of the following represents <em class="italic">an explicit or implicit contract with your users that includes consequences of meeting or missing the SLOs</em>?<p>a) SLI</p><p>b) SLO</p><p>c) SLA</p><p>d) Error budget</p></li>
				<li>Which of the following combinations represent metrics that are typically tracked as part of a request/response journey?<p>a) Availability, latency, and durability</p><p>b) Latency, coverage, throughput, and availability</p><p>c) Coverage, correctness, and quality</p><p>d) Availability, latency, and quality</p></li>
				<li>Select an option that represents SRE recommendation in terms of the time that an SRE engineer is allowed to spend on toil:<p>a) 25%-55%</p><p>b) 45%-60%</p><p>c) 50%-75%</p><p>d) 30%-50%</p></li>
				<li>Which of the following is the least realistic (preferred) option to target reliability for a service as an SLO?<p>a) 99.9%</p><p>b) 99.99%</p><p>c) 99.999% </p><p>d) 100%</p></li>
				<li>In terms of best practice, which option is correct with respect to the number of SLIs recommended per user journey?<p>a) 2 to 3</p><p>b) No specific limit</p><p>c) 3 to 5</p><p>d) 5 to 7</p></li>
				<li>An e-commerce web application is processing customer purchases through requests and storing the sales transactions in a database. The goal is to ensure that the forecasted sales numbers are based on the latest sales numbers. Which of the following should be selected as SLIs for the e-commerce application (<em class="italic">select two</em>)?<p>a) Database—Availability.</p><p>b) Database—Durability.</p><p>c) Database—Freshness.</p><p>d) Web application—Availability.</p><p>e) Web application—Durability.</p><p>f) Both the database and web application should be available. Production apps should have full availability.</p></li>
				<li>Which out of the following represents a precise numerical target for system availability?<p>a) SLA</p><p>b) SLO</p><p>c) SLI</p><p>d) Error budget</p></li>
				<li>Which of the following represents a direct measurement of service behavior?<p>a) SLA</p><p>b) SLO</p><p>c) SLI</p><p>d) Error budget</p></li>
				<li>Which of the following is the best suitable source to backfill an SLI?<p>a) Application server</p><p>b) Frontend infrastructure</p><p>c) Synthetic clients</p><p>d) None of the above</p></li>
			</ol>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor063"/>Answers</h1>
			<ol>
				<li value="1">(c) Overhead.</li>
				<li>(c) SLA.</li>
				<li>(d) Availability, latency, and quality.</li>
				<li>(d) 30%-50%. The recommended amount of toil should not exceed 50%.</li>
				<li>(d) 100%.</li>
				<li>(c) 3 to 5.</li>
				<li>(a) and (d): Both the database and web application should be available as these are production applications.</li>
				<li>(b) SLO.</li>
				<li>(c) SLI.</li>
				<li>(d) None of the above. The exact answer is server-side logs.</li>
			</ol>
		</div>
	</body></html>