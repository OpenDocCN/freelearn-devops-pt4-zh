- en: Running a Prometheus Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to get our hands on some Prometheus configurations. This chapter will
    explore the core component of the stack, you will be introduced to common patterns
    of usage and full setup process scenarios under virtual machines and containers.
    This will allow you to truly validate the knowledge you've gathered so far and
    provide you with real examples to test your knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: 'In brief, the following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Deep dive into the Prometheus configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Prometheus in a standalone server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Prometheus in Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deep dive into the Prometheus configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key features of Prometheus is, owing to incredibly sane default configurations,
    that it can scale from a quick test running on a local computer to a production-grade
    instance, handling millions of samples per second without having to touch almost
    any of its many knobs and dials. Having said that, it is very useful to know what
    configuration options are available to be able to get the most value out of Prometheus.
  prefs: []
  type: TYPE_NORMAL
- en: There are two main types of configuration on a Prometheus server—command-line
    flags and operating logic that provided through configuration files. Command-line
    flags control the parameters that cannot be changed at runtime, such as the storage
    path or which TCP port to bind to, and need a full server restart to apply any
    change done at this level. The configuration files control runtime configuration,
    such as scrape job definitions, rules files locations, or remote storage setup.
    In the following sections, we're going to explore both of these types of configurations
    in depth.
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus startup configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While running a Prometheus server with no startup configuration can be good
    enough for local instances, it is advisable to configure a couple of basic command-line
    flags for any serious deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, Prometheus has almost 30 command-line flags for tweaking
    several aspects of its operational configuration, grouped by the following namespaces:
    `config`, `web`, `storage`, `rules`, `alertmanager`, `query`, and `log`. The `--help`
    flag does a good job of describing most options, but it can be a bit terse in
    a few places, so we''re going to highlight the ones that are either important
    for any deployment or whose function is not readily apparent.'
  prefs: []
  type: TYPE_NORMAL
- en: The config section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing that is usually important to set is the Prometheus configuration
    file path, through the `--config.file` flag. By default, Prometheus will look
    for a file named `prometheus.yml` in the current working directory. While this
    is great for local tests, production deployments usually place server binaries
    and configuration files in their own paths, and so this flag is commonly needed.
    As a side note, this and a storage directory are the only hard requirements for
    starting a Prometheus server; without a configuration file, Prometheus refuses
    to start.
  prefs: []
  type: TYPE_NORMAL
- en: The storage section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following the same logic from the previous section, the `--storage.tsdb.path` flag
    should be set to configure the base path to the data storage location. This defaults
    to `data/` on the current working directory, and so it is advisable to point this
    to a more appropriate path—possibly to a different drive/volume, where data can
    be safely persisted and I/O contention can be mitigated. To note that NFS (AWS
    EFS included) is not supported, as it doesn't support the POSIX locking primitives
    needed for safe database files management. Placing the Prometheus data storage
    directory in a network share is also ill-advised as transient network failures
    would impact the monitoring system's ability to keep functioning - just when you'd
    need it the most.
  prefs: []
  type: TYPE_NORMAL
- en: The Prometheus local storage can only be written to by a single Prometheus instance
    at a time. To make sure this is the case, it uses a lock file in the data directory.
    On startup, it tries to lock this file using OS-specific system calls, and will
    refuse to start if the file is already locked by another process.
  prefs: []
  type: TYPE_NORMAL
- en: There can be an edge case to this behavior; when using persistent volumes to
    store the data directory, there is a chance that, when relaunching Prometheus
    as another container instance using the same volume, the previous instance might
    not have unlocked the database. This problem would make a setup of this kind susceptible
    to race conditions. Luckily, there is the `--storage.tsdb.no-lockfile` flag, which
    can be used in exactly this type of situation. Be warned though that, in general
    (and namely, in most Prometheus deployments), it is a bad idea to disable the
    lock file, as doing so makes unintended data corruption easier.
  prefs: []
  type: TYPE_NORMAL
- en: The web section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to configure what address users are going to utilize to get
    to the Prometheus server. The `--web.external-url` flag sets this base URL so
    that weblinks generated both in the web user interface and in outgoing alerts
    link back to the Prometheus server or servers correctly. This might be the DNS
    name for a load balancer/reverse proxy, a Kubernetes service, or, in the simplest
    deployments, the publicly accessible, fully qualified domain name of the host
    running the server. For completeness, and as stated in the official documentation,
    a URL path can also be supplied here when Prometheus is behind some layer seven
    reverse proxy with content switching (also referred to as location-based switching
    or URL prefix routing).
  prefs: []
  type: TYPE_NORMAL
- en: The Prometheus server behaves as a conventional `*nix` daemon by reloading its
    configuration file (along with rules files) when it receives a `SIGHUP`. However,
    there are situations where sending this signal isn't convenient (for example,
    when running in a container orchestration system such as Kubernetes or using custom-built
    automation) or even impossible (when running Prometheus on Windows). In these
    situations, the `--web.enable-lifecycle` flag can be used to enable the `/-/reload`
    and `/-/quit` HTTP endpoints, which can be used to control, reload, and shut down,
    respectively. To prevent accidental triggering of these endpoints, and because
    a `GET` wouldn't be semantically correct,  a `POST` request is needed. This flag
    is turned off by default as unfettered access to these endpoints pose a security
    concern.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the `--web.enable-admin-api` flag is also turned off by default for
    the same reason. This flag enables HTTP endpoints that provide some advanced administration
    actions, such as creating snapshots of data, deleting time series, and cleaning
    tombstones.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed in [Chapter 3](8f575e82-4713-45c7-8eb3-0af3e0e61ed3.xhtml),
    *Setting Up a Test Environment*, the official Prometheus tarballs also bring two
    additional directories, `consoles` and `console_libraries`. These are needed to
    enable the native dashboarding capabilities of Prometheus, which are often overlooked.
    These directories contain some preconfigured dashboards (referred to as consoles)
    and support template libraries, written in the Go templating language. Prometheus
    can be configured to load these by using the `--web.console.templates` and `--web.console.libraries`
    flags. After that, those dashboards will be available at the `/consoles` endpoint
    (a link will be available in the main web UI if an index.html file exists).
  prefs: []
  type: TYPE_NORMAL
- en: The query section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is all about tuning the inner workings of the query engine. Some
    are fairly straightforward to understand, such as how long a given query can run
    before being aborted (`--query.timeout`), or how many queries can run simultaneously
    (`--query.max-concurrency`).
  prefs: []
  type: TYPE_NORMAL
- en: However, two of them set limits that can have non-obvious consequences. The
    first is `--query.max-samples`, which was introduced in Prometheus 2.5.0, that
    sets the maximum number of samples that can be loaded onto memory. This was done
    as a way of capping the maximum memory the query subsystem can use (by using it
    together with `--query.max-concurrency`) to try and prevent the dreaded *query-of-death*—a
    query that loaded so much data to memory that it made Prometheus hit a memory
    limit and then killing the process. The behavior post 2.5.0 is that if any query
    hits the limit set by this flag (which defaults to 50,000,000 samples), the query
    simply fails.
  prefs: []
  type: TYPE_NORMAL
- en: The second one is `--query.lookback-delta`. Without going into too much detail
    regarding how PromQL works internally, this flag sets the limit of how far back
    Prometheus will look for time series data points before considering them stale.
    This implicitly means that if you collect data at a greater interval than what's
    set here (the default being five minutes), you will get inconsistent results in
    alerts and graphs, and as such, two minutes is the maximum sane value to allow
    for failures.
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus configuration file walkthrough
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The configuration file we mentioned in the previous section declares the runtime
    configuration for the Prometheus instance. As we will see, everything related
    to scrape jobs, rule evaluation, and remote read/write configuration is all defined
    here. As we mentioned previously, these configurations can be reloaded without
    shutting down the Prometheus server by either sending a `SIGHUP` to the process,
    or by sending an HTTP POST request to the `/-/reload` endpoint (when `--web.enable-lifecycle`
    is used at startup).
  prefs: []
  type: TYPE_NORMAL
- en: 'At a high level, we can split the configuration file into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '`global`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scrape_configs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alerting`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rule_files`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remote_read`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remote_write`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once again, the official Prometheus documentation includes the schema for this
    file, which is written in YAML format. In this chapter, we will introduce an example
    configuration for us to analyze, but only go into detail on the `global` and `scrape_configs`
    sections. The alerting and `rule_files` are covered in [Chapter 9](9aa1e3da-13cf-4051-845d-1d1c924ef47b.xhtml)*,
    Defining Alerting and Recording Rules*, while `remote_read` and `remote_write`
    are explained in [Chapter 14](1fb2aaff-5fe3-44ed-9df8-1cd27f383906.xhtml), *Integrating
    Long-Term Storage with Prometheus*.
  prefs: []
  type: TYPE_NORMAL
- en: A configuration file with the most comprehensive list of options available can
    be found in the Prometheus project GitHub repository, located in the following
    address: [https://github.com/prometheus/prometheus/blob/v2.9.2/config/testdata/conf.good.yml](https://github.com/prometheus/prometheus/blob/v2.9.2/config/testdata/conf.good.yml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our example configuration looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, it may seem a bit dense, but for clarity's sake, we're making
    some configurations whose defaults values don't usually need to be touched explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine each section in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Global configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `global` configuration defines the default parameters for every other configuration
    section, as well as outlining what labels should be added to metrics going to
    external systems, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Duration can only be integer values and can only have one unit. This means that
    trying to use 0.5 minutes instead of 30 seconds or one minute 30 seconds instead
    of 90 seconds will be considered a configuration error.
  prefs: []
  type: TYPE_NORMAL
- en: '`scrape_interval` sets the default frequency targets that should be scraped.
    This is usually between 10 seconds and one minute, and the default `1m` is a good
    conservative value to start. Longer intervals are not advisable as the lost granularity
    (especially in gauges) starts to impact the ability to properly alert on issues
    and makes querying finicky as you need to be aware that some shorter intervals
    might not return data. Additionally, considering the default loopback delta of
    five minutes (mentioned in the command-line flags), any `scrape_interval` longer
    than 150 seconds (2 minutes 30 seconds) will mean every time series for a given
    target will be considered stale if a single scrape fails.'
  prefs: []
  type: TYPE_NORMAL
- en: '`scrape_timeout` defines how long Prometheus should wait by default for a response
    from a target before closing the connection and marking the scrape as failed (10
    seconds if not declared). Bear in mind that even though it is expected that targets
    respond to scrapes fairly quickly, the guidelines for metrics exposition mandate
    that collection should happen at scrape time and not cached, which means there
    can be some exporters that take a bit longer to respond.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to `scrape_interval`, `evaluation_interval` sets the default frequency
    recording and alerting rules are evaluated. For sanity, both should have the same.
    This is going to be discussed in more detail in [Chapter 9](9aa1e3da-13cf-4051-845d-1d1c924ef47b.xhtml),
    *Defining Alerting and Recording Rules*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5423912c-df8a-4cab-9a10-8e20e264621d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Representation of scrape intervals and evaluation intervals inside
    Prometheus'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, `external_labels` allows you to set label name/value pairs that are
    added to time series or alerts going to external systems, such as Alertmanager,
    remote read and write infrastructure, or even other Prometheis through federation.
    This functionality is usually employed to uniquely identify the source of a given
    alert or time series; therefore, it is common to identify the region, datacenter,
    shard, or even the instance identifier of a Prometheus server.
  prefs: []
  type: TYPE_NORMAL
- en: 'As per the official documentation, the plural form of *Prometheus* is *Prometheis*:
    [https://prometheus.io/docs/introduction/faq/#what-is-the-plural-of-prometheus](https://prometheus.io/docs/introduction/faq/#what-is-the-plural-of-prometheus).'
  prefs: []
  type: TYPE_NORMAL
- en: Scrape configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though Prometheus accepts an empty file as a valid configuration file,
    the absolute minimum useful configuration needs a `scrape_configs` section. This
    is where we define the targets for metrics collection, and if some post-scrape
    processing is needed before actual ingestion.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the configuration example we introduced previously, we defined two scrape
    jobs: `prometheus` and `blackbox`. In Prometheus terms, a scrape is the action
    of collecting metrics through an HTTP request from a targeted instance, parsing
    the response, and ingesting the collected samples to storage. The default HTTP
    endpoint used in the Prometheus ecosystem for metrics collection is aptly named
    `/metrics`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A collection of such instances is called a **job**. The instances in a job
    are usually all running copies of the same service, and so there is usually a
    job definition for each kind of monitored software, though this can be a bit different
    when using service discovery, as we''ll see in [Chapter 12](5360e790-3884-4eeb-aaa1-8aad21dc6c1e.xhtml),
    *Choosing the Right Service Discovery*. The combination of instance and job identify
    the source of the collected samples, and so these are automatically added as labels
    to the ingested data, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A scrape job definition needs at least a `job_name` and a set of targets. In
    this example, `static_configs` was used to declare the list of targets for both
    scrape jobs. While Prometheus supports a lot of ways to dynamically define this
    list, `static_configs` is the simplest and most straightforward method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Analyzing the `prometheus` scrape job in detail, we can see that both `scrape_interval`
    and `scrape_timeout` can be redeclared at the job level, thus overriding the global
    values. As stated before, having varying intervals is discouraged, so only use
    this when absolutely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: By setting `sample_limit`, Prometheus will ensure that whatever value was set,
    it will be collected per scrape by not ingesting those samples when their number
    goes over the limit and marking the scrape as failed. This is a great safety net
    for preventing a cardinality explosion from a target outside of your control impacting
    the monitoring system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last relevant configuration here is `metric_relabel_configs`. This is a
    powerful rewrite engine that allows a collected metrics'' identity to be transformed,
    or even dropped, before being saved to storage. The most common use cases for
    this feature is to blacklist a set of misbehaving metrics, dropping labels without
    compromising a metric''s identity, or changing labels to better match Prometheus
    semantics. Ideally, `metric_relabel_configs` should be used as a stopgap while
    the problems aren''t fixed at the source and so using it often can be a red flag.
    The preceding example is using `metric_relabel_configs` to drop every metric that
    starts with `expensive_metric_`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'While we are going to explore blackbox exporter in depth in the next chapter,
    its configuration is used here to help explain the following important configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`metrics_path` is used to change which endpoint Prometheus should scrape'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scheme` defines whether HTTP or HTTPS is going to be used when connecting
    to targets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params` allows you to define a set of optional HTTP parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, the most important and most useful configuration is `relabel_configs`.
    It provides the same powerful semantics as `metric_relabel_configs`, but it has
    a very different function; `relabel_configs` is used to manipulate the scrape
    job''s list of targets. The relabel actions are performed in sequence, and so
    it is possible to create or modify labels and then use those in the next action.
    By default, a target will have a couple of labels that have been generated automatically
    and that will be available for relabeling: the `job` label will be set to the
    `job_name` configuration,  `__address__` label will be created with the target''s
    host and port, `__scheme__` and `__metrics_path__` labels will be set to their
    respective configurations (`scheme` and `metrics_path`), and a `__param_<name>` label
    will be created for each of the parameters defined in the `params` configuration.
    Additionally, `__meta_` labels will be available when using a service discovery
    mechanism, as we''ll see in [Chapter 12](5360e790-3884-4eeb-aaa1-8aad21dc6c1e.xhtml),
    *Choosing the Right Service Discovery*. If the `instance` label is not set by
    the end of the relabeling phase, `__address__` will be used to set it. Labels
    that start with two underscores (`__`) will be removed when the relabeling phase
    ends. As a final note, if you need temporary labels during the relabeling process,
    always use the `__tmp` prefix, as it is guaranteed to not overlap with Prometheus
    internal labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the blackbox exporter, this functionality is very useful as
    we need to send the probe requests to the exporter, which will then use the `target`
    `GET` parameter to perform its job. So, going through the example, for each target
    specified in `static_configs`, this configuration does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Copies the target's address into a `__param_target` label, which will be used
    to set the `target` `GET` parameter in the scrape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copies the content of this newly created label into the `instance` label so
    that it is explicitly set, bypassing the automatic generation based on the `__address__`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replaces the `__address__` label with the address of the blackbox exporter so
    that scrapes are done to the exporter and not directly to the target we specified
    in `` `static_configs` ``
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While `relabel_configs` is used to rewrite the target list (it runs before the
    scrape is performed), `metric_relabel_configs` is used to rewrite labels or drop
    samples (it runs after the scrape is performed).
  prefs: []
  type: TYPE_NORMAL
- en: The example configuration used in this section is for demonstration purposes
    only. For example, there should be no need to set `sample_limit` on Prometheus
    itself, or to drop metrics without a concrete reason.
  prefs: []
  type: TYPE_NORMAL
- en: A very useful metric that must be introduced is the `up` metric. This metric
    exposes the status of a scrape job. It includes, at least, a label with the correspondent
    job name and another with the targeted instance. In its sample, we can have the
    value `1` for a successful scrape or `0` for a failed one.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we're going to start managing Prometheus in different deployment environments.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Prometheus in a standalone server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we previously went through several configuration definitions, we're now ready
    to put them to practice by managing a standalone instance of Prometheus. In these
    examples, we'll be exposing several configurations while providing an environment
    to validate them.
  prefs: []
  type: TYPE_NORMAL
- en: Server deploy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a new instance of Prometheus, move into the correct repository path,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that no other test environments are running and spin up this chapter''s
    environment, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After a few moments, the new instance will be available for inspection, and
    the Prometheus web interface will be accessible at `http://192.168.42.10:9090`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration inspection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the newly created instance running, it''s time to log in using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can validate the startup configuration in use by looking into its `systemd`
    unit file by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following excerpt shows the flags that are currently in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration file for Prometheus itself, as defined by the `--config.file` flag,
    can be reviewed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the configuration in use is similar to the one that was presented
    previously, in the Prometheus configuration file walkthrough. We can now validate
    a couple of concepts we mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to `metric_relabel_configs` in the `prometheus` job, we can use two of
    Prometheus'' per-scrape metrics to determine the number of samples being dropped
    by our configuration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`scrape_samples_scraped`: This metric provides the total of samples collected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scrape_samples_post_metric_relabeling`: This metric provides the total of
    samples available after the metric relabeling takes place'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we subtract these two metrics, we obtain the number of dropped samples (in
    our example, this is all of the metric names starting with `go_`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5186397-edfd-4ac5-a0b5-e7ee7282c009.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2: Number of metrics being dropped
  prefs: []
  type: TYPE_NORMAL
- en: 'We can confirm the outcome of the configuration relabeling, which in our example,
    generates the instance labels under the `blackbox` job:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81d9eaa7-bc18-414f-b81d-3a879252e4bd.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3: Instance labels generated by *relabel_configs*
  prefs: []
  type: TYPE_NORMAL
- en: You can validate the Prometheus configuration by using a provided utility called
    `promtool`, which will be thoroughly dissected on [Chapter 8](19357d8c-dfcf-4497-ae80-4761f6633d14.xhtml),* Troubleshooting
    and Validation*. When reloading Prometheus with a new configuration, you also
    have the option to look at the `prometheus_config_last_reload_successful` metric
    to assess whether the configuration was successfully parsed and applied.
  prefs: []
  type: TYPE_NORMAL
- en: Cleanup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you''ve finish testing, just make sure you''re inside the `chapter05/` path
    and execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry too much – you can easily spin up the environment again if you so
    require.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Prometheus in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes is the first project to graduate from the CNCF and is currently the
    de facto standard for container orchestration. Early on, Heapster was widely used
    as a monitoring solution that came out-of-the-box with Kubernetes. It started
    out as a tool to send monitoring data to external systems but then grew to become
    a monitoring system itself. However, it didn't take long for Prometheus to become
    the de facto standard monitoring system for Kubernetes clusters. Nowadays, most
    of the components that make up a Kubernetes cluster have native Prometheus instrumentation.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we'll go into how to integrate Prometheus in a Kubernetes
    environment by, employing examples based on the Kubernetes project and the Prometheus
    Operator project.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the complete source code of the Kubernetes project and the Prometheus
    Operator at the following addresses, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/kubernetes/kubernetes](https://github.com/kubernetes/kubernetes)
    and [https://github.com/coreos/prometheus-operator](https://github.com/coreos/prometheus-operator).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that you have all the software requirements that were defined in [Chapter
    3](8f575e82-4713-45c7-8eb3-0af3e0e61ed3.xhtml), *Setting Up a Test Environment*,
    available in their specific versions, particularly the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Minikube
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: kubectl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although this approach is quite far from being advised, it provides the foundations
    to better understand and troubleshoot a Prometheus server running in Kubernetes.
    In this example, we'll create a Prometheus deployment using a ConfigMap to define
    the server configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ensure that there''s no instance of `minikube` running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`minikube delete` is a destructive instruction, so be sure you save your work
    before proceeding.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a new `minikube` instance with the following specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When the previous command finishes, a new Kubernetes environment should be
    ready to be used. You may access its dashboard by using the following command,
    which will open the Kubernetes dashboard address in your default browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To proceed with our example, ensure that you move into the correct repository
    path, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of organization, we''ll be creating a new namespace called `monitoring`
    using the following manifest with the help of `kubectl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the previous manifest using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can validate the successful namespace creation on the Kubernetes dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29f1589b-449a-4300-9623-28fcd8d16f23.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4: Kubernetes dashboard - monitoring namespace
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus server deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our new namespace available, it''s time to create a very simple Prometheus
    configuration and save it on a ConfigMap using the following manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the previous manifest using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to start a new deployment of Prometheus, making sure we mount
    the previously configured ConfigMap into the pod we are deploying. The Deployment
    object is configured with the following metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The Prometheus container will be started with its configuration file and data
    directory coming from volume mounts, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `config-volume` volume is created from a ConfigMap, while the `prometheus-data`
    volume is created with an empty directory. This can be seen in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the previous manifest using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can follow the deployment status using this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We should look at the logs of our Prometheus instance using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'After a successful deployment, we''re ready to assign a new service to our
    instance, choosing `NodePort` so we can access it without requiring port-forwarding,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the previous manifest using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And you''re ready to check your new Prometheus service using the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This will open your browser on the Prometheus service endpoint. You can now
    check the running configuration and targets using the Prometheus web interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d66fcb0-d114-413a-924c-5b1b5a193991.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5: Prometheus initial configuration
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have Prometheus running in Kubernetes, we can start adding targets
    for it to scrape. In the next section, we will have a look at how you can achieve
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Adding targets to Prometheus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the sake of this example, we'll deploy yet another service and add it to
    our Prometheus server, going step by step on how to do it. We'll use a small *Hello
    World* type of application called *Hey* for our setup.
  prefs: []
  type: TYPE_NORMAL
- en: The code for the *Hey* application can be inspected at [https://github.com/kintoandar/hey](https://github.com/kintoandar/hey).
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps are quite similar to the deployment of the Prometheus server. Start
    by creating a new deployment for *Hey* using the following manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the previous manifest using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can follow the deployment status using this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can validate the logs of our *Hey* instance using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After a successful deployment, we''re ready to assign a new service to our
    instance choosing `NodePort` so that we can access it without requiring port-forwarding,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the previous manifest using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you''re ready to check your new *Hey* service like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Prometheus is statically managed in our example, we need to add the new
    *Hey* target for metric collection. This means that we need to change the Prometheus
    ConfigMap to reflect the newly added service, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the previous manifest using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If you check the running Prometheus configuration, nothing has changed; this
    is because a new deployment wasn''t triggered. For that to happen, something needs
    to change on the deployment definition, so we just change the version annotation
    and apply the new manifest like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can follow the deployment status using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'After a moment, a new deployment will take place, changing the Prometheus configuration
    and a new target will present itself, which you can validate in the Prometheus
    web user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06658f18-12d1-47fd-90e4-f35e00f2c945.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6: Prometheus targeting the Hey application
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that no **role-based access control** (**RBAC**) configuration
    was required in this example. This is because all pods run in the same namespace
    and Prometheus didn't require access to the Kubernetes API yet. We strongly believe
    RBAC is fundamental in a secure Kubernetes setup.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic configuration – the Prometheus Operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CoreOS was the pioneer in building a pattern called Operator, which abstracts
    the complexity of packaging, deployment, and the management of Kubernetes applications.
    The Operator synthesizes the knowledge required for the operation of an application
    (such as configuration and deploy logic) into Kubernetes custom resources and
    custom controllers.
  prefs: []
  type: TYPE_NORMAL
- en: A custom resource is an object that extends the Kubernetes API, allowing custom
    API definitions. Custom controller strives to achieve the user's required state
    for a resource, continuously working on maintaining such a state.
  prefs: []
  type: TYPE_NORMAL
- en: The combination of both a Kubernetes custom resource and custom controller into
    a pattern is what brings the Operator definition to life.
  prefs: []
  type: TYPE_NORMAL
- en: When implementing this type of pattern, instead of defining per example, the
    persistent storage for an application, as well as the specific configuration for
    their environment, the user would rather just request an instance of that application,
    and the Operator would abstract all the required dependencies and provide the
    final result automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, besides managing the deployment, including the number of pods
    and persistent volumes of the Prometheus server, the Prometheus Operator will
    also update the configuration dynamically using the concept of ServiceMonitor,
    which targets services with matching rules against the labels of running containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed29b32a-94a0-4d12-b694-1265ce526576.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7: Prometheus Operator logic diagram
  prefs: []
  type: TYPE_NORMAL
- en: Empowered with this knowledge, we'll provide an example on how to deploy and
    configure Prometheus using the Prometheus Operator, including collecting metrics
    from an application, this time running on a different namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ensure that there''s no instance of `minikube` running, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Start a new `minikube` instance with the following specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'When the previous command finishes, a new Kubernetes environment should be
    ready to be used. You may access its dashboard by using the following command,
    which will open the Kubernetes dashboard address in your default browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To proceed with the deployment of our example, ensure that you move into the
    correct repository path, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the previous example, we''ll be creating a new namespace called `monitoring`
    with the help of `kubectl`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Prometheus Operator deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the new namespace available, it''s time to ensure that all access permissions
    are in place for the Prometheus Operator, as shown in the next few configuration
    snippets. The first one defines the `ClusterRole`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we apply the `ClusterRole` to a `ClusterRoleBinding`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create a `ServiceAccount` for the `ClusterRoleBinding`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the manifest containing the previous snippets using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Having the new service account configured, we''re ready to deploy the Operator
    itself, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the previous manifest using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can follow the deployment status using the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: With the Operator deployed, we can now use it to deploy and manage Prometheus
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus server deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before proceeding with the setup of Prometheus, we''ll need to grant its instances
    with the right access control permissions.  The following snippets from the Prometheus
    RBAC manifest do just that. First we need to create a `ClusterRole` that allows
    Prometheus access to `/metrics` through GET requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a `ClusterRoleBinding` to grant the permissions from the aforementioned
    `ClusterRole` to a user, which in our case will be a `ServiceAccount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create a `ServiceAccount` for Prometheus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the manifest containing the previous snippets using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Having the service account ready, we can now use the Prometheus Operator to
    deploy our Prometheus servers using the following manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the previous manifest using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We can follow the deployment progress using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'When the deployment is finished, we''ll be ready to create a new service for
    our Prometheus servers and launch the web interface to validate the current settings,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the Prometheus default configuration created by the Prometheus
    Operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/378fe1fa-94fd-43c0-93af-072535466a0e.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8: Prometheus default configuration created by the Prometheus Operator
  prefs: []
  type: TYPE_NORMAL
- en: Adding targets to Prometheus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've deployed the Operator and used it to deploy Prometheus itself.
    Now, we're ready to add targets and go over the logic of how to generate them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding, we''ll also deploy an application to increase the number
    of available targets. For this, we''ll be using the *Hey* application once again,
    this time using the default namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay close attention to the labels and the port name, as shown in the following
    code block; they''ll be used by the service monitor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the manifest containing the previous snippets using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We can follow the status of the deployment using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'After the deployment finishes, we''ll create a new service, as shown in the
    following code block. Pay close attention to the labels that will be used by the
    service monitor to target this service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the previous manifest using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we are going to create service monitors for both the Prometheus instances
    and the *Hey* application, which will instruct the Operator to configure Prometheus,
    adding the required targets. Pay close attention to the selector configuration –
    it will be used to match the services we created previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the service monitor for Prometheus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The service monitor for the *Hey* application is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the previous manifests using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'You can validate the successful deployment of the service monitors using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'After the Operator reconfigures Prometheus, which might take a few seconds,
    the added targets should be available on your Prometheus web interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cc495c2-9f2d-437c-9666-316902f42895.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9: Prometheus targets after the service monitors' configuration
  prefs: []
  type: TYPE_NORMAL
- en: ServiceMonitors are the main building block when using the Prometheus Operator.
    You can configure anything that goes into a scrape job, such as scrape and timeout
    intervals, metrics endpoint to scrape, HTTP query parameters, and so on. You can
    find the documentation for these configurations at [https://github.com/coreos/prometheus-operator/blob/master/Documentation/api.md#endpoint](https://github.com/coreos/prometheus-operator/blob/master/Documentation/api.md#endpoint).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we were introduced to some of the most important configuration
    concepts for setting up a Prometheus server. This knowledge is fundamental for
    tailoring Prometheus for your specific scenario. From startup flags to the configuration
    file, we also spun up an instance to experiment and validate the knowledge we
    obtained.
  prefs: []
  type: TYPE_NORMAL
- en: As more and more workloads are transitioning to containers, and specifically
    to Kubernetes, we dived into how to set up and manage Prometheus on such an environment.
    We began experimenting with static configurations as a stepping stone to understand
    a more robust approach, the Prometheus Operator.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll go into the most common exporters and build upon
    what we've learned so that we can successfully collect data from various different
    sources on Prometheus.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What happens if `scrape_timeout` is not declared explicitly?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can Prometheus be made to reload its configuration file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How far back does Prometheus look for data before considering a time series
    stale?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `relabel_configs` and `metric_relabel_configs`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the static deployment example, we added a Kubernetes service for the Hey
    application as a target in Prometheus. What problems will arise if we increase
    the number of *Hey* pods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does static Prometheus static configuration make sense on a Kubernetes environment?
    Why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In which Kubernetes facilities does the Prometheus Operator rely upon to achieve
    its goals?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Prometheus configuration**: [https://prometheus.io/docs/prometheus/latest/configuration/configuration/](https://prometheus.io/docs/prometheus/latest/configuration/configuration/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prometheus TSDB APIs**: [https://prometheus.io/docs/prometheus/latest/querying/api/#tsdb-admin-apis](https://prometheus.io/docs/prometheus/latest/querying/api/#tsdb-admin-apis)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prometheus security**: [https://prometheus.io/docs/operating/security/](https://prometheus.io/docs/operating/security/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubernetes custom controllers**: [https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/#custom-controllers](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/#custom-controllers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubernetes custom resources**: [https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/#customresourcedefinitions](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/#customresourcedefinitions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prometheus Operator**: [https://github.com/coreos/prometheus-operator/blob/master/Documentation/design.md](https://github.com/coreos/prometheus-operator/blob/master/Documentation/design.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
