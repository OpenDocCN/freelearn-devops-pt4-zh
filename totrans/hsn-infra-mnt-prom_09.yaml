- en: Prometheus Query Language - PromQL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'Prometheus 查询语言 - PromQL  '
- en: Prometheus offers a powerful and flexible query language in order to leverage
    its multi-dimensional data model that allows ad hoc aggregation and a combination
    of time series data. In this chapter, we'll introduce PromQL, its syntax, and
    semantics. Armed with the knowledge and features of this language, we'll be able
    to unlock the true potential of Prometheus.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'Prometheus 提供了一种强大且灵活的查询语言，利用其多维数据模型进行临时聚合和时间序列数据的组合。在本章中，我们将介绍 PromQL 及其语法和语义。掌握了这门语言的知识和功能后，我们将能够解锁
    Prometheus 的真正潜力。  '
- en: 'In brief, the following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '简而言之，本章将涵盖以下内容：  '
- en: The test environment for this chapter
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '本章的测试环境  '
- en: Getting to know the basics of PromQL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '了解 PromQL 的基础知识  '
- en: Common patterns and pitfalls
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '常见模式与陷阱  '
- en: Moving on to more complex queries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '进入更复杂的查询  '
- en: The test environment for this chapter
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '本章的测试环境  '
- en: 'In this chapter, we will be using a Kubernetes-based environment to generate
    all the metrics we need to test the PromQL examples that are covered in this chapter.
    Using the Prometheus Operator, the setup of this environment is quite simple;
    go through the following steps to get yourself up and running:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章中，我们将使用基于 Kubernetes 的环境来生成我们需要的所有指标，以测试本章中涵盖的 PromQL 示例。通过使用 Prometheus
    Operator，设置这个环境相当简单；按照以下步骤操作即可启动并运行：  '
- en: 'To start the Kubernetes test environment, we first must ensure there''s no
    instance of `minikube` running:'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '为了启动 Kubernetes 测试环境，我们首先必须确保没有正在运行的 `minikube` 实例：  '
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Start a new `minikube` instance with the following specifications:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '启动一个新的 `minikube` 实例，具体规格如下：  '
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When the previous command finishes, a new Kubernetes environment should be ready
    to be used.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '当前一个命令执行完成后，一个新的 Kubernetes 环境应该可以开始使用了。  '
- en: For our Kubernetes test environment, we'll be building upon the lessons we learned
    about in [Chapter 5](12e775c2-bee9-4ebe-ad73-2f9313eeeeee.xhtml), *Running a Prometheus
    Server*, and will employ the Prometheus Operator in our workflow. Since we've
    already covered the Prometheus Operator setup, we'll deploy all the required components
    without dwelling on each one of them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '对于我们的 Kubernetes 测试环境，我们将基于[第5章](12e775c2-bee9-4ebe-ad73-2f9313eeeeee.xhtml)《运行
    Prometheus 服务器》中学到的知识，并在我们的工作流中使用 Prometheus Operator。由于我们已经覆盖了 Prometheus Operator
    的设置，接下来我们将部署所有必需的组件，而不再逐一讲解它们。  '
- en: 'Step into this chapter number, relative to the code repository root path:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '进入本章对应的代码仓库根路径：  '
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Deploy the Prometheus Operator and validate the successful deploy:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '部署 Prometheus Operator 并验证成功部署：  '
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Wait a few seconds for the Prometheus Operator to be able to execute requests
    and deploy the Prometheus server:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '等待几秒钟，直到 Prometheus Operator 能够执行请求并部署 Prometheus 服务器：  '
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So that we have a few metric providers, we''ll be deploying some of the exporters
    we covered in [Chapter 6](51ddca07-f381-40f6-ae45-8b089ed918cd.xhtml), *Exporters
    and Integrations*, specifically the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '为了让我们有一些指标提供者，我们将部署在[第6章](51ddca07-f381-40f6-ae45-8b089ed918cd.xhtml)《导出器与集成》中介绍的部分导出器，特别是以下这些：  '
- en: Node Exporter
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Node Exporter  '
- en: cAdvisor
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'cAdvisor  '
- en: kube-state-metrics
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'kube-state-metrics  '
- en: We'll also be deploying a type of *Hello World* application, *Hey*, that we
    introduced in [Chapter 5](12e775c2-bee9-4ebe-ad73-2f9313eeeeee.xhtml), *Running
    a Prometheus Server*, so that Prometheus gathers web application metrics as well.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将部署一种*Hello World* 应用，*Hey*，这也是我们在[第5章](12e775c2-bee9-4ebe-ad73-2f9313eeeeee.xhtml)《运行
    Prometheus 服务器》中介绍过的，这样 Prometheus 也可以收集 Web 应用的指标。
- en: 'To ease the effort required to deploy all of the components and configurations,
    the following command abstracts all the steps needed, which we also went through
    in previous chapters:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '为了简化所有组件和配置的部署工作，以下命令将抽象出所有必需的步骤，我们在之前的章节中也走过这些步骤：  '
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After a moment, you should have Prometheus and all the services ready and available.
    The following instruction should open the Prometheus web interface in your default
    web browser:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '几秒钟后，你应该可以看到 Prometheus 和所有服务已经准备好并可用。以下指令将在默认的 web 浏览器中打开 Prometheus 的 web
    界面：  '
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you browse the `/targets` endpoint, you''ll be presented with something
    similar to the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你浏览 `/targets` 端点，你将看到类似以下的内容：  '
- en: '![](img/7a882111-8d07-43a0-a237-d9404a1b740c.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a882111-8d07-43a0-a237-d9404a1b740c.png)  '
- en: 'Figure 7.1: Prometheus /targets endpoint showing all the configured targets'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '图 7.1：Prometheus /targets 端点显示所有已配置的目标  '
- en: You can now follow along with the examples in this chapter using this newly
    created test environment.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以在此新创建的测试环境中跟随本章的示例。
- en: Getting to know the basics of PromQL
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 PromQL 基础
- en: Understanding the Prometheus Query Language is essential to be able to perform
    insightful dashboarding, capacity planning, and alerting. But for that, we need
    to begin by learning the basics. The following topics will cover the components
    that available to construct queries and look into how they behave together.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 Prometheus 查询语言对于能够执行深入的仪表盘分析、容量规划和告警非常重要。但要做到这一点，我们需要从了解基础开始。以下主题将介绍构建查询时可用的组件，并探讨它们如何一起运作。
- en: Selectors
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择器
- en: 'Prometheus is designed to handle hundreds of thousands of time series. Each
    metric name can have several different time series, depending on the combination
    of labels; querying the right data can look difficult, or even downright perplexing,
    when similarly-named metrics from different jobs are mixed together. In Prometheus,
    a selector refers to a set of label matchers. The metric name is also included
    in this definition as, technically, its internal representation is also a label,
    albeit a special one: `__name__`. Each label name/value pair in a selector is
    called a label matcher, and multiple matchers can be used to further filter down
    the time series matched by the selector. Label matchers are enclosed in curly
    brackets. If no matcher is needed, the curly brackets can be omitted. Selectors
    can return instant or range vectors. Here''s an example selector:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 旨在处理数十万条时间序列。每个度量名称可能具有多个不同的时间序列，这取决于标签的组合；当来自不同作业的相似名称的度量混合在一起时，查询正确的数据可能看起来很困难，甚至令人困惑。在
    Prometheus 中，选择器指的是一组标签匹配器。度量名称也包含在此定义中，因为从技术上讲，它的内部表示也是一个标签，尽管是一个特殊的标签：`__name__`。选择器中的每一对标签名称/值被称为标签匹配器，可以使用多个匹配器进一步过滤选择器匹配的时间序列。标签匹配器被包含在大括号中。如果不需要匹配器，大括号可以省略。选择器可以返回瞬时或区间向量。以下是一个选择器示例：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This selector is equivalent to the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选择器等同于以下内容：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's now see how to label matchers work.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下标签匹配器是如何工作的。
- en: Label matchers
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签匹配器
- en: 'Matchers are employed to restrict a query search to a specific set of label
    values. We''ll be using the `node_cpu_seconds_total` metric to exemplify the four
    available label matcher operators: `=`, `!=`, `=~`, and `!~`. Without any matching
    specification, this metric alone returns an instant vector with all the available
    time series containing the metric name,  as well as all combinations of the CPU
    core numbers (`cpu=”0”`, `cpu=”1”`) and CPU modes (`mode="idle"`, `mode="iowait"`,
    `mode="irq"`, `mode="nice"`, `mode="softirq"`, `mode="steal"`, `mode="user"`,
    `mode="system"`), which makes a grand total of 16 time series, as shown in the
    following screenshot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配器用于限制查询搜索到特定的标签值集。我们将使用 `node_cpu_seconds_total` 度量来示范四个可用的标签匹配器操作符：`=`, `!=`,
    `=~` 和 `!~`。如果没有任何匹配规范，仅使用此度量会返回一个瞬时向量，其中包含所有包含该度量名称的时间序列，以及所有 CPU 核心编号（`cpu="0"`、`cpu="1"`）和
    CPU 模式（`mode="idle"`、`mode="iowait"`、`mode="irq"`、`mode="nice"`、`mode="softirq"`、`mode="steal"`、`mode="user"`、`mode="system"`）的组合，总共返回
    16 个时间序列，如以下截图所示：
- en: '![](img/bf556780-70a2-419b-a597-67aa44511f97.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf556780-70a2-419b-a597-67aa44511f97.png)'
- en: 'Figure 7.2: node_cpu_seconds_total query resulting in 16 time series being
    returned'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：`node_cpu_seconds_total` 查询结果返回 16 个时间序列
- en: Now, let's use each of the four available label matchers (`=`, `!=`, `=~`, and `!~`)
    to restrict the query differently and analyze the produced results.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用四个可用的标签匹配器（`=`, `!=`, `=~`, `!~`）来不同地限制查询，并分析产生的结果。
- en: 'Using `=`, we can perform an exact match on the label value. For instance,
    if we only match CPU core `0`, it will return an instant vector with half of the
    time series from the previous query:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `=`，我们可以对标签值进行精确匹配。例如，如果我们只匹配 CPU 核心 `0`，它将返回一个瞬时向量，其中包含前一个查询中一半的时间序列：
- en: '![](img/90f43aa4-f2ca-4c0e-904e-474d4f3ed1d7.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90f43aa4-f2ca-4c0e-904e-474d4f3ed1d7.png)'
- en: 'Figure 7.3: Query node_cpu_seconds_total only on CPU core 0'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：仅查询 CPU 核心 0 上的 `node_cpu_seconds_total`
- en: 'We can also negate a match to obtain all the remaining time series using the
    `!=` matcher. Once applied to our example, it will return the remaining eight
    time series only, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用 `!=` 匹配器来否定匹配，获取所有剩余的时间序列。应用到我们的示例时，它将仅返回剩余的八个时间序列，如下所示：
- en: '![](img/21529ddd-f465-45fe-bac8-9f4e177d97f0.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21529ddd-f465-45fe-bac8-9f4e177d97f0.png)'
- en: 'Figure 7.4: Query node_cpu_seconds*_total* for all time series except core
    0'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：查询 `node_cpu_seconds*_total*` 的所有时间序列，排除核心 0
- en: When selecting time series, instead of relying solely on exact matches, it is
    also important to be able to apply regular expressions. Hence, `=~` and `!~` are
    PromQL matchers for this operation and they both accept RE2 type regex syntax.
    Keep in mind that the regular expressions are anchored when using these matchers.
    This means they need to match the full label value. You can unanchor an expression
    by adding `.*` at the beginning and end of the regex.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择时间序列时，除了仅依赖于精确匹配外，能够应用正则表达式也是非常重要的。因此，`=~` 和 `!~` 是 PromQL 用于此操作的匹配符，它们都接受
    RE2 类型的正则表达式语法。请记住，在使用这些匹配符时，正则表达式是有锚点的。这意味着它们需要匹配完整的标签值。你可以通过在正则表达式的开始和结束处添加
    `.*` 来解除锚点。
- en: The regular expression syntax that's accepted by RE2 can be found at: [https://github.com/google/re2/wiki/Syntax](https://github.com/google/re2/wiki/Syntax).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: RE2 接受的正则表达式语法可以在以下链接找到：[https://github.com/google/re2/wiki/Syntax](https://github.com/google/re2/wiki/Syntax)。
- en: 'Looking at our example, if we were only interested in two CPU modes, `mode="user"`
    and `mode="system"`, we could easily perform a query like the following, effectively
    selecting only the modes we require:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看我们的示例，如果我们只对两个 CPU 模式感兴趣，`mode="user"` 和 `mode="system"`，我们可以轻松地执行如下查询，从而有效地选择我们需要的模式：
- en: '![](img/b428a929-dcaf-43eb-a8d1-040690da14c2.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b428a929-dcaf-43eb-a8d1-040690da14c2.png)'
- en: 'Figure 7.5: Query node_cpu_seconds_total only for mode="user" and mode="system"'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5：仅查询 mode="user" 和 mode="system" 的 node_cpu_seconds_total
- en: 'Considering that RE2 does not support negative lookahead, and similar to the
    negate matcher, Prometheus provides a way to negate the regex matcher, by using
    `!~`. This matcher excludes results that match the expression and allows all the
    remaining time series. Here''s an example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 RE2 不支持负向前瞻，且类似于否定匹配符，Prometheus 提供了一种方式来否定正则表达式匹配符，方法是使用 `!~`。该匹配符排除与表达式匹配的结果，并允许所有其余的时间序列。以下是一个示例：
- en: '![](img/4f35318a-d701-4cc9-ae3c-e1676169b106.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f35318a-d701-4cc9-ae3c-e1676169b106.png)'
- en: 'Figure 7.6: Query node_cpu_seconds_total for all time series except mode="user"
    and mode="system"'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6：查询所有时间序列，除了 mode="user" 和 mode="system"
- en: Now that we have a good understanding on how label matchers work, let's have
    a look at instant vectors.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对标签匹配器的工作原理有了很好的理解，让我们来看看即时向量。
- en: Instant vectors
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即时向量
- en: Instant vector selectors are named as such because they return a list of samples,
    relative to the query evaluation time, for the time series that match them. This
    list is called an **instant vector**, as it's a result at a given instant. A sample
    is a data point of a time series, composed of a value and a timestamp. This timestamp,
    in most cases, reflects the time when the scrape occurred and that value was ingested,
    with the exception of metrics pushed to the Pushgateway, which, due to their nature,
    will never have timestamps. However, if functions are applied or operations are
    performed on the time series, the timestamp for the instant vector samples will
    reflect the query time and not the ingested time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 即时向量选择器之所以这样命名，是因为它们返回与查询评估时间相关的、匹配时间序列的样本列表。这个列表被称为**即时向量**，因为它是某一时刻的结果。样本是时间序列中的数据点，由一个值和一个时间戳组成。这个时间戳在大多数情况下反映了抓取发生的时间以及该值被摄取的时间，除非是推送到
    Pushgateway 的度量，因为它们的性质决定了它们永远没有时间戳。然而，如果对时间序列应用了函数或执行了操作，则即时向量样本的时间戳将反映查询时间，而不是摄取时间。
- en: The way instant vectors operate – by only returning the most recent samples
    relative to query time that match the selector - means that Prometheus will not
    return time series that are considered stale (as we mentioned in [Chapter 5](12e775c2-bee9-4ebe-ad73-2f9313eeeeee.xhtml),
    *Running a Prometheus Server*). A stale marker (a special kind of sample that
    marks that time series as stale) is inserted when either the originating target
    disappears from the discovery mechanism, or if they are not present in the scrape
    after the last successful one where they existed. A time series with a stale marker
    as its last sample will not be returned when using instant vector selectors.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 即时向量的工作方式——只返回与查询时间相关的、与选择器匹配的最新样本——意味着 Prometheus 不会返回被视为过时的时间序列（正如我们在[第5章](12e775c2-bee9-4ebe-ad73-2f9313eeeeee.xhtml)中提到的，*运行
    Prometheus 服务器*）。当源目标从发现机制中消失，或在上次成功的抓取后未出现在抓取数据中时，会插入一个过时标记（一个特殊的样本，用来标记该时间序列为过时）。当时间序列的最后一个样本是过时标记时，使用即时向量选择器时该时间序列将不会被返回。
- en: Every example in the *Label Matchers*section was an instant vector selector,
    and so every result was an instant vector.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *标签匹配器* 部分中的每个示例都是瞬时向量选择器，因此每个结果都是瞬时向量。
- en: Range vectors
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围向量
- en: A range vector selector is similar to an instant vector selector, but it returns
    a set of samples for a given time range, for each time series that matches it.
    Keep in mind that a timestamp of a given value might not be completely aligned
    with the scrape time for different targets since Prometheus spreads the scrapes
    across their defined intervals, reducing overlapping scrapes in the same instant.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 范围向量选择器类似于瞬时向量选择器，但它返回一组样本，适用于每个匹配的时间序列，并且在给定的时间范围内。请记住，给定值的时间戳可能不会完全与不同目标的抓取时间对齐，因为
    Prometheus 会将抓取分散到其定义的时间间隔内，从而减少同一时刻的重叠抓取。
- en: To define a range vector selector query, you have to set an instant vector selector
    and append a range using square brackets `[ ]`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义范围向量选择器查询，必须设置一个瞬时向量选择器，并使用方括号 `[ ]` 添加一个范围。
- en: 'The following table details the available time units for defining a range:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下表详细说明了用于定义时间范围的可用时间单位：
- en: '| **Abbreviation** | **Unit** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **缩写** | **单位** |'
- en: '| `s` | Seconds |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `s` | 秒 |'
- en: '| `m` | Minutes |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `m` | 分钟 |'
- en: '| `h` | Hours |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `h` | 小时 |'
- en: '| `d` | Days |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `d` | 天 |'
- en: '| `w` | Weeks |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `w` | 周 |'
- en: '| `y` | Years |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `y` | 年 |'
- en: 'Like durations, as explained in [Chapter 5](12e775c2-bee9-4ebe-ad73-2f9313eeeeee.xhtml)*,
    Running a Prometheus Server*, a time range is always an integer value with a single
    unit. For example, 1.5d and 1d12h are considered errors and should be represented
    as 36h. Durations ignore leap seconds and leap days: a week is always is always
    exactly 7 days long, and a year 365 days.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[第 5 章](12e775c2-bee9-4ebe-ad73-2f9313eeeeee.xhtml)*《运行 Prometheus 服务器》*中所述，时间范围总是一个带有单一单位的整数值。例如，1.5d
    和 1d12h 被视为错误，应表示为 36h。持续时间忽略闰秒和闰日：一周始终恰好是 7 天，一年始终是 365 天。
- en: 'Let''s put this into practice. Using the *Hey* application as our case example,
    we''re going to inspect the samples that were collected in the last two minutes
    for HTTP code `200`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来实际操作一下。以 *Hey* 应用程序为例，我们将检查过去两分钟内收集的 HTTP 状态码 `200` 的样本：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Following is the output for the preceding code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![](img/8199bca8-6b57-4898-b6f4-58a7788d1404.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8199bca8-6b57-4898-b6f4-58a7788d1404.png)'
- en: 'Figure 7.7: Two minutes of samples of the http_requests_total metric for the
    HTTP code 200'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7：HTTP 状态码 200 的 http_requests_total 指标过去两分钟的样本
- en: As we can see in the preceding screenshot, there are four samples available
    (defined by the 30s scrape interval) for each instance of the *Hey* application
    that are returned by our range vector selector.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的截图中看到的，返回的每个 *Hey* 应用程序实例的样本（由 30 秒抓取间隔定义）有四个可用样本，来自我们的范围向量选择器。
- en: The offset modifier
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 偏移修饰符
- en: 'The `offset` modifier allows you to query data in the past. This means that
    we can offset the query time of an instant or range vector selector relative to
    the current time. It is applied on a per-selector basis, which means that offsetting
    one selector but not another effectively unlocks the ability to compare current
    behavior with past behavior for each of the matched time series. To use this modifier,
    we need to specify it right after the selector and add the offset time; for example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`offset` 修饰符允许你查询过去的数据。这意味着我们可以相对于当前时间对瞬时或范围向量选择器的查询时间进行偏移。它是按选择器逐一应用的，这意味着只偏移一个选择器而不偏移另一个选择器，实际上解锁了将当前行为与过去行为进行比较的能力，适用于每个匹配的时间序列。使用此修饰符时，我们需要将其紧跟在选择器后面，并添加偏移时间；例如：'
- en: '![](img/05dbe816-b363-4134-8daa-655d9bedde7c.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05dbe816-b363-4134-8daa-655d9bedde7c.png)'
- en: 'Figure 7.8: Two minutes of samples of the http_requests_total metric of the
    past hour for the HTTP code 200'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8：HTTP 状态码 200 的 http_requests_total 指标过去一小时内的两分钟样本
- en: Despite not being directly related to PromQL, it's important to be aware of
    the moment feature of the Prometheus expression browser. This feature changes
    the query moment as if we went back to a specific date and time. The main difference
    between the moment picker and using offset is that the former is absolute while
    the latter is relative time shifting.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管与 PromQL 没有直接关系，但了解 Prometheus 表达式浏览器的时刻功能仍然很重要。此功能改变了查询时刻，就像我们回到了特定的日期和时间。时刻选择器与使用偏移量的主要区别在于，前者是绝对时间，而后者是相对时间偏移。
- en: Subqueries
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子查询
- en: Before the introduction of the subquery selector in Prometheus 2.7.0, there
    wasn't a direct way to feed the output of functions that returned instant vectors
    to range vector functions. In order to do that, you would have recorded the expression
    that produced the desired instant vector as a new time series, also called a recording
    rule – which we'll go into in depth in [Chapter 9](9aa1e3da-13cf-4051-845d-1d1c924ef47b.xhtml),
    *Defining Alerting and Recording Rules – *waited for it to have enough data, and
    then used the appropriate range vector selector to feed the recorded series into
    the range vector function. The subquery selector simplifies this process by allowing
    the evaluation of functions that return instant vectors over time and return the
    result as a range vector, without needing to wait for recording rules to capture
    sufficient data. Subquery syntax is similar to range vectors, with the added detail
    of being able to specify the frequency in which samples should be captured, as
    we'll see soon.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Prometheus 2.7.0 引入子查询选择器之前，并没有直接的方法将返回瞬时向量的函数的输出传递给范围向量函数。为了做到这一点，你需要将产生所需瞬时向量的表达式记录为一个新的时间序列，这也叫做记录规则——我们将在[第9章](9aa1e3da-13cf-4051-845d-1d1c924ef47b.xhtml)中深入讨论，*定义告警和记录规则*——等待它有足够的数据，然后使用适当的范围向量选择器将记录的序列传递给范围向量函数。子查询选择器通过允许对返回瞬时向量的函数进行时间上的评估，并将结果作为范围向量返回，从而简化了这个过程，而无需等待记录规则捕获足够的数据。子查询语法与范围向量类似，唯一的区别是可以指定采样频率，正如我们很快将看到的那样。
- en: 'We''ll be using the following query example to explain its syntax:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下查询示例来解释其语法：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Splitting the query into its components, we can see the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将查询拆解成其组件后，我们可以看到以下内容：
- en: '| **Component** | **Description** |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **组件** | **描述** |'
- en: '| `rate(http_requests_total{handler="/health", instance="172.17.0.9:8000"}[5m])`
    | The inner query to be run, which in this case is aggregating five minutes''
    worth of data into an instant vector. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `rate(http_requests_total{handler="/health", instance="172.17.0.9:8000"}[5m])`
    | 要执行的内部查询，在这种情况下，它将五分钟的数据聚合成一个瞬时向量。 |'
- en: '| `[1h` | Just like a range vector selector, this defines the size of the range
    relative to the query evaluation time. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `[1h` | 就像一个范围向量选择器一样，这定义了相对于查询评估时间的范围大小。 |'
- en: '| `:1m]` | The resolution step to use. If not defined, it defaults to the global
    evaluation interval. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `:1m]` | 要使用的分辨率步长。如果没有定义，则默认为全局评估间隔。 |'
- en: '| `max_over_time` | The subquery returns a range vector, which is now able
    to become the argument of this aggregation operation over time. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `max_over_time` | 子查询返回一个范围向量，这现在可以作为此聚合操作在时间上的参数。 |'
- en: This is a common use case, as it is good practice to expose counters wherever
    possible (with the obvious exception of things that are gauges by nature, such
    as current memory occupation) and then rate them to be resilient to failed scrapes,
    but most interesting functions take ranges of gauges.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常见的用例，因为尽可能公开计数器是一个好的实践（显然，像当前内存占用这类天生是仪表的内容除外），然后对其进行速率计算，以增强对抓取失败的抵抗力，但大多数有趣的函数会采用范围内的仪表值。
- en: Subqueries are fairly expensive to evaluate, so it is strongly discouraged to
    use them for dashboarding, as recording rules would produce the same result given
    enough time. Similarly, they should not be used in recording rules for the same
    reason. Subqueries are best suited for exploratory querying, where it is not known
    in advance which aggregations are needed to be looked at over time.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 子查询的评估开销相对较高，因此强烈不建议在仪表板中使用它们，因为记录规则在足够的时间后会产生相同的结果。同样，出于同样的原因，它们也不应在记录规则中使用。子查询最适合用于探索性查询，其中无法提前知道需要查看哪些聚合。
- en: Operators
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: PromQL allows the use of binary, vector matching, and aggregation operators.
    In the following sections, we'll go over each one, providing examples on how and
    when to use them.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: PromQL 允许使用二元操作符、向量匹配和聚合操作符。在接下来的章节中，我们将逐一介绍每个操作符，并提供如何以及何时使用它们的示例。
- en: Binary operators
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二元操作符
- en: Apart from instant and range vectors, Prometheus also supports values of the
    scalar type, which consist of single numbers without any dimensionality.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了瞬时向量和范围向量，Prometheus 还支持标量类型的值，它们是没有任何维度的单一数字。
- en: 'In the following subsections, we will explore each of the binary operators:
    the arithmetic and the comparison operators.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的子章节中，我们将探讨每个二元操作符：算术操作符和比较操作符。
- en: Arithmetic
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算术
- en: The arithmetic operators provide basic math between two operands.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 算术操作符提供两个操作数之间的基本数学运算。
- en: There are three available combinations of operands. The simplest is between
    two scalars, which will return a scalar after applying the chosen arithmetic operator.
    We can also combine an instant vector and a scalar, which will apply the chosen
    arithmetic operator between the scalar and each sample of the instant vector,
    effectively returning the same instant vector with updated samples. The last combination
    we can have is between two instant vectors. In this case, the arithmetic operator
    is applied between the vector from the left-hand side and the matching element
    from the right-hand side vector, while the metric name is dropped. If no match
    is present, those samples will not be part of the result. This case will be explained
    further in the *Vector matching* section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种可用的操作数组合。最简单的组合是两个标量之间的运算，这将返回一个标量结果。我们还可以将一个即时向量与标量相结合，这将在标量和即时向量的每个样本之间应用选定的算术运算符，最终返回更新样本的相同即时向量。最后一种组合是两个即时向量之间的运算。在这种情况下，算术运算符将应用于左侧向量和右侧向量中匹配的元素，而度量名称会被省略。如果没有匹配项，这些样本将不会出现在结果中。这个案例将在*向量匹配*部分进一步解释。
- en: 'For reference, the available arithmetic operators are as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，以下是可用的算术运算符：
- en: '| **Operator** | **Description** |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **描述** |'
- en: '| `+` | Addition |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 加法 |'
- en: '| `-` | Subtraction |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `-` | 减法 |'
- en: '| `*` | Multiplication |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 乘法 |'
- en: '| `/` | Division |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `/` | 除法 |'
- en: '| `%` | Modulo |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `%` | 取模 |'
- en: '| `^` | Power |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 幂运算 |'
- en: Comparison
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较
- en: 'The comparison operators, as shown in the following table, are useful for filtering
    results:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了比较运算符，这些运算符对于过滤结果非常有用：
- en: '| **Operator** | **Description** |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **描述** |'
- en: '| `==` | Equal |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `==` | 等于 |'
- en: '| `!=` | Not equal |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `!=` | 不等于 |'
- en: '| `>` | Greater than |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `>` | 大于 |'
- en: '| `<` | Less than |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `<` | 小于 |'
- en: '| `>=` | Greater or equal |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | 大于或等于 |'
- en: '| `<=` | Less or equal |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | 小于或等于 |'
- en: 'Say, for example, we have the following instant vector:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，我们有以下即时向量：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To that, we apply a comparison operator such as the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以应用如下的比较运算符：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The result will be as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This operation shows that we have effectively filtered the results of the instant
    vector, which is fundamental for alerting, as we'll discuss later, in [Chapter
    9](9aa1e3da-13cf-4051-845d-1d1c924ef47b.xhtml), *Defining Alerting and Recording
    Rules*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作表明我们已经有效地过滤了即时向量的结果，这对于警报非常重要，正如我们稍后将在[第9章](9aa1e3da-13cf-4051-845d-1d1c924ef47b.xhtml)
    *定义警报和记录规则*部分中讨论的那样。
- en: Moreover, we can use the `bool` modifier to not only return all matched time
    series but also modify each returned sample to become 1 or 0, depending on whether
    the sample would be kept or dropped by the comparison operator.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用 `bool` 修饰符，不仅返回所有匹配的时间序列，还可以将每个返回的样本修改为 1 或 0，具体取决于该样本是否会被比较运算符保留或丢弃。
- en: Using the bool modifier is the only way to compare scalars; for example, `42
    == bool 42`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `bool` 修饰符是比较标量的唯一方法；例如，`42 == bool 42`。
- en: 'Therefore, we can apply the same query with the `bool` modifier to our previous
    example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将带有 `bool` 修饰符的相同查询应用于我们之前的示例：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This would return the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下内容：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Vector matching
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量匹配
- en: Vector matching, as the name implies, is an operation only available between
    vectors. So far, we have learned that when we have a scalar and an instant vector,
    the scalar gets applied to each sample of the instant vector. However, when we
    have two instant vectors, how can we match their samples? We'll be tackling this
    question in the following sub-sections.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 向量匹配，顾名思义，是一种仅在向量之间可用的操作。到目前为止，我们已经了解了当我们有一个标量和一个即时向量时，标量会应用于即时向量的每个样本。然而，当我们有两个即时向量时，如何匹配它们的样本呢？我们将在接下来的子部分中探讨这个问题。
- en: One-to-one
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一一对应
- en: Since binary operators require two operands, as we described previously, when
    vectors of the same size and label set are located on each side of one operator,
    that is, one-to-one, samples with the exact same label/value pairs are matched
    together, while the metric name and all non-matching elements are dropped.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于二元运算符需要两个操作数，正如我们之前所描述的，当同样大小和标签集的向量位于一个运算符的两侧时，也就是一一对应的情况下，具有完全相同标签/值对的样本会被匹配在一起，而度量名称以及所有不匹配的元素将被丢弃。
- en: 'Let''s consider an example. We''ll start by using the following instant vectors:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个示例。我们将从使用以下即时向量开始：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We''ll then apply the following operation:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将应用以下操作：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will return the resulting instant vector:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回结果即时向量：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It might be useful to aggregate vectors with mismatching labels. In those situations,
    you can apply the `ignoring` keyword right after the binary operator to ignore
    the specified labels. Additionally, it is also possible to restrict which labels
    from both sides should be used in matching by using the `on` keyword after the
    binary operator.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能需要聚合标签不匹配的向量。在这些情况下，你可以在二元运算符后应用 `ignoring` 关键字来忽略指定的标签。此外，也可以使用 `on`
    关键字来限制用于匹配的左右两侧的标签。
- en: Many-to-one and one-to-many
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多对一和一对多
- en: Occasionally, you are required to perform operations where the element of one
    side is matched with several elements on the other side of the operation. When
    this happens, you are required to provide Prometheus with the means to interpret
    such operations. If the higher cardinality is on the left-hand side of the operation,
    you can use the `group_left` modifier after either `on` or `ignoring`; if it's
    on the right-hand side, then `group_right` should be applied. The `group_left`
    operation is commonly used for its ability to copy labels over from the right
    side of the expression, as will be seen on some practical examples later in this
    chapter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，你需要执行一种操作，其中一侧的元素与另一侧的多个元素匹配。当这种情况发生时，你需要为 Prometheus 提供解释这种操作的方法。如果操作的左侧具有更高的基数，你可以在
    `on` 或 `ignoring` 后使用 `group_left` 修饰符；如果更高的基数在右侧，那么应使用 `group_right`。`group_left`
    操作通常用于其能够将标签从表达式的右侧复制过来的能力，稍后的实践示例中将展示这一点。
- en: Logical operators
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'Logical operators are most easily understood as their set theory counterparts,
    as shown in the following table. These operators are the only ones in PromQL that
    work many-to-many. There are three logical operators that can be used between
    expressions:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符最容易理解的是它们的集合论对应物，如下表所示。这些运算符是 PromQL 中唯一能实现多对多的运算符。可以在表达式之间使用三种逻辑运算符：
- en: '| **Operator** | **Description** |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** |'
- en: '| `and` | Intersection |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `and` | 交集 |'
- en: '| `or` | Union |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `or` | 并集 |'
- en: '| `unless` | Complement |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `unless` | 补集 |'
- en: 'The `and` logical operator works by only returning the matches from the left-hand
    side if the expression on the right-hand side has results with matching label
    key/value pairs. All other time series from the left-hand side that do not have
    a match on the right-hand side are dropped. The resulting time series will keep
    the name from the left operand. This is why it is also called the **intersection**
    operator. The `and` operator is often used like an `if` statement: by using the
    expression on the right as the condition to return the one on the left.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`and` 逻辑运算符通过仅返回左侧的匹配项来工作，前提是右侧的表达式有与之匹配的标签键/值对。所有左侧没有在右侧匹配的时间序列将被丢弃。结果的时间序列将保留来自左侧操作数的名称。这就是它也被称为**交集**运算符的原因。`and`
    运算符通常像 `if` 语句一样使用：通过将右侧的表达式作为条件来返回左侧的表达式。'
- en: 'Using the following instant vector as an example, we''ll validate the previous
    statement:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下瞬时向量为例，我们将验证之前的说法：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We''ll be applying the following expression:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用以下表达式：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will return the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下结果：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The union logical operator, `or`, works by returning the elements from the left-hand
    side, except if there are no matches, it will return the elements from the right-hand
    side. Again, both sides need to have matching label names/values.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 并集逻辑运算符 `or` 通过返回左侧的元素来工作，除非没有匹配项，否则它将返回右侧的元素。再次强调，左右两侧的标签名称/值必须匹配。
- en: 'We can reuse the previous data sample and apply the following expression:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重用之前的数据样本，并应用以下表达式：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The result will be as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Finally, the `unless` logical operator will return the elements from the first
    expression that do not match the label name/value pairs from the second. In set
    theory, this is called a complement. Practically speaking, this operator works
    in the opposite way to `and`, which means it can also be used as an `if not` statement.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`unless` 逻辑运算符将返回来自第一个表达式中不与第二个表达式的标签名称/值对匹配的元素。在集合理论中，这称为补集。实际使用中，这个运算符的工作方式与
    `and` 相反，这意味着它也可以作为 `if not` 语句使用。
- en: 'Once again, we''ll be using the same sample data that we used previously while
    applying the following expression:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将使用之前使用的相同样本数据，并应用以下表达式：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This, in turn, provides us with the following result:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这反过来会给我们提供以下结果：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Aggregation operators
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合运算符
- en: By employing aggregation operators, we can take an instant vector and aggregate
    its elements, resulting in a new instant vector, usually with fewer elements.
    Every aggregation of an instant vector such as this works in the ways that we
    described in the *Vertical aggregation* section of [Chapter 4](d571ee63-1941-40e0-a314-70030efe76ea.xhtml)*,
    Prometheus Metrics Fundamentals*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用聚合运算符，我们可以对即时向量进行聚合，结果是一个新的即时向量，通常包含更少的元素。每次对即时向量的聚合都按我们在[第 4 章](d571ee63-1941-40e0-a314-70030efe76ea.xhtml)*“Prometheus
    指标基础”*一节中描述的方式进行。
- en: 'The available aggregation operators are as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的聚合运算符如下：
- en: '| **Operator** | **Description** | **Requirements** |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** | **要求** |'
- en: '| `sum` | Sums the elements |  |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `sum` | 求元素的和 |  |'
- en: '| `min` | Selects the minimum element |  |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `min` | 选择最小元素 |  |'
- en: '| `max` | Selects the maximum element |  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `max` | 选择最大元素 |  |'
- en: '| `avg` | Calculates the average of the elements |  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `avg` | 计算元素的平均值 |  |'
- en: '| `stddev` | Calculates the standard deviation of the elements |  |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `stddev` | 计算元素的标准偏差 |  |'
- en: '| `stdvar` | Calculates the standard variance of the elements |  |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `stdvar` | 计算元素的标准方差 |  |'
- en: '| `count` | Counts the number of elements |  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `count` | 统计元素的个数 |  |'
- en: '| `count_values` | Counts the number of elements with the same value |  |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `count_values` | 统计具有相同值的元素个数 |  |'
- en: '| `bottomk` | The lower `k` elements by sample | Requires the number of elements
    (`k`) as a scalar |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `bottomk` | 按样本选择最小的 `k` 个元素 | 需要元素数量（`k`）作为标量 |'
- en: '| `topq` | The higher `k` elements by sample value | Requires the number of
    elements (`k`) as a scalar |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `topq` | 按样本值选择最上面的 `k` 个元素 | 需要元素数量（`k`）作为标量 |'
- en: '| `quantile` | Calculates the quantile of the elements | Requires the quantile
    (0 ≤ φ ≤ 1) definition as a scalar |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `quantile` | 计算元素的分位数 | 需要分位数（0 ≤ φ ≤ 1）定义作为标量 |'
- en: 'The operators that require a parameter (such as `count_values`, `bottomk`,
    `topk`, and `quantile`) need to specify it before the vector expression. There
    are two available modifiers to use in conjunction with aggregation operators that
    take a list of label names: `without` allows you to define which labels to aggregate
    away, effectively dropping those labels from the resulting vector, while `by`
    does exactly the opposite; that is, it allows you to specify which labels to keep
    from being aggregated. Only a single modifier can be used per aggregation operator.
    These modifiers will influence which dimensions will be aggregated by the operators.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 需要参数的运算符（如 `count_values`、`bottomk`、`topk` 和 `quantile`）需要在向量表达式之前指定参数。与聚合运算符一起使用时，有两个可用的修饰符可以与标签名列表结合使用：`without`
    允许你定义要聚合掉的标签，从而将这些标签从结果向量中去除，而 `by` 则完全相反；即，它允许你指定哪些标签不被聚合。每个聚合运算符只能使用一个修饰符。这些修饰符会影响运算符聚合的维度。
- en: 'For example, let''s say that we use some sample data from the following query:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们使用以下查询的一些示例数据：
- en: '[PRE26]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This would generate something like the following snippet:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成类似以下的片段：
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we want to know the aggregate of all requests, we can apply the following
    expression:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想知道所有请求的聚合，可以应用以下表达式：
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will return the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下内容：
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, if we add the `by` operator, we can aggregate by the handler endpoint:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们添加 `by` 运算符，就可以按处理程序端点进行聚合：
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This would, in turn, return the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下内容：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This simple example demonstrates how you can easily aggregate data.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的示例展示了如何轻松地聚合数据。
- en: Binary operator precedence
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二元运算符优先级
- en: 'When a PromQL query is evaluated, the order in which binary operators are applied
    is dictated by the operator precedence. The following table shows the precedence
    order, from higher to lower:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当 PromQL 查询被评估时，二元运算符的应用顺序由运算符的优先级决定。下表展示了优先级顺序，从高到低：
- en: '| **Precedence** | **Operator** | **Description** |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| **优先级** | **运算符** | **描述** |'
- en: '| 1 | `^` | Evaluated right to left, for example, 1 ^ 2 ^ 3 is evaluated as
    1 ^ (2 ^ 3) |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `^` | 从右到左求值，例如，1 ^ 2 ^ 3 按照 1 ^ (2 ^ 3) 计算 |'
- en: '| 2 | `*`, `/`, `%` | Evaluated left to right, for example, 1 / 2 * 3 is evaluated
    as (1 / 2) * 3 |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `*`, `/`, `%` | 从左到右求值，例如，1 / 2 * 3 按照 (1 / 2) * 3 计算 |'
- en: '| 3 | `+`, `-` | Evaluated left to right |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 3 | `+`, `-` | 从左到右求值 |'
- en: '| 4 | `==`, `!=`, `<=`, `<`, `>=`, `>` | Evaluated left to right |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 4 | `==`, `!=`, `<=`, `<`, `>=`, `>` | 从左到右求值 |'
- en: '| 5 | `and`, `unless` | Evaluated left to right |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 5 | `and`, `unless` | 从左到右求值 |'
- en: '| 6 | `or` | Evaluated left to right |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 6 | `or` | 从左到右求值 |'
- en: Functions
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: PromQL has almost 50 different functions for a variety of use cases, such as
    math; sorting; counter, gauge and histogram manipulation; label transformations;
    aggregations over time; type conversions; and finally, date and time functions.
    In the following sections, we'll cover some of the most commonly used ones and
    provide examples on why they are so relevant.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: PromQL有近50种不同的函数，适用于各种用例，如数学运算、排序、计数器、仪表和直方图操作、标签转换、时间上的聚合、类型转换以及日期和时间函数。在接下来的章节中，我们将介绍一些最常用的函数，并提供它们为何如此相关的示例。
- en: A comprehensive overview of all functions is available at [https://prometheus.io/docs/prometheus/latest/querying/functions/](https://prometheus.io/docs/prometheus/latest/querying/functions/).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 所有函数的全面概述可以在[https://prometheus.io/docs/prometheus/latest/querying/functions/](https://prometheus.io/docs/prometheus/latest/querying/functions/)中查看。
- en: absent()
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: absent()
- en: 'The `absent()` function takes an instant vector as an argument and returns
    the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`absent()`函数接受一个瞬时向量作为参数，并返回以下内容：'
- en: An empty vector if the argument has results
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果参数有结果，则返回一个空向量
- en: 1-element vector with the sample value equal to 1, containing the labels from
    the specified argument in the case of non-conflicting equality matchers
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1元素向量，示例值为1，在非冲突相等匹配器的情况下包含指定参数中的标签
- en: This function is quite useful for alerting on, as the name suggests, absent
    time series.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，这个函数对告警非常有用，特别是缺失时间序列时。
- en: 'For example, say that the instant vector exists and we execute the following
    expression:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设瞬时向量存在，我们执行以下表达式：
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will return the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下内容：
- en: '[PRE33]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s say we use an expression with a label matcher using a nonexistent label
    value, like in the following example:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用带有不存在标签值的标签匹配器的表达式，如下所示：
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will produce an instant vector with the nonexistent label value:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个包含不存在标签值的瞬时向量：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s apply `absent` to a nonexistent metric, as shown in this snippet:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`absent`应用于一个不存在的指标，如下所示：
- en: '[PRE36]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This will translate into the following output:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这将转化为以下输出：
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, let''s say we use `absent` on a nonexistent metric and a nonexistent
    label/value pair, as shown in the following snippet:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，假设我们在一个不存在的指标和不存在的标签/值对上使用`absent`，如以下代码片段所示：
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The result can be seen in the following snippet:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可以在以下代码片段中看到：
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: label_join() and label_replace()
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: label_join() 和 label_replace()
- en: These functions are used to manipulate labels—they allow you to join labels
    to other ones, extract parts of label values, and even drop labels (though that
    particular operation is easier and more ergonomic to do with standard aggregation
    operators). In both functions, if the defined target label is a new one, it will
    get added to the label set; if it's an existing label, it will get replaced.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数用于操作标签——它们允许你将标签连接到其他标签、提取标签值的一部分，甚至删除标签（尽管这个操作通过标准聚合操作符更简单、更符合人机工程学）。在这两个函数中，如果定义的目标标签是新的，它将被添加到标签集合中；如果是现有标签，它将被替换。
- en: 'When using `label_join`, you''re required to provide an instant vector, define
    a resulting label, identify the separator of the resulting concatenation, and
    establish the labels to join, as exemplified in the following syntax:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`label_join`时，您需要提供一个瞬时向量，定义一个结果标签，确定结果连接的分隔符，并建立要连接的标签，如以下语法所示：
- en: '[PRE40]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'For example, say that we use the following sample data:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们使用以下示例数据：
- en: '[PRE41]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We then apply the following expression:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们应用以下表达式：
- en: '[PRE42]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We end up with the following instant vector:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们得到以下瞬时向量：
- en: '[PRE43]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When you need to arbitrarily manipulate labels, `label_replace` is the function
    to use. The way it works is by applying a regular expression to the value of a
    chosen source label and storing the matched capture groups on the destination
    label. Both source and destination can be the same label, effectively replacing
    its value. This sounds complex, but it really isn''t; let''s have a look at the
    syntax of `label_replace`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要任意操作标签时，`label_replace`是要使用的函数。它的工作方式是对所选源标签的值应用正则表达式，并将匹配的捕获组存储到目标标签中。源标签和目标标签可以是相同的标签，从而有效地替换其值。这听起来复杂，但实际上并不复杂；让我们看看`label_replace`的语法：
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Say that we take the preceding sample data and apply the following expression:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们采用前面的示例数据并应用以下表达式：
- en: '[PRE45]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The result will then be the matching elements with the new label, called **port**:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是带有新标签**port**的匹配元素：
- en: '[PRE46]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When using `label_replace`, if the regular expression doesn't match the label
    value, the originating time series will be returned unchanged.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `label_replace` 时，如果正则表达式没有匹配到标签值，则原始时间序列将保持不变。
- en: predict_linear()
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: predict_linear()
- en: This function receives a range vector and a scalar time value as arguments.
    It extrapolates the value of each matched time series from the query evaluation
    time to the specified number of seconds in the future, given the trend in the
    data from the range vector. It uses linear regression to achieve such a prediction,
    which means there is no complex algorithmic forecasting happening in the background.
    It should only be used with gauges.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接收一个范围向量和一个标量时间值作为参数。它会根据范围向量中的数据趋势，将查询评估时间到未来指定秒数的时间序列值进行外推。它使用线性回归来实现这样的预测，这意味着后台没有复杂的算法预测过程。此函数仅应与仪表（gauge）类型一起使用。
- en: 'We''ll apply the following expression, which employs `predict_linear` using
    a range of one hour of data, and extrapolate the sample value four hours in the
    future (60 (seconds) * 60 (minutes) * 4):'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用以下表达式，使用 `predict_linear`，并利用一小时的数据范围，外推四小时后的样本值（60（秒）* 60（分钟）* 4）：
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: rate() and irate()
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: rate() 和 irate()
- en: These two functions allow you to calculate the rate of increase of the given
    counters. Both automatically adjust for counter resets and take a range vector
    as an argument.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数允许您计算给定计数器的增长率。它们都会自动调整计数器重置，并将范围向量作为参数。
- en: While the `rate()` function provides the per second *average rate of change*
    over the specified interval by using the first and last values in the range scaled
    to fit the range window, the `irate()` function uses the last two values in the
    range for the calculation, which produces the instant rate of change.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`rate()` 函数通过使用范围内的第一个和最后一个值来提供指定区间内的每秒 *平均变化率*，而 `irate()` 函数则使用范围内的最后两个值进行计算，从而产生瞬时变化率。'
- en: It's important to understand in what scenarios the usage of one is more suitable
    than the other. For example, when creating visualizations such as dashboards,
    we might want to increase the awareness of possible spikes; `irate` fits this
    criteria. Note that as `irate()` uses the last two values in a range, it is sensible
    to step downsampling, and so it can only be used when fully zoomed in. When building
    alerting expressions, we are more interested in obtaining smoother trends, so
    that spurious spikes don't reset the `for` timer (as we'll see in [Chapter 9](9aa1e3da-13cf-4051-845d-1d1c924ef47b.xhtml),
    *Defining Alerting and Recording Rules*); in this case, `rate` is the more appropriate
    function to apply. Always ensure there are at least four samples in the range
    vector so that `rate()` can work reliably.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 了解在什么场景下使用哪一个函数更为合适非常重要。例如，在创建仪表板等可视化时，我们可能希望更好地识别潜在的尖峰；此时，`irate` 符合这个要求。请注意，由于
    `irate()` 使用的是范围内的最后两个值，因此它适合步进下采样（step downsampling），只能在完全放大时使用。当构建告警表达式时，我们更关心获取平滑的趋势，以避免偶发的尖峰重置
    `for` 计时器（如我们将在 [第 9 章](9aa1e3da-13cf-4051-845d-1d1c924ef47b.xhtml)《定义告警和记录规则》中看到的那样）；在这种情况下，`rate`
    是更合适的函数。始终确保范围向量中至少有四个样本，以便 `rate()` 可以可靠地工作。
- en: 'To show the differences between these two functions, the following screenshot
    illustrate the same metric, at the same timeframe, one using `rate()` and the
    other using `irate()`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这两个函数之间的区别，以下截图展示了相同的指标，在相同的时间范围内，一个使用了 `rate()`，另一个使用了 `irate()`：
- en: '![](img/3599e048-112a-4092-8ced-a4cdeed41835.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3599e048-112a-4092-8ced-a4cdeed41835.png)'
- en: 'Figure 7.9: rate() of node_network_receive_bytes_total with 1m range'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9：`node_network_receive_bytes_total` 的 rate()，时间范围为 1 分钟
- en: '![](img/29508fe3-2742-40b8-bc04-1dd2544b8c26.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29508fe3-2742-40b8-bc04-1dd2544b8c26.png)'
- en: 'Figure 7.10: irate() of node_network_receive_bytes_total with 1m range'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10：`node_network_receive_bytes_total` 的 irate()，时间范围为 1 分钟
- en: As we can see, `irate` is a lot more sensitive to variations in the underlying
    counters, while `rate` generally produces more smoothed-out values.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`irate` 对基础计数器的变化更为敏感，而 `rate` 通常会产生更平滑的值。
- en: histogram_quantile()
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: histogram_quantile()
- en: This function takes a float, which defines the required quantile (0 ≤ φ ≤ 1),
    and an instant vector of the gauge type as arguments. Each time series must have
    a `le` label (which means less than or equal to) to represent the upper bound
    of a bucket. This function also expects one of the selected time series to have
    a bucket named such as `+Inf`, which works as the catch-all, the last bucket of
    the cumulative histogram. Since histograms that are generated by Prometheus client
    libraries use counters for each bucket, `rate()` needs to be applied to convert
    them into gauges for this function to do its work. The time that's range selected
    for the range vector will then correspond to the window for the quantile calculation.
    Although rare, some histograms produced by third-party software might not use
    counters for their buckets, so they can be used directly in `histogram_quantile` as
    long as they fulfil the label requirements.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个浮动值，定义所需的分位数（0 ≤ φ ≤ 1），以及一个量表类型的即时向量作为参数。每个时间序列必须具有一个 `le` 标签（表示小于或等于），用来表示桶的上界。该函数还要求所选时间序列之一具有一个名为
    `+Inf` 的桶，它作为捕获所有其他值的“最后桶”，即累计直方图的最后一个桶。由于 Prometheus 客户端库生成的直方图对每个桶使用计数器，`rate()`
    需要被应用来将它们转换为量表，以便此函数能正常工作。为时间范围选择的时间将对应于分位数计算的窗口。虽然不常见，但一些第三方软件生成的直方图可能没有对其桶使用计数器，因此只要它们满足标签要求，就可以直接在
    `histogram_quantile` 中使用。
- en: 'For example, lets execute the following expression:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，执行以下表达式：
- en: '[PRE48]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We''ll be presented with a result similar to the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会看到类似于以下的结果：
- en: '[PRE49]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This provides an example of the output of an internal Prometheus histogram.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一个内部 Prometheus 直方图输出的示例。
- en: sort() and sort_desc()
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sort() 和 sort_desc()
- en: As their names suggest, `sort` receives a vector and sorts it in ascending order
    by the sample values, while `sort_desc` does the same function but in descending
    order.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 正如它们的名字所示，`sort` 接收一个向量，并根据样本值按升序对其进行排序，而 `sort_desc` 做的是相同的操作，只不过是降序排序。
- en: The `topk` and `bottomk` aggregation operators sort their results by default.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`topk` 和 `bottomk` 聚合操作符默认会对其结果进行排序。'
- en: vector()
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: vector()
- en: The `vector()` function receives a scalar value as a parameter and returns a
    vector with no labels with the value of the specified scalar argument.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector()` 函数接收一个标量值作为参数，并返回一个没有标签的向量，该向量的值为指定的标量参数。'
- en: 'For example, query the following expression:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，查询以下表达式：
- en: '[PRE50]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It will return the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回以下内容：
- en: '[PRE51]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This is normally used as a way of ensuring an expression always has at least
    one result, by combining a vector expression with it, like in the following code:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常用作确保表达式总是至少有一个结果的一种方式，通过将一个向量表达式与其组合，如以下代码所示：
- en: '[PRE52]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Since the `or` operator returns both sides, a sample with the value 0 will always
    be present.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `or` 操作符返回两边的结果，因此值为 0 的样本将始终存在。
- en: Aggregation operations over time
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合操作（按时间）
- en: 'The aggregation operations we discussed earlier are always applied to instant
    vectors. When we need to perform those aggregations on range vectors, PromQL provides
    the `*_over_time` family of functions, which work as described in the *Horizontal
    aggregation* section of [Chapter 4](d571ee63-1941-40e0-a314-70030efe76ea.xhtml),
    *Prometheus Metrics Fundamentals*. All of them take a range vector and output
    an instant vector. Following is the description of the operations:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论的聚合操作总是应用于即时向量。当我们需要在范围向量上执行这些聚合时，PromQL 提供了 `*_over_time` 系列函数，按 [第 4
    章](d571ee63-1941-40e0-a314-70030efe76ea.xhtml)《Prometheus 指标基础》中的*水平聚合*部分所述工作。它们都接受一个范围向量并输出一个即时向量。以下是这些操作的描述：
- en: '| **Operation** | **Description** |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **描述** |'
- en: '| `avg_over_time()` | Average value of all samples in the range. |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `avg_over_time()` | 范围内所有样本的平均值。 |'
- en: '| `count_over_time()` | Count of all samples in the range. |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `count_over_time()` | 范围内所有样本的计数。 |'
- en: '| `max_over_time()` | Maximum value of all samples in the range. |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `max_over_time()` | 范围内所有样本的最大值。 |'
- en: '| `min_over_time()` | Minimum value of all samples in the range. |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `min_over_time()` | 范围内所有样本的最小值。 |'
- en: '| `quantile_over_time()` | The quantile of all samples in the range. It requires
    two arguments, the definition of the desired quantile, φ, as a scalar, where 0
    ≤ φ ≤ 1, as a first argument and then a range-vector. |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `quantile_over_time()` | 计算范围内所有样本的分位数。它需要两个参数，第一个参数是所需分位数 φ 的定义，作为一个标量，其中
    0 ≤ φ ≤ 1，第二个参数是一个范围向量。 |'
- en: '| `stddev_over_time()` | The standard deviation of the sample''s value in the
    range. |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `stddev_over_time()` | 范围内样本值的标准差。 |'
- en: '| `stdvar_over_time()` | The standard variance of the sample''s value in the
    range. |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `stdvar_over_time()` | 范围内样本值的标准方差。 |'
- en: '| `sum_over_time()` | The sum of all sample values in the range. |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `sum_over_time()` | 在范围内所有样本值的总和。 |'
- en: Time functions
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间函数
- en: Prometheus supplies a number of functions to help manipulating time data. These
    are useful for a couple of scenarios, such as checking how long ago was a process
    or batch job last seen, only triggering alerts at certain times, or not triggering
    them at all on certain days. Every time function in Prometheus assumes Universal
    Coordinated Time (UTC).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 提供了许多函数来帮助处理时间数据。这些函数在几种场景中非常有用，例如检查一个进程或批处理作业上次出现的时间，只有在特定时间触发警报，或者在某些天完全不触发警报。Prometheus
    中的每个时间函数都假定使用协调世界时（UTC）。
- en: 'The `time` function returns an instant vector with the current time in the
    UNIX epoch format (commonly known as a UNIX timestamp): the number of seconds
    that have elapsed since January 1st, 1970 UTC.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`time` 函数返回一个即时向量，表示当前时间的 UNIX 纪元格式（通常称为 UNIX 时间戳）：自 1970 年 1 月 1 日 UTC 起经过的秒数。'
- en: The `timestamp` function returns an instant vector with the UNIX timestamps
    of the samples returned by the supplied selector.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`timestamp` 函数返回一个即时向量，其中包含由提供的选择器返回的样本的 UNIX 时间戳。'
- en: 'The `minute`, `hour`, `month` and `year` functions all work the same way: they
    receive an instant vector with one or more timestamps, and return an instant vector
    with the corresponding time component they represent. These functions'' default
    input is the `time` function so, if they''re used without an argument, they will
    return the current minute, hour, month or year, respectively.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`minute`、`hour`、`month` 和 `year` 函数的工作方式相同：它们接受一个带有一个或多个时间戳的即时向量，并返回一个即时向量，表示相应的时间组件。这些函数的默认输入是
    `time` 函数，因此，如果没有提供参数，它们将分别返回当前的分钟、小时、月份或年份。'
- en: The `days_in_month` function receives an instant vector with timestamps as argument
    and returns the number of days in the month for each of those timestamps. As with
    the previous functions, the default input argument is the `time` function. The
    result will obviously range from 28 to 31.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`days_in_month` 函数接受一个带有时间戳的即时向量作为参数，并返回每个时间戳所在月份的天数。与之前的函数一样，默认输入参数是 `time`
    函数。结果显然会在 28 到 31 之间变化。'
- en: Lastly, and similarly to the previous function, the `day_of_week` and `day_of_month`
    functions expect an instant vector with timestamps as input and returns the corresponding
    day of the week (Sunday as 0, Monday as 1, and so on) and day of the month (from
    1 to 31), respectively. The default input is the `time` function.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，类似于之前的函数，`day_of_week` 和 `day_of_month` 函数期望一个带有时间戳的即时向量作为输入，分别返回对应的星期几（星期天为
    0，星期一为 1，以此类推）和月份中的天数（从 1 到 31）。默认输入是 `time` 函数。
- en: Info and enum
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信息与枚举
- en: There are two metric types yet to be mentioned, info and enum. They are quite
    recent, but the convenience they bring is very much appreciated. Metrics of the
    type info have their names end with `_info` and are regular gauges with one possible
    value, 1\. This special kind of metric was designed to be a place where labels
    whose values might change over time are stored, such as versions (for example,
    exporter version, language version, and kernel version), assigned roles, or VM
    metadata information; if those labels were to be exported in every time series,
    were they to change, a break in continuity would happen as the metric identity
    (the combination of the metric name and label set) would also change. This would
    also pollute the labels of all the time series that were affected, since these
    new labels would be present in every metric. To use this type of metric, we need
    to combine it with the metrics we wish to augment by using the multiplication
    operator—since the info metric value is `1`, the multiplication won't change the
    value of the other metric—and the `group_left`/`group_right` modifiers allow us
    to enrich of the resulting vector with the labels we might require.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两种度量类型尚未提及，分别是 info 和 enum。它们是相对较新的类型，但它们带来的便利性非常值得赞赏。info 类型的度量名称以 `_info`
    结尾，是具有一个可能值 `1` 的常规仪表。这种特殊类型的度量被设计为存储随时间变化的标签的地方，例如版本（例如，导出器版本、语言版本和内核版本）、分配的角色或虚拟机元数据等；如果这些标签每次都导出到时间序列中，当它们变化时，会导致断续性问题，因为度量标识（即度量名称和标签组合）会发生变化。这也会污染所有受影响的时间序列的标签，因为这些新的标签会出现在每个度量中。要使用这种类型的度量，我们需要结合我们希望增强的度量，使用乘法运算符—由于
    info 度量值为 `1`，乘法不会改变其他度量的值—而 `group_left`/`group_right` 修饰符允许我们在结果向量中添加所需的标签。
- en: 'Here''s an example of a query using an info metric:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用 info 度量的查询示例：
- en: '[PRE53]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can see the previous query result in the following snippet:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下代码片段中看到上一个查询结果：
- en: '[PRE54]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The enum metric type is also a gauge, just like info. Its objective is to provide
    a way to expose anything that might need state tracking, such as the current state
    of a state machine. The most common use case for this type of metric is exposing
    the state of daemons (start, starting, stop, stopping, failed, and so on). This
    tracking is done by maintaining state information on a label, appropriately named
    state, and setting the metric value to `1` for the current state and 0 otherwise.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举度量类型也是一种仪表，和 info 类型类似。它的目的是提供一种暴露需要跟踪状态的事物的方法，例如状态机的当前状态。此类度量的最常见用例是暴露守护进程的状态（启动、启动中、停止、停止中、失败等）。这种跟踪是通过在标签上维护状态信息来完成的，标签命名为
    state，并将度量值设置为 `1`，表示当前状态，否则为 0。
- en: 'Here''s an example of an instant vector selector query using an enum metric:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用枚举度量的即时向量选择器查询示例：
- en: '[PRE55]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The previous query results in the following snippet:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个查询结果如下所示：
- en: '[PRE56]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now that we know the basics of PromQL, let's dive into some common patterns
    and avoidable pitfalls when writing expressions.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 PromQL 的基础知识，让我们深入探讨在编写表达式时一些常见的模式和可以避免的陷阱。
- en: Common patterns and pitfalls
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的模式和陷阱
- en: With such a powerful language at your disposal, it's easy to become overwhelmed
    with so many options. In the following sections, we'll provide some common patterns
    and pitfalls to ensure the intended use of PromQL for each situation described,
    and in this way, further enforcing the knowledge that we have provided you with
    so far.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 PromQL 是一个功能强大的语言，面对如此多的选项，你很容易感到不知所措。在接下来的章节中，我们将提供一些常见的模式和陷阱，确保在每种情况中正确使用
    PromQL，通过这种方式进一步巩固我们至今为你提供的知识。
- en: Patterns
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式
- en: While the power and flexibility of PromQL allows for a world of possibilities
    in terms of information extraction, there are a few query patterns that make a
    set of common problems much easier to understand and help increase the level of
    insight into the monitored services. In the following topics, we'll be covering
    a few of our favorites, in the hope they become as useful for you as they currently
    are for us.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 PromQL 的强大功能和灵活性为信息提取提供了无尽的可能性，但有一些查询模式能够使一组常见问题变得更容易理解，并帮助提高对被监控服务的洞察力。在接下来的主题中，我们将介绍一些我们最喜欢的模式，希望它们对你来说和对我们一样有用。
- en: Service-level indicators
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务级指标
- en: In [Chapter 1](4214ddff-8289-4dc6-b0ef-240510a22192.xhtml), *Monitoring Fundamentals*,
    we introduced the notion of *What to measure*, discussing *Google's Four Golden
    Signals*, as well as the USE and RED methodologies. Building upon that knowledge,
    we can start to define **service-level indicators** (**SLIs**), which reflect
    a given service's performance and availability. Constructing queries to generate
    SLIs is a common pattern of PromQL usage and one of the most useful.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](4214ddff-8289-4dc6-b0ef-240510a22192.xhtml)，《监控基础》一章中，我们介绍了*测量什么*的概念，讨论了*Google的四大黄金信号*，以及USE和RED方法论。在此基础上，我们可以开始定义**服务水平指标**（**SLI**），这些指标反映了特定服务的性能和可用性。构建查询来生成SLI是PromQL使用的常见模式，也是最有用的之一。
- en: 'Let''s look at an example of an SLI: the typical definition of one is the number
    of good events over the number of valid events; in this case, we want to understand
    whether the percentage of requests being served by Prometheus is at or below 100
    ms, which makes it a latency SLI. First we need to gather information about how
    many requests are being served under that threshold; thankfully, we can rely on
    an already available histogram-typed metric called `prometheus_http_request_duration_seconds_bucket`.
    As we already know, this type of metric has buckets represented by the `le` label
    (less or equal), so we just match the elements under 100 ms (0.1 s), like so:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一个SLI的示例：其典型定义是“良好事件的数量”除以“有效事件的数量”；在这个例子中，我们希望了解Prometheus处理的请求是否在100毫秒以内，这使得它成为一个延迟SLI。首先，我们需要收集有关在该阈值下处理的请求数的信息；幸运的是，我们可以依赖一个已存在的直方图类型指标`prometheus_http_request_duration_seconds_bucket`。正如我们已经知道的，这种类型的指标有由`le`标签（小于或等于）表示的桶，所以我们只需匹配100毫秒（0.1秒）以内的元素，如下所示：
- en: '[PRE57]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'While ratios are typically the base unit in these type of calculations, for
    this example, we want a percentage, and so we must divide the matched elements
    by the total number of requests made (`prometheus_http_request_duration_seconds_count`)
    and multiply that result by 100\. These two instant vectors can''t to be divided
    directly due to the mismatch of the `le` label, so we must ignore it, as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然比率通常是此类计算的基本单位，但在这个例子中，我们需要一个百分比，因此我们必须将匹配的元素除以总请求数（`prometheus_http_request_duration_seconds_count`），然后将结果乘以100。这两个即时向量不能直接相除，因为`le`标签不匹配，因此我们必须忽略它，如下所示：
- en: '[PRE58]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This gives us an instant vector with information per endpoint and per instance,
    setting the sample value to the percentage of requests answered below 100 ms since
    the service started on each instance (remember that `_bucket` is a counter). That''s
    a good start, but not quite what we''re after, as we want the SLI for the service
    as a whole, not for each instance or for each endpoint. It''s also more useful
    to calculate it on a rolling window instead of averaging an indeterminate amount
    of data; as more data is collected, the average becomes smoother and harder to
    move. So, to fix these issues, we need to rate the counters over a time window
    to get a fixed rolling average, and then aggregate away instances and endpoints
    using `sum()`. This way, we don''t need to ignore the `le` label either, as it
    is also discarded during aggregation. Let''s put it all together:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们一个按端点和实例划分的即时向量，设置样本值为自服务启动以来每个实例中，低于100毫秒的请求百分比（记住，`_bucket`是一个计数器）。这算是一个好的开始，但还不是我们想要的，因为我们希望的是整个服务的SLI，而不是每个实例或每个端点的SLI。用一个滚动窗口来计算它比对不确定数量的数据求平均值更有用；随着数据的收集，平均值会变得更加平滑，且更难以改变。因此，为了修复这些问题，我们需要在时间窗口内对计数器进行速率计算，以获得一个固定的滚动平均值，然后使用`sum()`聚合掉实例和端点。这样，我们也不需要忽略`le`标签，因为它在聚合过程中也会被丢弃。我们把这些全部放在一起：
- en: '[PRE59]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Building a **service-level objective** (**SLO**) for our service now becomes
    trivial as we are just required to specify the percentage we're aiming to achieve
    using a comparison operator. This makes for an excellent condition to be defined
    as an alert.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个**服务水平目标**（**SLO**）对我们的服务来说变得简单，因为我们只需要通过比较操作符来指定我们希望达到的百分比。这为定义一个告警条件提供了一个很好的基础。
- en: Percentiles
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 百分位
- en: We just learned how to extract the percentage of requests being served under
    a given latency, but what if we need to understand the latency of a given percentile
    of requests?
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学习了如何提取在给定延迟下处理的请求百分比，但如果我们需要了解在某个百分位的请求延迟呢？
- en: 'To obtain, for example, the 95th percentile, we can use the `histogram_quantile`
    function by defining the quantile (in this case, `0.95`), and then feed it the
    query expression that represents the set of data we''re interested in—the average
    rate of increase for each of the buckets in the request duration histogram during
    a rolling time window. If we want the global latency of the service, instead of
    per instance/pod/handler, we need to apply the `sum()` aggregation:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要获得95百分位数，我们可以使用`histogram_quantile`函数，通过定义分位数（在此案例中为`0.95`），然后将表示我们感兴趣数据集的查询表达式传递给它——即请求持续时间直方图中每个桶的平均增长率，且该直方图是在滚动时间窗口内计算的。如果我们想要查看服务的全局延迟，而非每个实例/Pod/处理器的延迟，我们需要应用`sum()`聚合：
- en: '[PRE60]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This expression will produce a value that represents that 95% of requests will
    be at or under said value.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式会生成一个值，表示95%的请求会在该值或该值以下。
- en: The health of scrape jobs
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抓取任务的健康状态
- en: For each defined scrape job, Prometheus will produce an automatic metric named
    `up`, which reflects the health of the job in question – 1 for a successful scrape
    and 0 for a failed one. We can use this metric to quickly visualize the current
    health state of the entire infrastructure of exporters and/or applications being
    scraped.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个定义的抓取任务，Prometheus会生成一个名为`up`的自动指标，反映该任务的健康状况——抓取成功时为1，失败时为0。我们可以利用这个指标快速可视化整个基础设施中所有被抓取的exporters和/或应用程序的健康状态。
- en: 'Let''s get an overview of all the successful jobs being scraped:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下所有成功的抓取任务的概况：
- en: '[PRE61]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Pitfalls
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 陷阱
- en: The power and flexibility of PromQL can enable some impressive slicing and dicing
    of time series data, but can also be a source of frustration, unexpected results,
    and even severe performance issues. While recent releases of Prometheus have been
    steadily introducing features to address some of these pitfalls, understanding
    these issues can help you get the most out of PromQL, while saving you time and
    computing resources.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: PromQL的强大功能和灵活性使得我们能够对时间序列数据进行一些令人印象深刻的切割和分析，但也可能是造成挫折、意外结果，甚至严重性能问题的源头。尽管Prometheus的最新版本一直在持续引入功能以解决其中一些陷阱，但了解这些问题可以帮助你最大限度地利用PromQL，同时节省时间和计算资源。
- en: Choosing the right functions for the data type
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为数据类型选择正确的函数
- en: 'The most common pitfall when starting out with PromQL is not choosing the right
    function for the data type (such as counters, gauges, or histograms) or vector
    type. Even though this information is pointed out in the Prometheus documentation,
    there can still be some confusion as there are conceptually similar named functions
    and aggregators: `rate` and `deriv`, `increase`; `delta`, `quantile`; `histogram_quantile`,
    `sum` and `sum_over_time`, among others. Fortunately, in cases where there is
    a mismatch of vector types, the expression evaluation will fail and let you know
    what is wrong; for a mismatch in data types, such as providing a counter to a
    function that expects a gauge, the expression might evaluate successfully but
    return incorrect or deceptive results.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用PromQL时，最常见的陷阱是没有为数据类型（如计数器、仪表或直方图）或向量类型选择正确的函数。尽管Prometheus文档中有指出这一点，但由于有些函数和聚合器的命名概念上相似，仍然可能会让人感到困惑：如`rate`和`deriv`，`increase`；`delta`，`quantile`；`histogram_quantile`，`sum`和`sum_over_time`等。幸运的是，在存在向量类型不匹配的情况下，表达式计算会失败，并且会告诉你哪里出了问题；但如果数据类型不匹配，例如将一个计数器传递给期望仪表的函数时，表达式可能会成功计算，但返回的结果却是错误的或具有误导性的。
- en: Sum-of-rates versus rate-of-sums
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总和速率与速率总和
- en: 'The previous point might seem obvious, but when the complexity of the queries
    built starts to increase, it''s easy to make mistakes. A common example of this
    is trying to rate a sum of counters instead of summing rates. The `rate` function
    expects a counter, but a sum of counters is actually a gauge, as it can go down
    when one of the counters resets; this would translate into seemingly random spikes
    when graphed, because `rate` would consider any decrease a counter reset, but
    the total sum of the other counters would be considered a huge delta between zero
    and the current value. In the following diagram, we can see this in action: two
    counters (**G1**, **G2**), one of which had a reset (**G2**); **G3** shows the
    expected aggregate result that''s produced by summing the rate of each counter;
    **G4** shows what the sum of counters 1 and 2 looks like; **G5** represents how
    the rate function would interpret **G4** as a counter (the sudden increase being
    the difference between 0 and the point where the decrease happened); and finally,
    **G6** shows what rating the sum of counters would look like, with the erroneous
    spike appearing where **G2**''s counter reset happened:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 前一点可能看起来很显而易见，但当构建的查询复杂性开始增加时，很容易犯错。一个常见的例子是尝试对计数器的总和进行速率计算，而不是对速率进行求和。`rate`
    函数期望一个计数器，但计数器的总和实际上是一个仪表（gauge），因为当其中一个计数器重置时，仪表值可能会下降；这会在图形上显示出看似随机的尖峰，因为 `rate`
    会将任何下降视为计数器重置，而其他计数器的总和则会被视为从零到当前值的巨大变化。在下图中，我们可以看到这种情况：两个计数器（**G1**、**G2**），其中一个计数器（**G2**）发生了重置；**G3**
    显示了通过对每个计数器的速率求和得到的期望汇总结果；**G4** 显示了计数器 1 和 2 的总和；**G5** 表示 `rate` 函数如何将 **G4**
    视为计数器（突如其来的增加是 0 与下降发生点之间的差异）；最后，**G6** 显示了对计数器总和进行速率计算的结果，错误的尖峰出现在 **G2** 的计数器重置点：
- en: '![](img/9a1a2ab8-d685-4ab1-8c23-f87a6af1a15d.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a1a2ab8-d685-4ab1-8c23-f87a6af1a15d.png)'
- en: 'Figure 7.11: Approximation of what rate of sums and sum of rates look like'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11：总和的速率和速率的总和的近似图
- en: 'An example of how to properly do this in PromQL might be:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PromQL 中如何正确做这个的一个例子可能是：
- en: '[PRE62]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Making this mistake was a bit harder in past versions of Prometheus, because
    to give `rate` a range vector of sums, we would either need a recording rule or
    a manual sum of range vectors. Unfortunately, as of Prometheus 2.7.0, it is now
    possible to ask for the sum of counters over a time window, effectively creating
    a range vector from that result. This is an error and should not be done. So,
    in short, always apply aggregations after taking rates, never the other way around.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的 Prometheus 版本中，犯这个错误有点困难，因为要给 `rate` 提供一个总和的范围向量，我们需要一个录制规则或手动求和范围向量。不幸的是，从
    Prometheus 2.7.0 开始，现在可以请求在一个时间窗口内对计数器求和，从而有效地从该结果创建一个范围向量。这是一个错误，应该避免这样做。因此，总结一下，永远在计算速率后应用聚合操作，而不是反过来。
- en: Having enough data to work with
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拥有足够的数据进行工作
- en: 'The rate group of functions (`rate`, `irate`, `increase`, `deriv`, `delta`,
    and `idelta`) need at least two samples in the supplied range vector to work properly.
    This means that time ranges that are close to `scrape_interval` might fail to
    produce the desired results as a single failed scrape or window alignment issues
    (scrapes don''t happen at exact intervals and might be delayed) will make the
    range contain only one sample. It is therefore recommended to use 4 (or more)
    times the `scrape_interval` to make sure that enough samples are returned for
    the calculation to work. Following diagram shows failed scrape changing the trend
    of samples for a given range:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组 `rate`、`irate`、`increase`、`deriv`、`delta` 和 `idelta` 需要在提供的范围向量中至少有两个样本才能正常工作。这意味着，接近
    `scrape_interval` 的时间范围可能无法产生预期结果，因为一次抓取失败或窗口对齐问题（抓取并不会按精确的间隔发生，可能会有延迟）会导致范围内只包含一个样本。因此，建议使用
    4 倍（或更多）`scrape_interval` 的时间，以确保足够的样本返回以支持计算。以下图显示了由于抓取失败，导致给定范围内样本趋势发生变化：
- en: '![](img/0920208d-3f3a-4d42-b37d-60e62297884e.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0920208d-3f3a-4d42-b37d-60e62297884e.png)'
- en: 'Figure 7.12: A failed scrape changing the trend of samples for a given range'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12：抓取失败改变给定范围内样本的趋势
- en: Unexpected results when using increase
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 increase 时出现意外结果
- en: On a related subject, a common point of confusion is why functions such as `increase`
    and `delta` produce non-integer results. This point is briefly explained in the
    documentation, but is worth expanding upon. Since Prometheus collects data on
    a regular basis (defined in the `scrape_interval` configuration), when a query
    asks for a range of samples, the window limits for that range usually don't neatly
    align with the timestamps of the returned data. These functions extrapolate what
    the result would be like if the data points matched the time window. They do this
    by calculating the precise result with the samples provided, and then multiplying
    that result by the ratio of the time window over the interval between the first
    and last data point, effectively scaling the result to the requested range.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相关的一个常见问题是，为什么像`increase`和`delta`这样的函数会产生非整数结果。文档中简要解释了这一点，但值得进一步展开。由于Prometheus定期收集数据（由`scrape_interval`配置定义），当查询请求一个样本范围时，该范围的窗口限制通常不会与返回数据的时间戳完全对齐。这些函数通过推测数据点如果与时间窗口匹配时会是什么样子，来处理此问题。它们通过计算提供样本的精确结果，然后将该结果乘以时间窗口与第一个和最后一个数据点之间间隔的比率，从而有效地将结果缩放到请求的范围。
- en: Not using enough matchers to select a time series
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未使用足够的匹配器来选择时间序列
- en: 'Another common pitfall when writing PromQL expressions, whether for dashboarding
    or alerting, is not using enough matchers to make sure that the returned samples
    are from the expected time series. It is considered an anti-pattern in the Prometheus
    community to namespace metric names to applications when the metric in question
    is not specific to that particular software, and even if it is, there might be
    cases where naming collisions occur; this is why it is good practice to scope
    selectors so that `job` is always explicitly selected when trying to extract information
    about a particular software. As an example, we can look at the `go_goroutines` metric,
    which is collected by the first-party Prometheus Go client library: as a sizeable
    chunk of the Prometheus ecosystem is written in Go and uses this client library
    for instrumentation, it is usual for this metric to be present in many scrape
    jobs. This means that, if we were to investigate the aggregate go-routine behavior
    of a particular software, we would get incorrect results if the selectors that
    were used weren''t sufficiently narrow for the instances we were interested in.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 编写PromQL表达式时的另一个常见陷阱，无论是用于仪表盘还是告警，是没有使用足够的匹配器，确保返回的样本来自预期的时间序列。在Prometheus社区中，将度量名称命名为应用程序名称被视为一种反模式，尤其是在该度量并非特定于某个软件时，即便是特定于该软件的，也可能会出现命名冲突的情况；因此，最好实践是使选择器具有范围，以便在尝试提取有关某个特定软件的信息时，`job`始终明确选择。例如，我们可以看看由官方Prometheus
    Go客户端库收集的`go_goroutines`度量：由于Prometheus生态系统的大部分内容都是用Go编写的，并且使用此客户端库进行监控，因此通常会在许多抓取作业中看到该度量。这意味着，如果我们想调查某个特定软件的聚合Go协程行为，若所用的选择器不够精确，可能会得到错误的结果。
- en: Losing statistical significance
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 失去统计意义
- en: A mistake not specifically related to PromQL, but easy to make due to the flexibility
    of the language, is to apply transformations to aggregate values, thus losing
    their statistical significance. As an example, you might be tempted to average
    pre-computed quantiles in summaries from a group of instances to get a feel for
    the cluster, but they can't be further manipulated from a statistical standpoint
    – the result from that operation would not resemble the corresponding quantiles
    of the cluster as a whole. This, however, can be done with histograms, since buckets
    from each instance can be summed cluster-wide before calculating the approximate
    quantile. Another common example of this is averaging averages.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 一个与PromQL并无直接关系的错误，但由于语言的灵活性而容易犯的错误，是对聚合值应用变换，从而失去其统计意义。例如，你可能会想对来自一组实例的汇总中的预先计算的分位数进行平均，以了解集群的情况，但从统计学角度来看，这些数据不能进一步操作——这项操作的结果将无法代表整个集群的相应分位数。然而，对于直方图是可以做到的，因为每个实例的桶可以在计算近似分位数之前进行全集群求和。另一个常见的例子是对平均值进行平均。
- en: Knowing what to expect when constructing complex queries
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在构建复杂查询时，知道该期望什么
- en: 'An interesting detail to be mindful of when using PromQL is that, when using
    comparison operators between vectors, the returned result will be from the left-hand
    side of the comparison. This means that, when doing comparisons between a current
    value and a threshold, you should do them in that order (for example,  `current_value
    < threshold`) as you probably want the returned value to be the current value
    and not the threshold:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PromQL 时需要注意的一个有趣细节是，当在向量之间使用比较运算符时，返回的结果将来自比较的左侧部分。这意味着，在进行当前值与阈值的比较时，你应该按此顺序进行（例如，`current_value
    < threshold`），因为你可能希望返回的是当前值，而不是阈值：
- en: '[PRE63]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Furthermore, when chaining different comparisons using `and`, the result will
    still be the left-hand side from the first comparison. The following example returns
    the percentage of space left in a filesystem, which is under 20%, and is predicted
    to be full within 4 hours given the fill rate of the last 6 hours. Note that it''s
    not in read-only mode:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在使用 `and` 连接不同的比较时，结果仍然会是第一个比较的左侧部分。以下示例返回的是文件系统中剩余空间的百分比，且该空间低于 20%，并且根据过去
    6 小时的填充速率，预测在 4 小时内将满。请注意，它不是只读模式：
- en: '[PRE64]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Switching the first comparison with the second would produce the same number
    of results, but would also present the predicted bytes available 4 hours from
    now. This result would be less useful as knowing exactly the amount of negative
    bytes predicted just conveys the fact that they will be 0 in reality. Both expressions
    would be viable for alerting, though, as the resulting value of the expression
    is not sent in the alert notification.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将第一个比较和第二个比较的位置交换，仍然会得到相同数量的结果，但也会展示预测的 4 小时后的可用字节数。这个结果就不那么有用了，因为知道预测的负字节数实际上只传达了它们在现实中会变成
    0 的事实。尽管如此，这两个表达式都可以用于告警，因为表达式的结果不会在告警通知中发送。
- en: The query of death
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 死亡查询
- en: Lastly, care should be taken when crafting queries with overly broad selectors
    and memory-intensive aggregations. While Prometheus has default checks and bounds
    implemented to avoid unlimited memory usage (as discussed in [Chapter 5](12e775c2-bee9-4ebe-ad73-2f9313eeeeee.xhtml),
    *Running a Prometheus Server*), it is still possible to run up against a memory
    limit that is not large enough—either a container limit or even the actual system
    RAM, which would make the OS unceremoniously terminate the Prometheus server.
    Compounding the problem, pinpointing which queries are using the most resources
    is hard, especially in environments where you have little control over what queries
    are sent to the server; there is no slow query log functionality built in as making
    it work would involve some trade-offs that would impact performance and manageability.
    In practice, though, constant improvements to capping resource utilization (especially
    on the memory front) have made it much harder for this particular issue to happen
    in well-dimensioned environments.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在构建包含过于宽泛选择器和内存密集型聚合的查询时，需要小心。虽然 Prometheus 默认实现了检查和边界，以避免无限制的内存使用（如[第 5
    章](12e775c2-bee9-4ebe-ad73-2f9313eeeeee.xhtml)《运行 Prometheus 服务器》所讨论），但仍然可能会遇到内存限制不足的情况——无论是容器限制，还是实际的系统内存不足，这会导致操作系统无情地终止
    Prometheus 服务器。更糟糕的是，确定哪些查询使用了最多的资源是非常困难的，特别是在你对发送到服务器的查询几乎没有控制权的环境中；由于没有内建的慢查询日志功能，启用此功能将涉及一些会影响性能和可管理性的权衡。实际上，尽管如此，不断改进资源利用率限制（特别是在内存方面）使得在良好配置的环境中，这个问题的发生变得更加困难。
- en: Moving on to more complex queries
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理更复杂的查询
- en: With the information that's provided so far, we can move on to more complex
    queries, understand how they are built, and what to expect from them. In the following
    sections, we'll go over some intricate scenarios that demand the use of PromQL
    to explore and solidify the concepts we've covered so far.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 利用目前提供的信息，我们可以继续处理更复杂的查询，理解它们的构建方式，以及如何预期它们的结果。在接下来的部分中，我们将讨论一些复杂的场景，这些场景需要使用
    PromQL 来探索并巩固我们目前已经学习的概念。
- en: In which node is Node Exporter running?
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node Exporter 运行在哪个节点上？
- en: This scenario is designed to assist your understanding of concepts such as `info`
    metrics and the `group_left` modifier.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景旨在帮助你理解诸如 `info` 指标和 `group_left` 修饰符等概念。
- en: Scenario rationale
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景背景
- en: When running on Kubernetes, you might need to troubleshoot a Node Exporter pod,
    and for that you're required to know on which host it's running. Node Exporter
    metrics see the pod and not the host, so you don't have the hostname available
    in the metrics that produced. In this scenario, we are required to add the missing
    information to metrics that didn't have that label originally. Another alternative
    to this scenario would be to make the required information available in the instance
    labels via relabeling.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上运行时，你可能需要排查 Node Exporter pod 的问题，为此你需要知道它运行在哪个主机上。Node Exporter
    指标查看的是 pod 而不是主机，因此你无法在生成的指标中获取主机名。在这种情况下，我们需要将缺失的信息添加到原本没有该标签的指标中。另一种替代方案是通过重新标签化将所需信息放到实例标签中。
- en: PromQL approach
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PromQL 方法
- en: The following query allows us to augment the `node_exporter_build_info` metric
    with yet another label, called `nodename`, which has information regarding the
    hostname running your Node Exporter pod.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询允许我们通过 `group_left` 将另一个名为 `nodename` 的标签添加到 `node_exporter_build_info`
    指标中，该标签包含关于运行 Node Exporter pod 的主机名的信息。
- en: 'In this example, we have the following instant vector:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有以下瞬时向量：
- en: '[PRE65]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This produces the following result:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下结果：
- en: '[PRE66]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We also have `node_uname_info`, which has the `nodename` label:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有 `node_uname_info`，它包含 `nodename` 标签：
- en: '[PRE67]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This translates into the following code:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这将转化为以下代码：
- en: '[PRE68]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'With the help of an info metric, as we described previously, we''ll use the
    following expression to add the `nodename` label from the `node_uname_info` info
    type metric to the `node_exporter_build_info` metric using `group_left`:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 借助我们之前描述的 info 类型指标，我们将使用以下表达式，通过 `group_left` 从 `node_uname_info` info 类型指标将
    `nodename` 标签添加到 `node_exporter_build_info` 指标中：
- en: '[PRE69]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The result can be inspected in the following snippet:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可以通过以下代码片段进行检查：
- en: '[PRE70]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Comparing CPU usage across different versions
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较不同版本的 CPU 使用情况
- en: This scenario is similar to the previous one, but takes it a step further by
    combining metrics from different sources and making them all work together.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景类似于之前的场景，但通过结合来自不同来源的指标，并使它们共同工作，进一步扩展了之前的思路。
- en: Scenario rationale
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景理由
- en: You might want to observe how different software versions behave in terms of
    throughput or resource usage. This might be easier to analyze by graphing the
    patterns before and after the upgrade in clear terms. In this specific example,
    we are going to look at container CPU usage for `node_exporter` before and after
    an upgrade.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想观察不同软件版本在吞吐量或资源使用上的表现。这可以通过在升级前后以清晰的方式绘制图表来更容易地分析。在这个具体示例中，我们将查看 `node_exporter`
    升级前后的容器 CPU 使用情况。
- en: 'Keep in mind a couple of considerations: for the sake of this example, `node_exporter`
    is running as a container, which is ill-advised in a real-world scenario. Furthermore,
    we’ll be using `container_cpu_usage_seconds_total` from cAdvisor instead of `process_cpu_seconds_total`,
    which is collected directly from natively instrumented applications, so that this
    method can be applied to any kind of containerized process, consolidating the
    use of cAdvisor metrics along the way.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住几点考虑事项：为了这个示例，`node_exporter` 作为容器运行，在实际场景中不推荐这样做。此外，我们将使用来自 cAdvisor 的 `container_cpu_usage_seconds_total`，而不是直接从原生检测应用程序收集的
    `process_cpu_seconds_total`，这样这种方法就可以应用于任何类型的容器化进程，同时整合 cAdvisor 指标的使用。
- en: PromQL approach
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PromQL 方法
- en: The `container_cpu_usage_seconds_total` metric gives us the amount of CPU seconds
    spent running each container, and comes from the `cadvisor` exporter. The `node_exporter`
    version can be found in the `node_exporter_build_info` metric. To make things
    a bit harder, since the container metrics come from `cadvisor`, the container
    and pod registered in those metrics are the `cadvisor` ones and not from the target
    pods; however, we can find the original container names and pod names in the `container_label_io_kubernetes_container_name`
    and `container_label_io_kubernetes_pod_name` labels, respectively.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`container_cpu_usage_seconds_total` 指标告诉我们每个容器运行时消耗的 CPU 秒数，来自 `cadvisor` 导出器。`node_exporter`
    版本可以在 `node_exporter_build_info` 指标中找到。为了增加难度，由于容器指标来自 `cadvisor`，因此这些指标中注册的容器和
    pod 是 `cadvisor` 的，而不是目标 pod 的；但是，我们可以在 `container_label_io_kubernetes_container_name`
    和 `container_label_io_kubernetes_pod_name` 标签中分别找到原始的容器名称和 pod 名称。'
- en: 'The first thing we need to do is get the average number of CPU seconds per
    second each pod is using on a rolling window of one minute:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是获取每个 pod 在一分钟滚动窗口内使用的平均 CPU 秒数：
- en: '[PRE71]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Next, we need to create a new label in `node_exporter_build_info` so that matching
    works as intended. For this use case, we can use either `label_join` or `label_replace`,
    as we''re just reading one label and writing its contents verbatim in another:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Alternatively, we can use the following code:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Finally, we just need to match both metrics through their common label, `container_label_io_kubernetes_pod_name`,
    by using `on()` and then ask for the version label to be joined to the CPU expression''s
    label set by using `group_left()`. Let''s put that all together:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '![](img/f0716997-1497-4298-a144-62225620c708.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.13: Node exporter version upgrade impact on CPU usage'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: All of this might seem complex at first but after you try out these concepts
    for yourself they quickly become much easier to understand, apply and to reason
    about.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the basics of PromQL, from selectors to functions,
    covering concepts such as binary operators, vector matching, and aggregations.
    Going through the common patterns and pitfalls, we were introduced to how this
    language allows much more than simple querying and how it has become an essential
    infrastructure tool, helping with the design and management of SLIs and SLOs.
    We also demonstrated several scenarios where PromQL shines, and how seemingly
    complex queries are not that complex after all.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, [Chapter 8](19357d8c-dfcf-4497-ae80-4761f6633d14.xhtml), *Troubleshooting
    and Validation*, we'll delve into how to validate a healthy Prometheus setup and
    learn how to troubleshoot issues quickly, ensuring the stability of the monitoring
    stack.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the six available comparison operators in PromQL?
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should a `group_right` modifier be used instead of a `group_left` one?
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why shouldn't you use the `sort()` function when applying the `topk` aggregation
    operator?
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the major difference between `rate()` and `irate()`?
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which type of metric has an `_info` suffix and what is its purpose?
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should you sum and then rate or rate and then sum?
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you get the average CPU usage for the last five minutes in a percentage?
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Querying Prometheus**: [https://prometheus.io/docs/prometheus/latest/querying/basics/](https://prometheus.io/docs/prometheus/latest/querying/basics/)'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SRE Book - Service Level Objectives**: [https://landing.google.com/sre/sre-book/chapters/service-level-objectives/](https://landing.google.com/sre/sre-book/chapters/service-level-objectives/)'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
