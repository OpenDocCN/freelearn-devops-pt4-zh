- en: Defining Alerting and Recording Rules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义告警规则和记录规则
- en: Recording rules are a useful concept of Prometheus. They allow you to speed
    up heavy queries and enable subqueries in PromQL that otherwise would be very
    expensive. Alerting rules are similar to recording rules, but with alert-specific
    semantics. As testing is a fundamental part of any system, you'll have the opportunity
    in this chapter to learn how to ensure that recording and alerting rules behave
    as expected before being deployed. Understanding these constructs will help make
    Prometheus faster and more robust, as well as enabling its alerting capabilities.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 记录规则是 Prometheus 中一个非常有用的概念。它们使你能够加速繁重的查询，并在 PromQL 中启用本来非常昂贵的子查询。告警规则类似于记录规则，但具有告警特定的语义。由于测试是任何系统中的基础部分，本章将提供学习如何确保记录和告警规则在部署前按预期工作的机会。理解这些结构将有助于提升
    Prometheus 的性能和鲁棒性，并启用其告警能力。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Creating the test environment
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建测试环境
- en: How does rule evaluation work?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则评估是如何工作的？
- en: Setting up alerting in Prometheus
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Prometheus 中设置告警
- en: Testing your rules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试你的规则
- en: Creating the test environment
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建测试环境
- en: In this chapter, we'll be focusing on the Prometheus server and we'll be deploying
    a new instance so that we can apply the concepts covered.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注 Prometheus 服务器，并且将部署一个新的实例，以便应用所覆盖的概念。
- en: Deployment
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: 'Let''s begin by creating a new instance of Prometheus and deploying it to the
    server:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从创建一个新的 Prometheus 实例并将其部署到服务器上开始：
- en: 'To create a new instance of Prometheus, move into the correct repository path:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个新的 Prometheus 实例，请进入正确的仓库路径：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Ensure that no other test environments are running and spin up this chapter''s
    environment:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保没有其他测试环境正在运行，然后启动本章的环境：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Validate the successful deployment of the test environment using the following
    code:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码验证测试环境是否成功部署：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will output the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The new instance will be available for inspection and the Prometheus web interface
    will be accessible at `http://192.168.42.10:9090`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 新实例将可供检查，Prometheus 的 Web 界面将可以通过 `http://192.168.42.10:9090` 访问。
- en: 'You can now access the `prometheus` instance by executing the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过执行以下命令访问 `prometheus` 实例：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that you're connected to the `prometheus` instance, you can validate the
    instructions described in this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经连接到 `prometheus` 实例，你可以验证本章中描述的指令。
- en: Cleanup
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理
- en: 'When you''ve finished testing, make sure that you''re inside `chapter09/` and
    execute the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 测试完成后，请确保你位于 `chapter09/` 目录内，并执行以下命令：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Don't worry too much; you can easily spin up the environment again if you so
    require.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不用太担心，如果需要，你可以轻松地重新启动环境。
- en: Understanding how rule evaluation works
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解规则评估是如何工作的
- en: Prometheus allows the periodic evaluation of PromQL expressions and the storage
    of the time series generated by them; these are called **rules**. There are two
    types of rules, as we'll see in this chapter. These rules are *recording* and
    *alerting* rules. They share the same evaluation engine, but have some variation
    in purpose, which we'll go into next.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 允许周期性地评估 PromQL 表达式，并存储由这些表达式生成的时间序列；这些被称为 **规则**。本章中我们将看到这两种规则类型。它们分别是
    *记录*规则和*告警*规则。它们共享相同的评估引擎，但在目的上有所不同，我们将在接下来的内容中详细探讨。
- en: The recording rules' evaluation results are saved into the Prometheus database
    as samples for the time series specified in the configuration. This type of rule
    can help take the load off of heavy dashboards by pre-computing expensive queries,
    aggregating raw data into a time series that can then be exported to external
    systems (such as higher-level Prometheus instances through federation, as described
    in [Chapter 13](3615e455-c55b-49af-8c9b-b5342d4859dd.xhtml), *Scaling and Federating
    Prometheus*), and can help to create compound range vector queries (while recording
    rules were the only way to do this in the past, the new subquery syntax enabled
    exploratory use cases for these).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 记录规则的评估结果将作为样本保存到 Prometheus 数据库中，针对配置中指定的时间序列。这类规则可以通过预计算昂贵的查询，将原始数据聚合为时间序列来减轻重型仪表板的负担，随后可以将其导出到外部系统（例如通过联邦机制导出到更高层次的
    Prometheus 实例，具体内容请见 [第13章](3615e455-c55b-49af-8c9b-b5342d4859dd.xhtml)，*扩展与联邦化
    Prometheus*），并且有助于创建复合的范围向量查询（虽然记录规则过去是唯一的实现方式，但新的子查询语法使得这类用例的探索成为可能）。
- en: Alerting rules trigger when an evaluated PromQL expression in a rule produces
    a non-empty result. They are the mechanism by which alerting over time series
    is done in Prometheus. Alerting rules also produce new time series when they trigger,
    but don't use the evaluation result as a sample; instead, they create an `ALERTS`
    metric with the alert name and state as labels, as well as any additional labels
    defined in the configuration. This will be further analyzed in the next section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Using recording rules
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rules are defined separately from the main Prometheus configuration file, and
    are included by the latter through the `rule_files` top-level configuration key.
    They are evaluated periodically, and that interval can be defined globally with
    `evaluation_interval` inside `global` (defaults to one minute).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this by looking at the configuration provided with the test environment:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`rule_files` takes a list of paths, which can be relative to the main Prometheus
    configuration or absolute paths. Additionally, globs can be used to match filenames
    (not directories); for example, `/etc/prometheus/rules/*.yml`. Changes in rule
    files are not automatically picked up by Prometheus, so a reload is needed (as
    described in [Chapter 5](12e775c2-bee9-4ebe-ad73-2f9313eeeeee.xhtml), *Running
    a Prometheus Server*). Prometheus will fail to reload if any error are found in
    rule files, and will keep running using the previous configuration. However, if
    the server is restarted, it will fail to start. To make sure that this does not
    happen, `promtool` can be used to test for errors in advance (as explained in
    [Chapter 8](19357d8c-dfcf-4497-ae80-4761f6633d14.xhtml), *Troubleshooting and
    Validation*) – this is strongly recommended when using automation to deploy rules.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the `prometheus.yml` configuration file, the `rules` files are also
    defined in are YAML format. The actual format is very easy to understand:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Each file defines one or more rule groups under the `groups` key. Each group
    has a `name`, an optional evaluation `interval` (which defaults to the global
    evaluation interval defined in the main Prometheus configuration file), and a
    list of `rules`. Each rule instructs Prometheus to record the result of evaluating
    the PromQL expression defined in `expr` into the specified metric name, optionally
    adding or overriding the series label set before storing the result by setting
    them in `labels`. The rules in each group are evaluated sequentially in the order
    they are declared, which means that a time series generated by a rule can safely
    be used in subsequent rules within the same group. Samples generated by rules
    will have the timestamp corresponding to the rule group evaluation time. The next
    figure illustrates the process previously mentioned:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74b724c0-a869-455c-8a0d-1382e5fab039.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: The Rule Manager is the Prometheus internal subsystem responsible
    for the periodic evaluation of rules according to their group''s evaluation interval,
    as well as managing the alerting life cycle'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1：规则管理器是Prometheus的内部子系统，负责根据规则组的评估间隔定期评估规则，并管理警报生命周期。
- en: 'Let''s have a look at the recording rules available in the test environment
    for this chapter:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下在本章测试环境中可用的录制规则：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This file has two rule groups, named `recording_rules` and `different_eval_interval`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件有两个规则组，分别命名为`recording_rules`和`different_eval_interval`：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first rule group is composed of a single recording rule, which is using
    the global evaluation interval, taking the `node_cpu_seconds_total` metric from
    the Node Exporter to count the number of CPU cores available in the **virtual
    machine** (**VM**), and recording that result into a new time series named `instance:node_cpu:count`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个规则组由一个录制规则组成，使用全局评估间隔，采用`node_cpu_seconds_total`指标，从Node Exporter获取该指标，以计算**虚拟机**（**VM**）中可用的CPU核心数，并将结果录制到一个新的时间序列`instance:node_cpu:count`中。
- en: 'The second rule group is busier; it shows a custom evaluation interval for
    the group and a recording rule using the time series generated by previous rules
    in the group. We won''t go into exactly what these rules are doing, as they will
    serve as examples for the following rule naming conventions section, but the evaluation
    interval can be seen here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个规则组更为复杂；它为该组显示了自定义评估间隔，并使用该组中先前规则生成的时间序列作为录制规则。我们不会深入讨论这些规则的具体作用，因为它们将作为接下来规则命名约定部分的示例，但可以看到这里的评估间隔：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'By declaring an evaluation interval in this second rule group, we are overriding
    the configuration set in the `global` section of `prometheus.yml`—the rules in
    this group will produce samples at the specified frequency. This was done for
    demonstration purposes only; setting different intervals is usually discouraged,
    for the same reasons as in scrape jobs: queries might produce erroneous results
    when using a series with different sampling rates, and having to periodically keep
    track of what series have what becomes unmanageable.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在第二个规则组中声明评估间隔，我们正在覆盖`prometheus.yml`的`global`部分中的配置——此组中的规则将在指定的频率下生成样本。这样做仅用于演示目的；通常不建议设置不同的间隔，原因与抓取作业相同：当使用具有不同采样率的系列时，查询可能会产生错误的结果，而且需要定期跟踪每个系列的不同采样率变得不可管理。
- en: 'Prometheus provides a status page in the web **user interface** (**UI**) where
    a user can check the loaded rule groups along with their enclosed recording rules,
    their recording state, how long the last evaluation took for each, and how long
    ago they were run. You can find this page by going into Status | Rules on the
    top bar:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus提供了一个状态页面，在Web**用户界面**（**UI**）中，用户可以查看已加载的规则组及其包含的录制规则、录制状态、每个规则的最后一次评估所需时间，以及它们上次运行的时间。您可以通过进入顶部栏的状态
    | 规则来找到这个页面：
- en: '![](img/6d4c3893-2aff-4b18-9bb2-5656f04eed6d.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d4c3893-2aff-4b18-9bb2-5656f04eed6d.png)'
- en: 'Figure 9.2: Prometheus web interface showing the /rules endpoint'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2：Prometheus Web 界面显示/rules端点
- en: With this information, we have now the fundamentals on how to create recording
    rules. Next, we'll explore the naming convention that the Prometheus community
    has agreed upon for recording rules.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，我们现在掌握了如何创建录制规则的基本知识。接下来，我们将探讨Prometheus社区为录制规则约定的命名规则。
- en: Naming convention for recording rules
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 录制规则的命名约定
- en: Recording rule name validation abides by the same regular expression as metric
    names, and so rules can technically be named the same as any other metric. However,
    having clear standards when naming recording rules can make it easier to identify
    them among scraped metrics, know from which metrics they were derived, and understand
    what aggregations were applied to them.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 录制规则名称的验证遵循与度量名称相同的正则表达式，因此，规则技术上可以与任何其他度量名称相同。然而，制定清晰的命名标准能使得在抓取的度量中更容易识别录制规则，知道它们来源于哪些度量，以及理解应用了哪些聚合。
- en: The Prometheus community has gravitated toward a well-defined naming convention
    for recording rules. This is based on years of experience running Prometheus at
    scale. This enables all of the aforementioned advantages when used correctly.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus社区已经趋向于为录制规则制定一个明确的命名约定。这是基于多年的经验，在大规模运行Prometheus时积累的。这能在正确使用时提供所有上述优势。
- en: 'The recommended convention for recording rule naming is composed of three sections,
    separated by colons, and takes the following form: `level:metric:operations`.
    The first section represents the aggregation level of the rule, which means that
    it will list the labels/dimensions that are present and relevant (usually separated
    by underscores); the second section is the metric name that was the basis for
    the rule; and the third section lists the aggregation operations that were applied
    to the metric.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 记录规则命名的推荐约定由三个部分组成，使用冒号分隔，格式如下：`level:metric:operations`。第一部分表示规则的聚合级别，意味着它将列出相关的标签/维度（通常以下划线分隔）；第二部分是作为规则基础的指标名称；第三部分列出了应用于指标的聚合操作。
- en: 'The recording rules presented in this chapter all follow this convention, so
    let''s have a look at the second rule group available in the test environment:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的记录规则都遵循这一约定，因此让我们看一下在测试环境中可用的第二条规则组：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Looking at the naming of the first rule, we can easily understand that the rule
    is based on the `prometheus_http_request_duration_seconds_sum` metric; `rate5m`
    indicates that `rate()` is being applied to a range vector of five minutes, and
    the interesting labels present are `handler` and `instance`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一条规则的命名来看，我们可以轻松理解该规则基于`prometheus_http_request_duration_seconds_sum`指标；`rate5m`表示对五分钟的时间范围应用了`rate()`函数，且有两个有趣的标签：`handler`和`instance`。
- en: The same logic is applied to the second rule, but this time using the `prometheus_http_request_duration_seconds_count`
    metric. The third rule, however, is a bit more nuanced; as it is dividing `_sum`
    by the `_count` of latency events, it effectively represents the five-minute latency
    average of, in this case, HTTP requests served by Prometheus. As we aggregated
    the `instance` label away, the `level` section reflects this by only having `handler`
    as the relevant dimension. The last thing to note is that the metric name for
    this rule is now `prometheus_http_request_duration_seconds`, as it neither represents
    the sum nor the count, but it still makes it possible to clearly understand which
    metrics this rule is based on.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条规则应用了相同的逻辑，但这次使用的是`prometheus_http_request_duration_seconds_count`指标。第三条规则则稍微复杂一些；因为它是将`_sum`除以延迟事件的`_count`，它实际上代表了五分钟的延迟平均值，在这种情况下是Prometheus提供的HTTP请求的延迟。由于我们将`instance`标签聚合掉了，`level`部分通过仅保留`handler`作为相关维度来反映这一点。最后需要注意的是，这条规则的指标名称现在是`prometheus_http_request_duration_seconds`，因为它既不代表总和也不代表计数，但它仍然可以清楚地理解该规则所基于的指标。
- en: Naming recording rules can be a hard task, a balancing act between precisely
    representing all the factors at play and being concise enough for metric names
    to be manageable. When you find yourself in a situation where it isn't immediately
    clear how to name a recording rule given its expression, a good rule of thumb
    to follow is to make sure another person that is aware of this naming convention
    can tie the rule back to the metric used, what labels/dimensions should be present,
    and what transformations were applied.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 命名记录规则可能是一项困难的任务，需要在精确表示所有相关因素和简洁管理指标名称之间取得平衡。当你遇到这种情况——无法立即清楚如何根据表达式命名记录规则时，一个好的经验法则是确保另一个熟悉这种命名约定的人可以将该规则与使用的指标、应该存在的标签/维度以及应用的变换联系起来。
- en: Setting up alerting in Prometheus
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Prometheus中设置告警
- en: So far, we have covered how PromQL can be invaluable in querying the collected
    data, but when we require an expression to be continuously evaluated so that an
    event is triggered when a defined condition is met, we're promptly stepping into
    alerting. We explained how alerting is one of the components of monitoring in
    [Chapter 1](4214ddff-8289-4dc6-b0ef-240510a22192.xhtml), *Monitoring Fundamentals*.
    To be clear, Prometheus is not responsible for issuing email, Slack, or any other
    forms of notification; that is the responsibility of another service. This service
    is typically Alertmanager, which we'll go over in [Chapter 11](db658650-14d2-4a7e-9ae0-1c003e63109c.xhtml),
    *Understanding and Extending Alertmanager*. Prometheus leverages the power of
    alerting rules to push alerts, which we'll be covering next.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: What is an alerting rule?
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An alerting rule is much like a recording rule with some additional definitions;
    they can even share the same rule group without any issues. The biggest difference
    is that, when firing, they are sent to an external endpoint via an HTTP POST with
    a JSON payload for further processing. Expanding on the term active, in this context,
    we are talking about when the current state differs from the desired state, which
    boils down to when an expression returns one or more samples.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Alerting rules, such as recording rules, rely on PromQL expressions that are
    evaluated on a defined interval. This interval can be a globally configured one
    or can be local to the specific rule group. In each of the interval iterations,
    triggered alerts are validated to ensure that they're still active; if not, they're
    considered to be resolved.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: For every sample returned by our expression, it will trigger an alert. This
    is important to keep in mind, because a relaxed PromQL expression can generate
    a deluge of alerts, so keep them as aggregated as possible.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Configuring alerting rules
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate how to create and understand alerting rules, we'll guide you
    through the entire process. This will touch not only on the main Prometheus configuration
    file, but also on rule files and how the web interface of the server behaves with
    regard to alerts.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus server configuration file
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside this chapter''s test environment, we can find the following Prometheus
    configuration:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this configuration, there are three components to be aware of:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '`evaluation_interval`: This is responsible for defining the global evaluation
    interval for recording and alerting rules, which can be overridden at the rule
    group level using the `interval` keyword.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rule_files`: This is the file location where Prometheus can read the configured
    recording and/or alerting rules.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alerting`: This is the endpoint(s) where Prometheus sends alerts for further
    processing.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the alerting section, we've configured `“prometheus:5001”`. Behind this endpoint,
    there is nothing more than a small service, called **alertdump**, that is listening
    on port `5001` for the HTTP POST requests and is simply dumping their payload
    onto a log file. This will help dissect what Prometheus sends when an alert is
    firing.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Rule file configuration
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previously, we took a look at the Prometheus configuration file; we''ll now
    move onto the provided alerting rules example, which we can see in the following
    snippet:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s look at the `NodeExporterDown` alert definition more closely. We can
    split the configuration into five distinct sections: `alert`, `expr`, `for`, `labels`,
    and `annotations`. We''ll now go over each one of these in the next table:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '| **Section** | **Description** | **Mandatory** |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| `alert` | The alert name to use | Yes |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| `expr` | The PromQL expression to evaluate | Yes |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| `for` | The time to ensure that the alert is being triggered before sending
    the alert, defaults to 0 | No |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| `labels` | User-defined key-value pairs | No |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| `annotations` | User-defined key-value pairs | No |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: The Prometheus community typically uses CamelCase for alert naming.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus does not carry out validation to check whether an alert name is already
    in use, so it is possible for two or more alerts to share the same name but evaluate
    different expressions. This might cause issues, such as tracking which specific
    alert is triggering, or writing tests for alerts.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NodeExporterDown` rule will only trigger when the `up` metric with the
    `job=”node”` selector is not `1` for more than one minute, which we''ll now test
    by stopping the Node Exporter service:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We''re now forcing an alert to become active. This will force the alert to
    go through three different states:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '| **Order** | **State** | **Description** |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: '| 1 | Inactive | Not yet pending or firing |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: '| 2 | Pending | Not yet active long enough to become firing |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '| 3 | Firing | Active `for` more than the defined `for` clause threshold |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: 'Going to the `/alerts` endpoint on the Prometheus server web interface, we
    can visualize the three different states for the `NodeExporterDown` alert. First,
    the alert is inactive, as we can see in the following figure:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1780ac8-5699-40ba-ac51-fe19d917fb04.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: The NodeExporterDown alert is inactive'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can see the alert in a pending state. This means that, while the alert
    condition has been triggered, Prometheus will continue to check whether that condition
    keeps being triggered for each evaluation cycle until the `for` duration has passed.
    The next figure illustrates the pending state; notice that the **Show annotations**
    tick box is selected, which expands the alert annotations:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b30ea059-23e0-4025-95e2-19505112ae71.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: The NodeExporterDown alert is pending'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can see the alert turn to firing. This means that the alert is
    active for more than the duration defined by the `for` clause – in this case,
    1 minute:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e0284b0-8f88-4c81-a54b-f19bb7618cb7.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: The NodeExporterDown alert is firing'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'When an alert becomes firing, Prometheus sends a JSON payload to the configured
    alerting service endpoint, which, in our case, is the alertdump service, which
    is configured to log to the `/vagrant/cache/alerting.log` file. This makes it
    very easy to understand what kind of information is being sent and can be validated
    as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that we've seen how to configure some alerting rules and validated what
    Prometheus is sending to the configured alerting system, let's explore how to
    enrich those alerts with contextual information by using labels and annotations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Labels and annotations
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the alert rule definition, there were two optional sections: labels and
    annotations. Labels define the identity of an alert and they can change according
    to the evaluation cycle they''re in; if they do this, it will alter the alert
    identity. To demonstrate this point, we''ll introduce the `ALERTS` metric, which
    tracks all active alerts and their labels. As we can see in the following figure,
    we have a label called `alertstate`, which tracks the alert state and transitions
    from `pending` to `firing`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb8a64c2-1844-4c5d-8e47-a29cba583986.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: The ALERTS metric'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Something to keep in mind is the issue of using a sample value in a label. Although
    it is technically possible, it's also a very bad idea. Doing so will change the
    alert identity every time the value changes, and, as such, will always be restarting
    the defined `for` countdown, resulting in an alert that will never enter the `firing`
    state.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, annotations do not belong to the identity of an alert, and,
    as such, are not stored in the `ALERTS` metric. These are useful to enrich the
    alert with more context and information. Annotations are also templated using
    the Go templating language, as we saw in our example. By using the `{{ .Labels.instance
    }}` template syntax, we are accessing the available alert labels, selecting the
    `instance` label, and using its value in the annotation `description` field. The
    value of the firing sample is available by using `{{ .Value }}`, if required.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: The Golang template `.Labels` and `.Value` variables are also available as `$labels`
    and `$value` for convenience.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows the alert rule in our example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will produce the following rendered result when `firing`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can find more information regarding Golang templating at [https://golang.org/pkg/text/template/](https://golang.org/pkg/text/template/).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Delays on alerting
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous topics, we talked about the three states that an alert goes
    through; but there''s more to it when calculating the total time required for
    an alert to become firing. First, there''s the scrape interval (which, in our
    example, is 30 seconds, although generally the scrape and evaluation intervals
    should be the same for clarity), we then have the rule evaluation interval (in
    our case, it was globally defined as 1 minute), and, finally, there''s the 1 minute
    defined in the alert rule''s `for` clause. If we put all of these variables together,
    the time for this alert to be considered as `firing` can take up to 2 minutes
    and 30 seconds in the worst-case scenario. The next figure illustrates this example
    situation:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的主题中，我们讨论了警报会经历的三个状态；但是在计算警报变为触发状态所需的总时间时，还需要考虑其他因素。首先是抓取间隔（在我们的示例中是 30 秒，虽然通常抓取和评估间隔应该相同以便于理解），然后是规则评估间隔（在我们的例子中全局定义为
    1 分钟），最后是警报规则中 `for` 子句定义的 1 分钟。如果将这些变量都考虑在内，警报被认为是 `firing` 的时间，在最坏情况下可能需要 2
    分钟 30 秒。下图展示了这个示例情况：
- en: '![](img/8973ea05-760e-4131-8a83-38b670f8c308.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8973ea05-760e-4131-8a83-38b670f8c308.png)'
- en: 'Figure 9.7: Alert delay visualized'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7：警报延迟可视化
- en: All these delays are just on the Prometheus side. The external service processing
    the alert sent may have other constraints, which can make the global delay until
    a notification is sent even longer.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些延迟仅发生在 Prometheus 端。处理发送警报的外部服务可能会有其他约束，这可能导致从发送通知到最终发送的全球延迟更长。
- en: Before Prometheus 2.4.0, the `pending` and `firing` states were not persistent
    across restarts, which could extend the delay for alerting even further. This
    was solved by implementing a new metric, called `ALERTS_FOR_STATE`, which stores
    the alert states. You can find the release notes for Prometheus 2.4.0 at [https://github.com/prometheus/prometheus/releases/tag/v2.4.0](https://github.com/prometheus/prometheus/releases/tag/v2.4.0).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Prometheus 2.4.0 之前，`pending` 和 `firing` 状态在重启后不会持久化，这可能会进一步延长警报的延迟。通过实现一个新的度量指标
    `ALERTS_FOR_STATE`，来存储警报状态，从而解决了这个问题。你可以在 [https://github.com/prometheus/prometheus/releases/tag/v2.4.0](https://github.com/prometheus/prometheus/releases/tag/v2.4.0)
    查阅 Prometheus 2.4.0 的发布说明。
- en: Testing your rules
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的规则
- en: In [Chapter 8](19357d8c-dfcf-4497-ae80-4761f6633d14.xhtml), *Troubleshooting
    and Validation*, we went through the features that `promtool` has to offer, with
    the exception of testing. The `test rules` subcommand can simulate the periodic
    ingestion of samples for several time series, use those series to evaluate recording
    and alerting rules, and then test whether the recorded series match what was configured
    as the expected results. Now that we understand recording and alerting rules,
    we'll look at how to ensure that they behave as expected, by creating unit tests
    and using `promtool` to validate our rules.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](19357d8c-dfcf-4497-ae80-4761f6633d14.xhtml)《故障排除与验证》中，我们介绍了 `promtool`
    的一些功能，测试功能除外。`test rules` 子命令可以模拟多个时间序列的周期性样本摄取，利用这些时间序列评估记录和警报规则，然后测试记录的系列是否与配置的预期结果匹配。现在我们已经了解了记录和警报规则，接下来将通过创建单元测试并使用
    `promtool` 来验证我们的规则，确保它们按预期工作。
- en: Recording rules tests
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录规则测试
- en: 'The `promtool` tool included in the Prometheus binary distribution allows us
    to define test cases to validate that the rules we write behave as expected. The
    test environment for this chapter also comes with a suite of pre-built tests for
    the rules we''ve explored so far. You can have a look at the configuration here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 二进制分发包中包含的 `promtool` 工具允许我们定义测试用例来验证我们编写的规则是否按预期工作。本章的测试环境还提供了一套针对我们到目前为止探索的规则的预构建测试。你可以在这里查看配置：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This file has tests for all recording and alerting rules presented in this
    chapter. Although you don''t need to define every test in a single file (it is,
    in fact, tidier to do a test file per rule group to keep things organized), this
    was done in this case for simplicity. For now, let''s analyze only the recording
    rules, as they are simpler to grasp. The top-level configuration keys for the
    test file defines which rule files to load and the default evaluation interval
    for the tests, which governs the periodicity of recording and alerting rule evaluation
    when they don''t explicitly state their own:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: While the `rule_files` configuration key in the test files might look the same
    as in the main Prometheus configuration file, it does not support globing (using
    filename wildcards).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Following these global configurations comes the definition of the test cases,
    under the `tests` key. You can define multiple test packs, each with their own
    simulated scrape intervals, collected series, and rules under test. Let''s have
    a look at the first test defined in the file, to which we added some comment to
    make it easier to understand:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`interval` sets the time that interval samples are generated in our simulated
    time series:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The list of `input_series` define what time series to generate and what values
    to produce in each iteration of the simulated collection interval:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The list of PromQL expressions to test is defined as `promql_expr_test`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Each `expr` defines a particular expression:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The point in time at which this expression will be run is set by setting `eval_time`,
    and the expected samples should be returned by running that expression as `exp_samples`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this test pack, we can see four time series being generated every 15 seconds
    for the same metric, `node_cpu_seconds_total`. As the actual value of these series
    isn't relevant for this recording rule (it only counts the number of CPUs per
    instance), a value of `1` was set for every sample. Do note the variation of labels
    present, namely that the `prometheus:9100` instance is reporting metrics for two
    CPUs and `example:9100` for one. The actual test is just validating that, when
    the `instance:node_cpu:count` expression is evaluated at `t=1m` (as if 1 minute
    had passed after the generated collection started), the returned samples should
    show the correct count of CPUs for each instance.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to execute the tests using the following instruction:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This ensures that the recording rule configured behaves the way we were expecting.
    You can try breaking the test by removing one of the input series from the `prometheus:9100`
    instance in the `instance:node_cpu:count` test pack. When you run the tests again,
    the following will be displayed, as one of the tests is now failing:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: What this output tells us is that `promtool` was expecting the defined set of
    samples, but a different set of samples was returned. You can see that, just as
    we configured, the recording rule now only reports one CPU for the `prometheus:9100`
    instance. This gives us confidence that the rule is behaving exactly as we wanted.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'The tests for the second recording rule group are mostly the same, but they
    showcase a powerful notation for generating a richer input series:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is called an **expanding notation**. This is a compact way of declaring
    a formula for the generation of time series values over time. It takes the form
    of either `A+BxC` or `A-BxC`, where `A` is the starting value, `B` is the amount
    of increase (when preceded by `+`) or decrease (when preceded by `-`) the series
    value should have in each iteration, and `C` is how many iterations this increase
    or decrease should be applied for.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming back to our example, `0+5x60` will expand to the following series:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can mix and match literal values with expanding notation when declaring
    the values for an input time series. This allows you to create complex behavior
    with ease. Take the following example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This will be expanded into the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Testing is fundamental to avoid unforeseen problems and, with the information
    covered so far, you're now able to generate your own unit tests for recording
    rules. Next, we'll continue tackling unit tests, but this time specifically related
    to alerting rules.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Alerting rules tests
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unit tests for alerting rules are quite similar to the ones used for recording
    rules. We''ll be using the example alert provided earlier in this chapter to perform
    a walkthrough on how to configure alerting tests and how to validate them. As
    mentioned before, the test environment for this chapter comes with a suite of
    tests for the rules presented here, including the alert rule we''re interested
    in. Once again, you can have a look at the test file using the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Focusing solely on the alerting component, we can see that we first define
    where the alerting rules are located:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The default rule evaluation interval is shared between recording and alerting
    rules in the same file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The alerting test is conveniently in its own test group, so let''s have a look
    at its full definition:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The test group definition is the same as explained previously, with the exception
    of the `alert_rule_test` section, which is where we define alerting tests. A thing
    to note in this example is that the second input series should never be picked
    up by our testing rule, as the defined alert is specifically matching `job="node"`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It's not mandatory to have `alert_rule_test` and `promql_expr_test` in separate
    test blocks; you may have both in the same test group when you have recording
    and alerting rules using the same input time series and with the same evaluation
    interval.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: The `alert_rule_test` section lists what alerts should be evaluated (`alertname`)
    at what time relative to the simulated start of the test run (`eval_time`). If
    the alert is expected to be firing at that time, an additional `exp_alerts` section
    should be defined listing what set of expected labels (`exp_labels`) and annotations
    (`exp_annotations`) should be present for each instance of the alert. Leaving
    the `exp_alerts` section empty means that the alert is not expected to be firing
    at the given time.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The first alerting test will be executed at the third minute, and, as the matching
    series we provided previously returns the value `1` at that moment, the alert
    expression defined at `alerting_rules.yml` will not trigger – this means that
    no data is returned by the expression defined in the alert.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The second alerting rule will be executed at the fourth minute and will return
    data, as the matching series we provided has the sample value `0` at that specific
    moment. All the labels returned by the alerting rule needs to be explicitly checked.
    The test must also check all the descriptions returned by the alert, with any
    templated variable fully expanded.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run the test using the following instruction:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As an extra step, try changing the description of the second alert from `prometheus:9100`
    to something like `prometheus:9999` and run the test again. You should get the
    following output:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: While this alert is very simple and easy for determining in which conditions
    it will fire, tests for alerting rules provide you with the assurance that alerts
    will trigger when conditions that you can't reasonably reproduce in your environment
    happen.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had the opportunity to observe a different way to produce
    a derivative time series. Recording rules help improve monitoring system stability
    and performance when recurrent heavy queries are required by pre-computing them
    into new time series that are comparatively cheap to consult. Alerting rules bring
    the power and flexibility of PromQL to alerts; they enable triggering alerts for
    complex and dynamic thresholds as well as targeting multiple instances or even
    different applications using a single alert rule. Having a good grasp on how delays
    are introduced in alerts will now help you tailor them to your needs, but remember,
    a little delay is better than noisy alerts. Finally, we explored how to create
    unit tests for our rules and validate them even before a Prometheus server is
    running.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chapter will step into another component of monitoring: visualization.
    We''ll be diving into Grafana, the community-preferred choice for Prometheus-powered
    dashboards.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the primary uses for recording rules?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you avoid setting different evaluation intervals in rule groups?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you were presented with the `instance_job:latency_seconds_bucket:rate30s`
    metric, what labels would you expect to find and what would be the expression
    used to record it?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is using the sample value of an alert in the alert labels a bad idea?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the pending state of an alert?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How long would an alert wait between being triggered and transitioning to the
    `firing` state when the `for` clause is not specified?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you test your rules without using Prometheus?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Prometheus recording rules**: [https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/](https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule naming best practices**: [https://prometheus.io/docs/practices/rules/](https://prometheus.io/docs/practices/rules/)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prometheus alerting rules**: [https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/](https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prometheus unit testing**: [https://prometheus.io/docs/prometheus/latest/configuration/unit_testing_rules/](https://prometheus.io/docs/prometheus/latest/configuration/unit_testing_rules/)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
