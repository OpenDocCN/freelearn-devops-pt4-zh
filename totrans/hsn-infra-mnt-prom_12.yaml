- en: Defining Alerting and Recording Rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recording rules are a useful concept of Prometheus. They allow you to speed
    up heavy queries and enable subqueries in PromQL that otherwise would be very
    expensive. Alerting rules are similar to recording rules, but with alert-specific
    semantics. As testing is a fundamental part of any system, you'll have the opportunity
    in this chapter to learn how to ensure that recording and alerting rules behave
    as expected before being deployed. Understanding these constructs will help make
    Prometheus faster and more robust, as well as enabling its alerting capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the test environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does rule evaluation work?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up alerting in Prometheus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing your rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the test environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll be focusing on the Prometheus server and we'll be deploying
    a new instance so that we can apply the concepts covered.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin by creating a new instance of Prometheus and deploying it to the
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new instance of Prometheus, move into the correct repository path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that no other test environments are running and spin up this chapter''s
    environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Validate the successful deployment of the test environment using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The new instance will be available for inspection and the Prometheus web interface
    will be accessible at `http://192.168.42.10:9090`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now access the `prometheus` instance by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now that you're connected to the `prometheus` instance, you can validate the
    instructions described in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Cleanup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you''ve finished testing, make sure that you''re inside `chapter09/` and
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry too much; you can easily spin up the environment again if you so
    require.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how rule evaluation works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prometheus allows the periodic evaluation of PromQL expressions and the storage
    of the time series generated by them; these are called **rules**. There are two
    types of rules, as we'll see in this chapter. These rules are *recording* and
    *alerting* rules. They share the same evaluation engine, but have some variation
    in purpose, which we'll go into next.
  prefs: []
  type: TYPE_NORMAL
- en: The recording rules' evaluation results are saved into the Prometheus database
    as samples for the time series specified in the configuration. This type of rule
    can help take the load off of heavy dashboards by pre-computing expensive queries,
    aggregating raw data into a time series that can then be exported to external
    systems (such as higher-level Prometheus instances through federation, as described
    in [Chapter 13](3615e455-c55b-49af-8c9b-b5342d4859dd.xhtml), *Scaling and Federating
    Prometheus*), and can help to create compound range vector queries (while recording
    rules were the only way to do this in the past, the new subquery syntax enabled
    exploratory use cases for these).
  prefs: []
  type: TYPE_NORMAL
- en: Alerting rules trigger when an evaluated PromQL expression in a rule produces
    a non-empty result. They are the mechanism by which alerting over time series
    is done in Prometheus. Alerting rules also produce new time series when they trigger,
    but don't use the evaluation result as a sample; instead, they create an `ALERTS`
    metric with the alert name and state as labels, as well as any additional labels
    defined in the configuration. This will be further analyzed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using recording rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rules are defined separately from the main Prometheus configuration file, and
    are included by the latter through the `rule_files` top-level configuration key.
    They are evaluated periodically, and that interval can be defined globally with
    `evaluation_interval` inside `global` (defaults to one minute).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this by looking at the configuration provided with the test environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`rule_files` takes a list of paths, which can be relative to the main Prometheus
    configuration or absolute paths. Additionally, globs can be used to match filenames
    (not directories); for example, `/etc/prometheus/rules/*.yml`. Changes in rule
    files are not automatically picked up by Prometheus, so a reload is needed (as
    described in [Chapter 5](12e775c2-bee9-4ebe-ad73-2f9313eeeeee.xhtml), *Running
    a Prometheus Server*). Prometheus will fail to reload if any error are found in
    rule files, and will keep running using the previous configuration. However, if
    the server is restarted, it will fail to start. To make sure that this does not
    happen, `promtool` can be used to test for errors in advance (as explained in
    [Chapter 8](19357d8c-dfcf-4497-ae80-4761f6633d14.xhtml), *Troubleshooting and
    Validation*) – this is strongly recommended when using automation to deploy rules.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the `prometheus.yml` configuration file, the `rules` files are also
    defined in are YAML format. The actual format is very easy to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Each file defines one or more rule groups under the `groups` key. Each group
    has a `name`, an optional evaluation `interval` (which defaults to the global
    evaluation interval defined in the main Prometheus configuration file), and a
    list of `rules`. Each rule instructs Prometheus to record the result of evaluating
    the PromQL expression defined in `expr` into the specified metric name, optionally
    adding or overriding the series label set before storing the result by setting
    them in `labels`. The rules in each group are evaluated sequentially in the order
    they are declared, which means that a time series generated by a rule can safely
    be used in subsequent rules within the same group. Samples generated by rules
    will have the timestamp corresponding to the rule group evaluation time. The next
    figure illustrates the process previously mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74b724c0-a869-455c-8a0d-1382e5fab039.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: The Rule Manager is the Prometheus internal subsystem responsible
    for the periodic evaluation of rules according to their group''s evaluation interval,
    as well as managing the alerting life cycle'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the recording rules available in the test environment
    for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This file has two rule groups, named `recording_rules` and `different_eval_interval`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first rule group is composed of a single recording rule, which is using
    the global evaluation interval, taking the `node_cpu_seconds_total` metric from
    the Node Exporter to count the number of CPU cores available in the **virtual
    machine** (**VM**), and recording that result into a new time series named `instance:node_cpu:count`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second rule group is busier; it shows a custom evaluation interval for
    the group and a recording rule using the time series generated by previous rules
    in the group. We won''t go into exactly what these rules are doing, as they will
    serve as examples for the following rule naming conventions section, but the evaluation
    interval can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'By declaring an evaluation interval in this second rule group, we are overriding
    the configuration set in the `global` section of `prometheus.yml`—the rules in
    this group will produce samples at the specified frequency. This was done for
    demonstration purposes only; setting different intervals is usually discouraged,
    for the same reasons as in scrape jobs: queries might produce erroneous results
    when using a series with different sampling rates, and having to periodically keep
    track of what series have what becomes unmanageable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prometheus provides a status page in the web **user interface** (**UI**) where
    a user can check the loaded rule groups along with their enclosed recording rules,
    their recording state, how long the last evaluation took for each, and how long
    ago they were run. You can find this page by going into Status | Rules on the
    top bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d4c3893-2aff-4b18-9bb2-5656f04eed6d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Prometheus web interface showing the /rules endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: With this information, we have now the fundamentals on how to create recording
    rules. Next, we'll explore the naming convention that the Prometheus community
    has agreed upon for recording rules.
  prefs: []
  type: TYPE_NORMAL
- en: Naming convention for recording rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recording rule name validation abides by the same regular expression as metric
    names, and so rules can technically be named the same as any other metric. However,
    having clear standards when naming recording rules can make it easier to identify
    them among scraped metrics, know from which metrics they were derived, and understand
    what aggregations were applied to them.
  prefs: []
  type: TYPE_NORMAL
- en: The Prometheus community has gravitated toward a well-defined naming convention
    for recording rules. This is based on years of experience running Prometheus at
    scale. This enables all of the aforementioned advantages when used correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recommended convention for recording rule naming is composed of three sections,
    separated by colons, and takes the following form: `level:metric:operations`.
    The first section represents the aggregation level of the rule, which means that
    it will list the labels/dimensions that are present and relevant (usually separated
    by underscores); the second section is the metric name that was the basis for
    the rule; and the third section lists the aggregation operations that were applied
    to the metric.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The recording rules presented in this chapter all follow this convention, so
    let''s have a look at the second rule group available in the test environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the naming of the first rule, we can easily understand that the rule
    is based on the `prometheus_http_request_duration_seconds_sum` metric; `rate5m`
    indicates that `rate()` is being applied to a range vector of five minutes, and
    the interesting labels present are `handler` and `instance`.
  prefs: []
  type: TYPE_NORMAL
- en: The same logic is applied to the second rule, but this time using the `prometheus_http_request_duration_seconds_count`
    metric. The third rule, however, is a bit more nuanced; as it is dividing `_sum`
    by the `_count` of latency events, it effectively represents the five-minute latency
    average of, in this case, HTTP requests served by Prometheus. As we aggregated
    the `instance` label away, the `level` section reflects this by only having `handler`
    as the relevant dimension. The last thing to note is that the metric name for
    this rule is now `prometheus_http_request_duration_seconds`, as it neither represents
    the sum nor the count, but it still makes it possible to clearly understand which
    metrics this rule is based on.
  prefs: []
  type: TYPE_NORMAL
- en: Naming recording rules can be a hard task, a balancing act between precisely
    representing all the factors at play and being concise enough for metric names
    to be manageable. When you find yourself in a situation where it isn't immediately
    clear how to name a recording rule given its expression, a good rule of thumb
    to follow is to make sure another person that is aware of this naming convention
    can tie the rule back to the metric used, what labels/dimensions should be present,
    and what transformations were applied.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up alerting in Prometheus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have covered how PromQL can be invaluable in querying the collected
    data, but when we require an expression to be continuously evaluated so that an
    event is triggered when a defined condition is met, we're promptly stepping into
    alerting. We explained how alerting is one of the components of monitoring in
    [Chapter 1](4214ddff-8289-4dc6-b0ef-240510a22192.xhtml), *Monitoring Fundamentals*.
    To be clear, Prometheus is not responsible for issuing email, Slack, or any other
    forms of notification; that is the responsibility of another service. This service
    is typically Alertmanager, which we'll go over in [Chapter 11](db658650-14d2-4a7e-9ae0-1c003e63109c.xhtml),
    *Understanding and Extending Alertmanager*. Prometheus leverages the power of
    alerting rules to push alerts, which we'll be covering next.
  prefs: []
  type: TYPE_NORMAL
- en: What is an alerting rule?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An alerting rule is much like a recording rule with some additional definitions;
    they can even share the same rule group without any issues. The biggest difference
    is that, when firing, they are sent to an external endpoint via an HTTP POST with
    a JSON payload for further processing. Expanding on the term active, in this context,
    we are talking about when the current state differs from the desired state, which
    boils down to when an expression returns one or more samples.
  prefs: []
  type: TYPE_NORMAL
- en: Alerting rules, such as recording rules, rely on PromQL expressions that are
    evaluated on a defined interval. This interval can be a globally configured one
    or can be local to the specific rule group. In each of the interval iterations,
    triggered alerts are validated to ensure that they're still active; if not, they're
    considered to be resolved.
  prefs: []
  type: TYPE_NORMAL
- en: For every sample returned by our expression, it will trigger an alert. This
    is important to keep in mind, because a relaxed PromQL expression can generate
    a deluge of alerts, so keep them as aggregated as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring alerting rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate how to create and understand alerting rules, we'll guide you
    through the entire process. This will touch not only on the main Prometheus configuration
    file, but also on rule files and how the web interface of the server behaves with
    regard to alerts.
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus server configuration file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside this chapter''s test environment, we can find the following Prometheus
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this configuration, there are three components to be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: '`evaluation_interval`: This is responsible for defining the global evaluation
    interval for recording and alerting rules, which can be overridden at the rule
    group level using the `interval` keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rule_files`: This is the file location where Prometheus can read the configured
    recording and/or alerting rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alerting`: This is the endpoint(s) where Prometheus sends alerts for further
    processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the alerting section, we've configured `“prometheus:5001”`. Behind this endpoint,
    there is nothing more than a small service, called **alertdump**, that is listening
    on port `5001` for the HTTP POST requests and is simply dumping their payload
    onto a log file. This will help dissect what Prometheus sends when an alert is
    firing.
  prefs: []
  type: TYPE_NORMAL
- en: Rule file configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previously, we took a look at the Prometheus configuration file; we''ll now
    move onto the provided alerting rules example, which we can see in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the `NodeExporterDown` alert definition more closely. We can
    split the configuration into five distinct sections: `alert`, `expr`, `for`, `labels`,
    and `annotations`. We''ll now go over each one of these in the next table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Section** | **Description** | **Mandatory** |'
  prefs: []
  type: TYPE_TB
- en: '| `alert` | The alert name to use | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `expr` | The PromQL expression to evaluate | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `for` | The time to ensure that the alert is being triggered before sending
    the alert, defaults to 0 | No |'
  prefs: []
  type: TYPE_TB
- en: '| `labels` | User-defined key-value pairs | No |'
  prefs: []
  type: TYPE_TB
- en: '| `annotations` | User-defined key-value pairs | No |'
  prefs: []
  type: TYPE_TB
- en: The Prometheus community typically uses CamelCase for alert naming.
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus does not carry out validation to check whether an alert name is already
    in use, so it is possible for two or more alerts to share the same name but evaluate
    different expressions. This might cause issues, such as tracking which specific
    alert is triggering, or writing tests for alerts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NodeExporterDown` rule will only trigger when the `up` metric with the
    `job=”node”` selector is not `1` for more than one minute, which we''ll now test
    by stopping the Node Exporter service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re now forcing an alert to become active. This will force the alert to
    go through three different states:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Order** | **State** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Inactive | Not yet pending or firing |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Pending | Not yet active long enough to become firing |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Firing | Active `for` more than the defined `for` clause threshold |'
  prefs: []
  type: TYPE_TB
- en: 'Going to the `/alerts` endpoint on the Prometheus server web interface, we
    can visualize the three different states for the `NodeExporterDown` alert. First,
    the alert is inactive, as we can see in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1780ac8-5699-40ba-ac51-fe19d917fb04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: The NodeExporterDown alert is inactive'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can see the alert in a pending state. This means that, while the alert
    condition has been triggered, Prometheus will continue to check whether that condition
    keeps being triggered for each evaluation cycle until the `for` duration has passed.
    The next figure illustrates the pending state; notice that the **Show annotations**
    tick box is selected, which expands the alert annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b30ea059-23e0-4025-95e2-19505112ae71.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: The NodeExporterDown alert is pending'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can see the alert turn to firing. This means that the alert is
    active for more than the duration defined by the `for` clause – in this case,
    1 minute:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e0284b0-8f88-4c81-a54b-f19bb7618cb7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: The NodeExporterDown alert is firing'
  prefs: []
  type: TYPE_NORMAL
- en: 'When an alert becomes firing, Prometheus sends a JSON payload to the configured
    alerting service endpoint, which, in our case, is the alertdump service, which
    is configured to log to the `/vagrant/cache/alerting.log` file. This makes it
    very easy to understand what kind of information is being sent and can be validated
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've seen how to configure some alerting rules and validated what
    Prometheus is sending to the configured alerting system, let's explore how to
    enrich those alerts with contextual information by using labels and annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Labels and annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the alert rule definition, there were two optional sections: labels and
    annotations. Labels define the identity of an alert and they can change according
    to the evaluation cycle they''re in; if they do this, it will alter the alert
    identity. To demonstrate this point, we''ll introduce the `ALERTS` metric, which
    tracks all active alerts and their labels. As we can see in the following figure,
    we have a label called `alertstate`, which tracks the alert state and transitions
    from `pending` to `firing`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb8a64c2-1844-4c5d-8e47-a29cba583986.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: The ALERTS metric'
  prefs: []
  type: TYPE_NORMAL
- en: Something to keep in mind is the issue of using a sample value in a label. Although
    it is technically possible, it's also a very bad idea. Doing so will change the
    alert identity every time the value changes, and, as such, will always be restarting
    the defined `for` countdown, resulting in an alert that will never enter the `firing`
    state.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, annotations do not belong to the identity of an alert, and,
    as such, are not stored in the `ALERTS` metric. These are useful to enrich the
    alert with more context and information. Annotations are also templated using
    the Go templating language, as we saw in our example. By using the `{{ .Labels.instance
    }}` template syntax, we are accessing the available alert labels, selecting the
    `instance` label, and using its value in the annotation `description` field. The
    value of the firing sample is available by using `{{ .Value }}`, if required.
  prefs: []
  type: TYPE_NORMAL
- en: The Golang template `.Labels` and `.Value` variables are also available as `$labels`
    and `$value` for convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows the alert rule in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following rendered result when `firing`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can find more information regarding Golang templating at [https://golang.org/pkg/text/template/](https://golang.org/pkg/text/template/).
  prefs: []
  type: TYPE_NORMAL
- en: Delays on alerting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous topics, we talked about the three states that an alert goes
    through; but there''s more to it when calculating the total time required for
    an alert to become firing. First, there''s the scrape interval (which, in our
    example, is 30 seconds, although generally the scrape and evaluation intervals
    should be the same for clarity), we then have the rule evaluation interval (in
    our case, it was globally defined as 1 minute), and, finally, there''s the 1 minute
    defined in the alert rule''s `for` clause. If we put all of these variables together,
    the time for this alert to be considered as `firing` can take up to 2 minutes
    and 30 seconds in the worst-case scenario. The next figure illustrates this example
    situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8973ea05-760e-4131-8a83-38b670f8c308.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: Alert delay visualized'
  prefs: []
  type: TYPE_NORMAL
- en: All these delays are just on the Prometheus side. The external service processing
    the alert sent may have other constraints, which can make the global delay until
    a notification is sent even longer.
  prefs: []
  type: TYPE_NORMAL
- en: Before Prometheus 2.4.0, the `pending` and `firing` states were not persistent
    across restarts, which could extend the delay for alerting even further. This
    was solved by implementing a new metric, called `ALERTS_FOR_STATE`, which stores
    the alert states. You can find the release notes for Prometheus 2.4.0 at [https://github.com/prometheus/prometheus/releases/tag/v2.4.0](https://github.com/prometheus/prometheus/releases/tag/v2.4.0).
  prefs: []
  type: TYPE_NORMAL
- en: Testing your rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 8](19357d8c-dfcf-4497-ae80-4761f6633d14.xhtml), *Troubleshooting
    and Validation*, we went through the features that `promtool` has to offer, with
    the exception of testing. The `test rules` subcommand can simulate the periodic
    ingestion of samples for several time series, use those series to evaluate recording
    and alerting rules, and then test whether the recorded series match what was configured
    as the expected results. Now that we understand recording and alerting rules,
    we'll look at how to ensure that they behave as expected, by creating unit tests
    and using `promtool` to validate our rules.
  prefs: []
  type: TYPE_NORMAL
- en: Recording rules tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `promtool` tool included in the Prometheus binary distribution allows us
    to define test cases to validate that the rules we write behave as expected. The
    test environment for this chapter also comes with a suite of pre-built tests for
    the rules we''ve explored so far. You can have a look at the configuration here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This file has tests for all recording and alerting rules presented in this
    chapter. Although you don''t need to define every test in a single file (it is,
    in fact, tidier to do a test file per rule group to keep things organized), this
    was done in this case for simplicity. For now, let''s analyze only the recording
    rules, as they are simpler to grasp. The top-level configuration keys for the
    test file defines which rule files to load and the default evaluation interval
    for the tests, which governs the periodicity of recording and alerting rule evaluation
    when they don''t explicitly state their own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: While the `rule_files` configuration key in the test files might look the same
    as in the main Prometheus configuration file, it does not support globing (using
    filename wildcards).
  prefs: []
  type: TYPE_NORMAL
- en: 'Following these global configurations comes the definition of the test cases,
    under the `tests` key. You can define multiple test packs, each with their own
    simulated scrape intervals, collected series, and rules under test. Let''s have
    a look at the first test defined in the file, to which we added some comment to
    make it easier to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`interval` sets the time that interval samples are generated in our simulated
    time series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The list of `input_series` define what time series to generate and what values
    to produce in each iteration of the simulated collection interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The list of PromQL expressions to test is defined as `promql_expr_test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Each `expr` defines a particular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The point in time at which this expression will be run is set by setting `eval_time`,
    and the expected samples should be returned by running that expression as `exp_samples`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this test pack, we can see four time series being generated every 15 seconds
    for the same metric, `node_cpu_seconds_total`. As the actual value of these series
    isn't relevant for this recording rule (it only counts the number of CPUs per
    instance), a value of `1` was set for every sample. Do note the variation of labels
    present, namely that the `prometheus:9100` instance is reporting metrics for two
    CPUs and `example:9100` for one. The actual test is just validating that, when
    the `instance:node_cpu:count` expression is evaluated at `t=1m` (as if 1 minute
    had passed after the generated collection started), the returned samples should
    show the correct count of CPUs for each instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to execute the tests using the following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This ensures that the recording rule configured behaves the way we were expecting.
    You can try breaking the test by removing one of the input series from the `prometheus:9100`
    instance in the `instance:node_cpu:count` test pack. When you run the tests again,
    the following will be displayed, as one of the tests is now failing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: What this output tells us is that `promtool` was expecting the defined set of
    samples, but a different set of samples was returned. You can see that, just as
    we configured, the recording rule now only reports one CPU for the `prometheus:9100`
    instance. This gives us confidence that the rule is behaving exactly as we wanted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tests for the second recording rule group are mostly the same, but they
    showcase a powerful notation for generating a richer input series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is called an **expanding notation**. This is a compact way of declaring
    a formula for the generation of time series values over time. It takes the form
    of either `A+BxC` or `A-BxC`, where `A` is the starting value, `B` is the amount
    of increase (when preceded by `+`) or decrease (when preceded by `-`) the series
    value should have in each iteration, and `C` is how many iterations this increase
    or decrease should be applied for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming back to our example, `0+5x60` will expand to the following series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can mix and match literal values with expanding notation when declaring
    the values for an input time series. This allows you to create complex behavior
    with ease. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be expanded into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Testing is fundamental to avoid unforeseen problems and, with the information
    covered so far, you're now able to generate your own unit tests for recording
    rules. Next, we'll continue tackling unit tests, but this time specifically related
    to alerting rules.
  prefs: []
  type: TYPE_NORMAL
- en: Alerting rules tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unit tests for alerting rules are quite similar to the ones used for recording
    rules. We''ll be using the example alert provided earlier in this chapter to perform
    a walkthrough on how to configure alerting tests and how to validate them. As
    mentioned before, the test environment for this chapter comes with a suite of
    tests for the rules presented here, including the alert rule we''re interested
    in. Once again, you can have a look at the test file using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Focusing solely on the alerting component, we can see that we first define
    where the alerting rules are located:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The default rule evaluation interval is shared between recording and alerting
    rules in the same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The alerting test is conveniently in its own test group, so let''s have a look
    at its full definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The test group definition is the same as explained previously, with the exception
    of the `alert_rule_test` section, which is where we define alerting tests. A thing
    to note in this example is that the second input series should never be picked
    up by our testing rule, as the defined alert is specifically matching `job="node"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: It's not mandatory to have `alert_rule_test` and `promql_expr_test` in separate
    test blocks; you may have both in the same test group when you have recording
    and alerting rules using the same input time series and with the same evaluation
    interval.
  prefs: []
  type: TYPE_NORMAL
- en: The `alert_rule_test` section lists what alerts should be evaluated (`alertname`)
    at what time relative to the simulated start of the test run (`eval_time`). If
    the alert is expected to be firing at that time, an additional `exp_alerts` section
    should be defined listing what set of expected labels (`exp_labels`) and annotations
    (`exp_annotations`) should be present for each instance of the alert. Leaving
    the `exp_alerts` section empty means that the alert is not expected to be firing
    at the given time.
  prefs: []
  type: TYPE_NORMAL
- en: The first alerting test will be executed at the third minute, and, as the matching
    series we provided previously returns the value `1` at that moment, the alert
    expression defined at `alerting_rules.yml` will not trigger – this means that
    no data is returned by the expression defined in the alert.
  prefs: []
  type: TYPE_NORMAL
- en: The second alerting rule will be executed at the fourth minute and will return
    data, as the matching series we provided has the sample value `0` at that specific
    moment. All the labels returned by the alerting rule needs to be explicitly checked.
    The test must also check all the descriptions returned by the alert, with any
    templated variable fully expanded.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run the test using the following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As an extra step, try changing the description of the second alert from `prometheus:9100`
    to something like `prometheus:9999` and run the test again. You should get the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: While this alert is very simple and easy for determining in which conditions
    it will fire, tests for alerting rules provide you with the assurance that alerts
    will trigger when conditions that you can't reasonably reproduce in your environment
    happen.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had the opportunity to observe a different way to produce
    a derivative time series. Recording rules help improve monitoring system stability
    and performance when recurrent heavy queries are required by pre-computing them
    into new time series that are comparatively cheap to consult. Alerting rules bring
    the power and flexibility of PromQL to alerts; they enable triggering alerts for
    complex and dynamic thresholds as well as targeting multiple instances or even
    different applications using a single alert rule. Having a good grasp on how delays
    are introduced in alerts will now help you tailor them to your needs, but remember,
    a little delay is better than noisy alerts. Finally, we explored how to create
    unit tests for our rules and validate them even before a Prometheus server is
    running.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chapter will step into another component of monitoring: visualization.
    We''ll be diving into Grafana, the community-preferred choice for Prometheus-powered
    dashboards.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the primary uses for recording rules?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you avoid setting different evaluation intervals in rule groups?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you were presented with the `instance_job:latency_seconds_bucket:rate30s`
    metric, what labels would you expect to find and what would be the expression
    used to record it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is using the sample value of an alert in the alert labels a bad idea?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the pending state of an alert?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How long would an alert wait between being triggered and transitioning to the
    `firing` state when the `for` clause is not specified?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you test your rules without using Prometheus?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Prometheus recording rules**: [https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/](https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule naming best practices**: [https://prometheus.io/docs/practices/rules/](https://prometheus.io/docs/practices/rules/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prometheus alerting rules**: [https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/](https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prometheus unit testing**: [https://prometheus.io/docs/prometheus/latest/configuration/unit_testing_rules/](https://prometheus.io/docs/prometheus/latest/configuration/unit_testing_rules/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
