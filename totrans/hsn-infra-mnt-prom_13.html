<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Discovering and Creating Grafana Dashboards</h1>
                </header>
            
            <article>
                
<p class="mce-root">The Prometheus expression browser is great for performing exploratory queries, but sometimes we require prebuilt visualizations to assist us when we want to quickly debug issues. In this chapter, we'll dive into Grafana, the tool recommended by the Prometheus project for building dashboards. The Grafana community keeps growing and thriving, in part by hosting a multitude of ready-to-use dashboards, making it easy to reuse them and contribute to the community and thus improve the ecosystem. In this chapter, we will learn how to find and use dashboards from the community, as well as how to write our own and give something back to the community. Finally, we'll also provide a cursory look at consoles, the dashboarding solution built into Prometheus for advanced use cases.</p>
<p>In brief, the following topics will be covered in this chapter:</p>
<ul>
<li>Test environment for this chapter</li>
<li>How to use Grafana with Prometheus</li>
<li>Building your own dashboards</li>
<li>Discovering ready-made dashboards</li>
<li>Default Prometheus visualizations</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test environment for this chapter</h1>
                </header>
            
            <article>
                
<p>To provide a hands-on approach, we'll be creating a new test environment for this chapter. The setup we'll be using resembles the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/867a4731-0373-4838-8e98-26aa280b6609.png" style="width:40.17em;height:19.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 10.1: Test environment network</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deployment</h1>
                </header>
            
            <article>
                
<p>To generate this chapter's <strong>virtual machine</strong> (<strong>VM</strong>) based test environment, go to the correct repository path, relative to the code repository root:</p>
<pre><strong>cd ./chapter10/</strong></pre>
<p>Ensure that no other test environments are running and spin up this chapter's environment, as follows:</p>
<pre><strong>vagrant global-status</strong><br/><strong>vagrant up</strong></pre>
<p>You can validate the successful deployment of the test environment using the following code:</p>
<pre><strong>vagrant status</strong></pre>
<p>This will give the following output:</p>
<pre>Current machine states:<br/><br/>prometheus                 running (virtualbox)<br/>grafana                    running (virtualbox)<br/><br/>This environment represents multiple VMs. The VMs are all listed above with their current state. For more information about a specific VM, run `vagrant status NAME`.</pre>
<p>When the deployment tasks end, you'll be able to validate the following endpoints on your host machine using your favorite JavaScript-enabled web browser:</p>
<table border="1" style="border-collapse: collapse;width: 59.7403%">
<tbody>
<tr>
<td>
<p><strong>Service</strong></p>
</td>
<td>
<p><strong>Endpoint</strong></p>
</td>
</tr>
<tr>
<td>
<p>Prometheus</p>
</td>
<td>
<p><kbd>http://192.168.42.10:9090</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Grafana</p>
</td>
<td>
<p><kbd>http://192.168.42.11:3000</kbd></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>You should be able to access the desired instance by using one of the following commands:</p>
<table border="1" style="border-collapse: collapse;width: 64.6104%">
<tbody>
<tr>
<td>
<p><strong>Instance</strong></p>
</td>
<td>
<p><strong>Command</strong></p>
</td>
</tr>
<tr>
<td>
<p>Prometheus</p>
</td>
<td>
<p><kbd>vagrant ssh prometheus</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Grafana</p>
</td>
<td>
<p><kbd>vagrant ssh grafana</kbd></p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cleanup</h1>
                </header>
            
            <article>
                
<p>When you've finished testing, just make sure you're inside <kbd>chapter10/</kbd> and execute the following command:</p>
<pre><strong>vagrant destroy -f</strong></pre>
<p>Don't worry too much—you can easily spin up the environment again if you need to.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to use Grafana with Prometheus</h1>
                </header>
            
            <article>
                
<p>Grafana is the most recognized open source project for dashboarding. It has the concept of data sources, which are nothing more than integrations with data backends. At the time of writing, the following are the available data sources:</p>
<ul>
<li>Prometheus</li>
<li>Graphite</li>
<li>InfluxDB</li>
<li>Elasticsearch</li>
<li>Google Stackdriver</li>
<li>AWS CloudWatch</li>
<li>Azure Monitor</li>
<li>Loki (logging visualization)</li>
<li>MySQL</li>
<li>PostgreSQL</li>
<li>Microsoft SQL Server</li>
<li>OpenTSDB</li>
<li>TestData (useful for generating fake data for testing)</li>
</ul>
<p>Several efforts have been made to improve the integration of Prometheus into Grafana—for example, PromQL autocompletion. Currently, Grafana is the go-to dashboarding solution for anyone interested in visualizing Prometheus data. The previous sentence isn't completely true, because we know that for exploratory queries, there's nothing like the Prometheus expression browser. Recently, though, after the release of version 6.0.0, a feature called Explore was introduced in Grafana as an alternative expression browser.</p>
<div class="packt_infobox">You can find the installation files for several operating systems and distributions at <a href="https://grafana.com/grafana/download">https://grafana.com/grafana/download</a>.</div>
<p>Grafana is built and preconfigured with automation in mind. In the following examples, we will demonstrate how you can pretty much set up an environment without touching the main configuration file. A noteworthy benefit is that Grafana comes natively instrumented with Prometheus metrics.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Login screen</h1>
                </header>
            
            <article>
                
<p>With the test environment running, you can access Grafana using the <kbd>http://192.168.42.11:3000</kbd> URL. The user is greeted with a simple login screen, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ac47013b-e9fb-45c2-aba3-f42bf359af55.png" style="width:39.00em;height:21.58em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 10.2: Grafana login screen</div>
<p>The default authentication credentials are as follows:</p>
<table border="1" style="border-collapse: collapse;width: 60.5519%">
<tbody>
<tr>
<td>
<p><strong>Username</strong></p>
</td>
<td>
<p><strong>Password</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>admin</kbd></p>
</td>
<td>
<p><kbd>admin</kbd></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root"/>
<p>After a successful login, we're welcomed to the Grafana homepage, which displays a setup wizard. Next, we're going to explain each one of the configuration steps that are presented. The following screenshot shows the wizard with some steps already configured:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1f250cb1-8e67-4e0e-9eb9-03edbb93f21a.png" style="width:39.33em;height:27.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 10.3: Grafana home screen</div>
<p>For the sake of readability, we've changed the default Grafana theme to <strong>Light</strong> instead of <strong>Dark</strong>. This is easily configured in the <strong>Preferences</strong><span> menu in the</span> <strong>Configuration</strong> tab (the small gear icon on the left).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data source</h1>
                </header>
            
            <article>
                
<p>To have data to query, we must configure a data source. In our case, we'll add our Prometheus instance as the default data source. To do this, we need to indicate where the data source is located, any authentication/authorization details that are needed, and any additional data source-specific configuration.</p>
<p>There are two ways to configure a data source. One way is by adding a YAML file with the required configuration in the Grafana provisioning path, which is picked up by the service when starting up and is configured automatically. This is what we are doing in the test environment for this chapter, as it is the better solution for automated deployments. When connecting to the <kbd>grafana</kbd> instance in the test environment, you can see the configuration we are using by looking at the default provisioning path, shown as follows:</p>
<pre><strong>vagrant@grafana:~$ cat /etc/grafana/provisioning/datasources/prometheus.yaml </strong><br/><strong>apiVersion: 1</strong><br/><br/><strong>datasources:</strong><br/><strong>- name: prometheus</strong><br/><strong>  type: prometheus</strong><br/><strong>  access: proxy</strong><br/><strong>  orgId: 1</strong><br/><strong>  url: http://prometheus:9090</strong><br/><strong>  isDefault: True</strong><br/><strong>  version: 1</strong><br/><strong>  editable: True</strong></pre>
<p>The other option is using the web interface by going into <strong>Configuration</strong> (the small gear icon on the left) | <strong>Data Sources</strong> and adding the options for the setup manually. When clicking on <strong>Save &amp; Test</strong>, Grafana will validate the settings and let you know if anything went wrong. Grafana provides two options for accessing data sources that provide HTTP-based APIs (such as Prometheus): with or without proxying requests. When proxying requests, every single query that's made from a dashboard panel or through the Explore expression browser will be proxied through the Grafana backend to the data source. Although this has the advantages of being able to manage data source credentials centrally and to close off direct network access to those data sources from everywhere except trusted clients, it creates additional load on the Grafana instances as a lot more traffic needs to pass through them. Not proxying requests means that the client browser will hit the data source directly for each request. This configuration expects that the user accessing Grafana also has direct access to the data source being used, and that security settings for that data source allow requests from different origins. In all of our examples, Grafana will be set to proxy queries.</p>
<p>The following screenshot shows the configuration that's being used in our test environment:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9fe103bc-7af6-41bb-9348-d8f80c95863b.png" style="width:21.17em;height:27.67em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 10.4: Data Sources configuration interface</div>
<p>Note that the <strong>Access</strong> option is set as <strong>Server (Default)</strong>. This means that all the requests for the data source will be proxied through the Grafana instance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Explore</h1>
                </header>
            
            <article>
                
<p>This feature was introduced in Grafana 6 and its developers continue to improve its tight integration with Prometheus. Before Explore, every single time you wanted to perform an exploratory query, you were required to jump to the Prometheus expression browser.</p>
<p>Besides this convenience, there are also some noteworthy features that make Explore unique, as shown in the following list:</p>
<ul>
<li><strong>Metrics list</strong>: In the top-left corner, we can find a combo box called <strong>Metrics</strong>. This lists metrics in a hierarchical form, grouped by their prefix, and even detects and groups recording rules when they follow the double-colon naming convention.</li>
<li><strong>Query field</strong>: Besides suggesting and autocompleting metrics, the query field also displays useful tooltips about PromQL functions and can even expand recording rules that are detected in their originating expression.</li>
<li><strong>Context menus</strong>: You can choose to open the query from any dashboard panel directly in the Explore page.</li>
</ul>
<p>The following screenshot illustrates the <strong>Explore</strong> interface while also displaying a tooltip for the PromQL function that is being used:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/65766f06-7707-4443-b677-3a5c4f130d0b.png" style="width:31.25em;height:31.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 10.5: Grafana Explore page depicting the tooltip for the label_replace function</div>
<p>Explore can normally be found by clicking the small compass icon on the left.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dashboards</h1>
                </header>
            
            <article>
                
<p>Similar to managing data sources, there are several ways that you can add dashboards, listed as follows:</p>
<ul>
<li>By manually building your own</li>
<li>By importing <a href="https://grafana.com/">grafana.com</a> community-driven dashboards</li>
<li>By automatically provisioning previously stored dashboards</li>
</ul>
<p>We'll be tackling the last way right now since the test environment is using this approach. We will focus on the other two methods in the following sections.</p>
<p>A dashboard file is a declarative representation of a dashboard, with all the required settings specified, and uses the JSON format. If you place it in the expected provisioning path, the Grafana service will pick it up at the start. In our example, we used the default path, as we can see in the following snippet:</p>
<pre><strong>vagrant@grafana:~$ ls /etc/grafana/dashboards/</strong><br/><strong>node_exporter_basics.json</strong></pre>
<p>You can find this dashboard by going into the <strong>Home</strong> menu on the top left of the page and then selecting <kbd>node_exporter_basics</kbd>. This translates visually into the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9298eb33-8b04-4ca3-b1a2-8f81dd501573.png" style="width:41.67em;height:21.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 10.6: Example dashboard that's been automatically provisioned</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Grafana running on Kubernetes</h1>
                </header>
            
            <article>
                
<p>Deploying Grafana on Kubernetes involves mostly the same method as deploying it in VMs, so we're just going to focus on some of the finer points that an operator should be aware of. The Kubernetes manifests for getting Grafana and Prometheus up and running in our Kubernetes test environment can be found, relative to the code repository root path, at the following path:</p>
<pre><strong>cd ./chapter10/provision/kubernetes/</strong></pre>
<p>Since the Kubernetes deployment procedure is the same as in previous chapters (bootstrapping the Prometheus Operator, deploying Prometheus using the Operator, and deploying exporters and their respective ServiceMonitors), this won't be covered in length again here. If you need additional context, feel free to have a look at the test environment walkthroughs in the previous chapters, such as <a href="205ddb34-6ee8-4e22-b80f-39d5b2198c29.xhtml">Chapter 7</a>, <em>Prometheus Query Language <span>–</span> PromQL</em>.</p>
<p>The following steps will ensure the creation of a new Kubernetes environment with all the required software provisioned so that we can focus on the Grafana component.</p>
<ol>
<li>Validate that no other environment is running:</li>
</ol>
<pre style="padding-left: 60px"><strong>minikube status</strong><br/><strong>minikube delete</strong></pre>
<ol start="2">
<li>Start an empty Kubernetes environment, <span>by using the following command</span>:</li>
</ol>
<pre style="padding-left: 60px">minikube start \<br/>  --cpus=2 \<br/>  --memory=3072 \<br/>  --kubernetes-version="v1.14.0" \<br/>  --vm-driver=virtualbox</pre>
<ol start="3">
<li>Add the Prometheus Operator components and follow its deployment, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>kubectl apply -f ./bootstrap/</strong><br/><strong>kubectl rollout status deployment/prometheus-operator -n monitoring</strong></pre>
<ol start="4">
<li>Add the new Prometheus cluster, ensuring that it's successful, by using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>kubectl apply -f ./prometheus/</strong><br/><strong>kubectl rollout status statefulset/prometheus-k8s -n monitoring</strong></pre>
<ol start="5">
<li>Add all the targets to Prometheus and list them using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>kubectl apply -f ./services/</strong><br/><strong>kubectl get servicemonitors --all-namespaces</strong></pre>
<p>Now that the Kubernetes environment is running, we can proceed with Grafana-specific configurations. Similar to the VM-focused test environment, we'll require the provisioning of not only Grafana itself, but also the data source and dashboards.</p>
<p>For the data source, since we might want to add sensitive information such as authentication in the future, we are going to use a Kubernetes secret. This also implies that there should be a ServiceAccount for accessing that secret.</p>
<p>We can create the ServiceAccount by applying the following manifest:</p>
<pre><strong>kubectl apply -f ./grafana/grafana-serviceaccount.yaml</strong></pre>
<p>Since we're using a secret, the data source configuration needs to be encoded into base64. As for the provisioning configuration itself, it is the same as in the VM deployment, but we will be substituting the Prometheus URL with the Kubernetes equivalent that is managed by the service. Here's a snippet before encoding:</p>
<pre>...<br/>datasources:<br/>- name: prometheus<br/>...<br/> url: http://prometheus-service.monitoring.svc:9090<br/>...</pre>
<p>After applying the following manifest, a new secret with the desired Grafana data source will be available:</p>
<pre><strong>kubectl apply -f ./grafana/grafana-datasources-provision.yaml</strong></pre>
<p>Now, it's time to add our example dashboard to Grafana. To achieve this, we need to provide Grafana with a provisioning configuration that tells it where to look for dashboard definitions and then put our example dashboard definition in that path. These are going to be available to the Grafana deployment as ConfigMaps. The relevant snippet that shows the dashboard location provisioning configuration is as follows:</p>
<pre>...<br/>data:<br/>  dashboards.yaml: |-<br/>    {<br/>        "apiVersion": 1,<br/>        "providers": [{<br/>           "folder": "",<br/>           "name": "default",<br/>           "options": {<br/>             "path": "/etc/grafana/dashboards" <br/>           },<br/>           "orgId": 1,<br/>           "type": "file"<br/>         }]<br/>    }<br/>kind: ConfigMap<br/>...</pre>
<p>The other <kbd>ConfigMap</kbd> contains our example dashboard, shown as follows:</p>
<pre>...<br/>data:<br/>  node_exporter_basics.json: |-<br/>    {<br/>...<br/>    }<br/>kind: ConfigMap<br/>...</pre>
<p>Both manifests can be deployed in the Kubernetes test environment using the following commands:</p>
<pre><strong>kubectl apply -f ./grafana/grafana-dashboards-provision.yaml</strong><br/><br/><strong>kubectl apply -f ./grafana/grafana-dashboards.yaml</strong></pre>
<p>It's now time to deploy Grafana and take advantage of all the preceding configurations, as follows:</p>
<pre><strong>kubectl apply -f ./grafana/grafana-deployment.yaml</strong></pre>
<p>This deployment brings everything together: it mounts the data source's secret, and the dashboard provision and dashboards ConfigMaps at the same locations as the VM test environment, as follows:</p>
<pre>... <br/>        volumeMounts:<br/>        - name: grafana-datasources-provision<br/>          mountPath: /etc/grafana/provisioning/datasources<br/>        - name: grafana-dashboards-provision<br/>          mountPath: /etc/grafana/provisioning/dashboards<br/>        - name: grafana-dashboards<br/>          mountPath: /etc/grafana/dashboards<br/>...</pre>
<p>You may follow the deployment status using the following instruction:</p>
<pre><strong>kubectl rollout status deployment/grafana -n monitoring</strong></pre>
<p>Finally, we can add a service so that we can access the newly launched Grafana instance, and a ServiceMonitor so that the Prometheus Operator configures Prometheus to collect metrics:</p>
<pre><strong>kubectl apply -f ./grafana/grafana-service.yaml</strong><br/><br/><strong>kubectl apply -f ./grafana/grafana-servicemonitor.yaml</strong></pre>
<p>You can now access the Grafana interface using the following command:</p>
<pre><strong>minikube service grafana -n monitoring</strong></pre>
<p>When you're finished testing, you can delete this Kubernetes-based test environment by issuing the following command:</p>
<pre><strong>minikube delete</strong></pre>
<p>This setup gives you a quick overview of how to integrate Grafana with Prometheus on Kubernetes. It's not awfully different from the VM test environment, but the details that were shown here will hopefully prevent you from having to search for information on how to accomplish it elsewhere.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building your own dashboards</h1>
                </header>
            
            <article>
                
<p>Inside the provided VM test environment, you had the opportunity to try out the bundled dashboard. Now, it is time that you learned how to build your own, but for that, you will need to grasp some concepts. In this section, we'll walk you through the process of creating a dashboard.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dashboard fundamentals</h1>
                </header>
            
            <article>
                
<p>A dashboard is composed of several components. We'll go over the most important concepts in the following sections, including panels, the visualizations they support, how to template variables, and changing the time range of the displayed data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Panels</h1>
                </header>
            
            <article>
                
<p>A panel is a rectangular-shaped slot in the visualization area of a dashboard. An example is shown in the following screenshot. It can be rearranged and resized as necessary by dragging and dropping its various dimensions. You can also put a set of panels inside a row, which is nothing more than a logical grouping of those panels. Rows can be expanded or collapsed to show or hide the panels within them:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/23f6ead4-8460-45e9-87e2-69a122551cbc.png" style="width:25.92em;height:13.67em;"/></p>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Figure 10.7: New panel</div>
<p>A panel, besides having the ability to query the chosen data source, also provides multiple visualization options to choose from. These visualization options allow you to present data in a variety of ways, such as simple single-value panels, bar graphs, line graphs, tables, all the way to heatmaps. The following screenshot illustrates the available built-in visualizations:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6f3d192a-23d5-4703-b697-111c60593a5c.png" style="width:28.00em;height:18.67em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 10.8: Built-in visualization options</div>
<p>In the preceding screenshot, we can see several panel types. Four of the most used ones are as follows:</p>
<ul>
<li><strong>Graph</strong>: This the main Grafana panel. It provides the tools to create rich two-dimensional graphs backed by one or more PromQL expressions.</li>
<li><strong>Singlestat</strong>: This is a multipurpose single-value display. As such, the PromQL query must return an instant vector with one sample only.</li>
<li><strong>Gauge</strong>: Using thresholds, this represents the position the current value is at in relation to the defined higher and lower bounds. Like the Singlestat visualization, this option requires a single instant vector with only one sample.</li>
<li><strong>Table</strong>: This displays the result of a PromQL expression in a table format, with each label in its own column, along with the value and the timestamp.</li>
</ul>
<p>For each one of the available visualizations, there are numerous options that allow for the extraordinary level of customization of each panel's appearance. The official Grafana documentation explains every option in detail, so we will focus on the most relevant ones here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Variables</h1>
                </header>
            
            <article>
                
<p>The variables feature is extremely powerful. It allows a dashboard to configure placeholders that can be used in expressions, and those placeholders can be filled with values from either a static or dynamic list, which are usually presented to the dashboard user in the form of a drop-down menu. Whenever the selected value changes, Grafana will automatically update the queries in panels that use that particular variable. In our example dashboard, we're using this feature to allow the user to choose which node instance to present. Besides being commonly used in queries, they're also available, for example, in panel titles.</p>
<p>This feature is available in the <strong>Dashboard settings</strong>, which can be found by clicking the top-right cog icon, which in turn is available inside any dashboard. The following screenshot depicts the <strong>Variables</strong> option from the <strong>node_exporter_basics</strong> dashboard in the <strong>Settings</strong> menu:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e221b523-da4c-4a4a-b509-d62a7e5ee47f.png" style="width:74.83em;height:33.58em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 10.9: Dashboard variables</div>
<p>As you can see, we're using a PromQL query to dynamically fetch the possible values for the <kbd>$instance</kbd> variable.</p>
<div class="packt_tip">When the viewport is not large enough, the responsive design of Grafana will hide some of the top-right icons.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Time picker</h1>
                </header>
            
            <article>
                
<p>The time picker feature is available in any dashboard in the top-right corner as a button containing the clock icon. The interface is split into two major blocks: <strong>Quick ranges</strong> of predefined time ranges (most of them relative to the current time) or a <strong>Custom range</strong>, which allows you to specify the exact time span to use in all the dashboard panels. As the name suggests, the <strong>Refreshing every:</strong> option will make the dashboard panels automatically reload at the interval specified. This is useful to see new data coming in when used in conjunction with a relative time range.</p>
<p>The following screenshot shows a series of quick ranges:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f60cdc9e-774a-4727-a1b8-1c51489f05c6.png" style="width:28.17em;height:27.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 10.10: Time picker</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a basic dashboard</h1>
                </header>
            
            <article>
                
<p>We are going to get hands-on with Grafana by guiding you through the creation process of a bare-bones dashboard. You can start by clicking the left plus sign logo | <strong>Dashboard</strong>. This will open a new empty dashboard with a new panel, ready to be edited. Since we want a dynamic dashboard, we're going to create a new variable, which will expand into a list of the available Node Exporter instances in our Prometheus server.</p>
<div class="packt_tip">Using the <em>Shift</em> + <em>?</em> key combination will display a helpful tooltip of all the available shortcuts.</div>
<p>To achieve our goal, we must click the top-right cog icon, open the <strong>Dashboard settings</strong>, then select <strong>Variables</strong>. The following screenshot illustrates the options that are available when creating such a variable:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/96af6a7f-afad-4096-bc80-aaeae5c57b66.png" style="width:21.58em;height:18.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 10.11: Variables interface</div>
<div class="packt_tip">The preview values depicted in the preceding screenshot show the Node Exporter targets from the VM-based test environment. You will get a different preview if you are following along using the Kubernetes test environment.</div>
<p>In this example, we're creating a variable named <kbd>instance</kbd> using the <strong>Query</strong> <span>type</span>, which means it will populate its values from the results of the query to the data source. We're specifying the data source as <kbd>prometheus</kbd>, the identifier we gave during provisioning, and that we want to refresh that variable only when the dashboards get loaded.</p>
<p>Now comes the interesting part: since we are interested in collecting Node Exporter instances, we use a metric in the <strong>Query</strong> field that is guaranteed to return the instances we require, <kbd>node_exporter_build_info</kbd>. The <kbd>label_values()</kbd> function isn't actually valid PromQL, but is provided by the Prometheus data source plugin in Grafana to use in this field to facilitate these kind of expressions.</p>
<p>The <strong>Regex</strong> field is used to match the parts of the query result we want to use to populate the variable. In our example, we want the full content of the instance label, so we match everything inside a regular expression capture group, <kbd>(.+)</kbd>. We can see that the matching is working in the <strong>Preview of values</strong> section at the bottom of the screen. After clicking <strong>Add</strong> and saving this dashboard using the name <kbd>example</kbd>, we can now see the following dropdown menu with the values of the <kbd>instance</kbd> variable:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/658cc9e1-5956-4698-ae88-29eec1a9a9c1.png" style="width:17.50em;height:17.42em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 10.11: Instance values</div>
<p class="mce-root">It's time to create our first panel. Click on the top-right graph logo, and in the new panel, click <strong>Add Query</strong>. The following screenshot illustrates the query interface:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d846f364-4fa0-41dd-a32b-63ffbb2e2518.png"/></p>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">Figure 10.12: Query interface</div>
<p>Here, we can specify the PromQL queries (one or more, depending on the visualization type) to perform on the desired data source. In our example, we'll be creating a graph of CPU usage per mode, and we want to template the query so that it uses the <kbd>instance</kbd> variable we created earlier. Note the <kbd>$instance</kbd>, which will be replaced at query time with the selected value in the <kbd>instance</kbd> combo box. The full expression is as follows:</p>
<pre>label_replace(avg by (mode, instance) (irate(node_cpu_seconds_total{instance="$instance", mode!="idle"}[5m])), "instance", "$1", "instance", "([^:]+):.+")</pre>
<p>The <kbd>label_replace()</kbd> function allows us to remove the port from the instance value, which we'll use in the <strong>Legend</strong> field. This field allows the substitution of <kbd>{{ }}</kbd> template markers with the values of the metric labels set within it. This will, in turn, reflect on the graph legend preceding the <strong>Query</strong> menu. In the following screenshot, we can see several visual options that have been applied to our dashboard, and we'll go over each one:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6f5e33df-ee34-442e-bedb-cd1f0689f455.png"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 10.13: Visualization interface</div>
<p>In the <strong>Axes</strong> section, we select which of the graph axes to enable; the <strong>Right Y</strong> configuration options do not produce any change, as that axis is not used. In the <strong>Left Y</strong> configuration, we can specify the <strong>Unit</strong>. In our case, we want a percentage; we could simply multiply our expression by 100, but not doing so exposes one of the handy features Grafana has to offer. As we already know, our value range is from 0 to 1; this <strong>Unit</strong> type will take the values in the 0-1 range and automatically transform them into percentages (from 0 to 100). We're also ensuring that <strong>Y-min</strong> is set to , so that the graph becomes easier to understand visually, as without it the graph would have the <em>y</em> axis scale adapted to start near the lowest <em>Y</em> value in the query result. Additionally, for the sake of this example, we want three decimal places in the values of the <em>y</em> scale, and so we set that using the <strong>Decimals</strong> field. On the <strong>X-Axis</strong>, we didn't change anything, as we want the time.</p>
<p>In the <strong>Legend</strong> section, we control how we want the graph legend to look and where it's placed inside the panel. In our case, we want it as a table, placed on the right-hand side of the graph, and we want it to present the average and current value of <em>Y</em>.</p>
<p>To finish our panel, we need to step into the <strong>General</strong> menu, as shown in the following screenshot, where we can name our panel and add a description. The description will be available as a small <strong>i</strong> icon in the top-left corner of the panel:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3cad9e01-6146-46f0-845a-4570d0e31f8a.png"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 10.14: The general menu of the panel</div>
<p>To save your new dashboard, just click the small floppy disk icon in the top-right corner. You have now created a simple dashboard from scratch! You can continue adding panels and visualizations, but the main concepts are pretty much the same. You can explore the provided dashboard in the test environment for more examples on how to use different visualizations options.</p>
<p>Something to keep in mind when creating a dashboard is to avoid unnecessary clutter. It is usual to see dashboards with dozens of panels, with a multitude of data on display. Try to have the right amount of information so that, for example, troubleshooting issues is quick and painless. Focus is the key word here: if there are panels that are not related to each other inside a dashboard, perhaps it would be a good idea to split them into their own dashboard.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exporting dashboards</h1>
                </header>
            
            <article>
                
<p>Grafana makes it easy to export dashboards. To proceed, just open the dashboard you intend to export and press the small <strong>square with arrow</strong> icon in the top-right panel, near the floppy disk icon.</p>
<p>The following form will open:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2b8e6f0d-846b-4dc5-8b5a-865903bf2d97.png" style="width:28.25em;height:9.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 10.15: Grafana dashboard export</div>
<p>Here, you're presented with several options:</p>
<ul>
<li><strong>Export for sharing externally</strong>: Enables the templating of the data source names, which is helpful for sharing the dashboard publicly. This is mandatory in order to publish the dashboard on the <a href="https://grafana.com/">grafana.com</a> website.</li>
<li><strong>View JSON</strong>: Allows you to visualize the code of the dashboard.</li>
<li><strong>Save to file</strong>: Downloads the dashboard as a JSON file.</li>
</ul>
<p>Next, we're going to see how we can download dashboards from the Grafana dashboard gallery, and how to contribute our own to it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Discovering ready-made dashboards</h1>
                </header>
            
            <article>
                
<p>Since Grafana is widely used and has a huge community behind it, it's logical that a huge number of dashboards are being created by that community. The folks at Grafana provide a service where registered users are able to publish their dashboards onto a gallery, and anyone can download and install them on their own Grafana instances. In the following sections, we'll be providing an overview of both actions, not only using community-made dashboards, but also how to publish your own.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Grafana dashboards gallery</h1>
                </header>
            
            <article>
                
<p>Both community-driven and official dashboards are available at <a href="https://grafana.com/dashboards">https://grafana.com/dashboards</a> and, as expected, there are a lot to choose from. Since we're interested in Prometheus-specific dashboards when searching the site, we should restrict the search results to that data source. By applying additional filters, we keep restricting results to exactly what we're after, as you can see in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8813a1bf-1e75-45bc-a419-c33c7ab23bf7.png" style="width:33.00em;height:29.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">10.16: Grafana.com filtered dashboards result</div>
<p>We can then select the dashboard we're interested in, which will in turn open a screen, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/45d1f4b5-42ff-4330-b110-7f9125e9a2a6.png" style="width:30.17em;height:24.58em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 10.17: Grafana.com selected dashboard information</div>
<p>Here, we can see some information regarding the dashboard and a screenshot of it. Notice the ID <strong>9916</strong> on the right; it's a unique identifier in the Grafana gallery for this particular dashboard. We can use it by going into a Grafana instance, such as the one in our test environment, clicking on the plus sign in the main menu on the left-hand side, selecting <strong>Import</strong> from the submenu, and pasting it in the appropriate text field, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2b84e849-cf97-4e71-a120-a79f7ea7300d.png" style="width:21.50em;height:12.67em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 10.18: Import dashboard interface</div>
<p>After pasting in the ID, a new menu will pop up, asking for the name we want to give to this dashboard, in which folder it should be placed, and what data source it should use. If there are any conflicts with pre-existing dashboards (such as dashboards with the same name), you will be asked to resolve them before you will be able to finish the import process.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Publishing your dashboards</h1>
                </header>
            
            <article>
                
<p>Publishing a newly created dashboard is quite easy. First, ensure that you have an account for the Grafana website by using the registration form located at <a href="https://grafana.com/signup">https://grafana.com/signup</a>. After a successful registration, go into your profile via <strong>Personal</strong> <em>|</em> <strong>My Dashboards</strong> or use the <kbd>https://grafana.com/orgs/&lt;user&gt;/dashboards</kbd> link, replacing <kbd>&lt;user&gt;</kbd> with your Grafana username.</p>
<p>Inside <strong>My Dashboards</strong>, you can now click the <strong>Upload Dashboard</strong> button. This action will open an upload form, requesting the dashboard to be uploaded. Remember, this will only accept dashboards that are exported with the <strong>Export for sharing externally</strong> option toggled on:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bc4c7fb5-c9ce-43b5-b2a9-73f8ff9a1a99.png" style="width:34.75em;height:16.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 10.19: Dashboard upload form</div>
<p>And you're done! You'll now obtain a numeric ID for your dashboard and you can start using it or sharing it across the globe. You can update the published dashboard if you want to, as this will not alter the generated ID. Instead, it will create another revision of the published dashboard, and users will always download the latest revision that's available.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Default Prometheus visualizations</h1>
                </header>
            
            <article>
                
<p>Historically, Prometheus maintained its own tool to create dashboards, called PromDash. Over time, since Grafana improved its native support for Prometheus as a data source, the community began gravitating toward using Grafana as its primary visualization solution—so much so that PromDash was deprecated by the people who maintained Prometheus in favor of Grafana.</p>
<div class="packt_tip">You can find the source code for PromDash at <a href="https://github.com/prometheus-junkyard/promdash">https://github.com/prometheus-junkyard/promdash</a>.</div>
<p>Even though Grafana is the recommended visualization solution for most people, Prometheus also ships with an internal dashboarding feature called <strong>console templates</strong>. These console templates are written in raw HTML/CSS/JavaScript and leverage the power of the Go templating language to generate dashboards (called consoles) that are served by the Prometheus server itself. This makes them blazingly fast and endlessly customizable. Console templates are as powerful as they are complex. We are going to introduce this feature by giving you a small overview of how to use and build console templates in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Out-of-the-box console templates</h1>
                </header>
            
            <article>
                
<p>When you unpack the Prometheus release archive, besides the binaries for the server and promtool, there are also a few console templates readily available. To make this clear, we can look inside our test environment where we unpacked these templates into system paths, shown as follows:</p>
<pre>vagrant@prometheus:/usr/share/prometheus$ systemctl cat prometheus<br/>...<br/>ExecStart=/usr/bin/prometheus \<br/>    --config.file=/etc/prometheus/prometheus.yml \<br/>    --storage.tsdb.path=/var/lib/prometheus/data \<br/><strong>    --web.console.templates=/usr/share/prometheus/consoles \</strong><br/><strong>    --web.console.libraries=/usr/share/prometheus/console_libraries</strong><br/>...</pre>
<p>Both directories need to be properly configured for consoles to work. Console libraries define helper functions that are then used in console templates so that repetition is kept to a minimum. We are going to have a closer look at these libraries in the next section when we build our own template.</p>
<p>For now, here are the console templates that ship with Prometheus:</p>
<pre><strong>vagrant@prometheus:~$ ls -lh /usr/share/prometheus/consoles </strong><br/><strong>total 36K</strong><br/><strong>-rw-r--r-- 1 root root 623 Mar 10 16:28 index.html.example</strong><br/><strong>-rw-r--r-- 1 root root 2.7K Mar 10 16:28 node-cpu.html</strong><br/><strong>-rw-r--r-- 1 root root 3.5K Mar 10 16:28 node-disk.html</strong><br/><strong>-rw-r--r-- 1 root root 1.5K Mar 10 16:28 node.html</strong><br/><strong>-rw-r--r-- 1 root root 5.7K Mar 10 16:28 node-overview.html</strong><br/><strong>-rw-r--r-- 1 root root 1.4K Mar 10 16:28 prometheus.html</strong><br/><strong>-rw-r--r-- 1 root root 4.1K Mar 10 16:28 prometheus-overview.html</strong></pre>
<p>As you can see in <kbd>index.html.example</kbd>, these templates expect the scrape jobs for Prometheus and Node Exporter to be named <kbd>prometheus</kbd> and <kbd>node</kbd> respectively, so they might not work for your Prometheus configuration out of the box.</p>
<p>We can access it by using the web interface URL at <kbd>http://192.168.42.10:9090/consoles/index.html.example</kbd> and exploring the available consoles. The following screenshot depicts the console for the node CPU of the Prometheus instance:<a href="http://192.168.42.10:9090/consoles/index.html.example"/></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ec4dbe95-b7b0-4822-8279-bae5419519d6.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 10.20: Node CPU for Prometheus</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Console template basics</h1>
                </header>
            
            <article>
                
<p>Creating console templates from scratch has a steep learning curve. Unlike in Grafana, console templates are crafted directly in HTML and JavaScript, with a fair dose of Go templating in the mix. This means that consoles can technically take any form, but for simplicity, we will stick to the structure provided by the built-in console libraries.</p>
<p>The libraries that power the example console templates define the scaffold for the consoles. They take care of things such as constructing the HTML structure, including the necessary CSS and JavaScript and modeling the four sections around the main console content: the navigation bar at the top, the menu on the left, the console time controls at the bottom, and a table to show summary statistics on the right. Let's see how we could use them to construct a simple console template by looking at the following code:</p>
<pre>{{template "head" .}}<br/><br/>{{template "prom_content_head" .}}</pre>
<p>The <kbd>head</kbd> template expands to HTML that defines the inclusion of CSS and JavaScript, the top navbar, and the menu; the <kbd>prom_content_head</kbd> template on the other hand, defines the time controls, as shown in the following code:</p>
<pre>&lt;h1&gt;Grafana&lt;/h1&gt;<br/><br/>&lt;h3&gt;Requests by endpoint&lt;/h3&gt;<br/>&lt;div id="queryGraph"&gt;&lt;/div&gt;<br/>&lt;script&gt;<br/>new PromConsole.Graph({<br/>  node: document.querySelector("#queryGraph"),<br/>  expr: "sum(rate(http_request_total{job='grafana'}[5m])) by (handler)",<br/>  name: '[[ handler ]]',<br/>  yAxisFormatter: PromConsole.NumberFormatter.humanizeNoSmallPrefix,<br/>  yHoverFormatter: PromConsole.NumberFormatter.humanizeNoSmallPrefix,<br/>  yUnits: "/s",<br/>  yTitle: "Requests"<br/>})<br/>&lt;/script&gt;</pre>
<p>This section defines the console itself. The <kbd>queryGraph</kbd> element is used as the placeholder that the graphing JavaScript library will use to generate the graph. The JavaScript snippet, on the other hand, configures the graph with the selector that is to be used (<kbd>node</kbd>), what expression to graph (<kbd>expr</kbd>), what to use in the legend (<kbd>name</kbd>), and several <em>y-</em>axis configurations, as shown in the following code:</p>
<pre>{{template "prom_content_tail" .}}<br/><br/>{{template "tail"}}</pre>
<p>The last two templates close the sections that the first opened. They are needed so that the generated HTML is well formed.</p>
<p>The resulting console is available in the test environment for this chapter, and can be checked out at <kbd>http://192.168.42.10:9090/consoles/grafana.html</kbd>. Here is a screenshot of how it should look:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7e993420-24b6-4226-9b65-5cad8c8e01fe.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 10.21: Example console for Grafana requests per second</div>
<p>Note that the menu on the left-hand side does not have a link to our newly created console template. This is because the included <kbd>menu.lib</kbd> only supports the example console templates that ship with Prometheus. When deploying actual custom console templates, you would need to replace this library with your own. This would allow you to add links to other internal systems in the navbar at the top and list which consoles should be available on the navigation menu on the left. By leveraging the fact that you can perform PromQL queries in templates, you should be able to find out which jobs are scraped by that Prometheus instance and generate links to similarly named consoles.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we explored the standard visualization tool for Prometheus: Grafana. We've learned how to provision not only data sources, but dashboards as well. After learning about the building blocks of a dashboard, we created a simple dashboard from scratch, learning all that it entails step by step. We also learned how to take advantage of the thriving community-built dashboard gallery. Giving back to the community is always important, so we've gone through the process of exporting and publishing dashboards. Finally, we were introduced to the Prometheus default visualizations—the consoles—which, even though they have a steep learning curve, are extremely powerful.</p>
<p class="mce-root">In the next chapter, we'll be exploring the Alertmanager, how to best take advantage of its functionalities, and how to integrate it with Prometheus.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>How can you provision a data source automatically in Grafana?</li>
<li>What are the steps to import a dashboard from the Grafana gallery?</li>
<li>How do Grafana dashboard variables work?</li>
<li>What's the building block of a dashboard?</li>
<li>When you update a dashboard that's published to <a href="https://grafana.com/">grafana.com</a>, does it change its ID?</li>
<li>In Prometheus terms, what is a console?</li>
<li>Why would you use Prometheus console templates?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li class="mce-root"><strong>Grafana Explore</strong><span>:</span> <a href="http://docs.grafana.org/features/explore/">http://docs.grafana.org/features/explore/</a></li>
<li><strong>Grafana templating</strong>: <a href="http://docs.grafana.org/reference/templating/">http://docs.grafana.org/reference/templating/</a></li>
<li><strong>Grafana time range</strong>: <a href="http://docs.grafana.org/reference/timerange/">http://docs.grafana.org/reference/timerange/</a></li>
<li><strong>Console templates official documentation</strong>: <a href="https://prometheus.io/docs/visualization/consoles/">https://prometheus.io/docs/visualization/consoles/</a></li>
<li><strong>Console templates best practices</strong>: <a href="https://prometheus.io/docs/practices/consoles/">https://prometheus.io/docs/practices/consoles/</a></li>
</ul>


            </article>

            
        </section>
    </body></html>