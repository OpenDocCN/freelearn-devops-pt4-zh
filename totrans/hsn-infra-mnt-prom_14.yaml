- en: Understanding and Extending Alertmanager
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解与扩展 Alertmanager
- en: Alerting is a critical component in any monitoring stack. In the Prometheus
    ecosystem, alerts and their subsequent notifications are decoupled. Alertmanager
    is the component that handles these alerts. In this chapter, we'll be focusing
    on converting alerts into useful notifications using Alertmanager. From reliability
    to customization, we'll delve into the inner workings of the Alertmanager service,
    providing the required knowledge to configure, troubleshoot, and customize all
    the options available. We'll make sure that concepts such as alert routing, silencing,
    and inhibition are clear so that you can decide how to implement them in your
    own stack.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 警报是任何监控堆栈中的关键组件。在 Prometheus 生态系统中，警报及其后续通知是解耦的。Alertmanager 是处理这些警报的组件。在本章中，我们将专注于使用
    Alertmanager 将警报转换为有用的通知。从可靠性到自定义，我们将深入探讨 Alertmanager 服务的内部工作原理，提供所需的知识，以配置、排除故障并自定义所有可用选项。我们将确保警报路由、静默和抑制等概念清晰，以便你能够决定如何在自己的堆栈中实现它们。
- en: Since Alertmanager is a critical component, high availability will also be explored,
    and we will also explain the relationship between Prometheus and Alertmanager.
    We will customize notifications and learn how to build and use reusable templates
    so that notifications are appropriate and carry accurate information when they
    reach their destination. We will finish this chapter by learning how to monitor
    the monitoring system and, more importantly, learning how to be alerted when the
    system is partially or completely down.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Alertmanager 是一个关键组件，我们还将探讨高可用性，并解释 Prometheus 与 Alertmanager 之间的关系。我们将自定义通知，并学习如何构建和使用可重用的模板，以确保通知在到达目的地时是适当的，并且传递准确的信息。本章的最后，我们将学习如何监控监控系统，更重要的是，学习当系统部分或完全宕机时如何收到警报。
- en: 'We will explore the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Test environment for this chapter.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的测试环境。
- en: Alertmanager fundamentals.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alertmanager 基础知识。
- en: Alertmanager configuration.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alertmanager 配置。
- en: Common Alertmanager notification integrations.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的 Alertmanager 通知集成。
- en: Customizing your alert notifications.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义你的警报通知。
- en: Who watches the Watchmen?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁来监视“监视者”？
- en: Setting up the test environment
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置测试环境
- en: To work with Alertmanager, we'll be three new instances to simulate a highly
    available setup. This approach will allow us to not only expose the required configurations,
    but also validate how everything works together.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Alertmanager，我们将新增三个实例来模拟一个高可用的设置。这种方法不仅能让我们暴露所需的配置，还能验证一切如何协同工作。
- en: 'The setup we''ll be using resembles the following diagram:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的设置类似于以下图示：
- en: '![](img/d40bc98a-eaf8-4512-b628-306b0872f0f0.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d40bc98a-eaf8-4512-b628-306b0872f0f0.png)'
- en: 'Figure 11.1: Test environment'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：测试环境
- en: Deployment
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: 'Let''s begin by deploying the Alertmanager test environment:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从部署 Alertmanager 测试环境开始：
- en: 'To launch a new test environment, move into this chapter''s path, relative
    to the repository root:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启动一个新的测试环境，请进入本章相对于仓库根目录的路径：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Ensure that no other test environments are running and spin up this chapter''s
    environment:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保没有其他测试环境在运行，然后启动本章的环境：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can validate the successful deployment of the test environment using the
    following command:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过以下命令验证测试环境的成功部署：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You will receive the following output:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你将收到以下输出：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When the deployment tasks end, you''ll be able to validate the following endpoints
    on your host machine using your favorite JavaScript-enabled web browser:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当部署任务完成后，你将能够使用你喜欢的支持 JavaScript 的网页浏览器，在主机上验证以下端点：
- en: '| **Service** | **Endpoint** |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| **服务** | **端点** |'
- en: '| Prometheus | `http://192.168.42.10:9090` |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| Prometheus | `http://192.168.42.10:9090` |'
- en: '| Alertmanager01 | `http://192.168.42.11:9093` |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| Alertmanager01 | `http://192.168.42.11:9093` |'
- en: '| Alertmanager02 | `http://192.168.42.12:9093` |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| Alertmanager02 | `http://192.168.42.12:9093` |'
- en: '| Alertmanager03 | `http://192.168.42.13:9093` |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| Alertmanager03 | `http://192.168.42.13:9093` |'
- en: 'You should be able to access the desired instance by using one of the following
    commands:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够通过以下命令之一访问所需的实例：
- en: '| **Instance** | **Command** |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **实例** | **命令** |'
- en: '| Prometheus | `vagrant ssh prometheus` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| Prometheus | `vagrant ssh prometheus` |'
- en: '| Alertmanager01 | `vagrant ssh alertmanager01` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| Alertmanager01 | `vagrant ssh alertmanager01` |'
- en: '| Alertmanager02 | `vagrant ssh alertmanager02` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| Alertmanager02 | `vagrant ssh alertmanager02` |'
- en: '| Alertmanager03 | `vagrant ssh alertmanager03` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| Alertmanager03 | `vagrant ssh alertmanager03` |'
- en: Cleanup
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理
- en: 'When you''ve finished testing, just make sure you''re inside `./chapter11/`
    and execute the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 测试完成后，只需确保你位于 `./chapter11/` 目录下，并执行以下命令：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Don't worry too much – you can easily spin up the environment again if you need
    to.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 不用太担心——如果需要，你可以轻松地再次启动环境。
- en: Alertmanager fundamentals
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Alertmanager 基础知识
- en: We covered how alerting rules work in Prometheus in [Chapter 9](9aa1e3da-13cf-4051-845d-1d1c924ef47b.xhtml),
    *Defining Alerting and Recording Rules*, but those, by themselves, aren't all
    that useful. As we mentioned previously, Prometheus delegates notification handling
    and routing to external systems through a Webhook-style HTTP interface. This is
    where Alertmanager comes in.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第9章](9aa1e3da-13cf-4051-845d-1d1c924ef47b.xhtml)中讲解了 Prometheus 中告警规则的工作原理，*定义告警和记录规则*，但仅仅这些规则本身并不十分有用。如我们之前提到的，Prometheus
    通过 Webhook 风格的 HTTP 接口将通知处理和路由委托给外部系统。这就是 Alertmanager 的作用所在。
- en: Alertmanager is responsible for accepting the alerts generated from Prometheus
    alerting rules and converting them into notifications. The latter can take any
    form, such as email messages, chat messages, pages, or even Webhooks that will
    then trigger custom actions, such as logging alerts to a data store or creating/updating
    tickets. Alertmanager is also the only component in the official stack that distributes
    its state across instances so that it can keep track of things such as which alerts
    were already sent and which ones are silenced.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Alertmanager 负责接收由 Prometheus 告警规则生成的告警，并将它们转换为通知。后者可以采取任何形式，例如电子邮件、聊天消息、页面通知，甚至是
    Webhook，这些 Webhook 会触发自定义操作，如将告警记录到数据存储中或创建/更新工单。Alertmanager 还是官方栈中唯一一个将其状态分发到多个实例的组件，这样它就能跟踪哪些告警已发送，哪些被静默。
- en: The notification pipeline
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通知管道
- en: 'The following diagram, inspired by the architecture diagram of Alertmanager,
    provides an overview of the steps an alert goes through until it''s successfully
    sent as a notification:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表受到 Alertmanager 架构图的启发，提供了一个概述，展示了告警经过的各个步骤，直到它成功地作为通知发送出去：
- en: '![](img/18b36137-36bb-4725-9259-1abbdfc5528b.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18b36137-36bb-4725-9259-1abbdfc5528b.png)'
- en: 'Figure 11.2: Notification pipeline overview'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2：通知管道概览
- en: The preceding diagram has a lot to unpack, so we're going to go through each
    of these steps in the next few sections. Knowing how the alert pipeline works
    will help you understand the various configuration options, how to troubleshoot
    missing alerts, and generally take full advantage of everything Alertmanager has
    to offer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表包含了很多内容，因此我们将在接下来的几节中逐一讲解这些步骤。了解告警管道的工作原理将帮助你理解各种配置选项，如何排查丢失的告警，并全面利用 Alertmanager
    提供的所有功能。
- en: Dispatching alert groups to the notification pipeline
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将告警组派发到通知管道
- en: 'Whenever an alerting rule is triggered, Prometheus will send an alert in the
    form of a JSON payload to the Alertmanager API, and it will keep sending updates
    at each evaluation interval of that rule or every minute (configurable through
    the `--rules.alert.resend-delay` flag), whichever is longer. When alerts are received
    by Alertmanager, they go through the dispatching step, where they will be grouped
    using one or more of the alert labels, such as `alertname`. We''re going to discuss
    more about this in the *Alertmanager configuration* section, later in this chapter.
    This allows you to sort alerts into categories, which can reduce the number of
    notifications that are sent as multiple alerts in the same category and are grouped
    together in a single notification, which will then trigger the notification pipeline:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个告警规则被触发时，Prometheus 会以 JSON 负载的形式将告警发送到 Alertmanager API，并且它会在该规则的每个评估间隔或每分钟（通过
    `--rules.alert.resend-delay` 标志可配置）内继续发送更新，以较长者为准。当告警被 Alertmanager 接收时，它们会经过调度步骤，在此步骤中，告警会根据一个或多个告警标签进行分组，例如
    `alertname`。我们将在本章后面的*Alertmanager 配置*部分进一步讨论。这样做可以将告警分类，从而减少多个告警合并为一个通知发送的次数，这些合并后的告警会触发通知管道：
- en: '![](img/f2fb4c43-294d-41ac-85cf-6457f1cef663.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2fb4c43-294d-41ac-85cf-6457f1cef663.png)'
- en: 'Figure 11.3: Alertmanager interface grouping alerts by alertname'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3：Alertmanager 界面通过 alertname 分组告警
- en: When running multiple Prometheus instances with the same configuration (a common
    setup when pursuing high availability/redundancy), alerting rules for the same
    condition won't necessarily trigger at the exact same time. Alertmanager accounts
    for this situation by having a configurable time interval. It will wait before
    doing anything else so that similar alerts can be grouped together and thus avoid
    sending multiple notifications for a single type of problem.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行多个具有相同配置的Prometheus实例时（追求高可用性/冗余性时的常见设置），相同条件的警报规则不一定会在完全相同的时间触发。Alertmanager通过具有可配置时间间隔来解决这种情况。它会等待其他任何操作，以便将相似的警报分组在一起，从而避免为单一类型的问题发送多个通知。
- en: This grouping is done in parallel across all the user-specified criteria. Each
    group will then trigger the notification pipeline, which we'll cover next.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分组是在用户指定的所有标准并行进行的。然后，每个组将触发通知管道，接下来我们将详细介绍它。
- en: Inhibition
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抑制
- en: A good example to help us understand what alert inhibition is is imagining a
    server rack and what happens if the top-of-rack switch fails. In this scenario,
    all the servers and services in that rack will start triggering alerts because
    they suddenly became unreachable. To avoid this problem, we can use the alert
    for the top-of-rack switch which, if triggered, will prevent the notifications
    for all the other alerts in that rack from going out. This helps the operator
    become more focused on the real problem and avoid a flood of unactionable alerts.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子可以帮助我们理解什么是警报抑制，就像想象一个服务器机架，如果顶部交换机失效会发生什么。在这种情况下，该机架中的所有服务器和服务都将开始触发警报，因为它们突然无法访问。为了避免这个问题，我们可以使用顶部交换机的警报，如果触发了，将阻止该机架中所有其他警报的通知发送出去。这有助于操作员更专注于真正的问题，避免洪水般的无法采取行动的警报。
- en: So, in a nutshell, inhibition allows you to map dependencies between alerts,
    and therefore prevents notifications for dependent alerts from going any further
    in the notification pipeline. This is set up in the Alertmanager configuration
    file, which means inhibitions require a service reload if changed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 简言之，抑制允许您映射警报之间的依赖关系，因此阻止依赖警报的通知继续在通知管道中传递。这是在Alertmanager配置文件中设置的，这意味着如果更改，则需要重新加载服务。
- en: If the alert is not matched in the inhibition phase, it will then step into
    the silencer step.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在抑制阶段未匹配警报，则会进入静音步骤。
- en: Silencing
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静音
- en: 'Silencing is a common concept in monitoring/alerting systems; it is how you
    can avoid alert notifications from going out in a time-capped way. It is often
    used to disable notifications during maintenance windows, or to temporarily suppress
    alerts of lower importance during incidents. Alertmanager takes this concept and
    supercharges it by taking advantage of the fact that alerts coming in usually
    have one or more differentiating labels: ones from the originating alerting rule
    expression, the alertname, the alert''s label fields, from `alert_relabel_configs`,
    as well as the ones from the Prometheus `external_labels`. This means that any
    one of these labels (or a combination of them) can be used to temporarily disable
    notifications through either direct matching or through regular expression matching:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在监控/警报系统中，静音是一个常见概念；它可以在有时间限制的情况下避免警报通知的发送。通常用于在维护窗口期间禁用通知，或在事故期间临时抑制较低重要性的警报。Alertmanager通过利用警报通常具有一个或多个不同标签的事实来加强这一概念：来自原始警报规则表达式、警报名称、警报的标签字段、`alert_relabel_configs`，以及Prometheus
    `external_labels`。这意味着可以使用这些标签中的任何一个（或它们的组合），通过直接匹配或正则表达式匹配来临时禁用通知：
- en: '![](img/34d02fda-3fe3-4365-a54a-c946cecab22e.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34d02fda-3fe3-4365-a54a-c946cecab22e.png)'
- en: 'Figure 11.4: Creating a silence matching alertname=NodeExporterDown'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：创建匹配 alertname=NodeExporterDown 的静音
- en: You should be careful with regex matching as you can accidentally silence more
    than you expect. The Alertmanager web UI can help prevent this as it shows a preview
    of which firing alerts will be suppressed when creating new silences.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用正则表达式匹配时要小心，因为可能会意外地静音超出预期的内容。Alertmanager Web UI 可以帮助预防此类问题，因为在创建新的静音时，它会显示将被抑制的触发警报的预览。
- en: Silences are defined at runtime. They can be set using the Alertmanager web
    interface, `amtool` (the Alertmanager command-line interface, which is going to
    be presented shortly), or directly through the API. They can be set while an alert
    is firing, such as during an incident, or in advance so that planned maintenance
    doesn't spam the people doing on-call. It is not supposed to be a permanent solution
    for a firing alert, only a temporary measure; this is why creating a silence requires
    that you set an expiration date for it, and why the web UI only recognizes durations
    up to days.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 静默是在运行时定义的。可以通过 Alertmanager Web 界面、`amtool`（稍后将介绍的 Alertmanager 命令行界面）或直接通过
    API 设置静默。可以在警报触发时设置静默，比如在事故处理中，或者提前设置以避免计划中的维护干扰值班人员。它不应成为一个永久的解决方案，仅是一个临时措施；因此，创建静默时需要设置到期日期，并且
    Web UI 仅识别最长为“天”的持续时间。
- en: Since the silencing step comes after inhibition, if you silence an alert that
    is triggering inhibition rules, it will continue to inhibit other alerts.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于静默步骤位于抑制之后，如果您对触发抑制规则的警报进行静默，它将继续抑制其他警报。
- en: If the alert didn't match any of the silences, it will go through to the next
    step in the notification pipeline, which is the routing phase.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果警报未与任何静默匹配，它将进入通知管道的下一步骤，即路由阶段。
- en: Routing
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: When an alert batch reaches this phase, Alertmanager needs to decide where to
    send it. Since the most common use cases are to have different people interested
    in different alerts, different notification methods for different alert severities,
    or even a combination of both, this step enables just that by way of a routing
    tree. It is composed of routes (if any), each of which specifies a match criteria
    for one or more labels and a receiver, and a root node, which defines a catch-all
    receiver in case none of the sub-routes have a match for the alert groups passing
    through. Sub-routes can have their own routes, making it a multi-level tree. Matching
    is done in the order the routes are declared in, going into defined sub-routes
    first when a route matches, and the highest depth match will define which receiver
    will be used. This will become clearer when we put it in action using the Alertmanager
    configuration.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当警报批次到达此阶段时，Alertmanager 需要决定将其发送到哪里。由于最常见的使用场景是不同的人对不同的警报感兴趣、对不同严重性的警报使用不同的通知方式，或者这两者的组合，因此此步骤通过路由树实现了这一点。它由多个路由（如果有的话）组成，每个路由指定了一个或多个标签的匹配条件和接收器，以及一个根节点，根节点定义了一个“捕获所有”接收器，以防没有子路由与传递的警报组匹配。子路由可以有自己的路由，从而形成多层树结构。匹配按声明路由的顺序进行，当一个路由匹配时，会进入已定义的子路由，而最深的匹配将决定使用哪个接收器。我们在实际应用中使用
    Alertmanager 配置时，这一点会更加清晰。
- en: 'Receivers and notifiers work similar in concept to address book contacts. Receivers
    are named contacts that can have one or more notifiers, which are like contact
    information. Alertmanager supports a lot of different notifiers that generally
    fall into one of the following categories: email, chat (Slack, WeChat, HipChat),
    and page (PagerDuty, Opsgenie, VictorOps, Pushover). Additionally, it also supports
    the Webhook notifier, which is a generic integration point that can be used to
    support every other notification system that is not built into Alertmanager.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接收器和通知器的工作方式类似于通讯录联系人。接收器是命名的联系人，可以有一个或多个通知器，通知器类似于联系信息。Alertmanager 支持许多不同的通知器，通常属于以下类别之一：电子邮件、聊天（Slack、微信、HipChat）和页面（PagerDuty、Opsgenie、VictorOps、Pushover）。此外，它还支持
    Webhook 通知器，这是一个通用的集成点，可用于支持所有未内置于 Alertmanager 的其他通知系统。
- en: After this routing stage connects an alert batch with a receiver, Alertmanager
    will then run a notification job for each notifier specified in that receiver.
    This job takes care of deduplicating, sending, and retrying notifications. For
    deduplication, it first checks the notification log (which will be discussed later
    in this chapter) to make sure that this particular notification hasn't been sent
    yet; if is already there, no further action is taken. Next, it will try to send
    the notification and, if it succeeds, that will be recorded in the notification
    log. If a notification fails to go through (for example, API error, connection
    timeout, and so on), the job will try again.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在此路由阶段将警报批次与接收器连接后，Alertmanager 会为该接收器中指定的每个通知器运行通知任务。这个任务负责去重、发送和重试通知。对于去重，它首先检查通知日志（稍后将在本章中讨论），确保该通知尚未发送；如果已经存在，则不执行任何操作。接下来，它会尝试发送通知，如果成功，通知将被记录在通知日志中。如果通知发送失败（例如
    API 错误、连接超时等），该任务会再次尝试。
- en: Now that we know the basics of the notification pipeline, let's have a look
    at what happens when there are several Alertmanager instances and how the alert
    state is shared among them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了通知管道的基本知识，接下来我们来看看当有多个 Alertmanager 实例时，会发生什么情况，以及如何在它们之间共享警报状态。
- en: Alertmanager clustering
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Alertmanager 集群
- en: The overview of the notification pipeline does not touch on the high availability
    component of Alertmanager. The way high availability is achieved is by relying
    on gossip (based on the HashiCorp memberlist, [https://github.com/hashicorp/memberlist](https://github.com/hashicorp/memberlist)),
    instead of using a consensus-based protocol; this means there's no real reason
    for choosing an odd number of instances in a cluster. Using gossip, the cluster
    shares the **notification log** (**nflog**) between all Alertmanager instances,
    which in turn will be aware of the collective state of the cluster regarding notifications.
    In the case of a network partition, there will be notifications being sent from
    each side of the partition, since logically it's better to receive more notifications
    than failing to notify altogether.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通知管道的概述没有涉及 Alertmanager 的高可用性组件。高可用性是通过依赖 gossip（基于 HashiCorp 的 memberlist，[https://github.com/hashicorp/memberlist](https://github.com/hashicorp/memberlist)）来实现的，而不是使用基于共识的协议；这意味着选择集群中实例的奇数数量没有实际意义。通过
    gossip，集群在所有 Alertmanager 实例之间共享**通知日志**（**nflog**），从而让每个实例都能了解到集群在通知方面的整体状态。如果发生网络分区，通知将会从每个分区的一方发送，因为从逻辑上讲，接收更多通知总比完全无法通知要好。
- en: As we now know, inhibition is set at the configuration file level, so it should
    be the same across all Alertmanager instances. However, silences also need to
    be gossiped across the cluster as they are set at runtime on a single Alertmanager
    instance. This is a good way to validate if the clustering is working as expected
    – confirming whether the configured silences show up in all instances.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，抑制是在配置文件级别设置的，因此它应该在所有 Alertmanager 实例中保持一致。然而，静默也需要在集群中进行 gossip，因为它们是在单个
    Alertmanager 实例的运行时设置的。这是验证集群是否按预期工作的一个好方法——确认配置的静默是否在所有实例中都能显示。
- en: 'The Alertmanager `/#/status` page shows the status of the gossip cluster, along
    with the known peers. You can check out this endpoint in our test environment
    by opening up, for example, `http://192.168.42.11:9093/#/status`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Alertmanager `/#/status` 页面显示了 gossip 集群的状态，以及已知的对等节点。你可以在我们的测试环境中查看这个端点，例如打开
    `http://192.168.42.11:9093/#/status`：
- en: '![](img/fc9b2956-1d3e-4687-ae5a-a39c2d29aaa8.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc9b2956-1d3e-4687-ae5a-a39c2d29aaa8.png)'
- en: 'Figure 11.5: Alertmanager cluster status'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5：Alertmanager 集群状态
- en: 'The way clustering works in Alertmanager is like so: every Prometheus instance
    sends alerts to all the Alertmanager instances they know about. Those instances,
    assuming they are all in the same HA cluster, order themselves, and the one that
    becomes the first will handle alert notifications. That instance will distribute
    the notification log through gossip, which will list the notifications that were
    successfully sent. Each of the remaining Alertmanager instances will have an increasing
    amount of delay, according to their respective position in the ordering, to wait
    for the notification log updates. Alerts in the notification log will not be sent
    again by these instances – if the notification log does not state that a given
    notification was taken care of by the time the gossip delay is done, then the
    second Alertmanager will take care of it, and so on:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Alertmanager 中，集群工作方式如下：每个 Prometheus 实例将告警发送到它们所知道的所有 Alertmanager 实例。这些实例假设它们都在同一个
    HA 集群中，会自己排序，并且排在第一位的实例将处理告警通知。该实例通过传播协议分发通知日志，通知日志会列出已成功发送的通知。其余的 Alertmanager
    实例将根据它们在排序中的位置，增加等待通知日志更新的延迟。通知日志中的告警不会被这些实例重新发送——如果通知日志没有说明某个通知在传播延迟结束时已被处理，那么第二个
    Alertmanager 实例将处理它，以此类推：
- en: '![](img/484c081e-4d9e-488e-9a22-7a584ff688b8.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/484c081e-4d9e-488e-9a22-7a584ff688b8.png)'
- en: 'Figure 11.6: Alertmanager clustering overview'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6：Alertmanager 集群概览
- en: Prometheus instances talk directly to all Alertmanager instances, since the
    cluster members will take care of deduplication between themselves. This means
    that no load balancers should be placed between Prometheus and Alertmanager.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 实例直接与所有 Alertmanager 实例通信，因为集群成员将负责彼此之间的去重。这意味着不应在 Prometheus 和 Alertmanager
    之间放置负载均衡器。
- en: Alertmanager clustering assumes that every instance is running with the same
    configuration file. However, failing to do so should only impact its ability to
    deduplicate notifications.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Alertmanager 集群假设每个实例都使用相同的配置文件运行。然而，如果没有做到这一点，只会影响其去重通知的能力。
- en: Alertmanager configuration
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Alertmanager 配置
- en: In [Chapter 9](9aa1e3da-13cf-4051-845d-1d1c924ef47b.xhtml),* Defining Alerting
    and Recording Rules*, we discussed how Prometheus generates and pushes out alerts.
    Having also made clear the distinction between an alert and a notification, it's
    now time to use Alertmanager to handle the alerts that are sent by Prometheus
    and turn them into notifications.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](9aa1e3da-13cf-4051-845d-1d1c924ef47b.xhtml)，*定义告警和记录规则*中，我们讨论了 Prometheus
    如何生成并推送告警。在已经明确区分告警和通知之后，现在是时候使用 Alertmanager 来处理 Prometheus 发送的告警并将其转化为通知了。
- en: Next, we'll go through the configuration required on Prometheus, along with
    the configuration options available in Alertmanager, so that we have notifications
    going out from our monitoring stack.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍在 Prometheus 中所需的配置，以及在 Alertmanager 中可用的配置选项，以便我们能够从监控栈中发送通知。
- en: Prometheus configuration
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Prometheus 配置
- en: There are a couple of configurations that need to be done in Prometheus so that
    we can start using Alertmanager. The first thing to do is configure the external
    labels, which are labels that are added to time series data (if it doesn't already
    have them) when communicating with external systems, including but not limited
    to Alertmanager. These are labels that uniquely identify the origin of the metrics,
    such as `region`, `datacenter`, or `environment`. As a rule of thumb, if you feel
    tempted to add the same label name/value to every single scrape and recording
    rule, that label would probably make more sense as an external label as it introduces
    no dimension to metrics locally in your Prometheus instance, but would most likely
    be useful in higher-level systems (such as with federation or long-term metric
    storage), as we will also see in the next few chapters. As we'll see in the following
    example, external labels are configured inside the top-level `global` key in the
    Prometheus main configuration file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Prometheus 中需要做几个配置，以便我们能够开始使用 Alertmanager。首先需要配置外部标签，这些标签会在与外部系统（包括但不限于
    Alertmanager）通信时，添加到时间序列数据中（如果数据中没有这些标签）。这些标签用于唯一标识指标的来源，比如 `region`、`datacenter`
    或 `environment` 等。一般来说，如果你有将相同的标签名/值添加到每个抓取和记录规则中的冲动，那么该标签更适合做为外部标签，因为它不会在本地的
    Prometheus 实例中引入新的维度，但在更高级的系统（例如联合或长期指标存储）中可能会非常有用，正如我们将在接下来的章节中看到的那样。正如我们将在以下示例中看到的，外部标签是在
    Prometheus 主配置文件的顶级 `global` 键内进行配置的。
- en: 'The second thing to do is configure Prometheus so that it can send alerts to
    Alertmanager. As we discussed previously, in the *Alertmanager clustering* section,
    Prometheus instances are required so that you can find out about and send alerts
    to all the Alertmanager cluster members individually. This configuration is set
    on the Prometheus configuration file in a top-level section called `alerting`.
    An example of this configuration can be found in our test environment, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是配置 Prometheus，使其能够将警报发送到 Alertmanager。正如我们之前在*Alertmanager 集群*一节中讨论的那样，Prometheus
    实例是必需的，以便你可以了解并将警报分别发送到所有 Alertmanager 集群成员。这个配置在 Prometheus 配置文件中，位于一个名为 `alerting`
    的顶级部分中。这个配置的示例可以在我们的测试环境中找到，具体如下：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this `alerting` section, we can also use `alert_relabel_configs`, which
    has the same configuration syntax as `relabel_configs` and `metric_relabel_configs`,
    as explained in [Chapter 5](12e775c2-bee9-4ebe-ad73-2f9313eeeeee.xhtml), *Running
    a Prometheus Server*, but in this case, it applies only to alerts going out. Using
    relabeling here can be useful to prevent certain alerts from reaching Alertmanager
    altogether, altering or dropping labels to ease grouping, or even adding alert-specific
    labels that for, some reason, don''t make sense in `external_labels`. Since `alert_relabel_configs`
    is run right before we send out alerts, external labels are present in those alerts
    and as such are available for manipulation. Here''s an example of preventing alerts
    with a label called `environment` and matching value of `development` from being
    pushed to Alertmanager:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `alerting` 部分，我们还可以使用 `alert_relabel_configs`，它的配置语法与 `relabel_configs` 和
    `metric_relabel_configs` 相同，正如在[第 5 章](12e775c2-bee9-4ebe-ad73-2f9313eeeeee.xhtml)《运行
    Prometheus 服务器》中所解释的那样，但在这种情况下，它仅适用于传出的警报。使用重标记在这里是有用的，可以防止某些警报完全到达 Alertmanager，修改或丢弃标签以便于分组，甚至可以添加某些警报特有的标签，这些标签在
    `external_labels` 中可能没有意义。由于 `alert_relabel_configs` 在我们发送警报之前运行，因此外部标签会出现在这些警报中，并因此可以进行操作。以下是一个示例，防止具有名为
    `environment` 且匹配值为 `development` 的标签的警报被推送到 Alertmanager：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: While the preceding example illustrates how to drop alerts, it should not be
    used as a permanent solution as the better solution would probably be to not create
    these alerts at all.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的示例说明了如何丢弃警报，但不应将其作为永久解决方案，因为更好的解决方案可能是根本不创建这些警报。
- en: Next, we're going to go through the Alertmanager configuration file, and its
    main areas, and point out some useful information that will help you get started
    with it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍 Alertmanager 配置文件及其主要部分，并指出一些有用的信息，帮助你入门。
- en: Configuration file overview
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置文件概述
- en: 'Alertmanager is configured through a single configuration file, and can reload
    it at runtime without restarting the same way Prometheus does: either sending
    a `SIGHUP` to the process or sending an HTTP POST request to the `/-/reload` endpoint.
    Such as Prometheus, a malformed configuration will not be applied – an error message
    will be logged and the `alertmanager_config_last_reload_successful` metric that''s
    found in its `/metrics` endpoint will be set to `0`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Alertmanager 通过一个单一的配置文件进行配置，并且可以像 Prometheus 一样在运行时重新加载，而无需重启：可以通过向进程发送 `SIGHUP`
    或发送 HTTP POST 请求到 `/-/reload` 端点来实现。与 Prometheus 一样，格式错误的配置将不会被应用——系统会记录错误信息，并且在其
    `/metrics` 端点中找到的 `alertmanager_config_last_reload_successful` 指标将被设置为 `0`。
- en: 'The configuration file is divided into five top-level sections: `global`, `route`,
    `inhibit_rules`, `receivers`, and `templates`. In the following sections, we''ll
    be exploring each one of them.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件分为五个顶级部分：`global`、`route`、`inhibit_rules`、`receivers` 和 `templates`。在接下来的章节中，我们将逐一探讨每个部分。
- en: global
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: global
- en: The global section gathers all the configuration options that are valid in other
    sections of the file, and act as default settings for those options. Since those
    parameters may be overridden in other sections, using them is a good way to keep
    the configuration file as clean as possible, avoiding repetition. Among all the
    available parameters in this section, most of them are related to credentials
    and tokens as notifiers. There's a noteworthy one called `resolve_timeout`. Prometheus
    will send alerts that are produced by triggering alerting rules on every evaluation
    interval, updating the `EndTime` field in JSON payload. When those get resolved,
    it notify Alertmanager of those resolutions by updating the `EndTime`. If, for
    some reason, an alert stops getting updated periodically (for example, the Prometheus
    instance sending that alert crashed and is still in the recovery process), Alertmanager
    will use the last received `EndTime` to resolve the alert. The `resolve_timeout` configuration
    is used to resolve alerts created by non-Prometheus systems, that don't use `EndTime`.
    To be clear, this is not a setting you should be changing as it pertains to the
    Prometheus-Alertmanager alert protocol; it is being explained here for completeness.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 全局部分收集了在文件的其他部分有效的所有配置选项，并作为这些选项的默认设置。由于这些参数可以在其他部分被覆盖，使用它们是保持配置文件尽可能简洁、避免重复的好方法。在这一部分的所有可用参数中，大多数与凭证和令牌作为通知器相关。这里有一个值得注意的参数，叫做`resolve_timeout`。当
    Prometheus 触发警报规则时，它将在每个评估间隔发送产生的警报，并更新 JSON 负载中的`EndTime`字段。当这些警报被解决时，Alertmanager会通过更新`EndTime`来通知这些解决。如果由于某些原因，警报停止定期更新（例如，发送该警报的
    Prometheus 实例崩溃并且仍在恢复过程中），Alertmanager 将使用最后接收到的`EndTime`来解决该警报。`resolve_timeout`配置用于解决由非
    Prometheus 系统创建的警报，这些系统不使用`EndTime`。需要明确的是，这是一个你不应该修改的设置，因为它与 Prometheus-Alertmanager
    警报协议相关；在此解释只是为了完整性。
- en: 'As an example, the global section of the Alertmanager configuration in our
    test environment looks as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们测试环境中 Alertmanager 配置的全局部分如下所示：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This example configuration sets the default email `smarthost` and the `from`
    address for every receiver that uses the email (SMTP) notifier.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例配置为每个使用电子邮件（SMTP）通知器的接收器设置默认的电子邮件`smarthost`和`from`地址。
- en: route
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: This is ostensibly the most important configuration section of Alertmanager.
    In this section, we will define how to group alerts based on their labels (`group_by`),
    how long to wait for new alerts before sending additional notifications (`group_interval`),
    and how long to repeat them (`repeat_interval`), but most importantly, which receivers
    should be triggered for each alert batch (`receiver`). Since each route can have
    its own child routes, this forms a routing tree. The top-level route can't have
    any matching rules as it works like a catch-all for any alert that doesn't match
    any of its sub-routes. Each setting, except `continue`, made on a route is carried
    over to its child routes in a cascading fashion. Although the default behavior
    is to stop searching for a receiver when the most specific match possible is found,
    it is possible to set `continue` to `true`, making the matching process keep going,
    thereby allowing you to trigger multiple receivers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这无疑是 Alertmanager 最重要的配置部分。在这一部分，我们将定义如何根据标签（`group_by`）对警报进行分组，等待多长时间才能发送更多通知（`group_interval`），以及如何重复它们（`repeat_interval`），但最重要的是，为每个警报批次触发哪些接收器（`receiver`）。由于每个路由都可以有自己的子路由，这就形成了一棵路由树。顶级路由不能有任何匹配规则，因为它像一个兜底规则，处理所有不匹配任何子路由的警报。除了`continue`，路由上的每个设置都会以级联方式传递给其子路由。尽管默认行为是在找到最具体的匹配项时停止搜索接收器，但可以将`continue`设置为`true`，使匹配过程继续，从而允许触发多个接收器。
- en: 'You can find the following example route configuration in our test environment:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在我们的测试环境中找到以下示例路由配置：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The main route in the preceding example does the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例中的主路由执行以下操作：
- en: Defines the `operations` receiver as the default route when no other sub-routes
    match
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`operations`接收器为默认路由，当没有其他子路由匹配时使用
- en: Groups incoming alerts by `alertname` and `job`
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据`alertname`和`job`对传入的警报进行分组
- en: Waits 30 seconds for more alerts to arrive before sending the first notification
    to reduce the number of notifications for the same problem
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发送第一次通知之前，等待 30 秒钟以便更多警报到达，从而减少相同问题的通知次数
- en: Waits five minutes before sending additional notifications when new alerts are
    added to a batch
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将新警报添加到批次后，等待五分钟再发送额外的通知
- en: Resends a notification every four hours for each alert batch with the currently
    firing alerts
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每四小时重新发送一次包含当前触发告警的告警批次的通知
- en: Additionally, it sets a sub-route for alerts whose `job` label matches either
    `checkoutService` or `paymentService` with its own receiver, `yellow-squad-email`.
    That sub-route, in turn, define its own child route that, if the severity label
    matches `pager`, should use the `yellow-squad-pager receiver` instead.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还为 `job` 标签匹配 `checkoutService` 或 `paymentService` 的告警设置了一个子路由，指定其接收者为 `yellow-squad-email`。该子路由反过来定义了一个自己的子路由，如果严重性标签匹配
    `pager`，则应使用 `yellow-squad-pager receiver`。
- en: The official Prometheus website offers a routing tree editor and visualizer
    at [https://prometheus.io/webtools/alerting/routing-tree-editor/](https://prometheus.io/webtools/alerting/routing-tree-editor/).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 官方 Prometheus 网站提供了一个路由树编辑器和可视化工具，链接：[https://prometheus.io/webtools/alerting/routing-tree-editor/](https://prometheus.io/webtools/alerting/routing-tree-editor/)。
- en: The `group_by` clause can also take the sole value of `...`, which will signal
    Alertmanager to not do any grouping for incoming alerts. This is very rarely used,
    as the purpose of grouping is to tune down the number of notifications so that
    the signal-to-noise ratio is high. One possible usage of this feature is to send
    every alert as-is to another system where alerts get processed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`group_by` 子句也可以采用唯一值 `...`，这将指示 Alertmanager 不对传入的告警进行任何分组。这种情况很少使用，因为分组的目的是减少通知的数量，从而提高信噪比。此功能的一个可能用途是将每个告警原样发送到另一个系统，供该系统处理。'
- en: inhibit_rules
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: inhibit_rules
- en: 'In this section, we will add rules to inhibit alerts. The way this works is
    by matching source alerts and muting target ones by using matchers on both. The
    only requirement is that the labels on the target and source match in terms of
    both label name and value, for example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将添加规则来抑制告警。其工作原理是通过在源和目标告警上使用匹配器来匹配源告警并静音目标告警。唯一的要求是目标和源的标签在标签名称和值上都要匹配，例如：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this example, we can read the following: if there''s an alert with the `job`
    label set to `icmp`, mute all other alerts with an `alertname` that matches `AlertmanagerDown`
    or `NodeExporterDown` when `base_instance` is the same across all matched alerts.
    In other words, if the instance that is running Alertmanager and Node Exporter
    is down, skip sending alerts about those services and just send the one about
    the instance itself, allowing the operator to focus on the real problem.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们可以读取到以下内容：如果有一个 `job` 标签设置为 `icmp` 的告警，且在所有匹配的告警中，`base_instance` 相同，则会静音所有
    `alertname` 匹配 `AlertmanagerDown` 或 `NodeExporterDown` 的告警。换句话说，如果运行 Alertmanager
    和 Node Exporter 的实例宕机，则跳过关于这些服务的告警，只发送关于实例本身的告警，让运维人员专注于真正的问题。
- en: If any label in the equal clause does not exist in both source and target alerts,
    it will be considered matched and thus inhibition will be enabled.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果等式子句中的任何标签在源和目标告警中都不存在，则视为匹配，从而启用抑制。
- en: If an alert matches both source and target in the inhibit rule definition, that
    alert will not be inhibited – this is to prevent an alert from inhibiting itself.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个告警同时匹配抑制规则定义中的源和目标，该告警将不会被抑制——这是为了防止告警抑制自身。
- en: 'We can see the interface of Alertmanager when this occurs in the following
    screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下截图中看到，当发生此情况时，Alertmanager 的界面：
- en: '![](img/2e9ca144-f7bb-42bd-9887-47f351d211e7.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e9ca144-f7bb-42bd-9887-47f351d211e7.png)'
- en: 'Figure 11.7: Alertmanager interface showing only firing notifications'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7：Alertmanager 界面，仅显示触发的通知
- en: 'In the following screenshot, we can see all the inhibited alerts that weren''t
    present in the preceding screenshot by selecting the **Inhibited** option in the
    top-right corner:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，我们可以通过选择右上角的**抑制**选项，看到所有未出现在前一张截图中的被抑制告警：
- en: '![](img/f3ac8d8a-c728-403e-a0e7-d75cd3448551.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3ac8d8a-c728-403e-a0e7-d75cd3448551.png)'
- en: 'Figure 11.8: Alertmanager interface showing notifications, including the inhibited
    ones'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8：Alertmanager 界面，显示包括被抑制告警在内的通知
- en: The Alertmanager interface allows you to have a bird's-eye view of all alerts,
    not only the ones that are active but also the ones that are inhibited. The default
    is to not show inhibited alerts in order to reduce visual clutter; however, as
    we can see in the preceding screenshot, you can easily enable showing them by
    selecting the **Inhibited** checkmark in the top-right corner of the **Filter**/**Group**
    box.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Alertmanager界面让你可以俯瞰所有警报，不仅是那些处于激活状态的警报，还有被抑制的警报。默认情况下不会显示被抑制的警报，以减少视觉杂乱；但是，正如我们在前面的截图中所看到的，你可以通过选择**抑制**复选框来轻松启用显示这些警报，位于**筛选器**/**分组**框的右上角。
- en: receiver
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: receiver
- en: When a route is matched, it will invoke a receiver. A receiver contains notifiers,
    which we'll be exploring more deeply in the following sections. Basically, the
    receiver is a named configuration for the available integrations.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当路由被匹配时，它将调用一个接收器。接收器包含通知器，我们将在后续章节中更深入地探讨这一点。基本上，接收器是可用集成的命名配置。
- en: 'In our test environment, we can find an example of a receiver by using the
    Webhook notifier, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试环境中，我们可以找到一个使用Webhook通知器的接收器示例，具体如下：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The top-level route, also known as the catch-all or fallback route, will trigger
    the receiver named `operations` when incoming alerts aren't matched in other sub-routes.
    The `operations` receiver is configured using a single notifier, which is the
    Webhook notifier. This means that alerts that go to this receiver are sent to
    the URL specified in the `url` configuration key. The Webhook notifier will be
    further dissected later in this chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级路由，也称为捕获所有或回退路由，将在其他子路由没有匹配到来警报时触发名为`operations`的接收器。`operations`接收器是使用单一通知器配置的，该通知器是Webhook通知器。这意味着发送到此接收器的警报会被发送到`url`配置键中指定的URL。Webhook通知器将在本章稍后进一步分析。
- en: templates
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: templates
- en: 'This section is where a list of paths that point to custom notification templates
    for the several notifiers that are available can be defined. Similar to other
    file path configurations in Prometheus, each path definition allows globing on
    the last component and can be defined as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是定义指向可用通知器的多个自定义通知模板的路径列表的地方。与Prometheus中的其他文件路径配置类似，每个路径定义允许在最后一个组件上使用glob模式，并可以如下定义：
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We'll be using this section to define our custom templates in the *Customizing
    your alert notifications* section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*自定义警报通知*部分使用这一部分来定义我们的自定义模板。
- en: The amtool command-line tool
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: amtool命令行工具
- en: Similar to `promtool`, `amtool` is an easy-to-use command-line tool backed by
    the Alertmanager HTTP API. Besides being useful for validating the correctness
    of the Alertmanager configuration file, it also allows you to query the server
    for currently triggering alerts, and to execute actions such as silencing alerts
    or creating new ones. The `amtool` sub-commands are split into four groups – `alert`,
    `silence`, `check-config`, and `config` – and we'll provide an overview of each
    one using the test environment.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`promtool`，`amtool`是一个易于使用的命令行工具，由Alertmanager HTTP API提供支持。除了用于验证Alertmanager配置文件的正确性外，它还允许你查询服务器中当前触发的警报，并执行诸如静默警报或创建新警报等操作。`amtool`的子命令分为四组——`alert`，`silence`，`check-config`和`config`——我们将使用测试环境对每一组进行概述。
- en: 'To follow the examples in this section, make sure that you connect to one of
    the Alertmanager instances. Since they are clustered, any one of them will do,
    for example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本节中的示例，确保你连接到其中一个Alertmanager实例。由于它们是集群化的，任何一个实例都可以，举例如下：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After logging in, you can run `amtool` as the default user, as no administrative
    permissions are required to interact with the Alertmanager API. Additionally,
    you can even use `amtool` to connect to any of the Alertmanager instances, not
    just the local instance, as most commands that interact with the HTTP API require
    that you specify the instance URL.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，你可以作为默认用户运行`amtool`，因为与Alertmanager API交互不需要管理员权限。此外，你甚至可以使用`amtool`连接到任何Alertmanager实例，而不仅仅是本地实例，因为与HTTP
    API交互的大多数命令要求你指定实例的URL。
- en: alert
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: alert
- en: 'This sub-command allows you to query the Alertmanager cluster for currently
    firing alerts, which can be achieved as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子命令允许你查询Alertmanager集群中当前触发的警报，可以通过如下方式实现：
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `alert` sub-command default action is `query`. The equivalent command to
    the previous example would be `amtool alert query --alertmanager.url http://alertmanager02:9093`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`alert`子命令的默认操作是`query`。与之前的示例等效的命令是`amtool alert query --alertmanager.url
    http://alertmanager02:9093`。'
- en: 'Another feature this sub-command has is the ability to create alerts on demand.
    This can come in useful for testing purposes. For example, let''s create a new
    alert named `ExampleAlert` with the label `example="amtool"`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此子命令的另一个功能是按需创建警报。这对于测试目的非常有用。例如，让我们创建一个名为 `ExampleAlert` 的新警报，标签为 `example="amtool"`：
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `add` action expects one label name/value pair per command argument, as
    we can see in the preceding code. This action will also consider the first argument
    since the alertname has no label name. An alert can be created without a name
    if we omit the `alertname` label, which can cause some weirdness in both `amtool`
    and the Alertmanager web UI, so some caution regarding this is advised.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`add` 操作期望每个命令参数都有一个标签名称/值对，正如我们在前面的代码中所看到的那样。此操作还会考虑第一个参数，因为警报名称没有标签名称。如果我们省略
    `alertname` 标签，警报也可以创建，但这可能会在 `amtool` 和 Alertmanager Web UI 中引发一些奇怪的行为，因此对此需要保持谨慎。'
- en: 'We can check that it was added correctly by waiting a bit (the defined `group_wait`
    in the test environment is 30 seconds) and then querying the current alerts again:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以稍等一会儿（在测试环境中，`group_wait` 定义为 30 秒），然后重新查询当前的警报，来检查它是否已正确添加：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This action also allows you to specify other alert fields, such as end time,
    generator URL, and annotations. You can consult the `add` action command-line
    interface (arguments and options) by using the `help` flag:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作还允许你指定其他警报字段，例如结束时间、生成器 URL 和注解。你可以通过使用 `help` 标志来查看 `add` 操作的命令行界面（参数和选项）：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Keep in mind that this newly created alert will be considered resolved after
    five minutes of inactivity (the default value for `resolve_timeout`), so be sure
    to add new instances of this alert (by running the `add` action) to keep it going
    if you need more time to test.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个新创建的警报将在五分钟的非活动后被认为已解决（`resolve_timeout` 的默认值），因此，如果你需要更多时间进行测试，请确保通过运行
    `add` 操作添加此警报的新实例，以保持警报继续存在。
- en: We'll be using this new alert next as a target for silencing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用这个新警报作为静默的目标。
- en: silence
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: silence
- en: 'With this sub-command, we can manage silences. First, we can try to query the
    available silences in the cluster by using the following instruction:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此子命令，我们可以管理静默。首先，我们可以尝试使用以下指令查询集群中可用的静默：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `silence` sub-command default action is `query`. The equivalent command
    to the previous example would be `amtool silence query --alertmanager.url http://alertmanager02:9093`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`silence` 子命令的默认操作是 `query`。与前面示例等效的命令是 `amtool silence query --alertmanager.url
    http://alertmanager02:9093`。'
- en: 'As we can see, no silence is currently being enforced. Let''s create a new
    one for the previous generated alert by matching its label, `example="amtool"`,
    and checking the silences again:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，目前没有任何静默被执行。让我们通过匹配其标签 `example="amtool"` 来为之前生成的警报创建一个新的静默，并再次检查静默：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can now see that the new silence has been added. To verify that it''s already
    in effect, we can use the `alert` sub-command and check that the `ExampleAlert`
    has disappeared from the list of current alerts:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到新静默已被添加。为了验证它是否已生效，我们可以使用 `alert` 子命令并检查 `ExampleAlert` 是否已从当前警报列表中消失：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s remove the silence we just created by using the `expire` action. For
    this, we need the silence identifier, which can be seen in the `ID` column when
    we listed the current silences:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用 `expire` 操作来移除刚刚创建的静默。为此，我们需要静默标识符，可以在列出当前静默时，在 `ID` 列中看到它：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If we query the list of current alerts again, we will see our `ExampleAlert`
    there again.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次查询当前的警报列表，我们将看到我们的 `ExampleAlert` 又出现了。
- en: These are the most common use cases for the silence feature. There are also
    other actions available, such as batch importing of silences (useful when migrating
    to a new cluster) or even updating an existing one if you ever so desire. As usual,
    the `--help` flag will provide you with guidance on how to use these actions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是静默功能最常见的使用场景。还有其他可用的操作，比如批量导入静默（在迁移到新集群时很有用）或在需要时更新现有的静默。像往常一样，`--help` 标志将为你提供如何使用这些操作的指导。
- en: check-config
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: check-config
- en: 'This is probably the most useful feature of `amtool`: the ability to validate
    the syntax and schema of our Alertmanager configuration file and referenced template
    files. You can test the `check-config` sub-command by following this example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是 `amtool` 最有用的功能：验证我们 Alertmanager 配置文件及引用的模板文件的语法和模式。你可以通过以下示例来测试 `check-config`
    子命令：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This type of validation is quite easy to automate and should be done after any
    configuration change, but before reloading the Alertmanager instance, thereby
    preventing most types of configuration issues.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的验证非常容易自动化，且应该在任何配置更改后进行，但在重新加载Alertmanager实例之前进行，以防止大多数类型的配置问题。
- en: config
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: config
- en: 'With the `config` sub-command, we can consult the internal configuration of
    a running Alertmanager instance, which includes all configurable fields, even
    ones not explicitly listed in the configuration file. You can check this by issuing
    the following command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`config`子命令，我们可以查询运行中的Alertmanager实例的内部配置，包括所有可配置字段，甚至是配置文件中未明确列出的字段。你可以通过执行以下命令来检查：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Configuration fields that were not specified in the configuration file will
    show with their default values, and fields that deal with secrets (such as passwords
    and tokens) will be automatically redacted.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件中未指定的配置字段将显示其默认值，而涉及秘密信息的字段（如密码和令牌）将被自动屏蔽。
- en: The `config` sub-command default action is shown. The equivalent command to
    the previous example would be `amtool config show --alertmanager.url http://alertmanager02:9093`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 显示了`config`子命令的默认操作。与前一个示例等效的命令是`amtool config show --alertmanager.url http://alertmanager02:9093`。
- en: 'The next sub-command action, `routes`, generates a text visualization of the
    configured routing tree. This command can be run against a running Alertmanager
    instance or a local configuration file. The syntax and output is as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子命令操作`routes`会生成配置的路由树的文本可视化。这个命令可以在运行中的Alertmanager实例或本地配置文件上执行。其语法和输出如下：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can even validate the routing tree by providing labels to the `routes test`
    action and checking which route would be triggered. We can see this in action
    in the following example, where we''re validating whether the triggered receiver
    is in fact `yellow-squad-email` when an alert comes in with the `job="checkoutService"`
    label:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以通过为`routes test`操作提供标签来验证路由树，并检查哪条路由会被触发。在以下示例中，我们可以看到当警报带有`job="checkoutService"`标签时，触发的接收器是否确实是`yellow-squad-email`：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Having this command-line tool around can help you streamline the development
    of complex routing rules and validate produced configurations without even needing
    an Alertmanager instance running locally.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这个命令行工具可以帮助你简化复杂路由规则的开发，并且无需本地运行Alertmanager实例即可验证生成的配置。
- en: Kubernetes Prometheus Operator and Alertmanager
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes Prometheus Operator 和 Alertmanager
- en: In [Chapter 5](12e775c2-bee9-4ebe-ad73-2f9313eeeeee.xhtml), *Running a Prometheus
    Server*, we had the opportunity to experiment with the Prometheus Operator. Since
    Alertmanager is a fundamental component of the Prometheus stack, the Operator
    is also able to manage its instances. Besides taking care of an Alertmanager cluster,
    the Operator is also responsible for managing the configuration of recording and
    alerting rules.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](12e775c2-bee9-4ebe-ad73-2f9313eeeeee.xhtml)，*运行Prometheus服务器*，我们有机会尝试了Prometheus
    Operator。由于Alertmanager是Prometheus栈的一个核心组件，因此Operator也能够管理其实例。除了负责管理Alertmanager集群外，Operator还负责管理记录和告警规则的配置。
- en: 'To provide some insight into how to use the Operator to manage an Alertmanager
    cluster, we will provide, as an example, a full setup for you to try out. The
    Kubernetes manifests for getting Alertmanager and Prometheus up and running in
    our Kubernetes test environment can be found, relative to the repository root
    path, at the following path:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一些如何使用Operator管理Alertmanager集群的见解，我们将提供一个完整的示例供你尝试。我们Kubernetes测试环境中使Alertmanager和Prometheus运行的Kubernetes清单可以在相对于仓库根路径的以下路径中找到：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following steps will ensure that a new Kubernetes environment with all
    the required software has been provisioned so that we can then focus on the Alertmanager
    component:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将确保已经配置好一个新的Kubernetes环境，并安装所有必需的软件，以便我们接下来可以专注于Alertmanager组件：
- en: 'Validate that no other Kubernetes environment is running:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证没有其他Kubernetes环境在运行：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Start an empty Kubernetes environment:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个空的Kubernetes环境：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the Prometheus Operator components and follow its deployment:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Prometheus Operator组件，并按照其部署步骤进行操作：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the new Prometheus cluster, ensuring that it''s successful:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加新的Prometheus集群，确保其成功：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add all the targets to Prometheus and list them:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有目标添加到Prometheus并列出它们：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After the Kubernetes test environment is running, we can proceed with Alertmanager-specific
    configurations. Similar to the virtual machine-based test environment, we'll require
    the provisioning of not only Alertmanager itself, but also the alerting rules
    for Prometheus.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 测试环境启动后，我们可以继续进行 Alertmanager 特定的配置。与基于虚拟机的测试环境类似，我们不仅需要配置 Alertmanager
    本身，还需要为 Prometheus 提供报警规则。
- en: For the Alertmanager configuration, since we might want to add sensitive information
    such as email credentials or a pager token, we are going to use a Kubernetes secret.
    This also implies that there should be a ServiceAccount for accessing that secret.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Alertmanager 配置，由于我们可能需要添加一些敏感信息，比如电子邮件凭证或呼叫令牌，我们将使用 Kubernetes secret。这也意味着应该有一个
    ServiceAccount 来访问该 secret。
- en: 'We can create the ServiceAccount by applying the following manifest:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过应用以下清单来创建 ServiceAccount：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Since we''re using a secret, the Alertmanager configuration needs to be encoded
    into base64\. A minimal configuration is provided and can be deployed by issuing
    the following command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了 secret，Alertmanager 配置需要编码为 base64。提供了一个最小配置，可以通过执行以下命令进行部署：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For reference, the minimal configuration that is encoded in the secret is the
    following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，编码在 secret 中的最小配置如下：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we can proceed with the deployment and get the Operator to do the heavy
    lifting for us. It will abstract the creation of a StatefulSet and get the cluster
    up and running. For this, we''re required to apply the following manifest:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续部署，并让 Operator 为我们处理繁重的工作。它会抽象出 StatefulSet 的创建，并让集群正常运行。为此，我们需要应用以下清单：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The important bit of the previous manifest can be seen in the following snippet:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 上述清单中的重要部分可以在以下代码片段中看到：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can follow the state of the deployment by issuing the following instruction:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行以下指令来跟踪部署状态：
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To ensure that the Prometheus instances can collect metrics from the newly
    created Alertmanagers, we''ll add a new Service and ServiceMonitor. For this,
    we need to apply the following manifests:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保 Prometheus 实例能够从新创建的 Alertmanager 收集指标，我们将添加一个新的 Service 和 ServiceMonitor。为此，我们需要应用以下清单：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It''s now time to add the alerting rules. To do this, you''re just required
    to apply the following manifest:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候添加报警规则了。为此，你只需要应用以下清单：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you open the previous manifest, you will see several rules. The following
    snippet illustrates the first one:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开之前的清单，你将看到几个规则。以下代码片段展示了第一个规则：
- en: '[PRE39]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: These rules will be added to the Prometheus instances, and the Operator will
    take care of reloading their configuration without causing any downtime of the
    service.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则将被添加到 Prometheus 实例中，Operator 会处理重新加载配置，而不会导致服务停机。
- en: 'Finally, you can access the web interface of Prometheus and Alertmanager and
    validate all the configurations you''ve made so far by issuing the following instructions,
    which will open a couple of browser tabs:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以访问 Prometheus 和 Alertmanager 的 web 界面，并通过执行以下指令验证到目前为止所做的所有配置，这将打开几个浏览器标签：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When you''re finished testing, you can delete this Kubernetes-based environment
    by issuing the following command:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 测试完成后，你可以通过执行以下命令删除这个基于 Kubernetes 的环境：
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This setup gives you a quick overview of how to integrate Alertmanager with
    Prometheus on Kubernetes. Once again, the Prometheus Operator abstracts most of
    the complexity and allows you to focus on what matters most.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置为你提供了一个快速概览，说明如何在 Kubernetes 上将 Alertmanager 集成到 Prometheus 中。再说一遍，Prometheus
    Operator 抽象了大部分复杂性，让你可以专注于最重要的部分。
- en: Common Alertmanager notification integrations
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的 Alertmanager 通知集成
- en: Users and/or organizations have different requirements regarding notification
    methods; some might be using HipChat as a means of communication, while others
    rely on email, on-call usually demands a pager system such as PagerDuty or VictorOps,
    and so on. Thankfully, Alertmanager provides several integration options out of
    the box and covers most of the notification needs you might have. If not, there's
    always the Webhook notifier, which allows integration with custom notification
    methods. Next, we'll be exploring the most common integrations and how to configure
    them, as well as providing basic examples to get you started.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 用户和/或组织对通知方式有不同的需求；有些可能使用 HipChat 作为通讯工具，而其他则依赖于电子邮件，值班通常需要使用类似 PagerDuty 或
    VictorOps 的寻呼系统，等等。幸运的是，Alertmanager 提供了多种开箱即用的集成选项，能够满足大部分的通知需求。如果没有，始终可以使用 Webhook
    通知器，它支持与自定义通知方法的集成。接下来，我们将探索最常见的集成方式以及如何配置它们，并提供基本的示例帮助你入门。
- en: Something to keep in mind when considering integrating with chat systems is
    that they're designed for humans, and the use of a ticketing system is advised
    when thinking about low-priority alerting. When the process of creating alerts
    is easy and self-service, managing them can quickly get out of control. Tickets
    ensure accountability: Some of the major advantages of using tickets over alerting
    on chat channels is that they allow tracking, prioritization, and proper follow-up
    to ensure that the alerted problem does not happen again. This method also implicitly
    ensures ownership of notifications and stops the usual *who's the owner of this
    alert?* question from arising. Ownership empowers service maintainers to curate
    the alerts they receive and, as a side effect, also helps reduce alert fatigue.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑与聊天系统集成时，需要记住的是，这些系统是为人类设计的，对于低优先级警报，建议使用工单系统。当创建警报的过程变得简单且自助时，管理警报可能很快失控。工单确保责任归属：与在聊天频道中发送警报相比，使用工单的主要优势是，它们可以跟踪、优先排序，并进行适当的跟进，以确保警报问题不再发生。这种方法还隐式确保了通知的归属，并避免了常见的
    *谁是这个警报的负责人？* 问题。归属感使服务维护人员能够筛选他们收到的警报，并且作为副作用，也有助于减少警报疲劳。
- en: If you happen to be using JIRA for task tracking, there's a custom integration
    that relies on the Webhook notifier called JIRAlert, available at [https://github.com/free/jiralert](https://github.com/free/jiralert).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 JIRA 进行任务跟踪，可以通过 Webhook 通知器实现一个名为 JIRAlert 的自定义集成，具体内容请参考 [https://github.com/free/jiralert](https://github.com/free/jiralert)。
- en: There is a configuration key that is common to all notifiers, and is called `send_resolved`.
    It takes a Boolean (true or false) and declares whether a notification should
    be sent when an alert is resolved. This is enabled by default for PagerDuty, Opsgenie,
    VictorOps, Pushover, and the Webhook integration, but disabled for the remaining
    notifiers, and is the main reason why you should prevent unnecessary spam.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 所有通知器都有一个共同的配置项，叫做 `send_resolved`。它接受一个布尔值（true 或 false），用于声明是否在警报被解决时发送通知。默认情况下，PagerDuty、Opsgenie、VictorOps、Pushover
    和 Webhook 集成启用了此选项，但其他通知器则禁用了它，这是你应该防止不必要垃圾邮件的主要原因。
- en: Email
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电子邮件
- en: 'Email is the standard communication method in most organizations, so it should
    be no surprise that it''s supported by Alertmanager. Configuration-wise, it''s
    quite straightforward to set up; however, since Alertmanager doesn''t send emails
    directly, it needs to use an actual email relay. Let''s use a real-world example
    that should be helpful for quick tests and low-budget setups, which is using the
    SMTP of an email provider (in this case, Google''s Gmail):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件是大多数组织的标准通讯方式，因此 Alertmanager 支持电子邮件也就不足为奇了。在配置方面，设置相当简单；然而，由于 Alertmanager
    本身并不直接发送电子邮件，它需要使用一个实际的电子邮件中继。我们以一个现实世界的例子为例，适用于快速测试和低预算设置，这就是使用一个电子邮件提供商（在此例中是
    Google 的 Gmail）提供的 SMTP 服务：
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this particular example, since it's a bad idea in terms of online security
    to use your main Gmail password directly, you'll need an account with two-factor
    authentication enabled, and then generate an app password to use in the `smtp_auth_password`
    field.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的示例中，由于直接使用你的主 Gmail 密码在网络安全方面不太安全，你需要一个启用了双因素认证的账户，并生成一个应用密码来使用 `smtp_auth_password`
    字段。
- en: You can find out how to generate app passwords for a Gmail account on the *Sign
    in using App Passwords* support page, located at [https://support.google.com/accounts/answer/185833](https://support.google.com/accounts/answer/185833).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *使用应用密码登录* 支持页面找到如何为 Gmail 帐号生成应用密码，页面地址是 [https://support.google.com/accounts/answer/185833](https://support.google.com/accounts/answer/185833)。
- en: Chat
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聊天
- en: 'At the time of writing, there are integrations for three chat services: Slack,
    WeChat, and HipChat. The following example represents the configuration for the
    Slack integration; later in this chapter, we''ll provide a more in-depth customization
    overview for this kind of integration:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写时，有三种聊天服务的集成：Slack、WeChat 和 HipChat。以下示例表示 Slack 集成的配置；本章稍后我们将提供更多关于这种集成的定制化概述：
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `slack_api_url` should point to a *Slack Incoming Webhooks* URL. You can
    find out more by going to their documentation about this subject at [https://api.slack.com/incoming-webhooks](https://api.slack.com/incoming-webhooks).
    Since `slack_configs` is a list, you can specify multiple channels on a single
    receiver.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`slack_api_url` 应指向 *Slack Incoming Webhooks* 的 URL。你可以通过访问他们的文档了解更多内容，网址是
    [https://api.slack.com/incoming-webhooks](https://api.slack.com/incoming-webhooks)。由于
    `slack_configs` 是一个列表，你可以在单个接收器中指定多个频道。'
- en: Pager
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 呼叫器
- en: 'Being on-call is generally synonymous with carrying a pager, physical or otherwise.
    Alertmanager, at the time of writing, supports four pager-style service integrations:
    PagerDuty, Opsgenie, VictorOps, and Pushover. The configuration for each of these
    services is fairly simple to get started, as they mostly revolve around API URLs
    and authentication tokens. However, they also support deeper levels of customization,
    such as adding images, and links, and configuring service-specific fields, such
    as severity. These advanced configuration options are described in Alertmanager''s
    official documentation, so they won''t be replicated here. The following example
    demonstrates a basic configuration for PagerDuty:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 值班通常意味着携带一个呼叫器，无论是物理的还是虚拟的。在撰写时，Alertmanager 支持四种呼叫器样式的服务集成：PagerDuty、Opsgenie、VictorOps
    和 Pushover。这些服务的配置相对简单，主要涉及 API URL 和身份验证令牌。然而，它们也支持更深层次的定制，比如添加图片、链接以及配置服务特定的字段，如严重性。这些高级配置选项已在
    Alertmanager 的官方文档中描述，因此这里不再赘述。以下示例展示了 PagerDuty 的基本配置：
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Just like in the previous notifier, since the `pagerduty_configs` configuration
    is a list, you can trigger multiple service routes in a single receiver. You can
    find out more about PagerDuty''s integration with Alertmanager here: [https://www.pagerduty.com/docs/guides/prometheus-integration-guide/](https://www.pagerduty.com/docs/guides/prometheus-integration-guide/).'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的通知器类似，由于 `pagerduty_configs` 配置是一个列表，你可以在单个接收器中触发多个服务路由。你可以在这里了解更多有关 PagerDuty
    与 Alertmanager 集成的内容：[https://www.pagerduty.com/docs/guides/prometheus-integration-guide/](https://www.pagerduty.com/docs/guides/prometheus-integration-guide/)。
- en: Webhook
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Webhook
- en: The Webhook integration opens up a world of possibilities for custom integrations.
    This feature allows Alertmanager to issue an HTTP POST request with the JSON payload
    of the notification to an endpoint of your choosing. Keep in mind that the URL
    is not templateable and the destination endpoint must be designed to handle the
    JSON payload. It can be used, for example, to push all notifications into a logging
    system such as Elasticsearch so that you can perform reporting and statistical
    analysis of the alert being generated. If your team uses IRC, this could also
    be a solution to integrate with it. One last example is the alertdump tool we've
    created for this book. It was previously used in [Chapter 9](9aa1e3da-13cf-4051-845d-1d1c924ef47b.xhtml),
    *Defining Alerting and Recording Rules*, to show what Prometheus sends out when
    alerting rules trigger, but it can also be used to demonstrate the notification
    payloads being sent by Alertmanager.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Webhook 集成为自定义集成提供了广阔的可能性。此功能允许 Alertmanager 发出带有通知 JSON 负载的 HTTP POST 请求到你选择的端点。请记住，URL
    不能被模板化，且目标端点必须设计为处理 JSON 负载。例如，它可以用于将所有通知推送到日志系统（如 Elasticsearch），以便你进行报告和统计分析。如果你的团队使用
    IRC，这也可以是与其集成的解决方案。另一个示例是我们为本书创建的 alertdump 工具。它以前在 [第9章](9aa1e3da-13cf-4051-845d-1d1c924ef47b.xhtml)中，*定义警报和记录规则*，用于展示
    Prometheus 在触发警报规则时发送的内容，但它也可以用来展示 Alertmanager 发送的通知负载。
- en: 'A simple configuration can be seen in the following code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在以下代码中看到一个简单的配置：
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This configuration will send every alert that's received by Alertmanager as-is
    to alertdump, which in turn will then append the payload to a log file named after
    the host that alertdump is running on. This log file is located in a path that's
    accessible both inside each virtual machine from our test environment (`/vagrant/cache/alertmanager*.log`),
    and outside it (`./cache/alertmanager*.log`, relative to the repository root).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 该配置会将 Alertmanager 接收到的每个警报原封不动地发送到 alertdump，后者会将有效负载追加到以 alertdump 运行所在主机命名的日志文件中。该日志文件位于一个路径中，该路径在我们测试环境中的每个虚拟机内均可访问（`/vagrant/cache/alertmanager*.log`），同时在外部（相对于仓库根目录的
    `./cache/alertmanager*.log`）也可访问。
- en: 'null'
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'null'
- en: 'This is not a notifier per se, but a pattern commonly used to drop notifications.
    The way it''s configured is by specifying a receiver without a notifier, which
    causes the notification to be dropped. The following example ensures that no notification
    will ever be sent:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这本身不是一个通知器，而是一个常用的模式，用于丢弃通知。其配置方式是指定一个接收者而不指定通知器，这样就会导致通知被丢弃。以下示例确保永远不会发送任何通知：
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is sometimes useful for demonstrative purposes, but not much else; alerts
    that aren't supposed to trigger notifications should be dropped at their source
    and not in Alertmanager, with the exception of alerts being used as source for
    inhibitions.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这有时对于演示目的很有用，但除此之外并无太多作用；不应触发通知的警报应该在源头被丢弃，而不是在 Alertmanager 中丢弃，唯一的例外是用作禁止的源头的警报。
- en: Something to always keep an eye on is the `alertmanager_notifications_failed_total`
    Alertmanager metric, as it tracks all the failed attempts to deliver notifications
    per integration.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 始终需要关注的是 `alertmanager_notifications_failed_total` 这个 Alertmanager 指标，因为它跟踪每个集成的通知发送失败次数。
- en: Now that we know the basics of Alertmanager notifiers, we can proceed to learn
    how to customize alert notifications so that the most important information is
    properly surfaced.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了 Alertmanager 通知器的基本知识，接下来可以学习如何自定义告警通知，以便将最重要的信息适当呈现。
- en: Customizing your alert notifications
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义你的警报通知
- en: For each of the available integrations, Alertmanager already includes built-in
    templates for their notifications. However, these can be tailored to the specific
    needs of the user and/or organization. Similar to the alerting rule annotations
    we explored in [Chapter 9](9aa1e3da-13cf-4051-845d-1d1c924ef47b.xhtml), *Defining
    Alerting and Recording Rules*, alert notifications are templated using the Go
    templating language. Let's use the Slack integration as an example and understand
    how the messages are constructed so that they are tailored to your needs.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个可用的集成，Alertmanager 已经包含了内置的通知模板。然而，这些模板可以根据用户和/或组织的具体需求进行定制。类似于我们在[第9章](9aa1e3da-13cf-4051-845d-1d1c924ef47b.xhtml)《定义告警和记录规则》中探讨的告警规则注解，告警通知使用
    Go 模板语言进行模板化。我们以 Slack 集成为例，了解消息是如何构建的，以便根据你的需求进行定制。
- en: Default message format
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认消息格式
- en: 'To have an idea of what a notification without any customization looks like,
    we''re going to use a very simple example. Take the following alerting rule, which
    we defined in our Prometheus instance:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解没有任何自定义的通知是什么样子，我们将使用一个非常简单的示例。以我们在 Prometheus 实例中定义的以下告警规则为例：
- en: '[PRE47]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As soon as this alert starts firing, an alert payload will be sent to Alertmanager.
    The following snippet demonstrates the payload being sent. Note the labels that
    are present, which include the `alertname` and the `external_labels` from the
    Prometheus instance:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦此警报开始触发，警报有效负载将被发送到 Alertmanager。以下代码片段演示了有效负载的发送。注意其中的标签，包括来自 Prometheus
    实例的 `alertname` 和 `external_labels`：
- en: '[PRE48]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'On the Alertmanager side, we will have this minimal configuration, just so
    that we can send a Slack notification (substituting `TOKEN` with an actual Slack
    token):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Alertmanager 端，我们将有这个最小化配置，确保能够发送 Slack 通知（将 `TOKEN` 替换为实际的 Slack token）：
- en: '[PRE49]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The end result would be a Slack message like the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果会是一个类似于以下的 Slack 消息：
- en: '![](img/6e072e2e-499d-4e06-a92c-52073b206923.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e072e2e-499d-4e06-a92c-52073b206923.png)'
- en: 'Figure 11.9: Slack default notification format'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9：Slack 默认通知格式
- en: 'As we can see, the default notification format has a lot of information in
    it. But the question remains, *how was this generated*? To answer this question,
    we can have a look into the runtime configuration of the `default` receiver that
    was generated from our basic Alertmanager configuration, which the following snippet
    illustrates:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，默认的通知格式包含了大量信息。但问题仍然存在，*这到底是如何生成的*？为了回答这个问题，我们可以查看由我们基础的 Alertmanager
    配置生成的 `default` 接收器的运行时配置，以下片段展示了这一点：
- en: '[PRE50]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The Alertmanager runtime configuration can be inspected by using `amtool config`
    or by accessing the `/#/status` endpoint of an Alertmanager web interface.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用`amtool config`或访问 Alertmanager Web 界面的`/#/status`端点来检查 Alertmanager 的运行时配置。
- en: As we can see, each of the customizable fields is configured using Go templating.
    We will take the `username` field to exemplify how the username in the Slack message
    gets generated, as it's a fairly straightforward template. All other templates
    being used follow the same logic, with varying levels of complexity.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，每个可自定义的字段都是使用 Go 模板配置的。我们将以`username`字段为例，说明 Slack 消息中的用户名是如何生成的，因为这是一个相当简单的模板。所有其他使用的模板都遵循相同的逻辑，复杂度有所不同。
- en: 'The default templates used by Alertmanager can''t be consulted locally on the
    test environment instances, as they are compiled and shipped within the Alertmanager
    binary. However, we can consult all the default templates for all the notification
    integrations provided by Alertmanager by looking at the `templates/default.tmpl`
    file in the Alertmanager code base. At the time of writing, the current version
    is 0.16.2 so, for convenience, we''re linking to the referenced file here: [https://github.com/prometheus/alertmanager/blob/v0.16.2/template/default.tmpl](https://github.com/prometheus/alertmanager/blob/v0.16.2/template/default.tmpl).'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Alertmanager 使用的默认模板无法在测试环境实例中本地查看，因为它们已经被编译并包含在 Alertmanager 的二进制文件中。不过，我们可以通过查看
    Alertmanager 代码库中的 `templates/default.tmpl` 文件来查阅所有默认的通知集成模板。本文撰写时，当前版本是 0.16.2，因此，为了方便起见，我们在此提供了链接：[https://github.com/prometheus/alertmanager/blob/v0.16.2/template/default.tmpl](https://github.com/prometheus/alertmanager/blob/v0.16.2/template/default.tmpl)。
- en: 'If we have a look at the `default.tmpl` file, we will find the definition of
    the `slack.default.username` template:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `default.tmpl` 文件，我们将找到 `slack.default.username` 模板的定义：
- en: '[PRE51]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As we can see, the template uses another template as its definition. So, if
    we look for the definition of the `__alertmanager` template, we''ll find the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，该模板使用了另一个模板作为其定义。因此，如果我们查找 `__alertmanager` 模板的定义，我们会发现以下内容：
- en: '[PRE52]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, you understand how the name `AlertManager` appears in the Slack notification.
    The tracing of each of the other templates is left as an exercise for you. In
    the next section, we're going to learn how to create our own templates, and then
    use them to customize our alert notifications.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你明白了 `AlertManager` 是如何出现在 Slack 通知中的。其余各个模板的追踪任务留给你作为练习。在下一部分中，我们将学习如何创建自己的模板，并将它们用于自定义我们的警报通知。
- en: Creating a new template
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新模板
- en: 'Before we dive into creating a template, we must first realize what kind of
    data structures are sent to the notification templates. The following table depicts
    the available variables that can be used:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入创建模板之前，我们首先需要了解发送到通知模板的数据结构。下表显示了可以使用的变量：
- en: '| **Variable** | **Description** |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| **变量** | **描述** |'
- en: '| `Alerts` | A list of Alert structures, each one with its own Status, Labels,
    Annotations, StartsAt, EndsAt, and GeneratorURL |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `Alerts` | 一个警报结构列表，每个警报都有其自己的状态、标签、注解、StartsAt、EndsAt 和 GeneratorURL |'
- en: '| `CommonAnnotations` | The annotations that are common to all alerts |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `CommonAnnotations` | 所有警报共有的注解 |'
- en: '| `CommonLabels` | The labels that are common to all alerts |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `CommonLabels` | 所有警报共有的标签 |'
- en: '| `ExternalURL` | The URL for the Alertmanager that sent the alert |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `ExternalURL` | 发送警报的 Alertmanager 的 URL |'
- en: '| `GroupLabels` | The labels that are used in the grouping of alerts |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `GroupLabels` | 用于警报分组的标签 |'
- en: '| `receiver` | The receiver that will handle the notification |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `receiver` | 将处理通知的接收器 |'
- en: '| `status` | This will be firing as long as there''s an alert in that state,
    or it will become resolved |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `status` | 只要警报处于该状态，就会触发该变量，或者当警报解决时，它会变为已解决 |'
- en: A comprehensive reference of all available data structures and functions is
    available at [https://prometheus.io/docs/alerting/notifications/](https://prometheus.io/docs/alerting/notifications/).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可用的数据结构和函数的全面参考可以在[https://prometheus.io/docs/alerting/notifications/](https://prometheus.io/docs/alerting/notifications/)找到。
- en: The best way to demonstrate how we can build a template is to provide an example.
    We've built the following template, which is available in the test environment,
    exactly with that intent. We will explain each part in detail while stripping
    the Alertmanager configurations down to only the important bits.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 演示如何构建模板的最佳方法是提供一个示例。我们构建了以下模板，它已经在测试环境中准备好，目的正是如此。我们将在详细讲解每一部分的同时，将Alertmanager配置精简为只包含重要的部分。
- en: 'The end result we aim to create can be seen in the following screenshot:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望创建的最终结果可以在以下截图中看到：
- en: '![](img/23660965-21b3-44b9-a32c-eddadb0dd050.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23660965-21b3-44b9-a32c-eddadb0dd050.png)'
- en: 'Figure 11.10: Example Slack notification template'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10：示例Slack通知模板
- en: 'Now, we''re going to dissect the example configuration, which will generate
    notifications that look like the ones shown in the preceding screenshot:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将解析示例配置，该配置将生成类似于前面截图所示的通知：
- en: '[PRE53]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'For the sake of this example, we''re grouping alerts by `alertname` and `job`.
    This is important, because it will influence the `CommonAnnotations` and `CommonLabels`,
    as we''ll see soon:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这个示例的考虑，我们将警报按`alertname`和`job`进行分组。这一点很重要，因为它将影响`CommonAnnotations`和`CommonLabels`，正如我们稍后会看到的那样：
- en: '[PRE54]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'As we saw in the previous table, `.Alerts` is a list of all the alerts, so
    we want the length (`len`) of that list to create a title for the message, starting
    with the number of firing alerts. Note the `if` clause, which ensures the use
    of plurals if there is more than one alert. Finally, since we''re grouping the
    alerts by `alertname`, we print the `alertname` after the square brackets:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的表格中看到的，`.Alerts` 是所有警报的列表，因此我们希望获取该列表的长度（`len`）来为消息创建一个标题，从触发的警报数量开始。注意`if`语句，它确保在有多个警报时使用复数形式。最后，由于我们按`alertname`分组警报，我们会在方括号后面打印`alertname`：
- en: '[PRE55]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: For the message body, we want to generate a link to the troubleshooting guide
    for this particular kind of alert. Our alerts are sending an annotation called
    `troubleshooting` with a base URL. If we rely on convention so that the guide
    name matches the alertname, we can easily generate the link using both fields.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对于消息正文，我们希望生成一个指向此类警报故障排除指南的链接。我们的警报发送了一个名为`troubleshooting`的注解，包含一个基本URL。如果我们遵循惯例，使得指南名称与警报名称匹配，我们就可以使用这两个字段轻松生成链接。
- en: 'To provide more context about the firing alerts, we''ll add all the available
    alert labels to the message. To achieve this goal, we must go through every alert
    in the list:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供更多关于触发警报的上下文，我们将把所有可用的警报标签添加到消息中。为了实现这个目标，我们必须遍历列表中的每个警报：
- en: '[PRE56]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'For every alert, we''ll print the description that''s available as an annotation
    of that alert:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个警报，我们将打印该警报可用的描述，它作为该警报的注解存在：
- en: '[PRE57]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We''ll print each alert label/value pair as well. To do that, we''ll be ranging
    over the result of `SortedPairs`, which returns a sorted list of label/value pairs:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将打印每个警报的标签/值对。为此，我们将遍历`SortedPairs`的结果，它返回一个排序后的标签/值对列表：
- en: '[PRE58]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `{{-` code trims all trailing whitespace from the preceding text. More information
    on this is available at [https://tip.golang.org/pkg/text/template/#hdr-Text_and_spaces](https://tip.golang.org/pkg/text/template/#hdr-Text_and_spaces).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`{{-` 代码会修剪掉前面的文本中的所有尾随空格。更多信息可以参见[https://tip.golang.org/pkg/text/template/#hdr-Text_and_spaces](https://tip.golang.org/pkg/text/template/#hdr-Text_and_spaces)。'
- en: 'We''re using the severity label as a routing key in order to choose the notifier
    (pager, email, or slack), so we don''t want to expose it in the alert message.
    We can do that by adding an `if` clause so that we don''t print that particular
    label/value:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将严重性标签用作路由键，以选择通知器（呼叫器、电子邮件或Slack），因此我们不希望在警报消息中暴露它。我们可以通过添加`if`语句来实现这一点，从而避免打印该特定标签/值：
- en: '[PRE59]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And that''s it. You can even make this more manageable by getting this template
    out of the Alertmanager configuration and into its own template file. We''ve done
    this in the test environment, where the receiver configuration is just the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。你甚至可以通过将此模板从Alertmanager配置中提取出来并放入自己的模板文件中，使其更加易于管理。我们在测试环境中已经这么做了，其中接收器配置仅如下所示：
- en: '[PRE60]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'All the template definitions are available in the Alertmanager instances at
    the following path:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模板定义都可以在Alertmanager实例中的以下路径找到：
- en: '[PRE61]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Notification templating is quite hard to understand and build at first. Luckily,
    a tool was created by Julius Volz, one of Prometheus' co-founders and core maintainer,
    that allows you to quickly iterate on Slack notification templates. It's by far
    the best way to understand how they work and how to generate them. You can find
    it at [https://juliusv.com/promslack/](https://juliusv.com/promslack/).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 通知模板化一开始是相当难以理解和构建的。幸运的是，Prometheus的联合创始人之一和核心维护者Julius Volz创建了一个工具，可以帮助你快速迭代Slack通知模板。这是理解它们如何工作及如何生成它们的最佳方式。你可以在[https://juliusv.com/promslack/](https://juliusv.com/promslack/)找到它。
- en: Who watches the Watchmen?
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谁来监视监视者？
- en: The monitoring system is a critical component of any infrastructure. We rely
    on it to keep watch over everything – from servers and network devices to services
    and applications – and expect to be notified whenever there's a problem. However,
    when the problem is on the monitoring stack itself, or even on a notification
    provider so that alerts are generated but don't reach us, how will we, as operators,
    know?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 监控系统是任何基础设施的关键组件。我们依赖它来监视一切——从服务器和网络设备到服务和应用程序——并期待在出现问题时收到通知。然而，当问题出现在监控堆栈本身，或者甚至是通知提供者上，导致警报被生成但未能到达我们时，作为运维人员，我们该如何得知？
- en: Guaranteeing that the monitoring stack is up and running, and that notifications
    are able to reach recipients, is a commonly overlooked task. In this section,
    we will go into what can be done to mitigate risk factors and improve overall
    confidence in the monitoring system.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 保证监控堆栈正常运行，并确保通知能够到达接收者，是一个常常被忽视的任务。在本节中，我们将深入探讨如何采取措施来减轻风险因素，并提高对监控系统的整体信任度。
- en: Meta-monitoring and cross-monitoring
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元监控与交叉监控
- en: 'In broad terms, you can''t have your monitoring system monitor itself; if the
    system suffers a serious failure, it won''t be able to send a notification about
    it. Although it is common practice to have Prometheus scrape itself (you may see
    this in most tutorials), you obviously can''t rely on it to alert on itself. This
    is where meta-monitoring comes in: it is the process by which the monitoring system
    is monitored.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 从广义上讲，你不能让监控系统监控自己；如果系统遭遇严重故障，它将无法发出相关通知。虽然让Prometheus自己抓取数据是常见做法（你可能会在大多数教程中看到），但显然不能依赖它来发出关于自己的警报。这时，元监控就派上用场了：它是指监控系统被监控的过程。
- en: 'The first option you should consider to mitigate this issue is to have a set
    of Prometheus instances that monitor every other Prometheus instance in their
    datacenter/zone. Since Prometheus generates relatively few metrics of its own,
    this would translate to a fairly light scrape job for the ones doing the meta-monitoring;
    they wouldn''t even need to be solely dedicated to this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该考虑的第一个选项来缓解这个问题，是拥有一组Prometheus实例，监控它们数据中心/区域中的所有其他Prometheus实例。由于Prometheus自身生成的指标相对较少，这将转化为一个相当轻量的抓取任务，进行元监控的实例甚至不需要专门致力于此：
- en: '![](img/7181b1e2-83d3-45f8-a939-c1c4c3096af1.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7181b1e2-83d3-45f8-a939-c1c4c3096af1.png)'
- en: 'Figure 11.11: Meta-monitoring – Prometheus group monitoring every other group'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11：元监控——Prometheus组互相监控
- en: However, you may be wondering how this set of instances would be monitored.
    We could keep adding progressively higher-level instances to do meta-monitoring
    in a hierarchical fashion – at the datacenter level, then at the regional level,
    then at the global level – but we would still be left with a set of servers that
    aren't being monitored.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能会想知道，这些实例该如何被监控。我们可以不断添加更高层次的实例，以分层方式进行元监控——先在数据中心级别，再在区域级别，最后在全球级别——但我们仍然会面临一组没有被监控的服务器。
- en: 'A complementary technique to mitigate this shortcoming is known as cross-monitoring.
    This method involves having Prometheus instances on the same responsibility level
    monitor as their peers. This way, every instance will have at least one other
    Prometheus watching over it and generating alerts if it fails:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 一种补充的技术来缓解这一不足被称为交叉监控。这种方法涉及让同一责任层级的Prometheus实例相互监控。这样，每个实例至少会有另一个Prometheus在监视它，并在其失败时生成警报：
- en: '![](img/8341ddba-98dc-4dff-832f-231728abb27a.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8341ddba-98dc-4dff-832f-231728abb27a.png)'
- en: 'Figure 11.12: Prometheus groups monitoring themselves'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12：Prometheus组自我监控
- en: But what happens if the problem is in the Alertmanager cluster? Or if external
    connectivity prevents notifications from reaching the notification provider? Or
    even if the notification provider itself is suffering an outage? In the next section,
    we'll provide possible solutions to these questions.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果问题出现在Alertmanager集群中会怎样？或者如果外部连接问题阻止了通知到达通知提供者呢？甚至如果通知提供者本身发生故障呢？在接下来的部分，我们将提供这些问题的可能解决方案。
- en: Dead man's switch alerts
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 死人开关警报
- en: Imagine that you have a set of Prometheus instances using an Alertmanager cluster
    for alerting. For some reason, a network partition happens between these two services.
    Even though each Prometheus instance detects that it can no longer reach any of
    the Alertmanager instances, they will have no means to send notifications.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一组Prometheus实例，使用Alertmanager集群进行警报。当某种原因导致这两个服务之间发生网络分区时，即使每个Prometheus实例都检测到它无法再连接任何Alertmanager实例，它们也没有办法发送通知。
- en: 'In this situation, no alerts about the issue will ever be sent:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，关于问题的任何警报都不会被发送：
- en: '![](img/998721d6-ecb3-4f19-b8ba-4186455fba9e.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](img/998721d6-ecb3-4f19-b8ba-4186455fba9e.png)'
- en: 'Figure 11.13: Network partition between Prometheus and Alertmanager'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13：Prometheus与Alertmanager之间的网络分区
- en: The original concept of a dead man's switch refers to a mechanism that activates
    if it stops being triggered/pressed. This concept has been adopted in the software
    world in several ways; for our purpose, we can achieve this by creating an alert
    that should always be firing – thereby constantly sending out notifications – and
    then checking if it ever stops. This way, we can exercise the full alerting path
    from Prometheus, through Alertmanager, to the notification provider, and ultimately
    to the recipient of the notifications so that we can ensure end-to-end connectivity
    and service availability. This, of course, goes against all we know about alert
    fatigue and we wouldn't want to be constantly receiving pages or emails about
    an always-firing alert. You can implement your own custom service implementing
    watchdog timers, but then you'll be in a situation where you need to monitor that
    as well. Ideally, you should leverage a third party so that you mitigate the risk
    of this service suffering from the same outage that is preventing notifications
    from going out.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 死人开关的原始概念指的是一个机制，它在停止触发/按下时会被激活。这个概念在软件世界中以多种方式得到了应用；就我们的目的而言，我们可以通过创建一个应该始终触发的警报来实现——从而持续发送通知——然后检查它是否停止触发。通过这种方式，我们可以全面测试从Prometheus、通过Alertmanager，到通知提供者，最终到达通知接收者的警报路径，以确保端到端的连接性和服务可用性。当然，这与我们了解的警报疲劳背道而驰，我们不希望一直收到关于总是触发的警报的页面或电子邮件。你可以实现自己的自定义服务，使用看门狗定时器，但那样你也需要监控这个服务。理想情况下，你应该利用第三方服务，这样可以减轻该服务遭遇与阻止通知发送的故障相同问题的风险。
- en: For this, there's a service built around the dead man's switch type of alert,
    and it's curiously named *Dead Man's Snitch* ([deadmanssnitch.com](https://deadmanssnitch.com)).
    This is a third-party provider, outside of your infrastructure, that's responsible
    for receiving your always-firing notification via email or Webhook and will, in
    turn, issue a page, Slack message, or Webhook if that notification stops being
    received for more than a configurable amount of time. This setup mitigates the
    problems we presented previously – even if the entire datacenter goes up in flames,
    you'll still be paged!
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，有一个围绕死人的开关类型警报构建的服务，名字也非常有趣，叫做*Dead Man's Snitch*（[deadmanssnitch.com](https://deadmanssnitch.com)）。这是一个第三方服务，位于你的基础设施之外，负责通过电子邮件或Webhook接收你的始终触发的通知，并在该通知停止接收超过可配置时间后，发出页面、Slack消息或Webhook。这个设置减轻了我们之前提出的问题——即使整个数据中心起火，你仍然会收到警报！
- en: The full configuration guide for integrating Dead Man's Snitch with VictorOps
    and PagerDuty can be found at [https://help.victorops.com/knowledge-base/victorops-dead-mans-snitch-integration/](https://help.victorops.com/knowledge-base/victorops-dead-mans-snitch-integration/)
    and [https://www.pagerduty.com/docs/guides/dead-mans-snitch-integration-guide/](https://www.pagerduty.com/docs/guides/dead-mans-snitch-integration-guide/),
    respectively.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Dead Man's Snitch与VictorOps和PagerDuty集成的完整配置指南可以在[https://help.victorops.com/knowledge-base/victorops-dead-mans-snitch-integration/](https://help.victorops.com/knowledge-base/victorops-dead-mans-snitch-integration/)和[https://www.pagerduty.com/docs/guides/dead-mans-snitch-integration-guide/](https://www.pagerduty.com/docs/guides/dead-mans-snitch-integration-guide/)找到。
- en: Summary
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we dived into the alerting component of the Prometheus stack,
    Alertmanager. This service was designed with availability in mind, and we had
    the opportunity to understand how it works, from generating better notifications
    to avoiding being flooded by useless ones. The notification pipeline is a very
    good starting point to grok the inner workings of Alertmanager, but we also went
    through its configuration, while providing examples to better solidify that knowledge.
    We were introduced to `amtool` and all the features it provides, such as adding,
    removing, and updating silences directly from the command line.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了 Prometheus 堆栈中的告警组件——Alertmanager。这个服务的设计考虑了高可用性，我们有机会了解它的工作原理，从生成更好的通知到避免被无用的通知淹没。通知管道是理解
    Alertmanager 内部工作原理的一个很好的起点，但我们也了解了它的配置，并通过示例更好地巩固了这些知识。我们还介绍了 `amtool` 及其提供的所有功能，如通过命令行直接添加、删除和更新静默。
- en: Alertmanager has several notification integrations available and we went through
    all of them, so you can pick and choose the ones you're interested in. Since we
    all want better notifications, we delved into how to customize the default notifications,
    using Slack as our example. A hard problem to solve is how to monitor the monitoring
    system; in this chapter, we learned how to make sure we are alerted when notifications
    aren't getting out.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Alertmanager 提供了多种通知集成方式，我们已经涵盖了所有这些方式，帮助你挑选出感兴趣的部分。既然我们都希望获得更好的通知，我们深入探讨了如何自定义默认通知，使用
    Slack 作为示例。解决的一个难题是如何监控监控系统；在本章中，我们学习了如何确保在通知未正常发送时能够及时告警。
- en: In an always-changing infrastructure, it's not trivial to keep track of what's
    running and where it's running. In the next chapter, we'll be providing more insight
    into how Prometheus tackles service discovery and automates these tasks for you.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个不断变化的基础设施中，追踪哪些服务在运行以及它们运行在哪里并非易事。在下一章中，我们将深入探讨 Prometheus 如何处理服务发现，并为你自动化这些任务。
- en: Questions
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What happens to the notifications if there's a network partition between Alertmanager
    instances in the same cluster?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在同一集群中 Alertmanager 实例之间发生网络分区，通知会发生什么？
- en: Can an alert trigger multiple receivers? What is required for that to happen?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个告警可以触发多个接收者吗？为此需要满足什么条件？
- en: What's the difference between `group_interval` and `repeat_interval`?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`group_interval` 和 `repeat_interval` 有什么区别？'
- en: What happens if an alert does not match any of the configured routes?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果告警与任何配置的路由都不匹配，会发生什么？
- en: If the notification provider you require is not supported natively by Alertmanager,
    how can you use it?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Alertmanager 原生不支持你需要的通知提供者，你该如何使用它？
- en: When writing custom notifications, how are `CommonLabels` and `CommonAnnotations`
    populated?
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编写自定义通知时，`CommonLabels` 和 `CommonAnnotations` 是如何填充的？
- en: What can you do to ensure that the full alerting path is working from end to
    end?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能做些什么来确保整个告警路径从头到尾都正常工作？
- en: Further reading
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**Official Alertmanager page**: [https://prometheus.io/docs/alerting/alertmanager/](https://prometheus.io/docs/alerting/alertmanager/)'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**官方 Alertmanager 页面**: [https://prometheus.io/docs/alerting/alertmanager/](https://prometheus.io/docs/alerting/alertmanager/)'
- en: '**Alertmanager notification guide**: [https://prometheus.io/docs/alerting/notifications/](https://prometheus.io/docs/alerting/notifications/)'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Alertmanager 通知指南**: [https://prometheus.io/docs/alerting/notifications/](https://prometheus.io/docs/alerting/notifications/)'
- en: '**Alertmanager configuration specifics**: [https://prometheus.io/docs/alerting/configuration/](https://prometheus.io/docs/alerting/configuration/)'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Alertmanager 配置细节**: [https://prometheus.io/docs/alerting/configuration/](https://prometheus.io/docs/alerting/configuration/)'
