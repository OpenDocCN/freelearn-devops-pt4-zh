<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Assessments</h1>
                </header>
            
            <article>
                


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 1, Monitoring Fundamentals</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">A consensual definition of monitoring is hard to come by because it quickly shifts from industry or even in job-specific contexts. The diversity of viewpoints, the components comprising the monitoring system, and even how the data is collected or used, are all factors that contribute to the struggle to reach a clear definition.</li>
<li class="mce-root">System administrators are interested in high resolution, low latency, high diversity data. Within this scope, the primary objective of monitoring is so that problems are discovered <span>quickly </span>and the root causes identified as soon as possible.</li>
<li class="mce-root">Low resolution, high latency, and high diversity data. </li>
<li class="mce-root">It depends on how broad you want to make the monitoring definition. Within the scope of this book, logging is not considered monitoring.</li>
<li class="mce-root">The monitoring service's location needs to be propagated to all targets. Staleness is a big drawback of this approach: if a system hasn't reported in for some time, does that mean it's having problems, or was it purposely decommissioned? Furthermore, when you manage a distributed fleet of hosts and services that push data to a central point, the risk of a thundering herd (overload due to many incoming connections at the same time) or a misconfiguration causing an unforeseen flood of data becomes much more complex and time-consuming to mitigate.</li>
<li class="mce-root">The RED method is a very good starting point, opting for rate, errors, and duration metrics.</li>
<li class="mce-root">This is a blackbox approach to monitoring and should instead rely on instrumenting said process directly or via an exporter.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 2, An Overview of the Prometheus Ecosystem</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">The main components are Prometheus, Alertmanager, Pushgateway, Native Instrumented Applications, Exporters, and Visualization solutions.</li>
<li class="mce-root">Only Prometheus and scrape targets (whether they are natively instrumented or use exporters) are essential for a Prometheus deployment. However, to have alert routing and management, you also need Alertmanager; Pushgateway is only required in very specific use cases, such as batch jobs; while Prometheus does have basic dashboarding functionality built in, Grafana can be added to the stack as the visualization option.</li>
<li class="mce-root">Not all applications are built with Prometheus-compatible instrumentation. Sometimes, no metrics at all are exposed. In these cases, we can rely on exporters.</li>
<li class="mce-root">The information should be quickly gathered and exposed in a synchronous operation.</li>
<li class="mce-root">Alerts will be sent from both sides of the partition, if possible.</li>
<li class="mce-root">The quickest option would be to use the webhook integration.</li>
<li class="mce-root">The Prometheus server comes with an expression browser and consoles.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 3, Setting Up a Test Environment</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">While the Prometheus stack can be deployed in almost every mainstream operating system, and thus, it will most certainly run in your desktop environment, it is more reproducible to use a Vagrant-based test environment for simulating machine deployments, and minikube to do the same for Kubernetes-based production environments.</li>
<li class="mce-root">The <kbd>defaults.sh</kbd> file located in the <kbd>utils</kbd> directory allows the software versions to be changed for the virtual machine-based examples.</li>
<li class="mce-root">The default subnet is <kbd>192.168.42.0/24</kbd> in all virtual machine-based examples.</li>
<li class="mce-root">The steps to get a Prometheus instance up and running are as follows:
<ol>
<li class="mce-root">Ensure that software versions match the ones recommended.</li>
<li class="mce-root">Clone the code repository <span>provided.</span></li>
<li class="mce-root">Move into the chapter directory.</li>
<li class="mce-root">Run <kbd>vagrant up</kbd>.</li>
<li class="mce-root">When finished, run <kbd>vagrant destroy -f</kbd>.</li>
</ol>
</li>
<li>That information is available in the Prometheus web interface under <kbd>/targets</kbd>.</li>
<li>Under <kbd>./cache/alerting.log</kbd>.</li>
<li>In any chapter, when you are done with the test environment, just run <kbd>vagrant destroy -f</kbd> under the said chapter's directory.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 4, Prometheus Metrics Fundamentals</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">Time series data can be defined as a sequence of numerical data points collected chronologically from the same source – usually at a fixed interval. As such, this kind of data, when represented in a graphical form, will plot the evolution of the data through time, with the <em>x</em>-axis being time and the <em>y</em>-axis the data value.</li>
<li class="mce-root">A timestamp, a value, and tags/labels.</li>
<li class="mce-root">The <strong>write-ahead log</strong> (<strong>WAL</strong>).</li>
<li class="mce-root">The default is 2h and should not be changed.</li>
<li class="mce-root">A float64 value and a timestamp with millisecond precision.</li>
<li class="mce-root">Histograms are especially useful for tracking bucketed latencies and sizes (for example, request durations or response sizes) as they can be freely aggregated across different dimensions. Another great use is to generate heatmaps (the evolution of histograms over time).<br/>
Summaries without quantiles are quite cheap to generate, collect, and store. The main reason for using summary quantiles is when accurate quantile estimation is needed, irrespective of the distribution and range of the observed events.</li>
<li class="mce-root">Cross-sectional aggregation combines multiple time series into one by aggregated dimension; longitudinal aggregation combines samples from a single time series over a time range into a single data point.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 5, Running a Prometheus Server</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">Then, <kbd>scrape_timeout</kbd> will be set to its default – 10 seconds.</li>
<li class="mce-root">Besides restarting, the configuration file can be reloaded by either sending a <kbd>SIGHUP</kbd> signal to the Prometheus process or sending an HTTP POST request to the <kbd>/-/reload</kbd> endpoint if <kbd>--web.enable-lifecycle</kbd> is used at startup.</li>
<li class="mce-root">Prometheus will look back up to five minutes by default, unless it finds a stale marker, in which case it will immediately consider the series stale.</li>
<li class="mce-root">While <kbd>relabel_configs</kbd> is used to rewrite the target list before the scrape is performed, <kbd>metric_relabel_configs</kbd> is used to rewrite labels or drop samples after the scrape has occurred.</li>
<li class="mce-root">As we're scraping through a Kubernetes service (which is similar in function to a load balancer), the scrapes will hit only a single instance of the <em>Hey</em> application at a time.</li>
<li class="mce-root">Due to the ephemeral nature of Kubernetes pods, it would be almost impossible to accurately manage the scrape targets using static configurations without additional automation.</li>
<li class="mce-root">The Prometheus Operator leverages Kubernetes Custom Resources and Custom Controllers to declare domain-specific definitions that can be used to automatically manage a Prometheus stack and its scrape jobs.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 6, Exporters and Integrations</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">The textfile collector enables the exposition of custom metrics by watching a directory for files with the <kbd>.prom</kbd> extension that contain metrics in the Prometheus exposition format.</li>
<li class="mce-root">Data is collected from the container runtime daemon and from Linux cgroups.</li>
<li class="mce-root">You can restrict the number of collectors (<kbd>--collectors</kbd>) to enable, or use the metric whitelist (<kbd>--metric-whitelist</kbd>) or blacklist (<kbd>--metric-blacklist</kbd>) flags.</li>
<li class="mce-root">When debugging probes, you can append <kbd>&amp;debug=true</kbd> to the <span>HTTP GET URL </span>to enable debug information.</li>
<li class="mce-root">We can use <kbd>mtail</kbd> or <kbd>grok_exporter</kbd> to extract metrics from the application logs.</li>
<li class="mce-root">One possible problem is the lack of high availability, making it a single point of failure. This also impacts scalability, as the only way to scale is vertically or by sharding. By using Pushgateway, Prometheus does not scrape an instance directly, which prevents having the <kbd>up</kbd> metric be a proxy for health monitoring. Additionally, and like the textfile collector from <kbd>node_exporter</kbd>, metrics need to be manually deleted from Pushgateway, via its API, or they will forever be exposed to Prometheus</li>
<li class="mce-root">In this particular case, the textfile collector from Node Exporter can be a valid solution, particularly when the life cycle of the produced metric matches the life cycle of the instance.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 7, Prometheus Query Language - PromQL</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">The comparison operators are <kbd>&lt;</kbd> (less than), <kbd>&gt;</kbd> (greater than), <kbd>==</kbd> (equals), <kbd>!=</kbd> (differs), <kbd>=&gt;</kbd> (greater than or equal to), and <kbd>&lt;=</kbd> (less than or equal to).</li>
<li class="mce-root">When the time series you want to enrich are on the right-hand side of the PromQL expression.</li>
<li class="mce-root"><kbd>topk</kbd> already sorts its results.</li>
<li class="mce-root">While the <kbd>rate()</kbd> function provides the per-second average rate of change over the specified interval by using the first and last values in the range scaled to fit the range window, the <kbd>irate()</kbd> function uses the last two values in the range for the calculation, which produces the instant rate of change.</li>
<li class="mce-root">Metrics of type info have their names ending in <kbd>_info</kbd> and are regular gauges with one possible value, <kbd>1</kbd>. This special kind of metric was designed to be a place where labels whose values might change over time are stored, such as versions (for example, exporter version, language version, and kernel version), assigned roles, or VM metadata information.</li>
<li class="mce-root">The <kbd>rate</kbd> function expects a counter, but a sum of counters is actually a gauge, as it can go down when one of the counters resets; this would translate into seemingly random spikes when graphed, because <kbd>rate</kbd> would consider any decrease a counter reset, but the total sum of the other counters would be considered a huge delta between zero and the current value.</li>
<li class="mce-root">When a CPU core is being used 100%, it uses 1 CPU second. Conversely, when it's idle, it will use 0 CPU seconds. This makes it easy to calculate the percentage of usage, as we can utilize the CPU seconds directly. A virtual machine might have more than one core, which means that it might use more than 1 CPU second per second. The following expression calculates how many CPU seconds per second each core was idling in the last 5 minutes:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">rate(node_cpu_seconds_total{job="node",mode="idle"}[5m])</pre>
<p class="mce-root" style="padding-left: 60px">A simple way to calculate the average CPU idle seconds per second for the last five minutes is to average the value for each core:</p>
<pre class="mce-root" style="padding-left: 60px">avg without (cpu, mode) (rate(node_cpu_seconds_total{job="node",mode="idle"}[5m]))</pre>
<p class="mce-root" style="padding-left: 60px">As CPU seconds used, plus CPU seconds idle, should total <kbd>1</kbd> CPU second per second per core, to get the CPU usage, we do the following:</p>
<pre class="mce-root" style="padding-left: 60px">avg without (cpu, mode) (1 - rate(node_cpu_seconds_total{job="node",mode="idle"}[5m]))</pre>
<p class="mce-root" style="padding-left: 60px">To get a percentage, we just need to multiply by <kbd>100</kbd>:</p>
<pre class="mce-root" style="padding-left: 60px">avg without (cpu, mode) (1 - rate(node_cpu_seconds_total{job="node",mode="idle"}[5m])) * 100</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 8, Troubleshooting and Validation</h1>
                </header>
            
            <article>
                
<ol>
<li>Prometheus is distributed with <kbd>promtool</kbd> which, among other functions, can check a configuration file for issues:</li>
</ol>
<pre style="padding-left: 60px"><strong>promtool check config /etc/prometheus/prometheus.yml</strong></pre>
<ol start="2">
<li>The <kbd>promtool</kbd> utility can also read metrics in the Prometheus exposition format from <kbd>stdin</kbd> and validate them according to the current Prometheus standards:</li>
</ol>
<pre style="padding-left: 60px"><strong>curl -s http://prometheus:9090/metrics | promtool check metrics</strong></pre>
<ol start="3">
<li>The <kbd>promtool</kbd> utility can be used to run instant queries against a Prometheus instance:</li>
</ol>
<pre style="padding-left: 60px"><strong>promtool query instant 'http://prometheus:9090' 'up == 1'</strong></pre>
<ol start="4">
<li>You can use <kbd>promtool</kbd> to find every label value for a given label name. One example is the following:</li>
</ol>
<pre style="padding-left: 60px"><strong>promtool query labels 'http://prometheus:9090' 'mountpoint'</strong></pre>
<ol start="5">
<li>By adding <kbd>--log.level=debug</kbd> to the start-up parameters.</li>
<li>The <kbd>/-/healthy</kbd> endpoint will tell you (or the orchestration system) whether the instance has issues and needs to be redeployed, while the <kbd>/-/ready</kbd> endpoint will tell you (or your instance's load balancer) whether it is ready to receive traffic.</li>
<li>While the Prometheus database is unlocked (for example, when no Prometheus is using that directory), you can run the <kbd>tsdb</kbd> utility to analyze a specific block of data for metric and label churn:</li>
</ol>
<pre style="padding-left: 60px"><strong>tsdb analyze /var/lib/prometheus/data 01D486GRJTNYJH1RM0F2F4Q9TR</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 9, Defining Alerting and Recording Rules</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">This type of rules can help take the load off heavy dashboards by pre-computing expensive queries, aggregate raw data into time series that can then be exported to external systems, and assist the creation of compound range vector queries.</li>
<li class="mce-root"><kbd>instance_job:latency_seconds_bucket:rate30s</kbd> needs to have at least the <kbd>instance</kbd> and <kbd>job</kbd> labels. It was calculated by applying the rate to the <kbd>latency_seconds_bucket_total</kbd> metric, using a 30-second range vector. Thus, the originating expression could probably be as follows:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>rate(latency_seconds_bucket_total[30s])</strong></pre>
<ol start="3">
<li class="mce-root">As that label changes its value, so will the identity of the alert.</li>
<li class="mce-root">An alert enters the <em>pending</em> state when it starts triggering (its expression starts returning results), but the <kbd>for</kbd> interval hasn't elapsed yet to be considered <em>firing</em>.</li>
<li class="mce-root">It would be immediate. When the <kbd>for</kbd> clause isn't specified, the alert will be considered firing as soon as its expression produces results.</li>
<li class="mce-root">The <kbd>promtool</kbd> utility has a <kbd>test</kbd> sub-command that can run unit tests for recording and alerting rules.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 10, Discovering and Creating Grafana Dashboards</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">Grafana supports automatic provisioning of data sources by reading YAML definitions from a provisioning path at startup.</li>
<li class="mce-root">Steps to import a dashboard from the Grafana gallery are as follows:
<ol>
<li class="mce-root">Choose a dashboard ID from the <a href="https://grafana.com/dashboards">grafana.com</a> gallery.</li>
<li class="mce-root">In the target Grafana instance, click on the plus sign in the main menu on the left-hand side and select <strong>Import</strong> from the sub-menu.</li>
<li class="mce-root">Paste the chosen ID in the appropriate text field.</li>
</ol>
</li>
<li class="mce-root">Variables allow a dashboard to configure placeholders that can be used in expressions and title strings, and those placeholders can be filled with values from either a static or dynamic list, which are usually presented to the dashboard user in the form of a drop-down menu. Whenever the selected value changes, Grafana will automatically update the queries in panels and title strings that use that respective variable.</li>
<li class="mce-root">In Grafana, the building block is the panel.</li>
<li class="mce-root">No, it does not. The dashboard ID will remain the same, but the iteration will be incremented.</li>
<li class="mce-root">Consoles are custom dashboards that are served directly from a Prometheus instance.</li>
<li class="mce-root">They are generated from console templates, which are written in raw HTML/CSS/JavaScript and leverage the power of the Go templating language, making them endlessly customizable. Since the templating runs inside Prometheus, it can access the TSDB directly instead of going through the HTTP API, which makes console generation amazingly quick.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 11, Understanding and Extending Alertmanager</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">In the case of a network partition, each side of the partition will send notifications for the alerts they are aware of: in a clustering failure scenario, it's better to receive duplicate notifications for an issue than to not get any at all.</li>
<li class="mce-root">By setting <kbd>continue</kbd> to <kbd>true</kbd> on a route, it will make the matching process keep going through the routing tree until the next match, thereby allowing multiple receivers to be triggered.</li>
<li class="mce-root">The <kbd>group_interval</kbd> configuration defines how long to wait for additional alerts in a given alert group (defined by <kbd>group_by</kbd>) before sending an updated notification when a new alert is received; <kbd>repeat_interval</kbd> defines how long to wait until resending notifications for a given alert group when there are no changes.</li>
<li class="mce-root">The top-level route, also known as the catch-all or fallback route, will trigger a default receiver when incoming alerts aren't matched in other sub-routes.</li>
<li class="mce-root">The webhook integration allows Alertmanager to issue an HTTP POST request with the JSON payload of the notification to a configurable endpoint. This allows you to run a bridge that can convert notifications from Alertmanager to your chosen notification provider's format, and then forward them to it.</li>
<li class="mce-root">The <kbd>CommonLabels</kbd> field is populated with the labels that are common to all alerts in the notification. The <kbd>CommonAnnotations</kbd> field does exactly the same, but for annotations.</li>
<li class="mce-root">A good approach is to use a deadman's switch alert: create an alert that is guaranteed to always be firing, and then configure Alertmanager to route that alert to a (hopefully) external system that will be responsible for letting you know whether it ever stops receiving notifications.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 12, Choosing the Right Service Discovery</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">Managing scrape targets in a highly dynamic environment becomes an arduous task without automatic discovery.</li>
<li class="mce-root">Having a set of access credentials with sufficient permissions to list all the required resources through its API.</li>
<li class="mce-root">It supports A, AAAA, and SRV DNS records.</li>
<li class="mce-root">Due to the large number of API objects available to query, the Kubernetes discovery configuration for Prometheus has the concept of <em>role</em>, which can be either <kbd>node</kbd>, <kbd>service</kbd>, <kbd>pod</kbd>, <kbd>endpoint</kbd>, or <kbd>ingress</kbd>. Each will make available their corresponding set of objects for target discovery.</li>
<li class="mce-root">The best mechanism for implementing a custom service discovery is to use file-based discovery integration to inject targets into Prometheus.</li>
<li class="mce-root">No. Prometheus will try to use filesystem watches to automatically detect when there are changes and then reload the target list, and will fall back to re-reading target files on a schedule if watches aren't available.</li>
<li class="mce-root">It's recommended to use the adapter code available in the Prometheus code repository, as it abstracts much of the boilerplate needed to implement a discovery mechanism. Additionally, if you intend to contribute your custom service discovery to the project, the adapter makes it easy to incorporate the service discovery code into the main Prometheus binary, were it to gain traction and community support.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 13, Scaling and Federating Prometheus</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">You should consider sharding when you're sure a single instance isn't enough to handle the load, and you can't run it with more resources.</li>
<li class="mce-root">Vertical sharding is used to split scrape workload according to responsibility (for example, by function or team), where each Prometheus shard scrapes different jobs. Horizontal sharding splits loads from a single scrape job into multiple Prometheus instances.</li>
<li class="mce-root">To reduce the ingestion load on a Prometheus instance, you should consider dropping unnecessary metrics through the use of <kbd>metric_relabel_configs</kbd> rules, or by increasing the scrape interval so that fewer samples are ingested in total.</li>
<li class="mce-root">Instance-level Prometheus servers should federate job-level aggregate metrics. Job-level Prometheus servers should federate datacenter-level aggregate metrics.</li>
<li class="mce-root">You might need to use metrics only available in other Prometheus instances in recording and alerting rules.</li>
<li class="mce-root">The protocol used is gRPC.</li>
<li class="mce-root">You will lose the ability to use the Thanos deduplication feature.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 14, Integrating Long-Term Storage with Prometheus</h1>
                </header>
            
            <article>
                
<ol>
<li>The main advantages of basing the remote write feature on the WAL are: it makes streaming of metrics possible, has a much smaller memory footprint, and it’s more resilient to crashes.</li>
<li>You can request Prometheus to produce a snapshot of the TSDB by using the <kbd>/api/v1/admin/tsdb/snapshot</kbd> API endpoint (only available when the <kbd>--web.enable-admin-api</kbd> flag is enabled), and then back up the snapshot.</li>
<li>You can delete time series from the TSDB by using the <kbd>/api/v1/admin/tsdb/delete_series</kbd> <span>API endpoint and then using the</span> <kbd>/api/v1/admin/tsdb/clean_tombstones</kbd> <span>to make Prometheus clean up the deleted series (these endpoints will only be available when the</span> <kbd>--web.enable-admin-api</kbd> <span>flag is enabled).</span></li>
<li>Object storage usually provides 99.999999999% durability and 99.99% availability service-level agreements, and it’s quite cheap in comparison to block storage.</li>
<li>Yes. For example, keeping the raw data is useful for zooming into short time ranges in the past.</li>
<li>Thanos store provides an API gateway between Thanos Querier and object storage.</li>
<li>Data in object storage can be inspected using the <kbd>thanos bucket</kbd> <span>sub-command, which also allows verifying, repairing, listing and inspecting storage buckets.</span></li>
</ol>


            </article>

            
        </section>
    </body></html>