<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Everything Starts with Source Control</h1>
                </header>
            
            <article>
                
<p>Source control is one of the most basic tools that is used in software development. Therefore, it is probably safe to assume that you have worked with source control before. For that reason, this chapter will contain only a brief introduction to source control and quickly move on to more advanced topics to help you to set up your source control to support DevOps practices.</p>
<p>Multiple DevOps practices rely on source control, hence, setting up your repositories to continuously deliver value to your users is a great way to get started and a prerequisite for many of the subjects in the following chapters.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>The types of source control in Azure DevOps</li>
<li>Source control systems</li>
<li>Selecting a branching and merging strategy</li>
<li>Securing source control using branch policies</li>
<li>Other tools that are available for source control</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To practice the subjects covered in this chapter, you may need an Azure DevOps organization.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Types of source control in Azure DevOps</h1>
                </header>
            
            <article>
                
<p>While there are many different source control systems in existence, they can be classified into two categories, centralized and decentralized source control, as follows:</p>
<ul>
<li>In a <strong>centralized source control</strong> system, only the server has the full history and the full set of branches that make up the repository.</li>
<li>In <strong>decentralized source control</strong>, everyone working with the repository has a full copy of the repository, all of the branches, and its history.</li>
</ul>
<p>Azure Repos, part of Azure DevOps services, offers both types of source control through TFVC and Git. The next two sections discuss both types of source control in more detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Centralized source control</h1>
                </header>
            
            <article>
                
<p>In a centralized source control system, the server is the only location where the full repository, including all of the history, is stored. When you create a local version of the content, you only receive the latest version of the code. Receiving this latest version is called <strong>checking out</strong> the repository. In addition to this latest version, your own computer only has the changes you make locally.</p>
<p>Not checking out the full history obviously saves space on your local computer. However, disk space is hardly ever an issue nowadays. Yet the downside of this is that you need to be continuously connected to the server to perform operations such as viewing the history of a file, recent commits of others, or which line in a file was last changed by who.</p>
<p>An advantage of centralized source control systems is that that they often offer options for fine-grained control over who can access which branches, directories, and even files.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decentralized source control</h1>
                </header>
            
            <article>
                
<p>With a decentralized source control system, all files, history, and branches are also stored on a server. The difference with centralized source control comes when you <strong>clone</strong> the repository, to have a local copy on your own computer.</p>
<p>Since you have a full clone of the repository, you can now view the history of a file and other branches without connecting to the server again. This obviously lessens the load on the server and allows you to continue working even when disconnected, two advantages of decentralized source control.</p>
<p>The downside is that decentralized source control can be harder to learn than centralized source control. Overall, the learning curve of decentralized source control systems is steeper. Also, access control on the level of individual directories and files is often more limited.</p>
<p><span>No matter which type of source control you are using, you must put a branching and merging strategy in place to allow developers to work on different features in parallel, while always keeping your master branch in a shippable state.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Source control systems</h1>
                </header>
            
            <article>
                
<p>There are many source control systems in use, but in this chapter, we will only be looking at the three currently most used. They are the following:</p>
<ul>
<li><strong>Team Foundation Version Control<span> </span></strong><span>(</span><strong>TFVC</strong><span>)</span></li>
<li>Git</li>
<li>Subversion</li>
</ul>
<p>Within Azure DevOps, only TVFC and Git are available. Subversion is a centralized source control system that is created by the Apache Foundation. In the upcoming subsections, <span>we'll take a look at TFVC and Git in more detail and learn how to migrate sources between them. Subversion </span>is discussed at the end of this chapter in the <em><span>Other tools for source control</span></em> section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Team Foundation Version Control</h1>
                </header>
            
            <article>
                
<p><strong>Team Foundation Version Control</strong> (<strong>TFVC</strong>) is a centralized source control system that was introduced by Microsoft in 2013, as part of <strong>Team Foundation Server</strong> (<strong>TFS</strong>), the product that has evolved to become Azure DevOps. TFVC is still supported in Azure DevOps but is not recommended for new projects. If you are not working with TFVC yet, there is no value in learning it. Now, TFVC is not recommended for new projects and Microsoft will most likely not release new features for it, but it isn't necessary to move away from it without other drivers.</p>
<p>In Azure DevOps, there is a maximum of one TFVC repository per team project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Git</h1>
                </header>
            
            <article>
                
<p>Next to TFVC, Azure DevOps also supports hosting Git repositories. Git is a form of decentralized source control that is rapidly gaining ground. Git is not specific to Azure DevOps but is a general protocol that is used by many platforms that provide source control hosting as a service. Well-known examples next to Azure DevOps are GitHub and GitLab.</p>
<p>To work with a Git repository, you must first clone it:</p>
<ol>
<li>Open Command Prompt and navigate to the directory where you want to store the repository.</li>
<li>Execute the following command and replace the example URL with the URL to your Git repository. The example URL shows how the location of a Git repository in Azure DevOps is built up:</li>
</ol>
<pre style="padding-left: 90px"><strong>git clone https://{organization}@dev.azure.com/{organization}/{teamProject}/_git/{repository}</strong></pre>
<p style="padding-left: 60px">Now, you can start working on the changes you want to make. In this example, a new file, <kbd>NewFile.txt</kbd>, was added.</p>
<ol start="3">
<li>Next, this file must be staged for commit. Staging files is done to differentiate between files you want to commit and changes you want to keep for your own:</li>
</ol>
<pre style="padding-left: 90px"><strong>git add NewFile.txt</strong></pre>
<ol start="4">
<li>After staging all of the changes you want to group into a single commit, creating the actual <kbd>commit</kbd> is done by calling the commit command and specifying a description of the changes:</li>
</ol>
<pre style="padding-left: 90px"><strong>git commit -m "Added a new file that contains an important text"</strong></pre>
<ol start="5">
<li>Finally, you can push your changes back to the central repository, the remote, by executing the following command:</li>
</ol>
<pre style="padding-left: 90px"><strong>git push</strong></pre>
<p>To make more changes, you can stage and commit changes as often as required. You can push the commits one at a time, but you can also push multiple commits at once.</p>
<p>You can also work with Git through the Visual Studio or VS Code interfaces. Here, you execute precisely the same steps, but instead, you can use a visual interface.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Large File Storage</h1>
                </header>
            
            <article>
                
<p>Git is designed and optimized for working with plain text files and tracking changes from version to version. However, you might want to store other things than just text files into source control. Examples are images or binary files that should be included with your application at runtime. While these are valid use cases, out of the box they do not work very well with Git. To fix this, <strong>Large File Storage</strong> (<strong>LFS</strong>) was introduced.</p>
<p>Git LFS allows you to store, instead of the binary files themselves, a small text file that acts as a pointer to that file. Such a file contains a hash of the file so that the client can download the file when cloning or fetching changes and update the file when you update the binary file.</p>
<p>To work with Git LFS, you must install the LFS client next to the Git client. This is a separate client that every user of the repository must download. Without this client, other users will only see the pointer files instead of the actual binary files. After installing the client, you must prepare the repository for the use of LFS. The following example commands enable the use of LFS for MP4 files:</p>
<pre><strong>git lfs install</strong><br/><strong>git lfs track "*.mp4"</strong><br/><strong>git add .gitattributes</strong></pre>
<p>From here onward, you can work with MP4 files just as any file and behind the scenes, they will be stored separate from your text file changes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Migrating between control systems</h1>
                </header>
            
            <article>
                
<p>One of the steps on the DevOps journey is the consolidation of tools. This means that, at some point, you might be asked to migrate sources from one source control system to another. This means that companies might decide to move all of their sources from GitLab or Subversion to Azure Git Repos. There are multiple options available to you to do migrations like these.</p>
<p>The most likely event is that you will receive requests to move sources to one or more Azure Git repositories. Possible sources are other Git repositories, TFVC, or Subversion. There are tools and approaches available to do such a migration while retaining the change history of the original repository.</p>
<p>If there is no procedure available or you must import sources from another system, you can also fall back on creating a new empty repository and initialize that with an existing code base. The disadvantage of this is that all history will be a lost this way.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Migrating existing Git repositories</h1>
                </header>
            
            <article>
                
<p>When it comes to migrating sources, moving to another location for hosting Git repositories is straightforward, compared to other migrations. Let's learn how to do this:</p>
<ol>
<li>First, clone the existing repository to your local computer. Please note the dot at the end—this will place the repository in your current directory:</li>
</ol>
<pre style="padding-left: 90px"><strong>git clone https://{organization}@dev.azure.com/{organization}/{teamProject}/_git/{repository} .</strong></pre>
<ol start="2">
<li>Add another remote that refers to the new, empty repository that you want to move the sources to:</li>
</ol>
<pre style="padding-left: 90px"><strong>git remote add migrationTarget https://{organization}@dev.azure.com/{organization}/{teamProject}/_git/{newRepository}</strong></pre>
<ol start="3">
<li class="mce-root"> Finally, you push the changes to this new repository. You must do this separately for every branch you want to move next to the master:</li>
</ol>
<pre style="padding-left: 90px"><strong>git push migrationTarget master</strong></pre>
<p style="padding-left: 60px">Meanwhile, other developers might have continued working with the existing repository.</p>
<ol start="4">
<li>To include those in the new repository as well, you must fetch them to your local computer from the original repository and then push them to the new repository. Again, repeat this for every branch:</li>
</ol>
<pre style="padding-left: 90px"><strong>git fetch origin master</strong><br/><strong>git push migrationTarget master</strong></pre>
<ol start="5">
<li>Repeat these last two commands until there are no developers working on the source repository anymore.</li>
<li>After a successful migration, it is often best to remove the old repository. This prevents anyone from continuing to work there by accident.</li>
</ol>
<p>The preceding steps will work for any Git-to-Git migration.</p>
<p>Now, if you specifically want to migrate to an Azure Git Repo, you can also use the import functionality that is included with Azure DevOps. To do this, follow these steps:</p>
<ol>
<li>Navigate to Git <span class="packt_screen">Repos</span> and optionally create a new Git repository first.</li>
<li>Choose to <span class="packt_screen">Import</span> an existing repository.</li>
</ol>
<ol start="3">
<li>Provide the requested information.</li>
<li>Click on <span class="packt_screen">Import</span> to start importing the repository.</li>
</ol>
<p>The following screenshot illustrates these steps:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1000 image-border" src="assets/9149b6f2-dac4-42a6-b2de-798020c9d16a.png" style="width:94.58em;height:53.33em;"/></p>
<p>The disadvantage of this approach is that you cannot keep pushing changes from the source repository to the new repository. This means that all other developers on your team must make sure that they move their changes over on their own or do not have any pending work while you migrate the repository.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Migrating from TFVC to an Azure Git repository</h1>
                </header>
            
            <article>
                
<p>For migrating from TFVC to a Git repository, you can use the same <em>import repository</em> as for moving from any Git repository to an Azure Repo. This wizard can take the history for up to 180 days when doing the import. If this is not enough and you are required to move more than 180 days' worth of history to the new repository, there are other approaches you can use but they are more involved. Links to more elaborate advice is included at the end of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Migrating from Subversion to an Azure Git repository</h1>
                </header>
            
            <article>
                
<p>A final type of request that you might receive is that of migrating from a Subversion repository to a Git repository. For this, there is no out-of-the-box solution from Microsoft available. However, Atlassian has created a tool that can be used to migrate a Subversion repository to a local Git repository while maintaining the change history.</p>
<p>After running this tool, the only thing left to do is to add a remote to a new empty, hosted repository and push all of the branches. These are the same as the steps for migrating from Git to Git, starting at the step that adds a new remote.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Migrating without retaining history</h1>
                </header>
            
            <article>
                
<p>If you are asked to do a migration without retaining history, you can just create a new, empty repository out of sources on your local computer and push existing changes there using the following commands.</p>
<p>Execute the following from the directory that contains the files that should go into the master branch:</p>
<pre><strong>git init</strong><br/><strong>git add </strong><br/><strong>git commit -m “Initial import of existing sources”</strong><br/><strong>git remote add https://{organization}@dev.azure.com/{organization}/{teamProject}/_git/{repository}</strong><br/><strong>git push</strong></pre>
<p>These commands initialize a new repository, create a first commit out of all of the files already in the directory, add a reference to the target server location, and push the newly created repository there.</p>
<p>If you want to retain multiple branches, you must repeat the following steps for every other branch:</p>
<ol>
<li>First, go to the right directory for that branch:</li>
</ol>
<pre style="padding-left: 90px"><strong>Git checkout {branchName}</strong></pre>
<ol start="2">
<li>Now, copy the files that need to go into this branch into your working directory. Then, continue with the following commands:</li>
</ol>
<pre style="padding-left: 90px"><strong>git add .</strong><br/><strong>git commit</strong><br/><strong>git push</strong></pre>
<p>This completes the migration and the latest version of the sources you had on your local computer are now available in Git. Other members of your team can now clone the repository and work with it. Next, we'll go on to learn about branching and merging.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selecting a branching and merging strategy</h1>
                </header>
            
            <article>
                
<p>Source control allows you to keep a history of all of the changes you have made to your files but also allows working separately from your team members for a while if you so desire. We call this <strong>branching</strong>. When you are branching in source control, you fork the line of changes currently registered. We call such a fork a <strong>branch</strong><em>.</em> A branch allows you to temporarily isolate some work from the rest. If you at any point want to integrate the changes from a branch with the changes on the other fork, you can <strong>merge</strong> these changes back. Branches are often used for working on not yet complete features, proofs of concept, or hotfixes. Using branches allows you to later decide which changes to include in the next version and which not to.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Branching strategies</h1>
                </header>
            
            <article>
                
<p>There are many, many branching strategies available, but the three most used nowadays are the following:</p>
<ul>
<li>GitHub flow</li>
<li>GitFlow</li>
<li>Release Flow</li>
</ul>
<p>The following subsections will discuss these in greater detail.</p>
<div class="packt_infobox"><span>As an alternative to branching, trunk-based development is becoming more popular nowadays. To know more about this, visit </span><a href="https://paulhammant.com/2013/04/05/what-is-trunk-based-development/">https://paulhammant.com/2013/04/05/what-is-trunk-based-development/</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GitHub flow</h1>
                </header>
            
            <article>
                
<p>GitHub flow is a simple, yet often sufficient, branching strategy. In GitHub flow, there is one <strong>master</strong> branch that should always be in a deployable state. No unfinished changes are allowed to go onto the master.</p>
<p>If you want to start work on a new feature or bugfix, you create a new topic branch of the master where you commit your work. Only when you are completely done with that work do you merge this branch back to the master. An example commit flow might look like this:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-248 image-border" src="assets/cb942fe3-358e-4737-9110-0ad9b6c24936.png" style="width:31.42em;height:8.17em;"/></p>
<p>As this is the branching scheme with the least branches involved, this is probably a good strategy to start with.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GitFlow</h1>
                </header>
            
            <article>
                
<p>GitFlow is another well-known elaborate branching scheme that can deal with almost any situation that might arise when working with software. GitFlow describes creating a branch, <strong>Develop</strong>, of the master whenever you start work on a new version. <strong>Develop</strong> is the integration branch where you combine new features and do integration testing. It should only contain work that you believe is ready to be released.</p>
<p>From <strong>Develop</strong>, you create one or more feature branches where you start working on new features. Only when a feature is done do you merge that branch back to the <strong>Develop</strong> branch.</p>
<p>When you want to release a new version of your application, you create a release branch of the <strong>Develop</strong> branch. On the code on this branch, you perform final testing and perform one or more bugfixes if needed. When you are satisfied with the quality of the code, you merge this branch to the master and tag the version. You also merge these bugfixes back to <strong>Develop</strong>, so they will also be incorporated in new developments. This flow is visible in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-249 image-border" src="assets/7426e312-0862-46dc-8c0d-5d42ae0e9cec.png" style="width:28.75em;height:9.42em;"/></p>
<p>If there is ever a critical bug that you need to ship as fast as possible or you want to do a hotfix, for this is also possible. In that case, you create a new branch of the master, where you fix the bug. After testing, you merge this branch to both master and developer—just as you would with a release branch.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Release Flow</h1>
                </header>
            
            <article>
                
<p><strong>Release Flow</strong> is the branching system that is used by the Azure DevOps team to develop Azure DevOps. It is also based on working with short-lived topic branches that are made from and merged to a master branch.</p>
<p>The difference is that it is not the code that is on the master branch that is being deployed to production. Instead, whenever a new version of the product needs to be released, a new branch is created of <strong>master</strong> with the name <strong>release-{version}</strong>. The code from this branch is then deployed to production. Once a new release branch is deployed, the previous one can be disregarded. This results in the following flow:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-252 image-border" src="assets/b8de65f1-3cd3-42e1-a874-26b2ed6093c9.png" style="width:28.25em;height:11.42em;"/></p>
<p>The advantage of this model is that it allows for taking a snapshot of the current state of the master branch and taking that to production. If there is ever a bug in production that needs to be fixed ahead of a new complete release then the correct commits can be merged from the master branch to the current release branch.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Trunk-based development</h1>
                </header>
            
            <article>
                
<p>In many companies, branching and merging are done to retain flexibility when releasing a new version and being able to pick changes for that version only at the last moment. This flexibility comes at the cost of having to merge or integrate your changes at some point. This cost is not only the time it takes but also the risks that a merge operation introduces. Merging the changes from two different branches that contain perfectly working software might still produce non-working code.</p>
<p>For this reason, you might consider switching to <strong>trunk-based development</strong>. In trunk-based development, you are no longer using branching for picking changes that go into a version. Instead, every developer on the team continuously works from the same branch (often the master) and only creates a short-lived branch for preparing one single change, which is then merged into the master branch.</p>
<p>When you adopt this, you will need another way to determine which changes will and won't yet be available to your users when releasing a new version of your software. You can do this by using <strong>branching by abstraction</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Branching by abstraction</h1>
                </header>
            
            <article>
                
<p>When branching by abstraction, you are not keeping two versions of your code side by side using branches, but you keep them side by side in your code base. For example, when you want to change the implementation of a class called <kbd>FoodClassifier</kbd>, which implements the <kbd>IFoodClassifier</kbd><span> </span><span>interface</span><span>, you go through the following steps:</span></p>
<ol>
<li>You refactor the name of the <kbd>FoodClassifier</kbd> class to <kbd>FoodClassifierToBeRemoved</kbd>.</li>
<li>You create a copy of the complete <kbd>FoodClassifierToBeRemoved</kbd> class.</li>
<li>You name this copy back to <kbd>FoodClassifier</kbd>.</li>
</ol>
<p style="padding-left: 60px">At this point, your changes should look like this:</p>
<pre style="padding-left: 90px">public class FoodClassifier : IFoodClassifier<br/>{<br/> public FoodClassification Classify(Food food)<br/> {<br/> // Unchanged classification algorithm<br/> } <br/>}<br/>public class FoodClassifierToBeRemoved : IFoodClassifer<br/>{<br/> public FoodClassification Classify(Food food)<br/> {<br/> // Unchanged classification algorithm<br/> } <br/>}</pre>
<p>Please note that at runtime, your application will behave just as it did before. You have just added a new, yet unused, class with a change in behavior. It is safe to commit these changes and even ship the new binaries to a user. Now you can start changing the implementation of the new <kbd>FoodClassifier</kbd> class, test it, and establish trust in its implementation. Meanwhile, you can keep committing and pushing your changes, even to customers. Switching to the new implementation can be done using your dependency injection configuration, a Boolean flag, or environment variables. Just choose what makes sense in your scenario.</p>
<p>Only when you are fully satisfied that the new implementation is working, you remove the <kbd>FoodClassifierToBeRemoved</kbd> class and update any references back to <kbd>FoodClassifier</kbd>.</p>
<p>We will expand on branching by abstraction in <a href="8ab4597a-becd-4855-9b45-89045982c14a.xhtml">Chapter 4</a>, <em>Continuous Deployment</em>, when discussing feature toggles. While being a recommended way forward to further accelerate your delivery, branching by abstraction is a double-edged sword. If you do not have a process to keep the number of side-by-side implementations under control and clean them up after switching implementations, the quality of your code base might decline.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Merging strategies</h1>
                </header>
            
            <article>
                
<p>Depending on the source control system you are working with, there might be multiple ways you can merge your changes from one branch to another.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TFVC</h1>
                </header>
            
            <article>
                
<p>When you are working with TFVC, you prepare a merge locally by choosing both a source and target branch and then picking the list of changes you want to merge. TFVC will then execute the merge and show you the changes that are the consequence of this merge as local changes. You can go over these changes, correct or change them, and must resolve any conflicts. After this, you commit the changes just as you would any regular change.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Git</h1>
                </header>
            
            <article>
                
<p>A merge using Git can be performed by switching to the target branch and then <em>merging</em> all of the changes from the source branch. If there are conflicting changes between the branches, you must resolve those just as you would when fetching new changes from the server. After merging the changes from the source branch and resolving any changes, you can commit the changes. This will result in a merge commit, which you push to the remote just as any change.</p>
<p>This can be done using the visual interface of Visual Studio or VS Code, but also using the following sequence of commands:</p>
<pre><strong>git checkout targetBranch</strong><br/><strong>git merge sourceBranch</strong></pre>
<p>If there are any conflicts, you have to resolve these at this point. Otherwise, you cannot continue:</p>
<pre><strong>git commit -m “Merged changes from sourceBranch”</strong><br/><strong>git push</strong></pre>
<p>As you will read in the <em>Securing repositories</em> section, it is possible to protect some branches by disallowing merging this way. Especially when it comes to changes to master, you might want to use another mechanism for merging changes, namely, pull requests. Using a pull request, you open a request for someone else to pull changes from your branch to the target branch. This way, another team member can first review your changes and only merge them when they meet all agreed standards. Others can comment on your changes or request updates before they perform the merge. This is the most common way of enforcing the four-eyes principle for source code when working with Git. The four-eyes principle says that every change or action should be viewed by at least two people.</p>
<p>Now, when you are approving a pull request, there are different strategies you can use for generating the merge commit. The most commonly used are a merge commit, squash commit, or a rebase.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Merge commit</h1>
                </header>
            
            <article>
                
<p>A regular <strong>merge commit</strong> is a type of commit that maintains visibility of all previous commits. It has a reference to two parents, showing both origins of the change, namely the source and target branch. This is the same type of merge as you can perform manually using a Git merge. The advantage of this type of commit is that it clearly shows where the new state of the target branch comes from.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Squash commit</h1>
                </header>
            
            <article>
                
<p>When performing a so-called <strong>squash commit</strong>, you are combining all of the individual commits from the source branch in one, new commit. This is useful when all of the commits on the source branch relate to one feature and you want to keep a clear, concise change history on the target branch. Especially when there are commits with bugfixes or clean-up operations on the source branch, this approach makes sense. The disadvantage is that you might lose the rationale for some incremental changes that were made on the source branch.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rebase</h1>
                </header>
            
            <article>
                
<p><strong>Rebasing</strong> a branch means that all of the commits for which your branch is ahead of the master branch are put aside for a bit. Meanwhile, all of the commits for which the master branch is ahead of your local branch are now merged to your local branch. Finally, all of your own commits that were set aside are now reapplied. The following diagram shows a branch before and after a rebase commit:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-909 image-border" src="assets/595b2365-971d-4d16-a572-ed58f652768b.png" style="width:35.08em;height:9.17em;"/></p>
<p>After rebasing the source branch, it is now merged into master. The advantage of this kind of merge is that you retain all individual changes in one single commit history.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing repositories</h1>
                </header>
            
            <article>
                
<p>When working in Azure Repos, every team project can have a maximum of one TFVC repository. However, when working with Git, you can have multiple repositories in the same team project. A discussion that is gaining more attention lately is that of having a single repository for all applications or a repository per application. Other topics that are important when managing repositories are creating and removing repositories, securing them, and setting policies on them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Monorepo or multi-repo</h1>
                </header>
            
            <article>
                
<p>You are using a <strong>monolithic repository</strong> (<strong>monorepo</strong>) when you are storing all of the code of all of your projects and applications in one single source control repository. Opposed to this, you might be using multiple repositories where every application, library, or project is stored in its own repository. Both approaches have their own pros and cons and both approaches are used by companies from small to large.</p>
<p>Possible advantages of a monorepo can include the following:</p>
<ul>
<li>Easier reuse of existing code: If all of the code is in a single repository, it is accessible by and visible to everyone. This means that the chances of reuse are increased.</li>
<li>Having all applications in one repository also means that any change affecting more than one application can be made in a single commit, in a single repository. A typical example is an API change.</li>
<li>With all of the code being accessible to and maintained by everyone, there is less chance that a developer or team claims a specific repository as its own. This encourages learning from each other.</li>
</ul>
<p>Possible advantages of multiple repositories include the following:</p>
<ul>
<li>A monorepo can become very, very large, even up to the point that developers checkout or clone only part of the monorepo. This effectively defeats most of the advantages of a monorepo.</li>
<li>Having one repository with all of the code encourages tight coupling between components or applications. If you have multiple repositories, you could update an API and release it under a new version and upgrade clients one by one. In a monorepo, you might be tempted to upgrade the API and change all of the consumers in one commit, with all of the risks attached.</li>
</ul>
<p>Which approach works best for you is influenced not only by the advantages and disadvantages discussed but also by the background and makeup of your team and organization. If you have a single team doing all the development for internal applications, a monorepo might make more sense. If you have multiple teams working on different applications for different clients, multiple repositories make more sense.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating and removing repositories</h1>
                </header>
            
            <article>
                
<p>In Azure DevOps, you can have multiple Git repositories per team project. Try doing the following:</p>
<ol>
<li>First, visit the <span class="packt_screen">Manage repositorie</span><span class="packt_screen">s</span> interface. The following screenshot shows how to access this interface:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1001 image-border" src="assets/de6970e8-edd4-457c-b66f-89a777610ba4.png" style="width:104.67em;height:34.42em;"/></p>
<ol start="2">
<li>After opening this interface, a new interface (as shown in the following screenshot) opens up. Here, you can add new repositories by clicking on the <span class="packt_screen">Add...</span> button with a plus sign (marked with a <strong>1</strong> in the following screenshot) and filling out a repository name.</li>
<li>Repositories can also be removed, by clicking on their name and then D<span class="packt_screen">elete</span> (marked with a <strong>2</strong>):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1002 image-border" src="assets/c987591b-c267-4c71-877b-2b3d5e69c640.png" style="width:104.67em;height:55.33em;"/></p>
<p style="padding-left: 60px">Removing repositories is not something that is often done. It might make more sense to make a no-longer-used repository read-only or remove all authorizations on it.</p>
<p>Now, let's learn how to secure the repositories that we create. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Securing repositories</h1>
                </header>
            
            <article>
                
<p>While the security options with distributed source control are often not as broad as with centralized source control, Azure Repos offers some means to set authorizations on a repository or a server-side branch. In the last image of the previous section, you can also see how you can select a group or user in the middle column and then update the authorizations on the repository. By default, all authorizations are inherited from project defaults.</p>
<div class="packt_tip">It is recommended to only change authorizations a little as possible and if you do, it is often best to work via groups and allow authorizations.</div>
<p>You can also change the authorizations for a specific branch by opening the repositories branches in the drop-down menu on the left and clicking on the branch you want to override the authorizations for. In the preceding screenshot, this is marked with a <span class="packt_screen">3</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Branch policies</h1>
                </header>
            
            <article>
                
<p>Finally, it is possible to enforce one or more policies on pull requests to a specific branch. The interface for branch policies is shown in the following screenshot and can be accessed by choosing the <span class="packt_screen">Branch policies</span> option while managing the authorizations on a repository branch:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1003 image-border" src="assets/c771726d-de8f-4b41-9154-a27ab3ed81ef.png" style="width:68.17em;height:66.25em;"/></p>
<p>The first four checkboxes are related to default policies that can be enabled (or not) on your preference. By default, they are all disabled.</p>
<p>Build validation can be used to disallow the merge of any pull request if one or more of the select builds have not completed successfully. How to set up such a build is something you will learn in the next chapter.</p>
<p>Next to builds, you can also call external services to inspect the pull request and to allow or disallow it. An often used integration here is with a code quality tool. You might also call your own APIs here, to enforce team agreements on things such as pull request titles, relation to work items, or more complex constraints.</p>
<p>Finally, you can enforce that a specific user or group has to be included in the review of a pull request. This might be needed to enforce a specific level of quality, but it can also be a limiting factor on your development speed and hence flow.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other tools for source control</h1>
                </header>
            
            <article>
                
<p>Next to the source control systems available in Azure Repos, there are also some other well-known systems that you should know about:</p>
<ul>
<li>GitHub</li>
<li>GitLab</li>
<li>Subversion</li>
</ul>
<p>We'll go over each of these in the upcoming subsections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GitHub</h1>
                </header>
            
            <article>
                
<p><strong>GitHub</strong> is a hosted source control provider that delivers hosted Git repositories. GitHub allows anyone to create as many publicly visible repositories as they want. Only, when you create private repositories that require three or more contributors, you must switch to a paid subscription.</p>
<p>This model that allows unlimited, free usage of the platform if developing in public has made GitHub, by far, the largest host of open source software in the world.</p>
<p>GitHub was acquired by Microsoft in 2018 and since then, Microsoft and GitHub have worked together to create a great integration experience between GitHub repositories and Azure DevOps, specifically with Azure Boards and Azure Pipelines. In addition to this, Microsoft has stated that GitHub and Azure Repos will continue to exist next to each other and that there are currently no plans to terminate one of the products in favor of the other.</p>
<p>There is also an on-premises offering by GitHub called GitHub Enterprise.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GitLab</h1>
                </header>
            
            <article>
                
<p>GitLab is another platform that delivers hosted Git repositories. Just like Azure DevOps, source control hosting is one of the services it provides.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Subversion</h1>
                </header>
            
            <article>
                
<p>An older source control system is Subversion. Subversion was developed and first used in 2004 and is maintained by the Apache Software Foundation. Subversion is a centralized source control system that supports all the features that you would expect of such a system.</p>
<p>There are many false arguments as to where Subversion would be inferior to Git, however, most of them are not true for more recent versions of Subversion. The reality is that Subversion is a widely used type of source control system that performs well, especially for very large repositories or repositories that have very specific authorization needs.</p>
<p>While Azure DevOps cannot host Subversion repositories, it can connect to, and work with, sources that are stored in Subversion.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you have learned about source control. We saw that there are two types of source control: centralized and decentralized, both supported by Azure DevOps. TFVC is no longer recommended for new projects. You should use Git whenever starting a new project.</p>
<p>When using Git, you can have more than one repository in your team project. Per repository, you can assign policies to lock down specific branches and enforce the four-eyes principle. You have also learned about access control and how to provide users access to one or more repositories. Finally, you have learned about alternative tools and how to migrate sources from one tool to the other.</p>
<p>You can use what you have learned to make decisions on which type of source control system to use in your products. You can now professionally organize the repository or repositories you work in. You are now able to work with different branching strategies and use policies for enforcing security or quality requirements.</p>
<p>The next chapter will take what you have learned about source control and use that to set up continuous integration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions </h1>
                </header>
            
            <article>
                
<p>As we conclude, here is a list of questions for you to test your knowledge regarding this chapter's material. You will find the answers in the <em>Assessments</em> section of the Appendix:</p>
<ol>
<li><span>What are the differences between centralized and decentralized source control and which work best in what situation?<br/></span></li>
<li>True or false: Git is an example of decentralized source control.</li>
<li>Which of the following is not a common branching strategy?<br/>
<ol>
<li>Release Flow</li>
<li>Rebasing</li>
<li>GitFlow</li>
<li>GitHub flow</li>
</ol>
</li>
</ol>
<ol start="3">
<li>Many companies want a code review to be performed before code is merged into the master branch. What construct is used to do so when working with Git and how can this be enforced in Azure DevOps?</li>
<li>Which of the following are not valid merge strategies?<br/>
<ol>
<li>Rebasing</li>
<li>Trunk-based development</li>
<li>Merge commit</li>
<li>Squash commit</li>
</ol>
</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>More information about working with Git can be found at <a href="https://docs.microsoft.com/en-us/learn/paths/intro-to-vc-git/">https://docs.microsoft.com/en-us/learn/paths/intro-to-vc-git/</a>.</li>
<li>The original Microsoft advice on TFVC versus Git can be found at <a href="https://docs.microsoft.com/en-us/azure/devops/repos/tfvc/comparison-git-tfvc?view=azure-devops&amp;viewFallbackFrom=vsts">https://docs.microsoft.com/en-us/azure/devops/repos/tfvc/comparison-git-tfvc?view=azure-devops&amp;viewFallbackFrom=vsts</a>.</li>
<li>More information about Git LFS can be found at <a href="https://docs.microsoft.com/en-us/azure/devops/repos/git/manage-large-files?view=azure-devops">https://docs.microsoft.com/en-us/azure/devops/repos/git/manage-large-files?view=azure-devops</a>.</li>
<li>Instructions for downloading Git LFS can be found at <a href="https://git-lfs.github.com/">https://git-lfs.github.com/</a>.</li>
<li>More information about migrating to Git can be found at <a href="https://docs.microsoft.com/en-us/azure/devops/repos/git/import-from-TFVC?view=azure-devops">https://docs.microsoft.com/en-us/azure/devops/repos/git/import-from-TFVC?view=azure-devops</a>.</li>
</ul>
<ul>
<li>An Atlassian tool for converting an SVN repository to a local Git repository can be found at <a href="https://www.atlassian.com/git/tutorials/migrating-convert">https://www.atlassian.com/git/tutorials/migrating-convert</a>.</li>
<li>More information about GitFlow can be found at <a href="https://datasift.github.io/gitflow/IntroducingGitFlow.html">https://datasift.github.io/gitflow/IntroducingGitFlow.html</a>.</li>
<li>More information about GitHub flow can be found at <a href="https://guides.github.com/introduction/flow/">https://guides.github.com/introduction/flow/</a>.</li>
<li>Release Flow is described in more detail at <a href="https://docs.microsoft.com/en-us/azure/devops/learn/devops-at-microsoft/release-flow">https://docs.microsoft.com/en-us/azure/devops/learn/devops-at-microsoft/release-flow</a>.</li>
<li>Trunk-based development is discussed at <a href="https://trunkbaseddevelopment.com/">https://trunkbaseddevelopment.com/</a>.</li>
<li>More information about GitLab can be found at <a href="https://about.gitlab.com/">https://about.gitlab.com/</a>.</li>
<li>More information about Subversion can be found at <a href="https://subversion.apache.org/docs/">https://subversion.apache.org/docs/</a>.</li>
</ul>


            </article>

            
        </section>
    </body></html>