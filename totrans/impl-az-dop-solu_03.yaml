- en: Everything Starts with Source Control
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一切从源代码管理开始
- en: Source control is one of the most basic tools that is used in software development.
    Therefore, it is probably safe to assume that you have worked with source control
    before. For that reason, this chapter will contain only a brief introduction to
    source control and quickly move on to more advanced topics to help you to set
    up your source control to support DevOps practices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码管理是软件开发中最基本的工具之一。因此，可以合理假设你之前已经使用过源代码管理。基于这一点，本章将仅简要介绍源代码管理，并迅速过渡到更高级的话题，帮助你设置源代码管理以支持
    DevOps 实践。
- en: Multiple DevOps practices rely on source control, hence, setting up your repositories
    to continuously deliver value to your users is a great way to get started and
    a prerequisite for many of the subjects in the following chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 多种 DevOps 实践依赖于源代码管理，因此，设置你的代码库以持续为用户提供价值是一个很好的起点，也是接下来章节中许多主题的前提条件。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The types of source control in Azure DevOps
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure DevOps 中的源代码管理类型
- en: Source control systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码管理系统
- en: Selecting a branching and merging strategy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择分支和合并策略
- en: Securing source control using branch policies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分支策略确保源代码管理的安全性
- en: Other tools that are available for source control
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用于源代码管理的其他工具
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To practice the subjects covered in this chapter, you may need an Azure DevOps
    organization.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要实践本章涉及的内容，你可能需要一个 Azure DevOps 组织。
- en: Types of source control in Azure DevOps
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure DevOps 中的源代码管理类型
- en: 'While there are many different source control systems in existence, they can
    be classified into two categories, centralized and decentralized source control,
    as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然存在许多不同的源代码管理系统，但它们可以分为两类：集中式和去中心化源代码管理，具体如下：
- en: In a **centralized source control** system, only the server has the full history
    and the full set of branches that make up the repository.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**集中式源代码管理**系统中，只有服务器拥有完整的历史记录和组成代码库的所有分支。
- en: In **decentralized source control**, everyone working with the repository has
    a full copy of the repository, all of the branches, and its history.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**去中心化源代码管理**中，所有与代码库一起工作的人员都拥有该代码库的完整副本，包括所有分支和历史记录。
- en: Azure Repos, part of Azure DevOps services, offers both types of source control
    through TFVC and Git. The next two sections discuss both types of source control
    in more detail.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Repos 是 Azure DevOps 服务的一部分，通过 TFVC 和 Git 提供两种类型的源代码管理。接下来的两个部分将更详细地讨论这两种源代码管理。
- en: Centralized source control
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集中式源代码管理
- en: In a centralized source control system, the server is the only location where
    the full repository, including all of the history, is stored. When you create
    a local version of the content, you only receive the latest version of the code.
    Receiving this latest version is called **checking out** the repository. In addition
    to this latest version, your own computer only has the changes you make locally.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在集中式源代码管理系统中，服务器是唯一存储完整代码库（包括所有历史记录）的地方。当你创建内容的本地版本时，你只会接收到代码的最新版本。接收这个最新版本被称为**检出**代码库。除了这个最新版本，你自己的计算机只会有你本地所做的更改。
- en: Not checking out the full history obviously saves space on your local computer.
    However, disk space is hardly ever an issue nowadays. Yet the downside of this
    is that you need to be continuously connected to the server to perform operations
    such as viewing the history of a file, recent commits of others, or which line
    in a file was last changed by who.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，不检出完整的历史记录可以节省本地计算机的存储空间。然而，如今磁盘空间几乎不再是问题。其缺点是，你需要持续连接到服务器才能执行查看文件历史记录、他人最近提交或某文件的某一行最后由谁修改等操作。
- en: An advantage of centralized source control systems is that that they often offer
    options for fine-grained control over who can access which branches, directories,
    and even files.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 集中式源代码管理系统的一个优点是，它们通常提供对谁可以访问哪些分支、目录甚至文件的精细化控制选项。
- en: Decentralized source control
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 去中心化源代码管理
- en: With a decentralized source control system, all files, history, and branches
    are also stored on a server. The difference with centralized source control comes
    when you **clone** the repository, to have a local copy on your own computer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用去中心化源代码管理系统时，所有文件、历史记录和分支也存储在服务器上。与集中式源代码管理的区别在于，当你**克隆**代码库时，你会在自己的计算机上获得一个本地副本。
- en: Since you have a full clone of the repository, you can now view the history
    of a file and other branches without connecting to the server again. This obviously
    lessens the load on the server and allows you to continue working even when disconnected,
    two advantages of decentralized source control.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你有该仓库的完整克隆，现在可以查看文件的历史记录和其他分支，而无需再次连接到服务器。这显然减轻了服务器的负担，并且即使在断开连接时也能继续工作，这是去中心化源代码管理的两个优点。
- en: The downside is that decentralized source control can be harder to learn than
    centralized source control. Overall, the learning curve of decentralized source
    control systems is steeper. Also, access control on the level of individual directories
    and files is often more limited.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是，去中心化的源代码管理可能比集中式源代码管理更难学习。总体来说，去中心化源代码管理系统的学习曲线更陡峭。此外，单个目录和文件的访问控制通常更为有限。
- en: No matter which type of source control you are using, you must put a branching
    and merging strategy in place to allow developers to work on different features
    in parallel, while always keeping your master branch in a shippable state.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用哪种类型的源代码管理，都必须制定一个分支和合并策略，以便开发者能够并行开发不同的功能，同时始终保持主分支处于可发布状态。
- en: Source control systems
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码管理系统
- en: 'There are many source control systems in use, but in this chapter, we will
    only be looking at the three currently most used. They are the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多源代码管理系统在使用，但在本章中，我们只会查看当前使用最广泛的三种系统。它们如下：
- en: '**Team Foundation Version Control **(**TFVC**)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队基础版本控制** (**TFVC**)'
- en: Git
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: Subversion
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Subversion
- en: Within Azure DevOps, only TVFC and Git are available. Subversion is a centralized
    source control system that is created by the Apache Foundation. In the upcoming
    subsections, we'll take a look at TFVC and Git in more detail and learn how to
    migrate sources between them. Subversion is discussed at the end of this chapter
    in the *Other tools for source control* section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure DevOps 中，仅支持 TVFC 和 Git。Subversion 是一个由 Apache 基金会创建的集中式源代码管理系统。在接下来的小节中，我们将更详细地了解
    TFVC 和 Git，并学习如何在它们之间迁移源代码。Subversion 在本章最后的*其他源代码管理工具*部分中讨论。
- en: Team Foundation Version Control
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 团队基础版本控制
- en: '**Team Foundation Version Control** (**TFVC**) is a centralized source control
    system that was introduced by Microsoft in 2013, as part of **Team Foundation
    Server** (**TFS**), the product that has evolved to become Azure DevOps. TFVC
    is still supported in Azure DevOps but is not recommended for new projects. If
    you are not working with TFVC yet, there is no value in learning it. Now, TFVC
    is not recommended for new projects and Microsoft will most likely not release
    new features for it, but it isn''t necessary to move away from it without other
    drivers.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**团队基础版本控制** (**TFVC**) 是一个由微软在2013年推出的集中式源代码管理系统，作为**团队基础服务器** (**TFS**)的一部分，TFS
    后来发展成了 Azure DevOps。TFVC 仍然在 Azure DevOps 中得到支持，但不推荐用于新项目。如果你还没有使用 TFVC，学习它没有什么价值。现在，TFVC
    不推荐用于新项目，微软很可能不会为其发布新特性，但没有其他驱动因素的情况下，没有必要从 TFVC 中迁移。'
- en: In Azure DevOps, there is a maximum of one TFVC repository per team project.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure DevOps 中，每个团队项目最多只能有一个 TFVC 仓库。
- en: Git
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git
- en: Next to TFVC, Azure DevOps also supports hosting Git repositories. Git is a
    form of decentralized source control that is rapidly gaining ground. Git is not
    specific to Azure DevOps but is a general protocol that is used by many platforms
    that provide source control hosting as a service. Well-known examples next to
    Azure DevOps are GitHub and GitLab.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 TFVC，Azure DevOps 还支持托管 Git 仓库。Git 是一种去中心化的源代码管理方式，正在迅速流行。Git 不仅仅是 Azure
    DevOps 特有的，它是一种通用协议，许多提供源代码托管服务的平台都在使用。除了 Azure DevOps，GitHub 和 GitLab 也是著名的例子。
- en: 'To work with a Git repository, you must first clone it:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Git 仓库，首先必须克隆它：
- en: Open Command Prompt and navigate to the directory where you want to store the
    repository.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符，导航到你希望存储仓库的目录。
- en: 'Execute the following command and replace the example URL with the URL to your
    Git repository. The example URL shows how the location of a Git repository in
    Azure DevOps is built up:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令，并将示例网址替换为你 Git 仓库的 URL。示例 URL 展示了 Azure DevOps 中 Git 仓库位置的构建方式：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, you can start working on the changes you want to make. In this example,
    a new file, `NewFile.txt`, was added.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以开始进行你想要的修改了。在这个例子中，添加了一个新文件，`NewFile.txt`。
- en: 'Next, this file must be staged for commit. Staging files is done to differentiate
    between files you want to commit and changes you want to keep for your own:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，这个文件必须被暂存以供提交。暂存文件是为了区分你想要提交的文件和你想保留自己更改的文件：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After staging all of the changes you want to group into a single commit, creating
    the actual `commit` is done by calling the commit command and specifying a description
    of the changes:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将所有想要分组到单个提交的更改暂存后，实际创建 `commit` 是通过调用提交命令并指定更改的描述来完成的：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, you can push your changes back to the central repository, the remote,
    by executing the following command:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以通过执行以下命令，将你的更改推送回中央仓库，即远程仓库：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To make more changes, you can stage and commit changes as often as required.
    You can push the commits one at a time, but you can also push multiple commits
    at once.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行更多更改，你可以根据需要随时暂存并提交更改。你可以一次推送一个提交，但也可以一次推送多个提交。
- en: You can also work with Git through the Visual Studio or VS Code interfaces.
    Here, you execute precisely the same steps, but instead, you can use a visual
    interface.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过 Visual Studio 或 VS Code 界面来使用 Git。在这里，你执行的步骤完全相同，但你可以使用可视化界面。
- en: Large File Storage
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大文件存储
- en: Git is designed and optimized for working with plain text files and tracking
    changes from version to version. However, you might want to store other things
    than just text files into source control. Examples are images or binary files
    that should be included with your application at runtime. While these are valid
    use cases, out of the box they do not work very well with Git. To fix this, **Large
    File Storage** (**LFS**) was introduced.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Git 被设计并优化用于处理纯文本文件，并跟踪版本之间的变化。然而，你可能希望将除文本文件之外的其他内容存储到源代码控制中。例如，图像或二进制文件应该在运行时与应用程序一起包含。虽然这些是有效的用例，但开箱即用时，它们与
    Git 的兼容性不好。为了解决这个问题，**大文件存储**（**LFS**）被引入。
- en: Git LFS allows you to store, instead of the binary files themselves, a small
    text file that acts as a pointer to that file. Such a file contains a hash of
    the file so that the client can download the file when cloning or fetching changes
    and update the file when you update the binary file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Git LFS 允许你存储一个小的文本文件，作为指向二进制文件的指针，而不是直接存储二进制文件。这样的文件包含该文件的哈希值，这样客户端在克隆或获取更改时可以下载该文件，并且在你更新二进制文件时能够更新该文件。
- en: 'To work with Git LFS, you must install the LFS client next to the Git client.
    This is a separate client that every user of the repository must download. Without
    this client, other users will only see the pointer files instead of the actual
    binary files. After installing the client, you must prepare the repository for
    the use of LFS. The following example commands enable the use of LFS for MP4 files:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Git LFS，你必须在 Git 客户端旁边安装 LFS 客户端。这是一个单独的客户端，每个仓库的用户都必须下载。没有这个客户端，其他用户只会看到指向文件的指针文件，而不是实际的二进制文件。安装客户端后，你必须准备仓库以便使用
    LFS。以下示例命令启用 MP4 文件的 LFS 使用：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: From here onward, you can work with MP4 files just as any file and behind the
    scenes, they will be stored separate from your text file changes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从此开始，你可以像操作任何文件一样操作 MP4 文件，幕后它们将与文本文件的更改分开存储。
- en: Migrating between control systems
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在控制系统之间迁移
- en: One of the steps on the DevOps journey is the consolidation of tools. This means
    that, at some point, you might be asked to migrate sources from one source control
    system to another. This means that companies might decide to move all of their
    sources from GitLab or Subversion to Azure Git Repos. There are multiple options
    available to you to do migrations like these.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 旅程中的一步是工具的整合。这意味着，在某个时刻，你可能会被要求将源代码从一个源代码控制系统迁移到另一个系统。这意味着公司可能会决定将所有源代码从
    GitLab 或 Subversion 移动到 Azure Git Repos。你可以选择多种方式进行这样的迁移。
- en: The most likely event is that you will receive requests to move sources to one
    or more Azure Git repositories. Possible sources are other Git repositories, TFVC,
    or Subversion. There are tools and approaches available to do such a migration
    while retaining the change history of the original repository.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最有可能发生的情况是，你会收到将源代码迁移到一个或多个 Azure Git 仓库的请求。可能的源包括其他 Git 仓库、TFVC 或 Subversion。可以使用一些工具和方法进行这样的迁移，同时保留原仓库的变更历史。
- en: If there is no procedure available or you must import sources from another system,
    you can also fall back on creating a new empty repository and initialize that
    with an existing code base. The disadvantage of this is that all history will
    be a lost this way.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有现成的迁移流程，或者你必须从另一个系统导入源代码，你也可以选择创建一个新的空仓库，并将其初始化为现有代码库。这种方法的缺点是，所有历史记录都会丢失。
- en: Migrating existing Git repositories
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移现有的 Git 仓库
- en: 'When it comes to migrating sources, moving to another location for hosting
    Git repositories is straightforward, compared to other migrations. Let''s learn
    how to do this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在迁移源代码时，与其他类型的迁移相比，将 Git 仓库迁移到其他位置进行托管是相对简单的。让我们学习如何做到这一点：
- en: 'First, clone the existing repository to your local computer. Please note the
    dot at the end—this will place the repository in your current directory:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将现有仓库克隆到本地计算机。请注意末尾的点，这将把仓库放置在当前目录中：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add another remote that refers to the new, empty repository that you want to
    move the sources to:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个远程仓库，指向你希望将源代码迁移到的新空仓库：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, you push the changes to this new repository. You must do this separately
    for every branch you want to move next to the master:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你将更改推送到这个新仓库。对于每个你想迁移到主分支的分支，你必须单独执行这个操作：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Meanwhile, other developers might have continued working with the existing repository.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，其他开发人员可能已经继续在现有仓库中工作。
- en: 'To include those in the new repository as well, you must fetch them to your
    local computer from the original repository and then push them to the new repository.
    Again, repeat this for every branch:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将这些内容也包括在新的仓库中，你必须先从原始仓库将它们获取到本地计算机，然后再推送到新的仓库。再次重复此操作，适用于每一个分支：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Repeat these last two commands until there are no developers working on the
    source repository anymore.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复执行这最后两个命令，直到没有开发人员继续在源仓库中工作为止。
- en: After a successful migration, it is often best to remove the old repository.
    This prevents anyone from continuing to work there by accident.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功迁移后，通常最好删除旧仓库。这可以防止任何人不小心继续在旧仓库中工作。
- en: The preceding steps will work for any Git-to-Git migration.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上述步骤适用于任何 Git-to-Git 迁移。
- en: 'Now, if you specifically want to migrate to an Azure Git Repo, you can also
    use the import functionality that is included with Azure DevOps. To do this, follow
    these steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你特别想迁移到 Azure Git 仓库，你也可以使用 Azure DevOps 提供的导入功能。要执行此操作，请按照以下步骤操作：
- en: Navigate to Git Repos and optionally create a new Git repository first.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航至 Git 仓库，并可以选择先创建一个新的 Git 仓库。
- en: Choose to Import an existing repository.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择导入一个现有的仓库。
- en: Provide the requested information.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供所需的相关信息。
- en: Click on Import to start importing the repository.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“导入”开始导入仓库。
- en: 'The following screenshot illustrates these steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了这些步骤：
- en: '![](img/9149b6f2-dac4-42a6-b2de-798020c9d16a.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9149b6f2-dac4-42a6-b2de-798020c9d16a.png)'
- en: The disadvantage of this approach is that you cannot keep pushing changes from
    the source repository to the new repository. This means that all other developers
    on your team must make sure that they move their changes over on their own or
    do not have any pending work while you migrate the repository.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，你不能持续将更改从源仓库推送到新仓库。这意味着，你团队中的所有其他开发人员必须确保自己将更改迁移过来，或者在迁移仓库时没有未完成的工作。
- en: Migrating from TFVC to an Azure Git repository
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 TFVC 迁移到 Azure Git 仓库
- en: For migrating from TFVC to a Git repository, you can use the same *import repository*
    as for moving from any Git repository to an Azure Repo. This wizard can take the
    history for up to 180 days when doing the import. If this is not enough and you
    are required to move more than 180 days' worth of history to the new repository,
    there are other approaches you can use but they are more involved. Links to more
    elaborate advice is included at the end of this chapter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从 TFVC 迁移到 Git 仓库，你可以使用与从任何 Git 仓库迁移到 Azure 仓库相同的*导入仓库*功能。此向导在执行导入时最多可以处理
    180 天的历史记录。如果这不足够，而且你需要将超过 180 天的历史记录迁移到新仓库，还有其他更复杂的方法可以使用，但它们涉及更多的步骤。更详细的建议链接将在本章结束时提供。
- en: Migrating from Subversion to an Azure Git repository
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Subversion 迁移到 Azure Git 仓库
- en: A final type of request that you might receive is that of migrating from a Subversion
    repository to a Git repository. For this, there is no out-of-the-box solution
    from Microsoft available. However, Atlassian has created a tool that can be used
    to migrate a Subversion repository to a local Git repository while maintaining
    the change history.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能收到的另一种请求是将一个Subversion仓库迁移到Git仓库。对于这种情况，微软没有现成的解决方案。不过，Atlassian开发了一款工具，可以在保留变更历史的同时，将Subversion仓库迁移到本地Git仓库。
- en: After running this tool, the only thing left to do is to add a remote to a new
    empty, hosted repository and push all of the branches. These are the same as the
    steps for migrating from Git to Git, starting at the step that adds a new remote.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 运行完该工具后，剩下的就是为一个新的空仓库添加远程，并推送所有的分支。这些步骤与从Git迁移到Git的步骤相同，起始于添加一个新的远程仓库。
- en: Migrating without retaining history
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不保留历史记录的迁移
- en: If you are asked to do a migration without retaining history, you can just create
    a new, empty repository out of sources on your local computer and push existing
    changes there using the following commands.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你被要求进行迁移且不保留历史记录，可以仅在本地计算机上创建一个新的空仓库，并使用以下命令将现有的更改推送到该仓库。
- en: 'Execute the following from the directory that contains the files that should
    go into the master branch:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从包含应该放入主分支的文件的目录执行以下命令：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These commands initialize a new repository, create a first commit out of all
    of the files already in the directory, add a reference to the target server location,
    and push the newly created repository there.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令初始化一个新的仓库，基于当前目录中所有文件创建第一次提交，添加目标服务器位置的引用，并将新创建的仓库推送到该位置。
- en: 'If you want to retain multiple branches, you must repeat the following steps
    for every other branch:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想保留多个分支，必须为每个其他分支重复以下步骤：
- en: 'First, go to the right directory for that branch:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，进入该分支的正确目录：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, copy the files that need to go into this branch into your working directory.
    Then, continue with the following commands:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将需要放入该分支的文件复制到你的工作目录中。然后，继续执行以下命令：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This completes the migration and the latest version of the sources you had on
    your local computer are now available in Git. Other members of your team can now
    clone the repository and work with it. Next, we'll go on to learn about branching
    and merging.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了迁移，现在你本地计算机上的最新源代码版本已在Git中可用。你团队的其他成员现在可以克隆该仓库并开始使用它。接下来，我们将学习分支和合并。
- en: Selecting a branching and merging strategy
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择分支和合并策略
- en: Source control allows you to keep a history of all of the changes you have made
    to your files but also allows working separately from your team members for a
    while if you so desire. We call this **branching**. When you are branching in
    source control, you fork the line of changes currently registered. We call such
    a fork a **branch***.* A branch allows you to temporarily isolate some work from
    the rest. If you at any point want to integrate the changes from a branch with
    the changes on the other fork, you can **merge** these changes back. Branches
    are often used for working on not yet complete features, proofs of concept, or
    hotfixes. Using branches allows you to later decide which changes to include in
    the next version and which not to.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制允许你记录对文件所做的所有更改，同时如果需要，也能暂时与团队成员分开工作。我们称之为**分支**。当你在版本控制中进行分支时，你会复制当前注册的更改路径。我们称这种复制为**分支**。分支允许你暂时将某些工作与其他工作隔离开。如果你希望在某个时刻将某个分支的更改与另一个分支的更改合并，你可以**合并**这些更改。分支通常用于处理尚未完成的功能、概念验证或热修复。使用分支可以让你稍后决定将哪些更改包含在下一个版本中，哪些不包含。
- en: Branching strategies
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支策略
- en: 'There are many, many branching strategies available, but the three most used
    nowadays are the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有许多分支策略可供选择，但如今最常用的三种策略如下：
- en: GitHub flow
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub流程
- en: GitFlow
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitFlow
- en: Release Flow
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布流程
- en: The following subsections will discuss these in greater detail.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节将更详细地讨论这些内容。
- en: As an alternative to branching, trunk-based development is becoming more popular
    nowadays. To know more about this, visit [https://paulhammant.com/2013/04/05/what-is-trunk-based-development/](https://paulhammant.com/2013/04/05/what-is-trunk-based-development/).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 作为分支管理的替代方案，基于主干的开发（trunk-based development）如今变得越来越流行。想了解更多内容，请访问 [https://paulhammant.com/2013/04/05/what-is-trunk-based-development/](https://paulhammant.com/2013/04/05/what-is-trunk-based-development/)。
- en: GitHub flow
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitHub流程
- en: GitHub flow is a simple, yet often sufficient, branching strategy. In GitHub
    flow, there is one **master** branch that should always be in a deployable state.
    No unfinished changes are allowed to go onto the master.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub flow是一种简单但通常足够的分支策略。在GitHub flow中，只有一个**master**分支，始终应该保持在可部署的状态。master上不允许有未完成的更改。
- en: 'If you want to start work on a new feature or bugfix, you create a new topic
    branch of the master where you commit your work. Only when you are completely
    done with that work do you merge this branch back to the master. An example commit
    flow might look like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想开始处理一个新的功能或错误修复，你需要从master创建一个新的主题分支，在这个分支上提交你的工作。只有当你完全完成这项工作时，才将这个分支合并回master。一个示例提交流程可能如下所示：
- en: '![](img/cb942fe3-358e-4737-9110-0ad9b6c24936.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb942fe3-358e-4737-9110-0ad9b6c24936.png)'
- en: As this is the branching scheme with the least branches involved, this is probably
    a good strategy to start with.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是涉及分支最少的分支策略，这可能是一个很好的起点。
- en: GitFlow
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitFlow
- en: GitFlow is another well-known elaborate branching scheme that can deal with
    almost any situation that might arise when working with software. GitFlow describes
    creating a branch, **Develop**, of the master whenever you start work on a new
    version. **Develop** is the integration branch where you combine new features
    and do integration testing. It should only contain work that you believe is ready
    to be released.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: GitFlow是另一种著名的复杂分支策略，可以应对在软件开发中可能出现的几乎所有情况。GitFlow描述了每当开始处理一个新版本时，都会创建一个**Develop**分支，作为master的分支。**Develop**是集成分支，用于合并新功能并进行集成测试。它只应包含那些你认为已经准备好发布的工作。
- en: From **Develop**, you create one or more feature branches where you start working
    on new features. Only when a feature is done do you merge that branch back to
    the **Develop** branch.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从**Develop**分支，你可以创建一个或多个功能分支，开始处理新的功能。只有当某个功能完成后，你才会将这个分支合并回**Develop**分支。
- en: 'When you want to release a new version of your application, you create a release
    branch of the **Develop** branch. On the code on this branch, you perform final
    testing and perform one or more bugfixes if needed. When you are satisfied with
    the quality of the code, you merge this branch to the master and tag the version.
    You also merge these bugfixes back to **Develop**, so they will also be incorporated
    in new developments. This flow is visible in the following diagram:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想发布一个新版本的应用程序时，你需要创建一个**Develop**分支的发布分支。在这个分支上的代码上，你进行最终测试，并在必要时进行一个或多个错误修复。当你对代码质量满意时，将这个分支合并到master，并打上版本标签。你还需要将这些错误修复合并回**Develop**，以便它们也会被纳入到新的开发中。这个流程可以通过以下图示来展示：
- en: '![](img/7426e312-0862-46dc-8c0d-5d42ae0e9cec.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7426e312-0862-46dc-8c0d-5d42ae0e9cec.png)'
- en: If there is ever a critical bug that you need to ship as fast as possible or
    you want to do a hotfix, for this is also possible. In that case, you create a
    new branch of the master, where you fix the bug. After testing, you merge this
    branch to both master and developer—just as you would with a release branch.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到需要尽快修复的关键性错误，或者你需要做热修复，也可以使用这种流程。在这种情况下，你需要从master创建一个新的分支，修复错误。测试完成后，你将这个分支合并到master和developer分支，就像处理发布分支一样。
- en: Release Flow
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Release Flow
- en: '**Release Flow** is the branching system that is used by the Azure DevOps team
    to develop Azure DevOps. It is also based on working with short-lived topic branches
    that are made from and merged to a master branch.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**Release Flow**是Azure DevOps团队用于开发Azure DevOps的分支系统。它同样基于使用短生命周期的主题分支，这些分支从master分支创建，并最终合并回master。'
- en: 'The difference is that it is not the code that is on the master branch that
    is being deployed to production. Instead, whenever a new version of the product
    needs to be released, a new branch is created of **master** with the name **release-{version}**.
    The code from this branch is then deployed to production. Once a new release branch
    is deployed, the previous one can be disregarded. This results in the following
    flow:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于，部署到生产环境的并不是master分支上的代码。而是每当需要发布新版本时，会从**master**创建一个新的分支，命名为**release-{version}**。这个分支上的代码会被部署到生产环境。一旦新的发布分支被部署，之前的发布分支可以被忽略。最终形成以下流程：
- en: '![](img/b8de65f1-3cd3-42e1-a874-26b2ed6093c9.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8de65f1-3cd3-42e1-a874-26b2ed6093c9.png)'
- en: The advantage of this model is that it allows for taking a snapshot of the current
    state of the master branch and taking that to production. If there is ever a bug
    in production that needs to be fixed ahead of a new complete release then the
    correct commits can be merged from the master branch to the current release branch.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模型的优点是，它允许拍摄主分支当前状态的快照，并将其推向生产。如果生产环境中出现需要在新完整版本之前修复的错误，那么可以将正确的提交从主分支合并到当前发布分支。
- en: Trunk-based development
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于主干的开发
- en: In many companies, branching and merging are done to retain flexibility when
    releasing a new version and being able to pick changes for that version only at
    the last moment. This flexibility comes at the cost of having to merge or integrate
    your changes at some point. This cost is not only the time it takes but also the
    risks that a merge operation introduces. Merging the changes from two different
    branches that contain perfectly working software might still produce non-working
    code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多公司中，分支和合并是为了在发布新版本时保留灵活性，并且能够在最后时刻只选择该版本的更改。这种灵活性是以必须在某个时刻合并或集成更改为代价的。这一代价不仅仅是所需的时间，还有合并操作带来的风险。从两个不同分支中合并包含完美工作的代码，可能仍然会产生无法工作的代码。
- en: For this reason, you might consider switching to **trunk-based development**.
    In trunk-based development, you are no longer using branching for picking changes
    that go into a version. Instead, every developer on the team continuously works
    from the same branch (often the master) and only creates a short-lived branch
    for preparing one single change, which is then merged into the master branch.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这个原因，你可能会考虑切换到**基于主干的开发**。在基于主干的开发中，你不再使用分支来选择进入版本的更改。相反，团队中的每个开发人员都持续在同一个分支（通常是主分支）上工作，并且只为准备一个单一的更改而创建短生命周期的分支，然后将其合并回主分支。
- en: When you adopt this, you will need another way to determine which changes will
    and won't yet be available to your users when releasing a new version of your
    software. You can do this by using **branching by abstraction**.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当你采用这种方式时，你将需要另一种方法来确定在发布新版本软件时，哪些更改将可用，哪些更改尚未可用。你可以通过使用**抽象分支**来做到这一点。
- en: Branching by abstraction
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象分支
- en: 'When branching by abstraction, you are not keeping two versions of your code
    side by side using branches, but you keep them side by side in your code base.
    For example, when you want to change the implementation of a class called `FoodClassifier`,
    which implements the `IFoodClassifier` interface, you go through the following
    steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行抽象分支时，你不会将代码的两个版本并排使用分支，而是将它们并排放在代码库中。例如，当你想要更改一个名为`FoodClassifier`的类的实现，而该类实现了`IFoodClassifier`接口时，你会执行以下步骤：
- en: You refactor the name of the `FoodClassifier` class to `FoodClassifierToBeRemoved`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将`FoodClassifier`类的名称重构为`FoodClassifierToBeRemoved`。
- en: You create a copy of the complete `FoodClassifierToBeRemoved` class.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你创建了一个完整的`FoodClassifierToBeRemoved`类的副本。
- en: You name this copy back to `FoodClassifier`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将这个副本命名为`FoodClassifier`。
- en: 'At this point, your changes should look like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你的修改应该看起来像这样：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Please note that at runtime, your application will behave just as it did before.
    You have just added a new, yet unused, class with a change in behavior. It is
    safe to commit these changes and even ship the new binaries to a user. Now you
    can start changing the implementation of the new `FoodClassifier` class, test
    it, and establish trust in its implementation. Meanwhile, you can keep committing
    and pushing your changes, even to customers. Switching to the new implementation
    can be done using your dependency injection configuration, a Boolean flag, or
    environment variables. Just choose what makes sense in your scenario.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在运行时，应用程序的行为将与之前一样。你只是添加了一个新的、尚未使用的类，并且改变了其行为。提交这些更改甚至将新的二进制文件发布给用户是安全的。现在，你可以开始更改新的`FoodClassifier`类的实现，进行测试，并建立对其实现的信任。同时，你可以继续提交并推送你的更改，甚至是推送给客户。切换到新实现可以通过依赖注入配置、布尔标志或环境变量来完成。只需选择在你的场景中最合适的方式。
- en: Only when you are fully satisfied that the new implementation is working, you
    remove the `FoodClassifierToBeRemoved` class and update any references back to
    `FoodClassifier`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在你完全满意新实现工作正常时，你才会删除`FoodClassifierToBeRemoved`类，并将任何引用更新回`FoodClassifier`。
- en: We will expand on branching by abstraction in [Chapter 4](8ab4597a-becd-4855-9b45-89045982c14a.xhtml),
    *Continuous Deployment*, when discussing feature toggles. While being a recommended
    way forward to further accelerate your delivery, branching by abstraction is a
    double-edged sword. If you do not have a process to keep the number of side-by-side
    implementations under control and clean them up after switching implementations,
    the quality of your code base might decline.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第4章](8ab4597a-becd-4855-9b45-89045982c14a.xhtml)中进一步探讨通过抽象进行分支，*持续部署*时讨论功能切换。虽然通过抽象进行分支是一种推荐的加速交付的方法，但它也是一把双刃剑。如果您没有流程来控制并行实现的数量，并在切换实现后清理它们，您的代码库质量可能会下降。
- en: Merging strategies
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并策略
- en: Depending on the source control system you are working with, there might be
    multiple ways you can merge your changes from one branch to another.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您使用的源代码管理系统，可能有多种方式将您的更改从一个分支合并到另一个分支。
- en: TFVC
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TFVC
- en: When you are working with TFVC, you prepare a merge locally by choosing both
    a source and target branch and then picking the list of changes you want to merge.
    TFVC will then execute the merge and show you the changes that are the consequence
    of this merge as local changes. You can go over these changes, correct or change
    them, and must resolve any conflicts. After this, you commit the changes just
    as you would any regular change.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 TFVC 时，您需要在本地准备合并，选择源分支和目标分支，然后选择要合并的更改列表。TFVC 然后执行合并，并将合并结果显示为本地更改。您可以检查这些更改，纠正或修改它们，并解决任何冲突。之后，您就可以像处理常规更改一样提交更改。
- en: Git
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git
- en: A merge using Git can be performed by switching to the target branch and then
    *merging* all of the changes from the source branch. If there are conflicting
    changes between the branches, you must resolve those just as you would when fetching
    new changes from the server. After merging the changes from the source branch
    and resolving any changes, you can commit the changes. This will result in a merge
    commit, which you push to the remote just as any change.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Git 进行合并时，可以通过切换到目标分支，然后*合并*源分支的所有更改来执行。如果分支之间存在冲突的更改，您必须像从服务器获取新更改时那样解决这些冲突。合并源分支的更改并解决所有冲突后，您可以提交更改。这将生成一个合并提交，您像提交任何其他更改一样将其推送到远程。
- en: 'This can be done using the visual interface of Visual Studio or VS Code, but
    also using the following sequence of commands:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以使用 Visual Studio 或 VS Code 的图形界面完成，也可以使用以下命令序列：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If there are any conflicts, you have to resolve these at this point. Otherwise,
    you cannot continue:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在任何冲突，您必须在此时解决这些冲突。否则，您无法继续：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you will read in the *Securing repositories* section, it is possible to protect
    some branches by disallowing merging this way. Especially when it comes to changes
    to master, you might want to use another mechanism for merging changes, namely,
    pull requests. Using a pull request, you open a request for someone else to pull
    changes from your branch to the target branch. This way, another team member can
    first review your changes and only merge them when they meet all agreed standards.
    Others can comment on your changes or request updates before they perform the
    merge. This is the most common way of enforcing the four-eyes principle for source
    code when working with Git. The four-eyes principle says that every change or
    action should be viewed by at least two people.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在*保护仓库*部分中所述，您可以通过禁止以这种方式合并来保护某些分支。尤其是对于主分支的更改，您可能希望使用另一种合并更改的机制，即拉取请求。使用拉取请求，您向其他人发出请求，让他们从您的分支拉取更改到目标分支。这样，其他团队成员可以首先审查您的更改，只有在它们满足所有约定的标准后才会合并。其他人可以对您的更改发表评论或要求更新，然后再执行合并。这是使用
    Git 强制实施源代码四眼原则的最常见方式。四眼原则规定，每个更改或操作应由至少两个人查看。
- en: Now, when you are approving a pull request, there are different strategies you
    can use for generating the merge commit. The most commonly used are a merge commit,
    squash commit, or a rebase.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您批准一个拉取请求时，您可以使用不同的策略来生成合并提交。最常用的策略是合并提交、压缩提交或变基。
- en: Merge commit
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并提交
- en: A regular **merge commit** is a type of commit that maintains visibility of
    all previous commits. It has a reference to two parents, showing both origins
    of the change, namely the source and target branch. This is the same type of merge
    as you can perform manually using a Git merge. The advantage of this type of commit
    is that it clearly shows where the new state of the target branch comes from.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Squash commit
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When performing a so-called **squash commit**, you are combining all of the
    individual commits from the source branch in one, new commit. This is useful when
    all of the commits on the source branch relate to one feature and you want to
    keep a clear, concise change history on the target branch. Especially when there
    are commits with bugfixes or clean-up operations on the source branch, this approach
    makes sense. The disadvantage is that you might lose the rationale for some incremental
    changes that were made on the source branch.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Rebase
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Rebasing** a branch means that all of the commits for which your branch is
    ahead of the master branch are put aside for a bit. Meanwhile, all of the commits
    for which the master branch is ahead of your local branch are now merged to your
    local branch. Finally, all of your own commits that were set aside are now reapplied.
    The following diagram shows a branch before and after a rebase commit:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/595b2365-971d-4d16-a572-ed58f652768b.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: After rebasing the source branch, it is now merged into master. The advantage
    of this kind of merge is that you retain all individual changes in one single
    commit history.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Managing repositories
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working in Azure Repos, every team project can have a maximum of one TFVC
    repository. However, when working with Git, you can have multiple repositories
    in the same team project. A discussion that is gaining more attention lately is
    that of having a single repository for all applications or a repository per application.
    Other topics that are important when managing repositories are creating and removing
    repositories, securing them, and setting policies on them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Monorepo or multi-repo
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are using a **monolithic repository** (**monorepo**) when you are storing
    all of the code of all of your projects and applications in one single source
    control repository. Opposed to this, you might be using multiple repositories
    where every application, library, or project is stored in its own repository.
    Both approaches have their own pros and cons and both approaches are used by companies
    from small to large.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Possible advantages of a monorepo can include the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Easier reuse of existing code: If all of the code is in a single repository,
    it is accessible by and visible to everyone. This means that the chances of reuse
    are increased.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having all applications in one repository also means that any change affecting
    more than one application can be made in a single commit, in a single repository.
    A typical example is an API change.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all of the code being accessible to and maintained by everyone, there is
    less chance that a developer or team claims a specific repository as its own.
    This encourages learning from each other.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Possible advantages of multiple repositories include the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: A monorepo can become very, very large, even up to the point that developers
    checkout or clone only part of the monorepo. This effectively defeats most of
    the advantages of a monorepo.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having one repository with all of the code encourages tight coupling between
    components or applications. If you have multiple repositories, you could update
    an API and release it under a new version and upgrade clients one by one. In a
    monorepo, you might be tempted to upgrade the API and change all of the consumers
    in one commit, with all of the risks attached.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which approach works best for you is influenced not only by the advantages and
    disadvantages discussed but also by the background and makeup of your team and
    organization. If you have a single team doing all the development for internal
    applications, a monorepo might make more sense. If you have multiple teams working
    on different applications for different clients, multiple repositories make more
    sense.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Creating and removing repositories
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Azure DevOps, you can have multiple Git repositories per team project. Try
    doing the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'First, visit the Manage repositories interface. The following screenshot shows
    how to access this interface:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/de6970e8-edd4-457c-b66f-89a777610ba4.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: After opening this interface, a new interface (as shown in the following screenshot)
    opens up. Here, you can add new repositories by clicking on the Add... button
    with a plus sign (marked with a **1** in the following screenshot) and filling
    out a repository name.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repositories can also be removed, by clicking on their name and then Delete
    (marked with a **2**):'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c987591b-c267-4c71-877b-2b3d5e69c640.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: Removing repositories is not something that is often done. It might make more
    sense to make a no-longer-used repository read-only or remove all authorizations
    on it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's learn how to secure the repositories that we create.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Securing repositories
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the security options with distributed source control are often not as
    broad as with centralized source control, Azure Repos offers some means to set
    authorizations on a repository or a server-side branch. In the last image of the
    previous section, you can also see how you can select a group or user in the middle
    column and then update the authorizations on the repository. By default, all authorizations
    are inherited from project defaults.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to only change authorizations a little as possible and if
    you do, it is often best to work via groups and allow authorizations.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: You can also change the authorizations for a specific branch by opening the
    repositories branches in the drop-down menu on the left and clicking on the branch
    you want to override the authorizations for. In the preceding screenshot, this
    is marked with a 3.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Branch policies
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, it is possible to enforce one or more policies on pull requests to
    a specific branch. The interface for branch policies is shown in the following
    screenshot and can be accessed by choosing the Branch policies option while managing
    the authorizations on a repository branch:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c771726d-de8f-4b41-9154-a27ab3ed81ef.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: The first four checkboxes are related to default policies that can be enabled
    (or not) on your preference. By default, they are all disabled.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Build validation can be used to disallow the merge of any pull request if one
    or more of the select builds have not completed successfully. How to set up such
    a build is something you will learn in the next chapter.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Next to builds, you can also call external services to inspect the pull request
    and to allow or disallow it. An often used integration here is with a code quality
    tool. You might also call your own APIs here, to enforce team agreements on things
    such as pull request titles, relation to work items, or more complex constraints.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can enforce that a specific user or group has to be included in
    the review of a pull request. This might be needed to enforce a specific level
    of quality, but it can also be a limiting factor on your development speed and
    hence flow.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Other tools for source control
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next to the source control systems available in Azure Repos, there are also
    some other well-known systems that you should know about:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: GitHub
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitLab
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subversion
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll go over each of these in the upcoming subsections.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: GitHub
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**GitHub** is a hosted source control provider that delivers hosted Git repositories.
    GitHub allows anyone to create as many publicly visible repositories as they want.
    Only, when you create private repositories that require three or more contributors,
    you must switch to a paid subscription.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: This model that allows unlimited, free usage of the platform if developing in
    public has made GitHub, by far, the largest host of open source software in the
    world.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: GitHub was acquired by Microsoft in 2018 and since then, Microsoft and GitHub
    have worked together to create a great integration experience between GitHub repositories
    and Azure DevOps, specifically with Azure Boards and Azure Pipelines. In addition
    to this, Microsoft has stated that GitHub and Azure Repos will continue to exist
    next to each other and that there are currently no plans to terminate one of the
    products in favor of the other.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: There is also an on-premises offering by GitHub called GitHub Enterprise.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: GitLab
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitLab is another platform that delivers hosted Git repositories. Just like
    Azure DevOps, source control hosting is one of the services it provides.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Subversion
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An older source control system is Subversion. Subversion was developed and first
    used in 2004 and is maintained by the Apache Software Foundation. Subversion is
    a centralized source control system that supports all the features that you would
    expect of such a system.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: There are many false arguments as to where Subversion would be inferior to Git,
    however, most of them are not true for more recent versions of Subversion. The
    reality is that Subversion is a widely used type of source control system that
    performs well, especially for very large repositories or repositories that have
    very specific authorization needs.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: While Azure DevOps cannot host Subversion repositories, it can connect to, and
    work with, sources that are stored in Subversion.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you have learned about source control. We saw that there are
    two types of source control: centralized and decentralized, both supported by
    Azure DevOps. TFVC is no longer recommended for new projects. You should use Git
    whenever starting a new project.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: When using Git, you can have more than one repository in your team project.
    Per repository, you can assign policies to lock down specific branches and enforce
    the four-eyes principle. You have also learned about access control and how to
    provide users access to one or more repositories. Finally, you have learned about
    alternative tools and how to migrate sources from one tool to the other.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: You can use what you have learned to make decisions on which type of source
    control system to use in your products. You can now professionally organize the
    repository or repositories you work in. You are now able to work with different
    branching strategies and use policies for enforcing security or quality requirements.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will take what you have learned about source control and use
    that to set up continuous integration.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the Appendix:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: What are the differences between centralized and decentralized source control
    and which work best in what situation?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: Git is an example of decentralized source control.'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is not a common branching strategy?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Release Flow
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Rebasing
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: GitFlow
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: GitHub flow
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Many companies want a code review to be performed before code is merged into
    the master branch. What construct is used to do so when working with Git and how
    can this be enforced in Azure DevOps?
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following are not valid merge strategies?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rebasing
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Trunk-based development
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Merge commit
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Squash commit
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More information about working with Git can be found at [https://docs.microsoft.com/en-us/learn/paths/intro-to-vc-git/](https://docs.microsoft.com/en-us/learn/paths/intro-to-vc-git/).
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The original Microsoft advice on TFVC versus Git can be found at [https://docs.microsoft.com/en-us/azure/devops/repos/tfvc/comparison-git-tfvc?view=azure-devops&viewFallbackFrom=vsts](https://docs.microsoft.com/en-us/azure/devops/repos/tfvc/comparison-git-tfvc?view=azure-devops&viewFallbackFrom=vsts).
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about Git LFS can be found at [https://docs.microsoft.com/en-us/azure/devops/repos/git/manage-large-files?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/repos/git/manage-large-files?view=azure-devops).
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instructions for downloading Git LFS can be found at [https://git-lfs.github.com/](https://git-lfs.github.com/).
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about migrating to Git can be found at [https://docs.microsoft.com/en-us/azure/devops/repos/git/import-from-TFVC?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/repos/git/import-from-TFVC?view=azure-devops).
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Atlassian tool for converting an SVN repository to a local Git repository
    can be found at [https://www.atlassian.com/git/tutorials/migrating-convert](https://www.atlassian.com/git/tutorials/migrating-convert).
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about GitFlow can be found at [https://datasift.github.io/gitflow/IntroducingGitFlow.html](https://datasift.github.io/gitflow/IntroducingGitFlow.html).
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about GitHub flow can be found at [https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/).
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release Flow is described in more detail at [https://docs.microsoft.com/en-us/azure/devops/learn/devops-at-microsoft/release-flow](https://docs.microsoft.com/en-us/azure/devops/learn/devops-at-microsoft/release-flow).
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trunk-based development is discussed at [https://trunkbaseddevelopment.com/](https://trunkbaseddevelopment.com/).
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about GitLab can be found at [https://about.gitlab.com/](https://about.gitlab.com/).
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about Subversion can be found at [https://subversion.apache.org/docs/](https://subversion.apache.org/docs/).
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
