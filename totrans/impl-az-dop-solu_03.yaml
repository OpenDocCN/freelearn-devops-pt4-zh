- en: Everything Starts with Source Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Source control is one of the most basic tools that is used in software development.
    Therefore, it is probably safe to assume that you have worked with source control
    before. For that reason, this chapter will contain only a brief introduction to
    source control and quickly move on to more advanced topics to help you to set
    up your source control to support DevOps practices.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple DevOps practices rely on source control, hence, setting up your repositories
    to continuously deliver value to your users is a great way to get started and
    a prerequisite for many of the subjects in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The types of source control in Azure DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source control systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting a branching and merging strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing source control using branch policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other tools that are available for source control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To practice the subjects covered in this chapter, you may need an Azure DevOps
    organization.
  prefs: []
  type: TYPE_NORMAL
- en: Types of source control in Azure DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While there are many different source control systems in existence, they can
    be classified into two categories, centralized and decentralized source control,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In a **centralized source control** system, only the server has the full history
    and the full set of branches that make up the repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In **decentralized source control**, everyone working with the repository has
    a full copy of the repository, all of the branches, and its history.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Repos, part of Azure DevOps services, offers both types of source control
    through TFVC and Git. The next two sections discuss both types of source control
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Centralized source control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a centralized source control system, the server is the only location where
    the full repository, including all of the history, is stored. When you create
    a local version of the content, you only receive the latest version of the code.
    Receiving this latest version is called **checking out** the repository. In addition
    to this latest version, your own computer only has the changes you make locally.
  prefs: []
  type: TYPE_NORMAL
- en: Not checking out the full history obviously saves space on your local computer.
    However, disk space is hardly ever an issue nowadays. Yet the downside of this
    is that you need to be continuously connected to the server to perform operations
    such as viewing the history of a file, recent commits of others, or which line
    in a file was last changed by who.
  prefs: []
  type: TYPE_NORMAL
- en: An advantage of centralized source control systems is that that they often offer
    options for fine-grained control over who can access which branches, directories,
    and even files.
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized source control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a decentralized source control system, all files, history, and branches
    are also stored on a server. The difference with centralized source control comes
    when you **clone** the repository, to have a local copy on your own computer.
  prefs: []
  type: TYPE_NORMAL
- en: Since you have a full clone of the repository, you can now view the history
    of a file and other branches without connecting to the server again. This obviously
    lessens the load on the server and allows you to continue working even when disconnected,
    two advantages of decentralized source control.
  prefs: []
  type: TYPE_NORMAL
- en: The downside is that decentralized source control can be harder to learn than
    centralized source control. Overall, the learning curve of decentralized source
    control systems is steeper. Also, access control on the level of individual directories
    and files is often more limited.
  prefs: []
  type: TYPE_NORMAL
- en: No matter which type of source control you are using, you must put a branching
    and merging strategy in place to allow developers to work on different features
    in parallel, while always keeping your master branch in a shippable state.
  prefs: []
  type: TYPE_NORMAL
- en: Source control systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many source control systems in use, but in this chapter, we will
    only be looking at the three currently most used. They are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Team Foundation Version Control **(**TFVC**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within Azure DevOps, only TVFC and Git are available. Subversion is a centralized
    source control system that is created by the Apache Foundation. In the upcoming
    subsections, we'll take a look at TFVC and Git in more detail and learn how to
    migrate sources between them. Subversion is discussed at the end of this chapter
    in the *Other tools for source control* section.
  prefs: []
  type: TYPE_NORMAL
- en: Team Foundation Version Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Team Foundation Version Control** (**TFVC**) is a centralized source control
    system that was introduced by Microsoft in 2013, as part of **Team Foundation
    Server** (**TFS**), the product that has evolved to become Azure DevOps. TFVC
    is still supported in Azure DevOps but is not recommended for new projects. If
    you are not working with TFVC yet, there is no value in learning it. Now, TFVC
    is not recommended for new projects and Microsoft will most likely not release
    new features for it, but it isn''t necessary to move away from it without other
    drivers.'
  prefs: []
  type: TYPE_NORMAL
- en: In Azure DevOps, there is a maximum of one TFVC repository per team project.
  prefs: []
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next to TFVC, Azure DevOps also supports hosting Git repositories. Git is a
    form of decentralized source control that is rapidly gaining ground. Git is not
    specific to Azure DevOps but is a general protocol that is used by many platforms
    that provide source control hosting as a service. Well-known examples next to
    Azure DevOps are GitHub and GitLab.
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with a Git repository, you must first clone it:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Command Prompt and navigate to the directory where you want to store the
    repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the following command and replace the example URL with the URL to your
    Git repository. The example URL shows how the location of a Git repository in
    Azure DevOps is built up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can start working on the changes you want to make. In this example,
    a new file, `NewFile.txt`, was added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, this file must be staged for commit. Staging files is done to differentiate
    between files you want to commit and changes you want to keep for your own:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After staging all of the changes you want to group into a single commit, creating
    the actual `commit` is done by calling the commit command and specifying a description
    of the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can push your changes back to the central repository, the remote,
    by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To make more changes, you can stage and commit changes as often as required.
    You can push the commits one at a time, but you can also push multiple commits
    at once.
  prefs: []
  type: TYPE_NORMAL
- en: You can also work with Git through the Visual Studio or VS Code interfaces.
    Here, you execute precisely the same steps, but instead, you can use a visual
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Large File Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git is designed and optimized for working with plain text files and tracking
    changes from version to version. However, you might want to store other things
    than just text files into source control. Examples are images or binary files
    that should be included with your application at runtime. While these are valid
    use cases, out of the box they do not work very well with Git. To fix this, **Large
    File Storage** (**LFS**) was introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Git LFS allows you to store, instead of the binary files themselves, a small
    text file that acts as a pointer to that file. Such a file contains a hash of
    the file so that the client can download the file when cloning or fetching changes
    and update the file when you update the binary file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with Git LFS, you must install the LFS client next to the Git client.
    This is a separate client that every user of the repository must download. Without
    this client, other users will only see the pointer files instead of the actual
    binary files. After installing the client, you must prepare the repository for
    the use of LFS. The following example commands enable the use of LFS for MP4 files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: From here onward, you can work with MP4 files just as any file and behind the
    scenes, they will be stored separate from your text file changes.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating between control systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the steps on the DevOps journey is the consolidation of tools. This means
    that, at some point, you might be asked to migrate sources from one source control
    system to another. This means that companies might decide to move all of their
    sources from GitLab or Subversion to Azure Git Repos. There are multiple options
    available to you to do migrations like these.
  prefs: []
  type: TYPE_NORMAL
- en: The most likely event is that you will receive requests to move sources to one
    or more Azure Git repositories. Possible sources are other Git repositories, TFVC,
    or Subversion. There are tools and approaches available to do such a migration
    while retaining the change history of the original repository.
  prefs: []
  type: TYPE_NORMAL
- en: If there is no procedure available or you must import sources from another system,
    you can also fall back on creating a new empty repository and initialize that
    with an existing code base. The disadvantage of this is that all history will
    be a lost this way.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating existing Git repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to migrating sources, moving to another location for hosting
    Git repositories is straightforward, compared to other migrations. Let''s learn
    how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, clone the existing repository to your local computer. Please note the
    dot at the end—this will place the repository in your current directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add another remote that refers to the new, empty repository that you want to
    move the sources to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you push the changes to this new repository. You must do this separately
    for every branch you want to move next to the master:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Meanwhile, other developers might have continued working with the existing repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To include those in the new repository as well, you must fetch them to your
    local computer from the original repository and then push them to the new repository.
    Again, repeat this for every branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Repeat these last two commands until there are no developers working on the
    source repository anymore.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a successful migration, it is often best to remove the old repository.
    This prevents anyone from continuing to work there by accident.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding steps will work for any Git-to-Git migration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you specifically want to migrate to an Azure Git Repo, you can also
    use the import functionality that is included with Azure DevOps. To do this, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to Git Repos and optionally create a new Git repository first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose to Import an existing repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the requested information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Import to start importing the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9149b6f2-dac4-42a6-b2de-798020c9d16a.png)'
  prefs: []
  type: TYPE_IMG
- en: The disadvantage of this approach is that you cannot keep pushing changes from
    the source repository to the new repository. This means that all other developers
    on your team must make sure that they move their changes over on their own or
    do not have any pending work while you migrate the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating from TFVC to an Azure Git repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For migrating from TFVC to a Git repository, you can use the same *import repository*
    as for moving from any Git repository to an Azure Repo. This wizard can take the
    history for up to 180 days when doing the import. If this is not enough and you
    are required to move more than 180 days' worth of history to the new repository,
    there are other approaches you can use but they are more involved. Links to more
    elaborate advice is included at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating from Subversion to an Azure Git repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A final type of request that you might receive is that of migrating from a Subversion
    repository to a Git repository. For this, there is no out-of-the-box solution
    from Microsoft available. However, Atlassian has created a tool that can be used
    to migrate a Subversion repository to a local Git repository while maintaining
    the change history.
  prefs: []
  type: TYPE_NORMAL
- en: After running this tool, the only thing left to do is to add a remote to a new
    empty, hosted repository and push all of the branches. These are the same as the
    steps for migrating from Git to Git, starting at the step that adds a new remote.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating without retaining history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are asked to do a migration without retaining history, you can just create
    a new, empty repository out of sources on your local computer and push existing
    changes there using the following commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following from the directory that contains the files that should
    go into the master branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: These commands initialize a new repository, create a first commit out of all
    of the files already in the directory, add a reference to the target server location,
    and push the newly created repository there.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to retain multiple branches, you must repeat the following steps
    for every other branch:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, go to the right directory for that branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, copy the files that need to go into this branch into your working directory.
    Then, continue with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This completes the migration and the latest version of the sources you had on
    your local computer are now available in Git. Other members of your team can now
    clone the repository and work with it. Next, we'll go on to learn about branching
    and merging.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a branching and merging strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Source control allows you to keep a history of all of the changes you have made
    to your files but also allows working separately from your team members for a
    while if you so desire. We call this **branching**. When you are branching in
    source control, you fork the line of changes currently registered. We call such
    a fork a **branch***.* A branch allows you to temporarily isolate some work from
    the rest. If you at any point want to integrate the changes from a branch with
    the changes on the other fork, you can **merge** these changes back. Branches
    are often used for working on not yet complete features, proofs of concept, or
    hotfixes. Using branches allows you to later decide which changes to include in
    the next version and which not to.
  prefs: []
  type: TYPE_NORMAL
- en: Branching strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many, many branching strategies available, but the three most used
    nowadays are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: GitHub flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitFlow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release Flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following subsections will discuss these in greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to branching, trunk-based development is becoming more popular
    nowadays. To know more about this, visit [https://paulhammant.com/2013/04/05/what-is-trunk-based-development/](https://paulhammant.com/2013/04/05/what-is-trunk-based-development/).
  prefs: []
  type: TYPE_NORMAL
- en: GitHub flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitHub flow is a simple, yet often sufficient, branching strategy. In GitHub
    flow, there is one **master** branch that should always be in a deployable state.
    No unfinished changes are allowed to go onto the master.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to start work on a new feature or bugfix, you create a new topic
    branch of the master where you commit your work. Only when you are completely
    done with that work do you merge this branch back to the master. An example commit
    flow might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb942fe3-358e-4737-9110-0ad9b6c24936.png)'
  prefs: []
  type: TYPE_IMG
- en: As this is the branching scheme with the least branches involved, this is probably
    a good strategy to start with.
  prefs: []
  type: TYPE_NORMAL
- en: GitFlow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitFlow is another well-known elaborate branching scheme that can deal with
    almost any situation that might arise when working with software. GitFlow describes
    creating a branch, **Develop**, of the master whenever you start work on a new
    version. **Develop** is the integration branch where you combine new features
    and do integration testing. It should only contain work that you believe is ready
    to be released.
  prefs: []
  type: TYPE_NORMAL
- en: From **Develop**, you create one or more feature branches where you start working
    on new features. Only when a feature is done do you merge that branch back to
    the **Develop** branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want to release a new version of your application, you create a release
    branch of the **Develop** branch. On the code on this branch, you perform final
    testing and perform one or more bugfixes if needed. When you are satisfied with
    the quality of the code, you merge this branch to the master and tag the version.
    You also merge these bugfixes back to **Develop**, so they will also be incorporated
    in new developments. This flow is visible in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7426e312-0862-46dc-8c0d-5d42ae0e9cec.png)'
  prefs: []
  type: TYPE_IMG
- en: If there is ever a critical bug that you need to ship as fast as possible or
    you want to do a hotfix, for this is also possible. In that case, you create a
    new branch of the master, where you fix the bug. After testing, you merge this
    branch to both master and developer—just as you would with a release branch.
  prefs: []
  type: TYPE_NORMAL
- en: Release Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Release Flow** is the branching system that is used by the Azure DevOps team
    to develop Azure DevOps. It is also based on working with short-lived topic branches
    that are made from and merged to a master branch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference is that it is not the code that is on the master branch that
    is being deployed to production. Instead, whenever a new version of the product
    needs to be released, a new branch is created of **master** with the name **release-{version}**.
    The code from this branch is then deployed to production. Once a new release branch
    is deployed, the previous one can be disregarded. This results in the following
    flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8de65f1-3cd3-42e1-a874-26b2ed6093c9.png)'
  prefs: []
  type: TYPE_IMG
- en: The advantage of this model is that it allows for taking a snapshot of the current
    state of the master branch and taking that to production. If there is ever a bug
    in production that needs to be fixed ahead of a new complete release then the
    correct commits can be merged from the master branch to the current release branch.
  prefs: []
  type: TYPE_NORMAL
- en: Trunk-based development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many companies, branching and merging are done to retain flexibility when
    releasing a new version and being able to pick changes for that version only at
    the last moment. This flexibility comes at the cost of having to merge or integrate
    your changes at some point. This cost is not only the time it takes but also the
    risks that a merge operation introduces. Merging the changes from two different
    branches that contain perfectly working software might still produce non-working
    code.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, you might consider switching to **trunk-based development**.
    In trunk-based development, you are no longer using branching for picking changes
    that go into a version. Instead, every developer on the team continuously works
    from the same branch (often the master) and only creates a short-lived branch
    for preparing one single change, which is then merged into the master branch.
  prefs: []
  type: TYPE_NORMAL
- en: When you adopt this, you will need another way to determine which changes will
    and won't yet be available to your users when releasing a new version of your
    software. You can do this by using **branching by abstraction**.
  prefs: []
  type: TYPE_NORMAL
- en: Branching by abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When branching by abstraction, you are not keeping two versions of your code
    side by side using branches, but you keep them side by side in your code base.
    For example, when you want to change the implementation of a class called `FoodClassifier`,
    which implements the `IFoodClassifier` interface, you go through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: You refactor the name of the `FoodClassifier` class to `FoodClassifierToBeRemoved`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You create a copy of the complete `FoodClassifierToBeRemoved` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You name this copy back to `FoodClassifier`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, your changes should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Please note that at runtime, your application will behave just as it did before.
    You have just added a new, yet unused, class with a change in behavior. It is
    safe to commit these changes and even ship the new binaries to a user. Now you
    can start changing the implementation of the new `FoodClassifier` class, test
    it, and establish trust in its implementation. Meanwhile, you can keep committing
    and pushing your changes, even to customers. Switching to the new implementation
    can be done using your dependency injection configuration, a Boolean flag, or
    environment variables. Just choose what makes sense in your scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Only when you are fully satisfied that the new implementation is working, you
    remove the `FoodClassifierToBeRemoved` class and update any references back to
    `FoodClassifier`.
  prefs: []
  type: TYPE_NORMAL
- en: We will expand on branching by abstraction in [Chapter 4](8ab4597a-becd-4855-9b45-89045982c14a.xhtml),
    *Continuous Deployment*, when discussing feature toggles. While being a recommended
    way forward to further accelerate your delivery, branching by abstraction is a
    double-edged sword. If you do not have a process to keep the number of side-by-side
    implementations under control and clean them up after switching implementations,
    the quality of your code base might decline.
  prefs: []
  type: TYPE_NORMAL
- en: Merging strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on the source control system you are working with, there might be
    multiple ways you can merge your changes from one branch to another.
  prefs: []
  type: TYPE_NORMAL
- en: TFVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are working with TFVC, you prepare a merge locally by choosing both
    a source and target branch and then picking the list of changes you want to merge.
    TFVC will then execute the merge and show you the changes that are the consequence
    of this merge as local changes. You can go over these changes, correct or change
    them, and must resolve any conflicts. After this, you commit the changes just
    as you would any regular change.
  prefs: []
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A merge using Git can be performed by switching to the target branch and then
    *merging* all of the changes from the source branch. If there are conflicting
    changes between the branches, you must resolve those just as you would when fetching
    new changes from the server. After merging the changes from the source branch
    and resolving any changes, you can commit the changes. This will result in a merge
    commit, which you push to the remote just as any change.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done using the visual interface of Visual Studio or VS Code, but
    also using the following sequence of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are any conflicts, you have to resolve these at this point. Otherwise,
    you cannot continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you will read in the *Securing repositories* section, it is possible to protect
    some branches by disallowing merging this way. Especially when it comes to changes
    to master, you might want to use another mechanism for merging changes, namely,
    pull requests. Using a pull request, you open a request for someone else to pull
    changes from your branch to the target branch. This way, another team member can
    first review your changes and only merge them when they meet all agreed standards.
    Others can comment on your changes or request updates before they perform the
    merge. This is the most common way of enforcing the four-eyes principle for source
    code when working with Git. The four-eyes principle says that every change or
    action should be viewed by at least two people.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when you are approving a pull request, there are different strategies you
    can use for generating the merge commit. The most commonly used are a merge commit,
    squash commit, or a rebase.
  prefs: []
  type: TYPE_NORMAL
- en: Merge commit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A regular **merge commit** is a type of commit that maintains visibility of
    all previous commits. It has a reference to two parents, showing both origins
    of the change, namely the source and target branch. This is the same type of merge
    as you can perform manually using a Git merge. The advantage of this type of commit
    is that it clearly shows where the new state of the target branch comes from.
  prefs: []
  type: TYPE_NORMAL
- en: Squash commit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When performing a so-called **squash commit**, you are combining all of the
    individual commits from the source branch in one, new commit. This is useful when
    all of the commits on the source branch relate to one feature and you want to
    keep a clear, concise change history on the target branch. Especially when there
    are commits with bugfixes or clean-up operations on the source branch, this approach
    makes sense. The disadvantage is that you might lose the rationale for some incremental
    changes that were made on the source branch.
  prefs: []
  type: TYPE_NORMAL
- en: Rebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Rebasing** a branch means that all of the commits for which your branch is
    ahead of the master branch are put aside for a bit. Meanwhile, all of the commits
    for which the master branch is ahead of your local branch are now merged to your
    local branch. Finally, all of your own commits that were set aside are now reapplied.
    The following diagram shows a branch before and after a rebase commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/595b2365-971d-4d16-a572-ed58f652768b.png)'
  prefs: []
  type: TYPE_IMG
- en: After rebasing the source branch, it is now merged into master. The advantage
    of this kind of merge is that you retain all individual changes in one single
    commit history.
  prefs: []
  type: TYPE_NORMAL
- en: Managing repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working in Azure Repos, every team project can have a maximum of one TFVC
    repository. However, when working with Git, you can have multiple repositories
    in the same team project. A discussion that is gaining more attention lately is
    that of having a single repository for all applications or a repository per application.
    Other topics that are important when managing repositories are creating and removing
    repositories, securing them, and setting policies on them.
  prefs: []
  type: TYPE_NORMAL
- en: Monorepo or multi-repo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are using a **monolithic repository** (**monorepo**) when you are storing
    all of the code of all of your projects and applications in one single source
    control repository. Opposed to this, you might be using multiple repositories
    where every application, library, or project is stored in its own repository.
    Both approaches have their own pros and cons and both approaches are used by companies
    from small to large.
  prefs: []
  type: TYPE_NORMAL
- en: 'Possible advantages of a monorepo can include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Easier reuse of existing code: If all of the code is in a single repository,
    it is accessible by and visible to everyone. This means that the chances of reuse
    are increased.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having all applications in one repository also means that any change affecting
    more than one application can be made in a single commit, in a single repository.
    A typical example is an API change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all of the code being accessible to and maintained by everyone, there is
    less chance that a developer or team claims a specific repository as its own.
    This encourages learning from each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Possible advantages of multiple repositories include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A monorepo can become very, very large, even up to the point that developers
    checkout or clone only part of the monorepo. This effectively defeats most of
    the advantages of a monorepo.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having one repository with all of the code encourages tight coupling between
    components or applications. If you have multiple repositories, you could update
    an API and release it under a new version and upgrade clients one by one. In a
    monorepo, you might be tempted to upgrade the API and change all of the consumers
    in one commit, with all of the risks attached.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which approach works best for you is influenced not only by the advantages and
    disadvantages discussed but also by the background and makeup of your team and
    organization. If you have a single team doing all the development for internal
    applications, a monorepo might make more sense. If you have multiple teams working
    on different applications for different clients, multiple repositories make more
    sense.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and removing repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Azure DevOps, you can have multiple Git repositories per team project. Try
    doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, visit the Manage repositories interface. The following screenshot shows
    how to access this interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/de6970e8-edd4-457c-b66f-89a777610ba4.png)'
  prefs: []
  type: TYPE_IMG
- en: After opening this interface, a new interface (as shown in the following screenshot)
    opens up. Here, you can add new repositories by clicking on the Add... button
    with a plus sign (marked with a **1** in the following screenshot) and filling
    out a repository name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repositories can also be removed, by clicking on their name and then Delete
    (marked with a **2**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c987591b-c267-4c71-877b-2b3d5e69c640.png)'
  prefs: []
  type: TYPE_IMG
- en: Removing repositories is not something that is often done. It might make more
    sense to make a no-longer-used repository read-only or remove all authorizations
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's learn how to secure the repositories that we create.
  prefs: []
  type: TYPE_NORMAL
- en: Securing repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the security options with distributed source control are often not as
    broad as with centralized source control, Azure Repos offers some means to set
    authorizations on a repository or a server-side branch. In the last image of the
    previous section, you can also see how you can select a group or user in the middle
    column and then update the authorizations on the repository. By default, all authorizations
    are inherited from project defaults.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to only change authorizations a little as possible and if
    you do, it is often best to work via groups and allow authorizations.
  prefs: []
  type: TYPE_NORMAL
- en: You can also change the authorizations for a specific branch by opening the
    repositories branches in the drop-down menu on the left and clicking on the branch
    you want to override the authorizations for. In the preceding screenshot, this
    is marked with a 3.
  prefs: []
  type: TYPE_NORMAL
- en: Branch policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, it is possible to enforce one or more policies on pull requests to
    a specific branch. The interface for branch policies is shown in the following
    screenshot and can be accessed by choosing the Branch policies option while managing
    the authorizations on a repository branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c771726d-de8f-4b41-9154-a27ab3ed81ef.png)'
  prefs: []
  type: TYPE_IMG
- en: The first four checkboxes are related to default policies that can be enabled
    (or not) on your preference. By default, they are all disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Build validation can be used to disallow the merge of any pull request if one
    or more of the select builds have not completed successfully. How to set up such
    a build is something you will learn in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Next to builds, you can also call external services to inspect the pull request
    and to allow or disallow it. An often used integration here is with a code quality
    tool. You might also call your own APIs here, to enforce team agreements on things
    such as pull request titles, relation to work items, or more complex constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can enforce that a specific user or group has to be included in
    the review of a pull request. This might be needed to enforce a specific level
    of quality, but it can also be a limiting factor on your development speed and
    hence flow.
  prefs: []
  type: TYPE_NORMAL
- en: Other tools for source control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next to the source control systems available in Azure Repos, there are also
    some other well-known systems that you should know about:'
  prefs: []
  type: TYPE_NORMAL
- en: GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitLab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll go over each of these in the upcoming subsections.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**GitHub** is a hosted source control provider that delivers hosted Git repositories.
    GitHub allows anyone to create as many publicly visible repositories as they want.
    Only, when you create private repositories that require three or more contributors,
    you must switch to a paid subscription.'
  prefs: []
  type: TYPE_NORMAL
- en: This model that allows unlimited, free usage of the platform if developing in
    public has made GitHub, by far, the largest host of open source software in the
    world.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub was acquired by Microsoft in 2018 and since then, Microsoft and GitHub
    have worked together to create a great integration experience between GitHub repositories
    and Azure DevOps, specifically with Azure Boards and Azure Pipelines. In addition
    to this, Microsoft has stated that GitHub and Azure Repos will continue to exist
    next to each other and that there are currently no plans to terminate one of the
    products in favor of the other.
  prefs: []
  type: TYPE_NORMAL
- en: There is also an on-premises offering by GitHub called GitHub Enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: GitLab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitLab is another platform that delivers hosted Git repositories. Just like
    Azure DevOps, source control hosting is one of the services it provides.
  prefs: []
  type: TYPE_NORMAL
- en: Subversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An older source control system is Subversion. Subversion was developed and first
    used in 2004 and is maintained by the Apache Software Foundation. Subversion is
    a centralized source control system that supports all the features that you would
    expect of such a system.
  prefs: []
  type: TYPE_NORMAL
- en: There are many false arguments as to where Subversion would be inferior to Git,
    however, most of them are not true for more recent versions of Subversion. The
    reality is that Subversion is a widely used type of source control system that
    performs well, especially for very large repositories or repositories that have
    very specific authorization needs.
  prefs: []
  type: TYPE_NORMAL
- en: While Azure DevOps cannot host Subversion repositories, it can connect to, and
    work with, sources that are stored in Subversion.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you have learned about source control. We saw that there are
    two types of source control: centralized and decentralized, both supported by
    Azure DevOps. TFVC is no longer recommended for new projects. You should use Git
    whenever starting a new project.'
  prefs: []
  type: TYPE_NORMAL
- en: When using Git, you can have more than one repository in your team project.
    Per repository, you can assign policies to lock down specific branches and enforce
    the four-eyes principle. You have also learned about access control and how to
    provide users access to one or more repositories. Finally, you have learned about
    alternative tools and how to migrate sources from one tool to the other.
  prefs: []
  type: TYPE_NORMAL
- en: You can use what you have learned to make decisions on which type of source
    control system to use in your products. You can now professionally organize the
    repository or repositories you work in. You are now able to work with different
    branching strategies and use policies for enforcing security or quality requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will take what you have learned about source control and use
    that to set up continuous integration.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the Appendix:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the differences between centralized and decentralized source control
    and which work best in what situation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: Git is an example of decentralized source control.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is not a common branching strategy?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Release Flow
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Rebasing
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: GitFlow
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: GitHub flow
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Many companies want a code review to be performed before code is merged into
    the master branch. What construct is used to do so when working with Git and how
    can this be enforced in Azure DevOps?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following are not valid merge strategies?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rebasing
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Trunk-based development
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Merge commit
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Squash commit
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More information about working with Git can be found at [https://docs.microsoft.com/en-us/learn/paths/intro-to-vc-git/](https://docs.microsoft.com/en-us/learn/paths/intro-to-vc-git/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The original Microsoft advice on TFVC versus Git can be found at [https://docs.microsoft.com/en-us/azure/devops/repos/tfvc/comparison-git-tfvc?view=azure-devops&viewFallbackFrom=vsts](https://docs.microsoft.com/en-us/azure/devops/repos/tfvc/comparison-git-tfvc?view=azure-devops&viewFallbackFrom=vsts).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about Git LFS can be found at [https://docs.microsoft.com/en-us/azure/devops/repos/git/manage-large-files?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/repos/git/manage-large-files?view=azure-devops).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instructions for downloading Git LFS can be found at [https://git-lfs.github.com/](https://git-lfs.github.com/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about migrating to Git can be found at [https://docs.microsoft.com/en-us/azure/devops/repos/git/import-from-TFVC?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/repos/git/import-from-TFVC?view=azure-devops).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Atlassian tool for converting an SVN repository to a local Git repository
    can be found at [https://www.atlassian.com/git/tutorials/migrating-convert](https://www.atlassian.com/git/tutorials/migrating-convert).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about GitFlow can be found at [https://datasift.github.io/gitflow/IntroducingGitFlow.html](https://datasift.github.io/gitflow/IntroducingGitFlow.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about GitHub flow can be found at [https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release Flow is described in more detail at [https://docs.microsoft.com/en-us/azure/devops/learn/devops-at-microsoft/release-flow](https://docs.microsoft.com/en-us/azure/devops/learn/devops-at-microsoft/release-flow).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trunk-based development is discussed at [https://trunkbaseddevelopment.com/](https://trunkbaseddevelopment.com/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about GitLab can be found at [https://about.gitlab.com/](https://about.gitlab.com/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about Subversion can be found at [https://subversion.apache.org/docs/](https://subversion.apache.org/docs/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
