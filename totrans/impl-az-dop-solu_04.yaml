- en: Moving to Continuous Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After setting up source control for your organization and deciding on a branching
    and merging strategy that supports parallel work, you are ready to move on to
    continuous integration. Continuous integration is a method where every developer
    takes their work and integrates it with the work of others, and then verifies
    the quality of the combined work. The value of this is an increase in quality
    early on in the pipeline. This reduces the risk of error later on when merging
    code changes and reduces the number of bugs that are found in production, thereby
    reducing costs and protecting your reputation.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration is only possible when you have the proper setup with
    the necessary tools. In this chapter, you will learn how to use Azure DevOps pipelines
    to set up continuous integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing continuous integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a build definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with YAML pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agents and agent queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To go through the recipes that are covered in this chapter, you will need an
    Azure DevOps organization.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous integration **is a methodology where you integrate your own changes
    with those of all of the other developers in your project and test whether the
    combined code still works as expected. This way, you create a fast loop that provides
    you with feedback on your work.'
  prefs: []
  type: TYPE_NORMAL
- en: When working with extensive branching strategies for isolating code changes,
    it is not uncommon for one or more developers to work for days, weeks, or even
    months on an isolated branch. While this is great for making sure that their changes
    do not disrupt others, it is also a great way to make sure that there won't be
    merge issues later. If you have ever had to merge weeks or months of work back
    into a master branch, you will know how much work is involved and how often this
    results in bugs or other issues.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this, developers should make it a habit to integrate their changes
    with those of all the other developers at least once a day. Here, integrating
    means at least merging, compiling, and running unit tests. This way, there is
    a constant stream of feedback on the quality of the developer's changes and since
    this feedback is combined, it is a great way to prevent merge issues later.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration also enables you to embed other concerns in your pipeline
    to automatically preserve the quality of your code. Testing and security scanning
    are two prime examples of this. These topics are discussed in later chapters,
    but a good continuous integration pipeline is the basis for these practices.
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of this chapter, you will learn about the technical means to set
    up continuous integration using Azure Pipelines. But first, let’s look at a common
    misconception and the four pillars of continuous integration.
  prefs: []
  type: TYPE_NORMAL
- en: While an automated continuous integration build is an important ingredient for
    performing continuous integration, continuous integration entails more than just
    having a build pipeline. The important thing to remember is that continuous integration
    is a process where every developer integrates their work with that of their colleagues
    at least daily. Then, the integrated sources are compiled and tested. The value
    comes from compiling and testing the integrated work, not the isolated work.
  prefs: []
  type: TYPE_NORMAL
- en: The four pillars of continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are four pillars that underpin the successful adoption of continuous
    integration:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A version control system**:Used for storing all of the changes made to a
    system since its inception. Version control systems were discussed in the previous
    chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A package management system**:Used to store the binary packages that you
    use in your own application and the packages that you create. This will be discussed
    in detail in [Chapter 5](d4208d51-c982-414f-9e96-17f14e084b90.xhtml), *Dependency
    Management*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A continuous integration system**: A system that can pull the changes of
    all developers together—several times a day—and create one integrated source version.
    This can be done using Azure DevOps pipelines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An** **automated build process**: Used to compile and test the combined sources.
    We will look at how to implement this process using Azure DevOps Pipelines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration and automated builds can be set up in Azure DevOps. The
    next section explains how to set both up in Azure DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a build definition in Azure DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main way to perform continuous integration is by using a continuous integration
    build. In Azure DevOps, builds can be configured as part of the Azure Pipelines
    offering. There are currently two approaches available for creating a build definition:'
  prefs: []
  type: TYPE_NORMAL
- en: Via the visual designer (also called **classic builds and releases**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through **Yet Another Markup Language** (**YAML**) files (also called **YAML
    pipelines** or **multistage pipelines**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of this section focuses on the visual designer. The following section,
    *YAML build definitions,* will go into more detail about YAML pipelines. Both
    approaches support roughly the same capabilities, although there are some differences.
    Some features that are available in classic builds and releases are not (yet)
    available in YAML build definitions. Also, some new features are only provided
    to YAML pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: If you have no experience with pipelines, the classic editor is a good way to
    get familiar with the workings of continuous integration/continuous development
    pipelines before moving on to YAML pipelines. Almost all of the concepts in classic
    builds translate to YAML builds as well.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will start by building a classic build pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to source control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started with a build definition, follow these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Pipelines menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From this menu, click on Builds. Here, you will be presented with a button
    to create a new build. After clicking on this button, a new view for creating
    a build will open, as in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c10e2393-4fe8-4c11-b088-ae6ba067d483.png)'
  prefs: []
  type: TYPE_IMG
- en: You will then be guided to the new YAML experience, but you can still opt to
    go back by choosing the classic editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After choosing the classic editor, you can configure how to connect to the source
    control. The classical editor is the editor that is visible in all of the screenshots
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Many source control systems are supported. If you are working with a hosted
    Git repository, pick your specific product, if available, and only choose Other
    Git if your product is not available; currently, GitHub, GitHub Enterprise Server,
    and BitBucket Cloud are supported. The reason for this is that continuous integration
    using Other Git works by using a polling model, where all the specific products
    use their known integration webhooks. The following example works with a Git repository
    that is in the same Azure DevOps instance.
  prefs: []
  type: TYPE_NORMAL
- en: When you select the Pipeline header, you can set the name of the build definition
    and select an agent pool that the phases will run on by default. Agents take care
    of the actual execution of your tasks and will be looked at in more detail in
    the A*gents and agent queues *section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Below the Pipeline header, you can see the chronological layout of your build
    definition. First up is downloading sources. Here, you can once again choose to connect
    to a source control system. You can also specify more advanced settings that relate
    to the way sources are fetched, such as whether to clean the build directory first,
    select a branch, or add tags.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a job
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Below the source''s node, you can add one or more jobs that will perform the
    bulk of the work that you want to perform. Jobs can be added using the ellipsis
    on the pipeline header. There are two types of jobs available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Agentless jobs**: Agentless jobs can be used to run tasks that need an agent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Agent jobs**: Agent jobs are used to run tasks that require an agent to run
    on, which is the case for the bulk of the tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some examples of agentless tasks are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for manual approval before continuing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting a delay before proceeding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling a REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling an Azure function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main benefit of an agentless job is that it does not keep an agent occupied
    while running. This frees the agent up to do other work, meaning that you need
    fewer agents, which can save costs. Also, the number of agents that you can use
    concurrently is governed by the number of parallel pipelines that you have bought
    in Azure DevOps. Limiting the number of agent jobs will save money here as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go over the process of configuring a job:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select any job. You will see the view shown in the following screenshot. In
    this view, you can change the name of the job and, for agent jobs, override the
    agent pool to execute this job on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dbfbf685-df22-4f4a-8332-f907f1f10e16.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, specify which agent pool to use for running the job. Here, it also specifies
    the demands that you have of the agent that will execute this job. Demands will
    be discussed in the *Agents and agent queues *section of this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As part of the execution plan for an agent, you can specify Parallelism and
    choose one of three options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'None: This will just execute all the tasks you add to the agent job one after
    another on the same agent.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multi-configuration: Here, you can specify a series of variables that determine
    the number of variations of the build to run. This is useful if you want to create,
    for example, x86 and x64 builds from the same code.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multi-agent: Here, you can specify the number of agents that will run the same
    tasks in parallel.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, you can specify one or more dependencies. These are the other jobs that
    need to be completed before the selected job runs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, for any job, you can specify how to cope with errors in previous jobs
    by telling it to continue or stop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As an alternative to steps 3 and 4, you can also specify a custom expression
    to specify whether a job should run. This expression should evaluate to a Boolean
    and support rudimentary operations, such as `or()`, `and()`, or `eq()`. The following
    is an example condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This condition specifies that the job will only run when all previous jobs have
    succeeded and the build is not started from the master branch. A link to a detailed
    description of the conditions syntax is included at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Agentless jobs have fewer options available than agent jobs. For example, it
    is not possible to execute the same build for multiple variable values in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Adding tasks to your job
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After adding one or more jobs, you can add tasks to a job. Tasks define the
    actual work that is to be done during the execution of your build. The following
    screenshot shows you how to add a task and then configure it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the plus sign next to the job you want to add tasks to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8c704d41-483e-45bc-8f2c-68655f5c9339.png)'
  prefs: []
  type: TYPE_IMG
- en: You will then be presented with a task picker, where you can find any task that
    matches your search input and add one or more tasks by clicking the Add button.
    A new screen will then open, where you can configure the individual task. The
    options provided here differ for each task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There can be multiple versions of a task and you can switch between the major
    versions of the task. This means that the maintainer can push non-breaking updates
    and you will receive them automatically. Major or breaking updates can be pushed
    with a new major version number and you can upgrade them at your own discretion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is possible to add as many tasks as needed to a pipeline job.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing build artifacts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important part of a build definition is its outcomes. Builds are often used
    to produce one or more artifacts that are later used for the deployment of an
    application. Examples of artifacts can be executables or installer files. These
    files need to be made available for use after the pipeline has completed.
  prefs: []
  type: TYPE_NORMAL
- en: The Publish Build Artifacts task that is shown in the preceding screenshot is
    a task that is specifically designed to do this. It allows you to select a file
    or directory and publish it under an **artifact name**. The result of this is
    that the file(s) in the selected path is retained with every execution of the
    pipeline for manual download or use in a release definition later. Release definitions
    are discussed in the next chapter, [Chapter 4](8ab4597a-becd-4855-9b45-89045982c14a.xhtml), *Continuous
    Deployment*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll learn how to integrate our pipeline with other tools and configure
    our service connection.
  prefs: []
  type: TYPE_NORMAL
- en: Calling other tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building pipelines, we will often need to integrate them with other tools.
    For source control systems, this is part of the flow when creating a pipeline
    and you are limited to the built-in options. For tasks, you can create references
    to any tool or location you want using service connections. An example of a task
    that uses a service connection to an Azure app service is shown in the following
    screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'A service connection is a pointer to a third-party system, with a name and
    series of properties that differ for each type of service connection. Often, you
    will need to put in a URL to locate the other service and a mechanism for authentication.
    The following steps will help you configure your service connection:'
  prefs: []
  type: TYPE_NORMAL
- en: 'After defining one or more service connections, you can select the one to use
    from a drop-down menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a9ec689c-480f-4b57-9997-338d77913f41.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Service connections are managed in a central location as project settings.
    You can access them by going to the management view directly from the task you
    are currently configuring, as shown in the preceding screenshot. You can also
    do this by navigating to Project Settings and then to Service connections, as
    in the following screenshot (see label 1):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8b676478-8d5d-4587-af5b-e32622d6e7c5.png)'
  prefs: []
  type: TYPE_IMG
- en: In this view, you can then either add a new service connection or update an
    existing service connection (see label 2 in the preceding screenshot).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, service connections are scoped to the project level, meaning they
    are not available for everyone in the Azure DevOps organization. To encourage
    the reuse of service connections, Azure has made it possible to share them between
    projects since mid-2019.
  prefs: []
  type: TYPE_NORMAL
- en: Task Marketplace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A set of frequently used tasks is built into Azure Pipelines; however, there
    are even more available using the Visual Studio marketplace for Azure DevOps.
    If you are an administrator, you can find and install extensions that add tasks
    here. If you are a regular user, you can find tasks here as well; however, you
    cannot install them, only request them. Your Azure DevOps administrator will then
    be notified and can install the extension on your behalf if they approve.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can write and distribute extensions with tasks of your own as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Creating variables and variable groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are configuring your build, there might be values that you need to
    use more than once. It is often wise to extract these values into variables, rather
    than just repeating those values throughout your tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Variables can be used to note down values that you do not want to have stored
    in source control. Values such as passwords and license keys can be safely stored
    as non-retrievable values when locked down using the lock symbol (see label 1
    in the following screenshot). After saving the build definition, these values
    are encrypted and can only be used by the build that they belong to. You will
    no longer be able to retrieve these values and they will be automatically scrubbed
    from logs and other output.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn how to work with variables in Azure Pipelines, go through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Azure Pipelines, you can add variables to your build definition by going
    to the Variables | Pipeline variables tab (see label 3 in the following screenshot).
    Here, you can enter them as name value, as can be seen in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6b846c91-0699-48ed-9598-e17df94d08ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once defined, you can use the variables in the configuration of all tasks in
    all jobs of the same build. For this, you can use the following notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you can mark variables as Settable at queue time (see label 2 in the
    preceding screenshot), which means that their value can be changed whenever someone
    queues a new build. An example of a variable for which this is used is the `system.debug`built-in
    variable*.* When this variable is set to `true`, there is a verbose debug logging
    included in the build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next to your own variables, system variables are also defined. These are variables that
    contain information about the build that is currently running, including version
    numbers, agent names, build definition details, the source version, and so on.
    A link to the full list of system-defined variables is included at the end of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Variable groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As well as creating the variables that go with a specific build, you can create
    variable groups. These variable groups can, in turn, be linked to one or more
    builds. This is an effective way of sharing variables between builds; some examples
    of these might be the name of your company, trademark texts, product names, and
    so on. Let''s see how we can work with variable groups:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Access variable groups through the menu by clicking on Library in the Pipelines
    menu (see label 1 in the following screenshot). This displays a list of the existing
    variable groups that you can edit and you can add a new group here as well, as
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bdfdd678-3ed2-46ae-ab48-089def21a003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, you can work with variables in the same way that you would with the variables
    that come with a build. The only differences are highlighted in the following
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You cannot mark variables in a group as settable at queue time.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can allow or deny the use of this group in all pipelines. If you deny their
    use in all pipelines, then only you can use the variable group. You can authorize
    other users or groups through the Security option (labeled with a 2 in the preceding
    screenshot).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can reference an Azure key vault for which this variable group will act
    as a placeholder. After logging into Azure, you can select a key vault and select
    which values that are stored in the key vault you want to be accessible through
    the variable group.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Key Vault** is an Azure offering that can be used for the secure storage
    of secrets. Secrets in a key vault are automatically versioned, so older values
    are not overwritten but replaced by a newer version. In addition to this, you
    can specify segregated access policies that specify, per user, whether they can
    read, write, update, or delete values. All these actions are audited in a key
    vault, so you can also find who has made which change. If you are linking Azure
    DevOps to a key vault, then a new service principal will be created in your active
    directory that has access to that key vault. Now, whenever Azure DevOps needs
    a variable from the variable group, the actual values will be pulled from the
    key vault.'
  prefs: []
  type: TYPE_NORMAL
- en: Variable groups can be linked to the variables of a build under the Variable
    groups tab (refer to the screenshot in the previous section).
  prefs: []
  type: TYPE_NORMAL
- en: As well as working with variable groups, you can also work with files in the
    library. You can upload files that are not accessible by other users but that
    can be used within a build. This is useful for files with private keys, license
    keys, and other secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Just as you can with variable groups, you can specify whether each secure file can
    be used by any build or authorize specific users only.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering the build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next tab in a build definition governs what should start or trigger the
    build. To implement continuous integration, go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Triggers tab and select the first header on the left:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1ab8338e-bef1-4f04-a865-8e642484a3d9.png)'
  prefs: []
  type: TYPE_IMG
- en: Check the Enable continuous integration box. This means that Azure DevOps will
    listen for changes in your repository and will queue a new build as soon as a
    new chance is available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you can choose whether you want to build every incoming change individually
    or batch multiple changes when more than one new change comes in while building
    a change. It is recommended that you build every single change separately if this
    is feasible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Along with the continuous integration trigger, specify one or more branch and
    path filters. Here, you can specify which branches and files to queue a new build
    for. You can specify either inclusions or exclusions, depending on your needs.
    A common example is to limit your build to the master branch. If you have folders
    named `doc` and `src` in your repository and all your sources are in the latter
    folder, then it might make sense to limit the trigger to this path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As well as choosing to have a continuous integration trigger, you can also opt
    to execute a build on a recurring schedule where you select one or more weekdays
    and a time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also schedule a build to run whenever another build completes. This
    is called **chaining** builds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let's learn how to change the configurations of our build definition.
  prefs: []
  type: TYPE_NORMAL
- en: Build options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can change the advanced configuration options for your build definition.
    These options include a description, the format of the build number, and the automated
    creation of work items on failures and times. To set this up, go through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Options tab. You should arrive at the following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8745ab6a-1703-48e0-b913-9dba0d108273.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, create your build number format. If this field is left empty, then the
    build number for your application will be set to an ever-increasing number that
    will increase by 1 with every build. This number is unique within a team project
    and counts over all the build definitions. You can also specify a format of your
    own using the variables available to you. A common approach is to specify a major
    and minor version number manually and then add an increasing number using a variable.
    The following example specifies a version of 4.1.xx, where the last part is replaced
    by a two-digit increasing number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: On the right, there are advanced (but rarely used) options for specifying the
    authorization scope for the Build job time-outs for each job in the build definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is also possible to specify the agent demands that every agent, for every
    job in the build definition, should fulfill. Again, we will look further at demands
    in the *Agents and agent queues* section of this chapter*.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other options on the left enable you to suspend the pipeline temporarily.
  prefs: []
  type: TYPE_NORMAL
- en: Build history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final tab, called History, shows you a list of every change that has been
    made to the build definition. Build definitions are stored in JSON format and
    you can pull up side-by-side comparisons for every change. The comment that you
    put in when saving a build is also stored here and can be used to provide the
    rationale for a change.
  prefs: []
  type: TYPE_NORMAL
- en: Since builds are an important means of preserving quality, it is important to
    keep track of who has changed them to ensure that automated quality metrics are
    not removed.
  prefs: []
  type: TYPE_NORMAL
- en: With this, you are now ready to run your first build. You can directly run it
    using the Save & Queue button that is visible in most of the screenshots in this
    section. The *Running a build* section of this chapter will teach you how to work
    with the results that you obtain.
  prefs: []
  type: TYPE_NORMAL
- en: Task groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working in a team or organization that has more than one pipeline, it often
    doesn't take long before multiple pipelines that take the same shape emerge. For
    example, in some companies, all pipelines contain tasks for security scanning,
    running tests, and calculating the test coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of repeating these tasks everywhere, they can be extracted from an existing
    pipeline into a task group. Task groups, in turn, can be used within multiple
    pipelines as if they are tasks themselves. Doing this reduces the effort needed
    to create a new pipeline or update all the pipelines with a new requirement. Doing
    this also ensures that all the pipelines using the task group have the same task
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new task group, open any existing build definition and go through
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6cadb314-e51b-4e8f-a492-4dc7dbdfc74f.png)'
  prefs: []
  type: TYPE_IMG
- en: Select one or more tasks by clicking on them while holding down *Ctrl*, or by
    using the selectors that appear when hovering the mouse over a task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the selection and select Create task group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the popup that now appears (not shown in the screenshot), choose a name,
    description, and category for the task group. If any of the selected tasks have
    a variable value specified, you can now provide a default value and description
    for these parameters. These parameters will be available within the task group
    and need to be configured when the task group is used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After clicking Create (not shown in the screenshot), the existing build definition
    is updated by removing the selected tasks and replacing them with the new task
    group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding an already existing task group to a build or release definition is done
    in precisely the same way as adding regular tasks. Task groups show up in the
    same list of tasks to choose from.
  prefs: []
  type: TYPE_NORMAL
- en: A list of all the existing task groups can be found by navigating to the Pipelines
    menu and then Task groups. To edit an existing task group, select it in the list
    that is shown, and select the Edit option. Editing task groups works in precisely
    the same way as editing a build definition.
  prefs: []
  type: TYPE_NORMAL
- en: This section was all about creating a build definition and describing how an
    application should be built. The next section is about executing the build.
  prefs: []
  type: TYPE_NORMAL
- en: Running a build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to work with the build results and use them
    to report and generate builds. You will also learn how to run a build with every
    pull request and report the quality of the changes back to that pull request to
    assist the reviewer.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the build results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While a build is running, an agent will perform all the configured steps one
    by one. Azure Pipelines will capture detailed information and logs from all these
    steps. As you can see in the following screenshot, a build will display a list
    of all the steps it has executed on the left. Clicking on any of these steps will
    open a detailed view that displays the logs per step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4147fb46-d394-4aa6-9413-c6f24dd82f74.png)'
  prefs: []
  type: TYPE_IMG
- en: Whenever there are warnings or errors during the build, they show up in orange
    or red, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Building a pull request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After setting up your build definition and running your first builds, you might
    also see the first failures coming in—for example, when someone accidentally commits
    and pushes changes that do not compile or contain unit tests that do not run successfully.
    You can prevent this by having a build definition run automatically whenever a
    pull request comes in. To configure this, go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on Policies under Project Settings. The following screen will open. Click
    on Add build policy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/26a16b99-d5cc-41a7-a202-029d9db74fc0.png)'
  prefs: []
  type: TYPE_IMG
- en: Select a build definition that you want to use to validate the pull request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, there will be three more things that you can configure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Trigger: When the build definition should start, either automatically or manually.
    Of course, the real value comes from running a verification build automatically.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Policy requirement: This determines whether a pull request can be completed
    if the build fails. In other words, this determines whether you can ignore a failing
    build. It is recommended that you avoid setting this to Optional, if possible.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Build expiration: This determines how long a positive build result is valid
    for. The default value is `12` hours, but you should consider changing this to
    Immediately when master is updated. The advantage of this is that you cannot merge
    changes without first running the build against a combination of the current state
    of the branch that you will merge to and the proposed changes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can add more than one build policy. If you have a lot of things that you
    can automatically validate and want to keep automated validation times to a minimum,
    then this is a good approach.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing build artifacts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As well as compiling, testing, and validating your source code, builds can also
    be used to generate what are called artifacts. Artifacts are the outputs from
    a build and can be anything that you want to save and publish from a build, such
    as test results and application packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'An application package is intended to be an immutable build of a version of
    your application. This package can later be picked up in a release and deployed
    to one or more environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c26cc7c-4394-41bd-ab9d-ea72dfed90ae.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can see, as part of the summary of an executed
    build, that there were two artifacts published. Artifacts can be accessed from
    either the Artifacts drop-down menu at the top-right corner of the screen or from
    the Summary tab. You can download and explore artifacts from this page and, in
    the next chapter, you will see how to work with them to set up continuous delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Great! With this, you have learned how to create a definition using the visual
    designer. But wait—as we mentioned earlier, there is another way of doing this,
    which is by using YAML files. Let's see how this works in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with YAML pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have seen how to create a build definition using the visual designer. A
    new, alternative approach, which has been available since early 2019, is the use
    of YAML pipelines. When working with YAML pipelines, you specify your complete
    build definition in a YAML file and store it in source control, often next to
    the source code that the build is for.
  prefs: []
  type: TYPE_NORMAL
- en: While both pipeline systems coexist, using YAML pipelines is now the preferred
    approach for defining pipelines. This means that it is very likely that new features
    will only surface in YAML pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for using build definitions as code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you first start working with YAML build definitions, you might find that
    the learning curve is steeper than it is when working with the visual designer.
    This might raise the question as to why you would use YAML-defined builds. There
    are two main advantages that YAML build definitions have over visually designed
    definitions.
  prefs: []
  type: TYPE_NORMAL
- en: When you are writing your definition in YAML, it can be hosted in source control
    next to your code. The consequence of this is that all the policies that you have
    in place for changing source control now automatically apply to your build definition.
    This means that any change must go through a pull request, be reviewed by a peer,
    and can be built and verified ahead of time. Enforcing the **four-eyes principle**
    on your build definition, as well as your code, increases the stability of your
    build process. Of course, it also benefits security and compliance, topics that
    will be discussed in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: As well as this increase in security, having the build definition in source
    control also means that it is available in every branch. This means that it can
    be changed in every branch to build that specific branch before merging it to
    the master branch. When working with a visually designed build definition, this
    single definition is responsible for building not only your master branch but
    also all the branches that you want to merge through a pull request.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that you must do one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the build definition for the change that you will merge. However, this
    will terminate building of the current state of the master branch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merge the change, which will also result in a broken build since the build definition
    has not yet been updated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either option has the risk of allowing faulty changes to flow through the target
    branch, defeating the purpose of a continuous integration build. With a build
    definition per branch, we eradicate this problem.
  prefs: []
  type: TYPE_NORMAL
- en: While having build definitions in source control is beneficial, this is also
    available in classic builds. Every change is recorded and you can see who has
    changed what and when, along with an optional explanation from the author of the
    change.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a basic YAML pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started with YAML builds, there are two things you need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to write your YAML file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, you need to create a build definition out of it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the YAML file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code sample contains an example YAML definition for building
    a .NET Core application and running unit tests. Save a file with any name, for
    example, `pipeline.yaml`, in any Git repository in Azure DevOps. Then, it can
    be used to create a pipeline out of it later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This example YAML defines a basic pipeline. Every pipeline needs to be triggered
    in some way. Just as with classic builds, this can be done by connecting the pipeline
    to a change in a source code repository. The default repository for this is the
    repository that also contains the YAML definition. The `trigger` keyword is used
    to specify a push to which branches should trigger the pipeline. A good starting
    point is the `master` branch. As the `trigger` keyword accepts a list, multiple
    branches can be specified and wildcards can be used.
  prefs: []
  type: TYPE_NORMAL
- en: A trigger is not mandatory as a pipeline can also be started manually.
  prefs: []
  type: TYPE_NORMAL
- en: There are also alternative options to using the `trigger` keyword, such as to
    include or exclude one or more branches, tags, or paths in the repository. These
    options are described in detail at [https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema#triggers](https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema#triggers).
  prefs: []
  type: TYPE_NORMAL
- en: As well as a trigger, every pipeline contains one or more tasks, just as in
    classic build definitions. All these tasks need to execute on an agent pool—again,
    just as in classic build definitions. The `pool` keyword is used to specify a
    set of key/value pairs that determine which pool the tasks will run on by specifying
    the name of the pool. When working with the default agents that Microsoft provides,
    the default name of `Azure Pipelines` can be used. When using this specific pool,
    a VM image has to be specified. This determines which operating system and what
    software is available on the agent that will execute the task.
  prefs: []
  type: TYPE_NORMAL
- en: An up-to-date list of all the VM images that are available can be found at [https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/hosted#use-a-microsoft-hosted-agent](https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/hosted#use-a-microsoft-hosted-agent).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the definition contains a list of the steps that make up the pipeline
    itself. These steps correspond one-to-one with the tasks that you could drag into
    a classic build pipeline. A task is added by specifying the name and version—separated
    by the `@` sign—of the task that you want to run. Next, you can optionally specify
    a display name for the task. This display name will later be visible in the views
    that show the results of an executed pipeline. Finally, specify one or more inputs
    for the task. These inputs relate to the task-specific configuration that you
    have already seen for the visual designer.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a YAML pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After saving your YAML file in a repository, you can create a build definition
    from it. When creating a new build definition (see the *Creating a build definition* section of
    this chapter), you should go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose the Azure Repos Git YAML option when the wizard starts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From here, go through the wizard to select and review the YAML you want to
    build, as in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/83bd90aa-8c2b-4693-b350-2524c05755be.png)'
  prefs: []
  type: TYPE_IMG
- en: In the first step, you locate the repository that contains the YAML file that
    you want to use as your pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you configure the pipeline by choosing an example YAML file to start from
    or by referring to an already existing file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, you can review the YAML file that you have selected and start a build
    from it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your pipeline is saved automatically. Once the pipeline is saved, it can be
    started and you can interact with it in the same way as you would with classic
    build pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-job pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The pipeline you saw in the previous section does not specify any jobs, as
    you may recall from the section on classic builds. Instead, it contains a list
    of tasks under the `steps` keyword. This means that it implicitly contains only
    a single job. With YAML pipelines, it is also possible to create a definition
    that contains more than one job. To do this, the following structure can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Instead of adding the `steps` keyword directly to the pipeline, first, a list
    of jobs is created. Within that list, one or more `job` keywords are added, followed
    by the name for that job. Next to this technical name, a display name (`displayName`)
    can be specified for each job.
  prefs: []
  type: TYPE_NORMAL
- en: As the second job in this example shows, it is also possible to specify which
    agent pool to use per job. When no pool is specified for a job, the default pool
    specified at the top of the file is used.
  prefs: []
  type: TYPE_NORMAL
- en: The jobs that are discussed in this section are called agent jobs. Besides agent
    jobs, there are also server jobs, container jobs, and deployment jobs available.
    More information about these types of jobs can be found at [https://docs.microsoft.com/en-us/azure/devops/pipelines/process/phases#types-of-jobs](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/phases#types-of-jobs).
  prefs: []
  type: TYPE_NORMAL
- en: By default, all the jobs in a pipeline run in parallel, but there are control
    options available to change this.
  prefs: []
  type: TYPE_NORMAL
- en: Control options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To control the order of jobs, the `dependsOn` keyword can be used on the definition
    of a job. This signals that the job can only be started after one or more jobs
    are completed. Besides this, the `condition` keyword can be used to specify a
    condition that a job should run under. These two keywords can be combined to realize
    more complex scenarios, such as the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This pipeline will start by running the job named `compile`. Once this job completes,
    the next two jobs, `test` and `build_schema`, will run in parallel as they both
    depend on the `compile` task. After both of these tasks complete, the report task
    runs as it declares a dependency on both the `test` and `build_schema` jobs. Before
    this job actually starts, the condition is evaluated to determine whether the
    job should actually run or be skipped. Conditions can be built using a syntax
    that is similar to many programming languages. It checks the successful completion
    of a job using the `succeeded()` and `failed()` functions. There is also support
    for Boolean operators such as `or()`, `and()`, and `ne()`.
  prefs: []
  type: TYPE_NORMAL
- en: You can combine the `dependsOn` and `condition` keywords in any way you see
    fit. The only requirement is that there should be at least one job that does not
    depend on any other job.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like classic build pipelines, YAML pipelines support the use of variables.
    Variables can be defined at every level of a YAML pipeline (except for within
    a task) using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Variables can later be retrieved using the syntax that you already know from
    classic build pipelines—`$(name)` and `$(anotherName)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to reference existing variable groups from within a YAML
    pipeline. This is done by using the `group` keyword, instead of specifying the
    name of a variable. To also retrieve all the variables from a variable group called
    `myVariableGroup`, you would extend the preceding YAML, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Variables can be set at every level in a YAML pipeline, but only variables set
    at the root level can be overridden when queuing a new execution manually.
  prefs: []
  type: TYPE_NORMAL
- en: Pipeline artifacts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like classic builds, YAML pipelines can be used to build and publish artifacts.
    As the task used to do this is a task like any other, it can be added directly
    to the list of steps in a job.
  prefs: []
  type: TYPE_NORMAL
- en: However, with the introduction of YAML pipelines, a new type of artifact has
    become available—the so-called pipeline artifact. This comes with the benefit
    of improving the speed at which large artifacts can be uploaded and downloaded.
    When working with classic releases, pipeline artifacts are not automatically downloaded,
    whereas build artifacts are.
  prefs: []
  type: TYPE_NORMAL
- en: 'To publish a pipeline artifact, the following YAML can be used in the `steps` keyword
    of a job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Pipeline artifacts are mainly intended to be downloaded in multi-stage YAML
    pipelines, which are also covered in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tips for writing YAML pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing YAML pipelines from scratch can be complicated when you are just getting
    started. There are two tools available that can help you.
  prefs: []
  type: TYPE_NORMAL
- en: First, there is the option to export YAML from the visual designer. For every
    task, there is a link with the View YAML title. This opens a small pop-up box
    that shows you the YAML corresponding to the task and configuration that you currently have open.
    The same can be done for jobs and, under specific conditions, for complete build
    definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other tool available for writing YAML is the built-in YAML editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af66f656-bb67-4536-9b45-f8758f4407eb.png)'
  prefs: []
  type: TYPE_IMG
- en: Whenever you open a YAML build definition, there are two tools available to
    help you. First, there is autocompletion for every location in your YAML file.
    This shows you the options available at that point in the file. As well as this,
    there are snippets available in the task picker on the right. When selecting any
    of the tasks on the right, you configure them visually and then click the Add
    button to add the generated YAML to your definition.
  prefs: []
  type: TYPE_NORMAL
- en: These two tools aim to bring the ease of the visual designer to the YAML build
    experience as well, combining the best of both worlds.
  prefs: []
  type: TYPE_NORMAL
- en: Agents and agent queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The build definitions that you have created so far can contain agent jobs,
    which in turn contain tasks. These tasks are not executed within your Azure DevOps
    organization directly, but are executed by agents that run on VMs or in containers.
    In turn, agents are grouped in agent pools. There are two types of agent pools
    that you can work with:'
  prefs: []
  type: TYPE_NORMAL
- en: Built-in agent pools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-hosted agent pools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's go through them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in agent pools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Built-in agent pools are managed by Microsoft and are made available to you
    as part of the product. There are different agent pools available, depending on
    your needs. Pools run different versions of Windows and Visual Studio, and there
    are also pools available that run Linux (Ubuntu) and macOS.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantage of these managed pools is that you cannot install extra software
    on the machines or containers that host the agents if you need to. This means
    that in these cases, you have to create your own private agent pools.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a private agent pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Private pools are defined in your Azure DevOps organization and are provisioned from
    there to one or more of your team projects. However, you can also create your
    private pools at the team project level, in case they are created and provisioned
    in one go. To do so, go to Project Settings | Agent pools. You should see the
    following Add agent pool option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/374c4de3-0979-4895-a050-00de8ea00fc7.png)'
  prefs: []
  type: TYPE_IMG
- en: After giving the pool a name and determining whether you want to automatically
    provide access to all pipelines, you can save the pool. After creating the pool,
    you can add or remove agents.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and removing agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding an agent is done in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and extract the agent runtime. You can find the agent runtime by going
    to the section with the overview of the agent pools and opening the details of
    any private agent pool. After the details of the pool are opened, click on New
    agent in the top-right corner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/59d02297-1f43-4e8f-bde5-2b8379a57611.png)'
  prefs: []
  type: TYPE_IMG
- en: In the dialog that opens, you can download a ZIP file with the agent and instructions
    for extracting and installing the agent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: During the configuration phase, you will be prompted to authenticate with your
    Azure DevOps organization and to provide the name of the agent pool you want to
    install the agent in. While there are x86 and x64 agents available, it is recommended
    that you work with the x64 agent unless you have a specific reason not to.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove agents from the pool, you can use one of two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can return to the PowerShell command line, just as you did for the installation,
    and use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As an alternative, you can also remove agents from the agent pool overview
    using the Agents tab. Go to Project Settings | Agent pools (see label 1 in the
    following screenshot) | Agents (see label 2 in the following screenshot) and then
    select the options button (see label 3 in the following screenshot) on the agent
    you want to remove. Then, click Delete (see label 4 in the following screenshot):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/5a0300ca-a7e6-4c92-bb7b-876bd3ed1333.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can see the steps to remove an agent using
    the interface. Be aware that this does not clean up the binaries and any files
    on the host machine; however, if a machine that is hosting an agent breaks down
    or a VM is removed, then this is the only way to remove the agent.
  prefs: []
  type: TYPE_NORMAL
- en: Agent selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever a build job starts running, an agent is selected from the pool that
    will perform the tasks that you have defined in the pipeline. The selection of
    an agent is done in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Only agents that are part of the selected pool are eligible for running the
    tasks. This means that when working with private agent pools, it is wise to have
    multiple agents in a pool. If you then take one agent offline for maintenance,
    the agent jobs that rely on the agent pool can continue running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before an agent job can run, the demands from each job and the tasks it contains
    are gathered. As you learned in the *Variable groups *section, an agent job can
    specify the demands it has of the agent that it uses. The same goes for tasks—they
    can also specify demands. To run a job, only agents that meet all of these demands
    are used. Demands and capabilities are key–value pairs, where the value is an
    integer. An example capability is `msbuild=15.0` and the corresponding demand
    is `msbuild>15.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When there is no eligible agent for a build definition, the build eventually
    fails after a timeout.
  prefs: []
  type: TYPE_NORMAL
- en: Finding agent capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To find the capabilities that are available on the individual agents, go through
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to Organization Settings | Agent pools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8b8d2080-5d74-4bc2-b1d4-111d245951e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Navigate to the correct agent pool (either hosted or private) and then Agents,
    and then open the agent details (not shown in the preceding screenshot).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Capabilities tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, you can specify one or more custom capabilities for the agent using the
    top block, called User-defined capabilities. For self-hosted (private) agents,
    all the capabilities that were discovered on the machine when you installed the
    agent are also shown.
  prefs: []
  type: TYPE_NORMAL
- en: Azure DevOps is not the only tool available for running continuous integration
    builds. The next section will take you through a couple of other tools.
  prefs: []
  type: TYPE_NORMAL
- en: Other tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many tools available besides Azure DevOps. Two other well-known tools
    are GitLab CI and Jenkins. Some very basic knowledge of these tools will help
    you to understand how to integrate with them if that is ever necessary. Also,
    a limited understanding of other tools will help you to more quickly understand
    the concepts and generalize your knowledge of how to work with these other tools.
  prefs: []
  type: TYPE_NORMAL
- en: To highlight how these tools work with the same concepts, both examples in this
    section are equivalent to the Azure DevOps YAML pipeline in the *Writing a YAML
    build definition *section*.*
  prefs: []
  type: TYPE_NORMAL
- en: GitLab CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GitLab offers build pipelines using the GitLab CI capabilities. GitLab CI is
    configured by putting a file with the `.gitlab-ci.yml` name in the root of a repository.
    In this file, you can define one or more stages and jobs, along with the tasks
    that they should perform. An example YAML file for GitLab CI can appear as in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Just as Azure DevOps uses agent pools with agents, GitLab CI relies on **runners** to
    perform the actual work. In GitLab CI, there is currently no support for visually
    creating or editing your pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jenkins is another tool used to run build pipelines. Complex builds can be
    run using Jenkins pipelines, which get their work from a Jenkinsfile. A **Jenkinsfile**
    is written in a Jenkins-specific notation, as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Jenkins has limited support for visually creating and editing a pipeline. This
    is referred to as a freestyle project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at continuous integration and learned how it is a
    combination of your mindset, the process, and tools. You learned how to create
    build definitions using Azure Pipelines using both the graphical designer and
    YAML, as well as how to run builds. You learned that you can use build pipelines
    to compile and test your code, as well as report the outcome back to pull requests.
  prefs: []
  type: TYPE_NORMAL
- en: You learned that builds can produce outcomes, called artifacts. Artifacts are
    stored and retained within Azure pipelines and can be used to store reports, but
    are also the starting point of deployment pipelines, which you will learn about
    in the next chapter. You also learned about the infrastructure that you need to
    run builds—namely, agents and agent pools. Finally, you saw two brief examples
    of how to run a continuous integration build using GitLab CI and Jenkins, which
    are two other tools that you can use for build pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, you are now able to create build pipelines for your projects.
    You can hook up to source control and produce the builds that you will use in
    the next chapter to deploy your applications. With this deep knowledge of the
    underlying structure of tasks, jobs, stages, and pipelines, you can solve complex
    application-building problems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will continue learning about pipelines, but this time
    for releases. You will learn how to pick up builds and release them to one or
    more environments.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the appendix:'
  prefs: []
  type: TYPE_NORMAL
- en: True or false – you achieve continuous integration if you compile all the branches
    of your project at least daily.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false – a classic build definition is always connected to a source code
    repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false – a YAML pipeline definition is always connected to a source code
    repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is needed to call an external tool from an Azure pipeline?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An external service definition
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An Azure services connection
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A service connection
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A service locator
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some common reasons for using self-hosted agents? (Choose all of the
    correct answers from the following:)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access to closed networks is needed.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Specific extension tasks need to be available to the agent.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The number of parallel pipeline executions needs to be larger than 10.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Specific software needs to be installed in order for the agent to use it.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An in-depth definition of continuous integration by Martin Fowler is available
    at [https://martinfowler.com/articles/continuousIntegration.html](https://martinfowler.com/articles/continuousIntegration.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A detailed description of the conditions syntax is available at [https://docs.microsoft.com/en-us/azure/devops/pipelines/process/conditions?view=azure-devops&tabs=classic](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/conditions?view=azure-devops&tabs=classic).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises for practicing with Azure DevOps builds can be found at [https://docs.microsoft.com/en-us/learn/modules/create-a-build-pipeline/index](https://docs.microsoft.com/en-us/learn/modules/create-a-build-pipeline/index).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the Visual Studio marketplace for Azure DevOps at [https://marketplace.visualstudio.com/azuredevops](https://marketplace.visualstudio.com/azuredevops).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find a detailed description of the Azure Pipelines YAML syntax at [https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devops&tabs=schema](https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devops&tabs=schema).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details of the pricing of the Azure pipelines hosted and self-hosted agent pools
    are available at [https://azure.microsoft.com/en-us/pricing/details/devops/azure-pipelines/](https://azure.microsoft.com/en-us/pricing/details/devops/azure-pipelines/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about GitLab CI can be found at [https://about.gitlab.com/product/continuous-integration/](https://about.gitlab.com/product/continuous-integration/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about Jenkins can be found at [https://jenkins.io/](https://jenkins.io/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
