- en: Moving to Continuous Integration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移到持续集成
- en: After setting up source control for your organization and deciding on a branching
    and merging strategy that supports parallel work, you are ready to move on to
    continuous integration. Continuous integration is a method where every developer
    takes their work and integrates it with the work of others, and then verifies
    the quality of the combined work. The value of this is an increase in quality
    early on in the pipeline. This reduces the risk of error later on when merging
    code changes and reduces the number of bugs that are found in production, thereby
    reducing costs and protecting your reputation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在为你的组织设置源代码控制，并决定支持并行工作的分支和合并策略之后，你就可以继续进行持续集成。持续集成是一种方法，其中每个开发人员将自己的工作与他人的工作进行集成，并验证合并后的工作质量。这样做的好处是在流水线的早期提高质量，减少后续合并代码更改时出现错误的风险，减少生产环境中发现的错误数量，从而降低成本并保护你的声誉。
- en: Continuous integration is only possible when you have the proper setup with
    the necessary tools. In this chapter, you will learn how to use Azure DevOps pipelines
    to set up continuous integration.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成只有在具备必要工具和适当设置时才能实现。在本章中，你将学习如何使用 Azure DevOps 管道来设置持续集成。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing continuous integration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入持续集成
- en: Creating a build definition
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建构建定义
- en: Running a build
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行构建
- en: Working with YAML pipelines
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 YAML 管道
- en: Agents and agent queues
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理和代理队列
- en: Other tools
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他工具
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To go through the recipes that are covered in this chapter, you will need an
    Azure DevOps organization.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行本章中的操作示例，你需要一个 Azure DevOps 组织。
- en: Introducing continuous integration
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入持续集成
- en: '**Continuous integration **is a methodology where you integrate your own changes
    with those of all of the other developers in your project and test whether the
    combined code still works as expected. This way, you create a fast loop that provides
    you with feedback on your work.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**是一种方法论，开发人员将自己的更改与项目中所有其他开发人员的更改进行集成，并测试合并后的代码是否仍然按预期工作。通过这种方式，你可以创建一个快速反馈的循环，及时了解自己工作的效果。'
- en: When working with extensive branching strategies for isolating code changes,
    it is not uncommon for one or more developers to work for days, weeks, or even
    months on an isolated branch. While this is great for making sure that their changes
    do not disrupt others, it is also a great way to make sure that there won't be
    merge issues later. If you have ever had to merge weeks or months of work back
    into a master branch, you will know how much work is involved and how often this
    results in bugs or other issues.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用广泛的分支策略来隔离代码更改时，开发人员经常会在一个独立的分支上工作几天、几周，甚至几个月。虽然这种做法可以确保他们的更改不会影响其他人，但它也是确保以后不会出现合并问题的好方法。如果你曾经将几周或几个月的工作合并回主分支，你就会知道这需要多少工作，而且通常会导致错误或其他问题。
- en: To prevent this, developers should make it a habit to integrate their changes
    with those of all the other developers at least once a day. Here, integrating
    means at least merging, compiling, and running unit tests. This way, there is
    a constant stream of feedback on the quality of the developer's changes and since
    this feedback is combined, it is a great way to prevent merge issues later.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况，开发人员应该养成每天至少将自己的更改与其他开发人员的更改集成一次的习惯。这里的集成至少指合并、编译和运行单元测试。这样，开发人员的更改质量会不断收到反馈，并且由于这些反馈是合并的，因此它是一种防止后续合并问题的好方法。
- en: Continuous integration also enables you to embed other concerns in your pipeline
    to automatically preserve the quality of your code. Testing and security scanning
    are two prime examples of this. These topics are discussed in later chapters,
    but a good continuous integration pipeline is the basis for these practices.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成还可以使你在管道中嵌入其他关注点，自动保持代码的质量。测试和安全扫描就是两个典型的例子。这些话题将在后续章节中讨论，但一个良好的持续集成管道是这些实践的基础。
- en: In the rest of this chapter, you will learn about the technical means to set
    up continuous integration using Azure Pipelines. But first, let’s look at a common
    misconception and the four pillars of continuous integration.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，你将学习如何使用 Azure Pipelines 设置持续集成的技术手段。但首先，我们来看一个常见的误解以及持续集成的四大支柱。
- en: While an automated continuous integration build is an important ingredient for
    performing continuous integration, continuous integration entails more than just
    having a build pipeline. The important thing to remember is that continuous integration
    is a process where every developer integrates their work with that of their colleagues
    at least daily. Then, the integrated sources are compiled and tested. The value
    comes from compiling and testing the integrated work, not the isolated work.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然自动化的持续集成构建是执行持续集成的一个重要组成部分，但持续集成不仅仅是拥有一个构建管道。需要记住的重要一点是，持续集成是一个过程，其中每个开发者至少每天将他们的工作与同事的工作进行整合。然后，将整合后的源代码进行编译和测试。价值来自于编译和测试整合后的工作，而不是孤立的工作。
- en: The four pillars of continuous integration
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成的四大支柱
- en: 'There are four pillars that underpin the successful adoption of continuous
    integration:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成成功采用的四大支柱：
- en: '**A version control system**:Used for storing all of the changes made to a
    system since its inception. Version control systems were discussed in the previous
    chapter.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制系统**：用于存储自系统创建以来所做的所有更改。版本控制系统在前一章中已有讨论。'
- en: '**A package management system**:Used to store the binary packages that you
    use in your own application and the packages that you create. This will be discussed
    in detail in [Chapter 5](d4208d51-c982-414f-9e96-17f14e084b90.xhtml), *Dependency
    Management*.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件包管理系统**：用于存储你在自己应用程序中使用的二进制包以及你创建的包。将在[第 5 章](d4208d51-c982-414f-9e96-17f14e084b90.xhtml)中详细讨论，*依赖管理*。'
- en: '**A continuous integration system**: A system that can pull the changes of
    all developers together—several times a day—and create one integrated source version.
    This can be done using Azure DevOps pipelines.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续集成系统**：可以将所有开发者的更改合并到一起——每天多次——并创建一个整合后的源版本。可以使用 Azure DevOps 管道来实现这一点。'
- en: '**An** **automated build process**: Used to compile and test the combined sources.
    We will look at how to implement this process using Azure DevOps Pipelines.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化构建过程**：用于编译和测试合并后的源代码。我们将展示如何使用 Azure DevOps Pipelines 实现这一过程。'
- en: Continuous integration and automated builds can be set up in Azure DevOps. The
    next section explains how to set both up in Azure DevOps.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 Azure DevOps 中设置持续集成和自动化构建。下一节将解释如何在 Azure DevOps 中设置这两者。
- en: Creating a build definition in Azure DevOps
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Azure DevOps 中创建构建定义
- en: 'The main way to perform continuous integration is by using a continuous integration
    build. In Azure DevOps, builds can be configured as part of the Azure Pipelines
    offering. There are currently two approaches available for creating a build definition:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 执行持续集成的主要方式是使用持续集成构建。在 Azure DevOps 中，构建可以作为 Azure Pipelines 服务的一部分进行配置。目前有两种方法可以创建构建定义：
- en: Via the visual designer (also called **classic builds and releases**)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过视觉设计器（也叫做**经典构建与发布**）
- en: Through **Yet Another Markup Language** (**YAML**) files (also called **YAML
    pipelines** or **multistage pipelines**)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过**另一种标记语言** (**YAML**) 文件（也称为 **YAML 管道** 或 **多阶段管道**）
- en: The rest of this section focuses on the visual designer. The following section,
    *YAML build definitions,* will go into more detail about YAML pipelines. Both
    approaches support roughly the same capabilities, although there are some differences.
    Some features that are available in classic builds and releases are not (yet)
    available in YAML build definitions. Also, some new features are only provided
    to YAML pipelines.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本节其余部分重点介绍视觉设计器。下一节，*YAML 构建定义*，将更详细地讲解 YAML 管道。两种方法支持大致相同的功能，尽管存在一些差异。一些在经典构建和发布中可用的功能目前（尚未）在
    YAML 构建定义中提供。此外，一些新功能仅在 YAML 管道中提供。
- en: If you have no experience with pipelines, the classic editor is a good way to
    get familiar with the workings of continuous integration/continuous development
    pipelines before moving on to YAML pipelines. Almost all of the concepts in classic
    builds translate to YAML builds as well.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有管道的经验，经典编辑器是一个很好的一步，可以帮助你熟悉持续集成/持续开发管道的工作方式，然后再过渡到 YAML 管道。经典构建中的几乎所有概念也都可以转化为
    YAML 构建。
- en: In the following sections, we will start by building a classic build pipeline.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将从构建经典构建管道开始。
- en: Connecting to source control
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到源代码管理
- en: 'To get started with a build definition, follow these simple steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始创建构建定义，请按照以下简单步骤操作：
- en: Open the Pipelines menu.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Pipelines 菜单。
- en: 'From this menu, click on Builds. Here, you will be presented with a button
    to create a new build. After clicking on this button, a new view for creating
    a build will open, as in the following screenshot:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此菜单中，点击构建。这里，你将看到一个按钮用于创建新的构建。点击该按钮后，将打开一个新的视图用于创建构建，如以下截图所示：
- en: '![](img/c10e2393-4fe8-4c11-b088-ae6ba067d483.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c10e2393-4fe8-4c11-b088-ae6ba067d483.png)'
- en: You will then be guided to the new YAML experience, but you can still opt to
    go back by choosing the classic editor.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你将被引导到新的 YAML 体验界面，但你仍然可以通过选择经典编辑器选择返回。
- en: After choosing the classic editor, you can configure how to connect to the source
    control. The classical editor is the editor that is visible in all of the screenshots
    in the following sections.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 选择经典编辑器后，你可以配置如何连接到源代码控制系统。经典编辑器是以下各节中所有截图中可见的编辑器。
- en: Many source control systems are supported. If you are working with a hosted
    Git repository, pick your specific product, if available, and only choose Other
    Git if your product is not available; currently, GitHub, GitHub Enterprise Server,
    and BitBucket Cloud are supported. The reason for this is that continuous integration
    using Other Git works by using a polling model, where all the specific products
    use their known integration webhooks. The following example works with a Git repository
    that is in the same Azure DevOps instance.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 支持许多源代码控制系统。如果你使用的是托管的 Git 仓库，选择你的具体产品（如果有），如果没有可用的产品，选择“其他 Git”；目前，支持 GitHub、GitHub
    企业服务器和 BitBucket Cloud。之所以如此，是因为使用“其他 Git”进行持续集成时采用的是轮询模型，而所有特定产品都使用它们已知的集成 Webhook。以下示例适用于位于同一
    Azure DevOps 实例中的 Git 仓库。
- en: When you select the Pipeline header, you can set the name of the build definition
    and select an agent pool that the phases will run on by default. Agents take care
    of the actual execution of your tasks and will be looked at in more detail in
    the A*gents and agent queues *section of this chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择流水线头部时，你可以设置构建定义的名称，并选择默认运行阶段的代理池。代理负责实际执行任务，代理的详细信息将在本章的“代理和代理队列”部分进行更深入的探讨。
- en: Below the Pipeline header, you can see the chronological layout of your build
    definition. First up is downloading sources. Here, you can once again choose to connect
    to a source control system. You can also specify more advanced settings that relate
    to the way sources are fetched, such as whether to clean the build directory first,
    select a branch, or add tags.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在流水线头部下方，你可以看到构建定义的时间顺序布局。首先是下载源代码。在这里，你可以再次选择连接到源代码控制系统。你还可以指定更多与获取源代码方式相关的高级设置，如是否先清理构建目录、选择分支或添加标签。
- en: Configuring a job
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置作业
- en: 'Below the source''s node, you can add one or more jobs that will perform the
    bulk of the work that you want to perform. Jobs can be added using the ellipsis
    on the pipeline header. There are two types of jobs available:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在源节点下方，你可以添加一个或多个作业，执行你想要完成的大部分工作。可以通过流水线头部的省略号来添加作业。这里有两种类型的作业：
- en: '**Agentless jobs**: Agentless jobs can be used to run tasks that need an agent.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无代理作业**：无代理作业可用于运行不需要代理的任务。'
- en: '**Agent jobs**: Agent jobs are used to run tasks that require an agent to run
    on, which is the case for the bulk of the tasks.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理作业**：代理作业用于运行需要在代理上运行的任务，这适用于大多数任务。'
- en: 'Some examples of agentless tasks are as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一些无代理任务的示例如下：
- en: Waiting for manual approval before continuing
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待手动批准后继续
- en: Inserting a delay before proceeding
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入延迟后再继续
- en: Calling a REST API
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 REST API
- en: Calling an Azure function
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 Azure 函数
- en: The main benefit of an agentless job is that it does not keep an agent occupied
    while running. This frees the agent up to do other work, meaning that you need
    fewer agents, which can save costs. Also, the number of agents that you can use
    concurrently is governed by the number of parallel pipelines that you have bought
    in Azure DevOps. Limiting the number of agent jobs will save money here as well.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 无代理作业的主要好处是它在运行时不会占用代理。这样可以释放代理去做其他工作，意味着你需要的代理更少，从而节省成本。此外，你可以并行使用的代理数量受你在
    Azure DevOps 中购买的并行流水线数量的限制。限制代理作业的数量也能节省费用。
- en: 'Let''s go over the process of configuring a job:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下配置作业的过程：
- en: 'Select any job. You will see the view shown in the following screenshot. In
    this view, you can change the name of the job and, for agent jobs, override the
    agent pool to execute this job on:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择任何任务。你将看到以下截图所示的视图。在此视图中，你可以更改任务的名称，并且对于代理任务，可以覆盖执行此任务的代理池：
- en: '![](img/dbfbf685-df22-4f4a-8332-f907f1f10e16.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dbfbf685-df22-4f4a-8332-f907f1f10e16.png)'
- en: Next, specify which agent pool to use for running the job. Here, it also specifies
    the demands that you have of the agent that will execute this job. Demands will
    be discussed in the *Agents and agent queues *section of this chapter.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，指定要用于执行该任务的代理池。在这里，还指定了你对执行该任务的代理的需求。需求将在本章的*代理和代理队列*部分进行讨论。
- en: 'As part of the execution plan for an agent, you can specify Parallelism and
    choose one of three options:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为代理执行计划的一部分，你可以指定并行性，并选择以下三种选项之一：
- en: 'None: This will just execute all the tasks you add to the agent job one after
    another on the same agent.'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无：这将依次在同一代理上执行你添加到代理任务中的所有任务。
- en: 'Multi-configuration: Here, you can specify a series of variables that determine
    the number of variations of the build to run. This is useful if you want to create,
    for example, x86 and x64 builds from the same code.'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多配置：在这里，你可以指定一系列变量来确定要运行的构建变体的数量。如果你想从相同代码创建例如x86和x64构建，这非常有用。
- en: 'Multi-agent: Here, you can specify the number of agents that will run the same
    tasks in parallel.'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多代理：在这里，你可以指定将并行运行相同任务的代理数量。
- en: Next, you can specify one or more dependencies. These are the other jobs that
    need to be completed before the selected job runs.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你可以指定一个或多个依赖项。这些是需要在选定的任务运行之前完成的其他任务。
- en: Also, for any job, you can specify how to cope with errors in previous jobs
    by telling it to continue or stop.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，对于任何任务，你都可以指定如何处理前一个任务中的错误，告诉它是继续执行还是停止。
- en: 'As an alternative to steps 3 and 4, you can also specify a custom expression
    to specify whether a job should run. This expression should evaluate to a Boolean
    and support rudimentary operations, such as `or()`, `and()`, or `eq()`. The following
    is an example condition:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第3步和第4步的替代方案，你还可以指定一个自定义表达式来判断是否应运行某个任务。此表达式应返回布尔值，并支持基本操作，如`or()`、`and()`或`eq()`。以下是一个示例条件：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This condition specifies that the job will only run when all previous jobs have
    succeeded and the build is not started from the master branch. A link to a detailed
    description of the conditions syntax is included at the end of this chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此条件指定，只有在所有先前的任务都成功并且构建不是从主分支启动时，任务才会执行。详细描述条件语法的链接将包含在本章的末尾。
- en: Agentless jobs have fewer options available than agent jobs. For example, it
    is not possible to execute the same build for multiple variable values in parallel.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 无代理任务的选项比代理任务少。例如，无法在多个变量值的并行任务中执行相同的构建。
- en: Adding tasks to your job
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向任务中添加任务
- en: 'After adding one or more jobs, you can add tasks to a job. Tasks define the
    actual work that is to be done during the execution of your build. The following
    screenshot shows you how to add a task and then configure it:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加一个或多个任务之后，你可以将任务添加到工作中。任务定义了在构建执行过程中要完成的实际工作。以下截图展示了如何添加任务并进行配置：
- en: 'Click on the plus sign next to the job you want to add tasks to:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击你想要添加任务的工作旁边的加号：
- en: '![](img/8c704d41-483e-45bc-8f2c-68655f5c9339.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c704d41-483e-45bc-8f2c-68655f5c9339.png)'
- en: You will then be presented with a task picker, where you can find any task that
    matches your search input and add one or more tasks by clicking the Add button.
    A new screen will then open, where you can configure the individual task. The
    options provided here differ for each task.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你将看到一个任务选择器，在其中可以找到任何与搜索输入匹配的任务，并通过点击添加按钮来添加一个或多个任务。然后将打开一个新屏幕，你可以在其中配置各个任务。此处提供的选项因任务而异。
- en: There can be multiple versions of a task and you can switch between the major
    versions of the task. This means that the maintainer can push non-breaking updates
    and you will receive them automatically. Major or breaking updates can be pushed
    with a new major version number and you can upgrade them at your own discretion.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个任务可以有多个版本，你可以在任务的主要版本之间切换。这意味着维护者可以推送非破坏性的更新，你将自动接收这些更新。主要或破坏性更新可以通过新的主要版本号推送，你可以根据自己的需要进行升级。
- en: It is possible to add as many tasks as needed to a pipeline job.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 可以根据需要向管道任务添加任意数量的任务。
- en: Publishing build artifacts
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布构建工件
- en: An important part of a build definition is its outcomes. Builds are often used
    to produce one or more artifacts that are later used for the deployment of an
    application. Examples of artifacts can be executables or installer files. These
    files need to be made available for use after the pipeline has completed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 构建定义的一个重要部分是它的结果。构建通常用于生成一个或多个工件，这些工件稍后会用于应用程序的部署。工件的示例可以是可执行文件或安装程序文件。这些文件需要在流水线完成后可供使用。
- en: The Publish Build Artifacts task that is shown in the preceding screenshot is
    a task that is specifically designed to do this. It allows you to select a file
    or directory and publish it under an **artifact name**. The result of this is
    that the file(s) in the selected path is retained with every execution of the
    pipeline for manual download or use in a release definition later. Release definitions
    are discussed in the next chapter, [Chapter 4](8ab4597a-becd-4855-9b45-89045982c14a.xhtml), *Continuous
    Deployment*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示的发布构建工件任务是专门设计用于此目的的任务。它允许您选择一个文件或目录，并将其发布为**工件名称**。其结果是，所选路径中的文件会在每次流水线执行时保留，以便手动下载或稍后在发布定义中使用。发布定义将在下一章[第4章](8ab4597a-becd-4855-9b45-89045982c14a.xhtml)《*持续部署*》中讨论。
- en: Next, we'll learn how to integrate our pipeline with other tools and configure
    our service connection.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何将我们的流水线与其他工具集成并配置我们的服务连接。
- en: Calling other tools
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用其他工具
- en: When building pipelines, we will often need to integrate them with other tools.
    For source control systems, this is part of the flow when creating a pipeline
    and you are limited to the built-in options. For tasks, you can create references
    to any tool or location you want using service connections. An example of a task
    that uses a service connection to an Azure app service is shown in the following
    screenshot.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建流水线时，我们通常需要将它们与其他工具集成。对于源代码控制系统，这是创建流水线时的一部分，您只能选择内置的选项。对于任务，您可以使用服务连接创建对任何工具或位置的引用。以下截图展示了一个使用服务连接连接到
    Azure 应用服务的任务示例。
- en: 'A service connection is a pointer to a third-party system, with a name and
    series of properties that differ for each type of service connection. Often, you
    will need to put in a URL to locate the other service and a mechanism for authentication.
    The following steps will help you configure your service connection:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 服务连接是指向第三方系统的指针，具有一个名称和一系列不同于每种类型的服务连接的属性。通常，您需要输入一个 URL 来定位另一个服务，并提供身份验证机制。以下步骤将帮助您配置服务连接：
- en: 'After defining one or more service connections, you can select the one to use
    from a drop-down menu:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义一个或多个服务连接后，您可以从下拉菜单中选择要使用的服务连接：
- en: '![](img/a9ec689c-480f-4b57-9997-338d77913f41.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9ec689c-480f-4b57-9997-338d77913f41.png)'
- en: 'Service connections are managed in a central location as project settings.
    You can access them by going to the management view directly from the task you
    are currently configuring, as shown in the preceding screenshot. You can also
    do this by navigating to Project Settings and then to Service connections, as
    in the following screenshot (see label 1):'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务连接在项目设置中集中管理。您可以通过直接从当前配置的任务访问管理视图，如上图所示。您也可以通过导航到项目设置，然后转到服务连接来访问，如下图所示（见标签1）：
- en: '![](img/8b676478-8d5d-4587-af5b-e32622d6e7c5.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b676478-8d5d-4587-af5b-e32622d6e7c5.png)'
- en: In this view, you can then either add a new service connection or update an
    existing service connection (see label 2 in the preceding screenshot).
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此视图中，您可以添加新的服务连接或更新现有的服务连接（见上图中的标签2）。
- en: By default, service connections are scoped to the project level, meaning they
    are not available for everyone in the Azure DevOps organization. To encourage
    the reuse of service connections, Azure has made it possible to share them between
    projects since mid-2019.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，服务连接的作用域是项目级别，这意味着它们并非对整个 Azure DevOps 组织中的所有人可用。为了鼓励服务连接的重用，Azure 从2019年中期起允许在项目之间共享它们。
- en: Task Marketplace
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务市场
- en: A set of frequently used tasks is built into Azure Pipelines; however, there
    are even more available using the Visual Studio marketplace for Azure DevOps.
    If you are an administrator, you can find and install extensions that add tasks
    here. If you are a regular user, you can find tasks here as well; however, you
    cannot install them, only request them. Your Azure DevOps administrator will then
    be notified and can install the extension on your behalf if they approve.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Pipelines 内置了一组常用任务；然而，使用 Azure DevOps 的 Visual Studio 市场可以找到更多任务。如果你是管理员，你可以在这里查找并安装扩展，这些扩展会添加任务。如果你是普通用户，你也可以在这里找到任务；然而，你不能安装它们，只能请求它们。你的
    Azure DevOps 管理员会收到通知，如果他们批准，便可以代表你安装该扩展。
- en: Of course, you can write and distribute extensions with tasks of your own as
    well.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以编写和分发自己带有任务的扩展。
- en: Creating variables and variable groups
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建变量和变量组
- en: When you are configuring your build, there might be values that you need to
    use more than once. It is often wise to extract these values into variables, rather
    than just repeating those values throughout your tasks.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当你配置构建时，可能会有一些值需要多次使用。通常明智的做法是将这些值提取为变量，而不是在任务中反复使用这些值。
- en: Variables can be used to note down values that you do not want to have stored
    in source control. Values such as passwords and license keys can be safely stored
    as non-retrievable values when locked down using the lock symbol (see label 1
    in the following screenshot). After saving the build definition, these values
    are encrypted and can only be used by the build that they belong to. You will
    no longer be able to retrieve these values and they will be automatically scrubbed
    from logs and other output.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可用于记录你不希望存储在源代码控制中的值。像密码和许可证密钥这样的值，可以在使用锁定符号锁定后，安全地存储为不可检索的值（请参见下图标签 1）。保存构建定义后，这些值会被加密，并且只能被属于它们的构建使用。你将无法再检索这些值，它们将会从日志和其他输出中自动清除。
- en: 'To learn how to work with variables in Azure Pipelines, go through the following
    steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习如何在 Azure Pipelines 中使用变量，请按照以下步骤操作：
- en: 'In Azure Pipelines, you can add variables to your build definition by going
    to the Variables | Pipeline variables tab (see label 3 in the following screenshot).
    Here, you can enter them as name value, as can be seen in the following screenshot:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Azure Pipelines 中，你可以通过进入变量 | 管道变量选项卡来添加变量到你的构建定义中（请参见下图标签 3）。在这里，你可以按名称值的形式输入它们，正如下图所示：
- en: '![](img/6b846c91-0699-48ed-9598-e17df94d08ec.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b846c91-0699-48ed-9598-e17df94d08ec.png)'
- en: 'Once defined, you can use the variables in the configuration of all tasks in
    all jobs of the same build. For this, you can use the following notation:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦定义好，你可以在同一构建的所有任务和所有工作中使用这些变量。为此，你可以使用以下符号：
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Finally, you can mark variables as Settable at queue time (see label 2 in the
    preceding screenshot), which means that their value can be changed whenever someone
    queues a new build. An example of a variable for which this is used is the `system.debug`built-in
    variable*.* When this variable is set to `true`, there is a verbose debug logging
    included in the build.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以将变量标记为“队列时可设置”（请参见前面截图中的标签 2），这意味着每当有人排队新的构建时，可以更改这些变量的值。一个使用此功能的变量示例是`system.debug`内置变量*。*当此变量设置为`true`时，构建中将包含详细的调试日志记录。
- en: Next to your own variables, system variables are also defined. These are variables that
    contain information about the build that is currently running, including version
    numbers, agent names, build definition details, the source version, and so on.
    A link to the full list of system-defined variables is included at the end of
    this chapter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了你自己的变量外，还定义了系统变量。这些是包含当前正在运行的构建信息的变量，包括版本号、代理名称、构建定义详情、源代码版本等。系统定义变量的完整列表链接将在本章末尾提供。
- en: Variable groups
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量组
- en: 'As well as creating the variables that go with a specific build, you can create
    variable groups. These variable groups can, in turn, be linked to one or more
    builds. This is an effective way of sharing variables between builds; some examples
    of these might be the name of your company, trademark texts, product names, and
    so on. Let''s see how we can work with variable groups:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为特定构建创建变量外，你还可以创建变量组。这些变量组可以与一个或多个构建关联。这是共享变量的一种有效方式；这些变量的示例可能是你公司的名称、商标文本、产品名称等。让我们来看一下如何使用变量组：
- en: 'Access variable groups through the menu by clicking on Library in the Pipelines
    menu (see label 1 in the following screenshot). This displays a list of the existing
    variable groups that you can edit and you can add a new group here as well, as
    in the following screenshot:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在“管道”菜单中点击“库”来访问变量组（参见下方截图中的标签 1）。这将显示现有的变量组列表，你可以在这里编辑并添加新的变量组，如下截图所示：
- en: '![](img/bdfdd678-3ed2-46ae-ab48-089def21a003.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bdfdd678-3ed2-46ae-ab48-089def21a003.png)'
- en: 'Here, you can work with variables in the same way that you would with the variables
    that come with a build. The only differences are highlighted in the following
    list:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，你可以像处理构建中变量那样处理变量。唯一的区别在以下列表中有突出显示：
- en: You cannot mark variables in a group as settable at queue time.
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能将组中的变量标记为在队列时可设置。
- en: You can allow or deny the use of this group in all pipelines. If you deny their
    use in all pipelines, then only you can use the variable group. You can authorize
    other users or groups through the Security option (labeled with a 2 in the preceding
    screenshot).
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以允许或拒绝在所有管道中使用此组。如果你拒绝在所有管道中的使用，则只有你自己可以使用该变量组。你可以通过安全选项（在前面的截图中标记为 2）授权其他用户或组。
- en: You can reference an Azure key vault for which this variable group will act
    as a placeholder. After logging into Azure, you can select a key vault and select
    which values that are stored in the key vault you want to be accessible through
    the variable group.
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以参考一个 Azure 密钥库，变量组将作为占位符。登录 Azure 后，你可以选择一个密钥库，并选择你希望通过变量组访问的密钥库中存储的值。
- en: '**Azure Key Vault** is an Azure offering that can be used for the secure storage
    of secrets. Secrets in a key vault are automatically versioned, so older values
    are not overwritten but replaced by a newer version. In addition to this, you
    can specify segregated access policies that specify, per user, whether they can
    read, write, update, or delete values. All these actions are audited in a key
    vault, so you can also find who has made which change. If you are linking Azure
    DevOps to a key vault, then a new service principal will be created in your active
    directory that has access to that key vault. Now, whenever Azure DevOps needs
    a variable from the variable group, the actual values will be pulled from the
    key vault.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**Azure 密钥库**是一个 Azure 服务，用于安全存储机密。密钥库中的机密会自动版本控制，因此较旧的值不会被覆盖，而是被更新的版本所替代。此外，你可以指定隔离的访问策略，按用户指定是否可以读取、写入、更新或删除值。所有这些操作都会在密钥库中进行审计，因此你也可以查找是谁进行了哪些更改。如果你将
    Azure DevOps 与密钥库连接，则会在你的活动目录中创建一个新的服务主体，并授予它对该密钥库的访问权限。现在，每当 Azure DevOps 需要从变量组中获取变量时，实际的值将从密钥库中提取。'
- en: Variable groups can be linked to the variables of a build under the Variable
    groups tab (refer to the screenshot in the previous section).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 变量组可以链接到构建中的变量，位于“变量组”选项卡下（参见前一部分的截图）。
- en: As well as working with variable groups, you can also work with files in the
    library. You can upload files that are not accessible by other users but that
    can be used within a build. This is useful for files with private keys, license
    keys, and other secrets.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 除了处理变量组，你还可以处理库中的文件。你可以上传一些其他用户无法访问的文件，但这些文件可以在构建中使用。这对包含私钥、许可证密钥及其他机密文件非常有用。
- en: Just as you can with variable groups, you can specify whether each secure file can
    be used by any build or authorize specific users only.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你使用变量组一样，你可以指定每个**安全文件**是否可以被任何构建使用，或者只授权特定用户使用。
- en: Triggering the build
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发构建
- en: 'The next tab in a build definition governs what should start or trigger the
    build. To implement continuous integration, go through the following steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 构建定义中的下一个选项卡控制着什么应该启动或触发构建。要实现持续集成，按照以下步骤操作：
- en: 'Click on the Triggers tab and select the first header on the left:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击触发器选项卡，然后选择左侧的第一个标题：
- en: '![](img/1ab8338e-bef1-4f04-a865-8e642484a3d9.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ab8338e-bef1-4f04-a865-8e642484a3d9.png)'
- en: Check the Enable continuous integration box. This means that Azure DevOps will
    listen for changes in your repository and will queue a new build as soon as a
    new chance is available.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选启用持续集成框。这意味着 Azure DevOps 将监听你仓库中的变化，并在有新机会时立即排队进行新的构建。
- en: Next, you can choose whether you want to build every incoming change individually
    or batch multiple changes when more than one new change comes in while building
    a change. It is recommended that you build every single change separately if this
    is feasible.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您可以选择是否在每次有新更改时单独构建每个更改，或者在多个新更改到达时将它们批量构建。建议您尽可能单独构建每个更改。
- en: Along with the continuous integration trigger, specify one or more branch and
    path filters. Here, you can specify which branches and files to queue a new build
    for. You can specify either inclusions or exclusions, depending on your needs.
    A common example is to limit your build to the master branch. If you have folders
    named `doc` and `src` in your repository and all your sources are in the latter
    folder, then it might make sense to limit the trigger to this path.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了连续集成触发器外，您还可以指定一个或多个分支和路径过滤器。在这里，您可以指定哪些分支和文件需要排队进行新的构建。您可以根据需要指定包含或排除的项。一个常见的例子是将构建限制在主分支上。如果您的代码库中有名为`doc`和`src`的文件夹，并且所有源文件都在后者文件夹中，那么将触发器限制为该路径可能更为合理。
- en: As well as choosing to have a continuous integration trigger, you can also opt
    to execute a build on a recurring schedule where you select one or more weekdays
    and a time.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了选择使用连续集成触发器外，您还可以选择按计划定期执行构建，选择一个或多个工作日和一个时间。
- en: You can also schedule a build to run whenever another build completes. This
    is called **chaining** builds.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以安排在另一个构建完成时自动启动一个构建。这被称为**构建链**。
- en: Next, let's learn how to change the configurations of our build definition.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何更改构建定义的配置。
- en: Build options
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建选项
- en: 'You can change the advanced configuration options for your build definition.
    These options include a description, the format of the build number, and the automated
    creation of work items on failures and times. To set this up, go through the following
    steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以更改构建定义的高级配置选项。这些选项包括描述、构建号格式以及在失败和超时时自动创建工作项。要进行设置，请按照以下步骤操作：
- en: 'Click on the Options tab. You should arrive at the following screen:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击选项卡。您应该到达以下屏幕：
- en: '![](img/8745ab6a-1703-48e0-b913-9dba0d108273.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8745ab6a-1703-48e0-b913-9dba0d108273.png)'
- en: 'Now, create your build number format. If this field is left empty, then the
    build number for your application will be set to an ever-increasing number that
    will increase by 1 with every build. This number is unique within a team project
    and counts over all the build definitions. You can also specify a format of your
    own using the variables available to you. A common approach is to specify a major
    and minor version number manually and then add an increasing number using a variable.
    The following example specifies a version of 4.1.xx, where the last part is replaced
    by a two-digit increasing number:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建您的构建号格式。如果该字段留空，您的应用程序构建号将设为一个不断增加的数字，每次构建时增加1。这个数字在团队项目内是唯一的，并且在所有构建定义中递增。您还可以使用您可用的变量来指定您自己的格式。常见的做法是手动指定主版本号和次版本号，然后使用变量添加递增的数字。以下示例指定了一个版本为4.1.xx，其中最后部分由一个递增的两位数字替代：
- en: '[PRE2]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On the right, there are advanced (but rarely used) options for specifying the
    authorization scope for the Build job time-outs for each job in the build definition.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧，有一些高级（但很少使用的）选项，用于指定每个作业在构建定义中的授权范围和构建超时设置。
- en: It is also possible to specify the agent demands that every agent, for every
    job in the build definition, should fulfill. Again, we will look further at demands
    in the *Agents and agent queues* section of this chapter*.*
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还可以指定每个作业在构建定义中应该满足的代理需求。我们将在本章的*代理和代理队列*部分进一步讨论需求。
- en: Other options on the left enable you to suspend the pipeline temporarily.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的其他选项使您能够暂时暂停流水线。
- en: Build history
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建历史
- en: The final tab, called History, shows you a list of every change that has been
    made to the build definition. Build definitions are stored in JSON format and
    you can pull up side-by-side comparisons for every change. The comment that you
    put in when saving a build is also stored here and can be used to provide the
    rationale for a change.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个标签页，称为“历史记录”，显示了对构建定义所做的每一个更改的列表。构建定义以JSON格式存储，您可以查看每个更改的并排比较。保存构建时添加的评论也会存储在这里，并可以用于提供更改的理由。
- en: Since builds are an important means of preserving quality, it is important to
    keep track of who has changed them to ensure that automated quality metrics are
    not removed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于构建是保证质量的重要手段，因此重要的是跟踪谁修改了它们，以确保不会删除自动化质量指标。
- en: With this, you are now ready to run your first build. You can directly run it
    using the Save & Queue button that is visible in most of the screenshots in this
    section. The *Running a build* section of this chapter will teach you how to work
    with the results that you obtain.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已准备好运行第一次构建了。您可以直接使用本节大多数截图中可见的**保存**和**排队**按钮来运行它。本章的*运行构建*部分将教您如何处理所获得的结果。
- en: Task groups
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务组
- en: When working in a team or organization that has more than one pipeline, it often
    doesn't take long before multiple pipelines that take the same shape emerge. For
    example, in some companies, all pipelines contain tasks for security scanning,
    running tests, and calculating the test coverage.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个具有多个管道的团队或组织中工作时，通常不久就会出现多个具有相同结构的管道。例如，在某些公司，所有管道都包含安全扫描、运行测试和计算测试覆盖率的任务。
- en: Instead of repeating these tasks everywhere, they can be extracted from an existing
    pipeline into a task group. Task groups, in turn, can be used within multiple
    pipelines as if they are tasks themselves. Doing this reduces the effort needed
    to create a new pipeline or update all the pipelines with a new requirement. Doing
    this also ensures that all the pipelines using the task group have the same task
    configuration.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 不必在各处重复这些任务，可以将它们从现有管道中提取到任务组中。任务组本身可以像任务一样在多个管道中使用。这样做可以减少创建新管道或更新所有管道以满足新需求的工作量。这样做还确保使用任务组的所有管道具有相同的任务配置。
- en: 'To create a new task group, open any existing build definition and go through
    the following steps:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的任务组，请打开任何现有的构建定义并按以下步骤操作：
- en: '![](img/6cadb314-e51b-4e8f-a492-4dc7dbdfc74f.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6cadb314-e51b-4e8f-a492-4dc7dbdfc74f.png)'
- en: Select one or more tasks by clicking on them while holding down *Ctrl*, or by
    using the selectors that appear when hovering the mouse over a task.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击它们并同时按住*Ctrl*键，或使用鼠标悬停在任务上时出现的选择器来选择一个或多个任务。
- en: Right-click on the selection and select Create task group.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击所选项并选择创建任务组。
- en: In the popup that now appears (not shown in the screenshot), choose a name,
    description, and category for the task group. If any of the selected tasks have
    a variable value specified, you can now provide a default value and description
    for these parameters. These parameters will be available within the task group
    and need to be configured when the task group is used.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出窗口中（截图未显示），选择任务组的名称、描述和类别。如果选择的任务中有指定变量值，现在可以为这些参数提供默认值和描述。这些参数将在使用任务组时可用，并且需要在使用任务组时进行配置。
- en: After clicking Create (not shown in the screenshot), the existing build definition
    is updated by removing the selected tasks and replacing them with the new task
    group.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击创建（截图未显示）后，现有的构建定义将被更新，删除所选任务并用新的任务组替换它们。
- en: Adding an already existing task group to a build or release definition is done
    in precisely the same way as adding regular tasks. Task groups show up in the
    same list of tasks to choose from.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将已有的任务组添加到构建或发布定义中的方法与添加常规任务完全相同。任务组显示在可供选择的任务列表中。
- en: A list of all the existing task groups can be found by navigating to the Pipelines
    menu and then Task groups. To edit an existing task group, select it in the list
    that is shown, and select the Edit option. Editing task groups works in precisely
    the same way as editing a build definition.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 可通过导航到管道菜单然后选择任务组找到所有现有的任务组列表。要编辑现有任务组，请在显示的列表中选择它，然后选择编辑选项。编辑任务组的方式与编辑构建定义完全相同。
- en: This section was all about creating a build definition and describing how an
    application should be built. The next section is about executing the build.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讲解了创建构建定义及描述应用程序构建方式的内容。下一节是执行构建。
- en: Running a build
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行构建
- en: In this section, you will learn how to work with the build results and use them
    to report and generate builds. You will also learn how to run a build with every
    pull request and report the quality of the changes back to that pull request to
    assist the reviewer.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何处理构建结果，并用它们来报告和生成构建。您还将学习如何在每次拉取请求时运行构建，并将变更的质量报告回到拉取请求，以帮助审阅者。
- en: Viewing the build results
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看构建结果
- en: 'While a build is running, an agent will perform all the configured steps one
    by one. Azure Pipelines will capture detailed information and logs from all these
    steps. As you can see in the following screenshot, a build will display a list
    of all the steps it has executed on the left. Clicking on any of these steps will
    open a detailed view that displays the logs per step:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建运行时，代理将按顺序执行所有配置的步骤。Azure Pipelines 会捕获所有这些步骤的详细信息和日志。如以下截图所示，构建会在左侧显示其执行的所有步骤列表。点击任何一个步骤将打开一个详细视图，显示每个步骤的日志：
- en: '![](img/4147fb46-d394-4aa6-9413-c6f24dd82f74.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4147fb46-d394-4aa6-9413-c6f24dd82f74.png)'
- en: Whenever there are warnings or errors during the build, they show up in orange
    or red, respectively.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 每当构建过程中出现警告或错误时，它们分别以橙色或红色显示。
- en: Building a pull request
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建拉取请求
- en: 'After setting up your build definition and running your first builds, you might
    also see the first failures coming in—for example, when someone accidentally commits
    and pushes changes that do not compile or contain unit tests that do not run successfully.
    You can prevent this by having a build definition run automatically whenever a
    pull request comes in. To configure this, go through the following steps:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好构建定义并运行第一次构建后，你可能会看到第一次失败的出现——例如，当有人不小心提交并推送了无法编译或包含无法成功运行的单元测试的更改时。你可以通过在拉取请求到达时自动运行构建定义来防止这种情况发生。要进行配置，请按照以下步骤操作：
- en: 'Click on Policies under Project Settings. The following screen will open. Click
    on Add build policy:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目设置中点击“策略”（Policies）。会打开以下屏幕，点击“添加构建策略”（Add build policy）：
- en: '![](img/26a16b99-d5cc-41a7-a202-029d9db74fc0.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26a16b99-d5cc-41a7-a202-029d9db74fc0.png)'
- en: Select a build definition that you want to use to validate the pull request.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个构建定义，用于验证拉取请求。
- en: 'Next, there will be three more things that you can configure:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你可以配置另外三项内容：
- en: 'Trigger: When the build definition should start, either automatically or manually.
    Of course, the real value comes from running a verification build automatically.'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发器：定义构建定义何时启动，可以是自动启动或手动启动。当然，真正的价值来自于自动运行验证构建。
- en: 'Policy requirement: This determines whether a pull request can be completed
    if the build fails. In other words, this determines whether you can ignore a failing
    build. It is recommended that you avoid setting this to Optional, if possible.'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略要求：这决定了如果构建失败，拉取请求是否可以完成。换句话说，这决定了你是否可以忽略失败的构建。建议尽可能避免将此设置为“可选”（Optional）。
- en: 'Build expiration: This determines how long a positive build result is valid
    for. The default value is `12` hours, but you should consider changing this to
    Immediately when master is updated. The advantage of this is that you cannot merge
    changes without first running the build against a combination of the current state
    of the branch that you will merge to and the proposed changes.'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建过期时间：这决定了一个成功的构建结果有效的时间长度。默认值为`12`小时，但你应该考虑在主分支更新时将其更改为立即。这样做的好处是，无法在未先运行构建并验证当前分支状态与拟议更改组合的情况下合并更改。
- en: You can add more than one build policy. If you have a lot of things that you
    can automatically validate and want to keep automated validation times to a minimum,
    then this is a good approach.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加多个构建策略。如果你有很多可以自动验证的内容，并且希望将自动验证时间保持在最低，那么这种方法是一个不错的选择。
- en: Accessing build artifacts
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问构建构件
- en: As well as compiling, testing, and validating your source code, builds can also
    be used to generate what are called artifacts. Artifacts are the outputs from
    a build and can be anything that you want to save and publish from a build, such
    as test results and application packages.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除了编译、测试和验证源代码外，构建还可以用于生成所谓的构件。构件是构建过程中的输出，可以是你希望从构建中保存和发布的任何内容，例如测试结果和应用程序包。
- en: 'An application package is intended to be an immutable build of a version of
    your application. This package can later be picked up in a release and deployed
    to one or more environments:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序包是指应用程序某个版本的不可变构建。该包稍后可以在发布过程中被提取，并部署到一个或多个环境中：
- en: '![](img/3c26cc7c-4394-41bd-ab9d-ea72dfed90ae.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c26cc7c-4394-41bd-ab9d-ea72dfed90ae.png)'
- en: In the preceding screenshot, you can see, as part of the summary of an executed
    build, that there were two artifacts published. Artifacts can be accessed from
    either the Artifacts drop-down menu at the top-right corner of the screen or from
    the Summary tab. You can download and explore artifacts from this page and, in
    the next chapter, you will see how to work with them to set up continuous delivery.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到，在执行构建的摘要部分，发布了两个工件。可以通过屏幕右上角的“工件”下拉菜单或“摘要”标签访问工件。你可以从此页面下载并浏览工件，在下一章中，你将看到如何使用这些工件来设置持续交付。
- en: Great! With this, you have learned how to create a definition using the visual
    designer. But wait—as we mentioned earlier, there is another way of doing this,
    which is by using YAML files. Let's see how this works in the next section.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！通过这个，你已经学会了如何使用可视化设计器创建定义。但等等——正如我们之前提到的，还有另一种方法，那就是使用 YAML 文件。让我们在下一节中看看这个方法是如何工作的。
- en: Working with YAML pipelines
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 YAML 流水线
- en: You have seen how to create a build definition using the visual designer. A
    new, alternative approach, which has been available since early 2019, is the use
    of YAML pipelines. When working with YAML pipelines, you specify your complete
    build definition in a YAML file and store it in source control, often next to
    the source code that the build is for.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看过如何使用可视化设计器创建构建定义。从 2019 年初开始，另一种新的替代方法是使用 YAML 流水线。在使用 YAML 流水线时，你需要在 YAML
    文件中指定完整的构建定义，并将其存储在源代码控制中，通常与构建所针对的源代码一起存储。
- en: While both pipeline systems coexist, using YAML pipelines is now the preferred
    approach for defining pipelines. This means that it is very likely that new features
    will only surface in YAML pipelines.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然两种流水线系统并存，但现在使用 YAML 流水线是定义流水线的首选方法。这意味着新特性很可能只会出现在 YAML 流水线中。
- en: The reason for using build definitions as code
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用构建定义作为代码的原因
- en: When you first start working with YAML build definitions, you might find that
    the learning curve is steeper than it is when working with the visual designer.
    This might raise the question as to why you would use YAML-defined builds. There
    are two main advantages that YAML build definitions have over visually designed
    definitions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次开始使用 YAML 构建定义时，你可能会发现学习曲线比使用可视化设计器时更陡峭。这可能会引发一个问题，为什么你要使用 YAML 定义的构建。YAML
    构建定义相较于可视化设计定义有两个主要优点。
- en: When you are writing your definition in YAML, it can be hosted in source control
    next to your code. The consequence of this is that all the policies that you have
    in place for changing source control now automatically apply to your build definition.
    This means that any change must go through a pull request, be reviewed by a peer,
    and can be built and verified ahead of time. Enforcing the **four-eyes principle**
    on your build definition, as well as your code, increases the stability of your
    build process. Of course, it also benefits security and compliance, topics that
    will be discussed in later chapters.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 YAML 中编写定义时，它可以与代码一起托管在源代码控制中。这样做的结果是，你在更改源代码控制时所制定的所有策略现在会自动应用于你的构建定义。这意味着任何更改都必须通过拉取请求，经过同行审查，并且可以提前进行构建和验证。在你的构建定义和代码中强制执行**四眼原则**，有助于提高构建过程的稳定性。当然，这也有助于安全性和合规性，这些话题将在后续章节中讨论。
- en: As well as this increase in security, having the build definition in source
    control also means that it is available in every branch. This means that it can
    be changed in every branch to build that specific branch before merging it to
    the master branch. When working with a visually designed build definition, this
    single definition is responsible for building not only your master branch but
    also all the branches that you want to merge through a pull request.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提高安全性之外，将构建定义存储在源代码控制中，还意味着它在每个分支中都是可用的。这意味着它可以在每个分支中进行更改，以便在合并到主分支之前构建该特定分支。当使用可视化设计的构建定义时，这个单一的定义负责构建不仅仅是你的主分支，还包括你希望通过拉取请求合并的所有分支。
- en: 'This means that you must do one of the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你必须执行以下操作之一：
- en: Update the build definition for the change that you will merge. However, this
    will terminate building of the current state of the master branch.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新构建定义，以便合并你将要合并的更改。然而，这将导致当前主分支的构建中止。
- en: Merge the change, which will also result in a broken build since the build definition
    has not yet been updated.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并更改，这也会导致构建失败，因为构建定义尚未更新。
- en: Either option has the risk of allowing faulty changes to flow through the target
    branch, defeating the purpose of a continuous integration build. With a build
    definition per branch, we eradicate this problem.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种选项都有可能允许错误的更改流入目标分支，从而破坏持续集成构建的目的。通过为每个分支创建一个构建定义，我们消除了这个问题。
- en: While having build definitions in source control is beneficial, this is also
    available in classic builds. Every change is recorded and you can see who has
    changed what and when, along with an optional explanation from the author of the
    change.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将构建定义存储在源代码控制中是有益的，但这在经典构建中也同样适用。每个更改都会被记录，您可以看到谁在何时更改了什么，并且可以查看更改作者的可选说明。
- en: Writing a basic YAML pipeline
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写基本的 YAML 管道
- en: 'To get started with YAML builds, there are two things you need to do:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 YAML 构建，您需要做两件事：
- en: First, you need to write your YAML file.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要编写您的 YAML 文件。
- en: Then, you need to create a build definition out of it.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您需要从中创建一个构建定义。
- en: So, let's get started.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。
- en: Writing the YAML file
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 YAML 文件
- en: 'The following code sample contains an example YAML definition for building
    a .NET Core application and running unit tests. Save a file with any name, for
    example, `pipeline.yaml`, in any Git repository in Azure DevOps. Then, it can
    be used to create a pipeline out of it later on:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例包含了构建 .NET Core 应用程序并运行单元测试的示例 YAML 定义。将文件保存为任意名称，例如 `pipeline.yaml`，并放入
    Azure DevOps 中的任意 Git 仓库中。然后，稍后可以使用它创建一个管道：
- en: '[PRE3]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This example YAML defines a basic pipeline. Every pipeline needs to be triggered
    in some way. Just as with classic builds, this can be done by connecting the pipeline
    to a change in a source code repository. The default repository for this is the
    repository that also contains the YAML definition. The `trigger` keyword is used
    to specify a push to which branches should trigger the pipeline. A good starting
    point is the `master` branch. As the `trigger` keyword accepts a list, multiple
    branches can be specified and wildcards can be used.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例 YAML 定义了一个基本的管道。每个管道都需要以某种方式被触发。就像经典构建一样，可以通过将管道连接到源代码仓库中的变更来触发管道。默认的仓库是包含
    YAML 定义的仓库。`trigger` 关键字用于指定哪些分支的推送应触发管道。一个好的起点是 `master` 分支。由于 `trigger` 关键字接受一个列表，可以指定多个分支并使用通配符。
- en: A trigger is not mandatory as a pipeline can also be started manually.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器不是必需的，因为管道也可以手动启动。
- en: There are also alternative options to using the `trigger` keyword, such as to
    include or exclude one or more branches, tags, or paths in the repository. These
    options are described in detail at [https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema#triggers](https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema#triggers).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他选项可以替代使用 `trigger` 关键字，例如在仓库中包括或排除一个或多个分支、标签或路径。这些选项在 [https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema#triggers](https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema#triggers)
    中有详细描述。
- en: As well as a trigger, every pipeline contains one or more tasks, just as in
    classic build definitions. All these tasks need to execute on an agent pool—again,
    just as in classic build definitions. The `pool` keyword is used to specify a
    set of key/value pairs that determine which pool the tasks will run on by specifying
    the name of the pool. When working with the default agents that Microsoft provides,
    the default name of `Azure Pipelines` can be used. When using this specific pool,
    a VM image has to be specified. This determines which operating system and what
    software is available on the agent that will execute the task.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 除了触发器外，每个管道还包含一个或多个任务，就像经典构建定义中的任务一样。所有这些任务需要在代理池上执行——同样，就像经典构建定义中的任务一样。`pool`
    关键字用于指定一组键/值对，通过指定池的名称来决定任务将在哪个池上运行。在使用 Microsoft 提供的默认代理时，可以使用 `Azure Pipelines`
    的默认名称。在使用此特定池时，必须指定一个虚拟机映像。这决定了将执行任务的代理上可用的操作系统和软件。
- en: An up-to-date list of all the VM images that are available can be found at [https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/hosted#use-a-microsoft-hosted-agent](https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/hosted#use-a-microsoft-hosted-agent).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 [https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/hosted#use-a-microsoft-hosted-agent](https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/hosted#use-a-microsoft-hosted-agent)
    找到所有可用的虚拟机映像的最新列表。
- en: Finally, the definition contains a list of the steps that make up the pipeline
    itself. These steps correspond one-to-one with the tasks that you could drag into
    a classic build pipeline. A task is added by specifying the name and version—separated
    by the `@` sign—of the task that you want to run. Next, you can optionally specify
    a display name for the task. This display name will later be visible in the views
    that show the results of an executed pipeline. Finally, specify one or more inputs
    for the task. These inputs relate to the task-specific configuration that you
    have already seen for the visual designer.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Creating a YAML pipeline
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After saving your YAML file in a repository, you can create a build definition
    from it. When creating a new build definition (see the *Creating a build definition* section of
    this chapter), you should go through the following steps:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Choose the Azure Repos Git YAML option when the wizard starts.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From here, go through the wizard to select and review the YAML you want to
    build, as in the following screenshot:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/83bd90aa-8c2b-4693-b350-2524c05755be.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: In the first step, you locate the repository that contains the YAML file that
    you want to use as your pipeline.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you configure the pipeline by choosing an example YAML file to start from
    or by referring to an already existing file.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, you can review the YAML file that you have selected and start a build
    from it.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your pipeline is saved automatically. Once the pipeline is saved, it can be
    started and you can interact with it in the same way as you would with classic
    build pipelines.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Multi-job pipelines
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The pipeline you saw in the previous section does not specify any jobs, as
    you may recall from the section on classic builds. Instead, it contains a list
    of tasks under the `steps` keyword. This means that it implicitly contains only
    a single job. With YAML pipelines, it is also possible to create a definition
    that contains more than one job. To do this, the following structure can be used:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Instead of adding the `steps` keyword directly to the pipeline, first, a list
    of jobs is created. Within that list, one or more `job` keywords are added, followed
    by the name for that job. Next to this technical name, a display name (`displayName`)
    can be specified for each job.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: As the second job in this example shows, it is also possible to specify which
    agent pool to use per job. When no pool is specified for a job, the default pool
    specified at the top of the file is used.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The jobs that are discussed in this section are called agent jobs. Besides agent
    jobs, there are also server jobs, container jobs, and deployment jobs available.
    More information about these types of jobs can be found at [https://docs.microsoft.com/en-us/azure/devops/pipelines/process/phases#types-of-jobs](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/phases#types-of-jobs).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: By default, all the jobs in a pipeline run in parallel, but there are control
    options available to change this.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Control options
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制选项
- en: 'To control the order of jobs, the `dependsOn` keyword can be used on the definition
    of a job. This signals that the job can only be started after one or more jobs
    are completed. Besides this, the `condition` keyword can be used to specify a
    condition that a job should run under. These two keywords can be combined to realize
    more complex scenarios, such as the one shown here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制作业的顺序，可以在作业定义中使用 `dependsOn` 关键字。这表明该作业只能在一个或多个作业完成后才可以开始。除此之外，还可以使用 `condition`
    关键字来指定作业应在何种条件下运行。可以将这两个关键字结合起来，实现更复杂的场景，如下所示：
- en: '[PRE5]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This pipeline will start by running the job named `compile`. Once this job completes,
    the next two jobs, `test` and `build_schema`, will run in parallel as they both
    depend on the `compile` task. After both of these tasks complete, the report task
    runs as it declares a dependency on both the `test` and `build_schema` jobs. Before
    this job actually starts, the condition is evaluated to determine whether the
    job should actually run or be skipped. Conditions can be built using a syntax
    that is similar to many programming languages. It checks the successful completion
    of a job using the `succeeded()` and `failed()` functions. There is also support
    for Boolean operators such as `or()`, `and()`, and `ne()`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个管道将首先运行名为 `compile` 的作业。一旦该作业完成，接下来的两个作业，`test` 和 `build_schema`，将并行运行，因为它们都依赖于
    `compile` 任务。在这两个任务完成后，`report` 任务将运行，因为它声明依赖于 `test` 和 `build_schema` 作业。在这个作业实际开始之前，会评估条件，以决定该作业是否真正运行或跳过。条件可以使用类似于许多编程语言的语法来构建。它检查作业是否成功完成，使用
    `succeeded()` 和 `failed()` 函数。此外，还支持 `or()`、`and()` 和 `ne()` 等布尔运算符。
- en: You can combine the `dependsOn` and `condition` keywords in any way you see
    fit. The only requirement is that there should be at least one job that does not
    depend on any other job.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要组合使用 `dependsOn` 和 `condition` 关键字。唯一的要求是，至少应有一个作业不依赖于任何其他作业。
- en: Variables
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: 'Just like classic build pipelines, YAML pipelines support the use of variables.
    Variables can be defined at every level of a YAML pipeline (except for within
    a task) using the following syntax:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 就像经典构建管道一样，YAML 管道支持使用变量。变量可以在 YAML 管道的每个级别（任务内除外）使用以下语法定义：
- en: '[PRE6]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Variables can later be retrieved using the syntax that you already know from
    classic build pipelines—`$(name)` and `$(anotherName)`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以使用你已经熟悉的经典构建管道语法来检索——`$(name)` 和 `$(anotherName)`。
- en: 'It is also possible to reference existing variable groups from within a YAML
    pipeline. This is done by using the `group` keyword, instead of specifying the
    name of a variable. To also retrieve all the variables from a variable group called
    `myVariableGroup`, you would extend the preceding YAML, as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在 YAML 管道中引用现有的变量组。这是通过使用 `group` 关键字来完成的，而不是指定变量的名称。要从名为 `myVariableGroup`
    的变量组中检索所有变量，可以将前面的 YAML 扩展如下：
- en: '[PRE7]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Variables can be set at every level in a YAML pipeline, but only variables set
    at the root level can be overridden when queuing a new execution manually.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以在 YAML 管道的每个级别设置，但只有在根级别设置的变量可以在手动排队新执行时被覆盖。
- en: Pipeline artifacts
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道工件
- en: Just like classic builds, YAML pipelines can be used to build and publish artifacts.
    As the task used to do this is a task like any other, it can be added directly
    to the list of steps in a job.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 就像经典构建一样，YAML 管道可以用于构建和发布工件。由于用于执行此任务的任务与其他任务一样，它可以直接添加到作业的步骤列表中。
- en: However, with the introduction of YAML pipelines, a new type of artifact has
    become available—the so-called pipeline artifact. This comes with the benefit
    of improving the speed at which large artifacts can be uploaded and downloaded.
    When working with classic releases, pipeline artifacts are not automatically downloaded,
    whereas build artifacts are.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着 YAML 管道的引入，一种新的工件类型——所谓的管道工件——已经可用。这带来了提高大规模工件上传和下载速度的好处。在使用经典发布时，管道工件不会自动下载，而构建工件会。
- en: 'To publish a pipeline artifact, the following YAML can be used in the `steps` keyword
    of a job:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要发布管道工件，可以在作业的 `steps` 关键字中使用以下 YAML：
- en: '[PRE8]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Pipeline artifacts are mainly intended to be downloaded in multi-stage YAML
    pipelines, which are also covered in the next chapter.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 管道工件主要用于在多阶段 YAML 管道中下载，后续章节也会涉及此内容。
- en: Tips for writing YAML pipelines
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 YAML 管道的技巧
- en: Writing YAML pipelines from scratch can be complicated when you are just getting
    started. There are two tools available that can help you.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 从零开始编写 YAML 管道在你刚开始时可能会比较复杂。此时有两个工具可以帮助你。
- en: First, there is the option to export YAML from the visual designer. For every
    task, there is a link with the View YAML title. This opens a small pop-up box
    that shows you the YAML corresponding to the task and configuration that you currently have open.
    The same can be done for jobs and, under specific conditions, for complete build
    definitions.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，可以从可视化设计器导出 YAML。对于每个任务，都有一个带有“查看 YAML”标题的链接。点击该链接会弹出一个小窗口，显示你当前打开的任务和配置对应的
    YAML。同样的操作也可以用于作业，并且在特定条件下也可以用于完整的构建定义。
- en: 'The other tool available for writing YAML is the built-in YAML editor:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于编写 YAML 的工具是内置的 YAML 编辑器：
- en: '![](img/af66f656-bb67-4536-9b45-f8758f4407eb.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af66f656-bb67-4536-9b45-f8758f4407eb.png)'
- en: Whenever you open a YAML build definition, there are two tools available to
    help you. First, there is autocompletion for every location in your YAML file.
    This shows you the options available at that point in the file. As well as this,
    there are snippets available in the task picker on the right. When selecting any
    of the tasks on the right, you configure them visually and then click the Add
    button to add the generated YAML to your definition.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你打开一个 YAML 构建定义时，有两个工具可以帮助你。首先，在 YAML 文件的每个位置都有自动完成功能。它会显示该位置可用的选项。此外，在右侧的任务选择器中也有代码片段可供选择。当选择右侧的任何任务时，你可以通过可视化配置它们，然后点击添加按钮将生成的
    YAML 添加到你的定义中。
- en: These two tools aim to bring the ease of the visual designer to the YAML build
    experience as well, combining the best of both worlds.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个工具旨在将可视化设计器的简便性带入 YAML 构建体验，结合两者的优势。
- en: Agents and agent queues
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理和代理队列
- en: 'The build definitions that you have created so far can contain agent jobs,
    which in turn contain tasks. These tasks are not executed within your Azure DevOps
    organization directly, but are executed by agents that run on VMs or in containers.
    In turn, agents are grouped in agent pools. There are two types of agent pools
    that you can work with:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你创建的构建定义可能包含代理作业，而这些作业又包含任务。这些任务并不会直接在你的 Azure DevOps 组织中执行，而是由在虚拟机或容器中运行的代理执行。代理被分组到代理池中。你可以使用两种类型的代理池：
- en: Built-in agent pools
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置代理池
- en: Self-hosted agent pools
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自托管代理池
- en: Let's go through them one by one.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一了解它们。
- en: Built-in agent pools
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置代理池
- en: Built-in agent pools are managed by Microsoft and are made available to you
    as part of the product. There are different agent pools available, depending on
    your needs. Pools run different versions of Windows and Visual Studio, and there
    are also pools available that run Linux (Ubuntu) and macOS.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 内置代理池由微软管理，作为产品的一部分提供给你。根据你的需求，提供不同的代理池。这些池运行不同版本的 Windows 和 Visual Studio，同时也有运行
    Linux（Ubuntu）和 macOS 的池。
- en: The disadvantage of these managed pools is that you cannot install extra software
    on the machines or containers that host the agents if you need to. This means
    that in these cases, you have to create your own private agent pools.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这些托管池的缺点是，如果你需要，你无法在托管代理的机器或容器上安装额外的软件。这意味着，在这些情况下，你必须创建自己的私有代理池。
- en: Creating a private agent pool
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建私有代理池
- en: 'Private pools are defined in your Azure DevOps organization and are provisioned from
    there to one or more of your team projects. However, you can also create your
    private pools at the team project level, in case they are created and provisioned
    in one go. To do so, go to Project Settings | Agent pools. You should see the
    following Add agent pool option:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 私有池在你的 Azure DevOps 组织中定义，并从那里提供到一个或多个团队项目。然而，你也可以在团队项目级别创建私有池，以便一次性创建和提供它们。为此，进入
    项目设置 | 代理池。你应该会看到以下的添加代理池选项：
- en: '![](img/374c4de3-0979-4895-a050-00de8ea00fc7.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/374c4de3-0979-4895-a050-00de8ea00fc7.png)'
- en: After giving the pool a name and determining whether you want to automatically
    provide access to all pipelines, you can save the pool. After creating the pool,
    you can add or remove agents.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 给池命名并确定是否希望自动为所有管道提供访问权限后，你可以保存池。在创建池之后，你可以添加或移除代理。
- en: Adding and removing agents
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加和移除代理
- en: 'Adding an agent is done in two steps:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 添加代理分为两步：
- en: 'Download and extract the agent runtime. You can find the agent runtime by going
    to the section with the overview of the agent pools and opening the details of
    any private agent pool. After the details of the pool are opened, click on New
    agent in the top-right corner:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并提取代理运行时。你可以通过访问代理池概览部分并打开任何私有代理池的详细信息来找到代理运行时。打开池的详细信息后，点击右上角的“新建代理”：
- en: '![](img/59d02297-1f43-4e8f-bde5-2b8379a57611.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59d02297-1f43-4e8f-bde5-2b8379a57611.png)'
- en: In the dialog that opens, you can download a ZIP file with the agent and instructions
    for extracting and installing the agent.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的对话框中，你可以下载一个包含代理和提取及安装代理说明的 ZIP 文件。
- en: During the configuration phase, you will be prompted to authenticate with your
    Azure DevOps organization and to provide the name of the agent pool you want to
    install the agent in. While there are x86 and x64 agents available, it is recommended
    that you work with the x64 agent unless you have a specific reason not to.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置阶段，系统会提示你使用你的 Azure DevOps 组织进行身份验证，并提供你希望安装代理的代理池名称。虽然有 x86 和 x64 代理可用，但建议你使用
    x64 代理，除非你有特殊原因不使用它。
- en: 'To remove agents from the pool, you can use one of two methods:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要从池中移除代理，你可以使用两种方法：
- en: 'You can return to the PowerShell command line, just as you did for the installation,
    and use the following command:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以返回 PowerShell 命令行，就像安装时一样，使用以下命令：
- en: '[PRE9]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As an alternative, you can also remove agents from the agent pool overview
    using the Agents tab. Go to Project Settings | Agent pools (see label 1 in the
    following screenshot) | Agents (see label 2 in the following screenshot) and then
    select the options button (see label 3 in the following screenshot) on the agent
    you want to remove. Then, click Delete (see label 4 in the following screenshot):'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另外，你还可以通过代理标签页从代理池概览中移除代理。前往“项目设置” | “代理池”（参见以下截图中的标签1）| “代理”（参见以下截图中的标签2），然后选择你要移除的代理的选项按钮（参见以下截图中的标签3）。接着，点击“删除”（参见以下截图中的标签4）：
- en: '![](img/5a0300ca-a7e6-4c92-bb7b-876bd3ed1333.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a0300ca-a7e6-4c92-bb7b-876bd3ed1333.png)'
- en: In the preceding screenshot, you can see the steps to remove an agent using
    the interface. Be aware that this does not clean up the binaries and any files
    on the host machine; however, if a machine that is hosting an agent breaks down
    or a VM is removed, then this is the only way to remove the agent.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，你可以看到使用界面移除代理的步骤。请注意，这不会清理主机上的二进制文件和任何文件；然而，如果托管代理的机器出现故障或虚拟机被移除，这就是移除代理的唯一方法。
- en: Agent selection
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理选择
- en: 'Whenever a build job starts running, an agent is selected from the pool that
    will perform the tasks that you have defined in the pipeline. The selection of
    an agent is done in two steps:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 每当构建作业开始运行时，系统会从代理池中选择一个代理来执行你在管道中定义的任务。选择代理的过程分为两个步骤：
- en: Only agents that are part of the selected pool are eligible for running the
    tasks. This means that when working with private agent pools, it is wise to have
    multiple agents in a pool. If you then take one agent offline for maintenance,
    the agent jobs that rely on the agent pool can continue running.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有属于选定池的代理才有资格运行任务。这意味着，在使用私有代理池时，最好池中有多个代理。这样，当你将一个代理下线进行维护时，依赖该代理池的代理作业仍然可以继续运行。
- en: Before an agent job can run, the demands from each job and the tasks it contains
    are gathered. As you learned in the *Variable groups *section, an agent job can
    specify the demands it has of the agent that it uses. The same goes for tasks—they
    can also specify demands. To run a job, only agents that meet all of these demands
    are used. Demands and capabilities are key–value pairs, where the value is an
    integer. An example capability is `msbuild=15.0` and the corresponding demand
    is `msbuild>15.0`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代理作业可以运行之前，会收集每个作业的需求及其包含的任务。如同你在*变量组*部分中学到的，代理作业可以指定它所使用的代理的需求。任务也是如此——它们也可以指定需求。要运行作业，只有符合所有这些需求的代理才会被使用。需求和功能是键值对，其中值是整数。例如，功能是`msbuild=15.0`，相应的需求是`msbuild>15.0`。
- en: When there is no eligible agent for a build definition, the build eventually
    fails after a timeout.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有合适的代理来满足构建定义时，构建会在超时后最终失败。
- en: Finding agent capabilities
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找代理功能
- en: 'To find the capabilities that are available on the individual agents, go through
    the following steps:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找各个代理上可用的功能，请按照以下步骤操作：
- en: 'Navigate to Organization Settings | Agent pools:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到“组织设置” | “代理池”：
- en: '![](img/8b8d2080-5d74-4bc2-b1d4-111d245951e5.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b8d2080-5d74-4bc2-b1d4-111d245951e5.png)'
- en: Navigate to the correct agent pool (either hosted or private) and then Agents,
    and then open the agent details (not shown in the preceding screenshot).
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到正确的代理池（无论是托管的还是私有的），然后点击“Agents”，接着打开代理详情（在前面的截图中未显示）。
- en: Open the Capabilities tab.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“Capabilities”标签。
- en: Here, you can specify one or more custom capabilities for the agent using the
    top block, called User-defined capabilities. For self-hosted (private) agents,
    all the capabilities that were discovered on the machine when you installed the
    agent are also shown.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以使用顶部块（称为用户定义的能力）为代理指定一个或多个自定义能力。对于自托管（私有）代理，在安装代理时，机器上发现的所有能力也会显示。
- en: Azure DevOps is not the only tool available for running continuous integration
    builds. The next section will take you through a couple of other tools.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Azure DevOps 并不是唯一可用于运行持续集成构建的工具。下一节将带你了解其他几种工具。
- en: Other tools
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他工具
- en: There are many tools available besides Azure DevOps. Two other well-known tools
    are GitLab CI and Jenkins. Some very basic knowledge of these tools will help
    you to understand how to integrate with them if that is ever necessary. Also,
    a limited understanding of other tools will help you to more quickly understand
    the concepts and generalize your knowledge of how to work with these other tools.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Azure DevOps 之外，还有许多其他工具可用。另有两个著名的工具是 GitLab CI 和 Jenkins。对这些工具的基本了解将帮助你理解如何在必要时与它们集成。此外，有限的了解其他工具将帮助你更快速地理解概念并概括你如何与这些工具一起工作。
- en: To highlight how these tools work with the same concepts, both examples in this
    section are equivalent to the Azure DevOps YAML pipeline in the *Writing a YAML
    build definition *section*.*
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了突出这些工具如何与相同概念协作，本节中的两个示例与 *“编写 YAML 构建定义”* 部分中的 Azure DevOps YAML 管道是等效的。
- en: GitLab CI
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitLab CI
- en: 'GitLab offers build pipelines using the GitLab CI capabilities. GitLab CI is
    configured by putting a file with the `.gitlab-ci.yml` name in the root of a repository.
    In this file, you can define one or more stages and jobs, along with the tasks
    that they should perform. An example YAML file for GitLab CI can appear as in
    the following example:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 提供了通过 GitLab CI 功能构建管道。GitLab CI 通过将一个名为`.gitlab-ci.yml`的文件放置在仓库的根目录中进行配置。在这个文件中，你可以定义一个或多个阶段和任务，以及它们应该执行的任务。GitLab
    CI 的 YAML 示例文件如下所示：
- en: '[PRE10]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Just as Azure DevOps uses agent pools with agents, GitLab CI relies on **runners** to
    perform the actual work. In GitLab CI, there is currently no support for visually
    creating or editing your pipelines.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 Azure DevOps 使用代理池和代理一样，GitLab CI 依赖于 **runners** 来执行实际的工作。在 GitLab CI 中，目前不支持视觉化创建或编辑管道。
- en: Jenkins
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins
- en: 'Jenkins is another tool used to run build pipelines. Complex builds can be
    run using Jenkins pipelines, which get their work from a Jenkinsfile. A **Jenkinsfile**
    is written in a Jenkins-specific notation, as in the following code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 是另一种用于运行构建管道的工具。复杂的构建可以通过 Jenkins 管道运行，这些管道从 Jenkinsfile 获取工作。**Jenkinsfile**
    是用 Jenkins 特定的符号编写的，如下代码所示：
- en: '[PRE11]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Jenkins has limited support for visually creating and editing a pipeline. This
    is referred to as a freestyle project.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 对于视觉化创建和编辑管道的支持有限。这被称为自由式项目（freestyle project）。
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we looked at continuous integration and learned how it is a
    combination of your mindset, the process, and tools. You learned how to create
    build definitions using Azure Pipelines using both the graphical designer and
    YAML, as well as how to run builds. You learned that you can use build pipelines
    to compile and test your code, as well as report the outcome back to pull requests.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们了解了持续集成，并学习了它是你的思维方式、流程和工具的结合。你学习了如何使用 Azure Pipelines 创建构建定义，既可以使用图形设计器也可以使用
    YAML，同时学习了如何运行构建。你了解了可以使用构建管道来编译和测试代码，并将结果报告回拉取请求。
- en: You learned that builds can produce outcomes, called artifacts. Artifacts are
    stored and retained within Azure pipelines and can be used to store reports, but
    are also the starting point of deployment pipelines, which you will learn about
    in the next chapter. You also learned about the infrastructure that you need to
    run builds—namely, agents and agent pools. Finally, you saw two brief examples
    of how to run a continuous integration build using GitLab CI and Jenkins, which
    are two other tools that you can use for build pipelines.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, you are now able to create build pipelines for your projects.
    You can hook up to source control and produce the builds that you will use in
    the next chapter to deploy your applications. With this deep knowledge of the
    underlying structure of tasks, jobs, stages, and pipelines, you can solve complex
    application-building problems.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will continue learning about pipelines, but this time
    for releases. You will learn how to pick up builds and release them to one or
    more environments.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the appendix:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: True or false – you achieve continuous integration if you compile all the branches
    of your project at least daily.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false – a classic build definition is always connected to a source code
    repository.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false – a YAML pipeline definition is always connected to a source code
    repository.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is needed to call an external tool from an Azure pipeline?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An external service definition
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An Azure services connection
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A service connection
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A service locator
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some common reasons for using self-hosted agents? (Choose all of the
    correct answers from the following:)
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access to closed networks is needed.
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Specific extension tasks need to be available to the agent.
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The number of parallel pipeline executions needs to be larger than 10.
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Specific software needs to be installed in order for the agent to use it.
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An in-depth definition of continuous integration by Martin Fowler is available
    at [https://martinfowler.com/articles/continuousIntegration.html](https://martinfowler.com/articles/continuousIntegration.html).
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A detailed description of the conditions syntax is available at [https://docs.microsoft.com/en-us/azure/devops/pipelines/process/conditions?view=azure-devops&tabs=classic](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/conditions?view=azure-devops&tabs=classic).
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises for practicing with Azure DevOps builds can be found at [https://docs.microsoft.com/en-us/learn/modules/create-a-build-pipeline/index](https://docs.microsoft.com/en-us/learn/modules/create-a-build-pipeline/index).
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the Visual Studio marketplace for Azure DevOps at [https://marketplace.visualstudio.com/azuredevops](https://marketplace.visualstudio.com/azuredevops).
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find a detailed description of the Azure Pipelines YAML syntax at [https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devops&tabs=schema](https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devops&tabs=schema).
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 [https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devops&tabs=schema](https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devops&tabs=schema)
    找到关于 Azure Pipelines YAML 语法的详细描述。
- en: Details of the pricing of the Azure pipelines hosted and self-hosted agent pools
    are available at [https://azure.microsoft.com/en-us/pricing/details/devops/azure-pipelines/](https://azure.microsoft.com/en-us/pricing/details/devops/azure-pipelines/).
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 管道托管和自托管代理池的定价详情可在 [https://azure.microsoft.com/en-us/pricing/details/devops/azure-pipelines/](https://azure.microsoft.com/en-us/pricing/details/devops/azure-pipelines/)
    查阅。
- en: More information about GitLab CI can be found at [https://about.gitlab.com/product/continuous-integration/](https://about.gitlab.com/product/continuous-integration/).
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 GitLab CI 的更多信息可以在 [https://about.gitlab.com/product/continuous-integration/](https://about.gitlab.com/product/continuous-integration/)
    找到。
- en: More information about Jenkins can be found at [https://jenkins.io/](https://jenkins.io/).
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Jenkins 的更多信息可以在 [https://jenkins.io/](https://jenkins.io/) 找到。
