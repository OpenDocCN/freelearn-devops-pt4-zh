<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Continuous Deployment</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, you learned how to use Azure DevOps pipelines for continuous integration. Due to this, you now know how to pick up a version of your sources and create artifacts that can be deployed. In this chapter, you will learn how to extend this practice with continuous delivery and continuous deployment so that you automatically deploy these artifacts to the servers or platforms your code is running on.</p>
<p>To do this, we will start by introducing Azure DevOps release definitions so that you can define and run the releases of your application. Next, a series of strategies will be introduced that you can use to perform deployments in a low-risk manner. Doing this makes it possible for you to automate the process of deploying new versions unattended, with a limited risk of incidents occurring. From here, we will shift our attention to automating the creation of release notes. After this, we will introduce App Center, which is used for deploying mobile applications. Finally, other tools for continuous deployment will be introduced.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Continuous delivery and continuous deployment</li>
<li>Working with Azure DevOps releases</li>
<li>Writing multi-stage YAML pipelines</li>
<li>Implementing continuous deployment strategies</li>
<li>Deploying mobile applications</li>
<li>Automating release notes</li>
<li>Other tools</li>
</ul>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To experiment with the techniques described in this chapter, you might need one or more of the following:</p>
<ul>
<li>An Azure DevOps account for building release definitions and multi-stage YAML pipelines</li>
<li>An App Center account for deploying mobile applications</li>
</ul>
<p>Free trial options are available for both of these.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Continuous delivery and continuous deployment</h1>
                </header>
            
            <article>
                
<p>The difference between continuous delivery and continuous deployment is a common source of confusion. Some people think these terms are interchangeable and see them as two synonyms for the same concept, but they have, in fact, two different meanings.</p>
<p>Continuous delivery is a practice where teams ensure that the artifacts they build are continuously validated and ready to be deployed to the production environment. Often, this is done by deploying the artifacts to a production-like environment, such as acceptance or even a staging environment, and applying a series of tests, such as verification tests, to ensure the application is working correctly.</p>
<p>Continuous deployment is a practice where every version that is deployed to a production-like environment and passes all tests and verifications, is also deployed to production automatically.</p>
<p>When working with Azure DevOps, Azure Pipelines is the tool of choice for implementing continuous delivery and deployment. This can be done using either the visual classic editor or with multi-stage YAML pipelines, both of which will be discussed in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with Azure DevOps releases</h1>
                </header>
            
            <article>
                
<p>Continuous delivery and deployment can both be implemented in Azure DevOps by using releases. When creating a new release definition, an outline of the release process is created. This process will often start with an artifact that triggers the creation of a new release. Next, it is possible to define one or more stages that the release can be deployed to. Often, these stages correspond to the different application environments, for example, test and production, but this is not mandatory.</p>
<p>Let's learn how to create a new release definition and explore the various options we have. First, navigate to <span class="packt_screen">Pipelines</span> and choose <span class="packt_screen">Releases</span> from the menu. From here, it is possible to start creating a new release pipeline, which will take us to a screen that looks similar to the one shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1017 image-border" src="assets/0df1b9c6-c830-439d-a27f-2a3da15aa37d.png" style="width:50.75em;height:34.75em;"/></p>
<p>From the preceding screen, we can perform the following actions (these are numbered in the preceding screenshot):   </p>
<ol>
<li>First, notice that, on the left, it is possible to see the outline of the release pipeline with a box. Here, you can select one or more artifacts that can be used in the release pipeline.</li>
<li>To the right of this, there is a box where the different stages of the release can be seen. By default, one stage is created already.</li>
<li>It is possible to pick a template as a starting point for the deployment pipeline for this pre-created stage. Choosing to start with an empty job in this view allows you to craft a custom deployment pipeline from scratch.</li>
</ol>
<p>After choosing a job template or an empty job to start with, the pane on the right will close, and it will be possible to start editing the release pipeline from left to right, starting with the artifacts.  </p>
<p>Once a skeleton release pipeline is visible, the first things you will need to configure are the artifacts that the release should work with. This is the subject of the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating artifacts and release triggers</h1>
                </header>
            
            <article>
                
<p>The previous chapter described build definitions and YAML pipelines, which create artifacts. These artifacts are picked up in releases and form the basis for deploying an application.</p>
<p>To start editing a release pipeline, follow these steps:</p>
<ol>
<li>Click on the <span class="packt_screen">Add an artifact</span> button to start building the starting point of the release definition. This will open the right-hand pane shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1018 image-border" src="assets/be76633f-7932-4fde-b711-e8e339885004.png" style="width:64.58em;height:34.08em;"/></p>
<ol start="2">
<li>In the picker for the project, the current project will be selected by default.</li>
<li>Now, specify the artifacts that the release pipeline should pick up.</li>
<li>After this, the default version to use and the source alias will be automatically selected. The default version can always be overridden when manually starting a release, so <span class="packt_screen">Latest</span> is a sensible default.</li>
<li>The source alias is the name of the folder where the artifacts can be located when we add jobs to the release stages at a later date. The default is often fine.</li>
<li>Finish adding the artifact by clicking <span class="packt_screen">Add.</span></li>
</ol>
<p>Now that we've specified the artifacts to work with, it is time to specify when a new release should be created. Let's learn how to do this:</p>
<ol>
<li>To configure the availability of a new artifact to trigger the release, click on the lightning bolt next to the artifact to open the configuration pane. This can be seen in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1019 image-border" src="assets/79bd2b7c-c408-43a3-8a3d-15b72ea4d7e3.png" style="width:63.75em;height:27.83em;"/></p>
<ol start="2">
<li>In this pane, it is possible to create a new release, when one is available, using the top slider. This will expand a new section where you can define one or more filters so that you can specify conditions under which a new artifact should trigger a release.</li>
<li>Click the <span class="packt_screen">Add</span> button to start adding a condition.</li>
<li>A common example is to only include artifacts that come from the master branch, as shown here.</li>
<li>In addition to artifacts that come from regular builds, it is possible to also allow artifacts that come from pull request builds to start a new release.</li>
<li>Finally, it is possible to create a new release on a fixed schedule.</li>
</ol>
<p>If no schedule and no trigger are specified, a new release will only be created when someone does so manually.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Specifying the stages to deploy the release</h1>
                </header>
            
            <article>
                
<p>After specifying the artifacts to release, it is time to specify one or more stages to deploy the release to. Often, every environment (test, acceptance, and production) will correspond to a stage. But it is also possible to have other stages if the situation calls for it.</p>
<p>Let's learn how to add a new stage and explore various options. First, click on <span class="packt_screen">Pipelines</span> to arrive at the following screen:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1020 image-border" src="assets/30e40337-f0c1-4f8a-b803-63b4fc5b189b.png" style="width:57.33em;height:22.42em;"/></p>
<p>Now, complete the following steps:</p>
<ol>
<li>Click the <span class="packt_screen">Add</span> button to create a new stage. A stage can be either new or a clone of an existing one.</li>
<li>After selecting an already existing stage, it can be removed using the <span class="packt_screen">Delete</span> button on the top right.</li>
<li>Other actions that can be performed on this screen include renaming the stage and designating a stage owner. The owner will be notified when a release is deployed to the environment.</li>
<li>After creating and naming a stage, it is possible to add jobs and tasks to a stage, just like it was possible for a build pipeline. To do this, click on the link in the box that denotes the stage.</li>
</ol>
<p>From here on, this works exactly the same as building pipelines. There is only one addition: besides agent jobs and agentless jobs, it is also possible to use deployment group jobs. These will be discussed in the <em>Working with deployment groups</em> section later on. But first, let's understand which stages we need.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Which stages do I need?</h1>
                </header>
            
            <article>
                
<p>One of the questions that frequently arises when working with releases is, <em>which stages do I need in my release pipeline</em>? According to the documentation, stages should denote the major divisions of a release pipeline. When starting out with releases, this often boils down to having one stage per environment in a release pipeline. Appropriate stages include <strong>test</strong>, <strong>acceptance</strong>, and <strong>production</strong>.</p>
<p>When working with releases for a long time, we might incorporate more automation in the pipelines and want to add extra checking stags to them. An example might be a stage called <strong>load test</strong> that is executed in parallel to the <strong>test</strong> stage. Another example might be the introduction of a stage for <strong>automated UI tests</strong>.</p>
<p>No matter which stages are added, the approach to propagating a release to production should always stay the same. When a release propagates from stage to stage and gets closer to production, this should show that there is confidence in this release, that it is working correctly, and that it can be promoted to production.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stage triggers, approvals, and gates</h1>
                </header>
            
            <article>
                
<p>After defining the required stages and adding jobs and tasks to them, it is time to configure when the release to a specific stage should be triggered. The steps for this can be seen in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1021 image-border" src="assets/7590041b-a49e-4253-ad67-d3e5fc875808.png" style="width:60.17em;height:31.08em;"/></p>
<p><span>Note that the following steps need to be carried out for every stage individually:   </span></p>
<ol>
<li>To trigger a release to a specific stage, click on the button with a lightning bolt and a person icon, to the left of the square that denotes the stage.</li>
<li>The first thing to configure here is when a release should propagate to this stage. This can be either upon the availability of the release, after completing another stage, or only upon manual request. The choice you make here will also be reflected in the visual representation of the pipeline.</li>
<li>Separate from the trigger, it is possible to define one or more filters that limit which artifacts will trigger a deployment to the stage. There can be one or more include or exclude branch filters for every artifact.</li>
<li>It is also possible to redeploy on a fixed schedule.</li>
<li>Finally, if the creation of a new release is specified for builds that were started from a pull request, the release can also be allowed to propagate to the current stage using the slider.</li>
</ol>
<p>Next to these triggers, approvers and gates can be added so that you can configure how to handle deployment queue settings. These settings can be accessed from the tabs below the section for <span class="packt_screen">Triggers</span>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1022 image-border" src="assets/08f5ca5d-f9bb-4be2-887e-bc7753ed0221.png" style="width:100.50em;height:45.25em;"/></p>
<p>The first tab is about approvers. Here, groups or users are specified. They must give their approval before releasing to this stage can begin. Multiple people can be added and if so, an order can be defined in which they have to approve or it can be specified that a single approval is enough. By scrolling down, you will find the following options:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1023 image-border" src="assets/dfc4fb92-1283-48e5-b56d-106e09ff7c4c.png" style="width:65.50em;height:39.83em;"/></p>
<p>The second tab (on the left) allows you to add one or more gates. Gates are automated checks that have to succeed before the release can continue. Currently, this shows the configuration details for configuring a work item query and a threshold on the number of results, for example, to ensure that there are no open bugs before a release proceeds. There are also gates available that can call in Azure Monitor, Azure Functions, or a RESTful API. This set of gates can be extended using the Azure DevOps extension mechanisms. Some of these extensions also integrate with common change management systems.</p>
<p>The final tab (on the right) allows you to configure how to handle a situation where different versions of the release are ready for deployment to the same stage. Here, it is possible to specify how many releases can run in parallel. If there are even more releases coming in, you can queue them up and deploy them one after the other, or only deploy the latest.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with deployment groups</h1>
                </header>
            
            <article>
                
<p>Another topic that you might run into at some point is deploying an application to on-premises servers or servers that are behind a firewall. You may also come across situations where it is necessary to run scripts on all of the machines hosting the application or situations where the target environment does not supply a mechanism for deploying applications.</p>
<p>The approach to performing releases, which was shown in the <em>Working with Azure DevOps releases</em> section of this chapter, relies on being able to connect to the target machines or services that will host the application. We call these <strong>push-based deployments</strong>, and this is not always possible.</p>
<p>When deploying to target machines that cannot be connected to, another approach needs to be taken. This approach is called <strong>agent-based deployment</strong><em>.</em> In an agent-based deployment, an Azure DevOps agent is installed on every machine that the application will be installed on. Next, these agents must be grouped into deployment groups. Once this is done, a <strong>deployment group job</strong> can be added to the release.</p>
<p>This is very similar to an agent job, except for one thing. In an agent job, the tasks in the job will run on <strong>one of the agents</strong> against the target machine. In a deployment group job, all of the tasks will run on all of the agents in the release group on the target machines. This difference between both approaches can be seen in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-450 image-border" src="assets/4666901d-34d2-44d2-8d60-57bf09286374.png" style="width:33.50em;height:18.75em;"/></p>
<p>When using this approach, it is necessary to have agents on the machines that the application needs to be deployed to. These agents listen to Azure DevOps and whenever a new release is requested, they retrieve the work and execute it on the local machine.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing deployment groups</h1>
                </header>
            
            <article>
                
<p>Before you can add a deployment group job to a release pipeline, you need to create a deployment group. To do so, perform the following steps:</p>
<ol>
<li>Navigate to the <span class="packt_screen">Pipelines</span> menu.</li>
<li>Open the <span class="packt_screen">Deployment groups</span> menu.</li>
<li>Enter a deployment group name and description and click <span class="packt_screen">Create</span>.</li>
</ol>
<p><span>Once the new deployment group has been created, a script will appear on the right, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1024 image-border" src="assets/12b5eabb-1890-4db6-9f3e-b3812675c646.png" style="width:58.08em;height:21.08em;"/></p>
<p><span>Executing this script on the target machine will install the agent and automatically register that machine as part of the newly created deployment group.</span></p>
<p>If an application must be deployed to three stages (test, acceptance, and production) using deployment groups, there will need to be three separate deployment groups, one for each environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a release pipeline with a deployment group</h1>
                </header>
            
            <article>
                
<p>After creating the necessary deployment group(s), those deployment group(s) can be used in releases from the tasks view, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1025 image-border" src="assets/33a72ee4-0edb-4abb-8209-6e620ac7fa7b.png" style="width:40.42em;height:33.50em;"/></p>
<p>To do this, perform the following steps:</p>
<ol>
<li>Add a new deployment group to the pipeline.</li>
<li>Specify which deployment group the job should run on by picking it from the drop-down menu.</li>
<li>Add one or more tasks to execute the job. The functionality of the user interface is the same as that for regular agent jobs.  </li>
</ol>
<p>Besides the different approaches to executing on all agents in a group instead of one, deployment group jobs behave the same as regular agent jobs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing multi-stage YAML pipelines</h1>
                </header>
            
            <article>
                
<p>In addition to the visual designer for release definitions, it is also possible to implement continuous deployment using YAML pipelines. When doing so, it is still recommended to differentiate between the build (CI) and release (CD) phases of a pipeline. The concept of stages is used to make this possible. A YAML pipeline can be divided into one or more stages. A stage can represent an environment such as test, acceptance, or production, but this isn't always true. If, in an application scenario, it makes sense to add extra stages such as pre-production or staging, this is possible. It is good practice to publish <strong>pipeline artifacts</strong> to earlier stages and to consume or <strong>download artifacts</strong> in later stages.</p>
<p class="mce-root">Multi-stage YAML pipelines are the new default for creating pipelines in Azure DevOps. Since working with YAML pipelines can have a steeper learning curve than working with classic releases, some find it easier to work with classic releases first and switch to YAML pipelines later. Just like with builds, many of the concepts of classic releases translate to multi-stage YAML pipelines as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding stages to YAML pipelines</h1>
                </header>
            
            <article>
                
<p>If no stages are defined in a YAML pipeline, there is always one implicit stage that holds all the jobs. To convert a pipeline into a multi-stage pipeline, you need to add the <kbd>stages</kbd> keyword and a list of stages, as shown in the following code:</p>
<pre>stages:<br/>- stage: stage1<br/> displayName: My first stage<br/> jobs:<br/> - job: job1<br/> steps:<br/> - task: DotNetCoreCLI@2<br/> displayName: ‘dotnet build’<br/> inputs:<br/> projects: '**/*.csproj'<br/> <br/>- stage: stage2<br/> jobs:<br/> ...</pre>
<p>The preceding syntax shows that a list of stages is defined at the top of the YAML file. Each stage starts by defining a name. This name can be used later on so that you can refer to this stage.</p>
<p>While jobs (unless otherwise specified) run in parallel by default, stages always run sequentially by default. But just like jobs, stages accept the <kbd>dependsOn</kbd> and <kbd>condition</kbd> keywords to change the ordering, parallelism, and (potentially) to skip stages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Downloading artifacts</h1>
                </header>
            
            <article>
                
<p>A common use of multi-stage pipelines it to separate the build stage and the deployment stage. To make this possible, the build stage often publishes one or more pipeline artifacts. This was discussed in the previous chapter.</p>
<p>All the artifacts that were published in a previous stage of the current pipeline can be downloaded using a <kbd>download</kbd> task:</p>
<pre>steps:<br/>- download: current<br/>  artifact: artifactName</pre>
<p>It is also possible to download artifacts from other pipelines. To do this, the <kbd>current</kbd> constant has to be replaced with the name of that pipeline. Pipeline artifacts are downloaded to the <kbd>$(Pipeline.Workspace)</kbd> directory.</p>
<div class="packt_tip">If you want more fine-grained control over downloading pipeline artifacts, for example, over the version of the artifact to use or the location to download the artifact to, you can also use the Download Pipeline Artifacts tasks, which are documented at <a href="https://docs.microsoft.com/bs-cyrl-ba/azure/devops/pipelines/tasks/utility/download-pipeline-artifact?view=azure-devops">https://docs.microsoft.com/bs-cyrl-ba/azure/devops/pipelines/tasks/utility/download-pipeline-artifact?view=azure-devops</a>.</div>
<p>Publishing and downloading artifacts within a pipeline ensures that the code that is built in the first stage is also the code that is deployed in the second stage <span>–</span> even if the stages run days apart. In essence, each pipeline run builds a local stage of all the artifacts associated with that specific run.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Approvals</h1>
                </header>
            
            <article>
                
<p>In a multi-stage pipeline, it is not possible to define approvers as it is in a classic release pipeline. The reason for this is that the pipeline <span>– </span><em>the build and deployment process <span>– </span></em>is viewed as code. Code is worked on by developers and operators only. Approvals are worked on by, for example, product owners. However, this does not mean that it is not possible to implement approval flows for the progression of a pipeline to the next stage.</p>
<p>To control whether a pipeline is allowed to proceed to a certain stage, the concept of environments needs to be introduced. An environment is defined when we give it a name and a description. One or more approvers can be attached to these environments. Once this is done, jobs can be configured to target such an environment. If there is at least one job in a stage that targets an environment, then that environment is said to be used by the stage. If an approval has been configured on that environment, the deployment to that stage will not continue until the approver has given permission.</p>
<p>To start working with environments, you'll need to access the list of environments. This list be found in the <span class="packt_screen">Pipelines</span> menu, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1026 image-border" src="assets/922c7d61-1af0-4e8d-a77b-25d7e990829f.png" style="width:41.33em;height:31.42em;"/></p>
<p>To add a new environment, perform the following steps:</p>
<ol>
<li>Open the <span class="packt_screen">Pipelines</span> menu and choose <span class="packt_screen">Environments</span>.</li>
<li>Select <span class="packt_screen">New environment</span> from the top right.</li>
<li>Specify a name and description.</li>
<li>Click <span class="packt_screen">Create</span>.</li>
</ol>
<p>It is possible to associate resources with an environment. Resources that are coupled with an environment can be used in a pipeline if, and only if, that pipeline is also targeting that environment. To protect the resources of an environment, the owner of that environment can add one or more approvers. An example of a configured approver can be seen in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1027 image-border" src="assets/f8684152-29f0-4fd1-8cf4-ce960c1a1dc7.png" style="width:43.17em;height:31.67em;"/></p>
<p>Approvers can be added to an environment as follows:</p>
<ol>
<li>Navigate to the <span class="packt_screen">Environments</span> overview pane.</li>
<li>Open an environment by clicking on it.</li>
</ol>
<ol start="3">
<li>Click the top-right menu marked with the three dots, and and choose <span class="packt_screen">Approvals and Checks</span>.</li>
<li>Click the <span class="packt_screen">Create</span> button.</li>
<li>Pick a user or group from the list and add extra instructions if needed.</li>
<li>Click the <span class="packt_screen">Create</span> button again.</li>
</ol>
<p>Approvals make it possible for you to control the progression of a pipeline to the next stage if that pipeline targets the correct environment. Targeting an environment is done by specifying a specific type of job: the deployment job. The following YAML shows how to do this:</p>
<pre>jobs:<br/>- deployment: deplyoymentJobName<br/>  displayName: Friendly name<br/>  strategy:<br/>  runOnce:<br/>    deploy:<br/>      steps:<br/>      …</pre>
<p>Deployment jobs do not directly contain the steps to execute like an agent job does. Instead, they first have to specify an execution strategy for the tasks outlined under the <kbd>steps</kbd> keyword. At the time of writing, the only strategy supported is <kbd>runOnce</kbd>. Other strategies are expected to be announced in the future.</p>
<p>At the time of writing, only Kubernetes clusters are supported as environment resources, but more types of resources have been announced for the future.</p>
<p>Now that we know about the technical means for creating release definitions and writing multi-stage YAML pipelines, it is time to take a look at the different strategies we can use to apply this in practice. These continuous deployment strategies are designed to minimize the risk of deploying new versions of an application automatically.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing continuous deployment strategies</h1>
                </header>
            
            <article>
                
<p>Before we deploy an application continuously, it is important to think about the strategy we should use. Just doing deployment after deployment may have more risks associated with it than the business is willing to accept. It is important to think about how to deal with issues that might occur during or after deploying a new version of your application.</p>
<p>There are a few deployment strategies that can be applied to reduce the risks that might come with deployments, all of which will be covered in this section. Please note that it is possible to combine one or more of the following patterns. For example, it is perfectly possible to use a blue-green strategy for every ring in a ring-based deployment. Also, all deployment strategies can be combined with the use of feature flags.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Blue-green deployments</h1>
                </header>
            
            <article>
                
<p>Blue-green deployments is a technique where a new version of an application never gets deployed to the production servers directly. Instead, it gets deployed to another set of servers first. Once this has be done successfully, users are directed to the new deployment.</p>
<p>Let's assume that an application runs on a total of three hosts by default. A typical setup for blue-green deployment would be two sets of three hosts: the blue group and the green group. In front of these two sets, there is a reverse proxy that functions as a load balancer and redirects the incoming requests to the blue group. The following diagram shows how this works:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1028 image-border" src="assets/69ebbc65-d520-4d2c-9ba5-feca9cec8e0d.png" style="width:49.17em;height:14.00em;"/></p>
<p>To deploy a new version of the application in this situation, it needs to be deployed to the green group of servers. Since these servers are not receiving any traffic from end users, this has no impact on them at all.</p>
<p>After the deployment, the new deployment can be verified to ensure it was successful and that the application is running correctly. After this verification, the load balancer is reconfigured to redirect traffic to the green group. Now, the new version of the application is served.</p>
<p>Should there suddenly be any unexpected issues, it is very easy to switch back to the previous deployment by reconfiguring the load balancer back to the blue group. If the deployment is successful and there are no issues, it is possible to start the deployment of the next version by going through the same procedure, but now with the roles of the green and the blue groups switched.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Immutable servers</h1>
                </header>
            
            <article>
                
<p>A variation of the blue-green deployment pattern is immutable servers. With immutable servers, there is no going back and forth between two groups of servers. Instead, the group of servers that are serving the old version of the application is completely disregarded or removed. Often, this is done after a grace period.</p>
<p>The result of this is that there will still be means to roll back to a previous version <span>–</span> almost instantaneously if the old servers are kept around for a while. The other benefit is that there is now a guarantee that no remains from a previous deployment are being carried over into the newer deployments. Using immutable servers, the change of active servers over time might look as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1029 image-border" src="assets/8d69a070-129b-409b-9fd5-2064e39a2b03.png" style="width:89.00em;height:19.00em;"/></p>
<p>Of course, an approach like this is only feasible when using technologies such as containers or virtual machines. Nobody would expect anyone to disregard physical servers after every redeployment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Progressive exposure</h1>
                </header>
            
            <article>
                
<p>Progressive exposure is a deployment strategy in which the number of users that have access to a new deployment or a new feature is slowly increased over time. The goal of this strategy is to limit the number of users that are experiencing issues when a faulty release of a feature is made available.</p>
<p>We can also look at this more positively and in line with the continuous deployment way of thinking: exposing a new feature to only a few users at first and increasing that number over time allows us to increase the amount of trust in a new version or feature of an application before exposing it to all users.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Canary deployments</h1>
                </header>
            
            <article>
                
<p>The first strategy for progressive exposure is to use canary deployments. In a canary deployment, not all users are routed to the new version immediately <span>– o</span>nly a limited percentage of the users get access to that version. These users are the canaries and they are monitored very closely. If they experience any issues or if degradation in performance or a service is measured, the new deployment is quickly rolled back.</p>
<p>A typical approach to realizing canary deployments is to use them in combination with blue-green deployments. The difference is that instead of switching all users over at the same time, only a small percentage is moved over to the new version at the start, and then the number of users that are moved over is gradually increased over time. This might look something similar to the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1030 image-border" src="assets/b28dc8db-007c-4f6e-baee-cdcdd9b4fe84.png" style="width:105.08em;height:21.92em;"/></p>
<p>If a deployment is rolled back because errors have been observed, this is not a fun experience for users. To prevent the same small group of users running into issues repeatedly, it might be beneficial to select a different group of canary users afterward.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ring-based deployments</h1>
                </header>
            
            <article>
                
<p>In a ring-based environment, there is not just one production environment <span>– </span>there are multiple. Each production environment serves only a portion of the users. Its difference from a canary deployment is that, instead of just two environments, there can be as many environments as needed. Also, every new version goes to all the rings, one after the other.</p>
<p>So, instead of redirecting the users, in a ring-based environment, the new version is propagating to the servers used by those users. The new version just keeps propagating from one ring to the next, until they are all done:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1031 image-border" src="assets/94cbe569-28fa-4548-bf78-948edbd3d6db.png" style="width:39.33em;height:4.58em;"/></p>
<p>Ring-based deployment architectures are especially suitable for products that are accessed by customers from all around the world. The different rings can be positioned around the world, thus combining the deployment benefits with the added benefit of reduced latencies for users.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Feature flags</h1>
                </header>
            
            <article>
                
<p>The third form of progressive deployment can be achieved using feature flags, also called feature toggles. Where canary deployments and ring-based deployments rely on slowly exposing new binaries to an increasing number of users, feature flags are used to slowly expose new features to an increasing number of users. This can be achieved even if they are all sending requests to the same server. Feature flags are used to decouple deploying a new version of the application binaries from releasing new features by enabling or disabling specific features at runtime.</p>
<p>The best example of a feature flag is showing or hiding a button that gives users access to a new feature. Application settings, a database, or an external service are used to keep track of which feature has been enabled for which user. Depending on that setting, the feature is shown or hidden. Examples of such external services include LaunchDarkly, Split.IO, and Prefab.cloud.</p>
<p>Other feature flags might toggle bug fixes or performance improvements on or off. This can help to gradually expose these to ensure there are no issues. When using feature toggles for these kinds of changes deeper in a codebase, introducing feature toggles also comes with a cost, and a process for this should be in place. This process should not only describe adding feature toggles, but also how to remove them as soon as possible. An example of such a process can be as follows.</p>
<p>A new feature flag is introduced by a developer as soon as the business needs to release the feature independently of the deployments that were made by the development team, or for a change that the development team qualifies as high risk and wants to be able to pull back at any time without redeploying it. Introducing a feature flag means a new database entry or a declaration of a new setting is applied in the application settings.</p>
<p>After introducing the feature toggle, the new feature or change is developed and tested. This means that there are one or more <kbd>if</kbd><em> </em>statements in the codebase that execute different code paths, depending on the state of the feature flag. At this point, the application must maintain two code execution paths until they remove the feature flag again. It is good practice to separate these two code paths as much as possible using existing engineering practices, such as dependency injection.</p>
<p>While the code is continuously being shipped to users, the feature is not enabled for anyone. Only when the development team is fully satisfied with the change or the product owner feels the time is right for releasing a new feature is the feature flag turned on.</p>
<p>It is important not to stop here. After turning the feature flag on, it should actively be determined whether the feature or change is working properly. And if it is, the feature flag should be removed as soon as possible. This way, the time the two code paths need to be maintained for is as short as possible.</p>
<p>Also, note that besides maintaining an increased number of execution paths, there is now a larger number of paths to test. The impact of this consequence quickly grows if dependencies or exclusions between feature flags are introduced. Feature flags that can only be turned on or off, depending on the state of another feature flag, can be costly, and it is recommended to avoid this.</p>
<p>If implemented properly and removed as soon as possible, the added cost of feature flags is often worth it. As with every engineering practice, start small and evaluate what works in the given context, before adapting the practice at scale.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Roll back or fail forward   </h1>
                </header>
            
            <article>
                
<p>No matter which strategy is being used, it is necessary to think about the ability to roll back one or more versions and how long that will take. For example, blue-green deployments give us the ability to go back one version almost instantaneously, as long as a new version is not being deployed to the non-active servers yet. On the other hand, performing a rollback in a ring-based deployment will require a full redeploy of the previous version, which will probably take longer and comes with all the risks of deployment in itself. This may even need to be done on multiple rings, making it more challenging.</p>
<p>Another approach that can be adopted is that of failing forward. When adopting this approach, it is stated that there will never be a rollback to a previous version. Instead, when any issue is encountered, this will be addressed by redeploying a new version with the fix of that issue in it. This strategy is gaining traction lately since it saves time as we don't have to prepare, test, and practice rollbacks. However, there can be risks involved with this process:</p>
<ul>
<li>There is no guarantee that the fix will be correct. The issue might not be resolved by the new deployed version or, even worse, the new version might result in transitioning from one issue to another.</li>
<li>Working out a detailed root cause of any issue takes time, just like writing a fix does. The consequence of this might be that the fix might take longer than a rollback would have taken.</li>
</ul>
<p>No matter which approach is taken, consider the consequences and prepare for them.</p>
<p>So far, we have mainly focused on web-based applications. In the next section, we will shift our attention to mobile applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying mobile applications</h1>
                </header>
            
            <article>
                
<p>One type of application that needs a special approach to deployment is mobile applications. These applications are often not downloaded and installed by end users directly and are mostly consumed via an app store on their mobile device.</p>
<p>App Center is a Microsoft offering that can be used for distributing (deploying) mobile applications to end users via app stores, but also via private distribution lists.</p>
<p>After logging into App Center, you will be taken to the following screen:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1032 image-border" src="assets/96a9c809-20ab-4be9-940a-19a1e66de1c7.png" style="width:41.83em;height:29.25em;"/></p>
<p>Here, you can create a new app definition.<span> An app definition should be created for every target operating system of an application. If the same application is going to be deployed to both Android and iOS, at least two apps have to be created.</span></p>
<p>Creating an app is done by performing the following steps:</p>
<ol>
<li>Log in to App Center.</li>
<li>Click the blue <span class="packt_screen">Add new app</span> button. If there are no existing apps, this button will be on the center of the screen; otherwise, it will be at the top right (hidden under the popup shown in the preceding screenshot).</li>
<li>Enter the name of the app.</li>
<li>Select the type of release.</li>
<li>Select the operating system.</li>
<li>Select the platform to use.</li>
<li>Click <span class="packt_screen">Add new app</span> to create the app.</li>
</ol>
<p>Once an app has been created, it can be connected to the correct app store and distribution groups can be created.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Connecting to the app store</h1>
                </header>
            
            <article>
                
<p>The app store is the main mechanism for distributing an application for all mobile platforms. Once a build is delivered to an app store, users can install and use the application. The current list of connections to app stores can be opened using the <span class="packt_screen">Stores</span> tab, on the left-hand side of App Center. From this list, an individual store connection can be opened, which will take us to a screen similar to the one shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1033 image-border" src="assets/11e01b80-57ac-4263-b81e-c327525753d3.png" style="width:63.00em;height:41.00em;"/></p>
<p>This view shows a list of all the versions of the application that have been published to the connected store account. This is also where a new version of the application can be selected for publication to the store. This is done using the blue <span class="packt_screen">Publish</span> button at the top. This will open a popup where you can select the correct release. You only have to confirm this once to publish this version.</p>
<p>New connections to the store can be created by navigating back to the list of all store connections and clicking the <span class="packt_screen">Add</span> button. This will open a wizard where two pieces of information have to be entered:</p>
<ul>
<li><strong>The type of store connection</strong>: This list is limited to the stores that are available to apps of the type that was chosen when creating the app definition. For example, for iOS, this is limited to the Apple App Store and the Intune Company Portal.</li>
<li><strong>Connection details</strong>: Often, they include the means of authentication between App Center and the app store.</li>
</ul>
<p>Once the new connection has been created, it can be found on the list shown previously and can be used to distribute the app.</p>
<p>Another means of distribution is using distribution groups, which we'll introduce in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using distribution groups</h1>
                </header>
            
            <article>
                
<p>Distribution groups are used to create named lists of one or more users, often testers or alpha users, that install the application through an invitation, rather than via the app store. Distribution groups can be found in the left-hand menu, under <span class="packt_screen">Groups</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1034 image-border" src="assets/ce71df3b-d743-4238-a772-d68809c6b2d7.png" style="width:42.75em;height:26.42em;"/></p>
<p>Here, a new group can be added, as follows:</p>
<ol>
<li>Navigate to <span class="packt_screen">Distribution groups</span> using the menu on the left.</li>
<li>Click the blue button labeled with a plus (<span class="packt_screen">+</span>) sign (hidden under the popup in the preceding screenshot).</li>
<li>Choose a name for the group.</li>
<li>Add one or more members.</li>
<li>Save the new group.</li>
</ol>
<p>Once a distribution group has been created, it can be used for publishing releases, which we will discuss in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Publishing an app</h1>
                </header>
            
            <article>
                
<p>To publish the first or a new version of an app, it has to be shared with App Center. This can be done using the <span class="packt_screen">Releases</span> tab on the left-hand side. When opening up the releases, the following view, detailing all the current releases, will appear. From here, any release can be selected so that you can view the details of that release:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1035 image-border" src="assets/ff331218-9620-4bc3-a888-b4de96a1cd4b.png" style="width:61.25em;height:34.92em;"/></p>
<p>In this view, a list of the most recent releases is shown in the middle column. After selecting an individual release, the details of that version will be shown. This includes its formal version, the store(s) and/or distribution group(s) it has been shared with, and other details.</p>
<p>From here, it is possible to distribute this specific version to a store connection or distribution group directly using the <span class="packt_screen">Distribute</span> bottom at the top right.</p>
<p>From here, a new release can also be created by uploading a new build of the app. To do this, follow these steps:</p>
<ol>
<li>Click on the <span class="packt_screen">New release</span> button, which is available from the list of all releases. (It might be necessary to close the details of a specific release first.) This will open the following view:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1036 image-border" src="assets/d4c34788-2be7-4547-ac25-7a2c0656a940.png" style="width:44.58em;height:30.00em;"/></p>
<ol start="2">
<li>A new wizard will open, where a build needs to be uploaded. Depending on the type of app, the correct type of file will be requested. After uploading the binaries, click <span class="packt_screen">Next</span>.</li>
<li>Now, the release notes have to be filled in. After detailing the changes in this release, click <span class="packt_screen">Next</span> again.</li>
</ol>
<ol start="4">
<li>Now, it is time to specify where this new build should be distributed. At least one destination <span>–</span> either a distribution group or a store <span>–</span> has to be selected. After selecting one or more destinations, click <span class="packt_screen">Next</span> again.</li>
<li>The final wizard tab will show the selections you've made so far. Check the details and click <span class="packt_screen">Distribute</span> to complete the creation of a new version and its initial distribution.</li>
</ol>
<p>Often, the same version or release needs to be distributed to other groups or stores over time as well. It is not necessary (nor useful) to create a new release every time. Instead, going to the <span class="packt_screen">Detail</span> pages of the new destination store connection or distribution group allows you to publish an existing release to that destination as well.</p>
<p>As an alternative to using App Center to perform release management this way, it is also possible to use Azure Pipelines for release management.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">App Center via Azure Pipelines</h1>
                </header>
            
            <article>
                
<p>App Center can also be integrated with Azure Pipelines. If teams are familiar with the release process in Azure Pipelines, it can be sensible to build the app in Azure Pipelines and only use App Center for deployment to stores and distribution groups.</p>
<p>To make this possible, there are tasks available in Azure Pipelines that allow you to upload a release and trigger the deployment of a release to a store or distribution group. That way, release management can be done in Azure Pipelines while the App Center-specific capabilities are still leveraged where applicable.</p>
<p>This section focused on mobile applications specifically, while the next section will apply to all types of releases. When creating releases is automated and new versions follow each other quickly, it is useful to start automating the creation and publication of release notes as well. This will be discussed in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Automating release notes</h1>
                </header>
            
            <article>
                
<p>After automating the build, releasing an application, and working on increasing the flow of value to end users, many developers find that it becomes harder and harder to keep documentation and release notes up to date. As the amount of releases increases, this becomes more and more work, and eventually, the team will fall behind or even give up completely.</p>
<p>To combat this, it is possible to automate the creation and publication of release notes. One way to do this is by using the Azure DevOps Release Notes Generator. The generator is an Azure Functions application that is available on GitHub. To use the Release Notes Generator, the following needs to be done:</p>
<ol>
<li>Download or clone the function code from GitHub.</li>
<li>Create an Azure App Service Plan, function app, and storage account in Azure.</li>
<li>Create a new blob container in the storage account called <kbd>releases</kbd><em>.</em></li>
<li>Compile the function code and deploy it to an Azure App Service.</li>
<li>Create a new Azure DevOps WebHook to call the deployed function whenever a new release is created.</li>
</ol>
<p>After setting this up, the generator will run whenever a new release is created. It will then do the following:</p>
<ol>
<li>Query the created release for its name, all associated work items, and all the commits that are new since the previous release.</li>
<li>Generate a markdown file containing all of this information.</li>
<li>Upload that file to the blob container, that is, <kbd>releases</kbd><em>.</em></li>
</ol>
<p>Of course, the Azure DevOps Release Notes Generator is just one example of automating tasks around releases, and there are other alternatives available as well. Also, many companies create tailored, in-house automation scripts for updating and publishing documentation and other tasks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other tools</h1>
                </header>
            
            <article>
                
<p>In addition to Azure DevOps and App Center, there are other tools that can be used for deploying and releasing software. GitLab CI/CD and Jenkins, which were discussed in the previous chapter for executing builds, can also be used for releases. Besides those, Octopus Deploy is also a commonly used tool that integrates well with Azure DevOps.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Octopus Deploy</h1>
                </header>
            
            <article>
                
<p><strong>Octopus Deploy</strong> is a deployment automation tool that is based on the concept of running a series of tasks on one or more target machines.</p>
<p>Octopus reaches these machines through a tentacle (an agent) that is installed on these machines. In Octopus Deploy, it is possible to define applications and environments and assign one or more machines to each of those. To do deployments, execution steps can be defined in a graphical editor, comparable to the visual release editor of Azure DevOps.</p>
<p>One of the main differences is that these steps are not defined per environment, only once per pipeline. Next, it is possible to specify which environments each task should run on. This way, it is easier to see where the deployment to different environments varies.</p>
<p>There is an integration between Azure DevOps and Octopus Deploy available, in the form of a build and release task. Using this integration, you can start a deployment using Octopus Deploy from an Azure DevOps build or release pipeline.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned about continuous delivery and deployment and how you can implement them using Azure DevOps. In addition to the visual release editor, you also learned about multi-stage YAML pipelines, which you can use for releasing your software to multiple stages, all of the way to production. Next, we discussed a series of strategies that you can use for releasing. You now know about blue-green deployments, using immutable servers, and different strategies for progressive exposure. You also learned how to choose between making sure you have rollback capabilities or accepting a fail forward strategy.</p>
<p>Then, you learned about automating release notes and documentation and how you can generate those automatically as part of your pipeline. After that, you learned about continuous deployment for mobile applications and how that differs from the delivery of web applications. Finally, you learned about the existence of Octopus Deploy, how it operates, and that it integrates with Azure DevOps.</p>
<p>In the next chapter, you will learn about topic dependency management using Azure Artifacts. Azure Artifacts can be used to host your own NuGet packages or to host build artifacts when you are using other products for building or releasing your application in combination with Azure Pipelines.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions </h1>
                </header>
            
            <article>
                
<p>As we conclude this chapter, here is a list of questions for you to test your knowledge of this chapter's material. You will find the answers in the <em>Assessments</em> section of the Appendix:</p>
<ol>
<li><span>True or false: An Azure DevOps Classic Release is always triggered by the availability of a new version of an artifact.</span></li>
<li>Which of the following platforms can App Center publish apps to? (You can choose more than one.)<br/>
<ol>
<li>Google Play Store</li>
<li>Apple App Store</li>
<li>Microsoft Intune</li>
</ol>
</li>
<li>Which of the following techniques use progressive exposure for minimizing the risks of deploying a new version? (<span>You can choose more than one.</span>)
<ol>
<li>Feature Toggles</li>
<li>Ring-based deployments</li>
<li>Canary deployments</li>
</ol>
</li>
<li>True or false: Deployment groups can be used for deploying software to on-premises servers when an Azure Pipelines agent is installed on the machine that will be running the software.</li>
<li>What is the advantage of integrating App Center with Azure Pipelines if you have an Azure Pipelines release definition triggering actions in App Center?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>More information on using stages in YAML pipelines can be found at <a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/process/stages">https://docs.microsoft.com/en-us/azure/devops/pipelines/process/stages</a>.</li>
<li>More information on the idea of immutable servers can be found at <a href="https://martinfowler.com/bliki/ImmutableServer.html">https://martinfowler.com/bliki/ImmutableServer.html</a>.</li>
<li>More information about LaunchDarkly can be found at <a href="https://launchdarkly.com/">https://launchdarkly.com/</a>.</li>
</ul>
<ul>
<li>More details about the build and release extension for integration with Octopus Deploy can be found at <a href="https://marketplace.visualstudio.com/items?itemName=octopusdeploy.octopus-deploy-build-release-tasks">https://marketplace.visualstudio.com/items?itemName=octopusdeploy.octopus-deploy-build-release-tasks</a>.</li>
<li>The Azure DevOps Release Notes Generator can be found at <a href="https://docs.microsoft.com/en-us/samples/azure-samples/azure-devops-release-notes/azure-devops-release-notes-generator/">https://docs.microsoft.com/en-us/samples/azure-samples/azure-devops-release-notes/azure-devops-release-notes-generator/</a>.</li>
<li>Some Microsoft hands-on labs for practicing the topics we covered in this chapter can be found at <a href="https://docs.microsoft.com/en-us/learn/modules/create-multi-stage-pipeline/index">https://docs.microsoft.com/en-us/learn/modules/create-multi-stage-pipeline/index</a>, <a href="https://docs.microsoft.com/en-us/learn/modules/create-release-pipeline/index">https://docs.microsoft.com/en-us/learn/modules/create-release-pipeline/index</a> and <a href="https://docs.microsoft.com/en-us/learn/modules/manage-release-cadence/index">https://docs.microsoft.com/en-us/learn/modules/manage-release-cadence/index</a>.<a href="https://docs.microsoft.com/en-us/learn/modules/manage-release-cadence/index"/></li>
</ul>


            </article>

            
        </section>
    </body></html>