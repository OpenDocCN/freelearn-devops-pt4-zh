- en: Continuous Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to use Azure DevOps pipelines for continuous
    integration. Due to this, you now know how to pick up a version of your sources
    and create artifacts that can be deployed. In this chapter, you will learn how
    to extend this practice with continuous delivery and continuous deployment so
    that you automatically deploy these artifacts to the servers or platforms your
    code is running on.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we will start by introducing Azure DevOps release definitions so
    that you can define and run the releases of your application. Next, a series of
    strategies will be introduced that you can use to perform deployments in a low-risk
    manner. Doing this makes it possible for you to automate the process of deploying
    new versions unattended, with a limited risk of incidents occurring. From here,
    we will shift our attention to automating the creation of release notes. After
    this, we will introduce App Center, which is used for deploying mobile applications.
    Finally, other tools for continuous deployment will be introduced.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery and continuous deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Azure DevOps releases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing multi-stage YAML pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing continuous deployment strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying mobile applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating release notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To experiment with the techniques described in this chapter, you might need
    one or more of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An Azure DevOps account for building release definitions and multi-stage YAML
    pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An App Center account for deploying mobile applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Free trial options are available for both of these.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery and continuous deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The difference between continuous delivery and continuous deployment is a common
    source of confusion. Some people think these terms are interchangeable and see
    them as two synonyms for the same concept, but they have, in fact, two different
    meanings.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery is a practice where teams ensure that the artifacts they
    build are continuously validated and ready to be deployed to the production environment.
    Often, this is done by deploying the artifacts to a production-like environment,
    such as acceptance or even a staging environment, and applying a series of tests,
    such as verification tests, to ensure the application is working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous deployment is a practice where every version that is deployed to
    a production-like environment and passes all tests and verifications, is also
    deployed to production automatically.
  prefs: []
  type: TYPE_NORMAL
- en: When working with Azure DevOps, Azure Pipelines is the tool of choice for implementing
    continuous delivery and deployment. This can be done using either the visual classic
    editor or with multi-stage YAML pipelines, both of which will be discussed in
    the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Azure DevOps releases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuous delivery and deployment can both be implemented in Azure DevOps by
    using releases. When creating a new release definition, an outline of the release
    process is created. This process will often start with an artifact that triggers
    the creation of a new release. Next, it is possible to define one or more stages
    that the release can be deployed to. Often, these stages correspond to the different
    application environments, for example, test and production, but this is not mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s learn how to create a new release definition and explore the various
    options we have. First, navigate to Pipelines and choose Releases from the menu.
    From here, it is possible to start creating a new release pipeline, which will
    take us to a screen that looks similar to the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0df1b9c6-c830-439d-a27f-2a3da15aa37d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding screen, we can perform the following actions (these are
    numbered in the preceding screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: First, notice that, on the left, it is possible to see the outline of the release
    pipeline with a box. Here, you can select one or more artifacts that can be used
    in the release pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To the right of this, there is a box where the different stages of the release
    can be seen. By default, one stage is created already.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is possible to pick a template as a starting point for the deployment pipeline
    for this pre-created stage. Choosing to start with an empty job in this view allows
    you to craft a custom deployment pipeline from scratch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After choosing a job template or an empty job to start with, the pane on the
    right will close, and it will be possible to start editing the release pipeline
    from left to right, starting with the artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: Once a skeleton release pipeline is visible, the first things you will need
    to configure are the artifacts that the release should work with. This is the
    subject of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating artifacts and release triggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter described build definitions and YAML pipelines, which create
    artifacts. These artifacts are picked up in releases and form the basis for deploying
    an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start editing a release pipeline, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Add an artifact button to start building the starting point of
    the release definition. This will open the right-hand pane shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/be76633f-7932-4fde-b711-e8e339885004.png)'
  prefs: []
  type: TYPE_IMG
- en: In the picker for the project, the current project will be selected by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, specify the artifacts that the release pipeline should pick up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this, the default version to use and the source alias will be automatically
    selected. The default version can always be overridden when manually starting
    a release, so Latest is a sensible default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The source alias is the name of the folder where the artifacts can be located
    when we add jobs to the release stages at a later date. The default is often fine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finish adding the artifact by clicking Add.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we''ve specified the artifacts to work with, it is time to specify
    when a new release should be created. Let''s learn how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure the availability of a new artifact to trigger the release, click
    on the lightning bolt next to the artifact to open the configuration pane. This
    can be seen in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/79bd2b7c-c408-43a3-8a3d-15b72ea4d7e3.png)'
  prefs: []
  type: TYPE_IMG
- en: In this pane, it is possible to create a new release, when one is available,
    using the top slider. This will expand a new section where you can define one
    or more filters so that you can specify conditions under which a new artifact
    should trigger a release.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the Add button to start adding a condition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A common example is to only include artifacts that come from the master branch,
    as shown here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition to artifacts that come from regular builds, it is possible to also
    allow artifacts that come from pull request builds to start a new release.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, it is possible to create a new release on a fixed schedule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If no schedule and no trigger are specified, a new release will only be created
    when someone does so manually.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the stages to deploy the release
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After specifying the artifacts to release, it is time to specify one or more
    stages to deploy the release to. Often, every environment (test, acceptance, and
    production) will correspond to a stage. But it is also possible to have other
    stages if the situation calls for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s learn how to add a new stage and explore various options. First, click
    on Pipelines to arrive at the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30e40337-f0c1-4f8a-b803-63b4fc5b189b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the Add button to create a new stage. A stage can be either new or a clone
    of an existing one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After selecting an already existing stage, it can be removed using the Delete
    button on the top right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other actions that can be performed on this screen include renaming the stage
    and designating a stage owner. The owner will be notified when a release is deployed
    to the environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After creating and naming a stage, it is possible to add jobs and tasks to a
    stage, just like it was possible for a build pipeline. To do this, click on the
    link in the box that denotes the stage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From here on, this works exactly the same as building pipelines. There is only
    one addition: besides agent jobs and agentless jobs, it is also possible to use
    deployment group jobs. These will be discussed in the *Working with deployment
    groups* section later on. But first, let''s understand which stages we need.'
  prefs: []
  type: TYPE_NORMAL
- en: Which stages do I need?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the questions that frequently arises when working with releases is, *which
    stages do I need in my release pipeline*? According to the documentation, stages
    should denote the major divisions of a release pipeline. When starting out with
    releases, this often boils down to having one stage per environment in a release
    pipeline. Appropriate stages include **test**, **acceptance**, and **production**.
  prefs: []
  type: TYPE_NORMAL
- en: When working with releases for a long time, we might incorporate more automation
    in the pipelines and want to add extra checking stags to them. An example might
    be a stage called **load test** that is executed in parallel to the **test** stage.
    Another example might be the introduction of a stage for **automated UI tests**.
  prefs: []
  type: TYPE_NORMAL
- en: No matter which stages are added, the approach to propagating a release to production
    should always stay the same. When a release propagates from stage to stage and
    gets closer to production, this should show that there is confidence in this release,
    that it is working correctly, and that it can be promoted to production.
  prefs: []
  type: TYPE_NORMAL
- en: Stage triggers, approvals, and gates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After defining the required stages and adding jobs and tasks to them, it is
    time to configure when the release to a specific stage should be triggered. The
    steps for this can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7590041b-a49e-4253-ad67-d3e5fc875808.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that the following steps need to be carried out for every stage individually:'
  prefs: []
  type: TYPE_NORMAL
- en: To trigger a release to a specific stage, click on the button with a lightning
    bolt and a person icon, to the left of the square that denotes the stage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first thing to configure here is when a release should propagate to this
    stage. This can be either upon the availability of the release, after completing
    another stage, or only upon manual request. The choice you make here will also
    be reflected in the visual representation of the pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Separate from the trigger, it is possible to define one or more filters that
    limit which artifacts will trigger a deployment to the stage. There can be one
    or more include or exclude branch filters for every artifact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is also possible to redeploy on a fixed schedule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, if the creation of a new release is specified for builds that were
    started from a pull request, the release can also be allowed to propagate to the
    current stage using the slider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next to these triggers, approvers and gates can be added so that you can configure
    how to handle deployment queue settings. These settings can be accessed from the
    tabs below the section for Triggers, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08f5ca5d-f9bb-4be2-887e-bc7753ed0221.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first tab is about approvers. Here, groups or users are specified. They
    must give their approval before releasing to this stage can begin. Multiple people
    can be added and if so, an order can be defined in which they have to approve
    or it can be specified that a single approval is enough. By scrolling down, you
    will find the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dfc4fb92-1283-48e5-b56d-106e09ff7c4c.png)'
  prefs: []
  type: TYPE_IMG
- en: The second tab (on the left) allows you to add one or more gates. Gates are
    automated checks that have to succeed before the release can continue. Currently,
    this shows the configuration details for configuring a work item query and a threshold
    on the number of results, for example, to ensure that there are no open bugs before
    a release proceeds. There are also gates available that can call in Azure Monitor,
    Azure Functions, or a RESTful API. This set of gates can be extended using the
    Azure DevOps extension mechanisms. Some of these extensions also integrate with
    common change management systems.
  prefs: []
  type: TYPE_NORMAL
- en: The final tab (on the right) allows you to configure how to handle a situation
    where different versions of the release are ready for deployment to the same stage.
    Here, it is possible to specify how many releases can run in parallel. If there
    are even more releases coming in, you can queue them up and deploy them one after
    the other, or only deploy the latest.
  prefs: []
  type: TYPE_NORMAL
- en: Working with deployment groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another topic that you might run into at some point is deploying an application
    to on-premises servers or servers that are behind a firewall. You may also come
    across situations where it is necessary to run scripts on all of the machines
    hosting the application or situations where the target environment does not supply
    a mechanism for deploying applications.
  prefs: []
  type: TYPE_NORMAL
- en: The approach to performing releases, which was shown in the *Working with Azure
    DevOps releases* section of this chapter, relies on being able to connect to the
    target machines or services that will host the application. We call these **push-based
    deployments**, and this is not always possible.
  prefs: []
  type: TYPE_NORMAL
- en: When deploying to target machines that cannot be connected to, another approach
    needs to be taken. This approach is called **agent-based deployment***.* In an
    agent-based deployment, an Azure DevOps agent is installed on every machine that
    the application will be installed on. Next, these agents must be grouped into
    deployment groups. Once this is done, a **deployment group job** can be added
    to the release.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is very similar to an agent job, except for one thing. In an agent job,
    the tasks in the job will run on **one of the agents** against the target machine.
    In a deployment group job, all of the tasks will run on all of the agents in the
    release group on the target machines. This difference between both approaches
    can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4666901d-34d2-44d2-8d60-57bf09286374.png)'
  prefs: []
  type: TYPE_IMG
- en: When using this approach, it is necessary to have agents on the machines that
    the application needs to be deployed to. These agents listen to Azure DevOps and
    whenever a new release is requested, they retrieve the work and execute it on
    the local machine.
  prefs: []
  type: TYPE_NORMAL
- en: Managing deployment groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you can add a deployment group job to a release pipeline, you need to
    create a deployment group. To do so, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the Pipelines menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Deployment groups menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a deployment group name and description and click Create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the new deployment group has been created, a script will appear on the
    right, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12b5eabb-1890-4db6-9f3e-b3812675c646.png)'
  prefs: []
  type: TYPE_IMG
- en: Executing this script on the target machine will install the agent and automatically
    register that machine as part of the newly created deployment group.
  prefs: []
  type: TYPE_NORMAL
- en: If an application must be deployed to three stages (test, acceptance, and production)
    using deployment groups, there will need to be three separate deployment groups,
    one for each environment.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a release pipeline with a deployment group
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After creating the necessary deployment group(s), those deployment group(s)
    can be used in releases from the tasks view, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33a72ee4-0edb-4abb-8209-6e620ac7fa7b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new deployment group to the pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify which deployment group the job should run on by picking it from the
    drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add one or more tasks to execute the job. The functionality of the user interface
    is the same as that for regular agent jobs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Besides the different approaches to executing on all agents in a group instead
    of one, deployment group jobs behave the same as regular agent jobs.
  prefs: []
  type: TYPE_NORMAL
- en: Writing multi-stage YAML pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the visual designer for release definitions, it is also possible
    to implement continuous deployment using YAML pipelines. When doing so, it is
    still recommended to differentiate between the build (CI) and release (CD) phases
    of a pipeline. The concept of stages is used to make this possible. A YAML pipeline
    can be divided into one or more stages. A stage can represent an environment such
    as test, acceptance, or production, but this isn't always true. If, in an application
    scenario, it makes sense to add extra stages such as pre-production or staging,
    this is possible. It is good practice to publish **pipeline artifacts** to earlier
    stages and to consume or **download artifacts** in later stages.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-stage YAML pipelines are the new default for creating pipelines in Azure
    DevOps. Since working with YAML pipelines can have a steeper learning curve than
    working with classic releases, some find it easier to work with classic releases
    first and switch to YAML pipelines later. Just like with builds, many of the concepts
    of classic releases translate to multi-stage YAML pipelines as well.
  prefs: []
  type: TYPE_NORMAL
- en: Adding stages to YAML pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If no stages are defined in a YAML pipeline, there is always one implicit stage
    that holds all the jobs. To convert a pipeline into a multi-stage pipeline, you
    need to add the `stages` keyword and a list of stages, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding syntax shows that a list of stages is defined at the top of the
    YAML file. Each stage starts by defining a name. This name can be used later on
    so that you can refer to this stage.
  prefs: []
  type: TYPE_NORMAL
- en: While jobs (unless otherwise specified) run in parallel by default, stages always
    run sequentially by default. But just like jobs, stages accept the `dependsOn`
    and `condition` keywords to change the ordering, parallelism, and (potentially)
    to skip stages.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading artifacts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common use of multi-stage pipelines it to separate the build stage and the
    deployment stage. To make this possible, the build stage often publishes one or
    more pipeline artifacts. This was discussed in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the artifacts that were published in a previous stage of the current pipeline
    can be downloaded using a `download` task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is also possible to download artifacts from other pipelines. To do this,
    the `current` constant has to be replaced with the name of that pipeline. Pipeline
    artifacts are downloaded to the `$(Pipeline.Workspace)` directory.
  prefs: []
  type: TYPE_NORMAL
- en: If you want more fine-grained control over downloading pipeline artifacts, for
    example, over the version of the artifact to use or the location to download the
    artifact to, you can also use the Download Pipeline Artifacts tasks, which are
    documented at [https://docs.microsoft.com/bs-cyrl-ba/azure/devops/pipelines/tasks/utility/download-pipeline-artifact?view=azure-devops](https://docs.microsoft.com/bs-cyrl-ba/azure/devops/pipelines/tasks/utility/download-pipeline-artifact?view=azure-devops).
  prefs: []
  type: TYPE_NORMAL
- en: Publishing and downloading artifacts within a pipeline ensures that the code
    that is built in the first stage is also the code that is deployed in the second
    stage – even if the stages run days apart. In essence, each pipeline run builds
    a local stage of all the artifacts associated with that specific run.
  prefs: []
  type: TYPE_NORMAL
- en: Approvals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a multi-stage pipeline, it is not possible to define approvers as it is in
    a classic release pipeline. The reason for this is that the pipeline – *the build
    and deployment process – *is viewed as code. Code is worked on by developers and
    operators only. Approvals are worked on by, for example, product owners. However,
    this does not mean that it is not possible to implement approval flows for the
    progression of a pipeline to the next stage.
  prefs: []
  type: TYPE_NORMAL
- en: To control whether a pipeline is allowed to proceed to a certain stage, the
    concept of environments needs to be introduced. An environment is defined when
    we give it a name and a description. One or more approvers can be attached to
    these environments. Once this is done, jobs can be configured to target such an
    environment. If there is at least one job in a stage that targets an environment,
    then that environment is said to be used by the stage. If an approval has been
    configured on that environment, the deployment to that stage will not continue
    until the approver has given permission.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start working with environments, you''ll need to access the list of environments.
    This list be found in the Pipelines menu, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/922c7d61-1af0-4e8d-a77b-25d7e990829f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To add a new environment, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Pipelines menu and choose Environments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select New environment from the top right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify a name and description.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is possible to associate resources with an environment. Resources that are
    coupled with an environment can be used in a pipeline if, and only if, that pipeline
    is also targeting that environment. To protect the resources of an environment,
    the owner of that environment can add one or more approvers. An example of a configured
    approver can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8684152-29f0-4fd1-8cf4-ce960c1a1dc7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Approvers can be added to an environment as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the Environments overview pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open an environment by clicking on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the top-right menu marked with the three dots, and and choose Approvals
    and Checks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the Create button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick a user or group from the list and add extra instructions if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the Create button again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Approvals make it possible for you to control the progression of a pipeline
    to the next stage if that pipeline targets the correct environment. Targeting
    an environment is done by specifying a specific type of job: the deployment job.
    The following YAML shows how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Deployment jobs do not directly contain the steps to execute like an agent job
    does. Instead, they first have to specify an execution strategy for the tasks
    outlined under the `steps` keyword. At the time of writing, the only strategy
    supported is `runOnce`. Other strategies are expected to be announced in the future.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, only Kubernetes clusters are supported as environment
    resources, but more types of resources have been announced for the future.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about the technical means for creating release definitions
    and writing multi-stage YAML pipelines, it is time to take a look at the different
    strategies we can use to apply this in practice. These continuous deployment strategies
    are designed to minimize the risk of deploying new versions of an application
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing continuous deployment strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we deploy an application continuously, it is important to think about
    the strategy we should use. Just doing deployment after deployment may have more
    risks associated with it than the business is willing to accept. It is important
    to think about how to deal with issues that might occur during or after deploying
    a new version of your application.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few deployment strategies that can be applied to reduce the risks
    that might come with deployments, all of which will be covered in this section.
    Please note that it is possible to combine one or more of the following patterns.
    For example, it is perfectly possible to use a blue-green strategy for every ring
    in a ring-based deployment. Also, all deployment strategies can be combined with
    the use of feature flags.
  prefs: []
  type: TYPE_NORMAL
- en: Blue-green deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blue-green deployments is a technique where a new version of an application
    never gets deployed to the production servers directly. Instead, it gets deployed
    to another set of servers first. Once this has be done successfully, users are
    directed to the new deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that an application runs on a total of three hosts by default.
    A typical setup for blue-green deployment would be two sets of three hosts: the
    blue group and the green group. In front of these two sets, there is a reverse
    proxy that functions as a load balancer and redirects the incoming requests to
    the blue group. The following diagram shows how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69ebbc65-d520-4d2c-9ba5-feca9cec8e0d.png)'
  prefs: []
  type: TYPE_IMG
- en: To deploy a new version of the application in this situation, it needs to be deployed
    to the green group of servers. Since these servers are not receiving any traffic
    from end users, this has no impact on them at all.
  prefs: []
  type: TYPE_NORMAL
- en: After the deployment, the new deployment can be verified to ensure it was successful
    and that the application is running correctly. After this verification, the load
    balancer is reconfigured to redirect traffic to the green group. Now, the new
    version of the application is served.
  prefs: []
  type: TYPE_NORMAL
- en: Should there suddenly be any unexpected issues, it is very easy to switch back
    to the previous deployment by reconfiguring the load balancer back to the blue
    group. If the deployment is successful and there are no issues, it is possible
    to start the deployment of the next version by going through the same procedure,
    but now with the roles of the green and the blue groups switched.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A variation of the blue-green deployment pattern is immutable servers. With
    immutable servers, there is no going back and forth between two groups of servers.
    Instead, the group of servers that are serving the old version of the application
    is completely disregarded or removed. Often, this is done after a grace period.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of this is that there will still be means to roll back to a previous
    version – almost instantaneously if the old servers are kept around for a while.
    The other benefit is that there is now a guarantee that no remains from a previous
    deployment are being carried over into the newer deployments. Using immutable
    servers, the change of active servers over time might look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d69a070-129b-409b-9fd5-2064e39a2b03.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, an approach like this is only feasible when using technologies such
    as containers or virtual machines. Nobody would expect anyone to disregard physical
    servers after every redeployment.
  prefs: []
  type: TYPE_NORMAL
- en: Progressive exposure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Progressive exposure is a deployment strategy in which the number of users that
    have access to a new deployment or a new feature is slowly increased over time.
    The goal of this strategy is to limit the number of users that are experiencing
    issues when a faulty release of a feature is made available.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also look at this more positively and in line with the continuous deployment
    way of thinking: exposing a new feature to only a few users at first and increasing
    that number over time allows us to increase the amount of trust in a new version
    or feature of an application before exposing it to all users.'
  prefs: []
  type: TYPE_NORMAL
- en: Canary deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first strategy for progressive exposure is to use canary deployments. In
    a canary deployment, not all users are routed to the new version immediately –
    only a limited percentage of the users get access to that version. These users
    are the canaries and they are monitored very closely. If they experience any issues
    or if degradation in performance or a service is measured, the new deployment
    is quickly rolled back.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical approach to realizing canary deployments is to use them in combination
    with blue-green deployments. The difference is that instead of switching all users
    over at the same time, only a small percentage is moved over to the new version
    at the start, and then the number of users that are moved over is gradually increased
    over time. This might look something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b28dc8db-007c-4f6e-baee-cdcdd9b4fe84.png)'
  prefs: []
  type: TYPE_IMG
- en: If a deployment is rolled back because errors have been observed, this is not
    a fun experience for users. To prevent the same small group of users running into
    issues repeatedly, it might be beneficial to select a different group of canary
    users afterward.
  prefs: []
  type: TYPE_NORMAL
- en: Ring-based deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a ring-based environment, there is not just one production environment – there
    are multiple. Each production environment serves only a portion of the users.
    Its difference from a canary deployment is that, instead of just two environments,
    there can be as many environments as needed. Also, every new version goes to all
    the rings, one after the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, instead of redirecting the users, in a ring-based environment, the new
    version is propagating to the servers used by those users. The new version just
    keeps propagating from one ring to the next, until they are all done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94cbe569-28fa-4548-bf78-948edbd3d6db.png)'
  prefs: []
  type: TYPE_IMG
- en: Ring-based deployment architectures are especially suitable for products that
    are accessed by customers from all around the world. The different rings can be
    positioned around the world, thus combining the deployment benefits with the added
    benefit of reduced latencies for users.
  prefs: []
  type: TYPE_NORMAL
- en: Feature flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The third form of progressive deployment can be achieved using feature flags,
    also called feature toggles. Where canary deployments and ring-based deployments
    rely on slowly exposing new binaries to an increasing number of users, feature
    flags are used to slowly expose new features to an increasing number of users.
    This can be achieved even if they are all sending requests to the same server.
    Feature flags are used to decouple deploying a new version of the application
    binaries from releasing new features by enabling or disabling specific features
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The best example of a feature flag is showing or hiding a button that gives
    users access to a new feature. Application settings, a database, or an external
    service are used to keep track of which feature has been enabled for which user.
    Depending on that setting, the feature is shown or hidden. Examples of such external
    services include LaunchDarkly, Split.IO, and Prefab.cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Other feature flags might toggle bug fixes or performance improvements on or
    off. This can help to gradually expose these to ensure there are no issues. When
    using feature toggles for these kinds of changes deeper in a codebase, introducing
    feature toggles also comes with a cost, and a process for this should be in place.
    This process should not only describe adding feature toggles, but also how to
    remove them as soon as possible. An example of such a process can be as follows.
  prefs: []
  type: TYPE_NORMAL
- en: A new feature flag is introduced by a developer as soon as the business needs
    to release the feature independently of the deployments that were made by the
    development team, or for a change that the development team qualifies as high
    risk and wants to be able to pull back at any time without redeploying it. Introducing
    a feature flag means a new database entry or a declaration of a new setting is
    applied in the application settings.
  prefs: []
  type: TYPE_NORMAL
- en: After introducing the feature toggle, the new feature or change is developed
    and tested. This means that there are one or more `if`statements in the codebase
    that execute different code paths, depending on the state of the feature flag.
    At this point, the application must maintain two code execution paths until they
    remove the feature flag again. It is good practice to separate these two code
    paths as much as possible using existing engineering practices, such as dependency
    injection.
  prefs: []
  type: TYPE_NORMAL
- en: While the code is continuously being shipped to users, the feature is not enabled
    for anyone. Only when the development team is fully satisfied with the change
    or the product owner feels the time is right for releasing a new feature is the
    feature flag turned on.
  prefs: []
  type: TYPE_NORMAL
- en: It is important not to stop here. After turning the feature flag on, it should
    actively be determined whether the feature or change is working properly. And
    if it is, the feature flag should be removed as soon as possible. This way, the
    time the two code paths need to be maintained for is as short as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that besides maintaining an increased number of execution paths,
    there is now a larger number of paths to test. The impact of this consequence
    quickly grows if dependencies or exclusions between feature flags are introduced.
    Feature flags that can only be turned on or off, depending on the state of another
    feature flag, can be costly, and it is recommended to avoid this.
  prefs: []
  type: TYPE_NORMAL
- en: If implemented properly and removed as soon as possible, the added cost of feature
    flags is often worth it. As with every engineering practice, start small and evaluate
    what works in the given context, before adapting the practice at scale.
  prefs: []
  type: TYPE_NORMAL
- en: Roll back or fail forward
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No matter which strategy is being used, it is necessary to think about the ability
    to roll back one or more versions and how long that will take. For example, blue-green
    deployments give us the ability to go back one version almost instantaneously,
    as long as a new version is not being deployed to the non-active servers yet.
    On the other hand, performing a rollback in a ring-based deployment will require
    a full redeploy of the previous version, which will probably take longer and comes
    with all the risks of deployment in itself. This may even need to be done on multiple
    rings, making it more challenging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach that can be adopted is that of failing forward. When adopting
    this approach, it is stated that there will never be a rollback to a previous
    version. Instead, when any issue is encountered, this will be addressed by redeploying
    a new version with the fix of that issue in it. This strategy is gaining traction
    lately since it saves time as we don''t have to prepare, test, and practice rollbacks.
    However, there can be risks involved with this process:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no guarantee that the fix will be correct. The issue might not be resolved
    by the new deployed version or, even worse, the new version might result in transitioning
    from one issue to another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working out a detailed root cause of any issue takes time, just like writing
    a fix does. The consequence of this might be that the fix might take longer than
    a rollback would have taken.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No matter which approach is taken, consider the consequences and prepare for
    them.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have mainly focused on web-based applications. In the next section,
    we will shift our attention to mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying mobile applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One type of application that needs a special approach to deployment is mobile
    applications. These applications are often not downloaded and installed by end
    users directly and are mostly consumed via an app store on their mobile device.
  prefs: []
  type: TYPE_NORMAL
- en: App Center is a Microsoft offering that can be used for distributing (deploying)
    mobile applications to end users via app stores, but also via private distribution
    lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'After logging into App Center, you will be taken to the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96a9c809-20ab-4be9-940a-19a1e66de1c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, you can create a new app definition. An app definition should be created
    for every target operating system of an application. If the same application is
    going to be deployed to both Android and iOS, at least two apps have to be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating an app is done by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to App Center.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the blue Add new app button. If there are no existing apps, this button
    will be on the center of the screen; otherwise, it will be at the top right (hidden
    under the popup shown in the preceding screenshot).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the name of the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the type of release.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the operating system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the platform to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Add new app to create the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once an app has been created, it can be connected to the correct app store and
    distribution groups can be created.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the app store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The app store is the main mechanism for distributing an application for all
    mobile platforms. Once a build is delivered to an app store, users can install
    and use the application. The current list of connections to app stores can be
    opened using the Stores tab, on the left-hand side of App Center. From this list,
    an individual store connection can be opened, which will take us to a screen similar
    to the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11e01b80-57ac-4263-b81e-c327525753d3.png)'
  prefs: []
  type: TYPE_IMG
- en: This view shows a list of all the versions of the application that have been
    published to the connected store account. This is also where a new version of
    the application can be selected for publication to the store. This is done using
    the blue Publish button at the top. This will open a popup where you can select
    the correct release. You only have to confirm this once to publish this version.
  prefs: []
  type: TYPE_NORMAL
- en: 'New connections to the store can be created by navigating back to the list
    of all store connections and clicking the Add button. This will open a wizard
    where two pieces of information have to be entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The type of store connection**: This list is limited to the stores that are
    available to apps of the type that was chosen when creating the app definition.
    For example, for iOS, this is limited to the Apple App Store and the Intune Company
    Portal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connection details**: Often, they include the means of authentication between
    App Center and the app store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the new connection has been created, it can be found on the list shown
    previously and can be used to distribute the app.
  prefs: []
  type: TYPE_NORMAL
- en: Another means of distribution is using distribution groups, which we'll introduce
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using distribution groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Distribution groups are used to create named lists of one or more users, often
    testers or alpha users, that install the application through an invitation, rather
    than via the app store. Distribution groups can be found in the left-hand menu,
    under Groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce71df3b-d743-4238-a772-d68809c6b2d7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, a new group can be added, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to Distribution groups using the menu on the left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the blue button labeled with a plus (+) sign (hidden under the popup in
    the preceding screenshot).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a name for the group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add one or more members.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the new group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once a distribution group has been created, it can be used for publishing releases,
    which we will discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing an app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To publish the first or a new version of an app, it has to be shared with App
    Center. This can be done using the Releases tab on the left-hand side. When opening
    up the releases, the following view, detailing all the current releases, will
    appear. From here, any release can be selected so that you can view the details
    of that release:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff331218-9620-4bc3-a888-b4de96a1cd4b.png)'
  prefs: []
  type: TYPE_IMG
- en: In this view, a list of the most recent releases is shown in the middle column.
    After selecting an individual release, the details of that version will be shown.
    This includes its formal version, the store(s) and/or distribution group(s) it
    has been shared with, and other details.
  prefs: []
  type: TYPE_NORMAL
- en: From here, it is possible to distribute this specific version to a store connection
    or distribution group directly using the Distribute bottom at the top right.
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, a new release can also be created by uploading a new build of the
    app. To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the New release button, which is available from the list of all releases.
    (It might be necessary to close the details of a specific release first.) This
    will open the following view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d4c34788-2be7-4547-ac25-7a2c0656a940.png)'
  prefs: []
  type: TYPE_IMG
- en: A new wizard will open, where a build needs to be uploaded. Depending on the
    type of app, the correct type of file will be requested. After uploading the binaries,
    click Next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the release notes have to be filled in. After detailing the changes in
    this release, click Next again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, it is time to specify where this new build should be distributed. At least
    one destination – either a distribution group or a store – has to be selected.
    After selecting one or more destinations, click Next again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final wizard tab will show the selections you've made so far. Check the
    details and click Distribute to complete the creation of a new version and its
    initial distribution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Often, the same version or release needs to be distributed to other groups or
    stores over time as well. It is not necessary (nor useful) to create a new release
    every time. Instead, going to the Detail pages of the new destination store connection
    or distribution group allows you to publish an existing release to that destination
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to using App Center to perform release management this way,
    it is also possible to use Azure Pipelines for release management.
  prefs: []
  type: TYPE_NORMAL
- en: App Center via Azure Pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: App Center can also be integrated with Azure Pipelines. If teams are familiar
    with the release process in Azure Pipelines, it can be sensible to build the app
    in Azure Pipelines and only use App Center for deployment to stores and distribution
    groups.
  prefs: []
  type: TYPE_NORMAL
- en: To make this possible, there are tasks available in Azure Pipelines that allow
    you to upload a release and trigger the deployment of a release to a store or
    distribution group. That way, release management can be done in Azure Pipelines
    while the App Center-specific capabilities are still leveraged where applicable.
  prefs: []
  type: TYPE_NORMAL
- en: This section focused on mobile applications specifically, while the next section
    will apply to all types of releases. When creating releases is automated and new
    versions follow each other quickly, it is useful to start automating the creation
    and publication of release notes as well. This will be discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Automating release notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After automating the build, releasing an application, and working on increasing
    the flow of value to end users, many developers find that it becomes harder and
    harder to keep documentation and release notes up to date. As the amount of releases
    increases, this becomes more and more work, and eventually, the team will fall
    behind or even give up completely.
  prefs: []
  type: TYPE_NORMAL
- en: 'To combat this, it is possible to automate the creation and publication of
    release notes. One way to do this is by using the Azure DevOps Release Notes Generator.
    The generator is an Azure Functions application that is available on GitHub. To
    use the Release Notes Generator, the following needs to be done:'
  prefs: []
  type: TYPE_NORMAL
- en: Download or clone the function code from GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an Azure App Service Plan, function app, and storage account in Azure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new blob container in the storage account called `releases`*.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile the function code and deploy it to an Azure App Service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Azure DevOps WebHook to call the deployed function whenever a new
    release is created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After setting this up, the generator will run whenever a new release is created.
    It will then do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Query the created release for its name, all associated work items, and all the
    commits that are new since the previous release.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a markdown file containing all of this information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload that file to the blob container, that is, `releases`*.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Of course, the Azure DevOps Release Notes Generator is just one example of automating
    tasks around releases, and there are other alternatives available as well. Also,
    many companies create tailored, in-house automation scripts for updating and publishing
    documentation and other tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Other tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to Azure DevOps and App Center, there are other tools that can be
    used for deploying and releasing software. GitLab CI/CD and Jenkins, which were
    discussed in the previous chapter for executing builds, can also be used for releases.
    Besides those, Octopus Deploy is also a commonly used tool that integrates well
    with Azure DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Octopus Deploy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Octopus Deploy** is a deployment automation tool that is based on the concept
    of running a series of tasks on one or more target machines.'
  prefs: []
  type: TYPE_NORMAL
- en: Octopus reaches these machines through a tentacle (an agent) that is installed
    on these machines. In Octopus Deploy, it is possible to define applications and
    environments and assign one or more machines to each of those. To do deployments,
    execution steps can be defined in a graphical editor, comparable to the visual
    release editor of Azure DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main differences is that these steps are not defined per environment,
    only once per pipeline. Next, it is possible to specify which environments each
    task should run on. This way, it is easier to see where the deployment to different
    environments varies.
  prefs: []
  type: TYPE_NORMAL
- en: There is an integration between Azure DevOps and Octopus Deploy available, in
    the form of a build and release task. Using this integration, you can start a
    deployment using Octopus Deploy from an Azure DevOps build or release pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about continuous delivery and deployment and how
    you can implement them using Azure DevOps. In addition to the visual release editor,
    you also learned about multi-stage YAML pipelines, which you can use for releasing
    your software to multiple stages, all of the way to production. Next, we discussed
    a series of strategies that you can use for releasing. You now know about blue-green
    deployments, using immutable servers, and different strategies for progressive
    exposure. You also learned how to choose between making sure you have rollback
    capabilities or accepting a fail forward strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you learned about automating release notes and documentation and how you
    can generate those automatically as part of your pipeline. After that, you learned
    about continuous deployment for mobile applications and how that differs from
    the delivery of web applications. Finally, you learned about the existence of
    Octopus Deploy, how it operates, and that it integrates with Azure DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about topic dependency management using
    Azure Artifacts. Azure Artifacts can be used to host your own NuGet packages or
    to host build artifacts when you are using other products for building or releasing
    your application in combination with Azure Pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude this chapter, here is a list of questions for you to test your
    knowledge of this chapter''s material. You will find the answers in the *Assessments*
    section of the Appendix:'
  prefs: []
  type: TYPE_NORMAL
- en: 'True or false: An Azure DevOps Classic Release is always triggered by the availability
    of a new version of an artifact.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following platforms can App Center publish apps to? (You can choose
    more than one.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Google Play Store
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Apple App Store
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Microsoft Intune
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following techniques use progressive exposure for minimizing the
    risks of deploying a new version? (You can choose more than one.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feature Toggles
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Ring-based deployments
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Canary deployments
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: Deployment groups can be used for deploying software to on-premises
    servers when an Azure Pipelines agent is installed on the machine that will be
    running the software.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the advantage of integrating App Center with Azure Pipelines if you
    have an Azure Pipelines release definition triggering actions in App Center?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More information on using stages in YAML pipelines can be found at [https://docs.microsoft.com/en-us/azure/devops/pipelines/process/stages](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/stages).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information on the idea of immutable servers can be found at [https://martinfowler.com/bliki/ImmutableServer.html](https://martinfowler.com/bliki/ImmutableServer.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about LaunchDarkly can be found at [https://launchdarkly.com/](https://launchdarkly.com/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More details about the build and release extension for integration with Octopus
    Deploy can be found at [https://marketplace.visualstudio.com/items?itemName=octopusdeploy.octopus-deploy-build-release-tasks](https://marketplace.visualstudio.com/items?itemName=octopusdeploy.octopus-deploy-build-release-tasks).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Azure DevOps Release Notes Generator can be found at [https://docs.microsoft.com/en-us/samples/azure-samples/azure-devops-release-notes/azure-devops-release-notes-generator/](https://docs.microsoft.com/en-us/samples/azure-samples/azure-devops-release-notes/azure-devops-release-notes-generator/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some Microsoft hands-on labs for practicing the topics we covered in this chapter
    can be found at [https://docs.microsoft.com/en-us/learn/modules/create-multi-stage-pipeline/index](https://docs.microsoft.com/en-us/learn/modules/create-multi-stage-pipeline/index),
    [https://docs.microsoft.com/en-us/learn/modules/create-release-pipeline/index](https://docs.microsoft.com/en-us/learn/modules/create-release-pipeline/index) and
    [https://docs.microsoft.com/en-us/learn/modules/manage-release-cadence/index](https://docs.microsoft.com/en-us/learn/modules/manage-release-cadence/index).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
