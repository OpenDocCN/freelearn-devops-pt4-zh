<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Dependency Management</h1>
                </header>
            
            <article>
                
<p>In part one of this book, you learned how to continuously deploy your application. While doing so, one of the main issues you might run into is that the total time it takes to build your application is too long. Due to this, developers have to wait a long time for feedback on their changes. One way of coping with this is by splitting your solutions up into multiple builds.</p>
<p>One approach to this is by introducing package management. Often, you will find that you want to reuse code from a previous project in a new project. Instead of copying and pasting this code from one project to another, you can create a shared library out of it. In this chapter, you will learn how to identify shared components and how to make them reusable using Azure Artifacts. In addition to this, you will learn how you can use Azure Artifacts for storing pipeline artifacts when working in a heterogeneous architecture. Here, you will also work with other CI/CD tools than just Azure DevOps. For this, you will learn how to use Azure Artifacts for universal packages.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Identifying shared components</li>
<li>Creating a feed</li>
<li>Publishing packages</li>
<li>Consuming packages</li>
<li>Working with universal packages</li>
<li>Exploring other tools</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To experiment with the topics mentioned in this chapter, only an Azure DevOps organization is required.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Identifying shared components</h1>
                </header>
            
            <article>
                
<p>Adopting DevOps practices, such as continuous integration/continuous delivery, can greatly reduce the amount of time you have to spend on building and testing your applications. Besides building your applications, there are also many other concerns that you can address in your pipelines.</p>
<p>When you start adding more and more tasks to your pipelines, you might run into a situation in which a single execution of your pipeline starts taking too long, sometimes longer than 5 minutes. Note that this a general recommendation for the maximum duration of a CI pipeline. In order to battle this, you might be interested in splitting your solution up into smaller builds and maybe even repositories. To do this, you could build parts of that application in isolation and then use the results of these builds in your main application as ready-built components.</p>
<div class="packt_infobox">A general recommendation for the maximum duration of a CI pipeline is 5 minutes.</div>
<p>Another reason for wanting to split your solution into parts is the use of shared projects. Imagine that you have two solutions that work closely together: one being a REST API and the other being a client package that you ship to your customers to work with that API. It is likely that these two solutions share at least one project with all the objects that are used for modeling the data that is sent back and forth between the two. Here, you could make a third solution with only the shared project, which you could then use as a package in your other solutions.</p>
<p>Or what if you work at a team that is responsible for maintaining a whole series of solutions and you find that you have complete namespaces that are copied and pasted between these solutions. It is not a desirable situation and one that probably comes with a lot of issues. What if you could write this code just once, build it, package it, and then reuse it in all of these solutions.</p>
<p>To summarize, three reasons for starting to work with packages and artifact feeds are as follows:</p>
<ul>
<li>Reducing build and CI times by splitting a larger solution into parts</li>
<li>Extracting shared components into packages</li>
<li>Building packages that are used by other teams</li>
</ul>
<p>In the remainder of this chapter, you will learn techniques for doing this by building packages out of (parts of) your application code, hosting them in a centralized location, and reusing them in one or more other solutions.</p>
<p>In all three scenarios, you might be looking to increase the reusability of the code, but also to reduce the time taken between checking for a change and receiving feedback for that change in the form of automated test results. Before you start breaking up your application, remember that moving part of your solution to a separate component does not always achieve this.</p>
<p>If you break your application up into three components and one remaining main part, make sure that you can build and test these three components completely in isolation, or at least close to 100%. If you cannot test a component of your application in isolation, creating a separate repository and build for that component will actually increase the time between checking for a change and the moment of feedback to you as a developer. Both separate builds might run quicker, but now you need to wait for two builds before you receive any feedback.</p>
<div class="packt_tip">If you break your application up into separate components, make sure that each component can be built and tested in isolation to a high degree.</div>
<p>As well as this, you have to make sure that making a reusable component out of part of your application makes sense from a conceptual point of view. For example, components that are addressing a cross-cutting concern such as logging libraries or database abstraction layers are great candidates for factoring out to shared libraries. (On a side note, after you have done so, you might also want to consider replacing your own general-purpose libraries with off-the-shelf alternatives where possible.)</p>
<p>However, if splitting your solution into components makes sense, it can bring great benefits.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Types of feeds</h1>
                </header>
            
            <article>
                
<p>There are many types of package feeds that can be hosted in Azure Artifacts. How you will use an Artifact feed will depend on the language and ecosystem used by the application. The following ecosystems are supported in Azure Artifacts:</p>
<ul>
<li><strong>NuGet</strong>: When working with Microsoft .NET languages, the protocol used for package management is NuGet.</li>
<li><strong>npm</strong>: The npm protocol is used when building applications with JavaScript or TypeScript.</li>
<li><strong>Maven or Gradle</strong>: Maven and Gradle are used from the Java ecosystem.</li>
<li><strong>Pip and Twine</strong>: When working with Python packages, they can be obtained using these protocols.</li>
<li><strong>Universal packages</strong>: Universal packages are not associated with a specific ecosystem, but are a generic means for uploading and retrieving packages.</li>
</ul>
<p>Whenever a new feed is created, no type needs to be specified. In fact, every feed can be accessed using any protocol, even with different protocols over time. However, in general, this does not make sense.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a feed</h1>
                </header>
            
            <article>
                
<p>Once you have identified one or more packages that you want to publish, you will need a place to store them. For this, you can use the Azure Artifacts offering. The following diagram shows the structural makeup of Azure Artifacts:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1037 image-border" src="assets/b1ad6c02-14cf-41af-8b66-91ad6f853650.png" style="width:13.42em;height:14.83em;"/></p>
<p>Within Azure Artifacts, you can create one or more feeds where you can store your packages. For each package, you can have multiple versions in a feed. The feed is the level on which you can set up authorizations for publishing packages. Within a feed, you can create one or more views that you can use for setting up authorizations for consuming packages. A specific version of any given package can be in more than one view at the same time. The following sections discuss all these concepts in more detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up a feed</h1>
                </header>
            
            <article>
                
<p>Within Azure Artifacts, the feed is the location where your packages are stored. Each feed is a separate and fully isolated repository. To create a new feed, follow these steps:</p>
<ol>
<li>First, navigate to Azure Artifacts in the menu on the left and then click on the <span class="packt_screen">Create feed</span> button (partially visible to access the view for creating a new feed):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1038 image-border" src="assets/5fdf7dfd-0736-4d9d-b6fa-40ab7c192601.png" style="width:208.33em;height:105.00em;"/></p>
<ol start="2">
<li>Specify a name for the feed. It should not contain any spaces and preferably contain only letters and numbers, since it will become part of a URL. </li>
<li><span>Next, it is possible to specify the initial settings for visibility. This determines which users can view the feed. This will be discussed in more detail later.</span></li>
</ol>
<ol start="4">
<li>Configure the <span>use of upstream sources. This will also be covered in more detail later.<br/></span></li>
<li><span>A few seconds after selecting <span class="packt_screen">Create</span>, your feed will be available.</span></li>
</ol>
<p>Once the feed is created, you can configure various settings such as hiding deleted packages, enabling package batches, and configuring retention policies. To learn how to do this, follow these steps:</p>
<ol>
<li>After the feed is created, access the settings for the feed by clicking on the gearbox in the top-right corner.</li>
<li>Choose <span class="packt_screen">Feed settings</span> in the view shown in the following screenshot. In this view, you can configure a few more things:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1039 image-border" src="assets/8dea9422-70f3-41ee-8569-af19213a4a9a.png" style="width:41.75em;height:29.83em;"/></p>
<ol start="3">
<li>Besides changing the name and adding a description, you can choose to hide deleted packages. When you do this, versions of a package that have been removed are no longer visible to administrators of the feed. Regular users are never able to view or use deleted packages, but this setting enables the same view logic as administrators.</li>
</ol>
<ol start="4">
<li>Another setting you can enable is that of package badges. A package badge is a visual element with the name of a package and the latest available version. If you enable this option, you can retrieve a URL for each package that will be a package badge for that package. This is useful for people who want to keep tabs on the latest version of a package.</li>
</ol>
<ol start="5">
<li>Finally, you can configure a retention policy. Here, you can configure the automated removal when the number of versions of a package exceeds a certain threshold. While this helps you to save disk space and therefore costs, this can have the unintended effect of breaking downstream users of the feed. To put in a safeguard against this, you can prevent removing a package for <em>x</em> number of days after it has been downloaded for the last time. Next to that, keep in mind that any package version that is currently a member of a feed will not be removed.</li>
<li>Once done, click on the <span class="packt_screen">Save</span> button.</li>
</ol>
<p><span>After you have created and configured your feed, it is time to specify which users have access to the feed and what permissions they have. Let's learn how to do that next.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Securing access</h1>
                </header>
            
            <article>
                
<p>There are four roles you can assign to a user or group, where the rights of each next role include the rights of the previous roles as well:</p>
<ul>
<li><strong>Readers</strong> are able to list all packages in a feed and can download them.</li>
<li><strong>Collaborators</strong> are also able to use packages from upstream sources.</li>
<li><strong>Contributors</strong> can also publish their own packages and unlist and deprecate packages.</li>
<li>Finally, <strong>owners</strong> have full control over the feed and can also change permissions, rename, or delete the feed.</li>
</ul>
<p>To change the permission of a user, follow these steps:</p>
<ol>
<li>Navigate to the <span class="packt_screen">Permissions</span> view that you can see in the following screenshot. <span>In this view, you can see a list of every user or group that has permissions assigned:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1040 image-border" src="assets/1ad71676-4d9d-4e06-a88b-089278359736.png" style="width:96.67em;height:34.17em;"/></p>
<ol start="2">
<li>To remove permissions, select the row and click on <span class="packt_screen">Delete</span>.</li>
<li>To add a new row, click on the add button. This will open the view you see to the right.</li>
</ol>
<p>As an alternative to adding users or groups as a reader on the whole feed, it is also possible to create one or more views on the feed and set access rights per view.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing views on a feed</h1>
                </header>
            
            <article>
                
<p>A feed is a repository of packages that you can publish and download packages to and from. However, there are many cases where you do not want every uploaded package to be available for download. Often, you might find that you want to control who can use which versions of a package; for example, when you are implementing the continuous delivery of a shared library but want to share only stable versions with the rest of your organization.</p>
<p>To do this, you can create views. A view is a subset of the package versions within a feed. When working with a view, as a consumer, it behaves just as if it were a feed.</p>
<p>Views can be managed as follows:</p>
<ol>
<li>Navigate and click on <span class="packt_screen">Views</span>; you should see something similar to the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1041 image-border" src="assets/f3c05b59-f7f6-4a4c-ad15-e8aee0c26329.png" style="width:107.08em;height:39.33em;"/></p>
<ol start="2">
<li>Here, you can see a list of all the current views and remove any views by selecting the row and clicking on <span class="packt_screen">Delete</span>.</li>
<li>Adding new views can be done using the add button, which opens the view you see to the right.</li>
<li>You can set permissions for reading from a view here as well. You can allow read access to your whole Azure DevOps organization, or specify specific users. Any user or group you add here will get reader permissions on this view only.</li>
<li>Editing permissions can be done by selecting any row and choosing <span class="packt_screen">Edit</span>.</li>
</ol>
<p>Once one or more views are available, packages can be promoted to a view for consumption through the view.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring upstream sources</h1>
                </header>
            
            <article>
                
<p>The final thing that you can configure on your feed is the upstream sources. Azure Artifacts feeds give you a repository where you can publish your own packages for reuse from one or more locations.</p>
<p>However, you will probably also use packages that are publicly available on repositories such as <kbd>NuGet.org</kbd> or <kbd>npmjs.org</kbd>. In this case, you could use a combination of an Artifacts feed and <kbd>NuGet.org</kbd>, but you can also configure your feed to serve packages from <kbd>NuGet.org</kbd> as well. If you do this, <kbd>NuGet.org</kbd> is called an upstream source.</p>
<p>Along with simplicity, this gives you the added benefit of having one central location where you can see all the packages you are using in your solution(s). This enables you to quickly check which packages and versions you are using, which can be useful for compliance or security checks. Using the different permissions between the reader and the collaborator role, you can also configure which users are authorized to pull packages from <kbd>NuGet.org</kbd> to your feed, and which users are not.</p>
<p>Of course, you can do this for any repository that is accessible over the internet and implements one of the protocols that Azure Artifacts supports. To configure upstream sources, follow these steps:</p>
<ol>
<li>Upstream sources can be configured after navigating to the following screen:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1042 image-border" src="assets/6750b743-bd18-482b-b4ee-297c70e06f8e.png" style="width:132.08em;height:31.50em;"/></p>
<ol start="2">
<li>Upstream sources are configured in the same way as permissions and views. You can delete upstream sources using the <span class="packt_screen">Delete</span> button in the menu bar.</li>
<li>Adding upstream sources is done by clicking on the <span class="packt_screen">Add upstream source</span> button, which opens the view on the right.</li>
</ol>
<div class="packt_infobox">A final thing to note about the use of upstream sources is that it is not possible to have the same version of a package published to your own feed if the same version of that package is already available in an upstream source.</div>
<p>This section discussed how to create and connect feeds. Now that these are in place, we will learn how to publish packages to those feeds in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Publishing packages</h1>
                </header>
            
            <article>
                
<p>Now that you know how to create and manage feeds, it is time to learn how to publish packages to them. If you have experience of publishing packages to public feeds, you will see that publishing to Azure Artifacts works in precisely the same way. There are two ways in which you can publish packages to a feed:</p>
<ul>
<li>Manually from your own computer</li>
<li>By using Azure Pipelines</li>
</ul>
<p>Both options are explored in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Uploading packages by hand</h1>
                </header>
            
            <article>
                
<p>To upload packages by hand, the following steps need to be performed:</p>
<ol>
<li>First, you will have to retrieve the URL to your feed. To do this, click on <span class="packt_screen">Connect to feed</span> for any of your feeds, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1043 image-border" src="assets/c7d5dae9-96c6-46f0-84fd-9615cbcb02a6.png" style="width:72.17em;height:37.08em;"/></p>
<ol start="2">
<li>In the list on the left, select the protocol to use for accessing the feed.</li>
<li>Select the correct view to use. Remember that for publishing packages, the full feed URL needs to be used since views are read-only.</li>
</ol>
<ol start="4">
<li>After making the correct selections, copy the correct URL to the clipboard using the <span class="packt_screen">copy</span> button.</li>
<li>Execute the following command to create a NuGet package from a regular <kbd>.csproj</kbd> file. If you do not have the <kbd>NuGet.exe</kbd> tool already available, you can download it using the link provided at the end of this chapter:</li>
</ol>
<pre style="padding-left: 90px">nuget.exe pack DemoSolution\MyPackage.csproj -Version 1.1.0</pre>
<ol start="6">
<li>Execute the final command for uploading the package to NuGet:</li>
</ol>
<pre style="padding-left: 90px">nuget.exe push <br/>    -Source "{feedUrl}" "MyPackage.1.1.0.nupkg"</pre>
<p>After executing the final command, the package will be published and become available in your feed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Publishing packages from a pipeline</h1>
                </header>
            
            <article>
                
<p>Uploading a package by hand is not a convenient solution if you need to do it more than once. In cases where you want to frequently generate and publish a new version of a library, you can use an Azure pipeline. As well as to the automation that this gives you, it is also a great way to introduce repeatability and reliability, since you can now use all of the benefits that pipelines offer you.</p>
<p>As an example, you can find a possible build definition for creating an <kbd>npm</kbd> package and publishing that as follows. The sources for this build are from an open source Microsoft GitHub repository called <kbd>tfs-cli</kbd>.</p>
<p>In this pipeline, there are three usages of the built-in <kbd>npm</kbd> task:</p>
<ul>
<li><span>The first occurrence is an <kbd>npm install</kbd> command. This command is used for installing the dependencies for this package:</span></li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1202 image-border" src="assets/d86d3e0c-40cc-41e1-99d7-dd316a0c7067.png" style="width:33.92em;height:26.00em;"/></p>
<ul>
<li><span>The second occurrence is running a custom command,</span> <kbd>build</kbd><span>. This command is defined in the source code itself using <kbd>package.json</kbd> and is used for transpiling the sources from TypeScript to JavaScript:</span></li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1203 image-border" src="assets/35e773ee-03d3-4197-a282-f6e7a5392d48.png" style="width:19.67em;height:22.08em;"/></p>
<ul>
<li>The final and third task is running the <kbd>npm publish</kbd> command to publish the generated package to an <kbd>npm</kbd> feed. In this instance, there is no external feed selected but a built-in target registry: the Azure Artifacts feed:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1204 image-border" src="assets/dcf02618-730b-44f8-b89a-b60306f80e43.png" style="width:36.42em;height:33.83em;"/></p>
<p>After running this build, your package is available in your feed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Versioning packages</h1>
                </header>
            
            <article>
                
<p>One of the things that is not done automatically using the tasks for uploading an <kbd>npm</kbd> package, or most types of packages for that matter, is managing the version number. Of course, there are many ways in which you can make sure your packages have proper versions, but a common approach is setting (part of) the version number during the build of a package.</p>
<p>Expanding on the <kbd>npm</kbd> package build that we demonstrated before, three changes can be made to the build definition:</p>
<ol>
<li>First, the build number format for the build definition is updated to the following: <kbd>1.0$(Rev:.rrr)</kbd>. This guarantees that a unique number is automatically generated for every build. The <kbd>Ref:.rrr</kbd> <span>variable </span>will generate a number with three positions, leading with zeros if needed. The first time, this number will be <kbd>000</kbd>, and it will increase by one every time the rest of the build number is not changed.</li>
<li>Second, a task is added to replace the version number that is currently specified in the source control, using the <kbd>{#Build.BuildNumber#}</kbd> <span>token.</span> This is a reference to the build variable with the name <kbd>Build.BuildNumber</kbd>, which contains the build number that was specified in <em>step 1</em>.</li>
<li>Finally, a <span class="packt_screen">Replace Tokens</span> task is added to the build before all other tasks. A possible configuration to replace the magic fixed-version number with the automatic version number for this task is shown as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1044 image-border" src="assets/b3b8b1b1-e1a5-4841-bd44-c64708fc484b.png" style="width:68.92em;height:33.67em;"/></p>
<p>This task can be configured to replace the tokens in one or more target files (<em><span class="packt_screen">1</span></em>). It will look for any series of characters starting with <kbd>{#</kbd> and ending in <kbd>#}</kbd>, take the text between these two markers, and then replace the whole text with the value of the corresponding variable.</p>
<p>With this in place, every package that is built using the definition will have a unique and ever-increasing patch version number. Whenever the major or minor version number needs to be updated, this can be done by updating the build number format.</p>
<p>As an alternative to this approach, there are many tasks available from the extensions marketplace that can help with versioning, including more complex scenarios.</p>
<p>This section discussed how to publish packages to a feed. With packages published to a feed, the next section will detail how these can be used with either Visual Studio or an Azure Pipeline.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Consuming packages</h1>
                </header>
            
            <article>
                
<p>Uploading packages to an Azure Artifacts feed or repository makes them available for use in many different scenarios. Two common scenarios are using your own packages with Visual Studio or from Azure Pipelines. Both scenarios will be detailed in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Consuming packages from Visual Studio</h1>
                </header>
            
            <article>
                
<p>Once you have your shared libraries available as NuGet packages in an Azure Artifacts feed, you can start using them from Visual Studio. Before you can do this, you will have to register your feed in your Visual Studio instance.</p>
<p>To do this, you first have to grab the URL of your feed. In order to do this, refer to the <em>Uploading packages by hand</em> <span>section</span>. Once you have your URL ready, go to manage NuGet files for your solution, as you would do normally. If you are not familiar with working with NuGet packages in Visual Studio, you can find this option in the solution explorer on the solution and project headers:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1045 image-border" src="assets/46845a03-ffff-4830-9481-2c2566c214e9.png" style="width:91.58em;height:60.75em;"/></p>
<p>Once you are here, walk through the following steps:</p>
<ol>
<li>Click on the small gearbox in the top-right corner to open the dialog where you can configure which NuGet feeds to use.</li>
<li>Add a new feed.</li>
<li>Fill in both the name and the source of your own feed.</li>
<li>After doing so, do not forget to click on <span class="packt_screen">Update</span>; otherwise, your changes to the <span class="packt_screen">Name</span> and <span class="packt_screen">Source</span> fields will not be saved and there will be no warning prompting you that you have unsaved changes.</li>
<li>After you have made these changes, you can now select your feed as the package source in the top right of the screen.</li>
</ol>
<p>From here onward, it is possible to work with these packages from your own feed just as you do with packages from <kbd>NuGet.org</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Consuming packages from a pipeline</h1>
                </header>
            
            <article>
                
<p>Once you start using your packages in Visual Studio, it is very likely you will need them in Azure Pipelines as well. This is in order to perform CI/CD on the dependent application that uses your packages.</p>
<p>Fortunately, this can be achieved with a small configuration change on your NuGet restore task, as shown in the following screenshot. The following screenshot relates to the NuGet restore task that can be used with both the Visual Studio build tasks and the .Net Core build tasks. Both contain the same interface and can be used in the same way:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1046 image-border" src="assets/81fed0eb-03ff-4db1-8001-2c0521612bb7.png" style="width:31.00em;height:12.33em;"/></p>
<p>By default, only the radio button for using packages from NuGet is checked; so, to include packages from your own feeds as well, you need to select the correct feed in the drop-down list.</p>
<p>If you ever find the need to include packages from more than one feed, you will be forced to create one aggregator feed and use the other feeds as upstream sources for that aggregator feed.</p>
<p>This section covered how to consume component packages from Visual Studio. The next section will dive into working with universal packages for sharing general binary packages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with universal packages</h1>
                </header>
            
            <article>
                
<p>The previous sections have all concentered on using Azure Artifacts as a means for redistributing application packages such as libraries or other shared components. However, there is also another important use of Azure Artifacts, which is using a feed for storing any type of binary package. These are called universal packages.</p>
<p>Since a universal packages feed can be used to store any type of package, this makes it a good choice for storing build artifacts if you are working with more than one CI/CD tool. In this case, you can use universal packages for storing and serving your build artifacts to and from whichever tool you are using at that time. This can be particularly useful since the built-in storage for classic build and release pipelines cannot be accessed by other tools.</p>
<p>To use universal packages for staging your build artifacts in such a heterogeneous architecture, there are four basic operations you should understand: uploading and downloading universal packages from an Azure pipeline and uploading and downloading universal packages using the Azure CLI. The last one you can invoke from other tools.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Uploading and downloading universal packages from Azure Pipelines</h1>
                </header>
            
            <article>
                
<p>Uploading build artifacts to a universal packages feed works in a similar way as uploading a regular build artifact. There are two changes you need to consider.</p>
<p>Firstly, you have to use another task for performing the upload. Instead of using the <em>publish build artifact</em> or <em>publish pipeline artifact</em> tasks, you have to use the task named <span class="packt_screen">Universal Packages</span>. When using this task, you can still give a name to the artifact and specify a location on the filesystem of the build agent to upload it from. Next, you can specify a target feed and a version to use. This version can be either automatically incremented whenever a new package is uploaded or be specified using a build variable.</p>
<p>Secondly, you have to consider the fact that the uploaded package is not associated one-to-one with the build that produced it—as it is with regular build or pipeline artifacts. This means that no matter where you are using the package that has been uploaded, you have to find another way to find the correct version to download.</p>
<p>To perform the actual download, you can use the <span class="packt_screen">Universal Packages</span> task again, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1047 image-border" src="assets/da1afaf8-384a-4b16-9d05-772895c51fab.png" style="width:60.75em;height:43.00em;"/></p>
<p>Refer to the screenshot and follow these steps:</p>
<ol>
<li>After adding the task, you can toggle it between upload and download.</li>
<li>You can also specify a directory that is uploaded as the artifact.</li>
<li>Or you can specify where the artifact should be downloaded. </li>
<li>Furthermore, the name of the feed needs to be specified.</li>
<li>Also, specify the name of the package.</li>
<li>Specify the version to be either upload or download.</li>
</ol>
<div class="packt_infobox">Note that you can also use feeds that are not part of your own organization by choosing to use another feed at step <em><span class="packt_screen">5</span></em>. If you do so, you need to create a service endpoint for reaching that feed.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Uploading and downloading universal packages using the Azure CLI</h1>
                </header>
            
            <article>
                
<p>When you want to work with universal packages from a product other than Azure Pipelines, you will have to use the Azure CLI. To do this, perform the following steps:</p>
<ol>
<li>The first thing you have to do to work with universal packages using the Azure CLI is to install the CLI itself. The link to the CLI can be found at the end of this chapter.</li>
<li>Next, it is time to install the extension for Azure DevOps. This can be done using the following command:</li>
</ol>
<pre style="padding-left: 90px"><strong>az extension add –name azure-devops</strong></pre>
<ol start="3">
<li>After making the extension for Azure DevOps available, you have to log in using the account that you also use to work within the Azure DevOps UI. You can log in by giving the following command:</li>
</ol>
<pre style="padding-left: 90px"><strong>az login</strong></pre>
<ol start="4">
<li>Once logged in, you can upload a file as an artifact using the following command:</li>
</ol>
<pre style="padding-left: 90px"><strong>az artifacts universal publish </strong><br/><strong>    --feed {yourFeedName} </strong><br/><strong>    --name {yourPackageName} </strong><br/><strong>    --version {yourVersion}</strong><br/><strong>    --organization https://dev.azure.com/{yourOrganizationName}</strong><br/><strong>    --path {sourceFileName}</strong></pre>
<ol start="5">
<li>To download a particular version of an artifact again, you can use the following:</li>
</ol>
<pre style="padding-left: 90px"><strong>az artifacts universal download </strong><br/><strong>    --feed {yourFeedName} </strong><br/><strong>    --name {yourPackageName}</strong><br/><strong> --version {yourVersion}</strong><br/><strong>    --organization https://dev.azure.com/{yourOrganizationName}</strong><br/><strong>    --path {targetFileName}</strong></pre>
<p>Using the CLI and these commands, you can use Azure Artifacts as a means for sharing build artifacts between multiple tools. When working with a number of tools on the same project, Universal Packages are a great tool for moving binaries around.</p>
<p>In the next section, other tools available for package management will be explored.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring other tools</h1>
                </header>
            
            <article>
                
<p>There are many other tools available for doing binary management. Three commonly used products are MyGet, Artifactory, and <strong>Azure Container Registry</strong><span> (</span><strong>ACR</strong><span>)</span>. The features they deliver do overlap, but they also have specific points at which they excel.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MyGet</h1>
                </header>
            
            <article>
                
<p>MyGet is an alternative location for hosting your NuGet packages. MyGet allows you to create both public and private feeds that are managed by you. MyGet also supports defining upstream sources and delivers built-in dependency scanning to give you continuous feedback on the level of security of your dependencies.</p>
<p>Since MyGet is an implementation of the NuGet protocol, you can publish and use packages using the default NuGet tasks from Azure Pipelines.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Artifactory</h1>
                </header>
            
            <article>
                
<p>Artifactory, a product by JFrog, is another tool that you can use for hosting your package feeds. Artifactory is originally an on-premises product, but it is now also available as a SaaS offering. Just like Azure Artifacts, it supports multiple protocols for interacting with package feeds. At the time of writing, Artifactory supports more repository protocols than Azure Artifacts. Examples of this include PHP Composer and <strong>Red Hat Package Manager</strong> (<strong>RPM</strong>).</p>
<p>JFrog has published an Azure Pipelines extension for downloading and uploading packages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Azure Container Registry</h1>
                </header>
            
            <article>
                
<p>Another type of storage for reusable packages is ACR. ACR is designed specifically for container images and has an understanding of the layered buildup of these images. This allows it to receive only partial uploads when a new version of an image becomes available if not all of the layers have changed. This makes ACR a very good location for storing container images. Uploads will be faster and ACR storage is cheaper than Azure Artifacts storage. This is a big benefit since container images can be large.</p>
<p>You can integrate with ACR from Azure Pipelines using the Docker integration extensions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned how to identify shared components in your solutions: pieces of code that appear not only in multiple locations but are also logical units for reuse. You learned how to use Azure Artifacts feeds for hosting packages that contain these libraries. Furthermore, you learned how to use these hosted packages to build dependent solutions using both Visual Studio and Azure Pipelines. You also learned about using universal packages to share build artifacts between Azure Pipelines and other tools that you might use for CI/CD.</p>
<p>With this knowledge, you will now be able to identify shared components in your solution(s). Once you have identified such a component, you will also be able to isolate it in source control, build it, and publish it to an artifact feed. From here, you can distribute it to one or more consuming solutions. Finally, you are now also capable of using Artifact feeds for sharing build artifacts between different CI/CD products.</p>
<p>In the next chapter, you will learn about infrastructure and configuration as code. This is one of the fundamental DevOps practices that allows you to have your infrastructure definition in source control and use that as part of your release pipeline.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<p>As we conclude, here is a list of questions for you to test your knowledge regarding this chapter's material. You will find the answers in the <em>Assessments</em> section of the Appendix:</p>
<ol>
<li>True or false: Any version of a package can be deployed to only one view within a feed.</li>
<li>True or false: Pipeline artifacts can be used for sharing build outcomes (packages) from Azure DevOps to other products.</li>
<li>True or false: Azure Artifact feeds with universal packages can be used for sharing build outcomes (packages) from Azure DevOps to other products.</li>
</ol>
<ol start="4">
<li>Which of the following is needed to enable building a solution that uses packages from an Azure Artifacts feed in Visual Studio? (You can select more than one option.)<br/>
<ol>
<li>Adding the full package URL to your project dependencies, instead of only the package name</li>
<li>Having at least <em>reader</em> access to the feed or one of the views in the feed</li>
<li>Having at least <em>consumer</em> access to the feed</li>
<li>Configuring the location of the feed as a package source for Visual Studio</li>
</ol>
</li>
<li>What can be the motivators for splitting a solution into multiple parts that are separated by Azure Artifacts feeds?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>Exercises for practicing with Azure DevOps Artifacts can be found at <a href="https://docs.microsoft.com/en-us/learn/modules/manage-build-dependencies/">https://docs.microsoft.com/en-us/learn/modules/manage-build-dependencies/</a>.</li>
<li>You can find and download <kbd>NuGet.exe</kbd> from <a href="https://www.nuget.org/downloads">https://www.nuget.org/downloads</a>.</li>
<li>Information on downloading and installing the Azure CLI can be found at <a href="https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest">https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest</a>.</li>
<li>More information about MyGet is available at <a href="https://www.myget.org/">https://www.myget.org/</a>.</li>
<li>More information about JFrog Artifactory is available at <a href="https://jfrog.com/artifactory/">https://jfrog.com/artifactory/</a>, and the extension for Azure Pipelines can be found at <a href="https://marketplace.visualstudio.com/items?itemName=JFrog.jfrog-artifactory-vsts-extension">https://marketplace.visualstudio.com/items?itemName=JFrog.jfrog-artifactory-vsts-extension</a>.</li>
<li>More information about ACR is available at <a href="https://azure.microsoft.com/en-in/services/container-registry/">https://azure.microsoft.com/en-in/services/container-registry/</a>.</li>
<li>You can find the Docker extensions for Azure Pipelines at <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscs-rm.docker">https://marketplace.visualstudio.com/items?itemName=ms-vscs-rm.docker</a>.</li>
</ul>


            </article>

            
        </section>
    </body></html>