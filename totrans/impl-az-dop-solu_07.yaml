- en: Dependency Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In part one of this book, you learned how to continuously deploy your application.
    While doing so, one of the main issues you might run into is that the total time
    it takes to build your application is too long. Due to this, developers have to
    wait a long time for feedback on their changes. One way of coping with this is
    by splitting your solutions up into multiple builds.
  prefs: []
  type: TYPE_NORMAL
- en: One approach to this is by introducing package management. Often, you will find
    that you want to reuse code from a previous project in a new project. Instead
    of copying and pasting this code from one project to another, you can create a
    shared library out of it. In this chapter, you will learn how to identify shared
    components and how to make them reusable using Azure Artifacts. In addition to
    this, you will learn how you can use Azure Artifacts for storing pipeline artifacts
    when working in a heterogeneous architecture. Here, you will also work with other
    CI/CD tools than just Azure DevOps. For this, you will learn how to use Azure
    Artifacts for universal packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying shared components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a feed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with universal packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring other tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To experiment with the topics mentioned in this chapter, only an Azure DevOps
    organization is required.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying shared components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adopting DevOps practices, such as continuous integration/continuous delivery,
    can greatly reduce the amount of time you have to spend on building and testing
    your applications. Besides building your applications, there are also many other
    concerns that you can address in your pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: When you start adding more and more tasks to your pipelines, you might run into
    a situation in which a single execution of your pipeline starts taking too long,
    sometimes longer than 5 minutes. Note that this a general recommendation for the
    maximum duration of a CI pipeline. In order to battle this, you might be interested
    in splitting your solution up into smaller builds and maybe even repositories.
    To do this, you could build parts of that application in isolation and then use
    the results of these builds in your main application as ready-built components.
  prefs: []
  type: TYPE_NORMAL
- en: A general recommendation for the maximum duration of a CI pipeline is 5 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another reason for wanting to split your solution into parts is the use of
    shared projects. Imagine that you have two solutions that work closely together:
    one being a REST API and the other being a client package that you ship to your
    customers to work with that API. It is likely that these two solutions share at
    least one project with all the objects that are used for modeling the data that
    is sent back and forth between the two. Here, you could make a third solution
    with only the shared project, which you could then use as a package in your other
    solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: Or what if you work at a team that is responsible for maintaining a whole series
    of solutions and you find that you have complete namespaces that are copied and
    pasted between these solutions. It is not a desirable situation and one that probably
    comes with a lot of issues. What if you could write this code just once, build
    it, package it, and then reuse it in all of these solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, three reasons for starting to work with packages and artifact
    feeds are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Reducing build and CI times by splitting a larger solution into parts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting shared components into packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building packages that are used by other teams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the remainder of this chapter, you will learn techniques for doing this by
    building packages out of (parts of) your application code, hosting them in a centralized
    location, and reusing them in one or more other solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In all three scenarios, you might be looking to increase the reusability of
    the code, but also to reduce the time taken between checking for a change and
    receiving feedback for that change in the form of automated test results. Before
    you start breaking up your application, remember that moving part of your solution
    to a separate component does not always achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: If you break your application up into three components and one remaining main
    part, make sure that you can build and test these three components completely
    in isolation, or at least close to 100%. If you cannot test a component of your
    application in isolation, creating a separate repository and build for that component
    will actually increase the time between checking for a change and the moment of
    feedback to you as a developer. Both separate builds might run quicker, but now
    you need to wait for two builds before you receive any feedback.
  prefs: []
  type: TYPE_NORMAL
- en: If you break your application up into separate components, make sure that each
    component can be built and tested in isolation to a high degree.
  prefs: []
  type: TYPE_NORMAL
- en: As well as this, you have to make sure that making a reusable component out
    of part of your application makes sense from a conceptual point of view. For example,
    components that are addressing a cross-cutting concern such as logging libraries
    or database abstraction layers are great candidates for factoring out to shared
    libraries. (On a side note, after you have done so, you might also want to consider
    replacing your own general-purpose libraries with off-the-shelf alternatives where
    possible.)
  prefs: []
  type: TYPE_NORMAL
- en: However, if splitting your solution into components makes sense, it can bring
    great benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Types of feeds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many types of package feeds that can be hosted in Azure Artifacts.
    How you will use an Artifact feed will depend on the language and ecosystem used
    by the application. The following ecosystems are supported in Azure Artifacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NuGet**: When working with Microsoft .NET languages, the protocol used for
    package management is NuGet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**npm**: The npm protocol is used when building applications with JavaScript
    or TypeScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maven or Gradle**: Maven and Gradle are used from the Java ecosystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pip and Twine**: When working with Python packages, they can be obtained
    using these protocols.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Universal packages**: Universal packages are not associated with a specific
    ecosystem, but are a generic means for uploading and retrieving packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever a new feed is created, no type needs to be specified. In fact, every
    feed can be accessed using any protocol, even with different protocols over time.
    However, in general, this does not make sense.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a feed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have identified one or more packages that you want to publish, you
    will need a place to store them. For this, you can use the Azure Artifacts offering.
    The following diagram shows the structural makeup of Azure Artifacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1ad6c02-14cf-41af-8b66-91ad6f853650.png)'
  prefs: []
  type: TYPE_IMG
- en: Within Azure Artifacts, you can create one or more feeds where you can store
    your packages. For each package, you can have multiple versions in a feed. The
    feed is the level on which you can set up authorizations for publishing packages.
    Within a feed, you can create one or more views that you can use for setting up
    authorizations for consuming packages. A specific version of any given package
    can be in more than one view at the same time. The following sections discuss
    all these concepts in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a feed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within Azure Artifacts, the feed is the location where your packages are stored.
    Each feed is a separate and fully isolated repository. To create a new feed, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, navigate to Azure Artifacts in the menu on the left and then click on
    the Create feed button (partially visible to access the view for creating a new
    feed):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5fdf7dfd-0736-4d9d-b6fa-40ab7c192601.png)'
  prefs: []
  type: TYPE_IMG
- en: Specify a name for the feed. It should not contain any spaces and preferably
    contain only letters and numbers, since it will become part of a URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, it is possible to specify the initial settings for visibility. This determines
    which users can view the feed. This will be discussed in more detail later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the use of upstream sources. This will also be covered in more detail
    later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A few seconds after selecting Create, your feed will be available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the feed is created, you can configure various settings such as hiding
    deleted packages, enabling package batches, and configuring retention policies.
    To learn how to do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: After the feed is created, access the settings for the feed by clicking on the
    gearbox in the top-right corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose Feed settings in the view shown in the following screenshot. In this
    view, you can configure a few more things:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8dea9422-70f3-41ee-8569-af19213a4a9a.png)'
  prefs: []
  type: TYPE_IMG
- en: Besides changing the name and adding a description, you can choose to hide deleted
    packages. When you do this, versions of a package that have been removed are no
    longer visible to administrators of the feed. Regular users are never able to
    view or use deleted packages, but this setting enables the same view logic as
    administrators.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another setting you can enable is that of package badges. A package badge is
    a visual element with the name of a package and the latest available version.
    If you enable this option, you can retrieve a URL for each package that will be
    a package badge for that package. This is useful for people who want to keep tabs
    on the latest version of a package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, you can configure a retention policy. Here, you can configure the automated
    removal when the number of versions of a package exceeds a certain threshold.
    While this helps you to save disk space and therefore costs, this can have the
    unintended effect of breaking downstream users of the feed. To put in a safeguard
    against this, you can prevent removing a package for *x* number of days after
    it has been downloaded for the last time. Next to that, keep in mind that any
    package version that is currently a member of a feed will not be removed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, click on the Save button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you have created and configured your feed, it is time to specify which
    users have access to the feed and what permissions they have. Let's learn how
    to do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Securing access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are four roles you can assign to a user or group, where the rights of
    each next role include the rights of the previous roles as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Readers** are able to list all packages in a feed and can download them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collaborators** are also able to use packages from upstream sources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contributors** can also publish their own packages and unlist and deprecate
    packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, **owners** have full control over the feed and can also change permissions,
    rename, or delete the feed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To change the permission of a user, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the Permissions view that you can see in the following screenshot. In
    this view, you can see a list of every user or group that has permissions assigned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1ad71676-4d9d-4e06-a88b-089278359736.png)'
  prefs: []
  type: TYPE_IMG
- en: To remove permissions, select the row and click on Delete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To add a new row, click on the add button. This will open the view you see to
    the right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As an alternative to adding users or groups as a reader on the whole feed, it
    is also possible to create one or more views on the feed and set access rights
    per view.
  prefs: []
  type: TYPE_NORMAL
- en: Managing views on a feed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A feed is a repository of packages that you can publish and download packages
    to and from. However, there are many cases where you do not want every uploaded
    package to be available for download. Often, you might find that you want to control
    who can use which versions of a package; for example, when you are implementing
    the continuous delivery of a shared library but want to share only stable versions
    with the rest of your organization.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, you can create views. A view is a subset of the package versions
    within a feed. When working with a view, as a consumer, it behaves just as if
    it were a feed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Views can be managed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate and click on Views; you should see something similar to the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f3c05b59-f7f6-4a4c-ad15-e8aee0c26329.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, you can see a list of all the current views and remove any views by selecting
    the row and clicking on Delete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding new views can be done using the add button, which opens the view you
    see to the right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can set permissions for reading from a view here as well. You can allow
    read access to your whole Azure DevOps organization, or specify specific users.
    Any user or group you add here will get reader permissions on this view only.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Editing permissions can be done by selecting any row and choosing Edit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once one or more views are available, packages can be promoted to a view for
    consumption through the view.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring upstream sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final thing that you can configure on your feed is the upstream sources.
    Azure Artifacts feeds give you a repository where you can publish your own packages
    for reuse from one or more locations.
  prefs: []
  type: TYPE_NORMAL
- en: However, you will probably also use packages that are publicly available on
    repositories such as `NuGet.org` or `npmjs.org`. In this case, you could use a
    combination of an Artifacts feed and `NuGet.org`, but you can also configure your
    feed to serve packages from `NuGet.org` as well. If you do this, `NuGet.org` is
    called an upstream source.
  prefs: []
  type: TYPE_NORMAL
- en: Along with simplicity, this gives you the added benefit of having one central
    location where you can see all the packages you are using in your solution(s).
    This enables you to quickly check which packages and versions you are using, which
    can be useful for compliance or security checks. Using the different permissions
    between the reader and the collaborator role, you can also configure which users
    are authorized to pull packages from `NuGet.org` to your feed, and which users
    are not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you can do this for any repository that is accessible over the internet
    and implements one of the protocols that Azure Artifacts supports. To configure
    upstream sources, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upstream sources can be configured after navigating to the following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6750b743-bd18-482b-b4ee-297c70e06f8e.png)'
  prefs: []
  type: TYPE_IMG
- en: Upstream sources are configured in the same way as permissions and views. You
    can delete upstream sources using the Delete button in the menu bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding upstream sources is done by clicking on the Add upstream source button,
    which opens the view on the right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A final thing to note about the use of upstream sources is that it is not possible
    to have the same version of a package published to your own feed if the same version
    of that package is already available in an upstream source.
  prefs: []
  type: TYPE_NORMAL
- en: This section discussed how to create and connect feeds. Now that these are in
    place, we will learn how to publish packages to those feeds in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you know how to create and manage feeds, it is time to learn how to
    publish packages to them. If you have experience of publishing packages to public
    feeds, you will see that publishing to Azure Artifacts works in precisely the
    same way. There are two ways in which you can publish packages to a feed:'
  prefs: []
  type: TYPE_NORMAL
- en: Manually from your own computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using Azure Pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both options are explored in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading packages by hand
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To upload packages by hand, the following steps need to be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you will have to retrieve the URL to your feed. To do this, click on
    Connect to feed for any of your feeds, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c7d5dae9-96c6-46f0-84fd-9615cbcb02a6.png)'
  prefs: []
  type: TYPE_IMG
- en: In the list on the left, select the protocol to use for accessing the feed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the correct view to use. Remember that for publishing packages, the full
    feed URL needs to be used since views are read-only.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After making the correct selections, copy the correct URL to the clipboard using
    the copy button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the following command to create a NuGet package from a regular `.csproj`
    file. If you do not have the `NuGet.exe` tool already available, you can download
    it using the link provided at the end of this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the final command for uploading the package to NuGet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: After executing the final command, the package will be published and become
    available in your feed.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing packages from a pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Uploading a package by hand is not a convenient solution if you need to do it
    more than once. In cases where you want to frequently generate and publish a new
    version of a library, you can use an Azure pipeline. As well as to the automation
    that this gives you, it is also a great way to introduce repeatability and reliability,
    since you can now use all of the benefits that pipelines offer you.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, you can find a possible build definition for creating an `npm`
    package and publishing that as follows. The sources for this build are from an
    open source Microsoft GitHub repository called `tfs-cli`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this pipeline, there are three usages of the built-in `npm` task:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first occurrence is an `npm install` command. This command is used for
    installing the dependencies for this package:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/d86d3e0c-40cc-41e1-99d7-dd316a0c7067.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The second occurrence is running a custom command, `build`. This command is
    defined in the source code itself using `package.json` and is used for transpiling
    the sources from TypeScript to JavaScript:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/35e773ee-03d3-4197-a282-f6e7a5392d48.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The final and third task is running the `npm publish` command to publish the
    generated package to an `npm` feed. In this instance, there is no external feed
    selected but a built-in target registry: the Azure Artifacts feed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/dcf02618-730b-44f8-b89a-b60306f80e43.png)'
  prefs: []
  type: TYPE_IMG
- en: After running this build, your package is available in your feed.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the things that is not done automatically using the tasks for uploading
    an `npm` package, or most types of packages for that matter, is managing the version
    number. Of course, there are many ways in which you can make sure your packages
    have proper versions, but a common approach is setting (part of) the version number
    during the build of a package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expanding on the `npm` package build that we demonstrated before, three changes
    can be made to the build definition:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the build number format for the build definition is updated to the following: `1.0$(Rev:.rrr)`.
    This guarantees that a unique number is automatically generated for every build.
    The `Ref:.rrr` variable will generate a number with three positions, leading with
    zeros if needed. The first time, this number will be `000`, and it will increase
    by one every time the rest of the build number is not changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Second, a task is added to replace the version number that is currently specified
    in the source control, using the `{#Build.BuildNumber#}` token. This is a reference
    to the build variable with the name `Build.BuildNumber`, which contains the build
    number that was specified in *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, a Replace Tokens task is added to the build before all other tasks.
    A possible configuration to replace the magic fixed-version number with the automatic
    version number for this task is shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b3b8b1b1-e1a5-4841-bd44-c64708fc484b.png)'
  prefs: []
  type: TYPE_IMG
- en: This task can be configured to replace the tokens in one or more target files
    (*1*). It will look for any series of characters starting with `{#` and ending
    in `#}`, take the text between these two markers, and then replace the whole text
    with the value of the corresponding variable.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, every package that is built using the definition will have
    a unique and ever-increasing patch version number. Whenever the major or minor
    version number needs to be updated, this can be done by updating the build number
    format.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to this approach, there are many tasks available from the
    extensions marketplace that can help with versioning, including more complex scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: This section discussed how to publish packages to a feed. With packages published
    to a feed, the next section will detail how these can be used with either Visual
    Studio or an Azure Pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Uploading packages to an Azure Artifacts feed or repository makes them available
    for use in many different scenarios. Two common scenarios are using your own packages
    with Visual Studio or from Azure Pipelines. Both scenarios will be detailed in
    the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming packages from Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have your shared libraries available as NuGet packages in an Azure
    Artifacts feed, you can start using them from Visual Studio. Before you can do
    this, you will have to register your feed in your Visual Studio instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, you first have to grab the URL of your feed. In order to do this,
    refer to the *Uploading packages by hand* section. Once you have your URL ready,
    go to manage NuGet files for your solution, as you would do normally. If you are
    not familiar with working with NuGet packages in Visual Studio, you can find this
    option in the solution explorer on the solution and project headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46845a03-ffff-4830-9481-2c2566c214e9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you are here, walk through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the small gearbox in the top-right corner to open the dialog where
    you can configure which NuGet feeds to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new feed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in both the name and the source of your own feed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After doing so, do not forget to click on Update; otherwise, your changes to
    the Name and Source fields will not be saved and there will be no warning prompting
    you that you have unsaved changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you have made these changes, you can now select your feed as the package
    source in the top right of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From here onward, it is possible to work with these packages from your own feed
    just as you do with packages from `NuGet.org`.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming packages from a pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you start using your packages in Visual Studio, it is very likely you will
    need them in Azure Pipelines as well. This is in order to perform CI/CD on the
    dependent application that uses your packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, this can be achieved with a small configuration change on your
    NuGet restore task, as shown in the following screenshot. The following screenshot
    relates to the NuGet restore task that can be used with both the Visual Studio
    build tasks and the .Net Core build tasks. Both contain the same interface and
    can be used in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81fed0eb-03ff-4db1-8001-2c0521612bb7.png)'
  prefs: []
  type: TYPE_IMG
- en: By default, only the radio button for using packages from NuGet is checked;
    so, to include packages from your own feeds as well, you need to select the correct
    feed in the drop-down list.
  prefs: []
  type: TYPE_NORMAL
- en: If you ever find the need to include packages from more than one feed, you will
    be forced to create one aggregator feed and use the other feeds as upstream sources
    for that aggregator feed.
  prefs: []
  type: TYPE_NORMAL
- en: This section covered how to consume component packages from Visual Studio. The
    next section will dive into working with universal packages for sharing general
    binary packages.
  prefs: []
  type: TYPE_NORMAL
- en: Working with universal packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous sections have all concentered on using Azure Artifacts as a means
    for redistributing application packages such as libraries or other shared components.
    However, there is also another important use of Azure Artifacts, which is using
    a feed for storing any type of binary package. These are called universal packages.
  prefs: []
  type: TYPE_NORMAL
- en: Since a universal packages feed can be used to store any type of package, this
    makes it a good choice for storing build artifacts if you are working with more
    than one CI/CD tool. In this case, you can use universal packages for storing
    and serving your build artifacts to and from whichever tool you are using at that
    time. This can be particularly useful since the built-in storage for classic build
    and release pipelines cannot be accessed by other tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use universal packages for staging your build artifacts in such a heterogeneous
    architecture, there are four basic operations you should understand: uploading
    and downloading universal packages from an Azure pipeline and uploading and downloading
    universal packages using the Azure CLI. The last one you can invoke from other
    tools.'
  prefs: []
  type: TYPE_NORMAL
- en: Uploading and downloading universal packages from Azure Pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Uploading build artifacts to a universal packages feed works in a similar way
    as uploading a regular build artifact. There are two changes you need to consider.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, you have to use another task for performing the upload. Instead of
    using the *publish build artifact* or *publish pipeline artifact* tasks, you have
    to use the task named Universal Packages. When using this task, you can still
    give a name to the artifact and specify a location on the filesystem of the build
    agent to upload it from. Next, you can specify a target feed and a version to
    use. This version can be either automatically incremented whenever a new package
    is uploaded or be specified using a build variable.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, you have to consider the fact that the uploaded package is not associated
    one-to-one with the build that produced it—as it is with regular build or pipeline
    artifacts. This means that no matter where you are using the package that has
    been uploaded, you have to find another way to find the correct version to download.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform the actual download, you can use the Universal Packages task again,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da1afaf8-384a-4b16-9d05-772895c51fab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Refer to the screenshot and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: After adding the task, you can toggle it between upload and download.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also specify a directory that is uploaded as the artifact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Or you can specify where the artifact should be downloaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Furthermore, the name of the feed needs to be specified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, specify the name of the package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify the version to be either upload or download.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that you can also use feeds that are not part of your own organization
    by choosing to use another feed at step *5*. If you do so, you need to create
    a service endpoint for reaching that feed.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading and downloading universal packages using the Azure CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you want to work with universal packages from a product other than Azure
    Pipelines, you will have to use the Azure CLI. To do this, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you have to do to work with universal packages using the Azure
    CLI is to install the CLI itself. The link to the CLI can be found at the end
    of this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, it is time to install the extension for Azure DevOps. This can be done
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After making the extension for Azure DevOps available, you have to log in using
    the account that you also use to work within the Azure DevOps UI. You can log
    in by giving the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once logged in, you can upload a file as an artifact using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To download a particular version of an artifact again, you can use the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Using the CLI and these commands, you can use Azure Artifacts as a means for
    sharing build artifacts between multiple tools. When working with a number of
    tools on the same project, Universal Packages are a great tool for moving binaries
    around.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, other tools available for package management will be explored.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring other tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many other tools available for doing binary management. Three commonly
    used products are MyGet, Artifactory, and **Azure Container Registry** (**ACR**).
    The features they deliver do overlap, but they also have specific points at which
    they excel.
  prefs: []
  type: TYPE_NORMAL
- en: MyGet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MyGet is an alternative location for hosting your NuGet packages. MyGet allows
    you to create both public and private feeds that are managed by you. MyGet also
    supports defining upstream sources and delivers built-in dependency scanning to
    give you continuous feedback on the level of security of your dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Since MyGet is an implementation of the NuGet protocol, you can publish and
    use packages using the default NuGet tasks from Azure Pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Artifactory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Artifactory, a product by JFrog, is another tool that you can use for hosting
    your package feeds. Artifactory is originally an on-premises product, but it is
    now also available as a SaaS offering. Just like Azure Artifacts, it supports
    multiple protocols for interacting with package feeds. At the time of writing,
    Artifactory supports more repository protocols than Azure Artifacts. Examples
    of this include PHP Composer and **Red Hat Package Manager** (**RPM**).
  prefs: []
  type: TYPE_NORMAL
- en: JFrog has published an Azure Pipelines extension for downloading and uploading
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Container Registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another type of storage for reusable packages is ACR. ACR is designed specifically
    for container images and has an understanding of the layered buildup of these
    images. This allows it to receive only partial uploads when a new version of an
    image becomes available if not all of the layers have changed. This makes ACR
    a very good location for storing container images. Uploads will be faster and
    ACR storage is cheaper than Azure Artifacts storage. This is a big benefit since
    container images can be large.
  prefs: []
  type: TYPE_NORMAL
- en: You can integrate with ACR from Azure Pipelines using the Docker integration
    extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how to identify shared components in your solutions:
    pieces of code that appear not only in multiple locations but are also logical
    units for reuse. You learned how to use Azure Artifacts feeds for hosting packages
    that contain these libraries. Furthermore, you learned how to use these hosted
    packages to build dependent solutions using both Visual Studio and Azure Pipelines.
    You also learned about using universal packages to share build artifacts between
    Azure Pipelines and other tools that you might use for CI/CD.'
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, you will now be able to identify shared components in your
    solution(s). Once you have identified such a component, you will also be able
    to isolate it in source control, build it, and publish it to an artifact feed.
    From here, you can distribute it to one or more consuming solutions. Finally,
    you are now also capable of using Artifact feeds for sharing build artifacts between
    different CI/CD products.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about infrastructure and configuration as
    code. This is one of the fundamental DevOps practices that allows you to have
    your infrastructure definition in source control and use that as part of your
    release pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the Appendix:'
  prefs: []
  type: TYPE_NORMAL
- en: 'True or false: Any version of a package can be deployed to only one view within
    a feed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: Pipeline artifacts can be used for sharing build outcomes (packages)
    from Azure DevOps to other products.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: Azure Artifact feeds with universal packages can be used for
    sharing build outcomes (packages) from Azure DevOps to other products.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is needed to enable building a solution that uses packages
    from an Azure Artifacts feed in Visual Studio? (You can select more than one option.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding the full package URL to your project dependencies, instead of only the
    package name
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Having at least *reader* access to the feed or one of the views in the feed
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Having at least *consumer* access to the feed
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring the location of the feed as a package source for Visual Studio
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What can be the motivators for splitting a solution into multiple parts that
    are separated by Azure Artifacts feeds?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exercises for practicing with Azure DevOps Artifacts can be found at [https://docs.microsoft.com/en-us/learn/modules/manage-build-dependencies/](https://docs.microsoft.com/en-us/learn/modules/manage-build-dependencies/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find and download `NuGet.exe` from [https://www.nuget.org/downloads](https://www.nuget.org/downloads).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information on downloading and installing the Azure CLI can be found at [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about MyGet is available at [https://www.myget.org/](https://www.myget.org/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about JFrog Artifactory is available at [https://jfrog.com/artifactory/](https://jfrog.com/artifactory/),
    and the extension for Azure Pipelines can be found at [https://marketplace.visualstudio.com/items?itemName=JFrog.jfrog-artifactory-vsts-extension](https://marketplace.visualstudio.com/items?itemName=JFrog.jfrog-artifactory-vsts-extension).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about ACR is available at [https://azure.microsoft.com/en-in/services/container-registry/](https://azure.microsoft.com/en-in/services/container-registry/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the Docker extensions for Azure Pipelines at [https://marketplace.visualstudio.com/items?itemName=ms-vscs-rm.docker](https://marketplace.visualstudio.com/items?itemName=ms-vscs-rm.docker).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
