<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Infrastructure and Configuration as Code</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, the focus was on storing and building application code and releasing the created binaries. You learned how to create a pipeline, from source control to a target environment for the automated, repeatable deployment of your applications.</p>
<p>In this chapter, you will learn how to apply the same principles to the infrastructure that your application runs on and the runtime configuration of your application. Doing so will help you to further increase the speed at which changes can be delivered to production, increasing the flow of value to your end users.</p>
<p>This chapter will start off by explaining the value of having everything, infrastructure and configuration included, as code. Next, it continues by explaining ARM templates. The syntax will be explained, as well as how to deploy ARM templates. Then, it proceeds to explain the Azure Automation offering, available in the Azure Cloud. Azure Automation can be used for running scripts on a schedule or for loading and applying PowerShell DSC modules. Next up is managing application settings for PaaS offerings, such as Azure App Service. Finally, it concludes by discussing several other tools that have similar capabilities.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Having everything as code</li>
<li>Working with ARM templates</li>
<li>Deploying ARM templates</li>
<li>Reverse engineering a template</li>
<li>Using Azure Automation</li>
<li>Managing application settings</li>
<li>Other tools</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To experiment with one or more of the technologies described in this chapter, one or more of the following may be required:</p>
<ul>
<li>An Azure subscription, for executing ARM templates and running Azure Automation</li>
<li>PowerShell with the Azure PowerShell modules, for executing ARM templates, available from <a href="https://docs.microsoft.com/en-us/powershell/azure/install-az-ps">https://docs.microsoft.com/en-us/powershell/azure/install-az-ps</a></li>
<li>The Azure CLI, for executing ARM templates, available from <a href="https://docs.microsoft.com/en-us/powershell/azure/install-az-ps">https://docs.microsoft.com/en-us/powershell/azure/install-az-ps</a></li>
<li>One or more virtual machines for experimenting with the different tools discussed in this chapter</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Having everything as code</h1>
                </header>
            
            <article>
                
<p>If you have been responsible for creating and maintaining application infrastructure and configuration in the past, you have most likely experienced what is called <strong>configuration drift</strong><em>.</em> Configuration drift is the name for the phenomenon where the configuration between servers in acceptance and the production environment differs. Or, even worse, when having multiple servers in the production environment, it might be the case that the configuration of these is not always the same.</p>
<p>The most common cause of configuration drift is manual change. When making changes manually, maybe under the pressure of a production issue, there is always the risk that you apply different settings to different servers or hosts. And if you ever need to scale out and add another server to your production environment, the chance of that server taking on the same configuration of all already existing servers is very slim.</p>
<p>With <strong>Infrastructure as Code</strong> (<strong>IaC</strong>) and <strong>Configuration as Code</strong> (<strong>CaC</strong>), you no longer make changes to application configuration and infrastructure by hand, but only through automation. The first step to do this is specifying the desired state of configuration and infrastructure. The desired state is then fed into configuration management tooling that enforces this configuration on your infrastructure. Specifying only the desired state is called a <em>declarative</em> approach, which differs from an <em>imperative</em> approach, where you specify all of the steps that need to be taken.</p>
<p>These tools are often also capable of checking the current state of your infrastructure and configuration on a regular interval and reapplying your desired state if any deviation is detected. This is possible due to the declarative approach. This makes applying configuration an idempotent operation. An operation is idempotent if it can be repeated one or more times, while the outcome will remain the same.</p>
<p>When adopting IaC and CaC, you can even go so far as to recreate the complete infrastructure before deploying an application, deploy the application on that new infrastructure, and then disregard the old infrastructure after switching to the new deployment. This is an extreme form of immutable servers. The added benefit of this approach is that you are now guaranteed that there will be no traces from any configuration or binaries from the previous deployment.</p>
<p>In the following sections, you will learn about different IaC technologies and how to use them. It is important to understand that they are complementary and are often used together. For example, ARM templates can be used to create virtual machines in Azure and, once that is done, PowerShell DSC or Ansible can be used to configure those virtual machines.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with ARM templates</h1>
                </header>
            
            <article>
                
<p>When working on the Azure platform, infrastructure is described using <strong>Azure Resource Manager</strong> (<strong>ARM</strong>) templates. ARM templates are written in JSON and a skeleton template looks as follows:</p>
<pre>{<br/>  "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",<br/>  "contentVersion": "1.0.0.0",<br/>  "parameters": {<br/>  },<br/>  "variables": {<br/>  },<br/>  "resources": [<br/>  ],<br/>  "outputs": {<br/>  }<br/>}</pre>
<p>The template itself is, at the highest level, a JSON object. There is a mandatory property, <kbd>$schema</kbd>, for which the shown value is also mandatory. The <kbd>contentVersion</kbd> property is also mandatory and can be specified to version the contents. This version can be used by the author to version the template if necessary.</p>
<p>The rest of this chapter will discuss the different parts that make up ARM templates in more detail. There is also an online reference available, to which a link is added at the end of this chapter. A link to the formal, detailed breakdown of the structure and syntax of ARM templates is also added at the end of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parameters</h1>
                </header>
            
            <article>
                
<p>Every template has to start with a parameters section. This section takes the shape of a JSON object, which can be empty but cannot be left out. The use of this section is to declare one or more parameters that can be specified by the caller of the ARM template, before deploying it. A common reason for using the parameters section is to use the same template for both the test and production environment, but varying the names of resources between the two. An example parameters section might look like this:</p>
<pre>{<br/>  “appServiceName”: {<br/>    “type”: “string”,<br/>    “metadata”: {<br/>      “description”: “a free to choose text”<br/>    }<br/>}</pre>
<p>For every parameter, a new key is specified with the parameter's name. The value is an object. This object has one mandatory key, <kbd>type</kbd>. The allowed values for type are <kbd>string</kbd>, <kbd>int</kbd>, <kbd>bool</kbd>, <kbd>object</kbd>, <kbd>array</kbd>, <kbd>secureString</kbd>, and <kbd>secureObject</kbd>. The <kbd>secureString</kbd> and <kbd>secureObject</kbd> variations can be used to make sure that the runtime values of these parameters are scrubbed from any log and output. They are intended to hold passwords, keys, or other secrets.</p>
<p>The metadata object, with the <kbd>description</kbd> key, is optional and can be used to add a description to the parameter for future reference.</p>
<p>Other properties that can be specified on a parameter object are the following:</p>
<ul>
<li><kbd>minValue</kbd> and <kbd>maxValue</kbd> for specifying bounds on an integer value</li>
<li><kbd>minLength</kbd> and <kbd>maxLength</kbd> for specifying bounds on the length of a string value</li>
<li><kbd>defaultValue</kbd> for specifying a default value that will be used if no value is specified when applying the template</li>
<li><kbd>allowedValues</kbd> for specifying an array of allowed values, limiting valid inputs</li>
</ul>
<p>Next, let's understand what parameter files<span> </span><span>are</span><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parameter files</h1>
                </header>
            
            <article>
                
<p>One way for specifying the parameter values when deploying a template is through a variable file. Often, a single template is accompanied by more than one parameter file, for example, one for test and one for production. The JSON for a parameter file appears as follows:</p>
<pre>{<br/>  "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",<br/>  "contentVersion": "1.0.0.0",<br/>  "parameters": {<br/>    "exampleParameter": {<br/>      "value": "exampleValue"<br/>    }<br/>  }<br/>}</pre>
<p>Just like an ARM template, every parameter file is a JSON object with mandatory <kbd>$schema</kbd> and <kbd>contentVersion</kbd> properties. The third property parameter is used to specify one or more parameter values. For each parameter, specify its name as the key and an object as the value. This object can hold the <kbd>value</kbd> <span>key</span><span> </span><span>for providing the actual value of the parameter.</span></p>
<p>While very valuable for specifying names for resources, scaling options, and other things that have to vary between environments, this solution is not useful for secrets. Keys, passwords, and other secrets should not be stored as plaintext in source control in a parameter file. For secrets, another notation <span>is</span><span> </span><span>available:</span></p>
<pre>{<br/>  "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",<br/>  "contentVersion": "1.0.0.0",<br/>  "parameters": {<br/>    "exampleParameter": {<br/>      "reference": {<br/>        “keyvault”: {<br/>          "id": "/subscriptions/…/Microsoft.KeyVault/vaults/&lt;vaultname&gt;"<br/>        },<br/>        “secretName”: “myKeyVaultSecret”<br/>      }<br/>    }<br/>  }<br/>}</pre>
<p>With this notation, instead of specifying the value directly, there is a pointer to a location in an Azure key vault where the correct value is stored. When deploying the template, this secret is (within Azure!) taken from the key vault and used in deployment. This is allowed only if the user or service starting the deployment has either an owner or contributor role in relation to the <span>key vault</span> and the <span>key vault</span> is enabled for template deployment.</p>
<div class="packt_infobox">Strictly speaking, any role that includes the <kbd>Microsoft.KeyVault/vaults/deploy/action</kbd> permission will work. By default, these are the owner and contributor roles, but you can create custom roles that include this action as well.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Variables</h1>
                </header>
            
            <article>
                
<p>The variables section is used to specify one or more values that will be used throughout the template. A common approach is building the names of all resources in the variables section, based on a single parameter called <kbd>environmentName</kbd>. This ensures that resources will have the same name between environments. Variables are also used to specify values that cannot be specified from outside the template, but should be recognized as configurable. An example might look like this:</p>
<pre>{<br/>  "appServicePlanType": "B1",<br/>  "appServiceName": "[concat('myAppService-', parameters('environmentName'))]"<br/>}</pre>
<p>Please note that the example for <kbd>appServiceName</kbd> contains functions that are discussed in detail in a later section called <em>Functions.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resources</h1>
                </header>
            
            <article>
                
<p>The third section in any ARM template is the resources section. This is the main part of the template, where all of the resources to be created are specified. This section is the only one that is not an object, but an array. Within that array, one or more objects of the following form are specified:</p>
<pre>{<br/>    "type": "Microsoft.Sql/servers",<br/>    "apiVersion": "2015-05-01-preview",<br/>    "name": "mySqlServer",<br/>    "location": "West Europe",<br/>    "properties": {<br/>        "administratorLogin": "myUsername",<br/>        "administratorLoginPassword": "myPassword",<br/>        "version": "12.0"<br/>    }<br/>}</pre>
<p>Each resource is specified in the form of an object. The first four properties are mandatory for every type of resource:</p>
<ul>
<li>The type of the resource to be created or updated needs to be specified: This takes the form of the name of <kbd>resourceprovider</kbd> followed by a slash and the name of a resource type that belongs to that <kbd>resourceprovider</kbd>.</li>
<li>The version of the API to use for this resource: A list of supported API versions can be retrieved from the reference.</li>
<li>The name for the resource: Every resource type has its own rules for determining what a valid name is. These can also be found in the reference.</li>
<li>The Azure Region where the resource is to be created: This must be a valid Azure Region.</li>
</ul>
<p>All other properties on the object vary from resource type to resource type and are all specified in the resource.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dependent resources</h1>
                </header>
            
            <article>
                
<p>A special type of resource is the dependent resource. For example, SQL databases are hosted on a SQL Server and Service Bus Topics are located within a Service Bus namespace. For a nested resource type, the type and name reflect this nesting:</p>
<pre class="mce-root">{<br/>    "apiVersion": "2017-04-01",<br/>    "name": "myNamespaceName/myTopicName",<br/>    "type": "Microsoft.ServiceBus/namespaces/topics",<br/>    "dependsOn": [<br/>        "Microsoft.ServiceBus/namespaces/myNamespaceName"<br/>    ]<br/>}</pre>
<p>Next to nesting the type and the name, the extra property, <kbd>dependsOn</kbd>, is also mandatory to specify that this nested resource can only be created after the containing resource exists. A location property is not necessary since this will be inherited from the containing resource.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Nested templates</h1>
                </header>
            
            <article>
                
<p>A second special type of resource is template deployment. This way, one template can trigger the deployment of another. An example of defining a template deployment as a resource in a template looks as follows:</p>
<pre>{<br/>    "type": "Microsoft.Resources/deployments",<br/>    "apiVersion": "2018-05-01",<br/>    "name": "linkedTemplate",<br/>    "properties": {<br/>        "mode": "Incremental",<br/>        "templateLink": {<br/>            "uri":"https://.../myLinkedTemplate.json"<br/>        },<br/>        "parametersLink": {<br/>            "uri":"https://.../myParameters.json"<br/>        }<br/>    }<br/>}</pre>
<p>The locations of the template and parameter file can be specified using both HTTP and HTTPS, but have to be publicly accessible locations. As an alternative, a single property template can be specified. This should then contain a whole template as a JSON object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Outputs</h1>
                </header>
            
            <article>
                
<p>The fourth and final section of a template is the outputs section. Here are the keys returned to the caller of the template. The caller can use these values to start another task or script and use one or more of the values created or used by the template.</p>
<p>The main use for this is to prevent hardcoding names in downstream automation. The outputs section is a JSON object of the following format:</p>
<pre>{<br/>    "outputName":<br/>   {<br/>        "type": "string",<br/>        "value": "myValue"<br/>    }<br/>}</pre>
<p><em> </em>When specifying outputs, the same types can be used as for parameters. Of course, it does not make much sense hardcoding the values, so functions are used to retrieve values from parameters, variables, or even created resources.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functions</h1>
                </header>
            
            <article>
                
<p>Functions are used to allow for dynamic evaluation of properties in ARM templates. Calling functions uses a notation very similar to that of many programming languages: <kbd>functionName(arg1, arg2, …)</kbd> functions can return either a value such as <kbd>string</kbd> or <kbd>int</kbd> or an object or array. When an object is returned, any property can be accessed using the <kbd>.propertyName</kbd><span> </span><span>notation</span><em>.</em> <span>Accessing elements in an array can be done using</span> <kbd>[position]</kbd><span>. To indicate which parts of a string should be evaluated as a function, they can be enclosed in brackets:</span></p>
<pre>"myVariable": "[concat('myAppService-', parameters('environmentName'))]"</pre>
<p>The preceding example shows two example functions. First, the <kbd>concat</kbd> function is called to concatenate two string values. One is hardcoded and the other one is the result of a second function call to retrieve the value of a template parameter.</p>
<p>There are a fair number of functions available. They can be used for string manipulation, for retrieving details about the current subscription, resource group, or Azure Active Directory tenant, or for getting resource details.</p>
<p>Functions can also be used to retrieve account keys or other secrets. This is often done to automatically insert keys directly from the service that exposes the key to application settings or a key vault. This completely eliminates the need for the manual transfer of secrets.</p>
<p class="mce-root">Well, so far, we have learned the different parts that make up an ARM template, which you should be able to write on your own. Now it's time to learn how we can <span>actually</span><span> </span><span>deploy them with the help of various tools.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying ARM templates</h1>
                </header>
            
            <article>
                
<p>Once an ARM template and its accompanying parameter files are written, they can be applied to an Azure environment. There are PowerShell Cmdlet and Azure CLI commands available for applying an ARM template from a scripting environment. When ARM templates are used for the infrastructure of an application, Azure Pipelines can be used for deploying not only code but also ARM templates.</p>
<p>No matter which approach is used for deployment, all of them will have a <em>deployment mode</em>. This can be either <em>incremental</em> or <em>complete</em>. In incremental mode, all resources specified in the template will be created in Azure or their properties will be updated if the resource already exists. In complete mode, all resources that are not specified in the template and already exist in Azure will also be removed. The default deployment mode is incremental.</p>
<p>In the next sections, several tools for executing deployments are discussed, starting with PowerShell.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PowerShell</h1>
                </header>
            
            <article>
                
<p>For local development and testing of ARM templates on a local machine, Powershell has a quick command to apply an ARM template to a resource group:</p>
<pre>New-AzResourceGroupDeployment -ResourceGroupName myResourceGroup -TemplateFile "c:\my\template.json" ` -TemplateParameterFile "c:\my\parameters.json"</pre>
<p>The preceding command will pick up the specified template and parameter file and apply it to the specified resource group. This command assumes that the current session has already been logged in to Azure.</p>
<p>There are a few variations on the command available:</p>
<ul>
<li>A parameter called <kbd>-Mode</kbd> with a <kbd>Complete</kbd> or <kbd>Incremental</kbd> value is available. This can be used to specify <kbd>deploymentmode</kbd>.</li>
<li>If no parameter file is specified and the template requires parameters, the cmdlet will prompt for these values on the command line.</li>
<li>As an alternative, the <kbd>-TemplateUri</kbd> and <kbd>-TemplateParametersUri</kbd> options can be used to specify the location of the template and parameters to be retrieved from another location.</li>
</ul>
<p>The next tool that we'll look into is the Azure CLI.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Azure CLI</h1>
                </header>
            
            <article>
                
<p>The Azure CLI is another way of deploying ARM templates from the command line. The benefit of the CLI is that it is completely cross-platform and runs on Windows, macOS, and Linux. The Azure CLI command for deploying an ARM template is as follows:</p>
<pre>az group deployment create –resource-group myResourceGroup –template-file "c:\my\template.json" –parameters "c:\my\parameters.json"</pre>
<p>All other options that are available in PowerShell are also available in the CLI.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Azure Pipelines</h1>
                </header>
            
            <article>
                
<p>A third mechanism for deploying ARM templates is from an Azure pipeline. This is particularly useful for deploying the infrastructure and configuration of an application, together with the binaries. To deploy an ARM template deployment from a pipeline, at least one service connection of the Azure Resource Manager needs to be configured. After doing this, a pipeline can be configured as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1048 image-border" src="assets/42359bf4-5736-4d18-9c5a-ae9f83e6bd0a.png" style="width:62.75em;height:41.83em;"/></p>
<p>In this example, there are two deployments of an ARM template, surrounding the deployment of the application code. The first deployment is of the incremental<span> </span><span>type</span><span>, while the second deployment is of the complete</span><span> </span><span>type</span><span>. Using this approach, the first deployment will create all new infrastructure needed by the new version of the application. </span><span>This deployment is done in incremental mode, so infrastructure that is no longer present in the template but still in use by the currently deployed version of the application will not yet be removed. The second deployment will take care of removing these elements after the new version of the code is deployed.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reverse engineering a template</h1>
                </header>
            
            <article>
                
<p>Writing an ARM template from scratch can be a tedious and time-consuming task. Luckily, there are two approaches available to generate an ARM template from existing infrastructure:</p>
<ul>
<li>Using the <span class="packt_screen">Export template</span></li>
<li>Using the <span class="packt_screen">Resource Explorer</span></li>
</ul>
<p>Let's discuss both of these in the upcoming subsections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the Export template </h1>
                </header>
            
            <article>
                
<p>The first approach is using the <span class="packt_screen">Export template</span> option that can be found on every resource and resource group in the Azure portal. This will generate an ARM template of the current state of the resource (group), as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1049 image-border" src="assets/aeb90981-6db5-4157-8cc0-73b0343b28c5.png" style="width:98.67em;height:61.75em;"/></p>
<p>Please note that not every service currently supports reverse engineering an ARM template using this approach. For any service not supported, there will be a warning at the top of the screen. To work around this limitation <span>for retrieving the JSON template for an individual resource</span>, there is another approach, which is our next topic of discussion.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the Resource Explorer </h1>
                </header>
            
            <article>
                
<p>For retrieving the JSON template for an individual resource, we can use the <span class="packt_screen">Resource Explorer</span><em>.</em> The Resource Explorer is shown here and can be found in the Azure portal by using the menu (<em>1</em>):</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1050 image-border" src="assets/3d56d466-61da-447d-9993-0da540143b9b.png" style="width:124.33em;height:69.83em;"/></p>
<p>After opening the resource explorer, two new panes open up. The left pane can be used to navigate through subscriptions and drill down into the resource groups, down to the individual resources. For every element that is selected, the corresponding JSON will be displayed on the right. In the preceding example, the JSON for a hard disk is shown. This JSON is the same as the JSON that can be used in the resources array of an ARM template.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Subscription-level templates</h1>
                </header>
            
            <article>
                
<p>The discussion of ARM templates up to this point has all been about ARM templates for a resource group deployment. A template describes one or more resources that are deployed to a resource group. Additionally, there are also subscription-level templates. An example ARM template for a resource group is shown as follows:</p>
<pre>{<br/>    "$schema": "https://schema.management.azure.com/schemas/2018-05-01<br/>                                                ... /subscriptionDeploymentTemplate.json#",<br/>    "contentVersion": "1.0.0.1",<br/>    "parameters": { },<br/>    "variables": { },<br/>    "resources": [<br/>        {<br/>            "type": "Microsoft.Resources/resourceGroups",<br/>            "apiVersion": "2018-05-01",<br/>            "location": "West Europe",<br/>            "name": "myResourceGroup",<br/>            "properties": {}<br/>        }<br/>    ],<br/>    "outputs": {}<br/>}</pre>
<p>The format for a subscription template is completely the same as that for a resource group. The differences are <kbd>$schema</kbd>, which points to another schema location, and the types of resources that are supported. Subscription templates do not support the creation of resources directly, and support only the creation of resource groups, the initiation of template deployments, creating and assigning Azure Policies, and the creation of role assignments.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Azure Blueprints</h1>
                </header>
            
            <article>
                
<p>Next to subscription level-templates, there is also another offering available: Azure Blueprints. Blueprints can be used to describe the desired state of an Azure subscription and apply that to an existing subscription.</p>
<p>All of the things that can be done using a blueprint can nowadays also be done using an ARM template. However, the other way around is not true. Azure Blueprints only support the following constructs, which are called artifacts:</p>
<ul>
<li>Policy assignments</li>
<li>Role (RBAC) assignments</li>
<li>Resource group creation</li>
<li>Nested ARM templates at the subscription or resource group level</li>
</ul>
<p>These are all of the elements that are needed to build the default layout, or a blueprint, for Azure subscriptions.</p>
<p>There are a number of key differences between blueprints and ARM templates:</p>
<ul>
<li>Blueprints are stored within Azure itself. A blueprint is a resource you can create and navigate to in the portal. The authoring experience is also in the portal, not in text files on a local computer.</li>
<li>The relation between a subscription and the blueprint that was used to create it remains, also after the deployment completes.</li>
<li>With the assignment of a blueprint to a subscription, it is possible to mark the assignment as locked. If this is done, all of the resources deployed through the blueprint cannot be deleted or edited as long as the blueprint is assigned—not even owners of the subscription that it is applied to.</li>
<li>There are many built-in blueprints available that can be used to implement controls from well-known standards such as ISO, NIST, or HIPAA.</li>
</ul>
<p>The general recommendation is to use blueprints whenever creating many new subscriptions, which should follow the same layout, and use ARM templates in all other cases. Blueprints are still in preview at the time of writing</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">November 2019 updates</h1>
                </header>
            
            <article>
                
<p>Since November 2019, ARM templates no longer have to be pure JSON. Several other constructs are now allowed to make working with ARM templates easier.</p>
<p>To comment the rest of a line, <kbd>//</kbd> is used, or to comment a block, the <kbd>/* */</kbd> notation is used. This makes the following snippets both valid as part of an ARM template:</p>
<pre>{<br/>  “appServiceName”: {<br/>    // this is a single line comment<br/>    “type”: “string” <br/>      /*<br/>       This is a multi-line comment<br/>     */<br/>    }<em> <br/></em><em>}</em></pre>
<p>Another deviation from JSON is that ARM templates allow for a multi-line string. When using these from the Azure CLI, this has to be enabled by specifying the<span> </span><kbd>--handle-extended-json-format</kbd><span> </span>switch. To use these and other new features, a new JSON schema has to be referenced from the template. This schema is<span> </span><a href="https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#">https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#</a>.</p>
<p>Also, a new command has been introduced to show what changes would be made if a template wer be applied. This command is still in preview and called<span> </span><kbd>New-AzDeploymentWhatIf</kbd>. A link to the documentation is included at the end of this chapter.</p>
<p><span>While ARM templates are the preferred approach in Azure for managing infrastructure, there are scenarios where it might not fit. In these cases, Azure Automation can be an alternative. Azure Automation is discussed in the next section.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Azure Automation</h1>
                </header>
            
            <article>
                
<p>Azure Automation is a service in Azure that is designed to help users to create, manage, deploy, and maintain their Azure resources. Azure Automation contains several concepts that remove some of the complexities and low-level details from these actions. Azure Automation allows for the formulation of workflows in the form of runbooks<em>.</em> These runbooks can be executed against Azure resources on behalf of the user.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Automation account resources</h1>
                </header>
            
            <article>
                
<p>Within an Azure Automation account, there are several resources that make this more than just a scripting engine. These resources are shared on the level of the automation account and can hence be reused within multiple runbooks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Run As account</h1>
                </header>
            
            <article>
                
<p>The first of these constructs is the <em>Run As</em> account. This account is a service principal that will be created in the Azure Active Directory that the Azure subscription containing the automation account is linked to. The credentials to authenticate as this service principal are securely stored within the automation account. These credentials are non-retrievable. The service principal is also added as a contributor to the Azure subscription. As a result, runbooks can now be set up to execute using this account.</p>
<p>Run As accounts can be automatically created when creating the Automation account.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Schedules</h1>
                </header>
            
            <article>
                
<p>A common way of automating workflows is scheduling them to run on a specific date and time or on a fixed interval. Instead of specifying a schedule for every workflow, shared schedules can be created and reused in runbooks. To create a new schedule, first, open the list of all schedules. After that, a new  schedule can be added, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1051 image-border" src="assets/a728d578-1ff0-47b6-aa70-32ecbd5baf63.png" style="width:87.25em;height:68.50em;"/></p>
<p>A schedule has a name and a description. These values are for the users interacting with the schedule only. Next, a starting date and time can be configured, along with an optional recurrence interval, and, if a recurrence interval is specified, an expiration date and time. Once the schedule is created, it can be used for a runbook.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modules</h1>
                </header>
            
            <article>
                
<p>The runbooks that are used in Azure Automation are written in PowerShell. PowerShell has a very rich ecosystem of modules with predefined functionalities that can be used. For using PowerShell modules from an automation account, only modules that have been uploaded to the modules section can be used. One major benefit of this is that it is possible to fix the version of a module to use. This guarantees that scripts will keep working and not break in case of updates to dependencies.</p>
<p>The PowerShell modules for interacting with Azure are by default installed into every automation account. Furthermore, more modules can be added, and existing modules can be upgraded or removed by administrators.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Variables</h1>
                </header>
            
            <article>
                
<p>Within runbooks, a lot of variables might come into play; the names of resource groups, virtual machines, start up or shutdown times, and so on. Hardcoding these values inside a script is not good practice, but storing them together with a runbook also has downsides. For example, in the case that there are three runbooks for the same virtual machine, this would mean that a number of variable values (for example, resource group name and virtual machine name) would be repeated at least three times. To prevent this, it is possible to store variable values at the automation account level, from where they can be reused throughout every runbook that is executed in that account.</p>
<p>Once a variable is set, it can be accessed from a runbook using the following command:</p>
<pre>$exampleVar = Get-AutomationVariable -Name 'ExampleVar'</pre>
<p>In addition to reading and using variables inside a runbook, they can also be updated from within a runbook:</p>
<pre>Set-AutomationVariable -name 'ExampleVar' -value 'ExampleValue'</pre>
<p>While a very powerful feature, updating variables from within runbooks can have unexpected consequences. If a variable value that is used in multiple runbooks gets updated by one of them, this might break the other runbooks. Keeping track of which variables are read-only and which are written to as well is important.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Credentials</h1>
                </header>
            
            <article>
                
<p>A special type of variable is the credential. Credentials contain not one but two values: a username and a password. Credentials are treated as secrets everywhere they are used. This means that they will not appear in logs and that they have to be retrieved using a specific PowerShell syntax:</p>
<pre>$myCredential = Get-AutomationPSCredential -Name 'MyCredential'</pre>
<p>After executing this command, the <kbd>myCredential</kbd> object can be used to retrieve both the username and password.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Connections</h1>
                </header>
            
            <article>
                
<p>It is a very common scenario to have to connect to one or more external services from within a runbook. A common example is the Azure Resource Manager that is used to manage all resources within Azure. To avoid having to store a series of variables and build the corresponding connection in a runbook, automation accounts allow for the creation beforehand of one or more connections.</p>
<div class="packt_tip">In most scenarios, it is not necessary to create connections manually as they are provided along with a Run As account.</div>
<p><span>Once all of the shared resources are in place, it is time to start writing one or more runbooks, which is our next topic of discussion.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Runbooks</h1>
                </header>
            
            <article>
                
<p>A number of types of runbooks are supported: PowerShell, Python 2, and graphical. The first two allow for writing scripts to be written in the specified language. Graphical runbooks allow for composing a runbook from all uploaded PowerShell modules, assets, and existing runbooks using drag and drop.</p>
<p>In addition to these three basic types of runbooks, there are PowerShell workflow and graphical workflow types available. The difference between a regular runbook and a workflow runbook is that workflow runbooks also support parallelism. Another benefit of PowerShell workflow is that it supports the use of checkpoints, which allow a script to be resumed if it encounters an exception mid-execution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Runbook execution</h1>
                </header>
            
            <article>
                
<p>Once the runbook is written, there are a number of ways to execute it:</p>
<ul>
<li><strong>Manually</strong>: Any runbook can be run at any time by opening it in the Azure portal and pressing <span class="packt_screen">Start</span>. Of course, these operations are also available using PowerShell or the Azure CLI.</li>
<li><strong>By attaching a Webhook</strong>: Once a runbook is published, one or more Webhooks can be generated for executing the runbook. Each Webhook can be enabled or disabled or given an expiration date. These tools allow a new Webhook to be generated for every user of the runbook and fine-grained control to be initiated  if ever future access should not be accorded to a particular user.</li>
<li><strong>On a schedule</strong>: Published runbooks can be attached to one or more of the shared schedules. Being able to attach to multiple schedules means that it is easy to pre-create a series of schedules for typical reoccurrences, such as hourly, daily, or every Monday, and reuse and combine these for the appropriate runbooks.</li>
</ul>
<p>When executing the runbook from a Webhook or on a schedule, the option to run it manually will stay available.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Jobs</h1>
                </header>
            
            <article>
                
<p>Every time a runbook is executed, a new entry is created in the <span class="packt_screen">Jobs</span> log. This log will show an entry for every time the runbook has run, no matter how execution was initiated. Every entry will contain the date and time the run was started, whether there were errors, and a full execution log.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Runbooks gallery</h1>
                </header>
            
            <article>
                
<p>Runbooks are a great way of automating common tasks. Of course, there are tasks that are only for specific customers, but there are also many tasks that are applicable to all Azure customers. Examples include the automated startup of a virtual machine every Monday morning at 8 A.M. or scaling up a database every morning and back down every evening.</p>
<p>For these common scenarios, there is the runbooks gallery, which is enabled within every automation account. In this gallery, hundreds of pre-made runbooks can be browsed and searched. Once an appropriate runbook has been found, it can be imported directly into the account as a runbook.</p>
<p><span>Besides executing scripts on set intervals or upon the invocation of a Webhook, Azure Automation can also be used as a PowerShell DSC pull server. Let's discuss this next.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PowerShell DSC</h1>
                </header>
            
            <article>
                
<p>PowerShell DSC is a notion for specifying the configuration of servers. This configuration is stored on a pull server, where it can be accessed by one or more virtual machines. These virtual machines are configured to check this server at a specified interval for the latest DSC configuration and update themselves to comply with this configuration.</p>
<p>PowerShell DSC is an extension to the PowerShell language specification that is used for writing desired state configurations. A configuration enables the desired state of one or more nodes to be specified. A node specifies which server, or set of servers, is to be configured. The configuration for a node is written in the form of one or more resources. An example configuration is shown as follows:</p>
<pre>configuration ServerFarmConfig<br/>{<br/>     Node FrontEndServer<br/>     {<br/>         WindowsFeature IIS<br/>         {<br/>             Ensure = 'Present'<br/>             Name = 'Web-Server'<br/>             IncludeAllSubFeature = $true<br/>         }<br/><br/>         File LogDirectory<br/>         {<br/>            Type = 'Directory'<br/>            DestinationPath = 'C:\logs’<br/>            Ensure = "Present"<br/>        }<br/>     }<br/>}</pre>
<p>In this example, the configuration for a server farm with a single type of server is described. This server contains two resources. The first one, of the <kbd>WindowsFeature</kbd> <span>type</span><span> </span><span>with the name <kbd>IIS</kbd>, ensures that <kbd>IIS</kbd> is installed together with all of its sub-features. The second resource, of the</span> <kbd>File</kbd><span> </span><span>type,</span><span> </span><span>ensures that a directory, </span><kbd>c:\logs</kbd>, <span>exists. The resource types of <kbd>IIS</kbd> and <kbd>File</kbd> and many more are built into the PowerShell DSC specification. A full reference of all resources is available online and a link is included at the end of this chapter.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compiling and applying PowerShell DSC</h1>
                </header>
            
            <article>
                
<p>PowerShell DSC files are saved in plaintext, often in a <kbd>.ps1</kbd> file. These files can be compiled into MOF files. These MOF files can then be pushed to one or more servers to update the state of the server to the state described in the MOF file. This is called <strong>push mode</strong>.</p>
<p>Besides push mode, there is another model for deploying MOF files. This is called <strong>pull mode</strong>. In pull mode, MOF files are not directly pushed to individual servers, but stored on a central server that is called the <strong>pull server</strong><em>.</em> This way, the pull server has a complete record of all configurations and node definitions within those configurations.</p>
<p>Once the pull server is up and running, individual servers are configured to fetch their DSC configuration at a fixed interval and apply that configuration. Applying a configuration means that, for every defined resource, the described state will be enacted. This can be done by doing nothing if the actual state already matches the desired state, or by running commands to achieve the desired state. In this process, all previous changes—even by administrators—will be reverted if necessary.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Powershell DSC with Azure Automation</h1>
                </header>
            
            <article>
                
<p>Azure Automation has built-in capabilities for PowerShell DSC and can fulfill the role of pull server for one or more virtual machines.</p>
<p>To start using the built-in pull server capabilities, upload one or more configuration files to the automation account. This is done from the <span class="packt_screen">State configuration</span> view that is shown in the following screenshot. Now, complete the following steps:</p>
<ol>
<li>Open by clicking the menu option on the left.</li>
<li>Select <span class="packt_screen">Configuration</span> in the tab bar at the top:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1154 image-border" src="assets/e2748a78-ee4d-4f5a-ab2d-cd0a6e90cfe4.png" style="width:48.08em;height:30.58em;"/></p>
<ol start="3">
<li>Once the overview of all configurations is opened, new configurations can be added using the <span class="packt_screen">Add</span> button. In <kbd>topHere</kbd>, a local <kbd>ps1</kbd> file can be selected and that will be added to the list. Any valid configuration in the list can be clicked on and compiled in place.</li>
<li>Now, the configuration will also be shown in the tab with compiled configurations and can be applied to one or more virtual machines.</li>
<li>Once a compiled configuration is available, the <span class="packt_screen">Nodes</span> tab can be used for adding one or more virtual machines from the subscription to a configuration node.</li>
<li>Clicking the <span class="packt_screen">Add</span> button while this tab is shown opens the view shown as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1155 image-border" src="assets/93411ab5-71a1-48f7-947f-b1f7f46a1848.png" style="width:51.83em;height:19.92em;"/></p>
<ol start="7">
<li>In this view, a virtual machine can be selected to which the selected configuration should be applied.</li>
<li>The local configuration manager on that machine will be configured to refresh the configuration at fixed intervals.</li>
<li>Whenever the configuration is refreshed, it will be reapplied to the server.</li>
</ol>
<p>Azure Automation enables users to manage virtual machines, for example, to apply application configuration. When working with PaaS offerings, this cannot be done using techniques as PowerShell DSC and other techniques have to be used to manage application settings. These will be discussed in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing application settings</h1>
                </header>
            
            <article>
                
<p>Another part of the infrastructure of an application is the application configuration. In this section, a number of approaches for storing and loading the application configuration for an Azure App Service are discussed. They include the following:</p>
<ul>
<li>Storing the configuration in the app settings</li>
<li><span>Using a combination of Managed Identity and key vault</span></li>
<li><span>Using the Azure App configuration service</span></li>
</ul>
<p>The disadvantage of the first approach is that the app settings can be read by any user who has administrative (read) access to the app service that is configured. The next two approaches do not have this disadvantage.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Azure app service settings from an ARM template</h1>
                </header>
            
            <article>
                
<p>The first way to configure application settings as code is by specifying app settings as a resource in an ARM template. This should be specified as a nested resource. This can be done as shown in the following screenshot:</p>
<pre>{<br/>    "name": "[concat(variables(‘websiteName’), ‘/appsettings’)]",<br/>    "type": "config",<br/>    "apiVersion": "2015-08-01",<br/>    "dependsOn": [<br/>        "[concat('Microsoft.Web/sites/', variables('webSiteName'))]"<br/>    ],<br/>    "properties": {<br/>        "key1": " [listKeys(parameters('storagename'), '2018-02-01').keys[0].value]",<br/>        "key2": "value2"<br/>    }<br/>}</pre>
<p>The use of the <kbd>listKeys</kbd> <span>function</span><span> </span><span>is especially useful in these scenarios. It allows for the direct copying of secrets from any service to the application settings without ever storing them in any intermediate solution. For secrets that do not come from Azure sources, template parameters should be used.</span></p>
<p>The configuration specified in the ARM template corresponds to the configuration of an App Service that can be found in the portal. These settings are used to override corresponding entries in the <kbd>appsettings.json</kbd> or <kbd>appsettings.config</kbd> files. Updating this configuration automatically reloads the application as well.</p>
<p>The downside of this approach is that secrets that are stored this way are readable through the Azure portal. Any user with read access to the app service can retrieve all secrets stored this way.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading settings at runtime from key vault</h1>
                </header>
            
            <article>
                
<p>The next possible location for storing app service settings is in an Azure <span>key vault</span>, where the application loads them at runtime. To make this possible, the following has to be in place.</p>
<p>To be able to authorize an application with access to a <span>key vault</span>, the application first has to be able to authenticate itself against the <strong>Azure Active Directory</strong> (<strong>AAD</strong>). Of course, this can be done by registering a service principal manually, but this would return a username and password that have to be stored somewhere. Usernames and passwords are secrets, but cannot be stored in the <span>key vault </span>since they are needed for accessing it. This problem of how to keep the key to the vault safe can be solved by using an Azure capability called <em>Managed</em> <em>Identity</em>.</p>
<div class="packt_infobox">The problem of securely storing secrets but getting another secret in return for accessing them is often referred to as the problem of <em>turtles all the way down.</em> This is an old anecdote to which a link is included at the end of this chapter.</div>
<p>With Azure Managed Identity enabled on an app service, Azure automatically generates a service principal with a non-retrievable username and password. Only at runtime, using specific code, <span>can</span><span> </span><span>an application authenticate itself as this principal. Azure will ensure that this will only work for code that is running with the app service that the Managed Identity belongs to.</span></p>
<p>Now that an application can have its own identity, that identity has to be granted access to the <span>key vault</span>. This can be done in the <span>key vault</span> description in an ARM template, using the following syntax:</p>
<pre>{<br/>    "type": "Microsoft.KeyVault/vaults",<br/>    "name": "[parameters('keyVaultName')]",<br/>    "apiVersion": "2015-06-01",<br/>    "location": "[resourceGroup().location]",<br/>    "dependsOn": [<br/>        "[resourceId('Microsoft.Web/sites/', parameters('appServiceName'))]"<br/>    ],<br/>    "properties": {<br/>        "enabledForTemplateDeployment": false,<br/>        "tenantId": "[subscription().tenantId]",<br/>        "accessPolicies": [<br/>          {<br/>            "tenantId": "[subscription().tenantId]",<br/>            "objectId": [reference(concat(resourceId('Microsoft.Web/sites',parameters('appServiceName')),<br/>                    [line continued] '/providers/Microsoft.ManagedIdentity/Idntities/default'), <br/>                    [line continued] '2015-08-31-preview').principalId]",<br/>            "permissions": {<br/>              "secrets": [ "get", "list" ]<br/>            }<br/>          }<br/>        ],<br/>        "sku": {<br/>          "name": "standard",<br/>          "family": "A"<br/>        }<br/>    }<br/>}</pre>
<p>In this example, the <kbd>reference()</kbd> function is used to retrieve the information of the Managed Identity and uses this to create an access policy on the <span>key vault</span>.</p>
<p>Finally, with the <span>key vault </span>and access to it set up, the application has to retrieve the contents at start up time. To do this, config builders can be used. They are introduced with .NET Core 2.0 (and .NET Framework 4.7.1) and are used in the <kbd>StartUp</kbd> class, as shown in the following code snippet:</p>
<pre>var tokenProvider = new AzureServiceTokenProvider();<br/>var kvClient = new KeyVaultClient((authority, resource, scope) =&gt;<br/>tokenProvider.KeyVaultTokenCallback(authority, resource, scope));<br/> <br/>var configurationBuilder = new ConfigurationBuilder().AddAzureKeyVault(<br/>    $"https://{ Configuration["keyVaultName"]}.vault.azure.net/",<br/>    kvClient, <br/>    new DefaultKeyVaultSecretManager());<br/> <br/>Configuration = configurationBuilder.Build();</pre>
<p>All types in this code example are available in the NuGet package, <kbd>Microsoft.Configuration.ConfigurationBuilders.Azure</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Azure App Configuration</h1>
                </header>
            
            <article>
                
<p>Another location for storing the configuration of applications is Azure App Configuration. This is a new service, and at the time of writing, still in preview. App Configuration allows for the creation of a central register of key-value pairs that can be used as configuration by such a register, but also multiple applications.</p>
<p>App Configuration is another type of resource that can be created from the portal. The main component is a configuration explorer, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1156 image-border" src="assets/02417fea-c92b-4913-bea5-1998182362cd.png" style="width:69.75em;height:53.33em;"/></p>
<p>In addition to the configuration explorer, there is a keys section for retrieving access keys that applications can use to read the configuration. There are also options to view recent changes to the configuration and restore earlier versions and for importing or exporting all configuration settings.</p>
<p>After the App Configuration resource has been created and configuration keys added, they can be retrieved from within an application by using an extension method of the <strong>IConfiguration</strong> framework type:</p>
<pre>config.AddAzureAppConfiguration(settings["ConnectionStrings:AppConfig"]);</pre>
<p>The loader for settings from an app configuration is part of the NuGet package, <kbd>Microsoft.Azure.AppConfiguration.AspNetCore</kbd>.</p>
<p>Compared to storing settings in Azure <span>key vault</span>, App Configuration has two downsides:</p>
<ul>
<li>Firstly, the application needs to be configured with a connection string to the App Configuration, storing at least one new secret in the app settings.</li>
<li>Secondly, App Configuration does not have access control options that are as rigid as <span>key vault</span>. For this reason, it might make sense to distribute configuration over both App Configuration and <span>key vault</span>, depending on the type of configuration value.</li>
</ul>
<p>This concludes our discussion of Azure and Azure DevOps capabilities for infrastructure as code. The next section will discuss a series of other tools available that offer similar capabilities.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other tools</h1>
                </header>
            
            <article>
                
<p>There are many other tools available for managing infrastructure and configuration through code. Next to the native Azure and Windows options discussed in the previous sections, there are many alternatives widely in use and some of them are listed in this section. It is important to know which tool can be used for which scenarios and how to integrate with them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CloudFormation</h1>
                </header>
            
            <article>
                
<p>CloudFormation is the IaC language for the AWS Cloud. CloudFormation templates can be written in either JSON or YAML format. One example of creating an AWS S3 Storage Bucket that is publicly readable would look like this:</p>
<pre>Resources:<br/> HelloBucket:<br/> Type: AWS::S3::Bucket<br/> Properties:<br/> AccessControl: PublicRead</pre>
<p>There is an extension available that allows the execution of CloudFormation templates on AWS from Azure DevOps. This extension provides tasks for creating, updating, or deleting AWS Stacks. A stack has a function that is comparable to a resource group in Azure and the tasks are comparable to the tasks for applying an ARM template.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chef</h1>
                </header>
            
            <article>
                
<p>Chef is a tool for CaC, with support for describing and enforcing the configuration of servers. Chef uses a centralized server, <em>Chef Server</em>, where all configuration for all servers is saved. Here, the correct desired state for every server is determined, which is then pulled by the <em>Chef Client,</em> an agent that runs on the <em>node</em> that is being managed.</p>
<p>Defining the desired state for a server is done using a number of constructs. The lowest level is the recipe. A recipe contains one or more resources, built-in capabilities that can be used. An example resource is execute , which runs a bash command. Another example resource is <kbd>apt_update</kbd>, which provides the means to interact with the <em>apt</em> package manager. One or more recipes are combined in cookbooks, which describe a capability that can be assigned to a node. The assignment of one or more cookbooks to a node is done using the run list. The run list contains all cookbooks that have to be applied to a node.</p>
<p>Interaction with the Chef Server is done using a command-line tool called <strong>knife</strong>.</p>
<p>While the terminology is completely different, there are many conceptual parallels between PowerShell DSC and Chef.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Puppet</h1>
                </header>
            
            <article>
                
<p>Puppet is a deployment and configuration management tool that operates using a server-client model. There is a centralized server called the <strong>Puppet Master</strong> that is responsible for taking in all of the desired state descriptions and compiling them to an intern catalog that holds the desired state for every managed server. All servers that are managed by Puppet need to have the Puppet agent installed on the local server. The agent connects to the server, to pull the state for the server it manages, and applies that locally. A managed server is called a node<em>.</em></p>
<p>The base building block used by Puppet is called a <strong>resource</strong>. A resource is defined by specifying a resource type and a series of attributes. There are many resource types available, for example, for managing users and installed applications. Resources are grouped in one or more <em>classes.</em> These classes are, in turn, assigned to one or more nodes.</p>
<p>Puppet can be installed on any Linux VM in Azure. There is also a pre-built image with Puppet Enterprise available in the Azure marketplace.</p>
<p>Puppet is comparable to Chef and PowerShell DSC. All three have a comparable model for describing the desired state and they all serve the same purpose.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ansible</h1>
                </header>
            
            <article>
                
<p>Ansible is yet another configuration management tool that is mostly used on Linux but <span>also</span><span> </span><span>has support for Windows. One aspect that differentiates Ansible from other tools is that it does not have a centralized server that hosts all of the desired states, nor does it work with agents. All commands executed by Ansible are executed using SSH.</span></p>
<p>Any server can initiate the deployment of a <em>playbook</em> against one or more <em>items</em> in an <em>inventory.</em> An Ansible inventory contains all of the servers that can be managed by Ansible. They can be grouped into one or more groups, which can be nested into other groups as well. Each individual server and every group is an inventory item. In Ansible, the desired state is written in playbooks. A playbook is a series of tasks or roles that need to be run at the target server. A role is a group of tasks. Roles are intended to be reused in more than one playbook and should, therefore, be general enough to be useable in multiple situations. Roles should also be idempotent. This means that the tasks in the role should ensure that the outcome of running the playbook is the same, no matter the number of times it is run.</p>
<p>Ansible scripts can be executed using command-line tools or an Azure DevOps extension that wraps this tool. There are also other management systems available, such as Ansible Tower, that provide a graphical user interface on top of the capabilities of the Ansible command-line tools.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Terraform</h1>
                </header>
            
            <article>
                
<p>Terraform is a multi-cloud infrastructure management solution. It is comparable to ARM templates, the difference being that it also supports Amazon Web Services, Google Cloud Platform, and other clouds. Terraform uses a custom file format for specifying one or more resources to be created using one or more providers. The resources correspond to the cloud resources, and the providers are responsible for knowing how to interact with the APIs of the different vendors.</p>
<p>Optionally, you can use a JSON format instead of the Terraform proprietary format. Terraform also supports the use of modules for creating packages that are reusable components.</p>
<p>Terraform configuration files are executed using command-line interfaces.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned about the concept of infrastructure and configuration as code, its value, and how to use it in practice. For implementing these, you learned about ARM templates, the IaC mechanism for Azure. You also learned about PowerShell DSC for managing the configuration of virtual machines and about different techniques for managing the configuration of your applications. Finally, you learned about several other tools available in the market. You learned which tool can be used in which situation and whether these tools can integrate with Azure DevOps.</p>
<p>With this knowledge, you are now able to start describing the infrastructure and configuration of your application(s) in source control using one or more of the tools you have read about. You are also capable of setting up the means to deliver the infrastructure using automation, either from a release pipeline or using dedicated infrastructure management tools. But no matter which solution you choose, you now have the capabilities to incorporate infrastructure into your DevOps processes.</p>
<p>In the next chapter, you will learn about another challenge you might encounter when implementing DevOps practices: databases. When increasing the speed at which features flow to production, you may also have to change the way you manage your database schema and how you apply changes. The next chapter will discuss this subject.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<p>As we conclude, here is a list of questions for you to test your knowledge regarding this chapter's material. You will find the answers in the <em>Assessments</em> section of the Appendix:</p>
<ol>
<li>True or False: ARM templates can be used for creating, updating, and deleting Azure Resources.</li>
<li>Which of the following is not an Azure Automation Account resource?
<ol>
<li>Modules</li>
<li>Containers</li>
<li>Run As account</li>
<li>Variables</li>
</ol>
</li>
<li>True or False: One disadvantage of infrastructure as code is that you have to put sensitive information in source control as ARM template parameter files.</li>
<li>True or False: Azure Automation Accounts allow for the execution of Powershell runbooks at a predefined schedule.</li>
<li>What are some of the benefits of using infrastructure as code?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>A formal breakdown of the ARM template structure and syntax can be found at <a href="https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-syntax">https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-syntax</a>.</li>
<li>The complete ARM Template reference can be found at <a href="https://docs.microsoft.com/en-us/azure/templates/">https://docs.microsoft.com/en-us/azure/templates/</a>.</li>
<li>An overview of all functions that can be used in ARM templates can be found at <a href="https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-template-functions">https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-template-functions</a>.</li>
<li>More information about Azure Blueprints can be found at <a href="https://docs.microsoft.com/en-us/azure/governance/blueprints/overview">https://docs.microsoft.com/en-us/azure/governance/blueprints/overview</a>.</li>
<li>Details about the WhatIf command for ARM templates can be found at <a href="https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-deploy-what-if">https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-deploy-what-if</a>.</li>
<li>There are many online references to the story of "turtles all the way down", but an early reference can be found digitized at <a href="https://dspace.mit.edu/handle/1721.1/15166">https://dspace.mit.edu/handle/1721.1/15166</a>.</li>
<li>The reference including all Powershell DSC built-in resources can be found at <a href="https://docs.microsoft.com/en-us/powershell/scripting/dsc/overview/overview">https://docs.microsoft.com/en-us/powershell/scripting/dsc/overview/overview</a>.</li>
<li>More information about CloudFormation can be found at <a href="https://aws.amazon.com/cloudformation/">https://aws.amazon.com/cloudformation/</a>.</li>
<li>More information about Chef can be found at <a href="https://www.chef.io/">https://www.chef.io/</a>.</li>
<li>More information about Puppet can be found at <a href="https://puppet.com/">https://puppet.com/</a>.</li>
<li>More information about Ansible can be found at <a href="https://www.ansible.com/">https://www.ansible.com/</a>.</li>
<li>More information about Terraform can be found at <a href="https://www.terraform.io/">https://www.terraform.io/</a>.</li>
<li>The following are links to Microsoft hands-on labs that can be used to get hands-on experience with the topics discussed in this chapter (<a href="https://docs.microsoft.com/en-us/learn/modules/intro-to-governance/">https://docs.microsoft.com/en-us/learn/modules/intro-to-governance/</a>):
<ul>
<li><a href="https://docs.microsoft.com/en-us/learn/modules/configure-infrastructure-azure-pipelines/index">https://docs.microsoft.com/en-us/learn/modules/configure-infrastructure-azure-pipelines/index</a></li>
<li><a href="https://docs.microsoft.com/en-us/learn/modules/provision-infrastructure-azure-pipelines/index">https://docs.microsoft.com/en-us/learn/modules/provision-infrastructure-azure-pipelines/index</a></li>
<li><a href="https://docs.microsoft.com/en-us/learn/modules/protect-vm-settings-with-dsc/">https://docs.microsoft.com/en-us/learn/modules/protect-vm-settings-with-dsc/</a> </li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    </body></html>