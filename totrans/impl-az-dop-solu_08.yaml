- en: Infrastructure and Configuration as Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, the focus was on storing and building application code
    and releasing the created binaries. You learned how to create a pipeline, from
    source control to a target environment for the automated, repeatable deployment
    of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to apply the same principles to the infrastructure
    that your application runs on and the runtime configuration of your application.
    Doing so will help you to further increase the speed at which changes can be delivered
    to production, increasing the flow of value to your end users.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will start off by explaining the value of having everything, infrastructure
    and configuration included, as code. Next, it continues by explaining ARM templates.
    The syntax will be explained, as well as how to deploy ARM templates. Then, it
    proceeds to explain the Azure Automation offering, available in the Azure Cloud.
    Azure Automation can be used for running scripts on a schedule or for loading
    and applying PowerShell DSC modules. Next up is managing application settings
    for PaaS offerings, such as Azure App Service. Finally, it concludes by discussing
    several other tools that have similar capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Having everything as code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with ARM templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying ARM templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse engineering a template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Azure Automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing application settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To experiment with one or more of the technologies described in this chapter,
    one or more of the following may be required:'
  prefs: []
  type: TYPE_NORMAL
- en: An Azure subscription, for executing ARM templates and running Azure Automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PowerShell with the Azure PowerShell modules, for executing ARM templates, available
    from [https://docs.microsoft.com/en-us/powershell/azure/install-az-ps](https://docs.microsoft.com/en-us/powershell/azure/install-az-ps)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Azure CLI, for executing ARM templates, available from [https://docs.microsoft.com/en-us/powershell/azure/install-az-ps](https://docs.microsoft.com/en-us/powershell/azure/install-az-ps)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more virtual machines for experimenting with the different tools discussed
    in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having everything as code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have been responsible for creating and maintaining application infrastructure
    and configuration in the past, you have most likely experienced what is called
    **configuration drift***.* Configuration drift is the name for the phenomenon
    where the configuration between servers in acceptance and the production environment
    differs. Or, even worse, when having multiple servers in the production environment,
    it might be the case that the configuration of these is not always the same.
  prefs: []
  type: TYPE_NORMAL
- en: The most common cause of configuration drift is manual change. When making changes
    manually, maybe under the pressure of a production issue, there is always the
    risk that you apply different settings to different servers or hosts. And if you
    ever need to scale out and add another server to your production environment,
    the chance of that server taking on the same configuration of all already existing
    servers is very slim.
  prefs: []
  type: TYPE_NORMAL
- en: With **Infrastructure as Code** (**IaC**) and **Configuration as Code** (**CaC**),
    you no longer make changes to application configuration and infrastructure by
    hand, but only through automation. The first step to do this is specifying the
    desired state of configuration and infrastructure. The desired state is then fed
    into configuration management tooling that enforces this configuration on your
    infrastructure. Specifying only the desired state is called a *declarative* approach,
    which differs from an *imperative* approach, where you specify all of the steps
    that need to be taken.
  prefs: []
  type: TYPE_NORMAL
- en: These tools are often also capable of checking the current state of your infrastructure
    and configuration on a regular interval and reapplying your desired state if any
    deviation is detected. This is possible due to the declarative approach. This
    makes applying configuration an idempotent operation. An operation is idempotent
    if it can be repeated one or more times, while the outcome will remain the same.
  prefs: []
  type: TYPE_NORMAL
- en: When adopting IaC and CaC, you can even go so far as to recreate the complete
    infrastructure before deploying an application, deploy the application on that
    new infrastructure, and then disregard the old infrastructure after switching
    to the new deployment. This is an extreme form of immutable servers. The added
    benefit of this approach is that you are now guaranteed that there will be no
    traces from any configuration or binaries from the previous deployment.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, you will learn about different IaC technologies and
    how to use them. It is important to understand that they are complementary and
    are often used together. For example, ARM templates can be used to create virtual
    machines in Azure and, once that is done, PowerShell DSC or Ansible can be used
    to configure those virtual machines.
  prefs: []
  type: TYPE_NORMAL
- en: Working with ARM templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working on the Azure platform, infrastructure is described using **Azure
    Resource Manager** (**ARM**) templates. ARM templates are written in JSON and
    a skeleton template looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The template itself is, at the highest level, a JSON object. There is a mandatory
    property, `$schema`, for which the shown value is also mandatory. The `contentVersion`
    property is also mandatory and can be specified to version the contents. This
    version can be used by the author to version the template if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this chapter will discuss the different parts that make up ARM templates
    in more detail. There is also an online reference available, to which a link is
    added at the end of this chapter. A link to the formal, detailed breakdown of
    the structure and syntax of ARM templates is also added at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every template has to start with a parameters section. This section takes the
    shape of a JSON object, which can be empty but cannot be left out. The use of
    this section is to declare one or more parameters that can be specified by the
    caller of the ARM template, before deploying it. A common reason for using the
    parameters section is to use the same template for both the test and production
    environment, but varying the names of resources between the two. An example parameters
    section might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For every parameter, a new key is specified with the parameter's name. The value
    is an object. This object has one mandatory key, `type`. The allowed values for
    type are `string`, `int`, `bool`, `object`, `array`, `secureString`, and `secureObject`.
    The `secureString` and `secureObject` variations can be used to make sure that
    the runtime values of these parameters are scrubbed from any log and output. They
    are intended to hold passwords, keys, or other secrets.
  prefs: []
  type: TYPE_NORMAL
- en: The metadata object, with the `description` key, is optional and can be used
    to add a description to the parameter for future reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other properties that can be specified on a parameter object are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`minValue` and `maxValue` for specifying bounds on an integer value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minLength` and `maxLength` for specifying bounds on the length of a string
    value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultValue` for specifying a default value that will be used if no value
    is specified when applying the template'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allowedValues` for specifying an array of allowed values, limiting valid inputs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let's understand what parameter files are.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One way for specifying the parameter values when deploying a template is through
    a variable file. Often, a single template is accompanied by more than one parameter
    file, for example, one for test and one for production. The JSON for a parameter
    file appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Just like an ARM template, every parameter file is a JSON object with mandatory
    `$schema` and `contentVersion` properties. The third property parameter is used
    to specify one or more parameter values. For each parameter, specify its name
    as the key and an object as the value. This object can hold the `value` key for
    providing the actual value of the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'While very valuable for specifying names for resources, scaling options, and
    other things that have to vary between environments, this solution is not useful
    for secrets. Keys, passwords, and other secrets should not be stored as plaintext
    in source control in a parameter file. For secrets, another notation is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With this notation, instead of specifying the value directly, there is a pointer
    to a location in an Azure key vault where the correct value is stored. When deploying
    the template, this secret is (within Azure!) taken from the key vault and used
    in deployment. This is allowed only if the user or service starting the deployment
    has either an owner or contributor role in relation to the key vault and the key
    vault is enabled for template deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Strictly speaking, any role that includes the `Microsoft.KeyVault/vaults/deploy/action`
    permission will work. By default, these are the owner and contributor roles, but
    you can create custom roles that include this action as well.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The variables section is used to specify one or more values that will be used
    throughout the template. A common approach is building the names of all resources
    in the variables section, based on a single parameter called `environmentName`.
    This ensures that resources will have the same name between environments. Variables
    are also used to specify values that cannot be specified from outside the template,
    but should be recognized as configurable. An example might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the example for `appServiceName` contains functions that are
    discussed in detail in a later section called *Functions.*
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The third section in any ARM template is the resources section. This is the
    main part of the template, where all of the resources to be created are specified.
    This section is the only one that is not an object, but an array. Within that
    array, one or more objects of the following form are specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Each resource is specified in the form of an object. The first four properties
    are mandatory for every type of resource:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The type of the resource to be created or updated needs to be specified: This
    takes the form of the name of `resourceprovider` followed by a slash and the name
    of a resource type that belongs to that `resourceprovider`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The version of the API to use for this resource: A list of supported API versions
    can be retrieved from the reference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The name for the resource: Every resource type has its own rules for determining
    what a valid name is. These can also be found in the reference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Azure Region where the resource is to be created: This must be a valid
    Azure Region.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All other properties on the object vary from resource type to resource type
    and are all specified in the resource.
  prefs: []
  type: TYPE_NORMAL
- en: Dependent resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A special type of resource is the dependent resource. For example, SQL databases
    are hosted on a SQL Server and Service Bus Topics are located within a Service
    Bus namespace. For a nested resource type, the type and name reflect this nesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Next to nesting the type and the name, the extra property, `dependsOn`, is also
    mandatory to specify that this nested resource can only be created after the containing
    resource exists. A location property is not necessary since this will be inherited
    from the containing resource.
  prefs: []
  type: TYPE_NORMAL
- en: Nested templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A second special type of resource is template deployment. This way, one template
    can trigger the deployment of another. An example of defining a template deployment
    as a resource in a template looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The locations of the template and parameter file can be specified using both
    HTTP and HTTPS, but have to be publicly accessible locations. As an alternative,
    a single property template can be specified. This should then contain a whole
    template as a JSON object.
  prefs: []
  type: TYPE_NORMAL
- en: Outputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fourth and final section of a template is the outputs section. Here are
    the keys returned to the caller of the template. The caller can use these values
    to start another task or script and use one or more of the values created or used
    by the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main use for this is to prevent hardcoding names in downstream automation.
    The outputs section is a JSON object of the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When specifying outputs, the same types can be used as for parameters. Of course,
    it does not make much sense hardcoding the values, so functions are used to retrieve
    values from parameters, variables, or even created resources.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions are used to allow for dynamic evaluation of properties in ARM templates.
    Calling functions uses a notation very similar to that of many programming languages:
    `functionName(arg1, arg2, …)` functions can return either a value such as `string`
    or `int` or an object or array. When an object is returned, any property can be
    accessed using the `.propertyName` notation*.* Accessing elements in an array
    can be done using `[position]`. To indicate which parts of a string should be
    evaluated as a function, they can be enclosed in brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example shows two example functions. First, the `concat` function
    is called to concatenate two string values. One is hardcoded and the other one
    is the result of a second function call to retrieve the value of a template parameter.
  prefs: []
  type: TYPE_NORMAL
- en: There are a fair number of functions available. They can be used for string
    manipulation, for retrieving details about the current subscription, resource
    group, or Azure Active Directory tenant, or for getting resource details.
  prefs: []
  type: TYPE_NORMAL
- en: Functions can also be used to retrieve account keys or other secrets. This is
    often done to automatically insert keys directly from the service that exposes
    the key to application settings or a key vault. This completely eliminates the
    need for the manual transfer of secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Well, so far, we have learned the different parts that make up an ARM template,
    which you should be able to write on your own. Now it's time to learn how we can actually deploy
    them with the help of various tools.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying ARM templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once an ARM template and its accompanying parameter files are written, they
    can be applied to an Azure environment. There are PowerShell Cmdlet and Azure
    CLI commands available for applying an ARM template from a scripting environment.
    When ARM templates are used for the infrastructure of an application, Azure Pipelines
    can be used for deploying not only code but also ARM templates.
  prefs: []
  type: TYPE_NORMAL
- en: No matter which approach is used for deployment, all of them will have a *deployment
    mode*. This can be either *incremental* or *complete*. In incremental mode, all
    resources specified in the template will be created in Azure or their properties
    will be updated if the resource already exists. In complete mode, all resources
    that are not specified in the template and already exist in Azure will also be
    removed. The default deployment mode is incremental.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, several tools for executing deployments are discussed,
    starting with PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For local development and testing of ARM templates on a local machine, Powershell
    has a quick command to apply an ARM template to a resource group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will pick up the specified template and parameter file
    and apply it to the specified resource group. This command assumes that the current
    session has already been logged in to Azure.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few variations on the command available:'
  prefs: []
  type: TYPE_NORMAL
- en: A parameter called `-Mode` with a `Complete` or `Incremental` value is available.
    This can be used to specify `deploymentmode`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no parameter file is specified and the template requires parameters, the
    cmdlet will prompt for these values on the command line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an alternative, the `-TemplateUri` and `-TemplateParametersUri` options can
    be used to specify the location of the template and parameters to be retrieved
    from another location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next tool that we'll look into is the Azure CLI.
  prefs: []
  type: TYPE_NORMAL
- en: The Azure CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Azure CLI is another way of deploying ARM templates from the command line.
    The benefit of the CLI is that it is completely cross-platform and runs on Windows,
    macOS, and Linux. The Azure CLI command for deploying an ARM template is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: All other options that are available in PowerShell are also available in the
    CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A third mechanism for deploying ARM templates is from an Azure pipeline. This
    is particularly useful for deploying the infrastructure and configuration of an
    application, together with the binaries. To deploy an ARM template deployment
    from a pipeline, at least one service connection of the Azure Resource Manager
    needs to be configured. After doing this, a pipeline can be configured as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42359bf4-5736-4d18-9c5a-ae9f83e6bd0a.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, there are two deployments of an ARM template, surrounding the
    deployment of the application code. The first deployment is of the incremental type,
    while the second deployment is of the complete type. Using this approach, the
    first deployment will create all new infrastructure needed by the new version
    of the application. This deployment is done in incremental mode, so infrastructure
    that is no longer present in the template but still in use by the currently deployed
    version of the application will not yet be removed. The second deployment will
    take care of removing these elements after the new version of the code is deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse engineering a template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing an ARM template from scratch can be a tedious and time-consuming task.
    Luckily, there are two approaches available to generate an ARM template from existing
    infrastructure:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Export template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Resource Explorer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss both of these in the upcoming subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Export template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first approach is using the Export template option that can be found on
    every resource and resource group in the Azure portal. This will generate an ARM
    template of the current state of the resource (group), as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aeb90981-6db5-4157-8cc0-73b0343b28c5.png)'
  prefs: []
  type: TYPE_IMG
- en: Please note that not every service currently supports reverse engineering an
    ARM template using this approach. For any service not supported, there will be
    a warning at the top of the screen. To work around this limitation for retrieving
    the JSON template for an individual resource, there is another approach, which
    is our next topic of discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Resource Explorer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For retrieving the JSON template for an individual resource, we can use the
    Resource Explorer*.* The Resource Explorer is shown here and can be found in the
    Azure portal by using the menu (*1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d56d466-61da-447d-9993-0da540143b9b.png)'
  prefs: []
  type: TYPE_IMG
- en: After opening the resource explorer, two new panes open up. The left pane can
    be used to navigate through subscriptions and drill down into the resource groups,
    down to the individual resources. For every element that is selected, the corresponding
    JSON will be displayed on the right. In the preceding example, the JSON for a
    hard disk is shown. This JSON is the same as the JSON that can be used in the
    resources array of an ARM template.
  prefs: []
  type: TYPE_NORMAL
- en: Subscription-level templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The discussion of ARM templates up to this point has all been about ARM templates
    for a resource group deployment. A template describes one or more resources that
    are deployed to a resource group. Additionally, there are also subscription-level
    templates. An example ARM template for a resource group is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The format for a subscription template is completely the same as that for a
    resource group. The differences are `$schema`, which points to another schema
    location, and the types of resources that are supported. Subscription templates
    do not support the creation of resources directly, and support only the creation
    of resource groups, the initiation of template deployments, creating and assigning
    Azure Policies, and the creation of role assignments.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Blueprints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next to subscription level-templates, there is also another offering available:
    Azure Blueprints. Blueprints can be used to describe the desired state of an Azure
    subscription and apply that to an existing subscription.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the things that can be done using a blueprint can nowadays also be done
    using an ARM template. However, the other way around is not true. Azure Blueprints
    only support the following constructs, which are called artifacts:'
  prefs: []
  type: TYPE_NORMAL
- en: Policy assignments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Role (RBAC) assignments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource group creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested ARM templates at the subscription or resource group level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are all of the elements that are needed to build the default layout, or
    a blueprint, for Azure subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of key differences between blueprints and ARM templates:'
  prefs: []
  type: TYPE_NORMAL
- en: Blueprints are stored within Azure itself. A blueprint is a resource you can
    create and navigate to in the portal. The authoring experience is also in the
    portal, not in text files on a local computer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The relation between a subscription and the blueprint that was used to create
    it remains, also after the deployment completes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the assignment of a blueprint to a subscription, it is possible to mark
    the assignment as locked. If this is done, all of the resources deployed through
    the blueprint cannot be deleted or edited as long as the blueprint is assigned—not
    even owners of the subscription that it is applied to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many built-in blueprints available that can be used to implement controls
    from well-known standards such as ISO, NIST, or HIPAA.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The general recommendation is to use blueprints whenever creating many new subscriptions,
    which should follow the same layout, and use ARM templates in all other cases.
    Blueprints are still in preview at the time of writing
  prefs: []
  type: TYPE_NORMAL
- en: November 2019 updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since November 2019, ARM templates no longer have to be pure JSON. Several other
    constructs are now allowed to make working with ARM templates easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'To comment the rest of a line, `//` is used, or to comment a block, the `/*
    */` notation is used. This makes the following snippets both valid as part of
    an ARM template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Another deviation from JSON is that ARM templates allow for a multi-line string.
    When using these from the Azure CLI, this has to be enabled by specifying the `--handle-extended-json-format` switch.
    To use these and other new features, a new JSON schema has to be referenced from
    the template. This schema is [https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#](https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#).
  prefs: []
  type: TYPE_NORMAL
- en: Also, a new command has been introduced to show what changes would be made if
    a template wer be applied. This command is still in preview and called `New-AzDeploymentWhatIf`.
    A link to the documentation is included at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: While ARM templates are the preferred approach in Azure for managing infrastructure,
    there are scenarios where it might not fit. In these cases, Azure Automation can
    be an alternative. Azure Automation is discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using Azure Automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Automation is a service in Azure that is designed to help users to create,
    manage, deploy, and maintain their Azure resources. Azure Automation contains
    several concepts that remove some of the complexities and low-level details from
    these actions. Azure Automation allows for the formulation of workflows in the
    form of runbooks*.* These runbooks can be executed against Azure resources on
    behalf of the user.
  prefs: []
  type: TYPE_NORMAL
- en: Automation account resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within an Azure Automation account, there are several resources that make this
    more than just a scripting engine. These resources are shared on the level of
    the automation account and can hence be reused within multiple runbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Run As account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first of these constructs is the *Run As* account. This account is a service
    principal that will be created in the Azure Active Directory that the Azure subscription
    containing the automation account is linked to. The credentials to authenticate
    as this service principal are securely stored within the automation account. These
    credentials are non-retrievable. The service principal is also added as a contributor
    to the Azure subscription. As a result, runbooks can now be set up to execute
    using this account.
  prefs: []
  type: TYPE_NORMAL
- en: Run As accounts can be automatically created when creating the Automation account.
  prefs: []
  type: TYPE_NORMAL
- en: Schedules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common way of automating workflows is scheduling them to run on a specific
    date and time or on a fixed interval. Instead of specifying a schedule for every
    workflow, shared schedules can be created and reused in runbooks. To create a
    new schedule, first, open the list of all schedules. After that, a new  schedule
    can be added, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a728d578-1ff0-47b6-aa70-32ecbd5baf63.png)'
  prefs: []
  type: TYPE_IMG
- en: A schedule has a name and a description. These values are for the users interacting
    with the schedule only. Next, a starting date and time can be configured, along
    with an optional recurrence interval, and, if a recurrence interval is specified,
    an expiration date and time. Once the schedule is created, it can be used for
    a runbook.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The runbooks that are used in Azure Automation are written in PowerShell. PowerShell
    has a very rich ecosystem of modules with predefined functionalities that can
    be used. For using PowerShell modules from an automation account, only modules
    that have been uploaded to the modules section can be used. One major benefit
    of this is that it is possible to fix the version of a module to use. This guarantees
    that scripts will keep working and not break in case of updates to dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The PowerShell modules for interacting with Azure are by default installed into
    every automation account. Furthermore, more modules can be added, and existing
    modules can be upgraded or removed by administrators.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within runbooks, a lot of variables might come into play; the names of resource
    groups, virtual machines, start up or shutdown times, and so on. Hardcoding these
    values inside a script is not good practice, but storing them together with a
    runbook also has downsides. For example, in the case that there are three runbooks
    for the same virtual machine, this would mean that a number of variable values
    (for example, resource group name and virtual machine name) would be repeated
    at least three times. To prevent this, it is possible to store variable values
    at the automation account level, from where they can be reused throughout every
    runbook that is executed in that account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a variable is set, it can be accessed from a runbook using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to reading and using variables inside a runbook, they can also
    be updated from within a runbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: While a very powerful feature, updating variables from within runbooks can have
    unexpected consequences. If a variable value that is used in multiple runbooks
    gets updated by one of them, this might break the other runbooks. Keeping track
    of which variables are read-only and which are written to as well is important.
  prefs: []
  type: TYPE_NORMAL
- en: Credentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A special type of variable is the credential. Credentials contain not one but
    two values: a username and a password. Credentials are treated as secrets everywhere
    they are used. This means that they will not appear in logs and that they have
    to be retrieved using a specific PowerShell syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: After executing this command, the `myCredential` object can be used to retrieve
    both the username and password.
  prefs: []
  type: TYPE_NORMAL
- en: Connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a very common scenario to have to connect to one or more external services
    from within a runbook. A common example is the Azure Resource Manager that is
    used to manage all resources within Azure. To avoid having to store a series of
    variables and build the corresponding connection in a runbook, automation accounts
    allow for the creation beforehand of one or more connections.
  prefs: []
  type: TYPE_NORMAL
- en: In most scenarios, it is not necessary to create connections manually as they
    are provided along with a Run As account.
  prefs: []
  type: TYPE_NORMAL
- en: Once all of the shared resources are in place, it is time to start writing one
    or more runbooks, which is our next topic of discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Runbooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A number of types of runbooks are supported: PowerShell, Python 2, and graphical.
    The first two allow for writing scripts to be written in the specified language.
    Graphical runbooks allow for composing a runbook from all uploaded PowerShell
    modules, assets, and existing runbooks using drag and drop.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these three basic types of runbooks, there are PowerShell workflow
    and graphical workflow types available. The difference between a regular runbook
    and a workflow runbook is that workflow runbooks also support parallelism. Another
    benefit of PowerShell workflow is that it supports the use of checkpoints, which
    allow a script to be resumed if it encounters an exception mid-execution.
  prefs: []
  type: TYPE_NORMAL
- en: Runbook execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the runbook is written, there are a number of ways to execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Manually**: Any runbook can be run at any time by opening it in the Azure
    portal and pressing Start. Of course, these operations are also available using
    PowerShell or the Azure CLI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**By attaching a Webhook**: Once a runbook is published, one or more Webhooks
    can be generated for executing the runbook. Each Webhook can be enabled or disabled
    or given an expiration date. These tools allow a new Webhook to be generated for
    every user of the runbook and fine-grained control to be initiated  if ever future
    access should not be accorded to a particular user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**On a schedule**: Published runbooks can be attached to one or more of the
    shared schedules. Being able to attach to multiple schedules means that it is
    easy to pre-create a series of schedules for typical reoccurrences, such as hourly,
    daily, or every Monday, and reuse and combine these for the appropriate runbooks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When executing the runbook from a Webhook or on a schedule, the option to run
    it manually will stay available.
  prefs: []
  type: TYPE_NORMAL
- en: Jobs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every time a runbook is executed, a new entry is created in the Jobs log. This
    log will show an entry for every time the runbook has run, no matter how execution
    was initiated. Every entry will contain the date and time the run was started,
    whether there were errors, and a full execution log.
  prefs: []
  type: TYPE_NORMAL
- en: Runbooks gallery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Runbooks are a great way of automating common tasks. Of course, there are tasks
    that are only for specific customers, but there are also many tasks that are applicable
    to all Azure customers. Examples include the automated startup of a virtual machine
    every Monday morning at 8 A.M. or scaling up a database every morning and back
    down every evening.
  prefs: []
  type: TYPE_NORMAL
- en: For these common scenarios, there is the runbooks gallery, which is enabled
    within every automation account. In this gallery, hundreds of pre-made runbooks
    can be browsed and searched. Once an appropriate runbook has been found, it can
    be imported directly into the account as a runbook.
  prefs: []
  type: TYPE_NORMAL
- en: Besides executing scripts on set intervals or upon the invocation of a Webhook,
    Azure Automation can also be used as a PowerShell DSC pull server. Let's discuss
    this next.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell DSC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell DSC is a notion for specifying the configuration of servers. This
    configuration is stored on a pull server, where it can be accessed by one or more
    virtual machines. These virtual machines are configured to check this server at
    a specified interval for the latest DSC configuration and update themselves to
    comply with this configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'PowerShell DSC is an extension to the PowerShell language specification that
    is used for writing desired state configurations. A configuration enables the
    desired state of one or more nodes to be specified. A node specifies which server,
    or set of servers, is to be configured. The configuration for a node is written
    in the form of one or more resources. An example configuration is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the configuration for a server farm with a single type of server
    is described. This server contains two resources. The first one, of the `WindowsFeature` type with
    the name `IIS`, ensures that `IIS` is installed together with all of its sub-features.
    The second resource, of the `File` type, ensures that a directory, `c:\logs`,
    exists. The resource types of `IIS` and `File` and many more are built into the
    PowerShell DSC specification. A full reference of all resources is available online
    and a link is included at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and applying PowerShell DSC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell DSC files are saved in plaintext, often in a `.ps1` file. These files
    can be compiled into MOF files. These MOF files can then be pushed to one or more
    servers to update the state of the server to the state described in the MOF file.
    This is called **push mode**.
  prefs: []
  type: TYPE_NORMAL
- en: Besides push mode, there is another model for deploying MOF files. This is called
    **pull mode**. In pull mode, MOF files are not directly pushed to individual servers,
    but stored on a central server that is called the **pull server***.* This way,
    the pull server has a complete record of all configurations and node definitions
    within those configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Once the pull server is up and running, individual servers are configured to
    fetch their DSC configuration at a fixed interval and apply that configuration.
    Applying a configuration means that, for every defined resource, the described
    state will be enacted. This can be done by doing nothing if the actual state already
    matches the desired state, or by running commands to achieve the desired state.
    In this process, all previous changes—even by administrators—will be reverted
    if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Using Powershell DSC with Azure Automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Automation has built-in capabilities for PowerShell DSC and can fulfill
    the role of pull server for one or more virtual machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using the built-in pull server capabilities, upload one or more configuration
    files to the automation account. This is done from the State configuration view
    that is shown in the following screenshot. Now, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open by clicking the menu option on the left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select Configuration in the tab bar at the top:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e2748a78-ee4d-4f5a-ab2d-cd0a6e90cfe4.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the overview of all configurations is opened, new configurations can be
    added using the Add button. In `topHere`, a local `ps1` file can be selected and
    that will be added to the list. Any valid configuration in the list can be clicked
    on and compiled in place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the configuration will also be shown in the tab with compiled configurations
    and can be applied to one or more virtual machines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once a compiled configuration is available, the Nodes tab can be used for adding
    one or more virtual machines from the subscription to a configuration node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Clicking the Add button while this tab is shown opens the view shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/93411ab5-71a1-48f7-947f-b1f7f46a1848.png)'
  prefs: []
  type: TYPE_IMG
- en: In this view, a virtual machine can be selected to which the selected configuration
    should be applied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The local configuration manager on that machine will be configured to refresh
    the configuration at fixed intervals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whenever the configuration is refreshed, it will be reapplied to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Azure Automation enables users to manage virtual machines, for example, to apply
    application configuration. When working with PaaS offerings, this cannot be done
    using techniques as PowerShell DSC and other techniques have to be used to manage
    application settings. These will be discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Managing application settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another part of the infrastructure of an application is the application configuration.
    In this section, a number of approaches for storing and loading the application
    configuration for an Azure App Service are discussed. They include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Storing the configuration in the app settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a combination of Managed Identity and key vault
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Azure App configuration service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The disadvantage of the first approach is that the app settings can be read
    by any user who has administrative (read) access to the app service that is configured.
    The next two approaches do not have this disadvantage.
  prefs: []
  type: TYPE_NORMAL
- en: Azure app service settings from an ARM template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first way to configure application settings as code is by specifying app
    settings as a resource in an ARM template. This should be specified as a nested
    resource. This can be done as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The use of the `listKeys` function is especially useful in these scenarios.
    It allows for the direct copying of secrets from any service to the application
    settings without ever storing them in any intermediate solution. For secrets that
    do not come from Azure sources, template parameters should be used.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration specified in the ARM template corresponds to the configuration
    of an App Service that can be found in the portal. These settings are used to
    override corresponding entries in the `appsettings.json` or `appsettings.config`
    files. Updating this configuration automatically reloads the application as well.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of this approach is that secrets that are stored this way are readable
    through the Azure portal. Any user with read access to the app service can retrieve
    all secrets stored this way.
  prefs: []
  type: TYPE_NORMAL
- en: Loading settings at runtime from key vault
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next possible location for storing app service settings is in an Azure key
    vault, where the application loads them at runtime. To make this possible, the
    following has to be in place.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to authorize an application with access to a key vault, the application
    first has to be able to authenticate itself against the **Azure Active Directory**
    (**AAD**). Of course, this can be done by registering a service principal manually,
    but this would return a username and password that have to be stored somewhere.
    Usernames and passwords are secrets, but cannot be stored in the key vault since
    they are needed for accessing it. This problem of how to keep the key to the vault
    safe can be solved by using an Azure capability called *Managed* *Identity*.
  prefs: []
  type: TYPE_NORMAL
- en: The problem of securely storing secrets but getting another secret in return
    for accessing them is often referred to as the problem of *turtles all the way
    down.* This is an old anecdote to which a link is included at the end of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: With Azure Managed Identity enabled on an app service, Azure automatically generates
    a service principal with a non-retrievable username and password. Only at runtime,
    using specific code, can an application authenticate itself as this principal.
    Azure will ensure that this will only work for code that is running with the app
    service that the Managed Identity belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that an application can have its own identity, that identity has to be
    granted access to the key vault. This can be done in the key vault description
    in an ARM template, using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `reference()` function is used to retrieve the information
    of the Managed Identity and uses this to create an access policy on the key vault.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, with the key vault and access to it set up, the application has to
    retrieve the contents at start up time. To do this, config builders can be used.
    They are introduced with .NET Core 2.0 (and .NET Framework 4.7.1) and are used
    in the `StartUp` class, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: All types in this code example are available in the NuGet package, `Microsoft.Configuration.ConfigurationBuilders.Azure`.
  prefs: []
  type: TYPE_NORMAL
- en: Azure App Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another location for storing the configuration of applications is Azure App
    Configuration. This is a new service, and at the time of writing, still in preview.
    App Configuration allows for the creation of a central register of key-value pairs
    that can be used as configuration by such a register, but also multiple applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'App Configuration is another type of resource that can be created from the
    portal. The main component is a configuration explorer, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02417fea-c92b-4913-bea5-1998182362cd.png)'
  prefs: []
  type: TYPE_IMG
- en: In addition to the configuration explorer, there is a keys section for retrieving
    access keys that applications can use to read the configuration. There are also
    options to view recent changes to the configuration and restore earlier versions
    and for importing or exporting all configuration settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the App Configuration resource has been created and configuration keys
    added, they can be retrieved from within an application by using an extension
    method of the **IConfiguration** framework type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The loader for settings from an app configuration is part of the NuGet package, `Microsoft.Azure.AppConfiguration.AspNetCore`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to storing settings in Azure key vault, App Configuration has two
    downsides:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, the application needs to be configured with a connection string to
    the App Configuration, storing at least one new secret in the app settings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, App Configuration does not have access control options that are as
    rigid as key vault. For this reason, it might make sense to distribute configuration
    over both App Configuration and key vault, depending on the type of configuration
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concludes our discussion of Azure and Azure DevOps capabilities for infrastructure
    as code. The next section will discuss a series of other tools available that
    offer similar capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Other tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many other tools available for managing infrastructure and configuration
    through code. Next to the native Azure and Windows options discussed in the previous
    sections, there are many alternatives widely in use and some of them are listed
    in this section. It is important to know which tool can be used for which scenarios
    and how to integrate with them.
  prefs: []
  type: TYPE_NORMAL
- en: CloudFormation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CloudFormation is the IaC language for the AWS Cloud. CloudFormation templates
    can be written in either JSON or YAML format. One example of creating an AWS S3
    Storage Bucket that is publicly readable would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There is an extension available that allows the execution of CloudFormation
    templates on AWS from Azure DevOps. This extension provides tasks for creating,
    updating, or deleting AWS Stacks. A stack has a function that is comparable to
    a resource group in Azure and the tasks are comparable to the tasks for applying
    an ARM template.
  prefs: []
  type: TYPE_NORMAL
- en: Chef
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chef is a tool for CaC, with support for describing and enforcing the configuration
    of servers. Chef uses a centralized server, *Chef Server*, where all configuration
    for all servers is saved. Here, the correct desired state for every server is
    determined, which is then pulled by the *Chef Client,* an agent that runs on the
    *node* that is being managed.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the desired state for a server is done using a number of constructs.
    The lowest level is the recipe. A recipe contains one or more resources, built-in
    capabilities that can be used. An example resource is execute , which runs a bash
    command. Another example resource is `apt_update`, which provides the means to
    interact with the *apt* package manager. One or more recipes are combined in cookbooks,
    which describe a capability that can be assigned to a node. The assignment of
    one or more cookbooks to a node is done using the run list. The run list contains
    all cookbooks that have to be applied to a node.
  prefs: []
  type: TYPE_NORMAL
- en: Interaction with the Chef Server is done using a command-line tool called **knife**.
  prefs: []
  type: TYPE_NORMAL
- en: While the terminology is completely different, there are many conceptual parallels
    between PowerShell DSC and Chef.
  prefs: []
  type: TYPE_NORMAL
- en: Puppet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Puppet is a deployment and configuration management tool that operates using
    a server-client model. There is a centralized server called the **Puppet Master**
    that is responsible for taking in all of the desired state descriptions and compiling
    them to an intern catalog that holds the desired state for every managed server.
    All servers that are managed by Puppet need to have the Puppet agent installed
    on the local server. The agent connects to the server, to pull the state for the
    server it manages, and applies that locally. A managed server is called a node*.*
  prefs: []
  type: TYPE_NORMAL
- en: The base building block used by Puppet is called a **resource**. A resource
    is defined by specifying a resource type and a series of attributes. There are
    many resource types available, for example, for managing users and installed applications.
    Resources are grouped in one or more *classes.* These classes are, in turn, assigned
    to one or more nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Puppet can be installed on any Linux VM in Azure. There is also a pre-built
    image with Puppet Enterprise available in the Azure marketplace.
  prefs: []
  type: TYPE_NORMAL
- en: Puppet is comparable to Chef and PowerShell DSC. All three have a comparable
    model for describing the desired state and they all serve the same purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is yet another configuration management tool that is mostly used on
    Linux but also has support for Windows. One aspect that differentiates Ansible
    from other tools is that it does not have a centralized server that hosts all
    of the desired states, nor does it work with agents. All commands executed by
    Ansible are executed using SSH.
  prefs: []
  type: TYPE_NORMAL
- en: Any server can initiate the deployment of a *playbook* against one or more *items*
    in an *inventory.* An Ansible inventory contains all of the servers that can be
    managed by Ansible. They can be grouped into one or more groups, which can be
    nested into other groups as well. Each individual server and every group is an
    inventory item. In Ansible, the desired state is written in playbooks. A playbook
    is a series of tasks or roles that need to be run at the target server. A role
    is a group of tasks. Roles are intended to be reused in more than one playbook
    and should, therefore, be general enough to be useable in multiple situations.
    Roles should also be idempotent. This means that the tasks in the role should
    ensure that the outcome of running the playbook is the same, no matter the number
    of times it is run.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible scripts can be executed using command-line tools or an Azure DevOps
    extension that wraps this tool. There are also other management systems available,
    such as Ansible Tower, that provide a graphical user interface on top of the capabilities
    of the Ansible command-line tools.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Terraform is a multi-cloud infrastructure management solution. It is comparable
    to ARM templates, the difference being that it also supports Amazon Web Services,
    Google Cloud Platform, and other clouds. Terraform uses a custom file format for
    specifying one or more resources to be created using one or more providers. The
    resources correspond to the cloud resources, and the providers are responsible
    for knowing how to interact with the APIs of the different vendors.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, you can use a JSON format instead of the Terraform proprietary format.
    Terraform also supports the use of modules for creating packages that are reusable
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform configuration files are executed using command-line interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the concept of infrastructure and configuration
    as code, its value, and how to use it in practice. For implementing these, you
    learned about ARM templates, the IaC mechanism for Azure. You also learned about
    PowerShell DSC for managing the configuration of virtual machines and about different
    techniques for managing the configuration of your applications. Finally, you learned
    about several other tools available in the market. You learned which tool can
    be used in which situation and whether these tools can integrate with Azure DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, you are now able to start describing the infrastructure
    and configuration of your application(s) in source control using one or more of
    the tools you have read about. You are also capable of setting up the means to
    deliver the infrastructure using automation, either from a release pipeline or
    using dedicated infrastructure management tools. But no matter which solution
    you choose, you now have the capabilities to incorporate infrastructure into your
    DevOps processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, you will learn about another challenge you might encounter
    when implementing DevOps practices: databases. When increasing the speed at which
    features flow to production, you may also have to change the way you manage your
    database schema and how you apply changes. The next chapter will discuss this
    subject.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the Appendix:'
  prefs: []
  type: TYPE_NORMAL
- en: 'True or False: ARM templates can be used for creating, updating, and deleting
    Azure Resources.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is not an Azure Automation Account resource?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Run As account
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or False: One disadvantage of infrastructure as code is that you have
    to put sensitive information in source control as ARM template parameter files.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or False: Azure Automation Accounts allow for the execution of Powershell
    runbooks at a predefined schedule.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some of the benefits of using infrastructure as code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A formal breakdown of the ARM template structure and syntax can be found at
    [https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-syntax](https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-syntax).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The complete ARM Template reference can be found at [https://docs.microsoft.com/en-us/azure/templates/](https://docs.microsoft.com/en-us/azure/templates/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of all functions that can be used in ARM templates can be found
    at [https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-template-functions](https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-template-functions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about Azure Blueprints can be found at [https://docs.microsoft.com/en-us/azure/governance/blueprints/overview](https://docs.microsoft.com/en-us/azure/governance/blueprints/overview).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details about the WhatIf command for ARM templates can be found at [https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-deploy-what-if](https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-deploy-what-if).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many online references to the story of "turtles all the way down",
    but an early reference can be found digitized at [https://dspace.mit.edu/handle/1721.1/15166](https://dspace.mit.edu/handle/1721.1/15166).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reference including all Powershell DSC built-in resources can be found at
    [https://docs.microsoft.com/en-us/powershell/scripting/dsc/overview/overview](https://docs.microsoft.com/en-us/powershell/scripting/dsc/overview/overview).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about CloudFormation can be found at [https://aws.amazon.com/cloudformation/](https://aws.amazon.com/cloudformation/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about Chef can be found at [https://www.chef.io/](https://www.chef.io/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about Puppet can be found at [https://puppet.com/](https://puppet.com/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about Ansible can be found at [https://www.ansible.com/](https://www.ansible.com/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about Terraform can be found at [https://www.terraform.io/](https://www.terraform.io/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are links to Microsoft hands-on labs that can be used to get
    hands-on experience with the topics discussed in this chapter ([https://docs.microsoft.com/en-us/learn/modules/intro-to-governance/](https://docs.microsoft.com/en-us/learn/modules/intro-to-governance/)):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/learn/modules/configure-infrastructure-azure-pipelines/index](https://docs.microsoft.com/en-us/learn/modules/configure-infrastructure-azure-pipelines/index)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/learn/modules/provision-infrastructure-azure-pipelines/index](https://docs.microsoft.com/en-us/learn/modules/provision-infrastructure-azure-pipelines/index)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/learn/modules/protect-vm-settings-with-dsc/](https://docs.microsoft.com/en-us/learn/modules/protect-vm-settings-with-dsc/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
