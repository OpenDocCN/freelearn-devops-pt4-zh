- en: Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the last couple of years, containers have become a hot topic. They allow
    you to package any application, any tool, written in any language, and deploy
    it on a basic host or cluster. When implementing DevOps, containers can be of
    tremendous value. That is why DevOps and containers are often mentioned in the
    same breath. However, they are not the same thing. While DevOps is more of a cultural
    thing, containers are a type of technology, an alternative way of hosting your
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn more about containers and how they work. This
    is achieved by exercises wherein custom container images are created and run on
    different hosting platforms, such as Azure Container Instances and Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a container image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building images in Azure DevOps and running them in Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes in action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrading containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling containers and Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying to Kubernetes with Azure DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To experiment with the techniques described in this chapter, you need one or
    more of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Desktop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio 2019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Azure subscription
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Azure CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these are available for free or can be obtained for a limited period for
    free for evaluation purposes.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers are the evolution of virtualization. With virtualization, the resources
    of physical machines are shared among several virtual machines. Sharing those
    resources also means that all virtual machines have their own operating system.
    This is different when using containers. With containers, not only are the resources
    shared, but also the operating system kernel, making it very small in comparison
    with a virtual machine image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the operating system kernel is shared, containers are also very portable.
    Images can be deployed on any type of host environment that supports running containers.
    This works because all the application''s binaries and configurations are stored
    inside the container. As a result, environment variables outside the container
    do not impact the application. Naturally, there are a number of caveats, however:
    a container shares the operating system kernel; Linux containers can only run
    on a Linux operating system, and the same applies to Windows containers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Containers provide the ability to virtualize an operating system in order to
    run multiple workloads on a single operating system. This is visualized in the
    following diagram, where you can see the difference between regular hosting, virtual
    machine hosting, and containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d858e1dc-2312-4de8-b626-dffa43717c02.png)'
  prefs: []
  type: TYPE_IMG
- en: If you have ever heard of containers, you almost certainly have also heard of
    Docker. This is because Docker is one of the most well-known container engines
    that can be used for running containers. The next section will delve into DevOps
    and containers, while the remainder of the chapter will go into more technical
    detail regarding containers.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps and containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned in the introduction, DevOps and containers are not the same thing.
    Containers are the technology that makes DevOps easier. This is because containers
    have benefits that make them *the* perfect tool for DevOps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Consistent**: Because you build the container images, the hurdle of "<q>it
    works on my machine</q>" is eliminated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separation of concerns**: When using containers, your application will be
    distributed between separate containers, which makes it easier to maintain and
    separate the processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform**: The solution can be run on different platforms. It does not matter
    whether this is in Azure, on Amazon Web Services, or in an on-premises environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That aside, DevOps is more cultural than technical and, as mentioned in [Chapter
    1](889f9224-f1b6-414d-bc80-16563f66e1e7.xhtml), *Introduction to DevOps*, technical
    components are used to support DevOps. In the remainder of this chapter, we will
    focus on the technical side of things.
  prefs: []
  type: TYPE_NORMAL
- en: Hosting options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned previously, one of the benefits of containers is that they are
    extremely portable. This also means that containers can be hosted on numerous
    platforms and technologies.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the containers, there are a lot of options that will vary according
    to your use case. Some of these options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Azure App Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Service Fabric
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Swarm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Desktop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the demands of the application/container, it could run on all the
    options mentioned in the preceding list.
  prefs: []
  type: TYPE_NORMAL
- en: The images used to run containers (container images) also need to be hosted.
    These images are hosted in a so-called container registry. In a container registry,
    they are published privately or publicly. The two most well-know registries are
    the Docker Registry and the Azure Container Registry within the Azure platform.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have gone through some of the background information regarding containers,
    we are ready to go more deeply into the techniques behind containers and find
    out what is needed to create a custom container image.
  prefs: []
  type: TYPE_NORMAL
- en: Building a container image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will take you through the process of building a container image
    and executing it on your local system. To do this, we will first have to create
    an application and then add Docker support to it before we create an image and
    finally test it. So let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to test and check what is running on the container, an application
    is required. For this, a new application can be created or you can use an existing
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating a new application, the easiest option is to use the default ASP.NET
    Core website template within Visual Studio 2019\. Container support can be added
    in a few clicks. This is simply done by checking the Enable Docker Support box when
    creating the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f581ba6-9178-4957-9d4c-5c5d729a39a6.png)'
  prefs: []
  type: TYPE_IMG
- en: Keep the new application open or open your existing application. In the next
    section, we will investigate how Docker support can be added to an existing application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Docker support to an existing application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding Docker support to an existing application requires a couple of simple
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project/solution in Visual Studio 2019 and right-click on the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose Add and select Docker Support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0d2ac44e-3785-4c6a-a0a1-f8ea4fee799f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Depending on your client tools and Visual Studio configuration, there may also
    be a Container Orchestrator Support option. With this option, the cloud orchestrator
    of your choice can be chosen. In this sample, we used Docker because this format
    is supported by the major container orchestrators. Other cloud orchestrator options
    do exist, however:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Swarm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mesos Marathon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the cloud orchestrator used, a file is added to the project in
    the specific format for that orchestrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'By adding Docker support, a new file is added to the project named `Docker`.
    The Dockerfile is the specification of a container image. This file can be read
    by Docker, which sees it as instructions. The file is a text document that contains
    separate commands that can also be called within a command-line tool to assemble
    an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The example uses a technique called a multi-stage build file. This is because
    the file uses multiple `FROM` statements where there is a reference to a specific
    image.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to multi-stage build, it wasn't possible to use multiple `FROM` statements.
    During this time, it was hard to build efficient container images. Each statement
    in the file represented an additional layer on the image that resulted in it becoming
    larger and larger.
  prefs: []
  type: TYPE_NORMAL
- en: During this build process, it was also necessary to remove any components that
    were required during this process. For this reason, it was very common to have
    separate Dockerfiles for development and production.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, the Dockerfile comprises instructions and the most commonly used
    instructions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**FROM**: The `FROM` command is used to specify on which operating system or
    base image the image will be based. In the example, the `mcr.microsoft.com/dotnet/core/aspnet:3.0-buster-slim` image is
    used for the production version of the application, and the `mcr.microsoft.com/dotnet/core/sdk:3.0-buster` image is
    used to build the image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RUN**: The `RUN` command is used to install components or perform operations
    during the build process of the container image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ENTRYPOINT**: The `ENTRYPOINT` command specifies what the entry point for
    a container image needs to be. In the example, the entry point is specified as
    a `.NET` application that references the library that was built during the compilation
    process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we've created our application and added Docker support. Next, we'll
    see how to create an image with the application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an image with the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to create a Docker image, Docker Desktop needs to be installed,
    as Visual Studio uses this to construct the image. With a complete Dockerfile,
    the image can be built using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click the Dockerfile in Visual Studio and select Build Docker Image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0ce5d270-2179-4c01-ac0a-762951e38fb0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'During the compilation and building of the image, take a look at the output
    window. Looking at it will provide more insights into the layered approach of
    container images. This layered approach is visible via the steps shown in the
    output window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/29d6b0f6-569c-4a6d-ae76-57c9b95a4097.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Docker Desktop also makes it possible to run and store images locally. After
    building the image, open a Terminal and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The command displays all images currently on the machine. In this list, the
    base images that are downloaded during the creation of images are also listed.
  prefs: []
  type: TYPE_NORMAL
- en: Running the container image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The container image can be started locally by running it within Docker. As
    we now have a container image, a container can be created:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following `docker container run` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will start the container image specified at the end of
    the command. In addition, different arguments are specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Publish**: The `publish` argument opens a port from the host to the container.
    As mentioned in the example, this will open port `8123` and will route traffic
    to port `80` within the container.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Detach**: The `detach` argument will run the container in the background
    and print out its specific ID.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Name**: The name for the container within Docker.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To list all running containers, use the `docker ps` command within the Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the container running, open a browser and navigate to `http://localhost:8123`.
    If everything works fine, this should show a default ASP.NET Core web page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d0e39e85-3964-47f4-a1e4-4d2ffc71ad49.png)'
  prefs: []
  type: TYPE_IMG
- en: Since building stuff locally and running it on your machine is not really the
    DevOps way of thinking, we will move to a different hosting platform in the upcoming
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Building images in Azure DevOps and running them in Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To support continuous integration and continuous delivery, the source files
    need to be shared in a repository. So, let''s share the resources in Azure Repos
    and try to build our container by using Azure Pipelines. After building the container
    image, a place to store the images and run the container are also required. Within
    the Azure platform, there are two perfect services for this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Container Registry**: This service is a managed private Docker registry
    based on the open source Docker Registry. Here, you can maintain and register
    container images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Container Instance**: The Azure Container Instance, also referred to
    as ACI, is a solution for running isolated containers without a lot of management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the simplicity of this guide, the files are already added to the repository
    and the Azure resource is already created.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As already discussed within the book, connections within Azure DevOps with external
    services such as Azure and container registries are configured within a service
    endpoint. Because the image needs to be available in order for Azure Container
    Instances to retrieve it, it needs to be published to a container registry. The
    connection from Azure DevOps to the registry is configured within a service connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to configure the service connection:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Azure DevOps project, open the project settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the project settings, click on Service connections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the service connection overview, click on Create service connection and choose
    Docker Registry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the fly-out that appears, fill in the correct information and save the connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7895daf8-24f3-4591-8a3c-5d24d6ffff52.png)'
  prefs: []
  type: TYPE_IMG
- en: Saving the connection will add a service connection to the project that can
    be used by the pipelines we will create, or that you will create in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to start building the container image and publish it to the registry,
    we will create a new pipeline. For this example, we will make use of the YAML
    pipeline experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to get started with the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: Open you Azure DevOps project and click on Pipelines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the pipelines overview, click on New Pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select Azure Repos Git, choose the correct repository, and then choose the
    Starter pipeline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4968a66e-f56a-4855-8f58-6ad821fed19b.png)'
  prefs: []
  type: TYPE_IMG
- en: From the starter pipeline, remove the two dummy script tasks and open the assistant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the assistant, search for the `Docker` tasks and add the tasks to the pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the service connection created for the container registry and keep the
    other information as the defaults.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure to change the `buildContext` property of the tasks to point to the
    correct directory. This is required for Docker to be able to reference the correct
    paths when building your image.
  prefs: []
  type: TYPE_NORMAL
- en: 'When added, the YAML should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Save and run the pipeline. After the first run, the container image is created
    and published to the container registry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The images in the container registry can be retrieved by using a predefined
    URL. This URL comprises a few specific components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[container registry]/[repository]:[tag]`:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container registry**: The base URL of the container registry.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repository**: The repository as specified during the process of publishing
    the image.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tag**: The tag for the specific version of the image. By default, the Docker
    tag used is `BuildId`.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have a reference to the container image, Azure Container Instances
    should be able to retrieve the container and run it. The only thing needed for
    this is an Azure CLI command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the reference to the image is different for each build (`BuildId` for
    the tag value), `BuildId` is retrieved in the Azure CLI command via the `$(Build.BuildId)` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To execute the preceding script, the Azure CLI task is added to the pipeline.
    In this task, we configure the correct subscription via the service endpoint and
    set the inline script.
  prefs: []
  type: TYPE_NORMAL
- en: The script will create a container instance in the `aci-rg-devops` resource
    group with the name `aci-demo-app` and retrieve the `azuredevops` container image
    from the `msftazuredevops.azurecr.io` repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete YAML for this task looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this pipeline will result in an Azure Container Instance in Azure.
    That container will be running the exact same application that was running locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55aa2959-0840-41e1-b4d4-63b1bb725ad6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When opening the Azure Container Instance in the Azure portal, you will see
    that it is a running instance and that there is an FQDN attached to the Azure
    Container Instance based on the value supplied, `dns-name-label`, within the Azure
    CLI command, `aci-msft-demo.westeurope.azurecontainer.io`. Open the URL in your
    browser and see the application we have pushed to the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb1fd6f7-038f-4ce1-9933-b9ffdf6cbd7a.png)'
  prefs: []
  type: TYPE_IMG
- en: It shows the same content as the container that was started locally. This is
    because, in both places, the same container image was started.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we started the container on Azure Container Instances, but
    how will we manage running containers and restart them when there are problems?
    This is where Kubernetes comes in.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes is another service for running your containers. Kubernetes is a cluster
    orchestration technology first developed by Google. It is now an open source platform
    for automating deployment, scaling, and operations of application containers across
    clusters of hosts, thereby providing a container-centric infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Functionalities of Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, containers offer you a great way to package your applications.
    When running the applications, you need to make sure that applications keep running
    and this is where Kubernetes comes in as it has the following core functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Service discovery and load balancing**: How a container is exposed is controlled
    within Kubernetes and, in addition, it is also capable of balancing the traffic
    within the orchestration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage orchestration**: The ability to mount different kinds of storage
    providers to the platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rollouts and rollbacks**: Kubernetes can automatically create and restart
    containers for the specified deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Self-healing**: Kubernetes can heal containers when they are failing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secret and configuration management**: Kubernetes has a built-in functionality
    to manage secrets such as tokens, passwords, and keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to provide these functionalities, Kubernetes consists of a number of
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes core components and services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes consists of a few core components that make it run. These components
    together make a great and stable product for running and managing containers.
    The next few subsections will go over each of these components individually.
  prefs: []
  type: TYPE_NORMAL
- en: Master node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the important components within Kubernetes is the master node. The node
    manages the cluster. It contains all the Kubernetes core components in order to
    manage the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kube-apiserver`: A component for exposing the Kubernetes API. This API is
    used by management tools of Kubernetes, such as `kubectl`, and the Kubernetes
    dashboard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`etcd`: Used to maintain the state of the Kubernetes cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kube-scheduler`: A component that selects nodes for the pods to run on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kube-controller-manager`: The controller manager oversees a number of smaller
    controllers that perform actions such as replicating pods and managing node operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using these components, the master node can maintain the desired state for
    the cluster. It is good to know that when you are interacting with Kubernetes,
    you are communicating with the master node. The master node itself will then communicate
    with the other components within the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Regular nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These nodes are the nodes that will run the containers. These can be virtual
    machines or even physical machines. On these machines, the so called `kubelet`
    is installed. `kubelet` is the agent that's used to run pods/containers within
    the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed in the preceding sections, there are also other core
    services within Kubernetes and we will discuss these next.
  prefs: []
  type: TYPE_NORMAL
- en: Pod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within Kubernetes, pods are used to run the applications. Within the pods, it
    is specified which resources are required to run the application. The scheduler
    (`kube-schedular`) within Kubernetes checks where to run the application depending
    on the demands and the nodes coupled to the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Pods themselves have a limited lifespan and are removed when new versions are
    deployed or, for example, when a node fails, pods can be replaced by pods on the
    same or another node.
  prefs: []
  type: TYPE_NORMAL
- en: Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The service is sometimes also referred to as the load balancer and is used to
    provide a logical grouping of pods and furnish them with connectivity (a way to
    connect).
  prefs: []
  type: TYPE_NORMAL
- en: 'Three major services are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cluster IP**: Adding an internal IP to a cluster of pods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node port**: Port mapping to the underlying node directory to connect to
    the application/pod with the IP address of the node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load balancer**: This service adds a load balancer resource and configures
    an external IP address on the load balancer. On the external side, the load balancer
    will route traffic to the specific nodes based on the rules configured in the
    load balancer and internally to the correct pod.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these services, the internal and external connections for pods are arranged.
    The services and pods are all specified within a deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A deployment describes the desired state of an application. It describes the
    number of replicas, but also the update strategy. Kubernetes will track the health
    of the pods and will remove or add pods when needed to comply with the desired
    state that is described in the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: These deployments are specified in a YAML file. For example, when running a
    container in Kubernetes, you must specify a replica set. A replica set ensures
    that a specified number of pod replicas are running at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: Operation of Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you are new to containers, and especially to Kubernetes, it is hard to
    figure things out immediately. However, to aid your understanding of the concept,
    take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efb2bde7-c6dd-48c6-9261-6377d9728cfc.png)'
  prefs: []
  type: TYPE_IMG
- en: Deployments of containers to a Kubernetes cluster are defined in the so-called
    deployment file (**1**). In these deployment files, the desired state of the application
    is described. This desired state is described as a YAML file.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the desired state is a load balancer service and three pods
    (**2**). These pods are divided by the Kubernetes API on the nodes that run the
    containers (**3**). The service defined in the deployments file ensures that the
    traffic is routed to the specific pods. The deployment can be changed by updating
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The scheduler can also change deployments when, for example, automatic scaling
    is configured for the application. In that kind of scenario, a fourth pod could
    be added to the cluster. In the service, there can also be an external load balancer
    to route traffic to the internal load balancer of Kubernetes (**4**).
  prefs: []
  type: TYPE_NORMAL
- en: Azure Kubernetes Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Azure Kubernetes Service**, or **AKS**, is the Microsoft implementation of
    Kubernetes. Setting up a regular Kubernetes cluster is a lot of work, but with
    AKS, it has been made easier. This is because Kubernetes is a managed platform
    and the reason why almost all operational tasks are handled by the platform itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some key functionalities of AKS are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Azure manages critical tasks, such as health monitoring and maintenance, including
    Kubernetes version upgrades and patching.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure performs simple cluster scaling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The master node of Kubernetes is fully managed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Master nodes are free, and you only pay for running agent nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using the AKS, a Kubernetes cluster can be operational within minutes. Besides
    that, the focus will be on the application as the master node is fully managed.
    Now, let's try to run a Kubernetes cluster with custom images.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first few sections of this chapter, we created a container and deployed
    it to an Azure Container Instance. Let's now deploy this container to a Kubernetes
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a cluster can be done via the Azure CLI or an ARM template. For ease
    of demonstration, the Azure CLI is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, a new resource group needs to be created to host the Azure Kubernetes
    cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can create our Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Kubernetes cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the resource group is created, a new Kubernetes cluster can be added to
    the group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a new Kubernetes cluster with the name `mykubernetescluster` and
    with a single node. This means that there will be one virtual machine created
    in the Azure portal that is configured as a node for the Kubernetes cluster. In
    addition, the monitoring add-ons will be enabled on the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The creation of this cluster will take a couple of minutes. In Azure, the `mykubernetescluster` service
    will be created in the specified resource group. Alongside this resource group,
    another group will be created by the Azure platform itself.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this resource group, all virtualized infrastructure that is needed to run
    the cluster is created. This also means that in the future, new components can
    be added to this resource group depending on the demands of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/557e2c0d-fe12-4e28-a57e-7eaaaf033bb1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the resource group created, you will find all the resources as mentioned
    to run the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d9d45c5-bb83-437e-b183-bf2588a7b9ef.png)'
  prefs: []
  type: TYPE_IMG
- en: With the Kubernetes infrastructure now up and running, the management and deployment
    of resources can begin.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To manage Kubernetes, the `kubectl` command line is used and installed locally
    (or used in the Azure cloud shell). This is command-line interface tooling that
    will communicate with the Kubernetes API. Let''s see how to work with Kubernetes
    with this command line:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not already have it installed, run the following command to install
    the Azure CLI on your machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To connect to the cluster, the credentials need to be retrieved and saved to
    the local system. This can be done by using the `az aks get-credentials` command and
    specifying the resource group and cluster name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With all the prerequisites configured, a lot of the base functionality can
    be run against the Kubernetes cluster. Take a look at these two commands for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Retrieve the nodes of the cluster:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the pods in the cluster:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next to the preceding commands, you can also try the following Azure CLI command
    to open up the Kubernetes dashboard. This dashboard is a management interface
    built on top of the Kubernetes API that can be used next to the `kubectl` command
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The dashboard is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae230049-85ac-4017-b74a-cb55061420ee.png)'
  prefs: []
  type: TYPE_IMG
- en: A deployment file needs to be created to be able to run containers within the
    cluster. So let's see how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a container image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a deployment file and deploy it to Kubernetes. To do this, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a new file in your favorite text editor and call it `deploy.yaml`. Add
    the following information to the `deploy.yaml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the following is specified:'
  prefs: []
  type: TYPE_NORMAL
- en: A deployment is created with the name `kubernetes-deployment` (`metadata.name`).
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The deployment will create three replicas of the specified container (`spec.replicas`).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The selector, in combination with the labels tag, is used to specify which components
    this deployment file will manage within Kubernetes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The deployment file will create a container for the `msftazuredevops.azurecr.io/azuredevops:586` image
    file.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To deploy this file to Kubernetes, we will again use the `kubectl` command
    line and make use of the `apply` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `-f` argument is used to specify that a local path is used as a reference
    to a deployment file. After executing the command, you can open the Kubernetes
    dashboard to see the status and maybe even observe errors.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible that you encounter an error stating that pulling the image from
    your location failed. This could be a security issue. Under the hood, AKS is using
    a service principal. You should also see this when creating a new Kubernetes cluster.
    Make sure to give this service principal access rights on the Azure registry.
  prefs: []
  type: TYPE_NORMAL
- en: Following a successful execution, try the `get pods` command to see whether
    there are three pods within the system. If everything proceeded correctly, there
    should be three pods running within Kubernetes, but the application is still not
    available to the outside world.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make it available, we need to add a service to the deployment file.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to add it to the same file, add a line with these characters, `---`,
    between the deployments. This is not required when you also define separate files
    for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `deploy.yaml` file, add the following section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This YAML section creates a load balancer and attaches it to the specified selector
    (`spec.selector.app`), meaning it will be used for the pods as we previously specified.
  prefs: []
  type: TYPE_NORMAL
- en: In the background, Kubernetes will create an Azure load balancer and a public
    IP for connection to the pods.
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve the external IP address of the service, use the following command
    until it displays the external IP address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will return all services and their external IP addresses if it is present.
    Also take a quick peak at the additional resource group of Kubernetes to see which
    Azure resources are created.
  prefs: []
  type: TYPE_NORMAL
- en: Well done! In this section, you learned how to create a Kubernetes cluster and
    deploy a container image on it via `kubectl` and deployment files. In the next
    section, we will take this forward and learn how to upgrade these containers.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Kubernetes, applications are very easily updated. For this, Kubernetes uses
    rolling updates, which means that traffic to a container is first drained before
    the container is replaced. During an upgrade of the application, Kubernetes will
    deploy an additional pod and run it through some specified probes.
  prefs: []
  type: TYPE_NORMAL
- en: A probe is a diagnostic that is periodically performed on a pod to check its
    status. During the upgrading or creation of a pod, Kubernetes brings up the additional
    pod and makes sure that it passes the liveness and readiness probes.
  prefs: []
  type: TYPE_NORMAL
- en: If the newly created pod succeeds with both probes, the traffic to a single
    old pod is terminated and traffic to the new pod is opened. For this termination,
    Kubernetes uses a termination grace period. During this period, the 2 connection
    to the load balancer is stopped and active connections are processed successfully,
    and new traffic is routed to a running pod. The default grace period is 30 seconds,
    during which the pod will be in a termination state and all old traffic to this
    pod is redirected to the other pods.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process continues until all pods are replaced with the new version. All
    of this is default behavior within Azure Kubernetes. A deployment is simply triggered
    by adjusting the deployment file and applying it with the same command as used
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, `httpGet` probes are added to pods that are being exposed, but
    they can also be customized by adding the readiness probe or liveness probe to
    the deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This readiness probe performs an `httpGet` request on the pod and has the following
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`path`: The path it should call for the `httpGet` request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`port`: The port number it should use for the call. This is also configured
    in our deployment file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initialDelaySeconds`: The seconds it waits before running the probe once the
    container is started.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`periodSeconds`: The number of seconds the probe waits before it times out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`successThreshold`: The amount of success required for the probe minimum value
    is `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As mentioned, a deployment has a default rolling upgrade scenario configured.
    The configuration of the rolling deployment can be retrieved by using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you are interested in doing so, build a new version of your container and
    upgrade it within Kubernetes. Before running the upgrade, make sure you have the
    dashboard open and refresh the page during the update and you will see extra pods
    coming up and old pods being terminated.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to upgrade containers, which will help you stay
    up to date with the latest version. Moving forward, in the next section, we will
    look further into the scaling of containers and Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling containers and Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the demand for your application may grow, you will need to scale the application.
    Scaling the application can be done in multiple ways and different components
    can be scaled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ba82303-be6e-4768-9396-6f29a7de1f2a.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows you the different ways to scale your application
    or cluster, which we will discuss over the upcoming subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling pods manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pods can easily be scaled by updating the number of replicas. Try getting your
    pods by using the `kubectl get pods` command and increase the number of replicas
    by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With this command, the pods are scaled up or down depending on the number of
    replicas. The up or specified scaling is down as per deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Autoscaling pods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Kubernetes also supports autoscaling. The scheduler will then update the
    number of pods depending on CPU utilization or other metrics that are available.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes uses the metrics server for this. The metrics server collects metrics
    from the summary API of the kubelet agents that run on the nodes within the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The metrics service is available by default if you are using Kubernetes version
    1.10 or above. If you are using an older version, you will have to install the
    metrics server manually.
  prefs: []
  type: TYPE_NORMAL
- en: The autoscale functionality also requires some configuration on the deployment
    side of Kubernetes. For a deployment, you need to specify the requests and limits
    for the running container. These values are specified for a specific metric, for
    example, the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, there are requests and limits specified for the CPU
    metric. The CPU metric is measured in CPU units. In Azure, one unit stands for
    one core. For different platforms, it can have a different meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This part can be added to the container in the deployment file and this will
    make sure that the pods can be autoscaled when large numbers of requests need
    to be served.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the updated deployment file, deploy it and make an autoscale rule within
    the Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This rule will update the deployment with autoscale functionality. If average
    CPU utilization across all pods exceeds 60% of their requested usage, the autoscaler
    increases the pods up to a maximum of 10 instances. A minimum of one instance
    is then defined for the deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the autoscaler, you can check it by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '**HPA** stands for **horizontal pod autoscaler**.'
  prefs: []
  type: TYPE_NORMAL
- en: Try creating a CPU-intensive operation within an application and checking automatic
    pod creation during execution. The Kubernetes cluster will notice the significant
    amount of CPU usage and will scale out the cluster automatically by creating multiple
    pods.
  prefs: []
  type: TYPE_NORMAL
- en: Once the intensive operation is finished, Kubernetes will scale the number of
    pods down to the minimum.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Alongside scaling pods, Kubernetes can also scale the number of nodes that
    run within the Kubernetes cluster. The number of nodes can be scaled using the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, get the information pertaining to the current environment by requesting
    the number of nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use this command to update the `nodepool`. Extract the name of the `nodepool`
    from the result of the last command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Scaling the number of nodes up can increase the performance drastically. This
    will also make the cluster more expensive. By scaling the number of cluster nodes
    down, costs can decrease and you are only using the resources that are actually
    required by your application. To keep track of this, the nodes can also be autoscaled.
  prefs: []
  type: TYPE_NORMAL
- en: Autoscaling nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Alongside the manual scaling of nodes, nodes can also scale automatically by
    updating the Kubernetes cluster. This can be done by using the `az aks update`
    command. With this command, you can set the minimum and maximum node counts. The
    autoscaler will then make sure that nodes are created when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Azure Kubernetes also has the option to scale out with Azure Container Instances.
    To use this option, a specific configuration needs to be applied when creating
    the AKS cluster. This is mainly required because Azure Container Instances needs
    a specific subnet within the virtual network.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned to scale containers and the cluster to drastically
    increase performance. Next up is deployment from Azure DevOps to facilitate continuous
    deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to Kubernetes with Azure DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen a lot of options for deploying and configuring the Kubernetes cluster
    via the command line. When working with DevOps, however, changes need to be applied
    in a continuous way.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, there is the Kubernetes manifest task within Azure DevOps, which
    contains a lot of functionalities to manage a Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the following is configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '`action`: The kind of action to we want to perform. In this example, the `deploy` action
    is used because we want to deploy/apply a deployment file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubernetesServiceConnection`: The service connection to the Kubernetes cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`manifests`: The path to the manifest file. As we are using the `deploy` action,
    this should be a reference to the deployment file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`containers`: A special field where you can override the version of the container
    being deployed. By specifying the above, every image is specified in the deployment
    manifest with the `msftazuredevops.azurecr.io` reference and the `azuredevops` repository is
    replaced by the new value as configured in this field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a Kubernetes destination environment within Azure DevOps pipelines also
    has the advantage of seeing the environment running within Azure DevOps. This
    will show the number of running pods within the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try it out with the following stage configuration for a build that will publish
    the deployment files to the artifact location of Azure DevOps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next to the build stage, add the following release stage. Following the initial
    execution of the pipeline, a new environment will be available within Azure DevOps.
    In the environment created by the release, attach the Kubernetes cluster to see
    information on the running pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the example, two stages are specified for a multi-stage pipeline. The first
    stage will build the container image via the Docker task and publish it to a container
    registry. After publishing the image, it also publishes a number of build artifacts,
    in this case, the Kubernetes manifests.
  prefs: []
  type: TYPE_NORMAL
- en: The second stage deploys to a specific environment called Kubernetes. This environment
    will also be created in Azure DevOps if it has not already been added. During
    the remainder of the process, it retrieves the published artifacts of the build
    stage and uses the Kubernetes manifest task to deploy the Kubernetes resources.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned what containers are and how they relate to
    DevOps. Where DevOps is more of a cultural thing, containers are a way to support
    it technically. You have also learned how to create container images via a Dockerfile,
    and specifically by using a multi-stage build file. Finally, we dived into Kubernetes,
    where we learned a way to host containers and also manage the running containers
    by using the `kubectl` command.
  prefs: []
  type: TYPE_NORMAL
- en: Using the knowledge acquired in this chapter, you are now able to deploy applications
    to Kubernetes and make sure that it scales with the number of requests it receives.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn more about facilitating the DevOps process
    by using Azure DevOps. You will learn what works for your organization and team
    and what doesn't and how to implement that structure and your approach using Azure
    DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding the material covered in this chapter. You will find the answers in the
    *Assessments* section of the Appendix:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the benefits of containers for DevOps?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: A specific container can be hosted on different platforms (Azure/AWS).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it possible to add container support to an existing application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `RUN` command used for within a Dockerfile?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kubernetes can be scaled on different components. What are these components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Information on installing the Azure CLI: [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Information on installing Docker Desktop: [https://docs.docker.com/docker-for-windows/install/](https://docs.docker.com/docker-for-windows/install/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information on Kubernetes: [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find more information regarding Azure Kubernetes at the following link:
    [https://azure.microsoft.com/en-us/topic/what-is-kubernetes/](https://azure.microsoft.com/en-us/topic/what-is-kubernetes/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Information on Azure Container Registry: [https://docs.microsoft.com/en-us/azure/container-registry/container-registry-intro](https://docs.microsoft.com/en-us/azure/container-registry/container-registry-intro)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information regarding multi-stage builds: [https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
