<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Planning Your Azure DevOps Organization</h1>
                </header>
            
            <article>
                
<p>In the previous chapters, you learned about many techniques and practices concerning DevOps. In this chapter, we will take a step back and look at how you can build a strong DevOps organization and what you need to think about when doing so. Next, you will learn what this can bring you with regard to security and traceability. From there on, you will learn how you can consolidate your toolchain, standardizing on Azure DevOps.</p>
<p>We will begin by creating an Azure DevOps organization where you will learn which constructs are available to lay out your products and teams in the tool. You will also learn about licensing and the security implications of the different approaches. Next, you will learn about traceability and how that can be used to create a verifiable software development process. Next up is the consolidation of the tools used. As you progress on your DevOps journey, you may find that each team uses different tools that it is familiar with and enjoys working with. While DevOps is all about empowering people, some level of standardization might be desirable, and you will learn how to go about this. Finally, you will read that you might have to accept that you will never be completely done adopting DevOps.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Setting up an Azure DevOps organization</li>
<li>Ensuring traceability</li>
<li>Consolidating tools</li>
<li>Accepting there is no end state</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To follow along with the practical parts of this chapter, one of the following is needed:</p>
<ul>
<li>A Microsoft Live account, also called a personal account</li>
<li>A work or school account</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up an Azure DevOps organization</h1>
                </header>
            
            <article>
                
<p>To practice with one or more of the technologies and techniques described in the previous chapters, an Azure DevOps organization might have been created specifically for this use, or maybe one was available already that could be used for this purpose. However, creating an organization for a company from scratch takes a little more consideration. Taking the time to properly plan the layout of the organization can save a lot of time later on.</p>
<p>This section describes the components out of which Azure DevOps is built, how you can use this to organize a fitting security model, and licensing options and costs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How Azure DevOps is organized</h1>
                </header>
            
            <article>
                
<p>The top-level construct in Azure DevOps is called an organization. For most companies, a total of one organization will suffice, but it is allowed to create more than one.</p>
<p>Each Azure DevOps organization is hosted in a specific region. Most of the data (source code and work items) for the organization is guaranteed to be located in the region for the organization, but some information is always stored in other data centers due to the global reach of the service. Having a distributed organization with teams and products in different geographies can be one reason for using more than one organization. For example, if some teams are located in Australia and some in West Europe, it makes sense to create two separate organizations and host all teams in the geography closest to them. This will locate the bulk of the services that are physically close to them, greatly reducing latencies when working with Azure DevOps.</p>
<p>An organization can be linked to an <strong>Azure Active Directory</strong> (<strong>AAD</strong>). If this link is enabled, only users that are inside that particular AAD are allowed access to the organization. Using a company AAD is not mandatory; an organization can also be created using a Microsoft account.</p>
<p>In each organization, one or more projects can be created. A project is an isolated container of work items, source control repositories, pipeline definitions, and all other Azure DevOps artifacts. There are only limited sharing and linking possibilities between projects. At the time of writing, only work items can be related across projects and nothing else can. This way, projects can serve as a strong isolation boundary for enforcing rigid security between products or teams if needed. In general, it is recommended to have as few projects as possible, with the goal of having only one if possible.</p>
<p>The following diagram shows a possible organization of Azure DevOps organizations and projects. It shows that there are two organizations connected to the Azure Active Directory. One is located in West Europe, and the other one in Australia. In West Europe, there are two projects in the organization, in Australia just one:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-960 image-border" src="assets/5f5fdac9-331b-42cf-86f6-8803b11a314a.png" style="width:21.50em;height:16.25em;"/></p>
<p>As stated before, the recommendation is to go with as few organizations and projects as possible. But in this example, the latency from Australia to West Europe is a good argument to split into two organizations to have Azure DevOps hosted close to the teams. The split into two projects in West Europe might be due to the need for a high level of isolation for team 4 that is working on product 3.</p>
<p>Combining the teams 1 to 3 and products 1 and 2 into one project has been done on purpose. The reason for this is that within a single project, multiple product areas and multiple teams can be defined. Having all of these in a single project enables easy linking of work items to do portfolio management. This way, working items from one team can also be related to the commits or pull requests of another team on another product. This is helpful if features are spread over multiple products or applications (components).</p>
<p>To make defining all products and all teams in a single project possible, it is important to know about the Azure DevOps security model and how to use this for implementing access control.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an Azure DevOps organization and project </h1>
                </header>
            
            <article>
                
<p>Creating a new Azure DevOps organization and one or more projects is a task often completed by administrators that will also be responsible for managing these environments later. These organizations are most likely connected to an Active Directory. To create an organization for private use or training and learning practices, it might be better to use a personal account.</p>
<p>To create a new organization using a personal account, do the following:</p>
<ol>
<li>Navigate to <a href="https://dev.azure.com">https://dev.azure.com</a>.</li>
<li>Choose <span class="packt_screen">Start free</span>, to start the creation of a new Azure DevOps organization.</li>
<li>When prompted with a login dialog, log in using a personal account.</li>
<li>After logging in, select the correct country of residence and opt in/out of tips and other service updates using the following dialog:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/94d4e59c-4d32-4665-8188-6542147ea8af.png" style="width:27.50em;height:28.75em;"/></p>
<ol start="5">
<li>Press <span class="packt_screen">Continue</span> to create a new organization.</li>
</ol>
<p>Once the organization is created, a new wizard will automatically start creating the first project. To create the project, do the following:</p>
<ol>
<li>Provide a project name.</li>
<li>Choose between making the project public or private. Private projects are the default setting and are intended to create software within an organization and not allow anonymous access. Public projects are intended for open source development.</li>
</ol>
<p>Once a new organization and a new project are created, it is possible to make changes to these choices using the management interface.</p>
<div class="packt_infobox">Please keep in mind that renaming the organization or a project will change URLs, so all existing integrations and links may break.</div>
<p>It is even possible to change the location of an organization later. This must be requested and is not as easy as changing other settings. A link to the documentation on how to do this is included at the end of this chapter.</p>
<p>Once an organization and project are available, it is time to set up security.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Azure DevOps security model</h1>
                </header>
            
            <article>
                
<p>Within Azure DevOps, authorizations can be assigned to individual users or to security groups. The security group is either a logical wrapper around an existing AAD group or can be defined within Azure DevOps itself. In general, it is recommended to assign authorizations as much as possible to groups and limit individual user assignments.</p>
<p>To configure the authorizations for a user or security group, two complementary approaches are available:</p>
<ul>
<li>Organization- and project-level authorizations</li>
<li>Object-level authorizations</li>
</ul>
<p>When working with the on-premises product, Azure DevOps Server, there are also server-level security groups and settings available.</p>
<p class="mce-root"/>
<div class="packt_infobox">In Azure DevOps services, an organization is called a project collection and a project is called a team project. Sometimes, these names are also visible in Azure DevOps.</div>
<p><strong>Organization-and project-level authorizations</strong>: To allow a user to perform a specific action on every object of a certain type, an organization- or project-level authorization can be set. As an example, look at the built-in groups, <kbd>Project Collection Build Administrators</kbd>, respectively, <kbd>[ProjectName]\Build Administrators</kbd>, which, by default, have permission to view, manage, and edit build definitions and build resources. The permissions that can be set on the organization and project level are automatically applied to all individual resources in the organization or the project.</p>
<p><strong>Object-level authorizations</strong>: On most of the objects in Azure DevOps, individual permissions can be assigned to users or groups. These permissions are set using an <strong>Access Control List</strong> (<strong>ACL</strong>) on the object itself. The following example shows a classic build definition:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1102 image-border" src="assets/6db26de9-28e8-4637-9eeb-f0dbb035e864.png" style="width:63.83em;height:31.00em;"/></p>
<p>For each group, for each action, it is possible to configure <span class="packt_screen">Allow</span>, <span class="packt_screen">Deny</span>, <span class="packt_screen">Not set</span>, or <span class="packt_screen">inherited</span>. When an action is configured with <span class="packt_screen">Deny</span>, access is never allowed, not even if a user is part of a group that has the authorization specified as <span class="packt_screen">Allow</span><strong>.</strong> In other words, when there are two conflicting assignments (<span class="packt_screen">Allow</span> and <span class="packt_screen">Deny</span>), <span class="packt_screen">Deny</span> will take precedence over <span class="packt_screen">Allow</span>. <span class="packt_screen">Not set</span> is to be interpreted as an implicit deny that does not take precedence. In other words, when there are two conflicting assignments (<span class="packt_screen">Not set</span> and <span class="packt_screen">Allow</span>), the user will be allowed access.</p>
<p>Some artifacts in Azure DevOps are part of a hierarchy. For example, pipelines can be in a folder. Whenever inheritance is enabled, permissions from higher in the hierarchy will propagate to the artifact. This means that, when a user has access to a pipeline folder, all of their rights will propagate to all underlying folders and pipelines, if and only if, there are no more specific authorizations set.</p>
<p>While the security model determines which authorization a user has, user actions are also limited by their assigned access level, which follows from their license.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Azure DevOps licensing</h1>
                </header>
            
            <article>
                
<p>Another aspect of creating an Azure DevOps organization is managing licenses. Within Azure DevOps, every user needs to have an access level assigned before they can log in to the product. There are three access levels defined:</p>
<ul>
<li><strong>Stakeholder</strong>: Stakeholders are free users who can log in to the product but have limited access to its features. Stakeholders can manage work items, manage pipelines, and view dashboards. They do not have access to any of the other product areas, making this license level usable for non-development roles only.</li>
<li><strong>Basic</strong>: Basic users have a paid license that gives them access to all parts of the product, except for test management and advanced test execution functionality. A basic user license is priced at € 5.06 per month at the time of writing.</li>
<li><strong>Basic and Test plans</strong>: Users of the Basic and Test Plans license option have access to all parts of Azure DevOps. They have the same access as basic users, but are also provided with test management and tools for user acceptance testing, test execution, and test result reporting. At the time of writing, the Basic and Test Plans license option is priced at € 43.86 per month.</li>
</ul>
<p>The first five basic licenses for every organization are free. This means that experimenting with the product and learning it can be done without incurring any costs. Additionally, Visual Studio subscribers can also get free licenses. Professional subscribers get a free Basic license and Enterprise subscribers get a free Basic and Test Plans license.</p>
<p>Licenses can be assigned and re-assigned at any point, so for a company or team with many joiners and leavers, it is not necessary to buy more licenses then they have people active at any given point.</p>
<p>Licensing costs are not the only costs that come from using Azure DevOps; it is important to also know about the pay-per-use costs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Consumption-based costs</h1>
                </header>
            
            <article>
                
<p>Licenses give users access to the product and, from there on, they can use all of the services in the product at a fixed cost, except for the following two:</p>
<ul>
<li>Azure Pipelines parallel executions</li>
<li>Azure Artifacts storage</li>
</ul>
<p><strong>Parallel executions</strong>: By default, every Azure DevOps organization is provided with one Microsoft-hosted parallel execution job. This means that, while there can be as many pipelines defined as needed, there can be only one executing at the same time. Of course, this number can be increased, but this comes at the cost of buying more Microsoft-hosted parallel execution jobs, which are currently priced at € 33.74 per month.</p>
<p>As an alternative, it is also possible to buy self-hosted jobs. For these jobs, the execution agents are not provided by Microsoft, but have to be provided by the organization itself. This provides the opportunity (and responsibility) to fully control the hardware. A self-hosted pipeline is currently priced at € 12.65.</p>
<p><strong>Artifacts storage</strong>: When working with Azure Artifact feeds, the first 2 GB of storage used is free. Any extra storage used is charged at a rate of € 1.69 per month.</p>
<p>Once more and more of the users of a team have a license for Azure DevOps and perform their work there, this can be used to increase traceability for software development.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ensuring traceability</h1>
                </header>
            
            <article>
                
<p>One of the advantages of Azure DevOps over some of the other tools covered in this book is that it is a fully integrated suite of tools, each supporting specific DevOps processes. This end-to-end integration allows for detailed and lengthy traceability, from work described on the board to the related binaries being deployed to an environment.</p>
<p>When working with a set of other tools that support only a part of the DevOps process, integrating them is often possible and, of course, this will result in some traceability. For example, when working with Jira and GitHub, it is possible to relate commits, pull requests, and other changes in GitHub back to work described in Jira. When picking merged changes up in Jenkins to build and deploy the product, there will also be traceability from Jenkins back to GitHub. However, there will be no direct visibility on which work item was completed with which Jenkins deployment</p>
<p>The disadvantage of this is that a product owner who works in the Jira tool, cannot see whether a completed user story is associated with a release already. They would have to visit multiple tools to find the answer to that question: in GitHub, they would have to find all commits relating to the story and then see whether those commits have been released already using Jenkins:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-538 image-border" src="assets/326fe846-3c51-4ef0-b235-1feaa4ce841f.png" style="width:21.33em;height:9.17em;"/></p>
<p>When working with Azure Boards, Repos, and Pipelines, this is different. When using all of the Azure DevOps services, traceability is possible from story to deployment, and the other way around. The following is an example that highlights how to see which commits were deployed for the first time to an environment with a specific deploy:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1103 image-border" src="assets/e067517b-a7e7-47e1-a074-1bdfc7c72fbd.png" style="width:140.50em;height:55.33em;"/></p>
<p>Having this type of end-to-end traceability enables a number of questions to be answered quickly, including the following:</p>
<ul>
<li>Has work on this work item already started? (Branches and pull requests can be related to work items.)</li>
<li>Is this work already part of our nightly build? (Commits and build pipelines can be related to work items.)</li>
<li>Is this bug already fixed and is the solution available to our customers on ring two already? (Releases and environments show which new commits and work items were part of the latest deployment.)</li>
</ul>
<p>One thought that is particularly important to reinforce when talking about traceability is that it is not about blame. Traceability is not about finding out who made which mistake, but about finding out what the state of things is and how objects relate. As soon as traceability becomes the basis for blame, engineers will soon find ways to hide their work. This will result in more errors and less visibility, only making problems worse.</p>
<p>With the benefits of traceability clear, let's explore how consolidating tools can help to reap these benefits.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Consolidating tools</h1>
                </header>
            
            <article>
                
<p>One trend that can be observed in the market is that of traceability and DevOps products that extend their offerings to include more than only source control, only pipelines, or just deployments. Examples are GitHub and GitLab, which are adding new services. More integrated <strong>Application Lifecycle Management</strong> (<strong>ALM</strong>) or DevOps suites emerge, while Azure DevOps has been offering this for years now. </p>
<p>However, there are many companies where these integrated suites are not in place. Teams operate in different ecosystems, leading to different tool choices. Or maybe teams just have different preferences or started adopting DevOps practices at different points in time, with other tools to choose from. No matter the reason, there are many companies that have several tools running for the same job.</p>
<p>Unfortunately, several drawbacks are associated with having disconnected tools or multiple tools for the same thing:</p>
<ul>
<li>Collaboration between teams is hindered if they are using different tools. No matter the personal preference of developers, it can prove to be a hindrance to productivity when one half of the organization is using Jenkins and the other half is using Azure Pipelines. By extension, switching teams or helping others out is severely impeded when they are using another tool.</li>
<li>When there are more tools, there are also more costs. Even when all of the tools are open source and free, there are still costs involved. These costs can consist of, for instance, support contracts or requests, training, or the time needed to investigate and overcome specific issues. The same holds for upgrades and maintenance. When there are more tools, the total costs increase.</li>
</ul>
<p>To overcome these challenges, many large companies decide to standardize which tools are used, either completely or at least to some extent. As an alternative or intermediate solution, it is also possible to use integration between tools as a way of starting a consolidation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Standardizing tools</h1>
                </header>
            
            <article>
                
<p>To combat these drawbacks, most companies accept one of two strategies:</p>
<ul>
<li>Centralized decision making to select one tool (for each DevOps area) for the whole company</li>
<li>Centralized adoption of a limited set of tools, out of which teams can choose which to adopt</li>
</ul>
<p><strong>Complete centralization</strong>: When completely centralizing, one central team or department decides, on behalf of everyone, which DevOps tools will be used within the organization. Once such a decision has been made and implemented, this reduces costs and makes it easier for engineers to assist in other teams.</p>
<p>The downside is, of course, that one single tool is not necessarily the best choice for everyone while, for the organization as a whole, the selected tool might be the best—such standardization can do damage in a number of edge cases.</p>
<p><strong>Limited centralization</strong>: To prevent this, other companies choose to have limited centralization. Instead of just one tool, a group of tools is chosen as the company's standard. Teams are now able to make their own choice out of two or three tools, depending on their specific needs. This limits many of the drawbacks of full decentralization while not sacrificing the productivity of teams with very specific needs.</p>
<p>Adopting one of these two strategies might mean that some existing tools will be deprecated or decommissioned altogether. This can be a slow and painful process, especially in large organizations where there are often conflicting interests. There are many ways to go about this, but there are strategies to make such a migration less painful.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Migration strategies</h1>
                </header>
            
            <article>
                
<p>Reducing the number of DevOps tools in use often means one or more tools must be decommissioned. This can be difficult since often, these tools are used to implement governance and compliance, as required by laws and regulations. In practice, this means that one of two things can be done:</p>
<ul>
<li>Old tools are not completely decommissioned but just no longer used, to maintain the change history.</li>
<li>History must be migrated to the new tools as well before the old tools can be decommissioned.</li>
</ul>
<p>When choosing to do a migration, there are four ways to go about this:</p>
<ul>
<li>Azure DevOps Server to Azure DevOps Services migration</li>
<li>Big-bang migration</li>
<li>Synchronization</li>
<li>Rebuilding</li>
</ul>
<div class="packt_tip">Azure DevOps Server used to be called <strong>Team Foundation Server</strong> (<strong>TFS</strong>). Older versions of TFS need to be upgraded to one of the latest versions of Azure DevOps Server before they can be imported into Azure DevOps Services. The import service <span>always </span>supports the latest two versions of Azure DevOps Server</div>
<p>All three of these are detailed in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Azure DevOps Server to Azure DevOps Services migration</h1>
                </header>
            
            <article>
                
<p>For organizations wanting to move from working with Azure DevOps Server to Azure DevOps Services, there is a high-fidelity migration service available. Every project collection that currently exists in the on-premises Azure DevOps Server environment can be migrated to an Azure DevOps organization using the Azure DevOps Server import service. All of the assets currently existing in the on-premises project collection will be migrated to Azure DevOps: work items, source control repositories, and build and release definitions.</p>
<p>The migration of a project collection consists of the following high-level steps:</p>
<ol>
<li>Validating whether a project collection is ready for migration: This step does not make any changes, but only checks whether all preconditions for a migration have been met.</li>
<li>Preparing the migration: In this step, a JSON file is generated that describes how the migration should be performed. A second file can also be supplied for linking on-premises identity to AAD identities to ensure that all of the history is still correctly linked to who made the change after the migration.</li>
<li>A dry run of the migration is done to verify that the import process will result in the expected outcomes.</li>
<li>The actual migration: In this step, the collection is taken offline, a DACPAC is generated from the project collection database, the DACPAC and files from step two are uploaded, and the migration is initiated.</li>
<li>After the import, all assets need to be verified and, in specific scenarios, some post-import actions have to be taken.</li>
</ol>
<p>For using the migration service, a comprehensive guide with checklists and step-by-step instructions is available and linked to at the end of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Big-bang migration</h1>
                </header>
            
            <article>
                
<p>The second possible strategy is a big-bang migration. At some point, the old tool is switched off, all data is migrated to the new tool, and the new tool is made available. If there is anything that does not breathe DevOps, it is such a migration. It has a high potential for issues and often there is no turning back. Often, this is not a good migration strategy.</p>
<p>However, one situation where such an approach might make sense is the migration of source control. There are tools available for migrating from different sources to any type of hosted Git solution, including Azure DevOps. Source control also has the benefit that change history is built so deep into the system that migrating with history is often easier than for other types of data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Synchronization</h1>
                </header>
            
            <article>
                
<p>Another strategy for migration is allowing for a period of time where both tools can be used at the same time.</p>
<p>One way to do this is by using a tool that can be used to sync between the old and the new tool. This can be either in one direction, from old to new, or in both directions. This way, an in-between situation is created where both tools can be in use at the same time. Every team can choose its own time for its migration within a certain window. This avoids a forced migration window. Teams can also opt to use both tools next to each other for a while. This allows them to learn the new tool, while still being able to switch to the tool that they know if they are under pressure. After a period of transition, the old tool can be made read-only or decommissioned completely. This approach often works well for work tracking systems. Between these systems, the concepts are often very similar (epics, features, stories, and sprints), which makes a synchronization a feasible approach.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rebuilding</h1>
                </header>
            
            <article>
                
<p>A slightly different approach is that of asking teams to rebuild in the new tool. This approach also creates an in-parallel situation, but there is no automated migration or synchronization. Teams will have to redo their process or way of working in the new tool. Since this can take a while, the old tool will remain while teams are working on this. One situation where this is often a good approach is that of build and/or release pipelines.</p>
<p>No matter the strategy that has been chosen, in all cases, it helps to make sure that the new tool or tools are an improvement for the teams over the existing tools. This should improve performance, traceability, ease of use, or integration with other company tools. A positive vibe around any migration can improve the outcomes dramatically.</p>
<p>As an alternative to migrating to a single tool, integrations between tools can be used to bring existing tools together.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating tools</h1>
                </header>
            
            <article>
                
<p>As an alternative to replacing no longer preferred tools, it is also possible to integrate them with the preferred tool. Especially when it has been decided to move to Azure DevOps, this can be a powerful strategy. In many of the chapters before, for each topic, different tools were listed that integrate with Azure DevOps.</p>
<p>When pursuing end-to-end traceability, these integrations can be used as a means to bring tools closer together. Consider the following example.</p>
<p>An organization is using Azure DevOps for managing work items, hosting Git repositories, and executing build pipelines. Deployments are done using Octopus Deploy for historic reasons. Since a full migration is too costly, as an alternative, an integration strategy is chosen. Triggering the Octopus Deploy not manually but automatically from Azure DevOps meets several goals:</p>
<ul>
<li>End-to-end automation is achieved.</li>
<li>Release management can now also be done in Azure DevOps, even though each deployment in Azure DevOps is no more than triggering Octopus Deploy.</li>
<li>Having release management in Azure DevOps now allows for end-to-end traceability.</li>
</ul>
<p>When consolidating tools, and really all things regarding DevOps, one thing that you must be ready to accept is that you are never done.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accepting there is no end state</h1>
                </header>
            
            <article>
                
<p>It is fair to expect that, at any point in time, there will be one or more improvements that teams want to make to their applications, toolchain, or way of working. To cope with this, it is recommended to not keep changing everything all of the time.</p>
<p>Instead, try to implement changes in batches or a series of well-defined steps. Also, note there is a natural order in things. It is impossible to practice continuous deployment without having a proper continuous integration process first. Also, adopting infrastructure as code will deliver the most value when a continuous deployment process for application code is already in place. Next, automating governance and security measures works best when infrastructure and configuration code is common practice. And once all of these practices have been implemented, new things will come up on the radar<span>—</span>future improvements that may be necessary.</p>
<p>Besides this series of improvements, it is also important to realize that not every team is at the same place in this journey and not every team can move at the same pace and that development is not always this linear.</p>
<p>But this does not mean that it is impossible to track and plan future changes and have learnings from one team applied to other teams as well. One oversimplified approach to tracking this can be a table, as shown here.</p>
<p>Here we see the adoption of different DevOps practices or ideas among five teams. All teams are practicing <strong>continuous</strong> <strong>integration</strong> (<strong>CI</strong>). Some of them are practicing <strong>continuous</strong> <strong>deployment</strong> (<strong>CD</strong>), while team 3 is still working on that (<strong>Work in Progress</strong>, <strong>WIP</strong>) and the fifth team has not started yet. Finally, team 2 is already experimenting with <strong>infrastructure as code</strong> (<strong>IaC</strong>). Finally, as there is no end state, it is only a matter of time before the next practice or idea will pop up and a team will start experimenting:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-959 image-border" src="assets/9cbda328-5e0a-436d-9dac-fbd75730da2e.png" style="width:31.08em;height:16.50em;"/></p>
<p>If a table, similar to the one shown in the preceding, is updated, evaluated, and expanded upon frequently, this helps to foster continuous learning and improve the way software is created and delivered. Learning and improving will become the standard and this will help to improve the delivery of value to end users. It also shows that adopting DevOps is never done.</p>
<p>It also provides the means to see which teams are at the forefront and which teams are following along. By giving teams who are in the lead more room for experimentation and knowledge sharing with other teams, organizations can encourage their leader teams to improve even more while, at the same time, accelerating other teams as well.</p>
<p>And with this remark about the need to keep learning, experimenting, and pushing yourself, it is a great time to wrap this book up. Let's recap this chapter in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned how to configure your Azure DevOps organization and how to create a layout for your products and teams. You learned what the implications are regarding the different configuration options and how to apply those. Next, you learned how you can use Azure DevOps to add traceability to your development process. You learned how to capture ideas and tasks in stories and tasks and how these can be traced all of the way to a deployment and the other way around. The next thing you learned about is how to approach the consolidation of tools used within your organization and when to stop trying to consolidate tools. Finally, you learned that it is important to continuously keep improving.</p>
<p>With the things you learned in this chapter, you are now capable of setting up and configuring Azure DevOps for your team, teams, or organization. You can create a structure that fits your organization and start using it with just one or multiple teams. You are also able to slowly standardize your way of working and consolidate the teams on the same set of tools.</p>
<p class="mce-root">This completes the final chapter of this book. You can refer to this book as a basis for taking the AZ-400 exam, as most of the topics are along similar lines. However, in order to be well prepared for the exam, I recommend reading more about them in other sources as well and try to get as much hands-on experience as you can. As a practice tool, the concluding chapter contains a mock exam to help you prepare for the final exam.</p>
<p style="line-height: 24.0pt"><span>Good luck!</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<p>As we conclude, here is a list of questions for you to test your knowledge regarding this chapter's material. You will find the answers in the <em>Assessments</em> section of the Appendix:</p>
<ol>
<li>True or False: All data stored in Azure DevOps by users is guaranteed to be contained within one region.</li>
<li>Reorder the following Azure DevOps concepts in such a way that each next element acts as a container for the next concept in the list:
<ul>
<li>Work item</li>
<li>Organization</li>
<li>Region</li>
<li>Project</li>
</ul>
</li>
<li>True or False: The general recommendation is to create a new project for every application that is developed by your organization.</li>
<li>Which two elements limit the actions any user can perform within Azure DevOps?</li>
<li>What is the main benefit of using a single tool for application life cycle management/DevOps as opposed to a suite of tools?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>More information on Azure DevOps projects and when to create more than one project can be found at <a href="https://docs.microsoft.com/en-us/azure/devops/organizations/projects/about-projects?view=azure-devops%23when-to-add-another-project">https://docs.microsoft.com/en-us/azure/devops/organizations/projects/about-projects?view=azure-devops#when-to-add-another-project</a>.</li>
<li>More information about the Azure DevOps security model can be found at <a href="https://docs.microsoft.com/en-us/azure/devops/organizations/security">https://docs.microsoft.com/en-us/azure/devops/organizations/security</a>.</li>
<li>Up-to-date information on Azure DevOps pricing can be found at <a href="https://azure.microsoft.com/en-us/pricing/details/devops/azure-devops-services/">https://azure.microsoft.com/en-us/pricing/details/devops/azure-devops-services/</a>.</li>
<li>More information about the Azure DevOps Server-import service can be found at <a href="https://docs.microsoft.com/en-us/azure/devops/migrate/migration-overview?view=azure-devops&amp;viewFallbackFrom=vsts">https://docs.microsoft.com/en-us/azure/devops/migrate/migration-overview?view=azure-devops&amp;viewFallbackFrom=vsts</a>.</li>
</ul>


            </article>

            
        </section>
    </body></html>