<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Developing with Librados</h1>
                </header>
            
            <article>
                
<p>Ceph provides block, file, and object storage via built-in interfaces that will meet the requirements of a large number of users. However, in scenarios where an application is developed internally, there may be benefits to directly interfacing it into Ceph via the use of librados. Librados is the Ceph library that allows applications to directly read and write objects to the RADOS layer in Ceph.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>What is librados?</li>
<li>Using librados and what languages it supports</li>
<li>Writing an example librados application</li>
<li>Writing a librados application that stores image files in Ceph using Python</li>
<li>Writing a librados application using atomic operations with C++</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is librados?</h1>
                </header>
            
            <article>
                
<p>Librados is a Ceph library that you can include in your applications to allow you to directly talk to a Ceph cluster using native protocols. As librados communicates with Ceph using its native communication protocols, it allows your application to harness the full power, speed, and flexibility of Ceph, instead of having to make use of high-level protocols, such as Amazon S3. A vast array of functions allows your application to read and write simple objects all the way to advanced operations, where you might want to wrap several operations in a transaction or run them asynchronously. Librados is available for several languages, including C, C++, Python, PHP, and Java.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to use librados</h1>
                </header>
            
            <article>
                
<p>To get started with librados, a development environment is needed. For the examples in this chapter, one of the monitor nodes can be used to act as both the development environment and the client to run the developed application. The examples in this book assume you are using a Debian-based distribution:</p>
<ol>
<li>Install the base build tools for the operating system:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo apt-get install build-essential</strong></pre>
<p style="padding-left: 60px">The preceding command gives the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/add38f39-eac4-4a65-8c60-3bf41dbe3ca8.png" style="width:52.75em;height:16.08em;"/></div>
<ol start="2">
<li>Install the <kbd>librados</kbd> development library:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo apt-get install librados-dev</strong></pre>
<p style="padding-left: 60px"><span>The preceding command gives the following output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3ed5943f-e3b8-448f-a41e-c2144c454013.png" style="width:60.17em;height:17.83em;"/></p>
<ol start="3">
<li>Create a quick application written in C to establish a connection to the test Ceph cluster:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ mkdir test_app<br/></strong><strong>$ cd test_app</strong></pre>
<ol start="4">
<li>Create a file called <kbd>test_app.c</kbd> with your favorite text editor and place the following in it:</li>
</ol>
<pre>       #include &lt;rados/librados.h&gt; <br/>       #include &lt;stdio.h&gt; <br/>       #include &lt;stdlib.h&gt; <br/><br/>       rados_t rados = NULL; <br/><br/>       int exit_func(); <br/><br/><br/>       int main(int argc, const char **argv) <br/>       { <br/>         int ret = 0; <br/>         ret = rados_create(&amp;rados, "admin"); // Use the<br/>         client.admin keyring <br/>         if (ret &lt; 0) { // Check that the rados object was created <br/>           printf("couldn't initialize rados! error %d\n", ret); <br/>           ret = EXIT_FAILURE; <br/>           exit_func; <br/>         } <br/>         else <br/>           printf("RADOS initialized\n"); <br/><br/>         ret = rados_conf_read_file(rados, "/etc/ceph/ceph.conf"); <br/>         if (ret &lt; 0) { //Parse the ceph.conf to obtain cluster details <br/>           printf("failed to parse config options! error %d\n", ret); <br/>           ret = EXIT_FAILURE; <br/>           exit_func(); <br/>         } <br/>         else <br/>           printf("Ceph config parsed\n"); <br/><br/>         ret = rados_connect(rados); //Initiate connection to the<br/>         Ceph cluster <br/>         if (ret &lt; 0) { <br/>           printf("couldn't connect to cluster! error %d\n", ret); <br/>           ret = EXIT_FAILURE; <br/>           exit_func; <br/>         } else { <br/>           printf("Connected to the rados cluster\n"); <br/>         } <br/><br/>         exit_func(); //End of example, call exit_func to clean<br/>         up and finish <br/><br/>       } <br/><br/><br/>       int exit_func () <br/>       { <br/>         rados_shutdown(rados); //Destroy connection to the<br/>         Ceph cluster <br/>         printf("RADOS connection destroyed\n"); <br/>         printf("The END\n"); <br/>         exit(0); <br/>       } </pre>
<ol start="5">
<li>Compile the test application by running the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ gcc test_app.c -o test_app -lrados</strong></pre>
<div class="packt_infobox">It's important to note that you need to tell <kbd>gcc</kbd> to link to the <kbd>librados</kbd> library to make use of its functions.</div>
<ol start="6">
<li>Test that the app works by running it. Don't forget to run it as root or use <kbd>sudo</kbd>, otherwise you won't have access to the Ceph keyring:</li>
</ol>
<pre style="padding-left: 60px"><strong>sudo ./test_app</strong></pre>
<p style="padding-left: 60px"><span>The preceding command gives the following output:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/f590224b-717c-4a2f-9a93-7c733dcd80d0.png" style="width:38.17em;height:6.83em;"/></div>
<p>The test application simply reads your <kbd>ceph.conf</kbd> configuration, uses it to establish a connection to your Ceph cluster, and then disconnects. It's hardly the most exciting of applications, but it tests that the basic infrastructure is in place and working, and establishes a foundation for the rest of the examples in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example librados application</h1>
                </header>
            
            <article>
                
<p>We will now go through some example librados applications that use librados to get a better understanding of what you can accomplish with the library.</p>
<p>The following example will take you through the steps to create an application which, when given an image file as a parameter, will store the image as an object in a Ceph cluster and store various attributes about the image file as object attributes. The application will also allow you to retrieve the object and export it as an image file. This example will be written in Python, which is also supported by librados. The following example also uses the <strong>Python Imaging Library</strong> (<strong>PIL</strong>) to read an image's size and the argument parser library to read command-line parameters:</p>
<ol>
<li>Install the librados Python bindings and image-manipulation libraries:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo apt-get install python-rados python-imaging</strong></pre>
<p style="padding-left: 60px"><span>The preceding command gives the following output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/665a9d8b-b782-401f-bfc5-f4e7c3911311.png" style="width:59.83em;height:16.83em;"/></p>
<ol start="2">
<li>Create a new file for your Python application ending with the <kbd>.py</kbd> extension and enter the following into it:</li>
</ol>
<pre>       import rados, sys, argparse <br/>       from PIL import Image <br/><br/>       #Argument Parser used to read parameters and generate --help <br/>       parser = argparse.ArgumentParser(description='Image to RADOS <br/>       Object Utility') <br/>       parser.add_argument('--action', dest='action', action='store',<br/>       required=True, help='Either upload or download image to/from <br/>       Ceph') <br/>       parser.add_argument('--image-file', dest='imagefile',<br/>       action='store', required=True, help='The image file to<br/>       upload to RADOS') <br/>       parser.add_argument('--object-name', dest='objectname', <br/>       action='store', required=True, help='The name of the<br/>       RADOS object') <br/>       parser.add_argument('--pool', dest='pool', action='store', <br/>       required=True, help='The name of the RADOS pool to store<br/>       the object') <br/>       parser.add_argument('--comment', dest='comment', action=<br/>       'store', help='A comment to store with the object') <br/><br/><br/>       args = parser.parse_args() <br/><br/>       try: #Read ceph.conf config file to obtain monitors <br/>         cluster = rados.Rados(conffile='/etc/ceph/ceph.conf') <br/>       except: <br/>         print "Error reading Ceph configuration" <br/>         sys.exit(1) <br/><br/>       try: #Connect to the Ceph cluster <br/>         cluster.connect() <br/>       except: <br/>         print "Error connecting to Ceph Cluster" <br/>         sys.exit(1) <br/><br/>       try: #Open specified RADOS pool <br/>         ioctx = cluster.open_ioctx(args.pool) <br/>       except: <br/>         print "Error opening pool: " + args.pool <br/>         cluster.shutdown() <br/>         sys.exit(1) <br/><br/>       if args.action == 'upload': #If action is to upload <br/>         try: #Open image file in read binary mode <br/>           image=open(args.imagefile,'rb') <br/>           im=Image.open(args.imagefile) <br/>         except: <br/>           print "Error opening image file" <br/>           ioctx.close() <br/>           cluster.shutdown() <br/>           sys.exit(1) <br/>         print "Image size is x=" + str(im.size[0]) + " y=" + <br/>         str(im.size[1]) <br/>         try: #Write the contents of image file to object and add <br/>         attributes <br/>           ioctx.write_full(args.objectname,image.read()) <br/>           ioctx.set_xattr(args.objectname,'xres',str(im.size[0]) <br/>           +"\n") <br/>           ioctx.set_xattr(args.objectname,'yres',str(im.size[1]) <br/>           +"\n") <br/>           im.close() <br/>           if args.comment: <br/>             ioctx.set_xattr(args.objectname,'comment',args.comment <br/>             +"\n") <br/>         except: <br/>           print "Error writing object or attributes" <br/>           ioctx.close() <br/>           cluster.shutdown() <br/>           sys.exit(1) <br/>         image.close() <br/>       elif args.action == 'download': <br/>         try: #Open image file in write binary mode <br/>           image=open(args.imagefile,'wb') <br/>         except: <br/>           print "Error opening image file" <br/>           ioctx.close() <br/>           cluster.shutdown() <br/>           sys.exit(1) <br/>         try: #Write object to image file <br/>           image.write(ioctx.read(args.objectname)) <br/>         except: <br/>           print "Error writing object to image file" <br/>           ioctx.close() <br/>           cluster.shutdown() <br/>           sys.exit(1) <br/>         image.close() <br/>       else: <br/>         print "Please specify --action as either upload or download" <br/>       ioctx.close() #Close connection to pool <br/>       cluster.shutdown() #Close connection to Ceph <br/>       #The End</pre>
<ol start="3">
<li>Test the <kbd>help</kbd> functionality generated by the Argument Parser library:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo python app1.py --help</strong></pre>
<p style="padding-left: 60px"><span>The preceding command gives the following output:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fa20975e-c1bc-452d-bec0-ec0b2693276d.png" style="width:51.58em;height:18.00em;"/></div>
<ol start="4">
<li>Download the Ceph logo to use as a test image:</li>
</ol>
<pre style="padding-left: 60px"><strong>wget <span class="URLPACKT">http://docs.ceph.com/docs/master/_static/logo.png</span></strong></pre>
<p style="padding-left: 60px"><span>The preceding command gives the following output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e1656145-ff23-413e-b7c0-1bf3bb8e3743.png"/></p>
<ol start="5">
<li>Run our Python application to read an image file and upload it to Ceph as an object:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo python app1.py --action=upload --image-file=test1.png<br/>       --object-name=image_test --pool=rbd --comment="Ceph Logo"</strong></pre>
<p style="padding-left: 60px"><span>The preceding command gives the following output:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/951a2ca7-8ecc-4ef8-a1f5-c076400ba028.png"/></div>
<ol start="6">
<li>Verify that the object has been created:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo rados -p rbd ls</strong></pre>
<p style="padding-left: 60px"><span>The preceding command gives the following output:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/922ccaff-4eee-441f-9505-4fda6f9c1078.png" style="width:21.75em;height:2.25em;"/></div>
<ol start="7">
<li>Use <kbd>rados</kbd> to verify that the attributes have been added to the object:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo rados -p rbd listxattr image_test</strong></pre>
<p style="padding-left: 60px"><span>The preceding command gives the following output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7bc93c14-7054-4ba8-b2d2-dbf92afda207.png" style="width:33.00em;height:6.58em;"/></p>
<ol start="8">
<li>Use <kbd>rados</kbd> to verify the attributes' contents, as shown in the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/c6eaeffc-1649-4530-a1e1-26c03354ce36.png" style="width:36.00em;height:6.25em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example of the librados application with atomic operations</h1>
                </header>
            
            <article>
                
<p>In the previous librados application example, an object was created on the Ceph cluster and then the object's attributes were added. In most cases, this two-stage operation may be fine; however, some applications might require that the creation of the object and its attributes are atomic. That is to say, if service were interrupted, the object should only exist if it has all its attributes set, otherwise the Ceph cluster should roll back the transaction. The following example, written in C++, shows how to use librados atomic operations to ensure transaction consistency across multiple operations. The example will write an object and then ask the user whether they wish to abort the transaction. If they choose to abort then the object write operation will be rolled back. If they choose to continue, the attributes will be written and the whole transaction will be committed. Perform the following steps:</p>
<ol>
<li>Create a new file with a <kbd>.cc</kbd> extension and place the following into it:</li>
</ol>
<pre>       #include &lt;cctype&gt; <br/>       #include &lt;rados/librados.hpp&gt; <br/>       #include &lt;iostream&gt; <br/>       #include &lt;string&gt; <br/><br/>       void exit_func(int ret); <br/><br/>       librados::Rados rados; <br/><br/>       int main(int argc, const char **argv) <br/>       { <br/>         int ret = 0; <br/><br/>         // Define variables <br/>         const char *pool_name = "rbd"; <br/>         std::string object_string("I am an atomic object\n"); <br/>         std::string attribute_string("I am an atomic attribute\n"); <br/>         std::string object_name("atomic_object"); <br/>         librados::IoCtx io_ctx; <br/><br/>         // Create the Rados object and initialize it <br/>         { <br/>           ret = rados.init("admin"); // Use the default client.admin <br/>           keyring <br/>           if (ret &lt; 0) { <br/>             std::cerr &lt;&lt; "Failed to initialize rados! error " &lt;&lt; ret <br/>             &lt;&lt; std::endl; <br/>             ret = EXIT_FAILURE; <br/>           } <br/>         } <br/><br/>         // Read the ceph config file in its default location <br/>         ret = rados.conf_read_file("/etc/ceph/ceph.conf"); <br/>         if (ret &lt; 0) { <br/>           std::cerr &lt;&lt; "Failed to parse config file " <br/>                     &lt;&lt; "! Error" &lt;&lt; ret &lt;&lt; std::endl; <br/>           ret = EXIT_FAILURE; <br/>         } <br/><br/>         // Connect to the Ceph cluster <br/>         ret = rados.connect(); <br/>         if (ret &lt; 0) { <br/>           std::cerr &lt;&lt; "Failed to connect to cluster! Error " &lt;&lt; ret <br/>           &lt;&lt; std::endl; <br/>           ret = EXIT_FAILURE; <br/>         } else { <br/>           std::cout &lt;&lt; "Connected to the Ceph cluster" &lt;&lt; std::endl; <br/>         } <br/><br/>         // Create connection to the Rados pool <br/>         ret = rados.ioctx_create(pool_name, io_ctx); <br/>         if (ret &lt; 0) { <br/>           std::cerr &lt;&lt; "Failed to connect to pool! Error: " &lt;&lt; ret &lt;&lt; <br/>           std::endl; <br/>           ret = EXIT_FAILURE; <br/>         } else { <br/>           std::cout &lt;&lt; "Connected to pool: " &lt;&lt; pool_name &lt;&lt;<br/>           std::endl; <br/>         } <br/><br/>         librados::bufferlist object_bl; // Initialize a bufferlist <br/>         object_bl.append(object_string); // Add our object text<br/>         string to the bufferlist <br/>         librados::ObjectWriteOperation write_op; // Create a write <br/>         transaction <br/>         write_op.write_full(object_bl); // Write our bufferlist to the <br/>         transaction <br/>         std::cout &lt;&lt; "Object: " &lt;&lt; object_name &lt;&lt; " has been written <br/>         to transaction" &lt;&lt; std::endl; <br/>         char c; <br/>         std::cout &lt;&lt; "Would you like to abort transaction? (Y/N)? "; <br/>         std::cin &gt;&gt; c; <br/>         if (toupper( c ) == 'Y') { <br/>           std::cout &lt;&lt; "Transaction has been aborted, so object will <br/>           not actually be written" &lt;&lt; std::endl; <br/>           exit_func(99); <br/>         } <br/>         librados::bufferlist attr_bl; // Initialize another bufferlist <br/>         attr_bl.append(attribute_string); // Add our attribute to the <br/>         bufferlist <br/>         write_op.setxattr("atomic_attribute", attr_bl); // Write our <br/>         attribute to our transaction <br/>         std::cout &lt;&lt; "Attribute has been written to transaction" &lt;&lt; <br/>         std::endl; <br/>         ret = io_ctx.operate(object_name, &amp;write_op); // Commit the<br/>         transaction <br/>         if (ret &lt; 0) { <br/>           std::cerr &lt;&lt; "failed to do compound write! error " &lt;&lt; ret &lt;&lt; <br/>           std::endl; <br/>           ret = EXIT_FAILURE; <br/>         } else { <br/>           std::cout &lt;&lt; "We wrote the transaction containing our object<br/>           and attribute" &lt;&lt; object_name &lt;&lt; std::endl; <br/>         } <br/><br/>       } <br/><br/>       void exit_func(int ret) <br/>       { <br/>         // Clean up and exit <br/>         rados.shutdown(); <br/>         exit(ret); <br/>       } </pre>
<ol start="2">
<li>Compile the source using <kbd>g++</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>g++ atomic.cc -o atomic -lrados -std=c++11</strong></pre>
<ol start="3">
<li>Let's run through the application and abort the transaction:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e5a70bba-5a35-44cf-beda-0dce7728d7a9.png" style="width:39.75em;height:7.58em;"/></div>
<p style="padding-left: 60px">The preceding screenshot shows that, even though we sent a write object command, as the transaction was not committed, the object was never actually written to the Ceph cluster.</p>
<ol start="4">
<li>Let's run the application again and, this time, let it continue the transaction:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5944bf12-2dde-4653-8014-19ef5384383d.png" style="width:38.92em;height:10.08em;"/></div>
<p style="padding-left: 60px">As you can see, this time the object was written along with its attribute.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example of the librados application that uses watchers and notifiers</h1>
                </header>
            
            <article>
                
<p>The following librados application is written in C and shows us how to use the watch or notify functionality in RADOS. Ceph enables a client to create a watcher on an object and receive notifications from a completely separate client connected to the same cluster.</p>
<p>The watcher functionality is implemented via callback functions. When you call the librados function to create the watcher, two of the arguments are for callback functions: one is for what to do when a notification is received and another is for what to do if the watcher loses contact or encounters an error with the object. These callback functions contain the code you want to run when a notification or error occurs.</p>
<p>This simple form of messaging is commonly used to instruct a client that has an RBD in use that a snapshot is wished to be taken. The client who wishes to take a snapshot sends a notification to all clients that may be watching the RBD object so that it can flush its cache and possibly make sure the filesystem is in a consistent state.</p>
<p>The following example creates a <kbd>watcher</kbd> instance on an object named <kbd>my_object</kbd> and then waits. When it receives a notification, it will display the payload and then send a received message back to the notifier:</p>
<ol>
<li>Create a new file with a <kbd>.c</kbd> extension and place the following into it:</li>
</ol>
<pre style="padding-left: 60px"> #include &lt;stdio.h&gt; <br/> #include &lt;stdlib.h&gt; <br/> #include &lt;string.h&gt; <br/> #include &lt;syslog.h&gt; <br/><br/> #include &lt;rados/librados.h&gt; <br/> #include &lt;rados/rados_types.h&gt; <br/><br/> uint64_t cookie; <br/> rados_ioctx_t io; <br/> rados_t cluster; <br/> char cluster_name[] = "ceph"; <br/> char user_name[] = "client.admin"; <br/> char object[] = "my_object"; <br/> char pool[] = "rbd"; <br/><br/> /* Watcher callback function - called when watcher receives a<br/> notification */ <br/> void watch_notify2_cb(void *arg, uint64_t notify_id, uint64_t<br/> cookie, uint64_t notifier_gid, void *data, size_t data_len) <br/> { <br/> const char *notify_oid = 0; <br/> char *temp = (char*)data+4; <br/> int ret; <br/> printf("Message from Notifier: %s\n",temp); <br/> rados_notify_ack(io, object, notify_id, cookie, "Received", 8); <br/> } <br/><br/> /* Watcher error callback function - called if watcher encounters<br/> an error */ <br/> void watch_notify2_errcb(void *arg, uint64_t cookie, int err) <br/> { <br/> printf("Removing Watcher on object %s\n",object); <br/> err = rados_unwatch2(io,cookie); <br/> printf("Creating Watcher on object %s\n",object); <br/> err = rados_watch2(io,object,&amp;cookie,watch_notify2_cb,<br/> watch_notify2_errcb,NULL); <br/> if (err &lt; 0) { <br/> fprintf(stderr, "Cannot create watcher on %s/%s: %s\n", object,<br/> pool, strerror(-err)); <br/> rados_ioctx_destroy(io); <br/> rados_shutdown(cluster); <br/> exit(1); <br/> } <br/> } <br/><br/> int main (int argc, char **argv) <br/> { <br/> int err; <br/> uint64_t flags; <br/><br/> /* Create Rados object */ <br/> err = rados_create2(&amp;cluster, cluster_name, user_name, flags); <br/> if (err &lt; 0) { <br/> fprintf(stderr, "Couldn't create the cluster object!: %s\n",<br/> strerror(-err)); <br/> exit(EXIT_FAILURE); <br/> } else { <br/> printf("Created the rados object.\n"); <br/> } <br/><br/><br/> /* Read a Ceph configuration file to configure the cluster<br/> handle. */ <br/> err = rados_conf_read_file(cluster, "/etc/ceph/ceph.conf"); <br/> if (err &lt; 0) { <br/> fprintf(stderr, "Cannot read config file: %s\n",<br/> strerror(-err)); <br/> exit(EXIT_FAILURE); <br/> } else { <br/> printf("Read the config file.\n"); <br/> } <br/> /* Connect to the cluster */ <br/> err = rados_connect(cluster); <br/> if (err &lt; 0) { <br/> fprintf(stderr, "Cannot connect to cluster: %s\n",<br/> strerror(-err)); <br/> exit(EXIT_FAILURE); <br/> } else { <br/> printf("\n Connected to the cluster.\n"); <br/> } <br/><br/> /* Create connection to the Rados pool */ <br/> err = rados_ioctx_create(cluster, pool, &amp;io); <br/> if (err &lt; 0) { <br/> fprintf(stderr, "Cannot open rados pool %s: %s\n", pool,<br/> strerror(-err)); <br/> rados_shutdown(cluster); <br/> exit(1); <br/> } <br/><br/> /* Create the Rados Watcher */ <br/> printf("Creating Watcher on object %s/%s\n",pool,object); <br/> err = rados_watch2(io,object,&amp;cookie,watch_notify2_cb, <br/> watch_notify2_errcb,NULL); <br/> if (err &lt; 0) { <br/> fprintf(stderr, "Cannot create watcher on object %s/%s: %s\n",<br/> pool, object, strerror(-err)); <br/> rados_ioctx_destroy(io); <br/> rados_shutdown(cluster); <br/> exit(1); <br/> } <br/><br/> /* Loop whilst waiting for notifier */ <br/> while(1){ <br/> sleep(1); <br/> } <br/> /* Clean up */ <br/> rados_ioctx_destroy(io); <br/> rados_shutdown(cluster); <br/> } </pre>
<ol start="2">
<li>Compile the <kbd>watcher</kbd> example code:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ gcc watcher.c -o watcher -lrados</strong></pre>
<ol start="3">
<li>Run the <kbd>watcher</kbd> example application:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/b887acd6-38ab-409d-be42-e84521b3306c.png" style="width:52.50em;height:7.58em;"/></div>
<ol start="4">
<li>The <kbd>watcher</kbd> is now waiting for a notification. In another Terminal window, using <kbd>rados</kbd>, send a notification to the <kbd>my_object</kbd> object that is being watched:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/e1674858-9df0-4520-876c-6a3e575d3390.png" style="width:53.08em;height:4.67em;"/></div>
<ol start="5">
<li>You can see that the notification was sent and an acknowledgement notification has been received back. If we look at the first Terminal window again, we can see the message from the notifier:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ef5bdf37-4df8-4a93-91b7-63d04dd30b69.png" style="width:25.25em;height:7.33em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This concludes our chapter on developing applications with librados. You should now feel comfortable with the basic concepts of how to include librados functionality in your application and how to read and write objects to your Ceph cluster. It would be recommended to read the official librados documentation if you intend to develop an application with librados, so that you can gain a better understanding of the full range of functions that are available.</p>
<p>In the next chapter, we will learn about RADOS classes and how they can be used to speed up processing for larger applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Name a reason you might want to write an application that uses the native librados API.</li>
<li>What does a RADOS <kbd>watcher</kbd> do?</li>
<li>Name the five languages that librados is available in.</li>
</ol>


            </article>

            
        </section>
    </body></html>