["```\n$ sudo apt-get install build-essential\n```", "```\n$ sudo apt-get install librados-dev\n```", "```\n$ mkdir test_app $ cd test_app\n```", "```\n       #include <rados/librados.h> \n       #include <stdio.h> \n       #include <stdlib.h> \n\n       rados_t rados = NULL; \n\n       int exit_func(); \n\n       int main(int argc, const char **argv) \n       { \n         int ret = 0; \n         ret = rados_create(&rados, \"admin\"); // Use the\n         client.admin keyring \n         if (ret < 0) { // Check that the rados object was created \n           printf(\"couldn't initialize rados! error %d\\n\", ret); \n           ret = EXIT_FAILURE; \n           exit_func; \n         } \n         else \n           printf(\"RADOS initialized\\n\"); \n\n         ret = rados_conf_read_file(rados, \"/etc/ceph/ceph.conf\"); \n         if (ret < 0) { //Parse the ceph.conf to obtain cluster details \n           printf(\"failed to parse config options! error %d\\n\", ret); \n           ret = EXIT_FAILURE; \n           exit_func(); \n         } \n         else \n           printf(\"Ceph config parsed\\n\"); \n\n         ret = rados_connect(rados); //Initiate connection to the\n         Ceph cluster \n         if (ret < 0) { \n           printf(\"couldn't connect to cluster! error %d\\n\", ret); \n           ret = EXIT_FAILURE; \n           exit_func; \n         } else { \n           printf(\"Connected to the rados cluster\\n\"); \n         } \n\n         exit_func(); //End of example, call exit_func to clean\n         up and finish \n\n       } \n\n       int exit_func () \n       { \n         rados_shutdown(rados); //Destroy connection to the\n         Ceph cluster \n         printf(\"RADOS connection destroyed\\n\"); \n         printf(\"The END\\n\"); \n         exit(0); \n       } \n```", "```\n$ gcc test_app.c -o test_app -lrados\n```", "```\nsudo ./test_app\n```", "```\n$ sudo apt-get install python-rados python-imaging\n```", "```\n       import rados, sys, argparse \n       from PIL import Image \n\n       #Argument Parser used to read parameters and generate --help \n       parser = argparse.ArgumentParser(description='Image to RADOS \n       Object Utility') \n       parser.add_argument('--action', dest='action', action='store',\n       required=True, help='Either upload or download image to/from \n       Ceph') \n       parser.add_argument('--image-file', dest='imagefile',\n       action='store', required=True, help='The image file to\n       upload to RADOS') \n       parser.add_argument('--object-name', dest='objectname', \n       action='store', required=True, help='The name of the\n       RADOS object') \n       parser.add_argument('--pool', dest='pool', action='store', \n       required=True, help='The name of the RADOS pool to store\n       the object') \n       parser.add_argument('--comment', dest='comment', action=\n       'store', help='A comment to store with the object') \n\n       args = parser.parse_args() \n\n       try: #Read ceph.conf config file to obtain monitors \n         cluster = rados.Rados(conffile='/etc/ceph/ceph.conf') \n       except: \n         print \"Error reading Ceph configuration\" \n         sys.exit(1) \n\n       try: #Connect to the Ceph cluster \n         cluster.connect() \n       except: \n         print \"Error connecting to Ceph Cluster\" \n         sys.exit(1) \n\n       try: #Open specified RADOS pool \n         ioctx = cluster.open_ioctx(args.pool) \n       except: \n         print \"Error opening pool: \" + args.pool \n         cluster.shutdown() \n         sys.exit(1) \n\n       if args.action == 'upload': #If action is to upload \n         try: #Open image file in read binary mode \n           image=open(args.imagefile,'rb') \n           im=Image.open(args.imagefile) \n         except: \n           print \"Error opening image file\" \n           ioctx.close() \n           cluster.shutdown() \n           sys.exit(1) \n         print \"Image size is x=\" + str(im.size[0]) + \" y=\" + \n         str(im.size[1]) \n         try: #Write the contents of image file to object and add \n         attributes \n           ioctx.write_full(args.objectname,image.read()) \n           ioctx.set_xattr(args.objectname,'xres',str(im.size[0]) \n           +\"\\n\") \n           ioctx.set_xattr(args.objectname,'yres',str(im.size[1]) \n           +\"\\n\") \n           im.close() \n           if args.comment: \n             ioctx.set_xattr(args.objectname,'comment',args.comment \n             +\"\\n\") \n         except: \n           print \"Error writing object or attributes\" \n           ioctx.close() \n           cluster.shutdown() \n           sys.exit(1) \n         image.close() \n       elif args.action == 'download': \n         try: #Open image file in write binary mode \n           image=open(args.imagefile,'wb') \n         except: \n           print \"Error opening image file\" \n           ioctx.close() \n           cluster.shutdown() \n           sys.exit(1) \n         try: #Write object to image file \n           image.write(ioctx.read(args.objectname)) \n         except: \n           print \"Error writing object to image file\" \n           ioctx.close() \n           cluster.shutdown() \n           sys.exit(1) \n         image.close() \n       else: \n         print \"Please specify --action as either upload or download\" \n       ioctx.close() #Close connection to pool \n       cluster.shutdown() #Close connection to Ceph \n       #The End\n```", "```\n$ sudo python app1.py --help\n```", "```\nwget http://docs.ceph.com/docs/master/_static/logo.png\n```", "```\n$ sudo python app1.py --action=upload --image-file=test1.png\n       --object-name=image_test --pool=rbd --comment=\"Ceph Logo\"\n```", "```\n$ sudo rados -p rbd ls\n```", "```\n$ sudo rados -p rbd listxattr image_test\n```", "```\n       #include <cctype> \n       #include <rados/librados.hpp> \n       #include <iostream> \n       #include <string> \n\n       void exit_func(int ret); \n\n       librados::Rados rados; \n\n       int main(int argc, const char **argv) \n       { \n         int ret = 0; \n\n         // Define variables \n         const char *pool_name = \"rbd\"; \n         std::string object_string(\"I am an atomic object\\n\"); \n         std::string attribute_string(\"I am an atomic attribute\\n\"); \n         std::string object_name(\"atomic_object\"); \n         librados::IoCtx io_ctx; \n\n         // Create the Rados object and initialize it \n         { \n           ret = rados.init(\"admin\"); // Use the default client.admin \n           keyring \n           if (ret < 0) { \n             std::cerr << \"Failed to initialize rados! error \" << ret \n             << std::endl; \n             ret = EXIT_FAILURE; \n           } \n         } \n\n         // Read the ceph config file in its default location \n         ret = rados.conf_read_file(\"/etc/ceph/ceph.conf\"); \n         if (ret < 0) { \n           std::cerr << \"Failed to parse config file \" \n                     << \"! Error\" << ret << std::endl; \n           ret = EXIT_FAILURE; \n         } \n\n         // Connect to the Ceph cluster \n         ret = rados.connect(); \n         if (ret < 0) { \n           std::cerr << \"Failed to connect to cluster! Error \" << ret \n           << std::endl; \n           ret = EXIT_FAILURE; \n         } else { \n           std::cout << \"Connected to the Ceph cluster\" << std::endl; \n         } \n\n         // Create connection to the Rados pool \n         ret = rados.ioctx_create(pool_name, io_ctx); \n         if (ret < 0) { \n           std::cerr << \"Failed to connect to pool! Error: \" << ret << \n           std::endl; \n           ret = EXIT_FAILURE; \n         } else { \n           std::cout << \"Connected to pool: \" << pool_name <<\n           std::endl; \n         } \n\n         librados::bufferlist object_bl; // Initialize a bufferlist \n         object_bl.append(object_string); // Add our object text\n         string to the bufferlist \n         librados::ObjectWriteOperation write_op; // Create a write \n         transaction \n         write_op.write_full(object_bl); // Write our bufferlist to the \n         transaction \n         std::cout << \"Object: \" << object_name << \" has been written \n         to transaction\" << std::endl; \n         char c; \n         std::cout << \"Would you like to abort transaction? (Y/N)? \"; \n         std::cin >> c; \n         if (toupper( c ) == 'Y') { \n           std::cout << \"Transaction has been aborted, so object will \n           not actually be written\" << std::endl; \n           exit_func(99); \n         } \n         librados::bufferlist attr_bl; // Initialize another bufferlist \n         attr_bl.append(attribute_string); // Add our attribute to the \n         bufferlist \n         write_op.setxattr(\"atomic_attribute\", attr_bl); // Write our \n         attribute to our transaction \n         std::cout << \"Attribute has been written to transaction\" << \n         std::endl; \n         ret = io_ctx.operate(object_name, &write_op); // Commit the\n         transaction \n         if (ret < 0) { \n           std::cerr << \"failed to do compound write! error \" << ret << \n           std::endl; \n           ret = EXIT_FAILURE; \n         } else { \n           std::cout << \"We wrote the transaction containing our object\n           and attribute\" << object_name << std::endl; \n         } \n\n       } \n\n       void exit_func(int ret) \n       { \n         // Clean up and exit \n         rados.shutdown(); \n         exit(ret); \n       } \n```", "```\ng++ atomic.cc -o atomic -lrados -std=c++11\n```", "```\n #include <stdio.h> \n #include <stdlib.h> \n #include <string.h> \n #include <syslog.h> \n\n #include <rados/librados.h> \n #include <rados/rados_types.h> \n\n uint64_t cookie; \n rados_ioctx_t io; \n rados_t cluster; \n char cluster_name[] = \"ceph\"; \n char user_name[] = \"client.admin\"; \n char object[] = \"my_object\"; \n char pool[] = \"rbd\"; \n\n /* Watcher callback function - called when watcher receives a\n notification */ \n void watch_notify2_cb(void *arg, uint64_t notify_id, uint64_t\n cookie, uint64_t notifier_gid, void *data, size_t data_len) \n { \n const char *notify_oid = 0; \n char *temp = (char*)data+4; \n int ret; \n printf(\"Message from Notifier: %s\\n\",temp); \n rados_notify_ack(io, object, notify_id, cookie, \"Received\", 8); \n } \n\n /* Watcher error callback function - called if watcher encounters\n an error */ \n void watch_notify2_errcb(void *arg, uint64_t cookie, int err) \n { \n printf(\"Removing Watcher on object %s\\n\",object); \n err = rados_unwatch2(io,cookie); \n printf(\"Creating Watcher on object %s\\n\",object); \n err = rados_watch2(io,object,&cookie,watch_notify2_cb,\n watch_notify2_errcb,NULL); \n if (err < 0) { \n fprintf(stderr, \"Cannot create watcher on %s/%s: %s\\n\", object,\n pool, strerror(-err)); \n rados_ioctx_destroy(io); \n rados_shutdown(cluster); \n exit(1); \n } \n } \n\n int main (int argc, char **argv) \n { \n int err; \n uint64_t flags; \n\n /* Create Rados object */ \n err = rados_create2(&cluster, cluster_name, user_name, flags); \n if (err < 0) { \n fprintf(stderr, \"Couldn't create the cluster object!: %s\\n\",\n strerror(-err)); \n exit(EXIT_FAILURE); \n } else { \n printf(\"Created the rados object.\\n\"); \n } \n\n /* Read a Ceph configuration file to configure the cluster\n handle. */ \n err = rados_conf_read_file(cluster, \"/etc/ceph/ceph.conf\"); \n if (err < 0) { \n fprintf(stderr, \"Cannot read config file: %s\\n\",\n strerror(-err)); \n exit(EXIT_FAILURE); \n } else { \n printf(\"Read the config file.\\n\"); \n } \n /* Connect to the cluster */ \n err = rados_connect(cluster); \n if (err < 0) { \n fprintf(stderr, \"Cannot connect to cluster: %s\\n\",\n strerror(-err)); \n exit(EXIT_FAILURE); \n } else { \n printf(\"\\n Connected to the cluster.\\n\"); \n } \n\n /* Create connection to the Rados pool */ \n err = rados_ioctx_create(cluster, pool, &io); \n if (err < 0) { \n fprintf(stderr, \"Cannot open rados pool %s: %s\\n\", pool,\n strerror(-err)); \n rados_shutdown(cluster); \n exit(1); \n } \n\n /* Create the Rados Watcher */ \n printf(\"Creating Watcher on object %s/%s\\n\",pool,object); \n err = rados_watch2(io,object,&cookie,watch_notify2_cb, \n watch_notify2_errcb,NULL); \n if (err < 0) { \n fprintf(stderr, \"Cannot create watcher on object %s/%s: %s\\n\",\n pool, object, strerror(-err)); \n rados_ioctx_destroy(io); \n rados_shutdown(cluster); \n exit(1); \n } \n\n /* Loop whilst waiting for notifier */ \n while(1){ \n sleep(1); \n } \n /* Clean up */ \n rados_ioctx_destroy(io); \n rados_shutdown(cluster); \n } \n```", "```\n$ gcc watcher.c -o watcher -lrados\n```"]