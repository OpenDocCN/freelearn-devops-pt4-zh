- en: Distributed Computation with Ceph RADOS Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An often-overlooked feature of Ceph is the ability to load custom code directly
    into OSD, which can then be executed from within a librados application. This
    allows you to take advantage of the large distributed scale of Ceph to not only
    provide high-performance scale-out storage, but also to distribute computational
    tasks over OSDs to achieve mass parallel computing. This ability is realized by
    dynamically loading in RADOS classes to each OSD.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Example applications and the benefits of using RADOS classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a simple RADOS class in Lua
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a RADOS class that simulates distributed computing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example applications and the benefits of using RADOS classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, with RADOS classes, code is executed directly inside the
    OSD code base and so can harness the combined power of all of the OSD nodes. With
    a typical client application approach, where the client would have to read the
    object from the Ceph cluster, run computations on it, and then write it back,
    there is a large amount of round-trip overhead. Using RADOS classes dramatically
    reduces the amount of round trips to and from OSDs, and also the available compute
    power is much higher than that single client could provide. Offloading operations
    directly to the OSDs therefore enables a single client to dramatically increase
    its processing rate.
  prefs: []
  type: TYPE_NORMAL
- en: A simple example of where RADOS classes could be used is where you need to calculate
    a hash of every object in a RADOS pool and store each object's hash as an attribute.
    Having a client perform this would highlight the bottlenecks and extra latency
    introduced by having the client perform these operations remotely from the cluster.
    With a RADOS class that contains the required code to read the object, calculate
    the hash, and store it as an attribute, all that the client would need to do is
    send the command to OSD to execute the RADOS class.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a simple RADOS class in Lua
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the default RADOS classes in Ceph from the Kraken release onward is one
    that can run Lua scripts. The Lua script is dynamically passed to the Lua RADOS
    object class, which then executes the contents of the script. The scripts are
    typically passed in a JSON-formatted string to the object class. Although this
    brings advantages over the traditional RADOS object classes, which need to be
    compiled before they can be used, it also limits the complexity of what the Lua
    scripts can accomplish. As such, thought should be given as to what method is
    appropriate for the task you wish to accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: The following Python code example demonstrates how to create and pass a Lua
    script to be executed on an OSD. The Lua script reads the contents of the specified
    object and returns the string of text back in uppercase—all processing is done
    on the remote OSD, which holds the object; the original object contents are never
    sent to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the following into a file named `rados_lua.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now create a test object with all lowercase characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The Lua object class, by default, is not allowed to be called by OSDs; we need
    to add the following to all the OSDs in their `ceph.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, run our Python librados application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0adf336-56bf-4d42-ba72-f1ff32e6d768.png)'
  prefs: []
  type: TYPE_IMG
- en: You should see that the text from our object has been converted all into uppercase.
    You can see from the Python code earlier that we are not doing any of the conversion
    in the local Python code and it's all being done remotely on OSD.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a RADOS class that simulates distributed computing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the example given earlier, although using the Lua object class
    reduces the complexity to use RADOS object classes, there is a limit to what you
    can currently achieve. In order to write a class that is capable of performing
    more advanced processing, we need to fall back to writing the class in C. We will
    then need to compile the new class in the Ceph source.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this, we will write a new RADOS object class that will calculate
    the MD5 hash of the specified object and then store it as an attribute of the
    object. This process will be repeated 1,000 times to simulate a busy environment
    and also to make the runtime easier to measure. We will then compare the operating
    speed of doing this via the object class versus calculating the MD5 hash on the
    client. Although this is still a fairly basic task, it will allow us to produce
    a controlled repeatable scenario and to compare the speed of completing a task
    client-side, versus doing it directly on the OSD via a RADOS class. It will also
    serve as a good foundation to enable understanding on how to build more advanced
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the build environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the following command to clone the Ceph Git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69d09e92-d82c-46e7-b97d-43171512d2b1.png)'
  prefs: []
  type: TYPE_IMG
- en: Once we have cloned the Ceph Git repository, we need to edit the `CMakeLists.txt`
    file and add in a section for our new class that we are going to write.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the following file in the source tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, place the following in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `cmakelist.txt` file is updated, we can get `cmake` to make the build
    environment by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10128218-376d-47c2-abc9-edbf69ae4819.png)'
  prefs: []
  type: TYPE_IMG
- en: This will create a `build` directory in the source tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for us to build the RADOS class, we need to install the required packages
    that contain the `make` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There is also an `install-deps.sh` file in the Ceph source tree, which will
    install the remaining packages required when run.
  prefs: []
  type: TYPE_NORMAL
- en: RADOS classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code sample is a RADOS class which, when executed, reads the
    object, calculates the MD5 hash, and then writes it as an attribute to the object
    without any client involvement. Each time this class is called, it repeats this
    operation 1,000 times locally to OSD and only notifies the client at the end of
    this processing. We have the following steps to perform:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the directory for our new RADOS class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the C++ source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Place the following code in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Change into the `build` directory created previously and create our new RADOS
    class using `make`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding commands will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/097bb01b-db8d-47b9-b498-9f685877d95c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Copy our new class to the OSDs in our cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65c7d0ca-a32d-4bb6-8239-bb1956684a1c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, restart the OSD for it to load the class. You will now see in the Ceph
    OSD log that it is loading our new class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9fb391a-ee0e-46f1-a28f-74491e44a1b6.png)'
  prefs: []
  type: TYPE_IMG
- en: This needs to be repeated for all OSD nodes in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Client librados applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, we will use two librados applications, one to calculate
    the MD5 hash directly on the client, and another to call our RADOS class and have
    it calculate the MD5 hash. The applications both need to be run from the monitor
    nodes in the test cluster, but can be compiled on any node and copied across if
    desired. For the purpose of this example, we will compile the applications directly
    on the monitor nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, let''s make sure that the build environment is present on
    the monitor node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Calculating MD5 on the client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following code sample is the librados client-side application, which will
    read the object from the OSD, calculate the MD5 hash of the object on the client,
    and write it back as an attribute to the object. This is doing the calculation
    and storage in the same way as the RADOS class, with the only difference being
    the location of the processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `rados_md5.cc` and incorporate the following in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Calculating MD5 on the OSD via the RADOS class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, the last code sample is the librados application, which instructs OSD
    to calculate the MD5 hash locally without transferring any data to or from the
    client. You will note that the code given later has no librados read or write
    statements and relies purely on the `exec` function to trigger the MD5 hash creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `rados_class_md5.cc` and place the following in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now compile both applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27f1e01a-244f-4c54-a5c4-4383f2cdc6fc.png)'
  prefs: []
  type: TYPE_IMG
- en: If the applications compile successfully, there will be no output.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will run the two librados applications using the standard Linux `time` utility
    to measure how long each run takes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/968838b3-03ba-4f0f-b610-621c8175d5c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s make sure that the attribute was actually created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a84172d-0064-43f6-b64b-67c89c384e8e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s delete the object attribute, so we can be certain that the RADOS class
    correctly creates it when it runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, run the application that performs the MD5 calculation via the RADOS
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e10f780-bbd9-42de-a0b8-cc195c17b215.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, using the RADOS class method is a lot faster, in fact, almost
    two orders of magnitude faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, let''s also confirm that the attribute was created and that the code
    ran 1,000 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b22b796d-d358-49ba-a020-6338bcdfbb2d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Due to the logging we inserted in the RADOS class, we can also check the OSD
    logs to confirm that the RADOS class did indeed run 1,000 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57ba3987-a567-471d-b4ac-8d4ef88a5e9f.png)'
  prefs: []
  type: TYPE_IMG
- en: When repeating small tasks, the overhead of communication between the client
    and OSDs really adds up. By moving processing directly to OSD, we can eliminate
    this.
  prefs: []
  type: TYPE_NORMAL
- en: RADOS class caveats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we have seen the power that can be harnessed using Ceph's RADOS classes,
    it's important to note that this is achieved by calling your own customized code
    from deep inside OSDs. As a consequence, great care needs to be taken that your
    RADOS class is bug free. A RADOS class has the ability to modify any data on your
    Ceph cluster, and so accidental data corruption is easily possible. It is also
    possible for the RADOS class to crash the OSD process. If the class is used in
    large-scale cluster operations, this has the ability to affect all OSDs in the
    cluster, so great care should be taken to ensure that error handling is done properly
    to avoid errors.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now have an understanding of what RADOS classes are and how they
    can be used to speed up processing by moving tasks directly to OSD. From building
    simple classes via Lua to developing classes in the Ceph source tree via C++,
    you should now have the knowledge to build a RADOS class for whatever problem
    you are trying to solve. By building on this concept, there is nothing stopping
    you from creating a larger application that can take advantage of the scale-out
    nature of a Ceph cluster to provide large amounts of storage and compute resources.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use some examples to explore the importance of
    monitoring in Ceph.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What Ceph component are RADOS classes executed in?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What languages can RADOS classes be written in?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What advantages do RADOS classes bring?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What disadvantages do RADOS classes bring?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
