- en: Introducing the GitLab Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the context of the GitLab project will help us to appreciate the
    choices that were made with regard to the design of the GitLab workflow. The GitLab
    project started out as a small, open source project, and has grown to be an organization
    of 400 people and thousands of volunteers. It is currently available in two versions,
    a free **Community Edition** (**CE**) and an **Enterprise Edition** (**EE**) with
    a proprietary license. There are several tiers of support for the enterprise version.
    Although it is proprietary licensed, the source code for that version is publicly
    available from GitLab.
  prefs: []
  type: TYPE_NORMAL
- en: To master GitLab, it is necessary to have a solid understanding of its individual
    components. In this chapter, we will look at the basic components of a GitLab
    installation, paying special attention to GitLab **Continuous Integration** (**CI**)
    and the accompanying runners. As the different components can be distributed across
    servers or even cloud providers, we will also provide an overview of those providers
    and how GitLab views them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The origins of GitLab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitLab CE or EE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The core components of GitLab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitLab CI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitLab Runners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud native
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with the instructions in this chapter, please download the Git
    repository with examples**,** available at GitHub: [https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter01](https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter01). You
    will also require Homebrew: [https://brew.sh/](https://brew.sh/).
  prefs: []
  type: TYPE_NORMAL
- en: The origins of GitLab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The story began in 2011, when Dimitri Zaporozhets, a web programmer from Ukraine,
    was faced with a common problem. He wanted to switch to Git for version management
    and GitHub to collaborate, but that was not allowed in his company. He needed
    a tool that did not hinder him in developing code and was easy to use. Like many
    developers, he had issues with the collaboration tool that he was obliged to use.
    To get around those issues, he created his side project in Ruby on Rails: GitLab.
    Together with his colleague, Valery Sizov, he developed this project alongside
    his regular work.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After this initiative, the project grew enormously:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Date** | **Fact** |'
  prefs: []
  type: TYPE_TB
- en: '| 2011 | Sytze Sybrandij, the future CEO of GitLab, is impressed by the GitLab
    project and code, and offers Zaporozhets the opportunity to try to commercialize
    it via [https://about.gitlab.com/.](https://about.gitlab.com/) |'
  prefs: []
  type: TYPE_TB
- en: '| 2012 | GitLab was announced to a broader audience via Hacker News ([https://news.ycombinator.com/item?id=4428278](https://news.ycombinator.com/item?id=4428278)).
    |'
  prefs: []
  type: TYPE_TB
- en: '| 2013 | Dimitri Zaporozhets decides to work full-time on GitLab and joins
    the company. |'
  prefs: []
  type: TYPE_TB
- en: '| 2015 | GitLab becomes part of the Y Combinator class and received VC funding
    that year. |'
  prefs: []
  type: TYPE_TB
- en: '| 2018 | GitLab receives another $100 million of VC funding and is valued at
    $1 billion. |'
  prefs: []
  type: TYPE_TB
- en: '| 2019 | The GitLab company employs over 600 employees. |'
  prefs: []
  type: TYPE_TB
- en: The initial idea of GitLab was to earn money from open source technology by
    offering support services. However, what happened was that companies started to
    bring in consultants only to upgrade GitLab, and then they would stop the service
    contract. It became clear that going for a 100% open source was not going to be
    competitive. Instead of this, therefore, they chose **open core**. Under open
    core, a company releases a core software system under an open source license.
    A different version of the software is sold under a commercial license and contains
    more features.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, GitLab was split up into two editions: an open source version, and an enterprise
    version.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring GitLab editions – CE and EE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core of the GitLab software is called the **CE**. It is distributed under
    the MIT license, which is a permissive free software license created at the Massachusetts
    Institute of Technology. You are allowed to modify the software and use it in
    your creations.
  prefs: []
  type: TYPE_NORMAL
- en: No feature that ever made it to CE will ever be removed, or moved to a closed
    source version. When GitLab EE was created in 2013, it was, at its core, GitLab
    CE, but it had additional enterprise features, such as **Lightweight Directory
    Access Protocol** (**LDAP**) groups. Those features are not open source, per se,
    but can be added to the core version if they are perceived by the company as a
    core feature. The idea was that companies should also contribute as much as possible
    to solving problems and creating new features.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2016, the GitLab EE product was divided into three tiers: Starter, Premium,
    and Ultimate. Each tier is about five times more expensive than the previous one
    and contains more features and support options, as mentioned in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Version** | **Features (short list)** |'
  prefs: []
  type: TYPE_TB
- en: '| Starter | Everything on core GitLab CE:'
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Issue Board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mattermost integrations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time tracking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitLab pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Premium | More enterprise features such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Maven and NPM repository functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protected environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Burndown charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple LDAP servers and Active Directory support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Ultimate | All options, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: All security scanning tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Epics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Free guest users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web terminal for the web IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: GitLab has a lot of features, but let's concentrate first on the basic building
    blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The core system components of GitLab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GitLab is not a monolithic application. It tries to follow the Unix philosophy,
    which means that a software module should do only one particular thing, and do
    it well. The components that GitLab is made of are not as small and elegant as
    Unix''s `awk` and `sed`, but each component has a single purpose. You can find
    a high-level overview of these components in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9662aa4-972d-4c6f-9b9b-c406e97a3768.png)'
  prefs: []
  type: TYPE_IMG
- en: Gitlab started as a pure Ruby on Rails application, but some components were later
    redesigned using Go. Ruby on Rails is a development framework built on top of
    the Ruby programming language. It implements a model-view-controller pattern and
    offers methods to connect to different databases (for example, ActiveRecord).
    It values convention over configuration and **don't-repeat-yourself** (**DRY**)
    programming. It is very well suited to rapid development, and at the same time,
    it is highly performant and has many features.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive a little deeper into those components in order to understand their
    roles.
  prefs: []
  type: TYPE_NORMAL
- en: NGINX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Unicorn web component cannot be used directly as it does not offer all
    the features for handling clients. The reverse proxy that is bundled by default
    is NGINX. It is also possible to use Apache as a frontend for GitLab, but it is
    preferable to use NGINX. There are many web servers available that could be installed
    in front of Unicorn, but in the end, there are basically two types, which are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Process-based (forking or threaded)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NGINX and lighttpd are probably the two most-well known asynchronous servers.
    Apache is without a doubt the de facto standard process-based server. The biggest
    difference between the two types is how they handle scalability. For a process-based
    server, any new connections require a thread, while an event-driven, asynchronous
    server such as NGINX only needs a few threads (or, theoretically, only one). For
    lighter workloads, this does not matter much, but you will see a big difference
    when the number of connections grows, especially in terms of RAM. When serving
    tens of thousands of simultaneous connections, the amount of RAM used by NGINX
    would still hover around a couple of megabytes. Apache would either use hundreds,
    or it would not work at all. This is why NGINX is the better choice.
  prefs: []
  type: TYPE_NORMAL
- en: You can run NGINX on many platforms and it is quite easy to install, as you
    can see in the next section, where you'll try it yourself!
  prefs: []
  type: TYPE_NORMAL
- en: Installing NGINX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NGINX is part of most package management repositories, including `yum` and `apt`.
    Installing NGINX on `apt`-based distributions such as Debian and Ubuntu would
    involve the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'On macOS, we can use `brew` for a fast one-line command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, it is always possible to install from the source. Remember to install
    the dependencies first. These include PCRE, zlib, and OpenSSL. You can find the
    source code at the following website: [http://nginx.org/en/download.html](http://nginx.org/en/download.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Before you start NGINX, you need to provide a configuration file for it to connect
    to the Unicorn web component. The interface between the two servers is a local
    Unix domain socket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please create a file called `nginx.config` and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding section is mandatory and you can specify how NGINX will handle
    connections. For this example, we just accept the default; that is why the section
    is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next section is an HTTP block. You can define several and let settings
    be inherited, but here, we define that HTTP requests should be redirected to `upstream
    gitlab-app`, which is Unicorn. You can also see that the interface is the Unix
    socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we have defined how NGINX connects to the backend, which is GitLab. On
    the frontend, we want to accept requests from HTTP clients. This is taken care
    of via a `server` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The next directive inside this block handles a path that doesn''t exist on
    disk. It forwards the request to the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the definition of `gitlab-app`, and it modifies request headers
    to proxy the request to the upstream Unicorn server via the Unix socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to close the server and HTTP block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a configuration, you can run this NGINX in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The command should return no output and the NGINX server runs in the background.
    You canverify this yourselfby checking the process list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have a running NGINX server, if you point your browser to `http://localhost:8080`, you
    should receive a 502 error. This is because there is no Unicorn server listening
    on a Unix socket yet. We will demonstrate how to run Unicorn in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Unicorn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unicorn is an HTTP server for applications that deal with well-performing clients
    on connections that show low latency and have enough bandwidth. It takes advantage
    of features that are present in the core of Linux-like systems. It is called a
    **Rack HTTP server** because it implements HTTP for Rack applications. Rack, in
    turn, is actually a Ruby implementation of a minimal interface to deal with web
    requests, which you can use in your code.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the project at [https://rack.github.io](https://rack.github.io).
  prefs: []
  type: TYPE_NORMAL
- en: Unicorn runs as a daemon server in Unix and is programmed in Ruby and the C
    programming language. Using Ruby means that it can also run a Ruby on Rails application
    such as GitLab.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a grasp of the basic concepts of Unicorn, we can install it,
    and also connect NGINX, which we installed earlier, to it.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Unicorn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have Ruby installed, you can easily install Unicorn using the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is installing Ruby on Rails:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step it to install the Unicorn server binary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s continue with installing web documents in `/usr/local/www`. We''ll begin
    by creating the directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create our Rails application that is to be served with Unicorn:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After an enormous output, which may look a bit scary, there is a preconfigured
    application ready for you. Let''s configure Unicorn to serve it. We can get a
    default configuration file here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to change some things. Let''s start by making a variable for the basic
    application folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can change the following paths:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Unicorn can listen on ports and/or sockets. We are going to use listen on a
    Unix socket because that is the shortest path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can start Unicorn with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If NGINX was started earlier as well, we can now point our browser to `http://localhost:8080`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, maybe you encountered errors and want to find out what went wrong. It may
    be necessary to know how to debug NGINX and Unicorn when there are problems. This
    will be covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging Unicorn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maybe installing Unicorn produced errors, or you are experiencing bad performance
    that you suspect is caused by Unicorn not working properly.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to find the cause. The log files can point you in the
    right direction.
  prefs: []
  type: TYPE_NORMAL
- en: Timeouts in Unicorn logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following output is what a Unicorn worker timeout looks like in `unicorn_stderr.log`.
    This is not necessarily bad; it just means that a new worker is spawned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It could be that there are just not enough Unicorn workers available to respond
    to the requests at hand. NGINX buffers a lot of requests so we must check on the
    handover socket whether Unicorn can keep up. To do this,a little nifty script
    is available here: [https://github.com/jahio/unicorn-status](https://github.com/jahio/unicorn-status).'
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be called with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The first argument here is the `unicorn_status.rb` script, the second is the
    socket to connect to `../.socket`, and the last argument is the poll interval
    (`10`).
  prefs: []
  type: TYPE_NORMAL
- en: Unicorn processes disappear
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On Linux, there is a mechanism called **Out-of-Memory** (**OOM**) **Killer**
    that will free up memory if the system is running low on memory, and you don't
    have any swap memory left. It might kill Unicorn if it is using too much memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `dmesg | egrep -i ''killed process''` to search for OOM events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Other kinds of errors or 100% CPU load
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ultimate way to debug Unicorn processes is to run strace on them:'
  prefs: []
  type: TYPE_NORMAL
- en: Run `sudo gdb -p (PID)` to attach to the Unicorn process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run `call (void) rb_backtrace()` in the GDB console and find the generated
    Ruby backtrace in `/var/log/gitlab/unicorn/unicorn_stderr.log`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When you are done, leave GDB with `detach` and `exit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sidekiq
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Sidekiq** is a framework for background job processing. It allows you to
    scale your application by performing work in the background. For more information
    on Sidekiq, consult the following website: [https://github.com/mperham/sidekiq/wiki](https://github.com/mperham/sidekiq/wiki).'
  prefs: []
  type: TYPE_NORMAL
- en: Each Sidekiq server process pulls jobs from the queue in Redis and processes
    them. Like your web processes, Sidekiq boots Rails so that your jobs and workers
    have the full Rails API available for use, including ActiveRecord. The server
    will instantiate the worker and call perform with the given arguments. Everything
    else is up to your code.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Sidekiq
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s very easy to start using Sidekiq. It can be installed as `gem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, some dependencies are installed as well, such as Redis, connection
    pooling, Rack, and Rack protection.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging Sidekiq
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with Unicorn, there are several ways to debug Sidekiq processing. The easiest
    way is to log in to GitLab as an administrator and view the logs from there, and
    especially view the queues and jobs on the Background Jobs page, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6577d62-2591-45a1-b48d-e7caacf8e987.png)'
  prefs: []
  type: TYPE_IMG
- en: Sometimes, you experience troubles and find situations on your Linux server.
  prefs: []
  type: TYPE_NORMAL
- en: Sidekiq processes disappear
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned before, in the Unicorn section, the OOM Killer might kill Sidekiq
    if it is using too much memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `dmesg | egrep -i ''killed process''` to search for OOM events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A Sidekiq process is seemingly doing nothing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If Sidekiq isn't doing any work and it seems stuck most of the time, this means
    that the program is waiting for something. A common wait situation is when you
    are doing remote network calls. If you think this could be the case, you could
    make Sidekiq processes dump a backtrace to the log by sending it a TTIN signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what a Sidekiq worker looks like in the log file in `/var/log/gitlan/sidekiq/current`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Since GitLab 12.0, the default output log format for Sidekiq is JSON, this makes
    it easier to read the log files into a tool like logstash because it is more structured.
  prefs: []
  type: TYPE_NORMAL
- en: Other kind of errors or 100% CPU load
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ultimate way to debug Sidekiq processes is to make it dump a backtrace
    via GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: Run `sudo gdb -p (PID)` to attach to the Sidekiq worker process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run `call (void) rb_backtrace()` in the GDB console and find the generated
    Ruby backtrace in `/var/log/gitlab/sidekiq/current`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It is very hard to read backtraces, but this process was doing network operations
    while being traced, we can see a  (`_read_from _socket`). You can read the source
    code to check what it is doing (there are line numbers mentioned).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you are done, leave GDB with `detach` and quit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also use other tracing tools to examine the behavior of the looping
    process. On Linux, for instance, `strace -p <pid>` allows you to view the system
    calls that are being made by the process.
  prefs: []
  type: TYPE_NORMAL
- en: GitLab Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This component is used to provide access to Git repositories through SSH. In
    fact, for pushes via the `git-http` protocol, it is also called instead of the
    Rails app. It's essentially a small Ruby wrapper around the Git client. Git, through
    SSH, uses predefined commands that can be executed on the GitLab server. For authorization,
    it makes calls to the GitLab API. Before GitLab 5.0, this functionality was delivered
    by Gitolite and powered by the Perl programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code of this project can be found here: [https://gitlab.com/gitlab-org/gitlab-shell](https://gitlab.com/gitlab-org/gitlab-shell).
    You can see the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2bdece6-99dd-4f04-acf2-0f287a96396c.png)'
  prefs: []
  type: TYPE_IMG
- en: You can install it locally, but it's really only useful when deployed together
    with other GitLab components. When you have that installed (see [Chapter 2](8e9ca130-15d0-4c6e-af6b-2fe5292f3618.xhtml),
    *Installing GitLab*, for instructions on how), the next section describes a way
    to debug when you have problems.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging GitLab Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In an omnibus installation, the log file for GitLab Shell can be found in the
    following location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it may be found in the following location, for installations
    from source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'What you will generally find are log lines that concern the basic operations
    of GitLab Shell:'
  prefs: []
  type: TYPE_NORMAL
- en: Git commands (such as `git push` and `git pull`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization calls to the GitLab Rails API to check whether you are allowed
    to connect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution of pre-receive hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actions requested
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Post-receive actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any custom post-receive actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, we have listed some lines from the log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: One way to find errors is to look for certain patterns, such as `failed`, as
    follows. This particular error points to a 500 error from Unicorn while checking
    whether a user has the right authorization to make a call to the GitLab API.
  prefs: []
  type: TYPE_NORMAL
- en: 'This error should show up in the Unicorn logs (`production.log`) if you search
    for an HTTP 500 error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Redis is a caching tool and HTTP session store that allows you to save cached
    data and session information from your website to an external location. This means
    that your website doesn''t have to calculate everything every time; instead, it
    can retrieve the data from the cache and load the website much faster. The user
    sessions are in memory even if the application goes down. Redis is a fast caching
    tool because it uses memory first. It has several useful advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Everything is stored in one place, so you only have to flush one cache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is faster than Memcache. This is noticeable when using the websites of large
    shops.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sessions are stored in memory and not in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The backend becomes faster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redis is not merely a cache, but is also a data structure store. It is basically
    a database and should be viewed conceptually as such. With regard to its operation
    and how it handles data, it has more in common with a NoSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Redis is available through all major package management systems. The following
    are the commands used to install it on different platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is for Mac with Homebrew installed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This is for Linux Ubuntu or other APT-based distributions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is for Red Hat or other YUM-based distributions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: However, the preferred way of installing Redis is by compiling it from the source.
    This way, you can easily stay up to date. It has no special dependencies other
    than the GCC compiler and the standard C library. You can find the latest stable
    version at [http://download.redis.io/redis-stable.tar.gz](http://download.redis.io/redis-stable.tar.gz).
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing and compiling it is as easy as entering the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: After completing this successfully, you can choose to carry out the next logical
    step, which is to issue `make test` to execute tests against compiled sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the binary in a useful place, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'For a further explanation about the structure that has been compiled, go to
    the `src` directory. You will find the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '`redis-server`: The Redis server program'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redis-sentinel`: This is used to monitor Redis clusters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redis-cli`: The command-line program to control Redis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redis-benchmark`: The program to be used to measure Redis performance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redis-check-aof` and `redis-check-dump`: Utilities to assist when there is
    data corruption'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we have everything in place, let's start the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'When installed on macOS with `brew`, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'On other platforms, when built from the source, you can directly start the
    Redis server by running the `redis-server` command. In a fresh shell window, type
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'After hitting *Enter*, you will see the server starting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aac23216-7d52-47e3-b04c-2c1dc3ee461e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can test whether your Redis instance is working by issuing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When Redis is operational, there will be a reaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If you receive `PONG`, then everything is in order.
  prefs: []
  type: TYPE_NORMAL
- en: Basic data operations in Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s discover some of the basics of Redis by playing with the data structures.
    Start the `redis-cli` command-line utility again without the `ping` argument,
    and it will connect to the local Redis server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It is not fair to view Redis as a simple hash database with key values. But
    still, the five data structures that are provided do actually consist of a key
    and a value. Let''s sum up the five data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '**String**: You can use the `set` command to write a value to Redis. In the
    case of a simple string, you can simply save the value in the datastore shown
    as follows. After setting the string value, you can retrieve the value again by
    issuing the `get` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '**Hash**: In the same way as the string, you can `set` an arbitrary number
    of values to a key. Generally speaking, Redis treats values as a byte array and
    doesn''t care what they are. This make Redis very handy for representing objects.
    Again, with the `get` command, you can retrieve the values. GitLab uses this type
    to store web session information from users:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '**List**: The list type in Redis is implemented as a linked list. You can add items
    to the listquite quickly with `rpush` (right push, to the tail of the list) or
    `lpush` (left push, to the head of the list). On the other hand, accessing an
    item by index is not that fast because it has to search the linked list. Still,
    for a queue mechanism, this is a good solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '**Sets**: Another datatype is the set. You add members with the `sadd` command.
    Don''t forget that these sets are unordered, so if you ask for the members with
    `smembers`, the order will mostly be different to how you entered it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '**Sorted sets**: Fortunately, there is an ordered set as well. It is almost
    the same, but one difference is that you add a score to the entry, and that will
    automatically score the sort order, as you can see from the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Gitaly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first versions of GitLab, all Git operations relied on using a local
    disk or network share. Gitaly is a project that tries to eliminate reliance on
    the **Network File System** (**NFS**). Instead of calls to a filesystem service,
    Gitaly provides GitLab with a system based on **Remote Procedure Calls** (**RPCs**)
    to access Git repositories. It is written in Go and uses **gRPC Remote Procedure**
    **Call** (**gRPC**), a cross-platform RPC framework from Google. It has been steadily
    developing since the beginning of 2017, and since GitLab 11.4, it can replace
    the need for a shared NFS filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find an overview of Gitaly and its place in the GitLab architecture
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/604f4f42-3c54-490d-8b34-5c07ae8217a1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On a small installation, it runs in the same servers as all other components.
    In big clustered environments, you can set up dedicated Gitaly servers, which
    can be used by Gitaly clients such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Unicorn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sidekiq
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gitlab-workhorse`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gitlab-shell`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elasticsearch indexer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gitaly as a client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The source code of this project can be found here: [https://gitlab.com/gitlab-org/gitaly](https://gitlab.com/gitlab-org/gitaly)[.](https://gitlab.com/gitlab-org/gitaly)'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging Gitaly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use debugging tools that are available for Golang. But for starters,
    you can take a look at the log file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For source installs, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'For Omnibus installations, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of a log line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You can see the log level is `info` and this is a log event that captures a
    Git SSH command (`method=SSHUploadPack`). It started a Git `pack` command on the
    server, which means it rearranged and compressed data in a repository.
  prefs: []
  type: TYPE_NORMAL
- en: To generate more verbose logging, you can set the log level to a debug in the
    configuration file. It is configured via a **Tom's Obvious Minimal Language**
    (**TOML**) configuration file. This file is documented in the Gitaly source code
    repository mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'For source installations, look here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You can change the following section and change the level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'For Omnibus installs, the following directives can be added to `gitlab.rb`
    to influence the level of monitoring of Gitaly. Set it to `debug` to enable debug-level
    logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: GitLab Workhorse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GitLab Workhorse is a sophisticated reverse proxy that is set up in front of
    GitLab. Initially conceived to solve the problem of handling `git-http` requests,
    it started as a weekend project with the name `gitlab-git-httpserver`. The functionality
    was previously delivered by `gitlab-grack` ([https://gitlab.com/gitlab-org/gitlab-grack](https://gitlab.com/gitlab-org/gitlab-grack)). The
    main web application server, Unicorn, was not especially suited to cater for these
    requests, which can take a long time to finish. Handling these directly in Unicorn
    actually reverses the advantages that Unicorn can provide: fast and scalable HTTP
    requests.'
  prefs: []
  type: TYPE_NORMAL
- en: Workhorse was created in Golang, and was conceived by Jacob Vosmaer, one of
    the GitLab developers. You can read all about the process of creating it at [https://about.gitlab.com/2016/04/12/a-brief-history-of-gitlab-workhorse/](https://about.gitlab.com/2016/04/12/a-brief-history-of-gitlab-workhorse/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it was first designed to handle the Git HTTP protocol, GitLab Workhorse
    increasingly gained functionalities, such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: Certain static files, such as JavaScript and CSS files, are served directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can intercept requests from Rails about opening a file. Workhorse will open
    the file and send the content in the response body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can intercept calls for Git **Large File Storage** (**LFS**) and insert a
    temporary path after preparing the file in the upload location. Git LFS is a feature
    where large files can be stored outside the project space in GitLab.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can control WebSocket connections for Rails, such as the terminal output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Workhorse sits behind NGINX, which handles request routing and SSL termination.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging GitLab Workhorse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As workhorse is a Golang written application, you can use methods for this language
    to debug programs.
  prefs: []
  type: TYPE_NORMAL
- en: It also supports remote error logging with Sentry. To activate this feature,
    set the `GITLAB_WORKHORSE_SENTRY_DSN` environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: '**For Omnibus installations**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is defined in the file (`/etc/gitlab/gitlab.rb`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '**For Source installations**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following environment variable can be set in the file (/`etc/default/gitlab`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the first thing to look at is the log files that are produced by
    this component. On an Omnibus-based GitLab installation, you can find them in
    `/var/log/gitlab/gitlab-workhorse`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an excerpt of the default log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding log file, you see, for example, `git-http` operations such
    as `git-upload-pack`.
  prefs: []
  type: TYPE_NORMAL
- en: Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two database varieties available for GitLab: PostgreSQL and MySQL/MariaDB.
    The use of the latter is not recommended because the fast development of iterations
    of GitLab, as a product, have focused primarily on PostgreSQL, meaning that a
    number of optimizations are not available on MySQL. Furthermore, the zero-downtime
    method is not available when using MySQL, and neither are features such as subgroups
    and GEO, which will be explained later in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: As explained earlier, Ruby on Rails uses a so-called MVC approach. MVC is a
    well known architectural pattern that was developed by Trygve Reenskaug in the
    Smalltalk language. It was later enhanced for web applications (Model 2). The
    model in MVC is implemented by the `ActiveRecord` library, which is part of Ruby
    on Rails.
  prefs: []
  type: TYPE_NORMAL
- en: 'The authoritative source for the data model can be found here: [https://gitlab.com/gitlab-org/gitlab-ee/blob/master/db/schema.rb](https://gitlab.com/gitlab-org/gitlab-ee/blob/master/db/schema.rb).
    It is auto generated and represents the current state of the database.'
  prefs: []
  type: TYPE_NORMAL
- en: The default PostgreSQL database that is included in the Omnibus package can
    handle workloads for up to 10,000 users. Also, if you would like to create a **Disaster
    Recovery** (**DR**) plan using a cold standby setup, you can use specific failover
    mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: 'A frequently used technique is to create a cold standby database (PostgreSQL
    DB 2) at another site, as illustrated by the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37c0d3a0-1133-4125-ba0e-84de5982ddc0.png)'
  prefs: []
  type: TYPE_IMG
- en: When you want to scale or increase the number of application servers, you need
    to scale the database too. There are three important aspects of database scaling.
    Firstly, you want to be able to scale database client connections as efficiently
    as possible. To do this, you can use PgBouncer, which is a lightweight connection
    pooler.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, you want to have several database instances, one being the master
    node, and replicate the data from the master to the slave. In the former, DR situation,
    this was done by the basic built-in replication mechanism of PostgreSQL. In the
    current situation, a specific tool, repmgr, is used, a tool for clustering PostgreSQL and
    handling the failover.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a service discovery tool such as **Consul** can be used to detect the
    PostgreSQL status of each node, and update the PGbouncer service setting that
    determines which Postgres instance to connect to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting architecture is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/682c99a5-6e3f-4586-bf5c-66fff93cef8f.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, there are different ways of setting up your database for GitLab.
    The architectures highlighted in the preceding diagram will be used in examples
    for building high-availability environments in *Scaling the Server Infrastructure
    (High- Availability Setup*) section of this book.
  prefs: []
  type: TYPE_NORMAL
- en: GitLab CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitLab CI is a feature that helps perform the **Continuous Integration** (**CI**)
    of software components. When several developers work together using a versioning
    system, problems can arise when changes made by one developer break the product
    as a whole. The best way to make sure this happens less often, or at least early
    in the process, is to use integration tests more frequently, hence the name continuous.
  prefs: []
  type: TYPE_NORMAL
- en: GitLab CI was launched as a standalone project in 2013, but was later integrated
    into the main GitLab package. Combined with the GitLab Runner software, this feature
    has been very popular with developers and is an important driver of the business.
    It also enabled GitLab to build their product into a solution that not only does
    CI, but even continuous delivery up to production environments. The current product
    vision for GitLab is to serve as a complete DevOps life cycle product, from idea
    to production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Forrester classified GitLab as a leader in CI in *The Forrester Wave: Continuous
    Integration Tools, Q3 2017*. This is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/baa860a0-b398-48a1-9f42-754053ffd5d1.png)'
  prefs: []
  type: TYPE_IMG
- en: Feedback, one of the important aspects of the **Extreme Programming** (**XP**)
    movement, is an important element of GitLab CI. It also serves as a way to communicate
    between developers.
  prefs: []
  type: TYPE_NORMAL
- en: Pipelines and jobs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pipelines and build jobs are basic building blocks for a **Continuous Integrations/Continuous
    Delivery** (**CI/CD**) system nowadays. In GitLab, it is very easy to start a
    pipeline. You only need to add a `.gitlab-ci.yml` file to your project and then,
    on every commit/push to your repository, a pipeline will start. Every project
    has a pipeline''s overview; you can find it in the left-hand menu bar, under CI/CD:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9500b78c-c838-4e0f-ba0d-724581246c4c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, you can view all jobs, by going to the Pipelines'' Jobs page,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3a96279-4d98-4ae2-a324-1e8de043d63f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can check the log of a job by clicking on the status of the job (for example,
    **failed** or **passed**). You can debug why some jobs fail and see exactly what
    happened:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2751d76-eda1-4258-b975-69917c7e97ae.png)'
  prefs: []
  type: TYPE_IMG
- en: The importance of using pipelines and jobs for CI/CD cannot be overstated. In
    this section, you've seen the basic interface to pipelines in GitLab, but in several
    chapters time, this will be discussed in more detail (*Utilizing GitLab CI and
    CI Runners* section).
  prefs: []
  type: TYPE_NORMAL
- en: GitLab Runners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitLab Runners were originally developed by Kamil Trzciński in 2015\. They're
    now one of the most popular features of GitLab.
  prefs: []
  type: TYPE_NORMAL
- en: The initial GitLab-CI-Runner was a very simple application written in Ruby,
    but worked well in quite basic setups. You can think of it as a reference implementation
    of what a bare runner could look like.
  prefs: []
  type: TYPE_NORMAL
- en: Issues with the old runner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main problem with the old runner is that it could only run one concurrent
    job at a time. If you wanted to run more, you could either set up a new server
    or create an additional user to build jobs.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, it always ran projects on the server shell. This made it really hard
    to test projects using different versions of Ruby or any other dependencies. It
    was not stateless, meaning you had a contaminated build environment. Builds were
    therefore not very trustworthy. Nowadays, having a stateless and clean build environment
    every time is essential.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect of the old Runner that made it less favorable was that it only
    ran on Linux-based platforms. To make it work on macOS, a big GitLab user platform,
    you had to carry out additional hacking. Support for Microsoft Windows was out
    of the question.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there were some heavy administrative burdens. The server was hard to
    scale, because setting up a new server took a long time due to the dependencies
    you needed to take care of in order to build projects.
  prefs: []
  type: TYPE_NORMAL
- en: The newer runner is a binary that you can put on a machine of any kind. It is
    really easy to set up as a service and can work with multiple projects and multiple
    GitLab CI coordinators. It also provides support for Docker, making it really
    easy to set up a build environment with different versions.
  prefs: []
  type: TYPE_NORMAL
- en: Switching to Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go (or Golang) is a new language (less than 10 years old). It is already widely
    used by some impressive parties, such as Docker ([https://docker.com](https://docker.com)),
    Google, Kubernetes ([https://kubernetes.io](https://kubernetes.io)), and Prometheus
    ([https://prometheus.io](https://prometheus.io)). Go is a versatile tool that
    can help you to program at a low level, close to the operating system or at a
    high level in a language such as Java. It is perfectly suited to creating systems
    software. The language was created in 2009 by R. Griesemer, R. Pike, and K.Thompson
    while working for Google. The latter is very famous for co-creating the first
    Unix implementation and the B programming language. The most important feature
    of the Go language is that it can compile one binary without dependencies for
    multiple operating systems such as Linux, macOS, the BSDs, and Windows. This also
    means it runs on different processor architectures (i386, amd64, ARM, and PowerPC).
  prefs: []
  type: TYPE_NORMAL
- en: 'A short list of the benefits of Go follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Very good standard libraries (with good optional ones available elsewhere).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is very fast to develop and test in Go.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The culture/community chooses boring solutions over complex ones (which is good).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cool tools such as Gofmt, race detector, and `go vet`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Made for concurrency—for instance, you can use goroutines and channels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type safety—will save you many times from run-time errors and wrongly defined
    data types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection—while programmers who use C know how to clean up, this can
    still be helpful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures or anonymous functions—enable the use of functional principles (higher-order
    functions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these characteristics make Go the perfect choice for GitLab Runners. With
    Go, you can create a relatively small binary that runs on a lot of platforms.
    It contains all that is needed to run your projects.
  prefs: []
  type: TYPE_NORMAL
- en: In a GitLab environment, jobs are being executed by the Runners. They run them
    as they are defined in a `.gitlab-ci.yml` file. The Runner itself can be running
    on a **Virtual Machine** (**VM**) such as VmWare (VM), VPS, a laptop, a Docker
    container, or in a Kubernetes cluster. Communication is one way from runner to
    GitLab and is mostly via an HTTP API, so that path must be accessible by the Runner.
  prefs: []
  type: TYPE_NORMAL
- en: The `.yml` file defines what stages your CI/CD pipeline has and what to do in
    each stage. This typically consists of build, test, and deploy stages.
  prefs: []
  type: TYPE_NORMAL
- en: GitLab mentions *boring* in its handbook as a valued way of reducing complexity;
    see [https://about.gitlab.com/handbook/values/#efficiency](https://about.gitlab.com/handbook/values/#efficiency).
  prefs: []
  type: TYPE_NORMAL
- en: 'The project can be found at [https://gitlab.com/gitlab-org/gitlab-runner](https://gitlab.com/gitlab-org/gitlab-runner):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2c04da4-3bda-4d67-a67d-12136489b33b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A runner can either be specific to a certain project or it can serve multiple
    projects in GitLab. If it serves all projects, it''s known as a Shared Runner. GitLab
    Runners implement a number of **executors** that can be used for your builds in
    different scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shell executor**: The runner simply executes a shell. The dependencies for
    the build have to be installed manually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker-based executor**: The runner runs from a container. This makes it
    easier to create clean builds because dependency management is shifted to the
    container image. It is also easier to create a build environment with services
    that need each other, such as PostgreSQL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Autoscaling Docker SSH**: A Docker machine creates instances with the Docker
    Engine to run Docker containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubernetes**: GitLab Runner can use Kubernetes to run builds on a Kubernetes
    cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runners have evolved enormously over the last couple of years. GitLab itself
    sees them as one of the most important components of their suite. This section
    has given more insight into the development of this popular tool.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud native
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Toward the end of 2016 and at the start of 2017, there was a public debate in
    the GitLab community about whether reverting back from the cloud to bare metal
    would be cost-effective for [GitLab.com](https://about.gitlab.com/). At the time,
    the filesystem used for repositories was Ceph. The performance of that distributed
    filesystem was not good enough to handle [GitLab.com](https://about.gitlab.com/).
    They asked the community for advice and received a lot of feedback from people
    who experienced similar moves firsthand. In the end, the decision was made to
    stay in the cloud ([https://about.gitlab.com/2017/03/02/why-we-are-not-leaving-the-cloud/](https://about.gitlab.com/2017/03/02/why-we-are-not-leaving-the-cloud/)).
    Instead, GitLab would focus on creating a solution, not on the filesystem level,
    but making sure that Git input/output (I/O) behavior is better managed at the
    application level. This can be seen as the birth of the Gitaly component. Sid
    Sijbrandij emphasized the importance of being a software company, not an infrastructure
    company.
  prefs: []
  type: TYPE_NORMAL
- en: 'In August 2018, GitLab migrated their cloud-based offering, [GitLab.com](https://about.gitlab.com/),
    from Azure to **Google Cloud Platform** (**GCP**). The main reason for switching
    to GCP according to CEO, Sid Sijbrandij was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Google as a public cloud, they have more experience than the other public
    cloud providers because they basically made a cloud for themselves [...] you find
    that in things such as networking, where their network quality is ahead of everyone
    else. It''s more reliable, it has less jitter, and it''s just really, really impressive
    how they do that, and we''re happy to start hosting GitLab.com on that."'
  prefs: []
  type: TYPE_NORMAL
- en: It seems the move paid off; users have reported that [GitLab.com](https://about.gitlab.com/)
    is noticeably faster. Another transformation that is likely to cause further acceleration
    soon is the move to using Kubernetes as a container orchestrator. This is an important
    part of their strategy to incorporate functionality in a lot of places in GitLab
    besides the autoscaling of GitLab runners. GitLab's own high-availability tool,
    GEO, was used to synchronize the data from one cloud to another. Running on Google's
    architecture also allows GitLab to utilize object-storage for particular features
    as well, such as Git LFS.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the people and the organization behind
    GitLab. Starting from the beginning, we have shown you how the project has developed
    over the years. We went through the core components of GitLab and how to install
    them. For some components, we included ways to debug the installation.
  prefs: []
  type: TYPE_NORMAL
- en: We also gave a brief introduction to GitLab CI and the client programs that
    interact with it, such as GitLab Runner. We showed you why this feature is so
    important and how it is perceived by the IT industry.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will install and configure GitLab on different kinds
    of systems. If you're new to the product, prepare to be amazed!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When and by whom was GitLab initially developed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is GitLab funded?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name all the programming languages that are used in the GitLab software.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which licenses are used by GitLab?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are they using these licenses?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the core components of GitLab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many offices does GitLab have?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is stored in Redis?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What has Gitaly replaced?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which cloud service was chosen by GitLab to focus on in 2018?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sidekiq—source and documentation: [https://github.com/mperham/sidekiq](https://github.com/mperham/sidekiq)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ruby on Rails: [https://rubyonrails.org](https://rubyonrails.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unicorn: [https://thorstenball.com/blog/2014/11/20/unicorn-unix-magic-tricks/](https://thorstenball.com/blog/2014/11/20/unicorn-unix-magic-tricks/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cloud Native programming with Golang* by *Mina Andrawos*, *Martin Helmich*: [https://www.packtpub.com/in/application-development/cloud-native-programming-golang](https://www.packtpub.com/in/application-development/cloud-native-programming-golang)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Nginx HTTP Server - Fourth Edition* by *Clement Nedelcu*, *Martin Fjordvald*: [https://www.packtpub.com/in/virtualization-and-cloud/nginx-http-server-fourth-edition](https://www.packtpub.com/in/virtualization-and-cloud/nginx-http-server-fourth-edition)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mastering Redis* by *Jeremy Nelson*: [https://www.packtpub.com/in/big-data-and-business-intelligence/mastering-redis](https://www.packtpub.com/in/big-data-and-business-intelligence/mastering-redis)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PostgreSQL Administration Cookbook, 9.5/9.6 Edition* by *Simon Riggs**,* *Gianni
    Ciolli*, *Gabriele Bartolini*: [https://www.packtpub.com/in/big-data-and-business-intelligence/postgresql-administration-cookbook-9596-edition](https://www.packtpub.com/in/big-data-and-business-intelligence/postgresql-administration-cookbook-9596-edition)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
