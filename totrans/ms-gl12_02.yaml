- en: Introducing the GitLab Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the context of the GitLab project will help us to appreciate the
    choices that were made with regard to the design of the GitLab workflow. The GitLab
    project started out as a small, open source project, and has grown to be an organization
    of 400 people and thousands of volunteers. It is currently available in two versions,
    a free **Community Edition** (**CE**) and an **Enterprise Edition** (**EE**) with
    a proprietary license. There are several tiers of support for the enterprise version.
    Although it is proprietary licensed, the source code for that version is publicly
    available from GitLab.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: To master GitLab, it is necessary to have a solid understanding of its individual
    components. In this chapter, we will look at the basic components of a GitLab
    installation, paying special attention to GitLab **Continuous Integration** (**CI**)
    and the accompanying runners. As the different components can be distributed across
    servers or even cloud providers, we will also provide an overview of those providers
    and how GitLab views them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The origins of GitLab
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitLab CE or EE
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The core components of GitLab
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitLab CI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitLab Runners
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud native
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with the instructions in this chapter, please download the Git
    repository with examples**,** available at GitHub: [https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter01](https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter01). You
    will also require Homebrew: [https://brew.sh/](https://brew.sh/).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The origins of GitLab
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The story began in 2011, when Dimitri Zaporozhets, a web programmer from Ukraine,
    was faced with a common problem. He wanted to switch to Git for version management
    and GitHub to collaborate, but that was not allowed in his company. He needed
    a tool that did not hinder him in developing code and was easy to use. Like many
    developers, he had issues with the collaboration tool that he was obliged to use.
    To get around those issues, he created his side project in Ruby on Rails: GitLab.
    Together with his colleague, Valery Sizov, he developed this project alongside
    his regular work.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'After this initiative, the project grew enormously:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '| **Date** | **Fact** |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
- en: '| 2011 | Sytze Sybrandij, the future CEO of GitLab, is impressed by the GitLab
    project and code, and offers Zaporozhets the opportunity to try to commercialize
    it via [https://about.gitlab.com/.](https://about.gitlab.com/) |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| 2012 | GitLab was announced to a broader audience via Hacker News ([https://news.ycombinator.com/item?id=4428278](https://news.ycombinator.com/item?id=4428278)).
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| 2013 | Dimitri Zaporozhets decides to work full-time on GitLab and joins
    the company. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| 2015 | GitLab becomes part of the Y Combinator class and received VC funding
    that year. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: '| 2018 | GitLab receives another $100 million of VC funding and is valued at
    $1 billion. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
- en: '| 2019 | The GitLab company employs over 600 employees. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
- en: The initial idea of GitLab was to earn money from open source technology by
    offering support services. However, what happened was that companies started to
    bring in consultants only to upgrade GitLab, and then they would stop the service
    contract. It became clear that going for a 100% open source was not going to be
    competitive. Instead of this, therefore, they chose **open core**. Under open
    core, a company releases a core software system under an open source license.
    A different version of the software is sold under a commercial license and contains
    more features.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'So, GitLab was split up into two editions: an open source version, and an enterprise
    version.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Exploring GitLab editions – CE and EE
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core of the GitLab software is called the **CE**. It is distributed under
    the MIT license, which is a permissive free software license created at the Massachusetts
    Institute of Technology. You are allowed to modify the software and use it in
    your creations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: No feature that ever made it to CE will ever be removed, or moved to a closed
    source version. When GitLab EE was created in 2013, it was, at its core, GitLab
    CE, but it had additional enterprise features, such as **Lightweight Directory
    Access Protocol** (**LDAP**) groups. Those features are not open source, per se,
    but can be added to the core version if they are perceived by the company as a
    core feature. The idea was that companies should also contribute as much as possible
    to solving problems and creating new features.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2016, the GitLab EE product was divided into three tiers: Starter, Premium,
    and Ultimate. Each tier is about five times more expensive than the previous one
    and contains more features and support options, as mentioned in the following
    table:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '| **Version** | **Features (short list)** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
- en: '| Starter | Everything on core GitLab CE:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Issue Board
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mattermost integrations
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time tracking
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitLab pages
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '| Premium | More enterprise features such as the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Maven and NPM repository functionality
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protected environments
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Burndown charts
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple LDAP servers and Active Directory support
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '| Ultimate | All options, including the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: All security scanning tools
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Epics
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Free guest users
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web terminal for the web IDE
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: GitLab has a lot of features, but let's concentrate first on the basic building
    blocks.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The core system components of GitLab
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GitLab is not a monolithic application. It tries to follow the Unix philosophy,
    which means that a software module should do only one particular thing, and do
    it well. The components that GitLab is made of are not as small and elegant as
    Unix''s `awk` and `sed`, but each component has a single purpose. You can find
    a high-level overview of these components in the following diagram:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9662aa4-972d-4c6f-9b9b-c406e97a3768.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: Gitlab started as a pure Ruby on Rails application, but some components were later
    redesigned using Go. Ruby on Rails is a development framework built on top of
    the Ruby programming language. It implements a model-view-controller pattern and
    offers methods to connect to different databases (for example, ActiveRecord).
    It values convention over configuration and **don't-repeat-yourself** (**DRY**)
    programming. It is very well suited to rapid development, and at the same time,
    it is highly performant and has many features.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive a little deeper into those components in order to understand their
    roles.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: NGINX
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Unicorn web component cannot be used directly as it does not offer all
    the features for handling clients. The reverse proxy that is bundled by default
    is NGINX. It is also possible to use Apache as a frontend for GitLab, but it is
    preferable to use NGINX. There are many web servers available that could be installed
    in front of Unicorn, but in the end, there are basically two types, which are
    as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Process-based (forking or threaded)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NGINX and lighttpd are probably the two most-well known asynchronous servers.
    Apache is without a doubt the de facto standard process-based server. The biggest
    difference between the two types is how they handle scalability. For a process-based
    server, any new connections require a thread, while an event-driven, asynchronous
    server such as NGINX only needs a few threads (or, theoretically, only one). For
    lighter workloads, this does not matter much, but you will see a big difference
    when the number of connections grows, especially in terms of RAM. When serving
    tens of thousands of simultaneous connections, the amount of RAM used by NGINX
    would still hover around a couple of megabytes. Apache would either use hundreds,
    or it would not work at all. This is why NGINX is the better choice.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: You can run NGINX on many platforms and it is quite easy to install, as you
    can see in the next section, where you'll try it yourself!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Installing NGINX
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NGINX is part of most package management repositories, including `yum` and `apt`.
    Installing NGINX on `apt`-based distributions such as Debian and Ubuntu would
    involve the following commands:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On macOS, we can use `brew` for a fast one-line command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Of course, it is always possible to install from the source. Remember to install
    the dependencies first. These include PCRE, zlib, and OpenSSL. You can find the
    source code at the following website: [http://nginx.org/en/download.html](http://nginx.org/en/download.html).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Before you start NGINX, you need to provide a configuration file for it to connect
    to the Unicorn web component. The interface between the two servers is a local
    Unix domain socket.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Please create a file called `nginx.config` and add the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding section is mandatory and you can specify how NGINX will handle
    connections. For this example, we just accept the default; that is why the section
    is empty.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'The next section is an HTTP block. You can define several and let settings
    be inherited, but here, we define that HTTP requests should be redirected to `upstream
    gitlab-app`, which is Unicorn. You can also see that the interface is the Unix
    socket:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, we have defined how NGINX connects to the backend, which is GitLab. On
    the frontend, we want to accept requests from HTTP clients. This is taken care
    of via a `server` block:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next directive inside this block handles a path that doesn''t exist on
    disk. It forwards the request to the app:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following is the definition of `gitlab-app`, and it modifies request headers
    to proxy the request to the upstream Unicorn server via the Unix socket:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Don''t forget to close the server and HTTP block:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have a configuration, you can run this NGINX in the following way:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The command should return no output and the NGINX server runs in the background.
    You canverify this yourselfby checking the process list:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that you have a running NGINX server, if you point your browser to `http://localhost:8080`, you
    should receive a 502 error. This is because there is no Unicorn server listening
    on a Unix socket yet. We will demonstrate how to run Unicorn in the next section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Unicorn
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unicorn is an HTTP server for applications that deal with well-performing clients
    on connections that show low latency and have enough bandwidth. It takes advantage
    of features that are present in the core of Linux-like systems. It is called a
    **Rack HTTP server** because it implements HTTP for Rack applications. Rack, in
    turn, is actually a Ruby implementation of a minimal interface to deal with web
    requests, which you can use in your code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: You can find the project at [https://rack.github.io](https://rack.github.io).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Unicorn runs as a daemon server in Unix and is programmed in Ruby and the C
    programming language. Using Ruby means that it can also run a Ruby on Rails application
    such as GitLab.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a grasp of the basic concepts of Unicorn, we can install it,
    and also connect NGINX, which we installed earlier, to it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Installing Unicorn
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have Ruby installed, you can easily install Unicorn using the following
    steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is installing Ruby on Rails:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next step it to install the Unicorn server binary:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s continue with installing web documents in `/usr/local/www`. We''ll begin
    by creating the directory:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now create our Rails application that is to be served with Unicorn:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After an enormous output, which may look a bit scary, there is a preconfigured
    application ready for you. Let''s configure Unicorn to serve it. We can get a
    default configuration file here:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have to change some things. Let''s start by making a variable for the basic
    application folder:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we can change the following paths:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Unicorn can listen on ports and/or sockets. We are going to use listen on a
    Unix socket because that is the shortest path:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can start Unicorn with the following command:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If NGINX was started earlier as well, we can now point our browser to `http://localhost:8080`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 NGINX 也提前启动了，我们现在可以将浏览器指向 `http://localhost:8080`。
- en: Now, maybe you encountered errors and want to find out what went wrong. It may
    be necessary to know how to debug NGINX and Unicorn when there are problems. This
    will be covered in the next section.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，也许你遇到了错误，想要了解发生了什么问题。了解如何在出现问题时调试 NGINX 和 Unicorn 可能是必要的。下一节将介绍这一内容。
- en: Debugging Unicorn
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 Unicorn
- en: Maybe installing Unicorn produced errors, or you are experiencing bad performance
    that you suspect is caused by Unicorn not working properly.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是安装 Unicorn 时产生了错误，或者你遇到了性能问题，怀疑是 Unicorn 未正常工作所致。
- en: There are several ways to find the cause. The log files can point you in the
    right direction.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以找到问题的根源。日志文件可以为你指明方向。
- en: Timeouts in Unicorn logs
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unicorn 日志中的超时
- en: 'The following output is what a Unicorn worker timeout looks like in `unicorn_stderr.log`.
    This is not necessarily bad; it just means that a new worker is spawned:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出是 Unicorn 工作者超时在 `unicorn_stderr.log` 中的表现。这不一定是坏事，它只是意味着新的工作进程被启动了：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It could be that there are just not enough Unicorn workers available to respond
    to the requests at hand. NGINX buffers a lot of requests so we must check on the
    handover socket whether Unicorn can keep up. To do this,a little nifty script
    is available here: [https://github.com/jahio/unicorn-status](https://github.com/jahio/unicorn-status).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是 Unicorn 可用的工作进程不足以响应当前的请求。NGINX 会缓存大量请求，所以我们必须检查交接套接字，看看 Unicorn 是否能跟得上。为此，可以使用一个方便的脚本，地址为：[https://github.com/jahio/unicorn-status](https://github.com/jahio/unicorn-status)。
- en: 'It can be called with the following command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以通过以下命令调用：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first argument here is the `unicorn_status.rb` script, the second is the
    socket to connect to `../.socket`, and the last argument is the poll interval
    (`10`).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一个参数是 `unicorn_status.rb` 脚本，第二个是要连接的套接字 `../.socket`，最后一个参数是轮询间隔（`10`）。
- en: Unicorn processes disappear
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unicorn 进程消失
- en: On Linux, there is a mechanism called **Out-of-Memory** (**OOM**) **Killer**
    that will free up memory if the system is running low on memory, and you don't
    have any swap memory left. It might kill Unicorn if it is using too much memory.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，有一种机制叫做 **Out-of-Memory** (**OOM**) **Killer**，当系统内存不足且没有交换内存时，它会释放内存。如果
    Unicorn 占用了过多内存，它可能会被杀死。
- en: 'Use `dmesg | egrep -i ''killed process''` to search for OOM events:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dmesg | egrep -i 'killed process'` 搜索 OOM 事件：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Other kinds of errors or 100% CPU load
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他类型的错误或 100% CPU 占用
- en: 'The ultimate way to debug Unicorn processes is to run strace on them:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 调试 Unicorn 进程的终极方法是对其运行 strace：
- en: Run `sudo gdb -p (PID)` to attach to the Unicorn process.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `sudo gdb -p (PID)` 以附加到 Unicorn 进程。
- en: 'Run `call (void) rb_backtrace()` in the GDB console and find the generated
    Ruby backtrace in `/var/log/gitlab/unicorn/unicorn_stderr.log`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 GDB 控制台中运行 `call (void) rb_backtrace()` 并在 `/var/log/gitlab/unicorn/unicorn_stderr.log`
    中找到生成的 Ruby 回溯信息：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When you are done, leave GDB with `detach` and `exit`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，使用 `detach` 和 `exit` 退出 GDB。
- en: Sidekiq
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sidekiq
- en: '**Sidekiq** is a framework for background job processing. It allows you to
    scale your application by performing work in the background. For more information
    on Sidekiq, consult the following website: [https://github.com/mperham/sidekiq/wiki](https://github.com/mperham/sidekiq/wiki).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sidekiq** 是一个后台作业处理框架。它通过在后台执行任务来帮助你扩展应用程序。欲了解更多有关 Sidekiq 的信息，请访问以下网站：[https://github.com/mperham/sidekiq/wiki](https://github.com/mperham/sidekiq/wiki)。'
- en: Each Sidekiq server process pulls jobs from the queue in Redis and processes
    them. Like your web processes, Sidekiq boots Rails so that your jobs and workers
    have the full Rails API available for use, including ActiveRecord. The server
    will instantiate the worker and call perform with the given arguments. Everything
    else is up to your code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Sidekiq 服务器进程从 Redis 队列中拉取任务并处理它们。像你的 Web 进程一样，Sidekiq 启动 Rails，这样你的任务和工作进程就可以使用完整的
    Rails API，包括 ActiveRecord。服务器将实例化工作进程，并使用给定的参数调用 `perform`。其余部分由你的代码决定。
- en: Installing Sidekiq
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Sidekiq
- en: 'It''s very easy to start using Sidekiq. It can be installed as `gem`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Sidekiq 非常简单。它可以作为 `gem` 安装：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, some dependencies are installed as well, such as Redis, connection
    pooling, Rack, and Rack protection.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，某些依赖项也已安装，例如 Redis、连接池、Rack 和 Rack 保护。
- en: Debugging Sidekiq
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 Sidekiq
- en: 'As with Unicorn, there are several ways to debug Sidekiq processing. The easiest
    way is to log in to GitLab as an administrator and view the logs from there, and
    especially view the queues and jobs on the Background Jobs page, as shown in the
    following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6577d62-2591-45a1-b48d-e7caacf8e987.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: Sometimes, you experience troubles and find situations on your Linux server.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Sidekiq processes disappear
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned before, in the Unicorn section, the OOM Killer might kill Sidekiq
    if it is using too much memory.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `dmesg | egrep -i ''killed process''` to search for OOM events:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A Sidekiq process is seemingly doing nothing
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If Sidekiq isn't doing any work and it seems stuck most of the time, this means
    that the program is waiting for something. A common wait situation is when you
    are doing remote network calls. If you think this could be the case, you could
    make Sidekiq processes dump a backtrace to the log by sending it a TTIN signal.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what a Sidekiq worker looks like in the log file in `/var/log/gitlan/sidekiq/current`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Since GitLab 12.0, the default output log format for Sidekiq is JSON, this makes
    it easier to read the log files into a tool like logstash because it is more structured.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Other kind of errors or 100% CPU load
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ultimate way to debug Sidekiq processes is to make it dump a backtrace
    via GDB:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Run `sudo gdb -p (PID)` to attach to the Sidekiq worker process.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run `call (void) rb_backtrace()` in the GDB console and find the generated
    Ruby backtrace in `/var/log/gitlab/sidekiq/current`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It is very hard to read backtraces, but this process was doing network operations
    while being traced, we can see a  (`_read_from _socket`). You can read the source
    code to check what it is doing (there are line numbers mentioned).
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you are done, leave GDB with `detach` and quit.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also use other tracing tools to examine the behavior of the looping
    process. On Linux, for instance, `strace -p <pid>` allows you to view the system
    calls that are being made by the process.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: GitLab Shell
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This component is used to provide access to Git repositories through SSH. In
    fact, for pushes via the `git-http` protocol, it is also called instead of the
    Rails app. It's essentially a small Ruby wrapper around the Git client. Git, through
    SSH, uses predefined commands that can be executed on the GitLab server. For authorization,
    it makes calls to the GitLab API. Before GitLab 5.0, this functionality was delivered
    by Gitolite and powered by the Perl programming language.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code of this project can be found here: [https://gitlab.com/gitlab-org/gitlab-shell](https://gitlab.com/gitlab-org/gitlab-shell).
    You can see the following page:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2bdece6-99dd-4f04-acf2-0f287a96396c.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: You can install it locally, but it's really only useful when deployed together
    with other GitLab components. When you have that installed (see [Chapter 2](8e9ca130-15d0-4c6e-af6b-2fe5292f3618.xhtml),
    *Installing GitLab*, for instructions on how), the next section describes a way
    to debug when you have problems.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Debugging GitLab Shell
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In an omnibus installation, the log file for GitLab Shell can be found in the
    following location:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Alternatively, it may be found in the following location, for installations
    from source:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'What you will generally find are log lines that concern the basic operations
    of GitLab Shell:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Git commands (such as `git push` and `git pull`).
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization calls to the GitLab Rails API to check whether you are allowed
    to connect
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution of pre-receive hooks
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actions requested
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Post-receive actions
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any custom post-receive actions
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, we have listed some lines from the log file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: One way to find errors is to look for certain patterns, such as `failed`, as
    follows. This particular error points to a 500 error from Unicorn while checking
    whether a user has the right authorization to make a call to the GitLab API.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'This error should show up in the Unicorn logs (`production.log`) if you search
    for an HTTP 500 error:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Redis
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Redis is a caching tool and HTTP session store that allows you to save cached
    data and session information from your website to an external location. This means
    that your website doesn''t have to calculate everything every time; instead, it
    can retrieve the data from the cache and load the website much faster. The user
    sessions are in memory even if the application goes down. Redis is a fast caching
    tool because it uses memory first. It has several useful advantages:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Everything is stored in one place, so you only have to flush one cache.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is faster than Memcache. This is noticeable when using the websites of large
    shops.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sessions are stored in memory and not in the database.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The backend becomes faster.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redis is not merely a cache, but is also a data structure store. It is basically
    a database and should be viewed conceptually as such. With regard to its operation
    and how it handles data, it has more in common with a NoSQL database.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Installing Redis
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Redis is available through all major package management systems. The following
    are the commands used to install it on different platforms:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'This is for Mac with Homebrew installed:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is for Linux Ubuntu or other APT-based distributions:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is for Red Hat or other YUM-based distributions:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: However, the preferred way of installing Redis is by compiling it from the source.
    This way, you can easily stay up to date. It has no special dependencies other
    than the GCC compiler and the standard C library. You can find the latest stable
    version at [http://download.redis.io/redis-stable.tar.gz](http://download.redis.io/redis-stable.tar.gz).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing and compiling it is as easy as entering the following command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After completing this successfully, you can choose to carry out the next logical
    step, which is to issue `make test` to execute tests against compiled sources.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the binary in a useful place, use the following command:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For a further explanation about the structure that has been compiled, go to
    the `src` directory. You will find the following information:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '`redis-server`: The Redis server program'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redis-sentinel`: This is used to monitor Redis clusters'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redis-cli`: The command-line program to control Redis'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redis-benchmark`: The program to be used to measure Redis performance'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redis-check-aof` and `redis-check-dump`: Utilities to assist when there is
    data corruption'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we have everything in place, let's start the server.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'When installed on macOS with `brew`, use the following command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'On other platforms, when built from the source, you can directly start the
    Redis server by running the `redis-server` command. In a fresh shell window, type
    the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After hitting *Enter*, you will see the server starting:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aac23216-7d52-47e3-b04c-2c1dc3ee461e.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
- en: 'You can test whether your Redis instance is working by issuing the following
    command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When Redis is operational, there will be a reaction:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you receive `PONG`, then everything is in order.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Basic data operations in Redis
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s discover some of the basics of Redis by playing with the data structures.
    Start the `redis-cli` command-line utility again without the `ping` argument,
    and it will connect to the local Redis server:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It is not fair to view Redis as a simple hash database with key values. But
    still, the five data structures that are provided do actually consist of a key
    and a value. Let''s sum up the five data structures:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '**String**: You can use the `set` command to write a value to Redis. In the
    case of a simple string, you can simply save the value in the datastore shown
    as follows. After setting the string value, you can retrieve the value again by
    issuing the `get` command:'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Hash**: In the same way as the string, you can `set` an arbitrary number
    of values to a key. Generally speaking, Redis treats values as a byte array and
    doesn''t care what they are. This make Redis very handy for representing objects.
    Again, with the `get` command, you can retrieve the values. GitLab uses this type
    to store web session information from users:'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**List**: The list type in Redis is implemented as a linked list. You can add items
    to the listquite quickly with `rpush` (right push, to the tail of the list) or
    `lpush` (left push, to the head of the list). On the other hand, accessing an
    item by index is not that fast because it has to search the linked list. Still,
    for a queue mechanism, this is a good solution.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**Sets**: Another datatype is the set. You add members with the `sadd` command.
    Don''t forget that these sets are unordered, so if you ask for the members with
    `smembers`, the order will mostly be different to how you entered it:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**Sorted sets**: Fortunately, there is an ordered set as well. It is almost
    the same, but one difference is that you add a score to the entry, and that will
    automatically score the sort order, as you can see from the following:'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Gitaly
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first versions of GitLab, all Git operations relied on using a local
    disk or network share. Gitaly is a project that tries to eliminate reliance on
    the **Network File System** (**NFS**). Instead of calls to a filesystem service,
    Gitaly provides GitLab with a system based on **Remote Procedure Calls** (**RPCs**)
    to access Git repositories. It is written in Go and uses **gRPC Remote Procedure**
    **Call** (**gRPC**), a cross-platform RPC framework from Google. It has been steadily
    developing since the beginning of 2017, and since GitLab 11.4, it can replace
    the need for a shared NFS filesystem.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find an overview of Gitaly and its place in the GitLab architecture
    in the following screenshot:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/604f4f42-3c54-490d-8b34-5c07ae8217a1.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: 'On a small installation, it runs in the same servers as all other components.
    In big clustered environments, you can set up dedicated Gitaly servers, which
    can be used by Gitaly clients such as the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Unicorn
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sidekiq
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gitlab-workhorse`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gitlab-shell`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elasticsearch indexer
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gitaly as a client
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The source code of this project can be found here: [https://gitlab.com/gitlab-org/gitaly](https://gitlab.com/gitlab-org/gitaly)[.](https://gitlab.com/gitlab-org/gitaly)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Debugging Gitaly
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use debugging tools that are available for Golang. But for starters,
    you can take a look at the log file.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'For source installs, use this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'For Omnibus installations, use this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following is an example of a log line:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can see the log level is `info` and this is a log event that captures a
    Git SSH command (`method=SSHUploadPack`). It started a Git `pack` command on the
    server, which means it rearranged and compressed data in a repository.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: To generate more verbose logging, you can set the log level to a debug in the
    configuration file. It is configured via a **Tom's Obvious Minimal Language**
    (**TOML**) configuration file. This file is documented in the Gitaly source code
    repository mentioned previously.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'For source installations, look here:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can change the following section and change the level:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'For Omnibus installs, the following directives can be added to `gitlab.rb`
    to influence the level of monitoring of Gitaly. Set it to `debug` to enable debug-level
    logging:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: GitLab Workhorse
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GitLab Workhorse is a sophisticated reverse proxy that is set up in front of
    GitLab. Initially conceived to solve the problem of handling `git-http` requests,
    it started as a weekend project with the name `gitlab-git-httpserver`. The functionality
    was previously delivered by `gitlab-grack` ([https://gitlab.com/gitlab-org/gitlab-grack](https://gitlab.com/gitlab-org/gitlab-grack)). The
    main web application server, Unicorn, was not especially suited to cater for these
    requests, which can take a long time to finish. Handling these directly in Unicorn
    actually reverses the advantages that Unicorn can provide: fast and scalable HTTP
    requests.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Workhorse was created in Golang, and was conceived by Jacob Vosmaer, one of
    the GitLab developers. You can read all about the process of creating it at [https://about.gitlab.com/2016/04/12/a-brief-history-of-gitlab-workhorse/](https://about.gitlab.com/2016/04/12/a-brief-history-of-gitlab-workhorse/).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it was first designed to handle the Git HTTP protocol, GitLab Workhorse
    increasingly gained functionalities, such as these:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Certain static files, such as JavaScript and CSS files, are served directly.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can intercept requests from Rails about opening a file. Workhorse will open
    the file and send the content in the response body.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can intercept calls for Git **Large File Storage** (**LFS**) and insert a
    temporary path after preparing the file in the upload location. Git LFS is a feature
    where large files can be stored outside the project space in GitLab.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can control WebSocket connections for Rails, such as the terminal output.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Workhorse sits behind NGINX, which handles request routing and SSL termination.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Debugging GitLab Workhorse
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As workhorse is a Golang written application, you can use methods for this language
    to debug programs.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: It also supports remote error logging with Sentry. To activate this feature,
    set the `GITLAB_WORKHORSE_SENTRY_DSN` environment variable.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '**For Omnibus installations**'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is defined in the file (`/etc/gitlab/gitlab.rb`):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '**For Source installations**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'The following environment variable can be set in the file (/`etc/default/gitlab`):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Of course, the first thing to look at is the log files that are produced by
    this component. On an Omnibus-based GitLab installation, you can find them in
    `/var/log/gitlab/gitlab-workhorse`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an excerpt of the default log file:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the preceding log file, you see, for example, `git-http` operations such
    as `git-upload-pack`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Database
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two database varieties available for GitLab: PostgreSQL and MySQL/MariaDB.
    The use of the latter is not recommended because the fast development of iterations
    of GitLab, as a product, have focused primarily on PostgreSQL, meaning that a
    number of optimizations are not available on MySQL. Furthermore, the zero-downtime
    method is not available when using MySQL, and neither are features such as subgroups
    and GEO, which will be explained later in this book.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: As explained earlier, Ruby on Rails uses a so-called MVC approach. MVC is a
    well known architectural pattern that was developed by Trygve Reenskaug in the
    Smalltalk language. It was later enhanced for web applications (Model 2). The
    model in MVC is implemented by the `ActiveRecord` library, which is part of Ruby
    on Rails.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'The authoritative source for the data model can be found here: [https://gitlab.com/gitlab-org/gitlab-ee/blob/master/db/schema.rb](https://gitlab.com/gitlab-org/gitlab-ee/blob/master/db/schema.rb).
    It is auto generated and represents the current state of the database.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: The default PostgreSQL database that is included in the Omnibus package can
    handle workloads for up to 10,000 users. Also, if you would like to create a **Disaster
    Recovery** (**DR**) plan using a cold standby setup, you can use specific failover
    mechanisms.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'A frequently used technique is to create a cold standby database (PostgreSQL
    DB 2) at another site, as illustrated by the following diagram:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37c0d3a0-1133-4125-ba0e-84de5982ddc0.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
- en: When you want to scale or increase the number of application servers, you need
    to scale the database too. There are three important aspects of database scaling.
    Firstly, you want to be able to scale database client connections as efficiently
    as possible. To do this, you can use PgBouncer, which is a lightweight connection
    pooler.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, you want to have several database instances, one being the master
    node, and replicate the data from the master to the slave. In the former, DR situation,
    this was done by the basic built-in replication mechanism of PostgreSQL. In the
    current situation, a specific tool, repmgr, is used, a tool for clustering PostgreSQL and
    handling the failover.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a service discovery tool such as **Consul** can be used to detect the
    PostgreSQL status of each node, and update the PGbouncer service setting that
    determines which Postgres instance to connect to.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting architecture is as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/682c99a5-6e3f-4586-bf5c-66fff93cef8f.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
- en: As you can see, there are different ways of setting up your database for GitLab.
    The architectures highlighted in the preceding diagram will be used in examples
    for building high-availability environments in *Scaling the Server Infrastructure
    (High- Availability Setup*) section of this book.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: GitLab CI
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitLab CI is a feature that helps perform the **Continuous Integration** (**CI**)
    of software components. When several developers work together using a versioning
    system, problems can arise when changes made by one developer break the product
    as a whole. The best way to make sure this happens less often, or at least early
    in the process, is to use integration tests more frequently, hence the name continuous.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: GitLab CI was launched as a standalone project in 2013, but was later integrated
    into the main GitLab package. Combined with the GitLab Runner software, this feature
    has been very popular with developers and is an important driver of the business.
    It also enabled GitLab to build their product into a solution that not only does
    CI, but even continuous delivery up to production environments. The current product
    vision for GitLab is to serve as a complete DevOps life cycle product, from idea
    to production.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Forrester classified GitLab as a leader in CI in *The Forrester Wave: Continuous
    Integration Tools, Q3 2017*. This is shown in the following diagram:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/baa860a0-b398-48a1-9f42-754053ffd5d1.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
- en: Feedback, one of the important aspects of the **Extreme Programming** (**XP**)
    movement, is an important element of GitLab CI. It also serves as a way to communicate
    between developers.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Pipelines and jobs
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pipelines and build jobs are basic building blocks for a **Continuous Integrations/Continuous
    Delivery** (**CI/CD**) system nowadays. In GitLab, it is very easy to start a
    pipeline. You only need to add a `.gitlab-ci.yml` file to your project and then,
    on every commit/push to your repository, a pipeline will start. Every project
    has a pipeline''s overview; you can find it in the left-hand menu bar, under CI/CD:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9500b78c-c838-4e0f-ba0d-724581246c4c.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, you can view all jobs, by going to the Pipelines'' Jobs page,
    as shown in the following screenshot:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3a96279-4d98-4ae2-a324-1e8de043d63f.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
- en: 'You can check the log of a job by clicking on the status of the job (for example,
    **failed** or **passed**). You can debug why some jobs fail and see exactly what
    happened:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2751d76-eda1-4258-b975-69917c7e97ae.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
- en: The importance of using pipelines and jobs for CI/CD cannot be overstated. In
    this section, you've seen the basic interface to pipelines in GitLab, but in several
    chapters time, this will be discussed in more detail (*Utilizing GitLab CI and
    CI Runners* section).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: GitLab Runners
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitLab Runners were originally developed by Kamil Trzciński in 2015\. They're
    now one of the most popular features of GitLab.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: The initial GitLab-CI-Runner was a very simple application written in Ruby,
    but worked well in quite basic setups. You can think of it as a reference implementation
    of what a bare runner could look like.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Issues with the old runner
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main problem with the old runner is that it could only run one concurrent
    job at a time. If you wanted to run more, you could either set up a new server
    or create an additional user to build jobs.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, it always ran projects on the server shell. This made it really hard
    to test projects using different versions of Ruby or any other dependencies. It
    was not stateless, meaning you had a contaminated build environment. Builds were
    therefore not very trustworthy. Nowadays, having a stateless and clean build environment
    every time is essential.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect of the old Runner that made it less favorable was that it only
    ran on Linux-based platforms. To make it work on macOS, a big GitLab user platform,
    you had to carry out additional hacking. Support for Microsoft Windows was out
    of the question.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there were some heavy administrative burdens. The server was hard to
    scale, because setting up a new server took a long time due to the dependencies
    you needed to take care of in order to build projects.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: The newer runner is a binary that you can put on a machine of any kind. It is
    really easy to set up as a service and can work with multiple projects and multiple
    GitLab CI coordinators. It also provides support for Docker, making it really
    easy to set up a build environment with different versions.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Switching to Go
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go (or Golang) is a new language (less than 10 years old). It is already widely
    used by some impressive parties, such as Docker ([https://docker.com](https://docker.com)),
    Google, Kubernetes ([https://kubernetes.io](https://kubernetes.io)), and Prometheus
    ([https://prometheus.io](https://prometheus.io)). Go is a versatile tool that
    can help you to program at a low level, close to the operating system or at a
    high level in a language such as Java. It is perfectly suited to creating systems
    software. The language was created in 2009 by R. Griesemer, R. Pike, and K.Thompson
    while working for Google. The latter is very famous for co-creating the first
    Unix implementation and the B programming language. The most important feature
    of the Go language is that it can compile one binary without dependencies for
    multiple operating systems such as Linux, macOS, the BSDs, and Windows. This also
    means it runs on different processor architectures (i386, amd64, ARM, and PowerPC).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'A short list of the benefits of Go follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Very good standard libraries (with good optional ones available elsewhere).
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is very fast to develop and test in Go.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The culture/community chooses boring solutions over complex ones (which is good).
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cool tools such as Gofmt, race detector, and `go vet`.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Made for concurrency—for instance, you can use goroutines and channels.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type safety—will save you many times from run-time errors and wrongly defined
    data types.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection—while programmers who use C know how to clean up, this can
    still be helpful.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures or anonymous functions—enable the use of functional principles (higher-order
    functions).
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these characteristics make Go the perfect choice for GitLab Runners. With
    Go, you can create a relatively small binary that runs on a lot of platforms.
    It contains all that is needed to run your projects.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: In a GitLab environment, jobs are being executed by the Runners. They run them
    as they are defined in a `.gitlab-ci.yml` file. The Runner itself can be running
    on a **Virtual Machine** (**VM**) such as VmWare (VM), VPS, a laptop, a Docker
    container, or in a Kubernetes cluster. Communication is one way from runner to
    GitLab and is mostly via an HTTP API, so that path must be accessible by the Runner.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: The `.yml` file defines what stages your CI/CD pipeline has and what to do in
    each stage. This typically consists of build, test, and deploy stages.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: GitLab mentions *boring* in its handbook as a valued way of reducing complexity;
    see [https://about.gitlab.com/handbook/values/#efficiency](https://about.gitlab.com/handbook/values/#efficiency).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'The project can be found at [https://gitlab.com/gitlab-org/gitlab-runner](https://gitlab.com/gitlab-org/gitlab-runner):'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2c04da4-3bda-4d67-a67d-12136489b33b.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
- en: 'A runner can either be specific to a certain project or it can serve multiple
    projects in GitLab. If it serves all projects, it''s known as a Shared Runner. GitLab
    Runners implement a number of **executors** that can be used for your builds in
    different scenarios:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '**Shell executor**: The runner simply executes a shell. The dependencies for
    the build have to be installed manually.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker-based executor**: The runner runs from a container. This makes it
    easier to create clean builds because dependency management is shifted to the
    container image. It is also easier to create a build environment with services
    that need each other, such as PostgreSQL.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Autoscaling Docker SSH**: A Docker machine creates instances with the Docker
    Engine to run Docker containers.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubernetes**: GitLab Runner can use Kubernetes to run builds on a Kubernetes
    cluster.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runners have evolved enormously over the last couple of years. GitLab itself
    sees them as one of the most important components of their suite. This section
    has given more insight into the development of this popular tool.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Cloud native
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Toward the end of 2016 and at the start of 2017, there was a public debate in
    the GitLab community about whether reverting back from the cloud to bare metal
    would be cost-effective for [GitLab.com](https://about.gitlab.com/). At the time,
    the filesystem used for repositories was Ceph. The performance of that distributed
    filesystem was not good enough to handle [GitLab.com](https://about.gitlab.com/).
    They asked the community for advice and received a lot of feedback from people
    who experienced similar moves firsthand. In the end, the decision was made to
    stay in the cloud ([https://about.gitlab.com/2017/03/02/why-we-are-not-leaving-the-cloud/](https://about.gitlab.com/2017/03/02/why-we-are-not-leaving-the-cloud/)).
    Instead, GitLab would focus on creating a solution, not on the filesystem level,
    but making sure that Git input/output (I/O) behavior is better managed at the
    application level. This can be seen as the birth of the Gitaly component. Sid
    Sijbrandij emphasized the importance of being a software company, not an infrastructure
    company.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'In August 2018, GitLab migrated their cloud-based offering, [GitLab.com](https://about.gitlab.com/),
    from Azure to **Google Cloud Platform** (**GCP**). The main reason for switching
    to GCP according to CEO, Sid Sijbrandij was as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '"Google as a public cloud, they have more experience than the other public
    cloud providers because they basically made a cloud for themselves [...] you find
    that in things such as networking, where their network quality is ahead of everyone
    else. It''s more reliable, it has less jitter, and it''s just really, really impressive
    how they do that, and we''re happy to start hosting GitLab.com on that."'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: It seems the move paid off; users have reported that [GitLab.com](https://about.gitlab.com/)
    is noticeably faster. Another transformation that is likely to cause further acceleration
    soon is the move to using Kubernetes as a container orchestrator. This is an important
    part of their strategy to incorporate functionality in a lot of places in GitLab
    besides the autoscaling of GitLab runners. GitLab's own high-availability tool,
    GEO, was used to synchronize the data from one cloud to another. Running on Google's
    architecture also allows GitLab to utilize object-storage for particular features
    as well, such as Git LFS.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the people and the organization behind
    GitLab. Starting from the beginning, we have shown you how the project has developed
    over the years. We went through the core components of GitLab and how to install
    them. For some components, we included ways to debug the installation.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: We also gave a brief introduction to GitLab CI and the client programs that
    interact with it, such as GitLab Runner. We showed you why this feature is so
    important and how it is perceived by the IT industry.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will install and configure GitLab on different kinds
    of systems. If you're new to the product, prepare to be amazed!
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When and by whom was GitLab initially developed?
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is GitLab funded?
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name all the programming languages that are used in the GitLab software.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which licenses are used by GitLab?
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are they using these licenses?
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the core components of GitLab.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many offices does GitLab have?
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is stored in Redis?
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What has Gitaly replaced?
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which cloud service was chosen by GitLab to focus on in 2018?
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sidekiq—source and documentation: [https://github.com/mperham/sidekiq](https://github.com/mperham/sidekiq)'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ruby on Rails: [https://rubyonrails.org](https://rubyonrails.org)'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unicorn: [https://thorstenball.com/blog/2014/11/20/unicorn-unix-magic-tricks/](https://thorstenball.com/blog/2014/11/20/unicorn-unix-magic-tricks/)'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cloud Native programming with Golang* by *Mina Andrawos*, *Martin Helmich*: [https://www.packtpub.com/in/application-development/cloud-native-programming-golang](https://www.packtpub.com/in/application-development/cloud-native-programming-golang)'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Nginx HTTP Server - Fourth Edition* by *Clement Nedelcu*, *Martin Fjordvald*: [https://www.packtpub.com/in/virtualization-and-cloud/nginx-http-server-fourth-edition](https://www.packtpub.com/in/virtualization-and-cloud/nginx-http-server-fourth-edition)'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mastering Redis* by *Jeremy Nelson*: [https://www.packtpub.com/in/big-data-and-business-intelligence/mastering-redis](https://www.packtpub.com/in/big-data-and-business-intelligence/mastering-redis)'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PostgreSQL Administration Cookbook, 9.5/9.6 Edition* by *Simon Riggs**,* *Gianni
    Ciolli*, *Gabriele Bartolini*: [https://www.packtpub.com/in/big-data-and-business-intelligence/postgresql-administration-cookbook-9596-edition](https://www.packtpub.com/in/big-data-and-business-intelligence/postgresql-administration-cookbook-9596-edition)'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
