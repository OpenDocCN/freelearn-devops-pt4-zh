<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Migrating From CVS</h1>
                </header>
            
            <article>
                
<p><span>For a long time, the <strong>Concurrent Versions System</strong> (<strong>CVS</strong>) was the standard in versioning software. It is, in essence, a client-server revision control system for software. CVS was written in 1986 by Dick Grune of the University of Amsterdam as a collection of shell scripts called <strong>RCS</strong>. RCS can only do version management on separate files, so this was a big step forward. In 1989, Brian Berliner made an implementation in C, which has been developed further since; it is a piece of open source software that's distributed under the GNU <strong>General Public License</strong> (<strong>GPL</strong>).</span></p>
<p><span>In the 2000s, there was a shift to subversion and to decentralized version control software such as Git.</span></p>
<p><span>In this chapter, we will compare both versioning systems. After that, we will prepare and run a migration from CVS to Git.</span></p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>CVS versus Git</li>
<li>Preparation for migrating from CVS to Git</li>
<li>Running the conversion</li>
<li>Cleaning up after migration</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p><span>To follow along with the instructions in this chapter, please download this book's GitHib repository, along with the examples: <a href="https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter06" target="_blank">https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter06</a>.</span></p>
<p class="mce-root">The other requirements so that you can follow along with this chapter are as follows:</p>
<ul>
<li><span>CVS binary: <a href="http://www.nongnu.org/cvs/">http://www.nongnu.org/cvs/</a></span></li>
<li><span>npm/Node.js binaries to create a JavaScript example: <a href="https://nodejs.org">https://nodejs.org</a></span></li>
<li><span><kbd>cvs-fast-export</kbd> binary: <a href="http://www.catb.org/~esr/cvs-fast-export">http://www.catb.org/~esr/cvs-fast-export</a></span></li>
<li><span><kbd>cvs2git</kbd> binary: <a href="https://www.mcs.anl.gov/~jacob/cvs2svn/cvs2git.html">https://www.mcs.anl.gov/~jacob/cvs2svn/cvs2git.html</a></span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CVS versus Git</h1>
                </header>
            
            <article>
                
<p>Centralization versus decentralization <span>– this </span>is the biggest difference between CVS, which is centralized, and Git's distributed design. With CVS, all developers pull from a centralized repository, thereby creating a single point of failure. Git uses a decentralized model, where every developer has a full-blown code repository locally available. By using push and pull requests, the decentralized repositories share code.</p>
<div>
<p><span>The following diagram depicts using push and pull on shared and distributed repositories:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c038631d-e3a6-44fb-bae6-2dc6047e6dfb.png" style="width:42.50em;height:19.00em;"/></p>
</div>
<p><span>With Git, there are different options in regards to the network protocol and system settings. In particular, you have the decision to communicate with remote services over SSH or HTTP. By utilizing SSH, you can generate your SSH keys and set them up for use with Git. After this, you can use Git to clone/push or pull from SSH locations. You can also use Git to use HTTP as a protocol, which generally requires basic HTTP authentication, after which the Git operations can occur. Some Git clients have built-in caching mechanisms to help you avoid typing in your HTTP password every time.</span></p>
<div>
<div>
<p><span>Publishing your work in this context is done by committing your changes to the central repository. CVS uses a specific protocol, called pserver, which is unencrypted and in plain text by default. Another option is to use the <strong>remote shell</strong> (<strong>rsh</strong>) on the remote server. To enhance security, you can also tunnel the pserver protocol through SSH or use SSH as the rsh executable.</span></p>
</div>
</div>
<div>
<p><span>The authorization model that's used in CVS systems is very simple. If you want to write something, you need to commit access to a repository. There is no facility to accept patches from people who are not authorized. The merge requests with all the facilities that modern Git servers provide have to be executed by the committer themselves. So, from a development engineering perspective, Git offers more complex workflows and is tailored for a world where many people contribute to a software project.</span></p>
</div>
<p>Besides the infrastructural difference, there are also several differences between your local CVS/Git client.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Filesets versus changesets</h1>
                </header>
            
            <article>
                
<p>CVS and Git have a different way of representing changes on a meta level. CVS uses filesets, so changes are recorded per file. Git, on the other hand, uses changesets, so changes are recorded against the <em>whole</em> repository. The advantage of this is that you can revert a change easily; however, this means that it is almost impossible to do a partial checkout (if you want to do this).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Git branching</h1>
                </header>
            
            <article>
                
<p>When using Git, it is very easy and cheap to create new branches <span>– they're just</span> pointers (a SHA-1 ID) to a specific commit. You create them on the fly, and that is how it should be, especially in agile development and with many collaborating developers. </p>
<div>
<p><span>The following diagram illustrates how Git uses branching:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bf2fa7ad-97c8-42ed-af43-f036639ed0cf.png" style="width:30.33em;height:28.33em;"/></p>
</div>
<p class="CDPAlignCenter CDPAlign"/>
<div>
<p><span>Notice the hash values shown in the preceding objects (98ce9, 22ca2, and f23ae) – these are the SHA values that uniquely identify a commit.</span></p>
<div>
<div>
<p><span>CVS also uses branches, but because it is file-based, a new branch gets you a copy of all the files in a new directory, which is much less efficient. This situation is depicted in the following diagram:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d320e715-c141-4212-83f9-4be247354482.png" style="width:36.83em;height:28.42em;"/></p>
</div>
</div>
</div>
<div>
<p><span>The way branches and file structures are handled is one of the most fundamental differences between these two systems.</span></p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating repositories</h1>
                </header>
            
            <article>
                
<p>When using CVS to create repositories, you have to set up a CVSROOT location where versioning data is stored. Then, you have to import projects into that location and create a working copy somewhere else. This is much easier and more logical with Git since you just implement <kbd>git init &amp;&amp; git add . &amp;&amp; git commit</kbd> in an existing directory only once a <kbd>.git</kbd> directory is created with <span><span>repository </span></span>meta information.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Atomic operations</h1>
                </header>
            
            <article>
                
<p>The basic idea of CVS is that it operates on files and not on snapshots. This means that when changes are processed and the operation is interrupted, the repository as a whole is inconsistent. This differs to Git, where changes succeed as a whole, or they fail <span><span>without the </span></span>changes combined.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Object naming or referencing versions</h1>
                </header>
            
            <article>
                
<p>In Git, every object has a unique ID, that is, a SHA-1 ID. This ID makes it easier to reference in the future (you can also use a shortened version if you so desire). In CVS, every file has its own version number. This number also reflects how many times it's been altered. In CVS, to reference changes to the project as a whole, you need to use tags.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Keyword substitution</h1>
                </header>
            
            <article>
                
<p><span>CVS supports the substitution of certain keywords in source code. For example, <kbd>$Author$</kbd>, <kbd>$CVSHeader$</kbd>, and <kbd>$Id$.Developers</kbd> have used this feature frequently (some still do). To use this mechanism, you would insert the keyword – let's call it a special variable – in your text or source file. Then, you would commit this file to your repository. By doing this, CVS will substitute this variable with the value in the CVS context during the commit. A lot of people use the <kbd>$Id$</kbd> string in their C source code. You can turn off this behavior completely in CVS by specifying <kbd>-ko</kbd> on the command line.</span></p>
<p>As an example, let's say I add a keyword to a source file, as follows:</p>
<pre>{<br/> "name": "cvsproject",<br/> "version": "1.0.0",<br/> "description": "something",<br/> "main": "index.js",<br/> "scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/> },<br/> "keywords": [],<br/> "author": "$Author$",<br/> "license": "ISC"<br/> }</pre>
<p>Then, I would commit this change:</p>
<pre><strong>$ cvs commit -m "Added author keyword"</strong><br/><strong> cvs commit: Examining .</strong><br/><strong> cvs commit: Examining images</strong><br/><strong> /Users/joostevertse/cvsroot/cvsproject/cvsproject/package.json,v &lt;-- package.json</strong><br/><strong> new revision: 1.3; previous revision: 1.2</strong></pre>
<p>After the commit, the keyword has been substituted by my username:</p>
<pre>"author": "$Author: joostevertse $",</pre>
<p>Git has a very limited set of keywords, and this is because changes are per repository and not per file. Also, Git avoids modifying files that didn't change when switching to another branch or rewinding to another point in time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Binary blobs</h1>
                </header>
            
            <article>
                
<p>Git and CVS handle binary files differently. In CVS, it is harder to handle them since you have to explicitly label them as binary. If you don't, you run the risk of corrupting the file with unwanted LR/LF conversions or keyword substitutions. Git, on the other hand, can automatically detect whether your file is of the binary kind. It uses the same mechanism as GNU diffutils.</p>
<p>Let's create a simple binary from source and add a reserved keyword. Then, we will compile it with GCC and run it:</p>
<pre><strong>$ cat hello.c</strong><br/><strong> #include &lt;stdio.h&gt;</strong><br/><strong> int main()</strong><br/><strong> {</strong><br/><strong>    // printf() displays the string inside quotation</strong><br/><strong>    printf("Hello, World!$Author$");</strong><br/><strong>    return 0;</strong><br/><strong> }</strong><br/> <br/><strong>$ gcc hello.c -o hello</strong><br/> <br/><strong>$ ./hello</strong><br/><strong> Hello, World!$Author$</strong></pre>
<p>So, let's copy the binary to the CVS project that we used previously:</p>
<pre><strong>$ cp hello /Users/joostevertse/cvs/cvsproject/cvsproject/</strong><br/><strong>$ cd $HOME/cvs/cvsproject/cvsproject</strong><br/><br/><strong>$ cvs add hello</strong><br/><strong> cvs add: scheduling file `hello' for addition</strong><br/><strong> cvs add: use `cvs commit' to add this file permanently</strong><br/><br/><strong>$ cvs commit -m "binary with keywords inside"</strong><br/><strong> cvs commit: Examining .</strong><br/><strong> cvs commit: Examining images</strong><br/><strong> /Users/joostevertse/cvsroot/cvsproject/cvsproject/hello,v &lt;-- hello</strong><br/><strong> initial revision: 1.1</strong><br/><br/><strong>$ ./hello</strong><br/><strong> Segmentation fault: 11</strong></pre>
<p>What happened? Well, keyword substitution added the author name in the binary! It corrupted it. If you run the <kbd>cat</kbd> command, you will find the following line in the file:</p>
<pre><strong>1ɉE???H??]??%?L??AS?%q?h?????Hello, World!$Author: joostevertse $P44{4</strong></pre>
<p>Fortunately, you can fix this with <kbd>cvs admin</kbd>:</p>
<pre><strong> $ cvs admin -kb hello</strong><br/><strong> $ cvs update -A hello</strong><br/><strong> $ cvs commit -m "make it binary" hello</strong><br/><strong> $ ./hello</strong><br/><strong> Hello, World!$Author$</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Amending commits</h1>
                </header>
            
            <article>
                
<p>One frequently used feature of Git is the ability to amend to a commit. This is possible because, in Git, there is a difference between creating and publishing a commit. This won't inconvenience users compared to CVS, where it would. If you make a typo in your commit message in Git, you can use <kbd>git commit --amend</kbd> to correct it. It's also technically possible in CVS, but it would be hard to implement:</p>
<pre><strong> $ echo "This is the last line FOR REAL" &gt;&gt; README.md</strong><br/><strong> $ git log</strong><br/><strong> commit 499beb6dd81ee62e90b05ee8e9aa3ccced7a4fd2 (HEAD -&gt; new-readme)</strong><br/><strong> Author: Joost Evertse &lt;joustie@gmail.com&gt;</strong><br/><strong> Date:   Thu Dec 6 21:18:32 2018 +0100</strong><br/> <br/><strong>    A new line was added</strong></pre>
<p>Let's pretend I forgot to add something to my <kbd>README.md</kbd> file (a text file in my repository). The following code shows you how to add it to the last commit:</p>
<pre><strong> $ echo "This is the last line FOR REAL" &gt;&gt; README.md</strong><br/><strong> $ git add README.md</strong><br/><strong> $ git commit -m "A new line was added FOR REAL" --amend</strong><br/><strong> $ git log</strong><br/><strong> commit 9c527dfe0ac2ce04b6cd1be6085bac00c7f31e6c (HEAD -&gt; new-readme)</strong><br/><strong> Author: Joost Evertse &lt;joustie@gmail.com&gt;</strong><br/><strong> Date:   Thu Dec 6 21:18:32 2018 +0100</strong><br/> <br/><strong>    A new line was added FOR REAL</strong></pre>
<p>By doing this, you can add to a commit, but this is only reflected in your local Git copy. You still have to push your changes to remote servers if you want others to see your changes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A central repository</h1>
                </header>
            
            <article>
                
<p>CVS as a centralized system has one place of origin. Git is a distributed versioning system, which means that each developer has its own copy of the repository. They have a private one and they can push changes to a public one or merge changes from other remotes. In larger organizations, it is common to have a central place to aggregate projects. With Git, there is no need to have a single central place where you store your changes. Each developer can have their own repository (or better repositories, that is, a private one in which they undertake development, and a public bare one where they publish parts that are ready), and they can pull/fetch from other repositories in a symmetric fashion.</p>
<div>
<p><span>In the Git world, there is no single source of truth like there is in the CVS server. There can be several truths, and because it is so easy to integrate changes from others, this works.</span></p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accompanying toolset</h1>
                </header>
            
            <article>
                
<p>Git provides a lot of tools that you can work with (Git bisect for one), which makes for a more productive way of working.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Detecting file renames</h1>
                </header>
            
            <article>
                
<p>The ability to rename a file is not supported in CVS, and being able to restore the state of the project when renames have happened is hard. Git uses heuristic rename detection so that it can analyze whether the content or filename are similar. You can also configure this detection in order to copy files.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Commit before merge</h1>
                </header>
            
            <article>
                
<div>
<p><span>A side effect of Git, when using a local repository, is that it changes the way commits are handled in the system. With CVS, you</span> <span>will need to handle conflicts first (if someone else changed something before you pull to update your working directory and resolve issues). Having done this, you can commit your changes to the CVS repository. This is called <strong>merge-before-commit</strong>. Git works entirely differently, since commits are always done in the local repository. This</span> <span>commit-before-merge</span> <span>strategy</span> <span>means that you merge changes after the commit, and it is also possible to ask the other developer to merge and resolve issues. It can get harder to distinguish changes between commits if there are many merges, but to retain a nice linear history, it is also possible to mimic CVS behavior by using the Git <em>rebase</em> mechanism (<kbd>git pull --rebase</kbd>) in which you apply changes on top of the updated state.</span></p>
</div>
<p>The last big difference is in the way people collaborate with each other. Some developers only need a read-only copy of the original software, but they need anonymous read-only access to the source code. Both CVS and Git can accommodate this. Things become different if people want to contribute something back to the project. With CVS, one way of doing this (like with the Linux kernel) is by sending patches via email. This is done by people who change a small amount of code. With Git, it is actually very easy to execute your changes on top of an existing upstream version and then generate an email with <kbd>git format-patch</kbd>. With bigger contributions, the functionality and ease of a pull request become important, and this was what Git was designed for. All of this happened because of the snapshot paradigm.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing to migrate from CVS to Git</h1>
                </header>
            
            <article>
                
<p><span>In the next section, we will look at two tools that can help us migrate repositories.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing for a conversion using cvs-fast-export</h1>
                </header>
            
            <article>
                
<p>This migration tool<span> </span>was created by Eric S. Raymond, a very well-known writer/developer who wrote the famous essay<span> </span><em>The Cathedral and the Bazaar</em> about open source software. He is also the author of fetchmail (an early open source POP3-client). Let's get started.</p>
<p><span>For the this tool, <kbd>cvs-fast-export</kbd>, I will create a CVS project from scratch that we will convert. Let's get started:</span></p>
<ol>
<li>Create a CVS root. This is where the CVS database will reside:</li>
</ol>
<pre style="padding-left: 60px"><strong><span> $ </span>cvs -d ~/cvsroot init</strong></pre>
<ol start="2">
<li>Add some variables for CVS to your environment:</li>
</ol>
<pre style="padding-left: 60px"><strong><span> $ </span>echo "export CVSROOT=~/cvsroot; export CVSEDITOR=vim" &gt;&gt; ~/.bash_profile</strong><br/><strong> <span>$ </span>source ~/.bash_profile</strong></pre>
<ol start="3">
<li>As an example, we will create an empty JavaScript project and add it to CVS. First, create a project:</li>
</ol>
<pre style="padding-left: 60px"><strong> $ mkdir cvs</strong><br/><strong> $ cd cvs</strong><br/><strong> $ mkdir cvsproject</strong><br/><strong> $ cd cvsproject/</strong><br/><strong> imac:cvsproject joostevertse$ npm init --yes</strong></pre>
<ol start="4">
<li>Now, let's add the project to CVS:</li>
</ol>
<pre style="padding-left: 60px"><strong> $ cd ..</strong><br/><strong> $ cvs import -m "Example javascript project" cvsproject Joost start</strong><br/><strong> cvs import: Importing /Users/joostevertse/cvsroot/cvsproject/cvsproject</strong><br/><strong> N cvsproject/cvsproject/package.json</strong><br/> <br/><strong> No conflicts created by this import</strong></pre>
<ol start="5">
<li>Now, the project is present in CVSROOT:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ ls ~/cvsroot</strong><br/><strong> CVSROOT     cvsproject</strong></pre>
<ol start="6">
<li>Now, we need to completely erase <kbd>~/cvs/cvsproject</kbd> because we're going to check it out as a CVS working directory:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ rm -rf cvsproject/</strong></pre>
<ol start="7">
<li>The next step is checking out the project in CVS, which will create a CVS working copy:</li>
</ol>
<pre style="padding-left: 60px"><strong> $ cvs checkout cvsproject</strong><br/><strong> cvs checkout: Updating cvsproject</strong><br/><strong> cvs checkout: Updating cvsproject/cvsproject</strong><br/><strong> U cvsproject/cvsproject/package.json</strong></pre>
<ol start="8">
<li>Looking into the directory reveals a CVS directory structure:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ tree</strong><br/><strong> .</strong><br/><strong> ├── CVS</strong><br/><strong> │   ├── Entries</strong><br/><strong> │   ├── Repository</strong><br/><strong> │   └── Root</strong><br/><strong> └── cvsproject</strong><br/><strong>    ├── CVS</strong><br/><strong>    │   ├── Entries</strong><br/><strong>    │   ├── Repository</strong><br/><strong>    │   └── Root</strong><br/><strong>    └── package.json</strong><br/> <br/><strong> 3 directories, 7 files</strong></pre>
<ol start="9">
<li>Let's create an image directory and add it to the repository:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>$ mkdir images</strong><br/><strong>$ cvs add images</strong><br/><strong> Directory /Users/joostevertse/cvsroot/cvsproject/cvsproject/images added to the repository</strong></pre>
<ol start="10">
<li>With the <kbd>cvs status</kbd> command, we can check which files have changed:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong> $ cvs status</strong><br/><strong> cvs status: Examining .</strong><br/><strong> ===================================================================</strong><br/><strong> File: package.json     Status: Locally Modified</strong><br/> <br/><strong>    Working revision:   1.1.1.1 2018-12-04 23:01:21 +0100</strong><br/><strong>    Repository revision: 1.1.1.1 /Users/joostevertse/cvsroot/cvsproject/cvsproject/package.json,v</strong><br/><strong>    Commit Identifier:   xmczkBNhTpkbWw2B</strong><br/><strong>    Sticky Tag:     (none)</strong><br/><strong>    Sticky Date:     (none)</strong><br/><strong>    Sticky Options: (none)</strong><br/> <br/><strong> cvs status: Examining images</strong></pre>
<ol start="11">
<li>Let's commit these changes into our CVS repository:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong> </strong><strong>$ cvs commit -m "changed description"</strong><br/><strong> cvs commit: Examining .</strong><br/><strong> cvs commit: Examining images</strong><br/><strong> /Users/jo</strong><strong>ostevertse/cvsroot/cvsproject/cvsproject/package.json,v &lt;-- package.json</strong><br/><strong> new revision: 1.2; previous revision: 1.1</strong></pre>
<ol start="12">
<li>With the <kbd>cvs log</kbd> command, we can see what has changed in more detail:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cvs log</strong><br/><strong> cvs log: Logging .</strong><br/> <br/><strong> RCS file: /Users/joostevertse/cvsroot/cvsproject/cvsproject/package.json,v</strong><br/><strong> Working file: package.json</strong><br/><strong> head: 1.2</strong><br/><strong> branch:</strong><br/><strong> locks: strict</strong><br/><strong> access list:</strong><br/><strong> symbolic names:</strong><br/><strong> start: 1.1.1.1</strong><br/><strong> Joost: 1.1.1</strong><br/><strong> keyword substitution: kv</strong><br/><strong> total revisions: 3; selected revisions: 3</strong><br/><strong>...</strong></pre>
<div>
<p><span>Now, we have a CVS repository that's been prepared for migration with <kbd>cvs-fast-export</kbd>.</span></p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing for a conversion using cvs2git</h1>
                </header>
            
            <article>
                
<div>
<p><span><span>Now, let's take a look the second tool, <kbd>cvs2git</kbd>. For this conversion, I took a copy of a project I have used before (<strong>itsmyparty</strong></span></span><span>: <a href="https://github.com/Joustie/itsmyparty">https://github.com/Joustie/itsmyparty</a></span><span>), like so:</span></p>
</div>
<div>
<pre><strong> $ git clone git@gitlab.com:joustie/itsmyparty_gitlab.git</strong><br/><strong> Cloning into 'itsmyparty_gitlab'...</strong><br/><strong> imac:git joostevertse$ cd itsmyparty_gitlab</strong><br/><strong> imac:itsmyparty_gitlab joostevertse$ tree</strong><br/><strong> .</strong><br/><strong> ├── attendees.rb</strong><br/><strong> ├── attendees.yml</strong><br/><strong> ├── atttendees.yml</strong><br/><strong> ├── itsmyparty.rb</strong><br/><strong>....</strong><br/><strong> 1 directory, 12 files</strong></pre>
<p>Then, I imported the source code into a CVS repository (I deleted the <kbd>.git</kbd> directory first):</p>
<pre><strong> $ cvs import -m "dir structure" cvsexample joost start</strong><br/><strong> N cvsexample/machines.yml</strong><br/><strong> N cvsexample/itsmyparty.rb</strong><br/><strong> N cvsexample/presence.yml</strong><br/><strong> N cvsexample/atttendees.yml</strong><br/><strong>.....</strong><br/><strong> No conflicts created by this import</strong></pre>
<p>As you can see, no conflicts were created by this import, which is great. We are now ready to run the conversions.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the conversion</h1>
                </header>
            
            <article>
                
<p>There are a couple of ways to convert data from a CVS repository into a Git one. After you have converted the repository, you need to push this new Git repository to a GitLab server.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Converting data using cvs-fast-export</h1>
                </header>
            
            <article>
                
<p>Perform the following steps for Converting data using <kbd>cvs-fast-export</kbd>:</p>
<ol>
<li>First, download the source from Eric Raymond's site: <a href="http://www.catb.org/~esr/cvs-fast-export">http://www.catb.org/~esr/cvs-fast-export</a>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ wget http://www.catb.org/~esr/cvs-fast-export/cvs-fast-export-1.44.tar.gz</strong><br/><strong>$ tar xvzf cvs-fast-export-1.44.tar.gz</strong><br/><strong>$ cd cvs-fast-export</strong></pre>
<ol start="2">
<li>Then, build the software:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ make cvs-fast-export</strong><br/><strong>$ cp cvs-fast-export /usr/local/bin; chmod +x /usr/local/bin/cvs-fast-export</strong></pre>
<ol start="3">
<li>Go to your <kbd>cvsroot</kbd> directory and run the tool in a pipe with <kbd>find</kbd> and output the results to a file:</li>
</ol>
<pre style="padding-left: 60px"><strong>imac:cvs-fast-export-1.44 joostevertse$ cd $HOME/cvsroot</strong><br/><strong> imac:cvsroot joostevertse$ find . |cvs-fast-export -A ~/authormap &gt;../cv.fi</strong></pre>
<ol start="4">
<li>Then, initiate an empty Git repository:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cd $HOME/git</strong><br/><strong>$ mkdir cvsproject</strong><br/><strong>$ cd cvsproject</strong><br/><strong>$ git init</strong><br/><strong> Initialized empty Git repository in /Users/joostevertse/git/cvsproject/.git/</strong></pre>
<ol start="5">
<li>Now, it's time to use <kbd>git fast-import</kbd> to populate our empty Git repository with information from the old CVS project:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cat ../../cv.fi |git fast-import</strong><br/><strong> Unpacking objects: 100% (19/19), done.</strong><br/><strong> /usr/local/Cellar/git/2.15.1_1/libexec/git-core/git-fast-import statistics:</strong><br/><strong>...</strong></pre>
<ol start="6">
<li>Now that all the meta information has been converted, the only thing left to do is checkout the code from Git:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git checkout</strong><br/><strong>$ git status</strong><br/><strong> On branch master</strong><br/><strong> nothing to commit, working tree clean</strong><br/><strong>$ ls</strong><br/><strong> hello           package.json</strong></pre>
<p>The CVS project is now available as a Git repository.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Converting data using cvs2git</h1>
                </header>
            
            <article>
                
<p>Let's take a look at converting data using <kbd>cvs2git</kbd>:</p>
<ol>
<li><span>The first step is to migrate the CVS data structure to something that could be imported with <kbd>git fast-import</kbd>:</span></li>
</ol>
<pre style="padding-left: 60px"><strong>$ ./cvs2git --blobfile=/tmp/git-blob.dat \ </strong><br/><strong> --dumpfile=/tmp/git-dump.dat "--username=Firstname Lastname" ~/cvsroot</strong><br/> <br/><strong>Writing temporary files to '/var/folders/sf/rdjwj43j4kx63xxng1gkgd040000gn/T/cvs2git-ElawtZ</strong><br/><strong>...</strong></pre>
<ol start="2">
<li>The first pass <span>(<kbd>CollectRevsPass</kbd>) w</span>ent through all the version files an<span>d analyzed them for revisions. The next 14 passes will transform all kinds of data from CVS and convert it:</span></li>
</ol>
<pre style="padding-left: 60px"><strong>----- pass 2 (CleanMetadataPass) -----</strong><br/><strong> Converting metadata to UTF8...</strong><br/><strong> Done</strong><br/><strong>...</strong></pre>
<div>
<ol start="3">
<li>Now t<span>he tool is will display statistics about the import:</span></li>
</ol>
</div>
<pre style="padding-left: 60px"><strong> cvs2svn Statistics:</strong><br/><strong> ------------------</strong><br/><strong> Total CVS Files: 50</strong><br/><strong> Total CVS Revisions: 50</strong><br/><strong> Total CVS Branches: 0</strong><br/><strong>.....</strong></pre>
<ol start="4">
<li>The next step is to create a skeleton Git repository, where we could import the converted data:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ mkdir itwasmyparty</strong><br/><strong>$ cd itwasmyparty/</strong><br/><strong>$ git init</strong><br/><strong> Initialized empty Git repository in /Users/joostevertse/git/itwasmyparty/.git/</strong></pre>
<ol start="5">
<li>Then, we start the import, with the blobs being imported first (<kbd>git-blob.dat</kbd>):</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git fast-import --export-marks=/tmp/git-marks.dat &lt; /tmp/git-blob.dat</strong><br/><br/><strong> Unpacking objects: 100% (48/48), done.</strong><br/><strong> git-fast-import statistics:</strong><br/><strong>....</strong></pre>
<ol start="6">
<li>Then, we import the Git metadata (<kbd>git-dump.dat</kbd>):</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git fast-import --import-marks=/tmp/git-marks.dat &lt; /tmp/git-dump.dat</strong><br/><br/><strong> Unpacking objects: 100% (23/23), done.</strong><br/><strong> git-fast-import statistics:</strong><br/><strong>....</strong></pre>
<ol start="7">
<li>Now, all we need to do is checkout the data:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git checkout</strong><br/><strong>$ git status</strong><br/><strong> On branch master</strong><br/><strong> nothing to com</strong><strong>mit, working tree clean</strong></pre>
<p>Now you have a migrated CVS repository.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cleaning up after migration</h1>
                </header>
            
            <article>
                
<p>Usually, after a migration of some sort, you will need to clean up afterwards. How this will take place in this situation depends on your use case. If it is a one-off migration, you should make a tarball of the old CVSROOT and put it on a DVD. You can also choose to let the repository systems coexist and even perform updates on the CVS repository from Git. There are also ways to create bidirectional communication (prepare for some shell scripting).</p>
<p>What definitely needs to happen if you migrated the CVS repository to Git is that you will need to add a remote that is pointing to your GitLab server. This will be the platform where pull requests (or, in GitLab speak, <em>merge requests</em>) are created.</p>
<p>Here, you need create an empty project in your GitLab server and then add the remote, as follows:</p>
<pre><strong> git remote add gitlab url-to-gitlab-repo</strong><br/><strong> git push gitlab master</strong></pre>
<p>Your old CVS repository will have been converted and pushed to your GitLab server.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p><span>In this chapter, we discussed the origins of CVS. We compared CVS to Git in a variety of way. The basic difference between the two is that CVS is a centralized versioning system while Git is of a distributed nature. Afterwards, we set up a basic CVS project and prepared to migrate it to GitLab. Then, we made a copy of an existing project to be used with the second tool. Finally</span><span>, we looked at two different ways of performing conversion to migrate th</span>e repositories.<strong> </strong></p>
<p><span>I</span><span>n the next chapter, we will take a look at what many people consider the <em>enhanced</em> successor of CVS: subversion. It already incorporates features that are also present in Git.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li><span>What is the biggest difference between CVS and Git?</span></li>
<li><span>What is the network protocol that's used with CVS called?</span></li>
<li><span>CVS uses changesets. (True | False)</span></li>
<li><span>How does Git implement versioning numbers?</span></li>
<li><span>How can you easily correct a typo in a commit message in Git?</span></li>
<li><span>Is it possible to rename a file in CVS?</span></li>
<li><span>What is the command to initialize a new CVS database on your machine?</span></li>
<li><span>What is the command to initialize a new Git project?</span></li>
<li><span>Who created the <kbd>cvs-fast-export</kbd> tool? </span></li>
<li>How do you import your migrated repository into GitLab?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li><span><kbd>cvs-fast-export</kbd>: <a href="http://www.catb.org/~esr/cvs-fast-export">http://www.catb.org/~esr/cvs-fast-export</a></span></li>
<li><span><kbd>cvs2git</kbd>: <a href="https://www.mcs.anl.gov/~jacob/cvs2svn/cvs2git.html">https://www.mcs.anl.gov/~jacob/cvs2svn/cvs2git.html</a></span></li>
<li><span><em>Git Version Control Cookbook - Second Edition</em> By <em>Kenneth Geisshirt</em>, <em>Emanuele Zattin</em>, <em>Rasmus Voss</em>, and <em>Aske Olsson</em>: <a href="https://www.packtpub.com/in/application-development/git-version-control-cookbook-second-edition">https://www.packtpub.com/in/application-development/git-version-control-cookbook-second-edition</a></span></li>
</ul>


            </article>

            
        </section>
    </body></html>