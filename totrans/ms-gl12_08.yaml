- en: Migrating From CVS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a long time, the **Concurrent Versions System** (**CVS**) was the standard
    in versioning software. It is, in essence, a client-server revision control system
    for software. CVS was written in 1986 by Dick Grune of the University of Amsterdam
    as a collection of shell scripts called **RCS**. RCS can only do version management
    on separate files, so this was a big step forward. In 1989, Brian Berliner made
    an implementation in C, which has been developed further since; it is a piece
    of open source software that's distributed under the GNU **General Public License**
    (**GPL**).
  prefs: []
  type: TYPE_NORMAL
- en: In the 2000s, there was a shift to subversion and to decentralized version control
    software such as Git.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will compare both versioning systems. After that, we will
    prepare and run a migration from CVS to Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: CVS versus Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparation for migrating from CVS to Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleaning up after migration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the instructions in this chapter, please download this
    book''s GitHib repository, along with the examples: [https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter06](https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter06).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other requirements so that you can follow along with this chapter are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: CVS binary: [http://www.nongnu.org/cvs/](http://www.nongnu.org/cvs/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'npm/Node.js binaries to create a JavaScript example: [https://nodejs.org](https://nodejs.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cvs-fast-export` binary: [http://www.catb.org/~esr/cvs-fast-export](http://www.catb.org/~esr/cvs-fast-export)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cvs2git` binary: [https://www.mcs.anl.gov/~jacob/cvs2svn/cvs2git.html](https://www.mcs.anl.gov/~jacob/cvs2svn/cvs2git.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CVS versus Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Centralization versus decentralization – this is the biggest difference between
    CVS, which is centralized, and Git's distributed design. With CVS, all developers
    pull from a centralized repository, thereby creating a single point of failure.
    Git uses a decentralized model, where every developer has a full-blown code repository
    locally available. By using push and pull requests, the decentralized repositories
    share code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts using push and pull on shared and distributed
    repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c038631d-e3a6-44fb-bae6-2dc6047e6dfb.png)'
  prefs: []
  type: TYPE_IMG
- en: With Git, there are different options in regards to the network protocol and
    system settings. In particular, you have the decision to communicate with remote
    services over SSH or HTTP. By utilizing SSH, you can generate your SSH keys and
    set them up for use with Git. After this, you can use Git to clone/push or pull
    from SSH locations. You can also use Git to use HTTP as a protocol, which generally
    requires basic HTTP authentication, after which the Git operations can occur.
    Some Git clients have built-in caching mechanisms to help you avoid typing in
    your HTTP password every time.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing your work in this context is done by committing your changes to the
    central repository. CVS uses a specific protocol, called pserver, which is unencrypted
    and in plain text by default. Another option is to use the **remote shell** (**rsh**)
    on the remote server. To enhance security, you can also tunnel the pserver protocol
    through SSH or use SSH as the rsh executable.
  prefs: []
  type: TYPE_NORMAL
- en: The authorization model that's used in CVS systems is very simple. If you want
    to write something, you need to commit access to a repository. There is no facility
    to accept patches from people who are not authorized. The merge requests with
    all the facilities that modern Git servers provide have to be executed by the
    committer themselves. So, from a development engineering perspective, Git offers
    more complex workflows and is tailored for a world where many people contribute
    to a software project.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the infrastructural difference, there are also several differences between
    your local CVS/Git client.
  prefs: []
  type: TYPE_NORMAL
- en: Filesets versus changesets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CVS and Git have a different way of representing changes on a meta level. CVS
    uses filesets, so changes are recorded per file. Git, on the other hand, uses
    changesets, so changes are recorded against the *whole* repository. The advantage
    of this is that you can revert a change easily; however, this means that it is
    almost impossible to do a partial checkout (if you want to do this).
  prefs: []
  type: TYPE_NORMAL
- en: Git branching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using Git, it is very easy and cheap to create new branches – they're just pointers
    (a SHA-1 ID) to a specific commit. You create them on the fly, and that is how
    it should be, especially in agile development and with many collaborating developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates how Git uses branching:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf2fa7ad-97c8-42ed-af43-f036639ed0cf.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice the hash values shown in the preceding objects (98ce9, 22ca2, and f23ae)
    – these are the SHA values that uniquely identify a commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'CVS also uses branches, but because it is file-based, a new branch gets you
    a copy of all the files in a new directory, which is much less efficient. This
    situation is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d320e715-c141-4212-83f9-4be247354482.png)'
  prefs: []
  type: TYPE_IMG
- en: The way branches and file structures are handled is one of the most fundamental
    differences between these two systems.
  prefs: []
  type: TYPE_NORMAL
- en: Creating repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using CVS to create repositories, you have to set up a CVSROOT location
    where versioning data is stored. Then, you have to import projects into that location
    and create a working copy somewhere else. This is much easier and more logical
    with Git since you just implement `git init && git add . && git commit` in an
    existing directory only once a `.git` directory is created with repository meta
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Atomic operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic idea of CVS is that it operates on files and not on snapshots. This
    means that when changes are processed and the operation is interrupted, the repository
    as a whole is inconsistent. This differs to Git, where changes succeed as a whole,
    or they fail without the changes combined.
  prefs: []
  type: TYPE_NORMAL
- en: Object naming or referencing versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Git, every object has a unique ID, that is, a SHA-1 ID. This ID makes it
    easier to reference in the future (you can also use a shortened version if you
    so desire). In CVS, every file has its own version number. This number also reflects
    how many times it's been altered. In CVS, to reference changes to the project
    as a whole, you need to use tags.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword substitution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CVS supports the substitution of certain keywords in source code. For example,
    `$Author$`, `$CVSHeader$`, and `$Id$.Developers` have used this feature frequently
    (some still do). To use this mechanism, you would insert the keyword – let's call
    it a special variable – in your text or source file. Then, you would commit this
    file to your repository. By doing this, CVS will substitute this variable with
    the value in the CVS context during the commit. A lot of people use the `$Id$`
    string in their C source code. You can turn off this behavior completely in CVS
    by specifying `-ko` on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s say I add a keyword to a source file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, I would commit this change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After the commit, the keyword has been substituted by my username:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Git has a very limited set of keywords, and this is because changes are per
    repository and not per file. Also, Git avoids modifying files that didn't change
    when switching to another branch or rewinding to another point in time.
  prefs: []
  type: TYPE_NORMAL
- en: Binary blobs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git and CVS handle binary files differently. In CVS, it is harder to handle
    them since you have to explicitly label them as binary. If you don't, you run
    the risk of corrupting the file with unwanted LR/LF conversions or keyword substitutions.
    Git, on the other hand, can automatically detect whether your file is of the binary
    kind. It uses the same mechanism as GNU diffutils.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple binary from source and add a reserved keyword. Then,
    we will compile it with GCC and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s copy the binary to the CVS project that we used previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'What happened? Well, keyword substitution added the author name in the binary!
    It corrupted it. If you run the `cat` command, you will find the following line
    in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Fortunately, you can fix this with `cvs admin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Amending commits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One frequently used feature of Git is the ability to amend to a commit. This
    is possible because, in Git, there is a difference between creating and publishing
    a commit. This won''t inconvenience users compared to CVS, where it would. If
    you make a typo in your commit message in Git, you can use `git commit --amend` to
    correct it. It''s also technically possible in CVS, but it would be hard to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s pretend I forgot to add something to my `README.md` file (a text file
    in my repository). The following code shows you how to add it to the last commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: By doing this, you can add to a commit, but this is only reflected in your local
    Git copy. You still have to push your changes to remote servers if you want others
    to see your changes.
  prefs: []
  type: TYPE_NORMAL
- en: A central repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CVS as a centralized system has one place of origin. Git is a distributed versioning
    system, which means that each developer has its own copy of the repository. They
    have a private one and they can push changes to a public one or merge changes
    from other remotes. In larger organizations, it is common to have a central place
    to aggregate projects. With Git, there is no need to have a single central place
    where you store your changes. Each developer can have their own repository (or
    better repositories, that is, a private one in which they undertake development,
    and a public bare one where they publish parts that are ready), and they can pull/fetch
    from other repositories in a symmetric fashion.
  prefs: []
  type: TYPE_NORMAL
- en: In the Git world, there is no single source of truth like there is in the CVS
    server. There can be several truths, and because it is so easy to integrate changes
    from others, this works.
  prefs: []
  type: TYPE_NORMAL
- en: Accompanying toolset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git provides a lot of tools that you can work with (Git bisect for one), which
    makes for a more productive way of working.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting file renames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to rename a file is not supported in CVS, and being able to restore
    the state of the project when renames have happened is hard. Git uses heuristic
    rename detection so that it can analyze whether the content or filename are similar.
    You can also configure this detection in order to copy files.
  prefs: []
  type: TYPE_NORMAL
- en: Commit before merge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A side effect of Git, when using a local repository, is that it changes the
    way commits are handled in the system. With CVS, you will need to handle conflicts
    first (if someone else changed something before you pull to update your working
    directory and resolve issues). Having done this, you can commit your changes to
    the CVS repository. This is called **merge-before-commit**. Git works entirely
    differently, since commits are always done in the local repository. This commit-before-merge strategy
    means that you merge changes after the commit, and it is also possible to ask
    the other developer to merge and resolve issues. It can get harder to distinguish
    changes between commits if there are many merges, but to retain a nice linear history,
    it is also possible to mimic CVS behavior by using the Git *rebase* mechanism
    (`git pull --rebase`) in which you apply changes on top of the updated state.
  prefs: []
  type: TYPE_NORMAL
- en: The last big difference is in the way people collaborate with each other. Some
    developers only need a read-only copy of the original software, but they need
    anonymous read-only access to the source code. Both CVS and Git can accommodate
    this. Things become different if people want to contribute something back to the
    project. With CVS, one way of doing this (like with the Linux kernel) is by sending
    patches via email. This is done by people who change a small amount of code. With
    Git, it is actually very easy to execute your changes on top of an existing upstream
    version and then generate an email with `git format-patch`. With bigger contributions,
    the functionality and ease of a pull request become important, and this was what
    Git was designed for. All of this happened because of the snapshot paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing to migrate from CVS to Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next section, we will look at two tools that can help us migrate repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for a conversion using cvs-fast-export
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This migration tool was created by Eric S. Raymond, a very well-known writer/developer
    who wrote the famous essay *The Cathedral and the Bazaar* about open source software.
    He is also the author of fetchmail (an early open source POP3-client). Let's get
    started.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the this tool, `cvs-fast-export`, I will create a CVS project from scratch
    that we will convert. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a CVS root. This is where the CVS database will reside:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some variables for CVS to your environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example, we will create an empty JavaScript project and add it to CVS.
    First, create a project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add the project to CVS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the project is present in CVSROOT:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to completely erase `~/cvs/cvsproject` because we''re going to
    check it out as a CVS working directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is checking out the project in CVS, which will create a CVS working
    copy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking into the directory reveals a CVS directory structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create an image directory and add it to the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `cvs status` command, we can check which files have changed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s commit these changes into our CVS repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `cvs log` command, we can see what has changed in more detail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a CVS repository that's been prepared for migration with `cvs-fast-export`.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for a conversion using cvs2git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s take a look the second tool, `cvs2git`. For this conversion, I
    took a copy of a project I have used before (**itsmyparty**: [https://github.com/Joustie/itsmyparty](https://github.com/Joustie/itsmyparty)),
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, I imported the source code into a CVS repository (I deleted the `.git`
    directory first):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, no conflicts were created by this import, which is great. We
    are now ready to run the conversions.
  prefs: []
  type: TYPE_NORMAL
- en: Running the conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a couple of ways to convert data from a CVS repository into a Git
    one. After you have converted the repository, you need to push this new Git repository
    to a GitLab server.
  prefs: []
  type: TYPE_NORMAL
- en: Converting data using cvs-fast-export
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps for Converting data using `cvs-fast-export`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, download the source from Eric Raymond''s site: [http://www.catb.org/~esr/cvs-fast-export](http://www.catb.org/~esr/cvs-fast-export):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, build the software:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to your `cvsroot` directory and run the tool in a pipe with `find` and output
    the results to a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, initiate an empty Git repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to use `git fast-import` to populate our empty Git repository
    with information from the old CVS project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that all the meta information has been converted, the only thing left to
    do is checkout the code from Git:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The CVS project is now available as a Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: Converting data using cvs2git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at converting data using `cvs2git`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to migrate the CVS data structure to something that could
    be imported with `git fast-import`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The first pass (`CollectRevsPass`) went through all the version files and analyzed
    them for revisions. The next 14 passes will transform all kinds of data from CVS
    and convert it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the tool is will display statistics about the import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create a skeleton Git repository, where we could import
    the converted data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we start the import, with the blobs being imported first (`git-blob.dat`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we import the Git metadata (`git-dump.dat`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all we need to do is checkout the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now you have a migrated CVS repository.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up after migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, after a migration of some sort, you will need to clean up afterwards.
    How this will take place in this situation depends on your use case. If it is
    a one-off migration, you should make a tarball of the old CVSROOT and put it on
    a DVD. You can also choose to let the repository systems coexist and even perform
    updates on the CVS repository from Git. There are also ways to create bidirectional
    communication (prepare for some shell scripting).
  prefs: []
  type: TYPE_NORMAL
- en: What definitely needs to happen if you migrated the CVS repository to Git is
    that you will need to add a remote that is pointing to your GitLab server. This
    will be the platform where pull requests (or, in GitLab speak, *merge requests*)
    are created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you need create an empty project in your GitLab server and then add the
    remote, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Your old CVS repository will have been converted and pushed to your GitLab server.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the origins of CVS. We compared CVS to Git in
    a variety of way. The basic difference between the two is that CVS is a centralized
    versioning system while Git is of a distributed nature. Afterwards, we set up
    a basic CVS project and prepared to migrate it to GitLab. Then, we made a copy
    of an existing project to be used with the second tool. Finally, we looked at
    two different ways of performing conversion to migrate the repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will take a look at what many people consider the *enhanced*
    successor of CVS: subversion. It already incorporates features that are also present
    in Git.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the biggest difference between CVS and Git?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the network protocol that's used with CVS called?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CVS uses changesets. (True | False)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does Git implement versioning numbers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you easily correct a typo in a commit message in Git?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it possible to rename a file in CVS?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the command to initialize a new CVS database on your machine?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the command to initialize a new Git project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Who created the `cvs-fast-export` tool?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you import your migrated repository into GitLab?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`cvs-fast-export`: [http://www.catb.org/~esr/cvs-fast-export](http://www.catb.org/~esr/cvs-fast-export)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cvs2git`: [https://www.mcs.anl.gov/~jacob/cvs2svn/cvs2git.html](https://www.mcs.anl.gov/~jacob/cvs2svn/cvs2git.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Git Version Control Cookbook - Second Edition* By *Kenneth Geisshirt*, *Emanuele
    Zattin*, *Rasmus Voss*, and *Aske Olsson*: [https://www.packtpub.com/in/application-development/git-version-control-cookbook-second-edition](https://www.packtpub.com/in/application-development/git-version-control-cookbook-second-edition)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
