- en: GitLab Vision - the Whole Toolchain in One Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is intended to provide more insight into the background against
    which GitLab has arisen. The product was literally created to help solve a number
    of problems that the Agile movement experienced. We will talk about the history
    of development methodologies and the rise of Agile as the dominant way to develop
    software. The Agile methodologies spilled over to the traditional operations department,
    which then led to the DevOps movement. Finally, we will summarize a number of
    tools that are part of the DevOps way of working.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Agile Manifesto
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extreme Programming** (**XP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DevOps movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The toolchain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with the instructions in this chapter, please download the Git
    repository with examples available from GitHub at [https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter09](https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: The Agile Manifesto
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some people in the 1990s had a problem with the classic engineering mindset
    of comparing software development to build engineering. Instead of trying to keep
    the requirements stable and not let them get out of hand through requirements
    creep or scope creep, they looked for a process that did not depend on the stability
    of requirement. Those people came up with a number of different ideas in response,
    and those methods are commonly known as lightweight methods. All of these form
    the Agile movement, together with lean manufacturing methods, and have grown very
    popular over time.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what is it about Agile that everyone says nowadays? For some, it's way
    of life and of looking at things. In IT, according to Google, it is a method of
    project management, used especially for software development, that is characterized
    by the division of tasks into short phases of work and the frequent reassessment
    and adaptation of plans.
  prefs: []
  type: TYPE_NORMAL
- en: Officially, Agile is not a method, but a collective term. Agile was born from
    several other methods to develop products (mostly software). Examples include
    XP, Scrum, the **Dynamic Systems Development Method** (**DSDM**), Adaptive Software
    Development, and Crystal. These methods share the common characteristic that they
    all aim for less bureaucracy during product and software development, and embrace
    change. In the 1980s and 1990s, these separate methods were developed by various
    experts, who eventually set up the Agile Manifesto in 2001\. These were mainly
    intended to prevent problems with the application of traditional waterfall methods.
  prefs: []
  type: TYPE_NORMAL
- en: All of the big names from different Agile disciplines eventually decided to
    come together informally and discuss ways to help IT improve. The Agile Manifesto
    was drawn up during this meeting of 17 software developers. It took place from
    February 11 to February 13, 2001, at The Lodge in Snowbird, Utah. The name Agile
    was also chosen here. Word has it that the name lightweight method was on the
    table, but Agile was eventually chosen.
  prefs: []
  type: TYPE_NORMAL
- en: The initial model – waterfall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When people talk about the origins of the waterfall model, it is often said
    that W. W. Royce introduced it in 1970 in the paper, *Managing the Development
    of Large Software Systems* ([http://www-scf.usc.edu/~csci201/lectures/Lecture11/royce1970.pdf](http://www-scf.usc.edu/~csci201/lectures/Lecture11/royce1970.pdf)).
    Royce himself actually believed in the iterative approach to software development
    and did not even use the term waterfall. Royce described the waterfall model as
    a method he thought was too extreme – and even an proposition doomed to fail:
    *"I believe in this concept, but the implementation described above is risky and
    invites failure"*, Royce wrote.'
  prefs: []
  type: TYPE_NORMAL
- en: In 1970, Royce thought that the waterfall method had to be seen as an initial
    concept, as he felt there were errors in the method. He published a document examining
    how the initial concept could be developed into a repeated method. In this enhanced
    model, there was more feedback between each phase than the previous phase, as
    we now often see in the current methods. Annoyingly for Royce, only the initial
    method got attention, and the criticism he had on this method was largely ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Royce''s intention was to transform the model from the paper into an iterating
    model; still, the original method has been widely used and idealized. However,
    people who oppose this model think it is too basic and has no real practical use.
    The following diagram illustrates the waterfall model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/523b8e48-5f0e-40aa-8f99-7567fb2faaf7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The waterfall model consists of the following phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Definition study/analysis (Requirements/analysis)**: In this phase, the only
    goal is to search for requirements. Some research is done to clarify the purpose
    of the software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Basic design (Design)**: In this phase, what has emerged during the first
    phase becomes clearer. The customer wishlist is put on paper and the user interface
    of the program is already being considered. Generally speaking, in this phase,
    it is recorded what the future system must do.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technical design/detail design (Design)**: A prototype or minimal program
    can already be built using the basic design. During this phase, consideration
    is given to the possibilities of achieving the desired functionality technically.
    The options are already grouped in modules, functions, or programs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Construction/implementation (Coding)**: In the construction phase, the actual
    source code is written for the program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To test (Testing)**: In the testing phase, it is checked whether the software
    is built properly according to the design. Here, errors can also emerge that have
    already been made in earlier stages. In the theoretical model, this should not
    happen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration (Testing)**: The system should now be ready and tested. However,
    it should also work with other pieces of software or hardware. There are special
    tests for this that make sure the integration works.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Management and maintenance (Maintenance)**: In order to ensure that the system
    continues to operate and function according to specification, maintenance will
    have to be carried out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, the waterfall model consists of different phases. Each phase has
    its own level that also determines the sequence. The highest level is executed
    first before the following, lower phases. This is equal to the natural effect
    of a waterfall, hence the name.
  prefs: []
  type: TYPE_NORMAL
- en: To mitigate the cons of the original method, several enhanced forms were developed.
  prefs: []
  type: TYPE_NORMAL
- en: Royce's model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Royce's model describes a different waterfall model that can go back to previous
    phases. Often, it will become apparent at a particular phase that something went
    wrong in a previous phase (this will most commonly surface in testing phases).
    It should then be possible to go back to a previous phase easily. 99% of the time,
    changes to the design have to be made – nobody is perfect, so this model is more
    realistic. Nevertheless, Royce continued to emphasize the importance of good documentation
    for proper phase transitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates Royce''s model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98c6319d-e8ff-465a-9e5d-59ba7af3a9e1.png)'
  prefs: []
  type: TYPE_IMG
- en: The sashimi model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The sashimi model, designed by Peter Degrace, is one of the models discussed
    in the book, *Wicked **Problems, Righteous Solutions: A Catalog of Modern Software
    Engineering Paradigms*. This model assumes the same phases as the waterfall model,
    but that they can overlap (even more than once). This way of working means that
    fewer resources are wasted. In the following diagram, you can see how the phases
    can overlap. What matters is that there are no hard endings of phases or gateways.
    You can see the current time as an example. Another aspect of this figure is that,
    in contrast to the waterfall model, the lead time is also included in the model.
    This is to indicate that you can already start designing, even if the analysis
    is not yet complete. It also means that you can go back to the analysis in the
    design phase.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure illustrates the sashimi model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67b2349c-bad9-4f02-8d16-7c30d294be81.png)'
  prefs: []
  type: TYPE_IMG
- en: The V-model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The V-model shows the phase transitions within software development, which offers
    the possibility of QA. For every phase transition, the developers and the customer
    make quality agreements about, for example, the designs. The V shape illustrates
    that at the bottom of the shape, after real implementation, there will be an ever-growing
    understanding of the problem that is being solved, and that initial ideas and
    requirements are tested against reality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the V-model model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51d17d27-69f6-4e91-99ad-46a086571321.png)'
  prefs: []
  type: TYPE_IMG
- en: The sequential way of working that is presented here in these methods fits classic
    engineering methods. For a long time during the 1970s and 1980s, it was believed
    that software engineering as a discipline should work in a similar way to how
    engineers build skyscrapers. Skyscrapers are built by first creating a detailed
    architectural plan before construction workers can carry out the building phase.
    To create an architecture and a plan in such a way, you need a very clear understanding
    of what needs to be built. What is important here is that the upfront requirements
    are clearly outlined and do not change along the way. If the expectations of real-world
    engineering projects changed as rapidly as they do in software, however, nothing
    would get built.
  prefs: []
  type: TYPE_NORMAL
- en: DSDM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The DSDM is derived from the linear **Software Development Methodology** *(***SDM**)
    model, which originated in the 1990s. It was an answer to the problem that, in
    linear methods, the functionality to be developed is often available too late
    as a whole. If the functionality to be delivered can be divided into sub-functionalities,
    these sub-functionalities can be delivered separately. We call this incremental
    system development or step-by-step development. In the beginning you want to find
    out which functionality can be split off. This means that the first two phases
    from the waterfall approach are completed, but only when the partial functionalities
    are clear can these be developed step by step in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: DSDM is more than just applying iterations at development stages. All of the
    remaining phases after analysis are iterative. In addition, the division of phases
    looks slightly different. In contrast to the linear development model, it is also
    possible to go back to previous phases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The phases within DSDM are structured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Feasibility study
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional model iteration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design and construction iteration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timeboxing is one of the core practices used in DSDM to control each stage,
    which is combined with better prioritization with MoSCoW. We will explain this
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Timeboxing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to ensure that a project can be of service to the organization in time,
    timeboxes are used. For example, the functionality with the highest priority should
    always be delivered within a timebox. If there is time and space left, then there
    will be room for functionalities with a lower priority. A timebox is a time interval
    in which an intermediate product is delivered. During the project, the precise
    functionality is refined further. Due to growing insights and changing circumstances,
    the specifications of a functionality can also change.
  prefs: []
  type: TYPE_NORMAL
- en: A timebox is prepared, in which must-haves, should-haves, and (possibly) could-haves
    are defined. This layout allows you to create room for manoeuvre without affecting
    the end time of the timebox. In other words, in the case of changing insight or
    emergencies, you will be able to re-prioritize. This may be at the expense of
    should-have and could-have system requirements. By applying MoSCoW, you make these
    choices explicit.
  prefs: []
  type: TYPE_NORMAL
- en: With this technique, you can keep constant focus on functional requirements
    with the highest priority, monitor your time and budget, and still be able to
    act when insights change. Using this technique enables you to give priority to
    the system requirements that give a company the most benefit, and lower the priority
    for requirements that were derived from situations that may never occur. This
    also makes systems simpler in design—something that improves their maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: The classification of requirements and wishes based on the MoSCoW classification
    also helps users to visualize the support for a project within an organization.
    There are now authors who think that you should consider projects as clusters
    of micro-projects. Every micro-project is a requirement or a wish with a certain
    priority. In many projects, the support from stakeholders starts to crumble when
    people are confronted with changes. If a project includes many must-haves, this
    risk will be smaller than when it largely consists of would-haves.
  prefs: []
  type: TYPE_NORMAL
- en: MoSCoW
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It often happens that a project is hindered by too many wishes from the user
    organization. However, a development strategy that provides feedback to the customer
    can prevent over-demanding the development organization. DSDM counteracts this
    by dividing the functional requirements and wishes into a number of categories
    in which the priority is indicated for each functionality.
  prefs: []
  type: TYPE_NORMAL
- en: DSDM uses the MoSCoW rules to determine the priorities for requirements and
    wishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'MoSCoW stands for:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Must-have**: This category has the highest priority, is guaranteed to be
    delivered, and counts as the engine of the information system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Should-have**: A necessary requirement where a (temporary) workaround is
    possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Could-have**: A requirement with a clear added value, but without it there
    is still a usable system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Would-have (or want to have but won''t have this time around)**: This requirement
    can be missed, although it does not mean that it is not relevant; in the next
    increment, it can be a **must-have**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nowadays, DSDM is not extensively used. The last decade has seen other methods
    gain a lot more popularity, especially Agile methods such as Scrum, which we will
    discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Scrum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next lightweight model we will touch upon in this book is called Scrum,
    which, as of 2018, has been widely adopted outside the IT realm. It is not a method
    such as DSDM and can be better described as a framework. It uses the paradigm
    of a sports team (rugby, to be exact), where a group of people work together to
    achieve a goal.In the rugby game, a scrum drives the ball into the game. The scrum
    group consists of five to eight players who operate as a unit. In the IT world,
    it is a group of people who create business value through close cooperation and
    coordination.
  prefs: []
  type: TYPE_NORMAL
- en: In Rugby, each player has a unique position; they play both roles in attack
    and defense, and they work as a team to get the ball to the other side. It can
    be compared to a situation in IT, where the degree of success of a scrum team
    depends on the different disciplines within the team and how they work together
    and coordinate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: The Rugby comparison originates from a 1986 article from the Harvard Business
    Review, *The New Product Development Game*, where the authors Takeuchi and Nonaka
    introduced the term scrum in the context of product development. They argued that
    it would bring more speed and flexibility, and they based it on case studies done
    in several industries, notably the automotive industries.
  prefs: []
  type: TYPE_NORMAL
- en: In the early 1990s, Ken Schwaber and Jeff Sutherland started using scrum techniques
    in their companies, and eventually in 1995, they presented a paper describing
    the Scrum framework at a software design conference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scrum sets out the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Commitment**: The members must fully commit themselves to the project; it
    is not a part-time job.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Focus**: embers should focus on what needs to be done in each sprints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Openness (Transparency)**: People must keep each other well informed about
    progress and possible problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Respect**: Members must respect those with a different background and expertise
    and trust each other''s good intent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Guts**: Members must have the courage to say things, ask questions, and come
    up with new solutions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scrum works with multidisciplinary teams who prefer to work in one room so that
    consultation is easy. The team is supervised by a scrum master, who has a facilitating
    role. The product owner is the customer or a client, or a representative thereof.
    He or she specifies the desired results, usually in the form of user stories.
    These user stories are kept in a list, the product backlog, or the work stock.
    The product owner sorts the work stock for priority. The most important user stories
    are at the top.
  prefs: []
  type: TYPE_NORMAL
- en: In Scrum, you work in sprints or iterations. These usually last from about a
    week to a month, with a duration of two weeks as the most common. Sprints are
    timeboxed. In other words, it is certain in advance how long a Sprint will last
    for and when it will end. At the beginning of a sprint, the user stories for that
    Sprint are determined and recorded in the sprint backlog.
  prefs: []
  type: TYPE_NORMAL
- en: Sprints provide results that are as tangible as possible. This means that the
    software development will provide usable code, including integration, tests, and
    documentation, that is understandable for the customer or end user.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of a sprint, a sprint review takes place, where the result is shown
    to the product owner. In addition, an evaluation takes place within the team.
  prefs: []
  type: TYPE_NORMAL
- en: Crystal methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Crystal method is a lightweight method with characteristics such as emphasis
    on people instead of processes and products, fast communication (preferably by
    working together in one room), the quick delivery of products, frequent and automatic
    testing, and regular evaluations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike some other software development processes, Crystal is not a software
    development method, but a collection of methods and processes. This collection
    is called the Crystal Family. Crystal was invented and described by Alistair Cockburn.
    Each member of the Crystal Family is indicated with a color representing the weight
    of a method, where the following applies: the darker the color, the heavier the
    method. The color of the method is chosen on the basis of the size and severity
    of the project. The size is determined by the number of people participating in
    the project, and the severity is determined by the risk that choosing the method could
    cause systemic damage. The colors are, like real crystals, sorted from light to
    dark. Crystal clear is the smallest and lightest, followed by yellow, orange,
    orange web, red, maroon, blue, violet, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the Crystal methods differ from each other, they do have some similarities,
    which is why they are also called a family. They have three common priorities:
    safety, efficiency, and usability. Furthermore, they also have common characteristics,
    the three most important of which are the frequent delivery of (intermediate)
    products, feedback on improvements, and good communication.'
  prefs: []
  type: TYPE_NORMAL
- en: We have already discussed a team-based approach to product development with
    certain process steps, and now with Crystal methods, a lightweight Agile method
    that focuses on people within the team itself. There are also more radical methods
    that focus not only on people and process, but also on tooling and technical quality.
    We will discuss these XPmethods in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: XP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important subcultures of the Agile movement is XP. The main
    founders of XP are Kent Beck, Ken Auer, Ward Cunningham, Martin Fowler, and Ron
    Jeffries. They developed XP during the **Chrysler Comprehensive Compensation**
    (**C3**) system project in 1996\. It is very popular nowadays, and this is reflected
    in the culture of software development but also in its ways of working and the
    toolset it uses. We believe GitLab is, in many ways, the tool once imagined for
    XP. It is, in fact, so profound that we have decided to dedicate an entire chapter
    to it to explain its relevance for GitLab.
  prefs: []
  type: TYPE_NORMAL
- en: 'XP takes its name from the fact that a number of proven development principles
    (so-called best practices) are carried through to the extreme. The optimal power
    of XP stems from the application of the 12 best practices of software development.
    The best practices are grouped into four groups: fine feedback, continuous process,
    shared knowledge, and the well-being of the developers.'
  prefs: []
  type: TYPE_NORMAL
- en: Fine-scale feedback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important principles in XP is the usage of feedback mechanisms
    and trying to keep the feedback loops as small as possible. This starts at the
    planning stage, because feedback from a customer at this stage can already limit
    wasted time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fine-scale feedback group in XP includes four practices: planning game,
    pair programming, **test-driven development** (**TDD**), and whole team. We will
    discuss the feedback loop for each practice in the following sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Planning game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The planning takes place at the beginning of each iteration and consists of
    both release planning and iteration planning.
  prefs: []
  type: TYPE_NORMAL
- en: Release planning determines which functionality will be realized in which release.
    Both the developers and the users are present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Release planning consists of the following three phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exploration phase**: Here, the users make a shortlist of the most important
    requirements for the new system. This happens in the form of user stories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Commitment phase**: Here, it is decided which user stories will be included
    in the next release and when this release will be.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Steering phase**: Here, the plan can be modified, and new stories added and
    others removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iteration planning is when user stories included in the release schedule for
    an upcoming Sprint are divided into tasks for the developers. No users are involved,
    only developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Iteration planning also consists of three phases; they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exploration phase**: Here, the stories are translated into tasks, which are
    then written on cards called task cards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Commitment phase**: Here, the time taken to realize the tasks is estimated
    and the tasks are assigned to the developers (pairs).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Steering phase**: Here, the tasks are carried out, and the result is compared
    with the original time schedule of the user story.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose of this kind of planning is to ensure that a product can be delivered.
    It is not so much about delivering exact data as about delivering the product.
  prefs: []
  type: TYPE_NORMAL
- en: Release planning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During this part of the planning game, customers and developers try to find
    out what will be included in the next release of the software and when this will
    take place. The focus is on creating user stories.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part of the game consists of the following three phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exploration phase**: This is the process of gathering requirements and estimating
    the amount of time it will take to realize them. Activities in this phase includes
    the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Writing a story (user story)**: Here, the users come up with a problem or
    wish; during a consultation, the developers will try to fully understand this
    problem. On this basis, a user story is written. This is done by the users, indicating
    what they expect from a system. It is important that developers do not interfere.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Estimating the user story (estimating a story)**: The developers estimate
    how much time it will take to make this. The developers can now also designate
    short examinations, called spikes, to investigate parts of the problem or the
    solution direction. These spikes are used to achieve better time estimates and
    are thrown away as soon as the problem and/or the solution is clear to everyone.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Splitting a user story**: In this phase, the story must be completely clear
    and all ambiguities must be cleared up before iterative planning can be started.
    If the developers cannot give a time estimate for the story due to lack of clarity,
    the story must be split. If the users have described all their wishes, they can
    continue with the concept of decision-making, which is known as the commitment
    phase.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Commitment phase**: In this phase, we will find out what the costs are, what
    the benefits are, and what schedule consequences they have. We create four different
    lists based on the way we sort the items, which are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sorting by value**: Users put the user stories in order of what they consider
    important. They make the following three stacks:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Critical**: Without these stories, the system cannot work or has no value.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Important**: User stories that are important to the company.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nice to have**: User stories in which less important characteristics are
    realized.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sorting according to risk**: Here, the developers give an estimate of the
    risks and sort the story accordingly. All values ​​for the user story are added
    together, giving the user story a accumulated risk value of low (0-1), medium
    (2-4), or high (5-6). The following is an example of this:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Completeness (do we have all the details about the table?)
  prefs: []
  type: TYPE_NORMAL
- en: Full (0)
  prefs:
  - PREF_UL
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Incomplete (1)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Unknown (2)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vulnerability (are changes likely?):'
  prefs: []
  type: TYPE_NORMAL
- en: Low (0)
  prefs:
  - PREF_UL
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Medium (1)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: High (2)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Difficulty (how difficult is it to realize?):'
  prefs: []
  type: TYPE_NORMAL
- en: Simple (0)
  prefs:
  - PREF_UL
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard (1)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Difficult (2)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Determining the development speed (velocity)**: Here, the developers determine
    at what speed they can execute a project and sort items accordingly.'
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scope**: Here, it is determined which user stories will be realized in the
    coming release. This is the final sort. On this basis, the release date is determined.
    The sort should be according to the value for the users (business value).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Steering phase**: In this phase, the developers can steer the process together
    with the users. In other words, they can still change something, whether that
    be an individual user''s story, or the importance of another particular story.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iteration planning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Depending on the speed of the team, it can be determined how many story points
    the team can do per iteration. Iterations can last from one to three weeks. The
    focus here is on creating tasks and prioritizing them. The iterations also have
    the same phases as the earlier release planning, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exploration phase**: During the research phase of iteration planning, the
    user stories are divided into tasks, and how long a task will take is estimated.
    The main activities in this phase include the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Translating the user story into tasks and writing them on task cards.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding or splitting tasks; in other words, if the developer cannot properly
    estimate how long a task will last because it is too big or too small, something
    will need to be altered.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Estimating the task, where an estimation of a task's execution is produced.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Commitment phase**: In the assignment phase of iteration planning, the following
    tasks are distributed among the developers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A developer (programmer) accepts a task: Each developer takes a task for which
    they then become responsible.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The developer gives a time schedule: Because the developer is now responsible,
    they are now best able to give a time estimate.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The effective working time is determined, outlining the number of hours that
    a developer or programmer can develop during an iteration. (For example, in a
    40-hour working week, in which five hours of meetings are held, the effective
    working time becomes 35 hours.)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Balancing: Once all the tasks have been assigned, the number of hours each
    developer has received is also compared to how many hours they actually have available
    (this is also known as the load factor). The tasks may then be redistributed to
    ensure that each developer has roughly the same amount of work. If a developer
    has too much work, something will have to shift.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Steering phase**: The execution of tasks is done during the execution, or
    steering phase, of iteration planning. There is a bit of a game element to this,
    but the following steps are advised:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Taking a task card**: Here, the developer gets a card with the description
    of one of the tasks they have registered for.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Finding a partner**: The developer looks for a partner to develop the task
    with.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Designing the task**: If necessary, in this stage, a (short) design will
    be made.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Writing the unit test**: Before any programming, all tests must be ready.
    Preferably, these are automatic tests because they often have to be done every
    time source code is checked in.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Writing the code**: Here, the programmer or developer makes the program.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing the program**: The unit tests are performed.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refactoring**: In this step, the refactoring rules are applied and the developers
    ensure their code meets the standards.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Doing functional and integration tests**: After the unit test, all possible
    other tests are run, such as integration tests, regression tests, and so on. The
    code must be adjusted in this step until the test succeeds.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Pair programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XP states that, ultimately, everything revolves around code when software is
    crafted. So, if it is a good thing for developers to review code together, software
    should always be developed in pairs. In other words, pair programming can be defined
    by two people working behind one computer. Pair programming is often considered
    one of the most extreme and controversial aspects of XP because it is thought
    to be slower. However, research has shown that peer review and code inspection
    are the most powerful weapons against bugs—and these are much more powerful than
    systematic testing. These techniques are only used sparsely and often drum up
    great resistance among the programmers themselves, as well as managers who are
    afraid of an increase in working hours.
  prefs: []
  type: TYPE_NORMAL
- en: By enforcing the rule that all software development is carried out in pairs,
    which also change composition regularly, a collective sense of ownership arises,
    and peer review and code inspection become a natural part of the software process.
    As a result, the system ultimately delivered no longer consists of a collection
    of pieces of code tied together with strings, which are poorly maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another advantage to this way of working: there are always at least
    two people who fully understand every piece of code. The transference of knowledge
    to new colleagues happens more naturally, and a continuous training on the job
    takes place.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the benefits of pair programming include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Better quality code**: Activities such as reading code out loud and discussing
    the thought process behind it helps others to understand its complexity, as well
    as giving developers the opportunity to clarify any details and prevent irrevocable
    choices from being made.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better knowledge-sharing within a team**: This is particularly useful when
    one of the developers is not yet familiar with the software component cooperates
    with someone who is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved knowledge transfer**: This is helped by developers automatically
    learning new techniques and skills from experienced team members.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Less management overhead**:This is aided by less individual control because
    developers are working in teams of two or more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continued focus**: Pair programming can be particularly helpful if one member
    of the pair has their work interrupted for any reason.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, are there any drawbacks to pair programming? Currently, it is not known
    exactly what the costs and benefits of pair programming are, but initial research
    indicates that the duration of a task increases by an average of 15% when a pair
    is working over an individual. Whether that cost can be justified by higher code
    quality is debatable.
  prefs: []
  type: TYPE_NORMAL
- en: Test Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In **Test Driven Development** (**TDD**), testing is carried out before any
    programming. TDD relies on the premise that if testing is good, the test code
    should be written before a line of code (functionality) is.
  prefs: []
  type: TYPE_NORMAL
- en: Within XP, the writing of automatic unit tests occupies an important place,
    as writing unit tests is done before an actual program is started. In TDD, the
    programmer makes one or two tests, writes a piece of the program, makes an additional
    test case, reworks the program until the new test passes, the designs a new test,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this process is that the programmer is obliged to think about
    the functionality and the exceptions that their program should take into account;
    they think about what the program should do first and how the program will work
    second. In other words, the tests capture the required functionality. It is therefore
    important that every program only has enough functionality to make the test work.
    If all tests pass, the program meets the previously-defined requirements, which
    are defined in the written and successful unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: When refactoring is required, the already-written unit tests are therefore a
    guarantee that changes will not cause undesirable side effects in the operation
    of a program.
  prefs: []
  type: TYPE_NORMAL
- en: Should it be necessary to expand a program with new functionality, the first
    thing to do is to start writing new unit tests that will define the new functionality
    to be written. This new functionality is only realized when both the new and the
    old unit tests all succeed.
  prefs: []
  type: TYPE_NORMAL
- en: If a bug is found at a later stage during a functional test, writing a unit
    test that brings this bug to light is the first port of call. A bug is therefore
    not a fault in the program, but rather the result of an insufficient test.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, a software development project that is carried out using TDD
    does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Starts with one unit test that describes one feature of the program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runs the test, which should ultimately fail because there is no code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizes the minimum amount of code needed to make a test pass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rewrites code to make it simpler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeats the process with more tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using this approach, the defect rate should go down after time, despite more
    time being needed to get things started. Most teams report that once they have
    reached the end stages of a project, the upfront testing cost is paid back and
    they work quicker in a project's final phases. Code that is developed this way
    tends to be of higher quality than otherwise, because for testing to work, you
    are forced to create code that is high in cohesion but low in coupling. This keeps
    code that works on the same behavior and keeps properties in the same class, as
    well as keeping modules as isolated as possible with clear interfaces to other
    code.
  prefs: []
  type: TYPE_NORMAL
- en: This approach may sound quite simple, but in practice, it's quite hard, as developers
    may forget to run tests. However, this problem can be easily fixed by setting
    up a project template in a CI/CD environment with pre-configured tests, where
    tests are run at every commit or push. If there are software engineers who are
    prone to overdo testing, it is a good idea to agree on the number of tests, and
    how far they will go, beforehand. Don't test constructs that are simple, such
    as accessors, for instance. On the other hand, be careful not to over-simplify
    your tests, such as by creating tests but no assertions.
  prefs: []
  type: TYPE_NORMAL
- en: Team culture and agreements are very important for testing. If some team members
    aren't on board, you will have conflicts. Also ensure that any test-templating,
    automation, or suites are well supported, or your tests will break. (This also
    means that several people should have knowledge of these products.)
  prefs: []
  type: TYPE_NORMAL
- en: In essence, TDD can really improve the quality of your software. This is especially
    true if all tests are automated via a continuous process, which we will discuss
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuous processes are a group of processes that are envisioned to run all
    the time with no interruptions. There is also no need for batching, which often
    slows down XP as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If integration and integration tests are important, then code should be integrated
    as often as possible – preferably, several times a day. This will prevent your
    team from working with different copies locally and encourages them to work alongside
    each other. Any integration problems will also become immediately visible. GitLab
    CI was created for this reason, and was introduced in [Chapter 1](384dcfd9-ef7f-470d-89dc-3af7502a2d09.xhtml),
    *Introducing the GitLab Architecture*.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key reasons CI is used is to prevent integration problems, which
    can occur if developers work on their own for too long. Imagine the phenomenon
    of integration hell, where at the last minute before release, a developer merges
    a big chunk of code that then introduces conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration has always been coupled with TDD in the XP world. Before
    integration tests are run, it helps if code is thoroughly tested locally, preferably
    by using unit tests. This way of testing code in your local environment helps
    uncover bugs before they break other people's code. Note that you can also hide
    features that are not yet complete by using feature toggles, which disable certain
    behaviors in code.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, build servers are used for other parts of the software **Quality
    Assurance** (**QA**) process, including running additional security tests, measuring
    performance, and even generating documentation. This behavior of shifting responsibilities
    to the build server means that a lot of QA work that was traditionally done after
    development work can instead be performed during development, with the bonus of
    immediate feedback. This feedback loop is a big driver of the continuous process
    of developing a software product, with the other being automation.
  prefs: []
  type: TYPE_NORMAL
- en: Automation has been further extended to create **Continuous Delivery** (**CD**),
    by making the deployment of software part of the automation. To make this possible
    and run quickly without issue, the code in the main trunk or branch should always
    be in a state so that it can be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Every element of building a software product that can also be automated is eligible
    to be part of the CI process, especially when it's particularly complex. Automating
    these stages is one of the reasons CI/CD exists.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important technique that differentiates XP from traditional development methods
    is refactoring, which is the continuous rewriting of program code in small, precisely-measured
    steps without affecting any visible functionality. In short, refactoring adds
    nothing to the functionality, but simplifies the design. By regularly executing
    rewriting steps, the overall effect is often astonishing.
  prefs: []
  type: TYPE_NORMAL
- en: In the meantime, some 70 rewrite rules have been discovered and documented.
    They carry names such as introduce null object, replace temp with query, and replace
    conditional with polymorphism. The preconditions for the successful application
    of refactoring is that there are unit tests available that can be carried out
    automatically after every rewriting step to ensure that the functionality has
    not changed. For example, for Smalltalk, there is now a refactoring browser, with
    which rewriting rules can be applied automatically and without the user having
    to worry too much about accuracy. Refactoring is often used in preparation for
    implementing an extension or a change in functionality.
  prefs: []
  type: TYPE_NORMAL
- en: What is not meant with refactoring is the rewriting of code, bug-fixing, or
    changing the user interface. Another danger of refactoring is that with the absence
    of good automated tests, you may introduce regression errors.
  prefs: []
  type: TYPE_NORMAL
- en: After some time and experience using this technique, teams report considerable
    improvements in the length of the code, less duplication, better coupling and
    cohesion, and reduced cyclomatic complexity. For people new to your software,
    this makes it easier to learn. For teams, it helps to think collectively about
    the general design of a project, and to understand why certain decisions have
    been made. Usually, this also relies on the introduction of certain reusable components
    and modules.
  prefs: []
  type: TYPE_NORMAL
- en: Short iterations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software is regularly delivered to the customer for review in releases of limited
    size; if short iteration strokes are good, you should therefore make them very
    short. We're talking seconds, minutes, or hours, instead of weeks, months, and
    years. An average iteration of XP takes two weeks, although according to [extremeprogramming.org](http://www.extremeprogramming.org/),
    it can vary from one to three weeks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The XP cycle consists of six phases: Exploration, Planning, Iterations to Release,
    Production, Maintenance, and Death.'
  prefs: []
  type: TYPE_NORMAL
- en: For Agile projects, an iteration is a specific time period during which development
    takes place. This is called timeboxing. This period varies from project to project,
    but is usually between one and four weeks, and is often defined for each project.
    A typical Agile approach would be that a project consists of several iterations,
    with a short phase of planning at the beginning and a closing phase at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Iterations are mostly classified in work weeks that start on a Monday and end
    on a Friday. After a while, the fixed term of the iteration makes it easier to
    assess how long a project will take.
  prefs: []
  type: TYPE_NORMAL
- en: The iteration timebox in the Scrum methodology is called a Sprint, which is
    of course a reference to Rugby. In XP, they are called weekly cycles. To most
    people, the word iteration means repetition or even multiple repetitions; when
    used in the Agile context, it means a repeated process.
  prefs: []
  type: TYPE_NORMAL
- en: Everybody owns the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note that every developer has equal rights to all aspects of a program's code.
    If the design is good, make it part of everyone's daily work and improve the design
    step by step as soon as the need arises. If architecture is so important, let
    everyone work on developing it. This concept encourages everyone to contribute
    and take responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Shared understanding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The values in a group are mostly to do with perception. To be efficient and
    effective as a group, you have to agree on certain points and share values and
    a common understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Coding standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To have a shared understanding you need to have some rules. There are coding
    standards that are known and used by everyone. It really helps if source is consistently
    formatted. That way everyone can read it and change it. Speak the same language
    in your code files.  It will also help in ensuring collective ownership of the
    codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Simple design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the code belongs to all developers in a group and everyone can change everything,
    it should be possible for them to do so. Keep the design as simple as possible.
    XP works a lot with the **Keep It Short and Simple** (**KISS**) principle. In
    other words, for a system to be easy to change, the design should be as simple
    as possible. This is easier said than done, however.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional development methods have learned to think ahead and to always think
    about functionality in a design that might have to be realized in the future,
    but these methods are based on the assumption that costs for changes increase
    exponentially. This is why XP is always trying to choose the simplest design to
    enable a functionality that must now be realized. Ideally, any future expansions
    can be implemented with XP without the usual extra costs. It also turns out that,
    all too often in the realization of a well thought-out design, it does not reflect
    current requirements. This may happen either because certain details have been
    overlooked during analysis and design, or because requirements have been adjusted.
    With XP, design does not come first, but instead follows the code.
  prefs: []
  type: TYPE_NORMAL
- en: System metaphor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All team members, including developers and users or customers, share a common
    view on the system (known as a metaphor); everyone must be able to describe the
    system in simple words. The use of naming conventions should also contribute to
    this.
  prefs: []
  type: TYPE_NORMAL
- en: As we have discussed, the final takeaway is that when working with XP, the human
    element is still the most important one. Is everyone talking about the same things,
    for example? Do they all think the right priorities are set? Are they able to
    create software that works and is understandable? This human element is also one
    of the driving forces behind DevOps, the spillover of Agile thinking from software
    development to IT operations.
  prefs: []
  type: TYPE_NORMAL
- en: The DevOps movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term DevOps originated in Belgium around the end of the last decade, as
    a result of the so-called DevOps days. These days were meant to bring together
    IT experts from both development and management operations. A DevOps team was
    initially defined as a multidisciplinary team that is fully responsible for the
    management and CD of a service. Think of Amazon and Google as companies that use
    these kinds of teams; they release dozens of changes every day.
  prefs: []
  type: TYPE_NORMAL
- en: 'This way of working is not yet standardized in big organizations—ITIL and PRINCE2
    still reign, and the Information Technology (IT) department is desperately trying
    to deliver services with value. The way in which these services are provided is
    difficult to maintain in the current situation where IT is still often seen as
    a cost item. This is caused by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The way of organizing organizations as a collection of independent silo's
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A focus on creating process excess (too many rules set in stone)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not defining clear **Key Performance Indicators** (**KPIs**) for measuring performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The technologies in these silos are not compatible, whereas for a successful
    business-IT alignment, one coherent chain is needed.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we are now seeing that customers are increasingly asking for the
    fast delivery of a new functionality. This includes the quick resolution of incidents,
    short lines of communication, and excellent quality requirements in their IT organization.
    Using the old ways of organizing IT in an organization, processes, working methods,
    attitude, behavior, and the required performance and results are not being sufficiently
    realized. A famous quote attributed to Albert Einstein, that "*the definition
    of insanity is doing the same thing over and over again and expecting a different
    result"*, seems to increasingly apply to IT. It is time, therefore, to fundamentally
    reconsider the setup of its organizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the DevOps process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d888abfd-d7aa-4880-aeb7-2464c5b1c5fc.png)'
  prefs: []
  type: TYPE_IMG
- en: History of the movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The term DevOps still causes a lot of confusion in many places. As a movement,
    it is still young, but it is largely based on common sense and experiences from
    the past. DevOps teams appeared from an effort by companies to respond to changes
    in the market. The new DevOps approach has been further developed with the aim
    of releasing higher-quality software to customers faster and more frequently.
    A brief timeline of DevOps is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**2007**: During the migration of a data center for the Belgian government,
    Patrick Debois is frustrated by the many conflicts between developers and system
    administrators. This makes him think.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2008**: At the Agile Conference in Toronto, software developer Andrew Shafer
    is poised to give a session about Agile infrastructure. He decides to skip it
    because he thought there were no attendees, but Debois was going to attend. Later,
    Debois tracks down Shafer for a wide-ranging hallway conversation. Based on their
    talk, they form the Agile Systems Administration Group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2009**: Two Flickr employees, John Allspaw and Paul Hammond, make the case
    to test, build, and deploy responsive, fresh software in a bid to make operations
    and development integrated and transparent. The first DevOps days take place in
    Gent, Belgium. The conference takes place on October 30 with an impressive collection
    of developers, system administrators, experts, and others. When the conference
    ends, ongoing discussions move over to Twitter. To create a memorable hashtag,
    Debois shortens the name to #DevOps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2010**: This is when the first ever DevOps days were organized in the US,
    carried out with the help of John Willis (author of the famous book, *The Phoenix
    Project*), along with early proponents of DevOps. The event soon becomes a global
    series of conferences that are community-organized and are the major force driving
    the DevOps community forward.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2011**: The community of DevOps starts to use open source tools, such as
    Vagrant, that can leverage technologies such as Chef and Puppet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2012**: The presentation development segment grows rapidly and becomes focused
    on innovation. There are now various DevOps days that suddenly pop up in a number
    of countries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2014**: Some of the biggest companies worldwide begin to use the DevOps method
    in their organization, including LEGO and Nordstrom.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Today, DevOps is embraced across the world by a number of businesses; small,
    big, and private businesses benefit from DevOps. DevOps can bring out the best
    results in the long-run for any business and contribute to its success.
  prefs: []
  type: TYPE_NORMAL
- en: However, an organization is not able to switch over to DevOps quickly – changing
    processes in an organization can have a major impact on its culture and needs
    time. A good way to find out where you might be in this journey is to use a maturity
    model. When using a model to represent reality, you can start to simplify the
    problem, instead of being overloaded by the amount of solutions and tools that
    are available. If you know where you are in the maturity model, you can determine
    where you want to be, and then plan your journey.
  prefs: []
  type: TYPE_NORMAL
- en: Four Quadrant Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The original maturity model is the Capability Maturity Model invented at **Carnegie
    Mellon University** (**CMU**). It is a bit heavy to fully utilize, so simplified,
    more lightweight versions of it are preferable. One such version is the Four Quadrant
    Model put forward by Brian Dawson ([https://techbeacon.com/devops/how-map-your-devops-journey](https://techbeacon.com/devops/how-map-your-devops-journey)).
    It is derived from real-world DevOps transformations and offers a flexible way
    to assess maturity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Four Quadrant Model, the values ​​on the *x* axis consist of the different
    phases in the cycle of software development. You can recognize the **Software
    Development Life Cycle** (**SDLC**) in this:'
  prefs: []
  type: TYPE_NORMAL
- en: Define
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You see there is quite some overlap with the DevOps lifecycle phases that are
    proposed by GitLab.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cycle is divided into two halves: **Agile Upstream** (which includes a
    definition, planning, coding, and building) and **Agile Downstream** (which includes
    integration, testing, release, implementation, and methods such as continuous
    deployment and continuous delivery).'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the *y* axis, there is the level of adoption of Agile and DevOps practices
    in an organization. At the lower end, there is the team level, which moves on
    to the workgroup level, and finally the enterprise level. In the original CMMI
    model, there are usually different levels of maturity. The following figure illustrates
    the 4 Quadrant model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a30b2b34-6140-4070-9823-631035dc5b50.png)'
  prefs: []
  type: TYPE_IMG
- en: Agile Upstream means that in a software life cycle, the development side of
    the product is done with Agile methodologies. Agile Downstream is all about the
    deployment and operational side of the SDLC.
  prefs: []
  type: TYPE_NORMAL
- en: Each team must strive to implement the Four Quadrant Model because it enables
    them to innovate faster, increase productivity, respond to market changes, gain
    a competitive advantage, and increase employee satisfaction and retention.
  prefs: []
  type: TYPE_NORMAL
- en: Another way of measuring maturity is to look at competencies. How strong are
    you in certain aspects, for example?
  prefs: []
  type: TYPE_NORMAL
- en: Four levels of competence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One way to test competence is by using the model mentioned by Mike Kavis' paper
    in Forbes. He describes a model that is based on the *Four stages of learning*
    used by Noel Burch in the 1970s.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic idea is that an individual goes through the following four stages
    while acquiring a new skill:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stage 1: unconscious incompetence**: A person may not recognize that they
    need a certain skill. The first step in changing or growing is to recognize this
    deficit and to acknowledge the skill as is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stage 2: conscious incompetence**: Gradually, it becomes apparent that a
    necessary skill is lacking. This is learned by making mistakes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stage 3: conscious competence**: After several iterations or tries, the person
    acquires the skill and knowingly applies it. It won''t succeed every time, and
    doing so takes serious effort.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stage 4: unconscious competence**: The skill has become so natural or logical,
    that it can be applied unconsciously. It can even by taught to others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Davis claims that this model can be applied to organizations that are trying
    to grasp the DevOps concept. It is not scientifically proven, but it can be valuable
    to make the following comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stage 1**: **Nothing there**: The organization initially seems averse to
    change. The term DevOps is described as a hype and is not applicable. This usually
    means that people don''t really understand what DevOps is about. People are trapped
    in the old silo thoughts and think that development should take over operations,
    or vice versa.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stage 2**: **Recognition**: Finally, it has sunk in that something has to
    change. In this stage, there will be mistakes. For instance, automation is introduced
    but the development silo may still think it is responsible for writing everything.
    A new silo (the DevOps silo) emerges, where developers are only creating automation
    for operations. These developers are not knowledgeable in networking  or security
    and compliance or other operational issues. Similar problems occur if the Operations
    department silo is converted to ''the'' DevOps engineer.  With limited knowledge
    about engineering, untested and unmanageable shell scripts may appear. However,
    at this stage, an organization is still learning and will eventually proceed to
    the next stage if the inevitable growing pains are managed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stage 3**: **Coming of age**: After learning from their mistake, the management
    of an organization has taken up interest and recognized the added value of changing
    people and processes. In the previous stage, the aim was to integrate the silos
    of development and operations. Now that this has succeeded through trial and error,
    cooperation has expanded to include legal departments, compliance, and audit.
    The first signs of productivity are visible, with the creation of specialized
    platforms, a framework, or a template for deploying standardized enterprise applications
    from idea to production. Platforms begin to have everything baked in, such as
    compliance and quality control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stage 4**: **100% business driven**: At this stage, multiple business units
    in an organization deploy several times a day and are able to easily enhance the
    process and share their knowledge via the platform. In the most optimal form,
    the business unit is in complete control and has become a multi-disciplined team
    that can advise and collaborate with dedicated platform specialists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, these models are quite theoretical, but they can help in the process
    of organizational change. Fortunately, several tools have emerged to help organizations
    bridge these gaps between the stages of maturity, which we'll discuss in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: The toolchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although we have learned that DevOps is more than just tools, there are a number
    of tools that are commonly used in the enterprise, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A source code repository**: Computer source code has become a very valuable
    asset. It is usually stored in a repository with advanced version management features.
    The repository manages the many versions of code that are checked in, so developers
    can collaborate on each other''s projects. This concept is not new and has been
    around for 30 years, but is a big part of continuous integration because it is
    where the source code is kept. Popular source code repository tools include the
    following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git on the client
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: GitLab
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Subversion
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: TFS
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: CVS
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these repository tools are explained in detail in [Chapter 4](d98d2cb3-53e4-4544-be20-4e618ae24e7b.xhtml),
    *Configuring GitLab from the Terminal*, [Chapter 5](f5893a6a-9076-45e6-8042-92c8304a0033.xhtml),
    *Importing Your Project from GitHub to GitLab*, [Chapter 6](632675c5-19ce-4c2f-8441-a8232ba70f1a.xhtml),
    *Migrating From CVS*, and [Chapter 7](6f1e3f0c-5dcc-47c1-a928-62caeebeca40.xhtml),
    *Switching from SVN*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Build server**: Building software used to be done on the individual developer''s
    workstation, but for the CI pipeline, a dedicated build server is used to compile
    source code from the source code repository into executable artefacts. Modern
    build servers do not just build, but also provide advance testing functions. Popular
    tools include the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitLab Runners**: The build tool for GitLab.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jenkins**: A fork of the Hudson project and a CI platform. This platform
    is primarily intended for the repeated execution and monitoring of build tasks,
    as well as the automated building and testing of applications. The many freely
    available plugins make it very easy to further expand the functionality of Jenkins.
    This software is only available as a distributed service to use on the cloud and
    is tightly integrated with GitHub as a source code repository.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration management**: For CI/CD, you need to control the environment
    where it takes place. For this, there are configuration management tools that
    describe and automate large parts of your infrastructure. Popular tools include
    the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Puppet**: Management software which can control large numbers of servers.
    This concerns both the management of configuration files (the settings of servers)
    and the management of the installed software (packages). It uses a declarative
    language and has a steep learning curve.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chef**: Also configuration management software, Chef supports slightly fewer
    platforms than Puppet and is not a declarative language. Chef uses pure Ruby code
    that indicates what you want to do on your servers. You have more freedom to create
    your own program data structures and functions. It is used by GitLab to manage
    the omnibus package.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Virtual infrastructure**: Infrastructure on which software runs has always
    been virtual, and an operating system is already several layers of abstraction.
    In the cloud, virtual infrastructure is an extra layer of abstraction that represents
    entire machines (such as networks, nodes, and storage). There is also an orchestration
    layer that manages the infrastructure. This provides easy up- and down-scaling
    and can use all resources efficiently. The first real, large-scale virtual infrastructure
    that became available as a service was Amazon Web Services. The other major tech
    companies soon followed with Google Cloud and Microsoft Azure. These infrastructures
    can be managed with their own orchestration tools, but also have APIs that can
    be used by configuration management tools, including the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Puppet
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Chef
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Cloud
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Governments often have special requirements regarding their data. This is called
    data sovereignty and this is why specialist clouds have arisen for governments.
    According to Garter, these clouds could be the next legacy system, after government
    infrastructure was moved like-for-like to the cloud without being decomposed into
    elastic, efficient, and cost-effective cloud components.
  prefs: []
  type: TYPE_NORMAL
- en: Not everyone is able to run their software and data on public clouds, even if
    they have special agreements. If you run a private or hybrid cloud, for example,
    you are essentially using abstractions that exist on the internet in your own
    data center. Even without the elasticity of Amazon or Azure, it can be very beneficial
    to apply cloud techniques yourself. The accompanying automation tools make integration
    with existing systems easier, and a lot less people are needed for managing the
    system. There are also private clouds; for example, VMware has vCloud. It is quite
    easy to extend your existing VMware infrastructure to create cloud-like environments.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test automation**: Testing is all about ensuring confidence in your product.
    When the product reaches deployment time in your pipeline, it should be tested
    for certain defects automatically before it has reached that point. There are
    several tools available to perform all kinds of testing and integrate nicely with
    a lot of other pipeline products; they include the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selenium**: Selenium is an application that allows you to automate browsers.
    What you do with this depends on your goal. You can automate repetitive administrative
    tasks, but Selenium is also used for browser testing.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cucumber**: This is a test tool for **Behavior-Driven Development** (**BDD**).
    The primary goal of BDD is to let people communicate, and close the gap between
    technical and business people. You can write tests in a human-readable format.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apache JMeter**: JMeter is an open source tool that performs load, performance,
    and stress tests. It is a simple but effective application where different types
    of scripts show exactly what the result of the test is. These scripts are used
    for HTTP websites and provide a simulated test environment. In addition to applications,
    JMeter is also suitable for checking services on the web and various databases.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also utilize GitLab Runners and write your own tests.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pipeline orchestration**: The pipeline refers to an automated number of steps
    to get your code from inception to production after it has been checked into version
    control. It''s based on the idea of a manufacturing assembly line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To manage things along the way in a CI/CD process, pipeline orchestration tools
    were introduced. Some of these tools include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kubernetes**: Kubernetes is, essentially, a platform for the roll-out and
    management of containers on a large scale. Kubernetes, Greek for helmsman or pilot,
    is the second name for the project, which originally saw the light of day in the
    big halls of Google as Project Seven of Nine. Project Seven of Nine was an external
    version of Borg, the task scheduler that drives the services of Google, and the
    operation of which was a Google secret for a long time.'
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
- en: Built as an extension to the Docker API, orchestration using Swarm also became
    popular a couple of years ago. It can easily convert a loose group of Docker containers
    in a managed virtual Docker engine. This makes it very easy to start running container
    workloads at scale from scratch.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mesos/Marathon Apache**: Mesos is a distributed kernel and is the backbone
    of DC/OS. It abstracts CPU, memory, storage, and other computer resolutions. It
    has APIs for resource management, planning in data centers, and cloud environments.
    It can scale up to 10,000 nodes. It can therefore be extremely suitable for large
    production clusters. It supports container orchestration with Marathon.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the aforementioned tools can be integrated with GitLab, and you can use
    GitLab for all parts of a pipeline. You can use runners for testing, building,
    or deploying your product, and you can utilize Kubernetes to orchestrate your
    workloads.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s up to you which part of the pipeline is used in GitLab, but it can support
    you in all stages of the DevOps life cycle, illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/caf5c152-1771-4cf1-a29a-8d18153158b6.png)'
  prefs: []
  type: TYPE_IMG
- en: We have now explained the basic setup of a CD pipeline in DevOps. GitLab offers
    close to 100% of all the stages, but can integrate with existing components as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter was intended to provide more background on the origins and development
    of GitLab. A tool does not arise from the void. In the 1990s, it became clear
    that in different parts of the world, people came to the same conclusion: linear
    software development is not the right approach for all projects. The solution
    to this problem has finally reached the operations department after 10 years through
    DevOps. DevOps is a way of working and a culture with accompanying tools for which
    GitLab has been built. In the next chapter, we will see how GitLab can contribute
    to a better DevOps experience.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is an SDLC?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many participants were at the Agile Manifesto conference in Utah?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When was the waterfall model first mentioned?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where was XP programming born?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does MoSCoW mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where and when did the first DevOps days take place?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Agile Upstream?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name two configuration management tools.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The Agile Maturity Model*: [https://info.thoughtworks.com/rs/thoughtworks2/images/agile_maturity_model.pdf](https://info.thoughtworks.com/rs/thoughtworks2/images/agile_maturity_model.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*DevOps maturity model*<q>*:*</q> [https://techbeacon.com/devops/how-map-your-devops-journey](https://techbeacon.com/devops/how-map-your-devops-journey)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What is DevOps?* [http://radar.oreilly.com/2012/06/what-is-devops.html](http://radar.oreilly.com/2012/06/what-is-devops.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Agile Developer''s Handbook*, by *Paul Flewelling*<q>: </q>[https://www.packtpub.com/web-development/agile-developers-handbook](https://www.packtpub.com/web-development/agile-developers-handbook)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*DevOps: Continuous Delivery, Integration, and Deployment with DevOps*, by
    *Sricharan Vadapalli*: [https://www.packtpub.com/virtualization-and-cloud/devops-continuous-delivery-integration-and-deployment-devops](https://www.packtpub.com/virtualization-and-cloud/devops-continuous-delivery-integration-and-deployment-devops)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Practical DevOpsm*, by *Joakim Verona*:[https://www.packtpub.com/in/networking-and-servers/practical-devops](https://www.packtpub.com/in/networking-and-servers/practical-devops)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Wicked Problems, Righteous Solutions: A Catalogue of Modern Software Engineering
    Paradigms*, by *DeGrace*, *Peter*, and *Stahl*, *Leslie Hulet*, pp. 116, 117,
    127\. Reprinted with permission of Prentice Hall, Englewood Cliffs, New Jersey,
    1990.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Managing the development of large systems: Concepts and techniques*, by W.
    W. Royce In: 9th International Conference on Software Engineering. ACM. 1970\.
    p. 328-38.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
