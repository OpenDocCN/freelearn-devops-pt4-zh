- en: Create Your Product, Verify, and Package it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will try to compare the theory from the previous chapter
    with its implementation in GitLab. As GitLab was born from a need to have a collaboration
    platform with advanced features, it has grown organically to its current form.
    It was built with agility in mind. We will present a use case where a small company
    wants to build a software product, and we will use GitLab to evolve the idea into
    a product.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The GitLab workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing your ideas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning your feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying your product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging it for use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with instructions in this chapter, please download the Git
    repository, along with the examples, from GitHub: [https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter10](https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter10).'
  prefs: []
  type: TYPE_NORMAL
- en: You will need an Amazon account if you want to try the examples.
  prefs: []
  type: TYPE_NORMAL
- en: You also need **AWS Command Line Interface** (**AWS CLI**): [https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html)
  prefs: []
  type: TYPE_NORMAL
- en: The GitLab workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remember we introduced the DevOps pipeline as seen by GitLab in previous chapter.
    This screenshot shows the various GitLab stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62d61cf6-be4e-4b8f-8303-74dd7066ce23.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we will present several aspects of the entire pipeline as we
    try to use it in our example project. The first phase is defined as **Manage**,
    and it sounds a bit weird as the first part, but it is a continuous process spanning
    the entire pipeline, and GitLab provides tools for it. The next stage will be
    **Plan**, in which you refine and prioritize and set timelines. Then you start
    the **Create** phase where the tasks are executed to produce solutions. After
    creating your product, you need to test different aspects of it in the **Verify**
    phase. After verifying the product you will package it for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: To explain the GitLab workflow in more detail, we will present a use case that
    is going to be used throughout this chapter to demonstrate features in GitLab.
    For some features you will need the most comprehensive GitLab license.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a company called *Event Horizon*. They want to build a solution for
    managing events (for humans). For instance, you can use their solution to arrange
    invitations to a party.
  prefs: []
  type: TYPE_NORMAL
- en: We introduce User1, who is a backend engineer, and is tasked with creating a
    backend for this solution. Then we also have User2, who is currently product owner
    of this product. They are both part of the IT department of the company. Then
    we have User3, who is part of the marketing department.
  prefs: []
  type: TYPE_NORMAL
- en: User1 and User2 have both been made members of the IT group in GitLab. User3
    is a member of the marketing group, but has reporter access to IT.
  prefs: []
  type: TYPE_NORMAL
- en: Let's help them create this product (minimally) and demonstrate how they can
    use GitLab for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the meeting where both users and developers are present (the Release planning
    in XP, or Sprint 0 when using Scrum) it is decided that these are following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: We want to build an app to help organize events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It needs to use email to communicate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are creating a list of invitees in advance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invitees can interactively indicate if they will attend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Non-functional requirement: documentation is very important.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Non-functional requirement: we want to automate as much as possible.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Non-functional requirement: the tool used should enhance collaboration.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Non-functional requirement: the code used should be reviewed by at least one
    other person.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the end of the meeting, the requirements are prioritized and the developers
    talk without the customers about the possibilities with GitLab as a product. This
    phase is the subject of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps phase – manage your ideas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of creating big designs up front we have learned that iterative development
    is the way to go. But even for projects using Agile methodologies there are some
    considerations before your coding goes off to start. This stage in the DevOps
    life cycle is called *Manage* and it comprises the *whole life cycle*. It is the
    beginning of an Agile iteration but also the end and in between. You will manage
    your solution from the beginning and it never stops. An import part of managing
    is knowing how you are doing. You can analyze this in GitLab, as shown in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Cycle analytics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important metrics in developing software through an Agile method
    is the cycle time. This **Key Performance Indicator** (**KPI**) is best described
    as the total time that has elapsed from the time work has started until completion
    of the task. Or in IT, the time it takes to get an idea implemented on production.
  prefs: []
  type: TYPE_NORMAL
- en: Before Agile project management, tools such as Microsoft Project were used to
    keep track of time. Nowadays, *guesstimates* are not entered in a project anymore,
    but other things such as risk and velocity are calculated in story points and
    they are used to plan some weeks ahead.
  prefs: []
  type: TYPE_NORMAL
- en: 'In GitLab, there is a place to measure cycle times: cycle analytics. It means
    you have to use GitLab''s project management features and it is available in all
    editions. The following image is an example of cycle analytics for the GitLab
    CE project. Notice that it takes about a month for an idea to go into production
    (which corresponds nicely with its actual release cycle):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cf1d0b6-82e5-476e-ad0d-fe2b739af643.png)'
  prefs: []
  type: TYPE_IMG
- en: We can use cycle analytics later in the project to check how well GitLab is
    used and what velocity the development team has.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps phase – plan your feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next stage in the DevOps life cycle that GitLab is envisioning is *Plan*.
    For this phase, we will explore all the steps needed to prepare for the coding
    and building of the solution. In GitLab, there are several tools that can help
    you in this phase, regardless of which development methodology you prefer (Agile
    or waterfall). Where to begin? We always begin with creating an issue. We will
    discuss this in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: Issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is an issue? Well, it can be many things. It could be a new business idea,
    a technical problem, a cry for help. An issue is like starting a new discussion,
    and it is a way to express your thinking. It should change along the way as other
    people get involved. It is the atomic, basic, first thing in GitLab that everything
    else is derived from. It always a good idea to start looking in the existing list
    of issues to see if your problem or wish is already part of an existing issue.
  prefs: []
  type: TYPE_NORMAL
- en: GitLab, as a product, facilitates this discussion and offers ways to manage
    it and flows to verify assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: An issue has several attributes and concepts, which we will look at.
  prefs: []
  type: TYPE_NORMAL
- en: Content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, an issue has content, so how is it structured? The issue  has a title
    and a description. It is also possible to insert tasks into the issue using markdown
    formatting. What also counts as content are the accompanying comments and events/activities
    that are linked and viewable through the issue. Within the content you can also
    insert quick actions, which will be discussed later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Status of the issue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several states an issue can be in. Of course, it can be open or closed.
    Another aspect of state is the confidentiality of the issue. If there is sensitive
    information, an issue can be marked as confidential. The visibility of the issue
    is then limited to members of the group who have  at least reporter permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Meta information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every issue has an author, and that information is prominently displayed, along
    with the current assignee. Other meta information consists of well-known project
    management data, such as: milestones, due dates, and weight.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to make this clear, based on our example. The *Event Horizon* company
    is about to start the first Scrum sprints. They want to use GitLab issues for
    project management.
  prefs: []
  type: TYPE_NORMAL
- en: 'User1 creates an issue in which he asks which technology we are going to use.
    That could be an example of the first issue, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15f4e0ec-3a38-423e-8379-ae9d54e02410.png)'
  prefs: []
  type: TYPE_IMG
- en: You will see that there is a list with tasks defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'User2 creates an issue regarding which documentation style to use for the project, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12648d2e-0b24-487a-906f-c1816311b7b3.png)'
  prefs: []
  type: TYPE_IMG
- en: Both are valid questions to ask, and to start a discussion about, and we will
    see how this continues when an issue evolves to the next level, a discussion.
    We will talk about this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Discussions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This a very important part of GitLab and is the next step in issue discovery.
    It is possible to give feedback in the form of comments in the context of an issue,
    and also in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Epics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merge requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Snippets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commit diffs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is also possible to create a threaded discussion or to transform a comment
    into one. You can use markdown to format your text and use quick actions (as described
    in the *Quick actions* section in this chapter). The default comment form is shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43e61ef1-6397-4408-aded-2d241c6adcd7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you have set up your GitLab for incoming email, you can respond to emails
    that are sent as comment notification emails. Replying to those will create a
    new comment or discussion item. In the following screenshot, you will find a discussion
    for an issue in the Event Horizon web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d188eba-fdd0-4991-9a1b-02e575f65c46.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As mentioned, it is also possible to add a discussion to an epic, which we
    will discuss later. The following example is the screenshot for adding any discussion
    to an epic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/938bbca0-e766-4528-8adf-a1ff56c9b128.png)'
  prefs: []
  type: TYPE_IMG
- en: Using these discussions, the idea evolves, as does the understanding of it.
  prefs: []
  type: TYPE_NORMAL
- en: Milestones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Milestones can have different functions in a project, but are used in GitLab
    to indicate where one stands in achieving a common goal for which issues and merge
    requests are defined.
  prefs: []
  type: TYPE_NORMAL
- en: A milestone can be used to mark the beginning and the end of an Agile iteration
    or a sprint. It's quite practical to just name the milestone after your sprint
    and then you can associate issues to the milestone to add work.
  prefs: []
  type: TYPE_NORMAL
- en: At GitLab, they are used as one release cycle. For instance, when they go from
    release 11.8 to 11.9, all the work contained in that release will be represented
    by a milestone, and that will be labeled 11.9\. Each piece of work is represented
    in an issue, for instance, the problems you need to solve, the conversation. All
    these issues work together towards one large milestone.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the Event Horizon project, there are three milestones defined: mvp 1, MVP3,
    and mvp2\. You can see them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f2914fb-85fe-49a5-ad44-cfde50b2bfd6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we open a milestone, it has the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/808ba8ad-b21a-4432-9912-caf63a359f3e.png)'
  prefs: []
  type: TYPE_IMG
- en: Project milestones can only be linked to issues and merge requests in the project
    context. You can view a list of milestones by going to Issues and then Milestones.
    Group milestones can be linked with issues and merge requests on the group context,
    which means you can link it to several projects that are part of the group. The
    list of those can be found via the Issues and then Milestones links in the group.
    A general view of all milestones is via the dashboard milestones list, or via
    the top navigation link, Milestones.
  prefs: []
  type: TYPE_NORMAL
- en: Epics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have GitLab EE, you can create epics. An epic is an extensive user story
    that still has to be broken down into a set of smaller user stories. Usually,
    an epic describes a defined piece of functionality or product property, but needs
    to be worked out in more detail before the team can commit to this feature to
    be realized within one sprint. It's like a theme among issues.
  prefs: []
  type: TYPE_NORMAL
- en: For big organizations that work with long-running project management programs,
    there is also the option to have multi-level epics so that you can link and coordinate
    efforts. There is a button (+) for it in the creation form of the epic.
  prefs: []
  type: TYPE_NORMAL
- en: Epics very much resemble issues in that you have the same editing functions
    and state. The same formatting is applicable, and also the same quick actions.
    Maybe more importantly for epics is the option to set due dates. Big projects
    that cover multiple business domains are still more date driven, so we can imagine
    that these fields are more appropriate here then in Agile-drive smaller projects.
  prefs: []
  type: TYPE_NORMAL
- en: From the epic, you can navigate to the linked issues. Also, when issues become
    too big and are misrepresented epics, it is also possible to promote an issue
    to an epic.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the Event Horizon  project, the Product Owner User3 can create an epic
    to track the progress of the two different projects and the issues that were created
    earlier. The following screenshot shows the tracking progress for the projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c80fbee3-6d07-4eb4-b5a5-f32eadfec323.png)'
  prefs: []
  type: TYPE_IMG
- en: The ability to use epics to group issues is necessary for keeping control over
    multiple discussions and issues and projects that together work towards a solution.
  prefs: []
  type: TYPE_NORMAL
- en: Time tracking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this feature, you can track how much time is being spent on issues and
    merge requests. You can also track what was estimated, to see where you stand.
    It is part of GitLab Core.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see that for an issue in the eventmanager
    project some time has been estimated and spent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89c5d5d7-8119-4cbb-b541-7161e9571d50.png)'
  prefs: []
  type: TYPE_IMG
- en: In the body of an issue or merge request, and in comments, you can use quick
    actions to enter the estimated and spent time for the issue. It can only be done
    by team members.
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the following screenshot, you can use `/estimate`, followed by the
    unit of time. If something will take five days and four hours, you would write
    `/estimate 5d 4h` in a comment and, after that, press Comment. There can only
    be one estimate. You can also remove it by using `/remove_estimate`. Here''s the
    screenshot for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c985bf3-f1b3-4dbe-80cb-bcc5c9004668.png)'
  prefs: []
  type: TYPE_IMG
- en: In the same manner, you can record how much time has been spent on the issue.
    Members of the project can use a quick `/spent` action in issues and merge requests
    to add time to a total amount of time that is dedicated to an issue. For example,
    if two hours have been spent, you issue `/spent 2h`, and it will show in the right
    panel. You can even remove time spent by using negative numbers, for instance, `/spend
    -1h`. It won't go below 0, but will reset the number. You can remove the total
    at once with `/remote_time_spent`.
  prefs: []
  type: TYPE_NORMAL
- en: Quick actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very handy feature in GitLab is the quick action. You can use a `/` with certain
    keywords to trigger a command on issues, epics, merge requests, and commits, just
    like you can with something like IRC chat. It is faster than using GitLab's web
    buttons or other controls. Remember to put each *command* on a separate line,
    otherwise it will be parsed incorrectly. Once they are parsed and executed, they
    will be removed from the text and nobody can see them. There is, of course, an
    audit trail for the action executed**.**
  prefs: []
  type: TYPE_NORMAL
- en: 'Some samples of quick action are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/todo`: Add a todo item from the comment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/done`: Mark the todo as done'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/close`: Same as clicking the close button'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/assign me` or `@someone else`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/milestone %milestone`: Set a milestone from the comment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/estimate <1w 3d 1h 10m>`: Add a time estimation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/due <in 1 day>`: Set a due date'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/approve`: Approve a merge request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Special quick action for commit messages: `/tag v1.5` – Tag immediately a commit
    with a message of choice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find all quick actions here: [https://docs.gitlab.com/ee/user/project/quick_actions.html](https://docs.gitlab.com/ee/user/project/quick_actions.html)'
  prefs: []
  type: TYPE_NORMAL
- en: The Project Issue board
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hidden in GitLab is a very nice project management feature. It is called the
    *Project Issue board*. It can be used to implement a workflow by using visualization
    and can help to plan and organize. It does not enforce one way of working. You
    have to organize and form your own process. The boards are heavily dependent on
    labels, which are used to group issues into lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go to the issues in the left navigation bar, you will find the option
    Boards. By default, you get a board called Development that offers basic lanes
    such as Open, To Do, Doing, and Closed. You can drag issues from lane to lane,
    indicating a change in state. For instance, if an issue is done, you drag it to
    Closed. What happens is that the issue will automatically get the label Closed.
    The following screenshot is an example of the project issue board for the eventmanager
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6698305c-19b9-4ee4-b610-c10455e10b26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you use GitLab Enterprise Edition, you can even have multiple issue boards,
    which can mean several things:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A board can be shared by multiple teams: Group Issue boards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each team can have its own boards.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are several views for projects, based on the scope of the board (milestone,
    label, assignee and weight).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see how to create a new issue board by
    clicking on the drop-down list saying Development. The default board is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f2a5103-5893-4323-b023-a104de6a96c4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you click on Create new board you will be presented with a form to enter
    the name of the new board, and the scope of the board. As with a label, it is
    just an attribute of an issue that is used to group or aggregate. Let''s choose
    to focus on milestones, and choose the milestone MVP3, which is the minimum viable
    product coming out of sprint 3, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88732478-0e27-4780-8616-ace7f4e47004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After creation, you will be presented with an issue board including the issues
    that are already assigned to a milestone. You can add issues (which then are coupled
    to the milestone) with the Add Issues, which is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f75284f7-21b1-4791-8a95-babcf83682e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Issue boards can function as information radiators for teams, it organizes issues
    in the way you want and can be the subject of conversation for a team meeting.
  prefs: []
  type: TYPE_NORMAL
- en: Todos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A planning feature that is useful for the individual user is *todo*. Notification
    emails can pile up in your inbox and get messy. An easy-to-use todo list, where
    you can view your tasks sorted chronologically, is more focused. You will find
    them at the top of your navigation bar, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c77e7e73-c76e-4251-a06d-092f2930c9f8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you have clicked the todo item, you will see a list of your todos with
    the option to sort in different fields, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b12f422a-90eb-4e86-8b1c-794789e65dfa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following items could trigger a todo item:'
  prefs: []
  type: TYPE_NORMAL
- en: An issue or merge request is assigned to you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being `@mentioned` in an issue, merge request, commit, or epic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A failed job in one of your project CI/CD pipelines that has been marked *not
    allowed to fail*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When in an automatic pipeline, a merge request has a conflict.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevOps phase – create it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the project has been planned by creating issues, milestones and so
    on, it is time to really start building. The next phase is *Create*, and GitLab
    provides several tools to help you with this. Before you start building, you should
    make sure your project and group structure is adequate for cooperation.
  prefs: []
  type: TYPE_NORMAL
- en: Projects and groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *Event Horizon* company has created two groups in GitLab. One group is
    called it and another Marketing, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16a8f1ba-2ad6-4c35-a5fd-36399e17cb81.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have created two separate projects in this context. The first one is called
    eventmanager, which will hold the source code for the technical solution. You
    can create this project by clicking on New Project if this is your first project,
    or click on the + icon in the top navigation bar. The form to create a new project
    appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78893e6f-c89e-4b23-9e6f-511927698361.png)'
  prefs: []
  type: TYPE_IMG
- en: The title of the project is `eventmanager`, and it will also appear in the URL.
    Take a good look at the first part of the URL. This is the namespace that defaults
    to your own, but we want this project to be in the it group. When you do that,
    you will notice that visibility is automatically set to Private. This is because
    the group *it* has this as default.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we want this project to be accompanied by a README, so we need to choose
    to automatically create it. Don't worry about what the project will look like,
    we will iterate on it in the sprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, there is a second project called eventmanager-documentation, which will
    consist of the documentation. We will use GitLab pages as a technology to build
    our user documentation, and will choose Pages/Plain HTML as a template. This is
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/769af59f-3e7c-4393-ab1f-47055da684e1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You have to enter the Project name and Project slug and determine the visibility,
    as per the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12daa600-92cf-4ef9-9831-a50e203f0002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click on projects you will see a list of two projects, as shown in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16e55002-fa0a-4280-9b2b-a7f79d5b6887.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we have our project and group structure ready, let's deal with other features
    that promote cooperation.
  prefs: []
  type: TYPE_NORMAL
- en: Snippets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have worked with GitHub as a developer, you will have seen *gists* before.
    These are little pieces of code that are usable for more than one goal. Often
    they could exist in several code repositories, but they are available as gists
    to be reused. In GitLab this concept is known as *snippets*. They are also used
    as examples to be discussed about, and so on. The following example is a screenshot
    of a new snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/63280b2c-6bb3-4fcb-b259-8b9faf27b99d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can create snippets on a personal and project level. They can be made public,
    and there is even an option to embed them in your own site, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac8e612a-2dd6-47e7-8a44-1cc70ed8be25.png)'
  prefs: []
  type: TYPE_IMG
- en: Snippets can be used to share information, and using them could help to fulfill
    the requirement for the platform to enhance collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: Web IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As of GitLab 10.4, an enhanced web editor is available in GitLab that gives
    you the ability to work on code online from the web. It offers many different
    features, including syntax highlighting for the most common languages (PHP, Ruby,
    Shell, Python, Java, C) and markup languages (XML, Markdown, and HTML). It is
    based on the Monaco editor which you can find here: [https://microsoft.github.io/monaco-editor/](https://microsoft.github.io/monaco-editor/).'
  prefs: []
  type: TYPE_NORMAL
- en: The Event Horizon company can also develop their software in the Web IDE. It,
    of course, has support for Ruby, the language in which GitLab is mostly written.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you will see a file from the eventmanager project
    shown in the web IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd912d94-4f5c-44be-a913-fc7fba03bd12.png)'
  prefs: []
  type: TYPE_IMG
- en: Use of this tool would also enhance collaboration within Event Horizon.
  prefs: []
  type: TYPE_NORMAL
- en: Wiki
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we have created a separate project to provide documentation for our new
    software product, GitLab also has a system for creating documentation by default.
    It is the Wiki feature. Every project can easily enable this feature and you will
    then have a full-blown wiki system available.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you navigate to the Wiki through the left navigation bar in your project
    you will be presented with the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc78b5a8-14f0-4570-b4a0-87cdf7b6310f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you create a new wiki, you will have to provide a title, the markup language
    used, and then you can start adding content. As all the information is itself
    saved in an accompanying Git repository, you can give the Commit message, because
    saving the page is creating a new commit, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be27fe4a-7785-48ba-9242-2d4f5f94108a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once created, you will see the page if you click on Wiki the next time. You
    can now create more pages (even a page hierarchy if you want) and you can view
    the page history (everything is versioned), as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1a91978-c93e-4073-92fa-71d87511502e.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, Wiki is another feature that enhances collaboration between
    employees.
  prefs: []
  type: TYPE_NORMAL
- en: Protected branches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because in Git it is possible to rewrite the entire history, GitLab has some
    mechanisms built in to help mitigate this risk. You can use *protected branches*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Protected branches have the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Before GitLab 11.9 you could not create a protected branch, only *Maintainers* could
    (as of 11.9 Developers can create them).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only Maintainers can push directly to a protected branch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is prohibited to use force push to a protected branch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A protected branch cannot be deleted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The only way to accept changes into a protected branch is to use merge requests.
    By default, the master branch is a protected branch. The following example is
    the screenshot for the protected branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66b43538-9e8e-4168-b388-7f460319e0b8.png)'
  prefs: []
  type: TYPE_IMG
- en: Using a protected branch forces the use of code reviews, which is a requirement
    for the eventmanager project.
  prefs: []
  type: TYPE_NORMAL
- en: Merge requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, the first version of eventmanager is almost ready. User1 has uploaded the
    latest changes to branch MVP1, and is ready to create a merge request, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fbf0fb17-6e49-4f26-b06d-48aed53299de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see the usage of quick actions by specifying `Closes #2, #3` in the
    Description field.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you scroll down, you will see there is a section to view in which changes
    are introduced to the master branch when you accept this merge request. It shows
    you how many changes (6) are in our example, which files are changed, and what
    was changed. This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e2520de-1d1b-46b9-8222-832d5e61d423.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see User3 has been added as merge request approver, so he or she has
    to review the changes, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7cb0024-8448-4b14-a3b6-45a2f43c7789.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At the bottom of the screen, you can see which branches will be merged by this
    merge request, and you can specify to delete the originating branch and/or squash
    the changes (which means all changes are placed under one commit). This is shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd450b1b-deef-4ecf-858f-a7b7cd18b994.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If User3 logs in, he will have a todo item for reviewing this merge request.
    As an example, let''s pretend User3 did a review and placed some comments. Let''s
    look at part of the `index.erb` file that is used in the eventmanager app to display
    a message saying that someone is invited to an event. You can find the file in
    the code examples ([https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter09/eventmanager](https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter09/eventmanager)).
    Here''s the snippet of code that is picked by the reviewer as troublesome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'User3 thinks the text `You are invited to my event on December 15!` is too
    specific. Better to keep the text simple. He wants to suggest changing the text
    to `You are invited to my event!`. He can add a suggestion using a quick action
    in markdown format in the review comment, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/773aa9c6-8a8b-40f4-842c-e979e4867a41.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After saving the comment, it looks like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0075c5aa-a348-46d8-bb42-b3bf5e2b80cb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'User3 can finish his review now. User1 gets a notification that the merge request
    has been reviewed. As he logs in and navigates to the review comment in the merge
    request, he will discover the suggestion made by User3 with a button to apply
    the suggestion. The comment will automatically be marked as resolved, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d930d16-30e2-4617-88fa-c4943a7ff468.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is another comment by User3 about an entry in the `attendees.yml` file,
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There are no sample entries in `attendees.yml` with a `YES`, so Users3 suggests
    to change one entry, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5edcaf02-bebb-4548-8e2b-629c3acfafd8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Unfortunately, the customer who attends the demo at the end of the sprint was
    not informed about the possibility to have an entry with `No`. There are also
    no real tests defined, so User1 decides to push this comment as an issue for the
    next iteration of the product, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f838d90b-5466-4f1d-a392-6cabf6b0ce70.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When all discussion points are resolved, the merge request can be approved
    by User3, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb945dfa-49dc-4f8d-aa5f-6ac0aeadd115.png)'
  prefs: []
  type: TYPE_IMG
- en: The merge request feature is one of the most important reasons to use GitLab.
    You can merge code or text in a project and cooperate on it.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps phase – verify your product
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next phase in the DevOps life cycle is *Verify*. After building your product
    in the create phase, you need to verify whether the product meets the requirements,
    is secure, and that the quality in general is OK. This can all be done from within
    GitLab, by using the **continuous integration** (**CI**) features. In the following
    sections, we will discuss a number of components of the CI pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Code Quality reports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A nice feature that verifies code quality is a quality scan with CI/CD in GitLab.
    It makes use of the open source and free Code Climate engines ([https://codeclimate.com/](https://codeclimate.com/)).
    It is embedded in a special Docker container that you can run within your GitLab
    runner. The following code is an example of a `.gitlab-ci.yml` file that runs
    such a scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When the jobs runs, the following logging is produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After downloading the Docker container, it will start scanning the code. When
    the scanning is complete a report is generated, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To view the report, download the artifact from the right, where there are links
    to it. The following example shows the screenshot of the Job artifacts tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/883e46ea-37c0-49e2-ad72-68a0d22681ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you open the report with an editor to properly format it, it will show warnings
    or high or critical findings. In the case of the eventmanager project, it found
    an unused variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Please notice the `"remediation_points": 50000,` entry, which scores the finding.
    This is different depending on the category finding, and can be used to compare
    total scores of several scans, showing you the progress (or decline) of total
    quality.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There follows the block of code that was mentioned in the report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can see that in the first line there is a `letter` variable that is unused
    in the loop. If we change `letter` to `_letter` the test should not report it
    as a warning anymore. Unused variables are reported as a warning, you can suppress
    the warning with an underscore.
  prefs: []
  type: TYPE_NORMAL
- en: After the next run of the CI pipeline, the code quality scan will show that
    nothing was found, the report will be empty.
  prefs: []
  type: TYPE_NORMAL
- en: You can use Code Quality reports as well in merge requests. It can run before
    merge and you can compare remediation points. If there are likely to be critical
    findings, the job would show as failed and in red. Now that we have verified that
    the application is of minimum quality, we also want to verify if the app or website
    is OK for users. We can build review versions on which to perform manual tests.
    This is our next section.
  prefs: []
  type: TYPE_NORMAL
- en: Review apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ultimate verification of your software product is to run all tests available
    and even mimic production. In GitLab, this can be accomplished by using GitLab
    CI and GitLab runners. For this to work, we will show an example using the eventmanager
    documentation site. One of the requirements of the project is, of course, creating
    documentation. We also created a separate project for it called **eventmanager-documentation**.
    There are already web pages present, so let''s automate the review process (also
    one of the requirements: more automation). We are going to use an Amazon S3 bucket,
    which has been enabled to act as a webserver (you can find information about how
    to configure them here: [https://docs.aws.amazon.com/AmazonS3/latest/dev/HowDoIWebsiteConfiguration.html](https://docs.aws.amazon.com/AmazonS3/latest/dev/HowDoIWebsiteConfiguration.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To upload files to a S3 bucket, you need to authenticate with AWS. We can add
    secret variables to the project that contain the credentials for AWS that are
    needed. You can find them under Project | Settings | CI/CD | Environment variables, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd725037-c403-46e1-9f8d-ec61365741d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` variables are present,
    you can execute aws-cli actions within GitLab CI/CD pipelines. The `.gitlab-ci.yml`
    file that is used to deploy review apps is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The job is called review apps, as seen on the first line. Then, after that,
    a variable is declared, the S3 bucket name. Next is the Docker image name that
    is used, which in this case is an image with Python installed, so we can make
    use of the Python-based AWS CLI utility that is installed in the script section.
    The last line contains the AWS CLI command to copy a file to an S3 bucket, and
    it authenticates through the environment variables that we have set.
  prefs: []
  type: TYPE_NORMAL
- en: After saving this file, the job will run, and if all goes well the HTML files
    are uploaded to your bucket. If you follow the job log you will see the following.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it gets the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then it clones the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It installs the Amazon CLI tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then it uploads the HTML files to the S3 bucket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When the job succeeds, the review environment will be created in GitLab. You
    can click on the review link, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b45f1a72-2652-40a5-b863-a0c8f53c837b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next page will show a list of deployments in the review environment, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e9e71e5-9e53-49c7-900e-642b50867e52.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can add the URL to the environment manually via edit, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2facc908-2686-4f3b-bb59-769e2f5d49fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After adding the URL to the environment, a button View deployment is available,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/295c2f85-6e0d-45ce-80bb-5e334070b4a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click View deployment, you will be taken to the review app, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/878655ac-e1b1-4918-bda7-3371d0d2336d.png)'
  prefs: []
  type: TYPE_IMG
- en: As of version 12.0 of GitLab, you will have a 'review button' next to 'view
    app' in the pipeline view. It will then run the review app with a little form
    in the corner where you can enter feedback. This input will be directly inserted
    into the issue.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f9d8974-3e6c-4f2e-948a-6aac995877a9.png)'
  prefs: []
  type: TYPE_IMG
- en: So, to verify our project we have used Code Quality reports for the eventmanager
    code. We learned that, initially, there was a warning that a variable was not
    used. We recommended a fix and we ran the pipeline again, and the warning went.
  prefs: []
  type: TYPE_NORMAL
- en: We have demonstrated the use of a review app for the documentation project.
    Using this review app we could verify that our initial requirements were met.
  prefs: []
  type: TYPE_NORMAL
- en: Both methods of automation implemented in your pipeline will greatly enhance
    your Agility and DevOps capabilities. When you find errors, you can correct them
    and run the pipeline again.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps phase – package it for use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitLab use Docker containers in their products for several purposes. To store
    container images that were custom built for projects they also added Docker Container
    Registry functionality to GitLab. By using this, you avoid having to store images
    in a remote location that is maybe not safe enough. The container registry is
    the subject of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: GitLab container registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have the container registry enabled in GitLab, you can store Docker
    images that are built in your CI/CD process. To enable this GitLab feature, you
    have to reconfigure your GitLab instance and enable the registry functionality**.** When
    enabled, there will be a registry menu item on the left for each project. If you
    click on it, you can view the contents of the registry and instructions on how
    to use it, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c89375d3-ed66-4fe1-a27d-155bee19a4f7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To store images in it for later use you have to edit your CI/CD configuration
    file in the root of your project. Here''s an example for the eventmanager project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To summarize the file, it defines a build job. On the second line, the image
    to use is defined as `docker:stable`. Because this image will build a docker container
    itself, it uses the `docker:dind` service, which enables Docker in Docker functionality.
    Then, in the variables section, there are two Docker variables defined: the Docker
    host to connect to (which is the docker engine and it will build a container itself)
    and the Docker storage driver to use, which is overlay2\. The stage defined is
    build. Then, in the scripts section, the actual script is given, which is really
    a basic Docker build, which is preceded by a login to the GitLab Docker registry
    and followed by a push to that location. You can see variables that start with
    `$CI_REGISTRY`. These are predefined variables available within GitLab to use
    and make use of one time tokens.'
  prefs: []
  type: TYPE_NORMAL
- en: When you save this file in the Web IDE, or push it to GitLab, the new pipeline
    will run immediately. If it does not run, or says there is no runner available,
    check if your runner is running in privileged mode. It needs this to run `docker:dind`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the image is finished, it is pushed to the GitLab registry with the latest
    tag. If this is successful the job has succeeded and will be green, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify afterwards that the container is present in the registry by
    navigating to the registry page of your project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c2bf385-be47-46b2-a1ef-f0292a65422e.png)'
  prefs: []
  type: TYPE_IMG
- en: The registry is a secure way to store image artifacts from the CI/CD pipeline.
    In the DevOps pipeline, it is part of the Package phase.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has tried to explain the GitLab flow using an example. Going through
    the first phases of the model with the eventmanager example demonstrates why GitLab
    is a tool that has sprung from the Agile revolution. From idea to implementation,
    every step can be automated and is very customizable. In the next chapter, we
    will continue the pipeline by looking at the Release and Configure phases.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the first phase of the DevOps cycle?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the most important unit of information in GitLab?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it possible to turn comments into a discussion?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you give an estimate of four days for an issue?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you enforce a review mechanism in GitLab?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What kind of setting does a GitLab Runner need to run a Code Quality scan?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you enable the link to a deployed environment?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do you need to do to enable the Registry link in a project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Comprehensive Ruby Programming* by *Jordan Hudgens*: [https://www.packtpub.com/application-development/comprehensive-ruby-programming](https://www.packtpub.com/application-development/comprehensive-ruby-programming)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Learn Docker - Fundamentals of Docker 18.x* by *Gabriel N. Schenker*: [https://www.packtpub.com/networking-and-servers/learn-docker-fundamentals-docker-18x](https://www.packtpub.com/networking-and-servers/learn-docker-fundamentals-docker-18x)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*AWS Automation Cookbook* by *Nikit Swaraj*: [https://www.packtpub.com/virtualization-and-cloud/aws-automation-cookbook](https://www.packtpub.com/virtualization-and-cloud/aws-automation-cookbook)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Effective DevOps with AWS - Second Edition* by *Yogesh Raheja*, *Giuseppe
    Borgese*, and *Nathaniel Felsen*: [https://www.packtpub.com/virtualization-and-cloud/effective-devops-aws-second-edition](https://www.packtpub.com/virtualization-and-cloud/effective-devops-aws-second-edition)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
