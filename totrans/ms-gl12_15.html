<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Monitoring with Prometheus</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we will explore how to monitor using the Prometheus time series, and we will also run some automated security tests. The built-in security tests in GitLab are only available when running with a GitLab Ultimate license on-premises or with a Gold subscription on <a href="http://gitlab.com">http://gitlab.com</a>.</p>
<p>In this chapter, we will cover following topics:</p>
<ul>
<li><span>Setting up Prometheus</span></li>
<li><span>Customizing monitoring</span></li>
<li><span>The static analysis of security vulnerabilities</span></li>
<li><strong><span>Dynamic Application Security Testing</span></strong> <span>(</span><strong><span>DAST</span></strong><span>)</span></li>
<li><span>Dependency checking</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="mce-root">To be able to manage Omnibus installs, there is one central configuration file required, called <kbd>gitlab.rb</kbd>. You need to create this file or copy an example. There is a template available at <a href="https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/files/gitlab-config-template/gitlab.rb.template">https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/files/gitlab-config-template/gitlab.rb.template</a>. This file is not updated after upgrades. Throughout this chapter, we will quote and discuss elements of this file.</p>
<p><span>To follow along with the instructions in this chapter, please download the Git repository with examples, available at GitHub:</span><span> <a href="https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter12" target="_blank">https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter12</a><a href="https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter12" target="_blank">.</a></span></p>
<p>You will also need to have Python installed to create the Python sample exporter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up Prometheus</h1>
                </header>
            
            <article>
                
<p class="mce-root">Prometheus is an open source monitoring system inspired by Borgmon, Google's production monitoring system. Since it was introduced in 2012, the project has built up an active community and has already been used by many companies. It is an example of a TSDB, a time-series monitoring database. This means that time is a deliberate X-axis in all of your measurements. Every new entry is an insert and not an update of a data-row.</p>
<p>This is best visualized in a table:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Time(x)</strong></td>
<td><strong>Key </strong></td>
<td><strong>Value</strong></td>
</tr>
<tr>
<td>12.01.33</td>
<td>ping-latency</td>
<td>0.234556</td>
</tr>
<tr>
<td>12.03.33</td>
<td>ping-latency</td>
<td>0.223344</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root">The two main advantages of this approach are as follows:</p>
<ul>
<li class="mce-root"><strong>Scalability</strong>: These databases are tuned to ingest data and do so very efficiently.</li>
<li class="mce-root"><strong>Usability</strong>: They provide all kinds of tools and functions, for example, data retention and continuous queries.</li>
</ul>
<p class="mce-root">Whereas most monitoring systems focus on measuring external system behaviors through health checks, Prometheus emphasizes measuring internal system behaviors by requesting metrics from the software itself. With Prometheus, you can set up monitoring dynamically, making it a valuable tool for gaining insight into distributed setups, such as software on a Kubernetes cluster.</p>
<p class="mce-root">The Prometheus project provides client libraries<strong> </strong>that make it easier to export metrics from software. These libraries enable you to integrate monitoring as part of your software. It opens a port to metrics inside your application, so to speak.</p>
<div>
<p><span>You can also use functions and objects from client libraries to expose the metrics inside your application.</span></p>
</div>
<p class="mce-root">Another method is to run separate smaller programs that gather data that will be scraped by the Prometheus server. Some officially endorsed exporters are available in the Prometheus group on GitHub: <a href="https://github.com/prometheus">https://github.com/prometheus</a>.</p>
<p class="mce-root">GitLab is packaged with both methods. When enabled, it can expose metrics from within GitLab itself, but the omnibus package can also deliver extra exporter instances that are able to monitor a number of components. The monitoring architecture is as follows (as you can see, the functionality runs on the GitLab application server):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f570a655-b4e2-4232-86a6-ae6470d40845.png" style="width:45.75em;height:34.00em;"/></p>
<p>You can see several exporters in the image; let's go through them:</p>
<ul>
<li class="mce-root">The (GitLab) Metrics Exporter: GitLab has incorporated the client functions into itself and can expose metrics if the setting is enabled. You can find this feature<span> in the <strong>Admin |</strong></span> <span class="packt_screen">Settings</span> <span>|</span> <span class="packt_screen">Metrics and profiling</span> <span>|</span> <span class="packt_screen">Metrics Prometheus</span><span>, as shown in the following screenshot:</span></li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="assets/eb1415e4-1073-4f57-9d01-dd146f279b8f.png" style="width:54.92em;height:13.58em;"/></p>
<p class="mce-root" style="padding-left: 60px">This works by allowing you to view the exporters' output on <kbd>http://{your gitlab url}}/-/metrics?token=something</kbd>. An example is given on the Health Check page via <span class="packt_screen">Monitoring</span> | <span class="packt_screen">Health check</span><span>, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4cd04fa5-9c88-4dcc-8155-a9e8d0bb13ea.png" style="width:37.25em;height:26.42em;"/></p>
<p class="mce-root" style="padding-left: 60px">Make sure that you append the token to the request otherwise you won't see any data. An example output shown when visiting the URL is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/261b4612-c78d-4f46-8b9f-59fab5a8232d.png"/></p>
<ul>
<li>The Redis Exporter: This is an external program you can find at <a href="https://github.com/oliver006/redis_exporter/blob/master/README.md#whats-exported">https://github.com/oliver006/redis_exporter/blob/master/README.md#whats-exported</a><span>. It is a Go binary that exposes metrics about Redis, the in-memory database and cache that GitLab uses for storing background job queues, and session state and UI caching.</span></li>
</ul>
<p style="padding-left: 60px">When used together with Grafana, dashboards can be quickly set up<span>, as shown in the following screenshot</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9b1797ed-1f0f-43da-b37d-7e096cb02a68.png"/></p>
<ul>
<li class="mce-root">The Postgres Exporter: Again, this is a Go binary and external project available at: <a href="https://github.com/wrouesnel/postgres_exporter">https://github.com/wrouesnel/postgres_exporter</a><span>.</span></li>
</ul>
<ul>
<li class="mce-root">The GitLab Monitor: This exporter is a bit different in that it is built-in with Ruby and exposes metrics with the Sinatra web server gem. The project page is <a href="https://gitlab.com/gitlab-org/gitlab-monitor">https://gitlab.com/gitlab-org/gitlab-monitor</a><span>.</span></li>
</ul>
<p class="mce-root" style="padding-left: 60px">When you query the GitLab Monitor, you can provide different parameters, which represent the kind of metric you want to scrape; they include the following:</p>
<ol>
<li style="list-style-type: none">
<ol>
<li style="list-style-type: none">
<ul>
<li><strong>Database</strong>: Provides information about tables, rows, and CI build</li>
<li><strong>Git</strong>: Provides information about Git pulls</li>
<li><strong>Process</strong>: Provides information about CPU, process count, sidekiq stats, and more</li>
</ul>
</li>
</ol>
</li>
</ol>
<ul>
<li>The Node Exporter: This is perhaps one of the best-known exporters for Prometheus. It consists of a lot of basic metrics for an application node. Again, this exporter is written in Go and is available at <a href="https://github.com/prometheus/node_exporter">https://github.com/prometheus/node_exporter</a>.</li>
<li class="mce-root">To enable the built-in Prometheus server on the GitLab application server, edit the <kbd>/etc/gitlab/gitlab.rb</kbd> <span>file. Search for</span> <kbd>prometheus['enable']</kbd><span>, uncomment it, and set it to</span> <kbd>true</kbd><span>. There are several other options, but just enabling it will already deliver you a working instance.</span></li>
</ul>
<p style="padding-left: 60px">The part of the <kbd>gitlab.rb</kbd> file you should change is as follows:</p>
<pre class="mce-root" style="padding-left: 60px">################################################################################<br/> ## Prometheus<br/> ##! Docs: https://docs.gitlab.com/ce/administration/monitoring/prometheus/<br/> ###############################################################################<br/> prometheus['enable'] = true<br/> # prometheus['monitor_kubernetes'] = true<br/> # prometheus['username'] = 'gitlab-prometheus'<br/> # prometheus['uid'] = nil<br/> # prometheus['gid'] = nil<br/><br/></pre>
<p class="mce-root" style="padding-left: 60px">After changing <kbd>gitlab.rb</kbd>, you should run a reconfiguration to activate the changes. You will see messages explaining that certain exporters and the Prometheus server have been started.</p>
<p class="mce-root" style="padding-left: 60px">You can navigate to the Prometheus console by going to the address configured in <kbd>prometheus['listen_address']</kbd>. You will be presented with a query interface. If you click the drop-down list, you should see a list of metrics that can be queried, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/54af35bc-dbc6-4de2-a8e5-963c48a55fb9.png"/></p>
<p class="mce-root" style="padding-left: 60px">Once you have chosen a metric, it will display all values it has recorded in the database (including data that was actively scraped from Prometheus exporters). In this case, the chose view mode was probably <span class="packt_screen">Console</span>. You can also view the data as a graph by clicking on <span class="packt_screen">Graph</span><span>, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/13390e57-6aa6-4383-88c2-40120dde5c69.png" style="width:29.83em;height:10.42em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using an external Prometheus host</h1>
                </header>
            
            <article>
                
<p class="mce-root">If you are not using the omnibus package to manage GitLab or insist on using an external Prometheus server, the picture will be a bit different. You should be aware that the default security model that Prometheus uses is rather simple; it assumes that anyone can view the stored time series data, and the server provides no authentication, authorization, or encryption. If you need these features, you should prepare a reverse proxy in front of the Prometheus server to help. More information about this can be found at <a href="https://prometheus.io/docs/operating/security/">https://prometheus.io/docs/operating/security/</a>.</p>
<p>The monitoring architecture for this situation is shown in the following diagram (as you can see, some functionality is running on a separate server):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/847051bd-70e3-4b4d-a840-2d4aec4d79fd.png" style="width:45.75em;height:35.92em;"/></p>
<p class="mce-root">Now we have to make sure we have an external Prometheus host configured that is ready to scrape the data. As we've previously mentioned, Prometheus is a single Go binary. To specify which configuration file to load, use the <kbd>--config.file</kbd> flag. This configuration file has to have the YAML format. How a single Prometheus server monitors the GitLab Metrics Exporter embedded in GitLab is shown in the following <span><kbd>prometheus.yml</kbd> example:</span></p>
<pre class="mce-root"><br/> - job_name: 'git-metrics'<br/> params:<br/> token: [ gitlab_health_check_access_token ]<br/> metrics_path: /-/metrics<br/> scrape_interval: 5s<br/> scheme: https<br/> tls_config:<br/> insecure_skip_verify: true<br/> file_sd_configs:<br/> - files:<br/> - /etc/prometheus/sd/gitlab_metrics_exporter_sd.yml<br/><br/></pre>
<p class="mce-root">The <kbd>gitlab_metrics_exporter_sd.yml</kbd> file contains the following code:</p>
<pre class="mce-root"><br/> - targets: ['gitlab.joustie.nl']<br/> labels:<br/> app: gitlab</pre>
<p class="mce-root">If you put both files in <kbd>/tmp</kbd>, or elsewhere, and run Prometheus as a Docker container (as seen in the following example), you should have an external Prometheus ready for action. Of course, you can also install it from source and run it on a dedicated server somewhere else if preferred.</p>
<pre class="mce-root"><strong> </strong><strong>docker run -it --name my-prometheus \</strong><br/><strong> -v /tmp:/etc/prometheus \</strong><br/><strong> --publish 9090:9090 \</strong><br/><strong> prom/prometheus</strong></pre>
<p>You now know how Prometheus runs on the GitLab application server itself, as well as on a separate server.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enabling the external dashboard link</h1>
                </header>
            
            <article>
                
<p>Since GitLab 12.0 it also possible to enable a link to an external dashboard from inside of GitLab.</p>
<ol>
<li class="mce-root">Go to <span class="packt_screen">Settings</span> | <span class="packt_screen">Operations</span> and navigate to <span class="packt_screen">External dashboard</span></li>
<li>Insert the location to your external dashboard and click on <span class="packt_screen">Save Changes</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fdc121f6-4512-4700-80dc-c0ac29f13d41.png" style="width:45.92em;height:22.42em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Customizing monitoring</h1>
                </header>
            
            <article>
                
<p class="mce-root">There are several ways to create custom monitoring scripts that will supply time series data to your Prometheus server. As noted earlier in the <em>Setting up Prometheus</em> section,<strong> </strong>there are many client libraries available, such as <a href="https://github.com/prometheus/client_python">https://github.com/prometheus/client_python</a>.</p>
<p>In the following screenshot, you can see that the preceding project is not very big but does have stars on GitHub.</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b6a6c593-5b1e-4777-8060-5b123cb8eb66.png" style="width:55.33em;height:6.25em;"/></p>
<p class="mce-root">To use this library, install it using pip (a Python package manager for modules) with the following code:</p>
<pre class="mce-root"><strong> $ pip install prometheus_client</strong><br/><strong> Collecting prometheus_client</strong><br/><strong> matplotlib 1.3.1 requires nose, which is not installed.</strong><br/><strong> matplotlib 1.3.1 requires tornado, which is not installed.</strong><br/><strong> Installing collected packages: prometheus-client</strong><br/><strong> Successfully installed prometheus-client-0.6.0</strong></pre>
<p class="mce-root">You can also create a simple exporter by running the following code from a Python interpreter or via a file:</p>
<pre class="mce-root"> from prometheus_client import start_http_server, Summary<br/> import random<br/> import time<br/># Create a metric to track time spent and requests made.<br/> REQUEST_TIME = Summary('request_processing_seconds', 'Time spent processing request')<br/># Decorate function with metric.<br/> @REQUEST_TIME.time()<br/> def process_request(t):<br/> """A dummy function that takes some time."""<br/> time.sleep(t)<br/>if __name__ == '__main__':<br/> # Start up the server to expose the metrics.<br/> start_http_server(8000)<br/> # Generate some requests.<br/> while True:<br/> process_request(random.random())<br/><br/></pre>
<p class="mce-root">The exporter will start on <kbd>localhost</kbd>, on port 8000, and the following page will appear when called:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/da943227-3d2d-4991-98b3-8c5e657809f9.png"/></p>
<p class="mce-root">You can add this exporter to your Prometheus server by adding the following code to <kbd>prometheus.yml</kbd> and restarting Prometheus with <kbd>gitlab-ctl restart prometheus</kbd> on an omnibus-installed GitLab application server, or you can use <kbd>service prometheus restart</kbd> on an externally-installed Prometheus:</p>
<pre class="mce-root"><span>job_name: 'python_gitlab'<br/></span><span># Override the global default and scrape targets from this job every 5 seconds.<br/>scrape_interval: 5s<br/>static_configs:- <br/>targets: ['localhost:</span>8000<span>']</span></pre>
<p>You now have the option to modify your own Python application to report metrics, or you can create Python code that gathers metrics from your system. For instance, you may want to parse a log file for certain patterns and accumulate the relevant metrics.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The static analysis of security vulnerabilities</h1>
                </header>
            
            <article>
                
<p class="mce-root"><strong>Static Application Security Testing</strong> (<strong>SAST</strong>) is used to analyze source code or binaries and to detect holes or weak points in security. When automated, this contributes to making your DevOps methodology resemble DevSecOps, where security testing and awareness is part of the DevOps life cycle.</p>
<p class="mce-root">GitLab, in its Ultimate license model, provides automated testing as part of the development of your application.</p>
<p>Currently, the following languages and frameworks are supported:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<thead>
<tr>
<th>Language/Framework</th>
<th>Scan tool</th>
</tr>
</thead>
<tbody>
<tr>
<td>.NET</td>
<td>Security Code Scan</td>
</tr>
<tr>
<td>C/C++</td>
<td>Flawfinder</td>
</tr>
<tr>
<td>Go</td>
<td>gosec</td>
</tr>
<tr>
<td>Groovy (Gradle and Grail)</td>
<td>find-sec-bugs</td>
</tr>
<tr>
<td>Java (Maven and Gradle) </td>
<td>find-sec-bugs</td>
</tr>
<tr>
<td>JavaScript</td>
<td>ESLint security plugin</td>
</tr>
<tr>
<td>Node.js</td>
<td>NodeJsScan</td>
</tr>
<tr>
<td>PHP</td>
<td>phpcs-security-audit</td>
</tr>
<tr>
<td>Python</td>
<td>bandit</td>
</tr>
<tr>
<td>Ruby on Rails</td>
<td>brakeman</td>
</tr>
<tr>
<td>Scala (sbt)</td>
<td>find-sec-bugs</td>
</tr>
<tr>
<td>Typescript</td>
<td>TSLint Config Security</td>
</tr>
</tbody>
</table>
<p> </p>
<p>First, you need GitLab Runner with a Docker-in-Docker executor.</p>
<div>
<p><span>This is a normal Docker executor, but it runs in privileged mode. This means it can run its own Docker daemon and therefore run containers itself.</span></p>
<p><span>You enable this functionality by changing the GitLab Runner configuration file (<kbd>config.toml</kbd>), making sure it has <kbd>privileged = true</kbd>. After changing this, restart the runner as follows:</span></p>
</div>
<pre>[[runners]]<br/>executor = "docker"<br/>[runners.docker]<br/>privileged = true</pre>
<p class="mce-root">Secondly, you need a specific <kbd>.gitlab-ci.yml</kbd> in your GitLab project folder to make the actual coupling, as shown in the following snippet:</p>
<pre class="mce-root">sast:<br/> image: docker:stable<br/> variables:<br/> DOCKER_DRIVER: overlay2<br/> allow_failure: true<br/> services:<br/> - docker:stable-dind<br/> script:<br/> - export SP_VERSION=$(echo "$CI_SERVER_VERSION" | sed 's/^\([0-9]*\)\.\([0-9]*\).*/\1-\2-stable/')<br/> - docker run<br/> --env SAST_CONFIDENCE_LEVEL="${SAST_CONFIDENCE_LEVEL:-3}"<br/> --volume "$PWD:/code"<br/> --volume /var/run/docker.sock:/var/run/docker.sock<br/> "registry.gitlab.com/gitlab-org/security-products/sast:$SP_VERSION" /app/bin/run /code<br/> artifacts:<br/> reports:<br/> sast: gl-sast-report.json</pre>
<p class="mce-root">As an example, we downloaded the following code from <a href="https://github.com/CSPF-Founder/JavaVulnerableLab">https://github.com/CSPF-Founder/JavaVulnerableLab</a> into our own project. We added <kbd>.gitlab-ci.yml</kbd> to run a scan. When the code was pushed, the workflow started and prepared for the scan:</p>
<pre class="mce-root"> [0KRunning with gitlab-runner 11.7.0 (8bb608ff)<br/> [0;m[0K on Joosts-MBP.fritz.box gGEycKK-<br/> [0;m[0KUsing Docker executor with image docker:stable ...<br/> [0;m[0KStarting service docker:stable-dind ...<br/> [0;m[0KPulling docker image docker:stable-dind ...<br/> [0;m[0KUsing docker image sha256:5b626cc3459ad077146e8aac1fbe25f7099d71c6765efd6552b9209ca7ea4dc1 for docker:stable-dind ...<br/> [0;m[0KWaiting for services to be up and running...<br/> [0;m[0KPulling docker image docker:stable ...<br/> [0;m[0KUsing docker image sha256:73d492654a095a2f91078b2dfacd0cfe1a1fe25412fac54b4eb2f5a9609ad418 for docker:stable ...<br/> [0;msection_start:1550847640:prepare_script<br/> [0KRunning on runner-gGEycKK--project-1-concurrent-0 via Joosts-MBP.fritz.box...<br/> section_end:1550847642:prepare_script<br/> [0Ksection_start:1550847642:get_sources</pre>
<p class="mce-root">In the next stage, the repository containing the code to be scanned is cloned, shown as follows:</p>
<pre class="mce-root"><br/> [0K[32;1mCloning repository...[0;m<br/> Cloning into '/builds/mastering_gitlab/JavaVulnerableLab'...<br/> [32;1mChecking out 157b6e94 as master...[0;m<br/> [32;1mSkipping Git submodules setup[0;m<br/> section_end:1550847644:get_sources<br/> [0Ksection_start:1550847644:restore_cache<br/> [0Ksection_end:1550847646:restore_cache<br/> [0Ksection_start:1550847646:download_artifacts<br/> [0Ksection_end:1550847647:download_artifacts<br/> [0Ksection_start:1550847647:build_script<br/> [0K[32;1m$ export SP_VERSION=$(echo "$CI_SERVER_VERSION" | sed 's/^\([0-9]*\)\.\([0-9]*\).*/\1-\2-stable/')[0;m<br/> [32;1m$ docker run --env SAST_CONFIDENCE_LEVEL="${SAST_CONFIDENCE_LEVEL:-3}" --volume "$PWD:/code" --volume /var/run/docker.sock:/var/run/docker.sock "registry.gitlab.com/gitlab-org/security-products/sast:$SP_VERSION" /app/bin/run /code[0;m</pre>
<p class="mce-root">In the next step, the run tries to get a specific Docker image for the scan. It will not find that locally and will instead try to get it from <kbd>gitlab.org</kbd>, as follows:</p>
<pre class="mce-root"> Unable to find image 'registry.gitlab.com/gitlab-org/security-products/sast:11-7-stable' locally<br/> 11-7-stable: Pulling from gitlab-org/security-products/sast<br/> 3f0edbe59eaa: Pulling fs layer<br/> 3f0edbe59eaa: Download complete<br/> 3f0edbe59eaa: Pull complete<br/> Digest: sha256:d31cbb2bfd200b60543ef99fa03638c2335a52597e0966b7347f896dbe4e78e7<br/> Status: Downloaded newer image for registry.gitlab.com/gitlab-org/security-products/sast:11-7-stable<br/><br/></pre>
<p class="mce-root">After successfully downloading the image, it will start the scan, as follows:</p>
<pre class="mce-root"> 2019/02/22 15:00:52 Copy project directory to containers<br/> 2019/02/22 15:00:52 [bandit] Detect project using plugin<br/> 2019/02/22 15:00:52 [bandit] Project not compatible<br/> 2019/02/22 15:00:52 [brakeman] Detect project using plugin<br/> 2019/02/22 15:00:52 [brakeman] Project not compatible<br/> 2019/02/22 15:00:52 [gosec] Detect project using plugin<br/> 2019/02/22 15:00:52 [gosec] Project not compatible<br/> 2019/02/22 15:00:52 [find-sec-bugs] Detect project using plugin<br/> 2019/02/22 15:00:52 [find-sec-bugs] Project is compatible<br/> 2019/02/22 15:00:52 [find-sec-bugs] Starting analyzer...<br/><br/></pre>
<p class="mce-root">After 10 minutes, the results should be as follows:</p>
<pre class="mce-root"> Downloaded from central: https://repo.maven.apache.org/maven2/com/google/collections/google-collections/1.0/google-collections-1.0.jar (640 kB at 882 kB/s)<br/> [INFO] Changes detected - recompiling the module!<br/> [WARNING] File encoding has not been set, using platform encoding UTF-8, i.e. build is platform dependent!<br/> [INFO] Compiling 15 source files to /tmp/app/target/classes<br/> [INFO] ------------------------------------------------------------------------<br/> [INFO] BUILD SUCCESS<br/> [INFO] ------------------------------------------------------------------------<br/> [INFO] Total time: 11.988 s<br/> [INFO] Finished at: 2019-02-22T15:24:25Z<br/> [INFO] ------------------------------------------------------------------------</pre>
<p class="mce-root">The scan will report on which plugin or module can be use (in other words, it checks project compatibility), as follows:</p>
<pre class="mce-root"> Warnings generated: 49<br/> 2019/02/22 15:24:33 [find-sec-bugs-gradle] Detect project using plugin<br/> 2019/02/22 15:24:33 [find-sec-bugs-gradle] Project not compatible<br/> 2019/02/22 15:24:33 [find-sec-bugs-sbt] Detect project using plugin<br/> 2019/02/22 15:24:33 [find-sec-bugs-sbt] Project not compatible<br/> 2019/02/22 15:24:33 [find-sec-bugs-groovy] Detect project using plugin<br/> 2019/02/22 15:24:33 [find-sec-bugs-groovy] Project not compatible<br/> 2019/02/22 15:24:33 [flawfinder] Detect project using plugin<br/> 2019/02/22 15:24:33 [flawfinder] Project not compatible<br/> 2019/02/22 15:24:33 [phpcs-security-audit] Detect project using plugin<br/> 2019/02/22 15:24:33 [phpcs-security-audit] Project not compatible<br/> 2019/02/22 15:24:33 [security-code-scan] Detect project using plugin<br/> 2019/02/22 15:24:33 [security-code-scan] Project not compatible<br/> 2019/02/22 15:24:33 [nodejs-scan] Detect project using plugin<br/> 2019/02/22 15:24:33 [nodejs-scan] Project not compatible</pre>
<p class="mce-root">You should now see a report of the findings, as in the following example (which is not entirely complete):</p>
<pre class="mce-root">+--------------------------------------------------------------------------------------+<br/> | Severity | Tool | Location |<br/> +--------------------------------------------------------------------------------------+<br/> | High | Find Security Bugs | src/main/java/org/cysecurity/cspf/jvl/controller/LoginValidator.java:64 |<br/> | |<br/> | HTTP cookie formed from untrusted input |<br/> +--------------------------------------------------------------------------------------+<br/> | High | Find Security Bugs | src/main/java/org/cysecurity/cspf/jvl/controller/AddPage.java:45 |<br/> | |<br/> | Relative path traversal in servlet |<br/> +--------------------------------------------------------------------------------------+</pre>
<p class="mce-root">As you can see in the following snippet, a lot of security issues were discovered:</p>
<pre class="mce-root"> Uploading artifacts...<br/> gl-sast-report.json: found 1 matching files<br/> Uploading artifacts to coordinator... ok id=4 responseStatus=201 Created token=Sy_pRf1e<br/> Job succeeded</pre>
<p class="mce-root">The scan finally finishes by uploading the report.</p>
<p>Essentially, <span>SAST</span> tries to analyze your code and applies plugins based on which code could be scanned. It will look for security hazards in your code. The scan is done in a special container delivered by GitLab. After scanning, a report is available.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dynamic Application Security Testing</h1>
                </header>
            
            <article>
                
<p class="mce-root"><strong>Dynamic Application Security Testing</strong> (<strong>DAST</strong>) runs PEN tests like scans of your application.</p>
<p class="mce-root"><span>The test uses OWASP ZAProxy (</span><a href="https://github.com/zaproxy/zaproxy">https://github.com/zaproxy/zaproxy</a><span>) to scan a running instance in your web application. It runs a passive scan, which means it only tries to discover your application by exploring links, will not find links created dynamically, and will not attack your application actively.</span></p>
<p>Before GitLab 12.0, this scan also used the Docker-in-Docker mechanism, but now it just retrieves and runs a container and the test. This means the image is cached on GitLab runners, and after retrieving the image for the first time, the security test will run faster.</p>
<p class="mce-root">As with SAST, you control how scanning happens through the <kbd>.gitlab-ci.yml</kbd> file, as follows:</p>
<pre class="mce-root"> dast:<br/> image: registry.gitlab.com/gitlab-org/security-products/zaproxy<br/> variables:<br/> website: "https://blog.joustie.nl"<br/> allow_failure: true<br/> script:<br/> - mkdir /zap/wrk/<br/> - /zap/zap-baseline.py -J gl-dast-report.json -t $website || true<br/> - cp /zap/wrk/gl-dast-report.json .<br/> artifacts:<br/> reports:<br/> dast: gl-dast-report.json</pre>
<p class="mce-root">When you push code to the repository, the DAST scan will start preparing, as shown in the following snippet. First, it will try to find the ZAProxy Docker container and pull it.</p>
<pre class="mce-root"> Running with gitlab-runner 11.7.0 (8bb608ff)<br/> on host gGEycKK-<br/> Using Docker executor with image registry.gitlab.com/gitlab-org/security-products/zaproxy ...<br/> Pulling docker image registry.gitlab.com/gitlab-org/security-products/zaproxy ...<br/> Using docker image sha256:cd12d3ce5fc66ef0c6b2cf0e6b745876b666aed7f9e859451eaef884b92cefa7 for registry.gitlab.com/gitlab-org/security-products/zaproxy ...</pre>
<p class="mce-root">The scan will start as follows:</p>
<pre class="mce-root"> Running on runner-gGEycKK--project-2-concurrent-0 via Joosts-MBP.fritz.box...<br/> Fetching changes...<br/> Removing zap.out<br/> HEAD is now at 6024894 Update .gitlab-ci.yml<br/> From http://192.168.178.82/root/unsecure<br/> 6024894..e6b26fe master -&gt; origin/master<br/> Checking out e6b26fe5 as master...<br/> Skipping Git submodules setup<br/> $ mkdir /zap/wrk/<br/> $ /zap/zap-baseline.py -J gl-dast-report.json -t $website || true<br/> 2019-02-22 15:50:26,650 Params: ['zap-x.sh', '-daemon', '-port', '40096', '-host', '0.0.0.0', '-config', 'api.disablekey=true', '-config', 'api.addrs.addr.name=.*', '-config', 'api.addrs.addr.regex=true', '-config', 'spider.maxDuration=1', '-addonupdate', '-addoninstall', 'pscanrulesBeta']<br/> Feb 22, 2019 3:50:34 PM java.util.prefs.FileSystemPreferences$1 run<br/> INFO: Created user preferences directory.</pre>
<p class="mce-root">It will try to scan the whole website, as shown in the following example:</p>
<pre class="mce-root"> Total of 251 URLs<br/> PASS: Cookie No HttpOnly Flag [10010]<br/> PASS: Cookie Without Secure Flag [10011]<br/> PASS: Incomplete or No Cache-control and Pragma HTTP Header Set [10015]<br/> PASS: Content-Type Header Missing [10019]<br/> PASS: Information Disclosure - Debug Error Messages [10023]<br/> PASS: Information Disclosure - Sensitive Information in URL [10024]<br/> PASS: Information Disclosure - Sensitive Information in HTTP Referrer Header [10025]<br/> PASS: HTTP Parameter Override [10026]<br/> PASS: Information Disclosure - Suspicious Comments [10027]<br/> PASS: Viewstate Scanner [10032]<br/> PASS: Secure Pages Include Mixed Content [10040]<br/> PASS: CSP Scanner [10055]<br/> PASS: Weak Authentication Method [10105]<br/> PASS: Session ID in URL Rewrite [3]<br/> PASS: Script Passive Scan Rules [50001]<br/> PASS: Insecure JSF ViewState [90001]<br/> PASS: Charset Mismatch [90011]<br/> PASS: WSDL File Passive Scanner [90030]<br/> PASS: Loosely Scoped Cookie [90033]<br/><br/></pre>
<p class="mce-root">It will then report vulnerabilities immediately, as shown in the following snippet:</p>
<pre class="mce-root">WARN-NEW: Web Browser XSS Protection Not Enabled [10016] x 112<br/> http://blog.joustie.nl/<br/> http://blog.joustie.nl/robots.txt<br/> http://blog.joustie.nl/sitemap.xml<br/> http://blog.joustie.nl<br/> http://blog.joustie.nl/atom.xml<br/> WARN-NEW: Cross-Domain JavaScript Source File Inclusion [10017] x 108<br/> http://blog.joustie.nl/<br/> http://blog.joustie.nl<br/> http://blog.joustie.nl/tags/personal/<br/> http://blog.joustie.nl/2019/01/12/2018-05-29-personalblog/<br/> http://blog.joustie.nl/2018/05/29/2018-05-20-met-zn-allen-1-wereld/<br/> .....<br/> FAIL-NEW: 0 FAIL-INPROG: 0 WARN-NEW: 7 WARN-INPROG: 0 INFO: 0 IGNORE: 0 PASS: 19</pre>
<p class="mce-root">After scanning, the report is created and uploaded as an artifact, as follows:</p>
<pre class="mce-root"><br/> $ cp /zap/wrk/gl-dast-report.json .<br/> Uploading artifacts...<br/> gl-dast-report.json: found 1 matching files<br/> Uploading artifacts to coordinator... ok id=6 responseStatus=201 Created token=LbTRyRU-<br/> Job succeeded<br/><br/></pre>
<p class="mce-root">As you can see from the preceding examples, by utilizing GitLab Runners with Docker, it is very easy to start a dynamic security scan.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dependency checking</h1>
                </header>
            
            <article>
                
<p class="mce-root">Known vulnerabilities in third-party components or dependencies are very common. They could even be part of the OWASP Top 10 List of Using Components with Known Vulnerabilities. The OWASP Web Malware Scanner (see <a href="https://www.owasp.org">https://www.owasp.org</a>) is a malware scanner for web applications. It can be used to scan a web application by using signatures from a community build and a managed database. It works by testing each file of the web application for known signatures of malware.</p>
<p class="mce-root">These known vulnerable components should be identified at an early development stage. It is also good practice to perform vulnerability scanning of the dependency components not only in the development stage but also in the production stage on a regular basis.</p>
<p class="mce-root"/>
<p class="mce-root">Again, the dependency scan in your GitLab workflow is controlled through the <kbd>.gitlab-ci.yml</kbd> file. It also uses the Docker-in-Docker technique, as follows:</p>
<pre class="mce-root">dependency_scanning:<br/> image: docker:stable<br/> variables:<br/> DOCKER_DRIVER: overlay2<br/> allow_failure: true<br/> services:<br/> - docker:stable-dind<br/> script:<br/> - export SP_VERSION=$(echo "$CI_SERVER_VERSION" | sed 's/^\([0-9]*\)\.\([0-9]*\).*/\1-\2-stable/')<br/> - docker run<br/> --env DEP_SCAN_DISABLE_REMOTE_CHECKS="${DEP_SCAN_DISABLE_REMOTE_CHECKS:-false}"<br/> --volume "$PWD:/code"<br/> --volume /var/run/docker.sock:/var/run/docker.sock<br/> "registry.gitlab.com/gitlab-org/security-products/dependency-scanning:$SP_VERSION" /code<br/> artifacts:<br/> reports:<br/> dependency_scanning: gl-dependency-scanning-report.json<br/><br/></pre>
<p class="mce-root">For this test, we used the same code (<a href="https://github.com/CSPF-Founder/JavaVulnerableLab">https://github.com/CSPF-Founder/JavaVulnerableLab</a>) as we did in the SAST scan to show our results. Here, you can see the job as it prepares after being pushed some new code. It should pull the <kbd>stable-dind</kbd> image, as follows:</p>
<pre class="mce-root"> Running with gitlab-runner 11.7.0 (8bb608ff)<br/> on host gGEycKK-<br/> Using Docker executor with image docker:stable ...<br/> Starting service docker:stable-dind ...<br/> Pulling docker image docker:stable-dind ...<br/> Using docker image sha256:5b626cc3459ad077146e8aac1fbe25f7099d71c6765efd6552b9209ca7ea4dc1 for docker:stable-dind ...<br/> Waiting for services to be up and running...<br/> Pulling docker image docker:stable ...<br/> Using docker image sha256:73d492654a095a2f91078b2dfacd0cfe1a1fe25412fac54b4eb2f5a9609ad418 for docker:stable ...</pre>
<p class="mce-root">Running the image will execute the dependency scan, as shown in the following snippets:</p>
<pre class="mce-root"> Running on runner-gGEycKK--project-2-concurrent-0 via Joosts-MBP.fritz.box...<br/> Fetching changes...<br/> HEAD is now at e6b26fe Update .gitlab-ci.yml<br/> From http://192.168.178.82/root/unsecure<br/> e6b26fe..3aa3162 master -&gt; origin/master<br/> Checking out 3aa3162f as master...<br/> Skipping Git submodules setup<br/> $ export SP_VERSION=$(echo "$CI_SERVER_VERSION" | sed 's/^\([0-9]*\)\.\([0-9]*\).*/\1-\2-stable/')<br/> $ docker run --env DEP_SCAN_DISABLE_REMOTE_CHECKS="${DEP_SCAN_DISABLE_REMOTE_CHECKS:-false}" --volume "$PWD:/code" --volume /var/run/docker.sock:/var/run/docker.sock "registry.gitlab.com/gitlab-org/security-products/dependency-scanning:$SP_VERSION" /code<br/> ...</pre>
<p class="mce-root">The technology used was formerly called Gemnasium. It was bought by GitLab in 2018, as you can see in a statement at<strong> <a href="https://docs.gitlab.com/ee/user/project/import/gemnasium.html">https://docs.gitlab.com/ee/user/project/import/gemnasium.html</a>.</strong></p>
<pre class="mce-root"><br/> Downloaded from central: https://repo.maven.apache.org/maven2/org/codehaus/plexus/plexus/2.0.6/plexus-2.0.6.pom (17 kB at 621 kB/s)<br/> [INFO] Gemnasium Maven Plugin<br/> [INFO]<br/> [INFO] Project's dependencies have been successfully dumped into: /tmp/app/gemnasium-maven-plugin.json<br/> [INFO] ------------------------------------------------------------------------<br/> [INFO] BUILD SUCCESS<br/> [INFO] ------------------------------------------------------------------------<br/> [INFO] Total time: 5.504 s<br/> [INFO] Finished at: 2019-02-23T11:45:49Z<br/> [INFO] ------------------------------------------------------------------------</pre>
<p class="mce-root">As you can see in the following code, some vulnerabilities in the MySQL library used were found:</p>
<pre class="mce-root"> +----------------------------------------------------------------------------------------+<br/> | Severity | Tool | Identifier |<br/> +----------------------------------------------------------------------------------------+<br/> | Unknown | Gemnasium | CVE-2015-7501 |<br/> | |<br/> | InvokerTransformer code execution during deserialization in commons |<br/> | collections/commons-collections |<br/> | Solution: Upgrade to the latest version |<br/> | In pom.xml |<br/> +----------------------------------------------------------------------------------------+<br/> | Unknown | Gemnasium | CVE-2017-3523 |<br/> | |<br/> | Vulnerability in the MySQL Connectors in mysql/mysql-connector-java |<br/> | Solution: Upgrade to the latest version |<br/> | In pom.xml |<br/> +----------------------------------------------------------------------------------------+<br/> 2019/02/23 11:45:51 [gemnasium-python] Detect project using plugin<br/> 2019/02/23 11:45:51 [gemnasium-python] Project not compatible<br/> 2019/02/23 11:45:51 [retire.js] Detect project using plugin<br/> 2019/02/23 11:45:51 [retire.js] Project not compatible<br/> Uploading artifacts...<br/> gl-dependency-scanning-report.json: found 1 matching files<br/> Uploading artifacts to coordinator... ok id=7 responseStatus=201 Created token=1cdLFEJP<br/> Job succeeded</pre>
<p>The job ends by uploading the scan report.</p>
<p>Just like the other scans, dependency checking uses the same technique of running a specific scan program from inside a Docker container. In this case, the scan program in use is Gemnasium, which was taken over by GitLab last year. If a problematic dependency is found, it is displayed in the output and in the resulting report.</p>
<p>A nice feature of GitLab 12.0 is that after your conducted your dependency scan, the resulting list of dependencies is saved in your project. This is a much wanted feature by security/compliance teams to keep track of what dependencies are used throughout the enterprise:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a03f0cc3-c028-4476-8ae9-02a52a7fed21.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we discussed the use of monitoring in the workflow, and the possibility to immediately integrate security monitoring. GitLab provides out-of-the-box opportunities to set up such things. In this chapter, we also looked at Prometheus and ways to write custom monitoring for it. In the next chapter, we will discuss integration options for GitLab, in case you need to connect to other tools. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>On which system is Prometheus inspired?</li>
<li>What is the name of the Prometheus clients?</li>
<li>On what path is the GitLab Metrics Exporter normally found?</li>
<li>What language was used for the GitLab Monitor Exporter?</li>
<li>How do you enable the built-in Prometheus server in the omnibus package?</li>
<li>What does SAST mean?</li>
<li>What does DAST mean?</li>
<li>Which file is used to control security testing?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>Prometheus site: <a href="https://prometheus.io">https://prometheus.io</a></li>
<li>OWASP scan: <a href="https://www.owasp.org">https://www.owasp.org</a></li>
<li><em>Practical Site Reliability Engineering</em>, by <em>Pethuru Raj Chelliah</em>, <em>Shreyash Naithani</em>, and <em>Shailender Singh</em>: <a href="https://www.packtpub.com/virtualization-and-cloud/practical-site-reliability-engineering">https://www.packtpub.com/virtualization-and-cloud/practical-site-reliability-engineering</a></li>
<li><em>Hands-On Security in DevOps</em>, by <em>Tony Hsu</em>: <a href="https://www.packtpub.com/in/networking-and-servers/hands-security-devops">https://www.packtpub.com/in/networking-and-servers/hands-security-devops</a></li>
<li><em>Industrial Internet Application Development</em>, by <em>Alena Traukina</em>, <em>Jayant Thomas</em>, <em>Prashant Tyagi</em>, and <em>Kishore Reddipalli</em>: <a href="https://www.packtpub.com/in/application-development/industrial-internet-application-development">https://www.packtpub.com/in/application-development/industrial-internet-application-development</a></li>
</ul>


            </article>

            
        </section>
    </body></html>