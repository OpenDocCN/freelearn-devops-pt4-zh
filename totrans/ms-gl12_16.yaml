- en: Integrating GitLab with CI/CD Tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 GitLab 与 CI/CD 工具集成
- en: In this chapter, we will cover some of the integrations that are possible with
    GitLab. Most of the time, companies will not use one tool for their complete DevOps
    journey. GitLab encourages this for small to midsize companies, but the reality
    is that big enterprise customers use a mix of different tools and technologies.
    We will connect Jira to GitLab, as this tool is in use in a big portion of the
    enterprise market. Of course, the venerable Jenkins server has to be mentioned
    and tried, and modern organizations use Slack/Mattermost or other chat tools for
    real-time collaboration. We will finish this chapter with an example of how to
    utilize a basic webhook.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些 GitLab 可以集成的工具。大多数情况下，公司不会仅使用一个工具来完成整个 DevOps 过程。GitLab 鼓励中小型公司这样做，但现实情况是，大型企业客户使用多种不同的工具和技术。我们将把
    Jira 与 GitLab 连接，因为该工具在企业市场中得到广泛应用。当然，值得一提并尝试的还有久负盛名的 Jenkins 服务器，现代组织使用 Slack/Mattermost
    或其他聊天工具进行实时协作。我们将在本章结束时，举例说明如何使用基本的 Webhook。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Using Jira with GitLab
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jira 与 GitLab
- en: Connecting with Jenkins
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Jenkins 连接
- en: Integrating with Mattermost
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Mattermost 集成
- en: Using webhooks for events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Webhook 处理事件
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For managing omnibus installs, there is one central configuration file called
    `gitlab.rb`. You need to create it or copy an example. There is a template available
    that you can find at [https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/files/gitlab-config-template/gitlab.rb.template](https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/files/gitlab-config-template/gitlab.rb.template).
    It isn't updated after upgrades. In large parts of this chapter, I will quote
    and discuss parts of this file.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于管理综合安装，有一个名为 `gitlab.rb` 的中央配置文件。您需要创建它或复制一个示例。您可以在以下链接找到模板：[https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/files/gitlab-config-template/gitlab.rb.template](https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/files/gitlab-config-template/gitlab.rb.template)。该模板在升级后不会自动更新。在本章的许多部分中，我将引用并讨论该文件的部分内容。
- en: The code examples for this chapter are available in this book's GitHub repository
    at [https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter13](https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter13).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码示例可以在本书的 GitHub 仓库中找到，链接：[https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter13](https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter13)。
- en: Using Jira with GitLab
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jira 与 GitLab
- en: Jira is an IT project management tool that was created by Atlassian in 2002
    and was first created as software for developers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Jira 是由 Atlassian 于 2002 年创建的 IT 项目管理工具，最初是为开发人员设计的软件。
- en: 'Jira was originally an issue tracking tool, that is, a tool to list and manage
    tasks. A *task* can be anything: a problem that needs to be solved, a simple TODO,
    an application, and so on. However, you can also go much further and put your
    products, customers, companies, and so on into this tool.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Jira 最初是一个问题跟踪工具，即列出和管理任务的工具。*任务* 可以是任何东西：需要解决的问题，一个简单的待办事项，一个应用程序等等。然而，您也可以进一步扩展，将产品、客户、公司等信息放入该工具中。
- en: JIRA is also a *workflow engine*. This means that you can define *workflows* (in
    other words, processes) that your tasks must follow. This way, you can impose
    different processes per project or per task. An example of a simple workflow for
    a task of the TODO type is OPEN | IN PROGRESS | READY.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JIRA 还是一个 *工作流引擎*。这意味着您可以定义 *工作流*（换句话说，流程），任务必须遵循这些流程。通过这种方式，您可以对每个项目或每个任务施加不同的流程。一个简单的任务工作流示例是：OPEN
    | IN PROGRESS | READY。
- en: For a different type of task, for example, an application to do something, you
    can set up this workflow: OPEN | CONFIRMED | APPROVED | READY.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不同类型的任务，例如应用程序执行某些操作，您可以设置以下工作流程：OPEN | CONFIRMED | APPROVED | READY。
- en: Through its integrations, GitLab can interface with Jira. Although GitLab already
    offers a lot of the project management features that Jira provides, in larger
    organizations, it can help integrate these tools. For instance, when overall project
    management is done in Jira, you can make sure that specific links are accessible
    in the GitLab workflow through commit messages, merge requests, and so on.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过集成，GitLab 可以与 Jira 对接。尽管 GitLab 已经提供了很多 Jira 提供的项目管理功能，但在较大的组织中，它可以帮助将这些工具集成在一起。例如，当整体项目管理在
    Jira 中进行时，您可以确保通过提交信息、合并请求等方式，在 GitLab 工作流中可以访问特定的链接。
- en: 'As an example, let''s create a project in Jira:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，让我们在 Jira 中创建一个项目：
- en: 'We created an account on the Cloud offering from Atlassian ([https://www.atlassian.com/enterprise/cloud](https://www.atlassian.com/enterprise/cloud)).
    When you have set up your instance in the Atlassian Cloud or on premise, continue
    to create a new project:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在Atlassian的云端服务上创建了一个账户（[https://www.atlassian.com/enterprise/cloud](https://www.atlassian.com/enterprise/cloud)）。当你在Atlassian云端或本地设置好你的实例后，继续创建一个新项目：
- en: '![](img/7fb74f38-1196-4790-93b9-d89c41e6caa8.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fb74f38-1196-4790-93b9-d89c41e6caa8.png)'
- en: 'When your project has been created, you will see the following screen:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你的项目创建完成后，你将看到以下页面：
- en: '![](img/0f9dbce0-5d59-4ee4-b2ad-a919a8ea4261.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f9dbce0-5d59-4ee4-b2ad-a919a8ea4261.png)'
- en: 'The next step is to create an issue in this project. Let''s do that with minimal
    information and call it `Integrate GitLab and Jira`. You will see it create an
    issue with an ID of `GI-1`. We now have an issue in our project management tool,
    which we like to link to our GitLab instance:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在该项目中创建一个问题。我们以最少的信息创建，命名为`Integrate GitLab and Jira`。你会看到它创建了一个ID为`GI-1`的问题。现在我们在我们的项目管理工具中有了一个问题，我们希望将它与我们的GitLab实例链接：
- en: '![](img/71cba23c-7968-41e5-8160-38080232d07f.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71cba23c-7968-41e5-8160-38080232d07f.png)'
- en: 'Now, we will create a special token in Jira, which we will use in GitLab to
    update the issue. Please visit [https://id.atlassian.com](https://id.atlassian.com),
    click Security, and then click Create and manage API tokens:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在Jira中创建一个特殊的令牌，用于在GitLab中更新问题。请访问[https://id.atlassian.com](https://id.atlassian.com)，点击安全，然后点击创建并管理API令牌：
- en: '![](img/333b5d30-3263-4715-97c0-7ee292d57c33.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/333b5d30-3263-4715-97c0-7ee292d57c33.png)'
- en: 'Click Create API token:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击创建API令牌：
- en: '![](img/46a9dec8-7f3f-4665-aaf3-5506d9878359.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46a9dec8-7f3f-4665-aaf3-5506d9878359.png)'
- en: 'After you have given it a nice name and clicked Create, it will appear in the
    list:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你为它取个好名字并点击创建后，它将出现在列表中：
- en: '![](img/82dbf83b-c981-4620-afbf-d9fe3ab745ef.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82dbf83b-c981-4620-afbf-d9fe3ab745ef.png)'
- en: 'Now, we need to head over to our GitLab instance to create the project that
    we want to connect to Jira:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要去我们的GitLab实例中创建一个我们想要连接到Jira的项目：
- en: '![](img/7841c2db-4952-4dde-9b40-682afd489b20.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7841c2db-4952-4dde-9b40-682afd489b20.png)'
- en: 'When the project has been created, go to the settings for this project and
    look for Jira in integrations:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当项目创建完成后，进入该项目的设置，查找集成中的Jira：
- en: '![](img/a7ca08d7-df3d-423d-b1cd-326440f6c543.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7ca08d7-df3d-423d-b1cd-326440f6c543.png)'
- en: You can choose whether comments can be created in Jira by following references
    in a Commit or a Merge request. You need to give the web URL for your Jira instance,
    which in our case is `https://joustie.atlassian.net`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以选择是否允许在Jira中通过提交或合并请求中的引用来创建评论。你需要提供你的Jira实例的网页URL，在我们的案例中是`https://joustie.atlassian.net`。
- en: Your username is the email address, and you can fill in your token that you
    created in Jira earlier.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你的用户名是你的电子邮件地址，你可以填写之前在Jira中创建的令牌。
- en: Now comes the harder part. When you change a Jira issue to another state, you
    need to provide a transition ID. In our example, this is `11`, `21`, `31`. Now,
    what is that and where do we find it? This is a good question, and all you need
    to do is call Jira's API. They represent the state an issue can be in, and you
    need to know this state in order to change them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是更难的部分。当你将Jira问题的状态更改为另一种状态时，你需要提供一个过渡ID。在我们的示例中，这是`11`、`21`、`31`。那么，这是什么？我们在哪里找到它？这是一个好问题，你需要做的就是调用Jira的API。它们代表问题可以处于的状态，你需要知道这些状态才能进行更改。
- en: In the following example, we called `https://joustie.atlassian.net/rest/api/2/issue/GI-1/transitions`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们调用了`https://joustie.atlassian.net/rest/api/2/issue/GI-1/transitions`。
- en: 'When you''ve found those IDs and saved the changes, Jira will test them, and
    hopefully, you''ll receive the following feedback:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你找到了这些ID并保存了更改后，Jira将会进行测试， hopefully，你会收到以下反馈：
- en: '![](img/e5c50e45-d0b9-4902-8a17-03cdceadf654.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5c50e45-d0b9-4902-8a17-03cdceadf654.png)'
- en: 'If you go back to the Integrations page, note that the Jira integration is
    green. Green is good:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你返回到集成页面，可以看到Jira集成的状态是绿色的。绿色表示良好：
- en: '![](img/270b742a-f362-4067-8e0a-2f94a1e28873.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/270b742a-f362-4067-8e0a-2f94a1e28873.png)'
- en: 'If something goes wrong or you would like to know more about these calls, you
    can consult `integrations_json.log` in the rails log directory. For instance,
    the successful call to activate Jira integration is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现问题或者你想了解更多这些调用的详细信息，可以查阅`integrations_json.log`，它位于rails日志目录下。例如，成功激活Jira集成的调用如下：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, you can resolve an issue in Jira through GitLab:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过GitLab解决Jira中的问题：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the project overview, you will find that the issue has moved to Done:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目概览中，你会发现问题已经移到“完成”状态：
- en: '![](img/0f3f2d01-c116-43ab-bd76-852079793323.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f3f2d01-c116-43ab-bd76-852079793323.png)'
- en: 'If you look in the issue itself, you will find that is has a status of Closed:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看该问题本身，你会发现它的状态是已关闭（Closed）：
- en: '![](img/ffff1970-786b-4d66-b9fb-3791a7bcc615.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ffff1970-786b-4d66-b9fb-3791a7bcc615.png)'
- en: As you can see, it is possible to integrate project management tools like Jira
    with GitLab and keep issues in sync. In this section, we have demonstrated how
    to integrate a cloud-based Jira offering with a local on-premise GitLab installation.
    Now, let's move on and connect with Jenkins.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，可以将像 Jira 这样的项目管理工具与 GitLab 集成，并保持问题同步。在本节中，我们展示了如何将基于云的 Jira 服务与本地 GitLab
    安装进行集成。接下来，让我们继续与 Jenkins 连接。
- en: Connecting Jenkins to GitLab
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Jenkins 与 GitLab 连接
- en: Jenkins (a fork of the Hudson project) is a Continuous Integration platform.
    The platform is primarily intended for the repeated execution and monitoring of
    build tasks, as well as the automated building and testing of applications. The
    many freely available plugins make it very easy to expand the functionality of
    Jenkins. An example of this is its integration with other systems (such as Sonar,
    Jira, or CloudBees) or changing its look and feel. It is possible to build a complete
    Continuous Delivery pipeline by using the right plugins.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins（Hudson 项目的一个分支）是一个持续集成平台。该平台主要用于重复执行和监控构建任务，以及自动构建和测试应用程序。许多免费的插件使得扩展
    Jenkins 功能变得非常容易。一个例子就是它与其他系统（如 Sonar、Jira 或 CloudBees）的集成，或者改变其外观和感觉。通过使用合适的插件，可以构建一个完整的持续交付（Continuous
    Delivery）管道。
- en: There is also a GitLab plugin available to integrate Jenkins in a GitLab workflow.
    You can download and host Jenkins yourself, or buy capacity in the cloud.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个 GitLab 插件可以将 Jenkins 集成到 GitLab 工作流中。你可以自己下载并托管 Jenkins，或者购买云中的容量。
- en: 'As an example, we have used a local Jenkins container and pulled a container
    from [https://hub.docker.com/_/jenkins](https://hub.docker.com/_/jenkins). Let''s
    get started:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，我们使用了一个本地的 Jenkins 容器，并从 [https://hub.docker.com/_/jenkins](https://hub.docker.com/_/jenkins)
    拉取了一个容器。让我们开始吧：
- en: 'When your Jenkins container has been configured and started, you need to make
    sure that the GitLab plugin has been installed:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你的 Jenkins 容器配置并启动后，你需要确保已经安装了 GitLab 插件：
- en: '![](img/d56ffa79-c120-4a2d-824c-1b44c9199605.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d56ffa79-c120-4a2d-824c-1b44c9199605.png)'
- en: 'Click on Manage Jenkins | Manage Plugins:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“管理 Jenkins”|“管理插件”：
- en: '![](img/028484bc-8e79-4eba-8424-f592a26bdf21.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/028484bc-8e79-4eba-8424-f592a26bdf21.png)'
- en: 'If you click on the Available tab and filter for GitLab, you can choose the
    GitLab plugin:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你点击“可用”标签并筛选 GitLab，你可以选择 GitLab 插件：
- en: '![](img/27eb9f83-ebd0-4422-8f81-bdd9f4021f37.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27eb9f83-ebd0-4422-8f81-bdd9f4021f37.png)'
- en: 'When it has been installed, you will see it appearing as a Success:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，你会看到它显示为“成功”：
- en: '![](img/b601f76a-410a-4d8a-b000-c03ce816aa9f.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b601f76a-410a-4d8a-b000-c03ce816aa9f.png)'
- en: Now, go back to the Manage Jenkins page, click Configure System, and scroll
    to the GitLab section.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，返回到“管理 Jenkins”页面，点击“配置系统”，然后滚动到 GitLab 部分。
- en: 'Give the connection a name of your choice, provide the correct URL, and click
    Add to get a GitLab API token. This API token can be generated in GitLab in the
    settings:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给连接起个名字，提供正确的 URL，然后点击“添加”以获取一个 GitLab API token。这个 API token 可以在 GitLab 的设置中生成：
- en: '![](img/53c81772-e64e-4ad3-81e3-546629a187f4.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53c81772-e64e-4ad3-81e3-546629a187f4.png)'
- en: 'You only need to fill in the API token here:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里只需要填写 API token：
- en: '![](img/3298f054-e460-4157-a94b-3cc4e3216e0d.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3298f054-e460-4157-a94b-3cc4e3216e0d.png)'
- en: 'The next step is to create projects in Jenkins and GitLab (for this example).
    For this occasion, we chose a freestyle project and named it `petclinic`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建 Jenkins 和 GitLab 项目（本示例中）。我们选择了一个自由风格项目，并命名为 `petclinic`：
- en: '![](img/2e2339c0-2f01-4f0f-8fff-6a99a4f9b26f.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e2339c0-2f01-4f0f-8fff-6a99a4f9b26f.png)'
- en: 'We did the same for GitLab:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 GitLab 上做了同样的操作：
- en: '![](img/78d67e70-0c8f-4ca9-abc8-7299e2245b29.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78d67e70-0c8f-4ca9-abc8-7299e2245b29.png)'
- en: 'In your Jenkins project, scroll down to the Source Code Management section
    and fill in the URL of your GitLab source code repository:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 Jenkins 项目中，向下滚动到“源代码管理”部分，并填写你的 GitLab 源代码仓库的 URL：
- en: '![](img/10e461b6-b57c-4529-8544-4f2d52542ea8.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10e461b6-b57c-4529-8544-4f2d52542ea8.png)'
- en: 'Next, click Add to add credentials. You need to add a username and password
    to connect to your HTTP Git repository (or an SSH user/key or an API key):'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击“添加”以添加凭据。你需要添加一个用户名和密码来连接到你的 HTTP Git 仓库（或者是 SSH 用户/密钥，或是 API 密钥）：
- en: '![](img/d5d06fe3-6082-415c-8da7-9b6188278f53.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5d06fe3-6082-415c-8da7-9b6188278f53.png)'
- en: 'Then, close the popup and scroll down to the Build Triggers section. You can
    then enable Build when a change is pushed to GitLab. For this example, we have
    chosen to trigger on push events and opened merge request events:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，关闭弹出窗口并向下滚动到“构建触发器”部分。你可以在这里启用当 GitLab 推送更改时触发构建。此示例中，我们选择了在推送事件和合并请求事件时触发：
- en: '![](img/4fb36457-0bff-4985-9a52-5b14773b9bec.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fb36457-0bff-4985-9a52-5b14773b9bec.png)'
- en: Click on Save to save your settings.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击保存以保存你的设置。
- en: For testing and fast development, I recommend using ngrok. This is a secure
    tunnel program that you can use to connect a localhost to a dynamic URL hosting
    service. You can find the tool at [http://ngrok.com](http://ngrok.com). Download
    the binary and place it on the local path.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试和快速开发，我推荐使用 ngrok。它是一个安全的隧道程序，可以将本地计算机连接到动态 URL 主机服务。你可以在 [http://ngrok.com](http://ngrok.com)
    找到这个工具，下载二进制文件并将其放在本地路径中。
- en: We can use it to tunnel from the internet (where our GitLab lives in a cloud
    container) to our local Docker container running Jenkins.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用它从互联网（我们托管 GitLab 的云容器）隧道到本地 Docker 容器中的 Jenkins。
- en: 'Start ngrok to connect an internet URL to our local Jenkins running on `8080`
    in Docker:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 ngrok，将互联网 URL 连接到我们在 Docker 中运行的本地 Jenkins（端口 `8080`）：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After starting ngrok, you will be presented with the following output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 ngrok 后，屏幕上将显示以下输出：
- en: '![](img/755ed7c4-a7b6-4e9f-a89e-f920abb08d07.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/755ed7c4-a7b6-4e9f-a89e-f920abb08d07.png)'
- en: 'Now, change some code in the repository and push the code to GitLab:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在仓库中修改一些代码并将其推送到 GitLab：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You will notice the hook being triggered in ngrok:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在 ngrok 中看到钩子被触发：
- en: '![](img/d2b95721-bd38-4f73-b67a-3b343f5a294c.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2b95721-bd38-4f73-b67a-3b343f5a294c.png)'
- en: 'By going to Jenkins, you will see that it receives an event and starts building
    the project:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过进入 Jenkins，你会看到它接收到事件并开始构建项目：
- en: '![](img/3415ec38-f749-495b-b625-9f111652c5ce.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3415ec38-f749-495b-b625-9f111652c5ce.png)'
- en: As you can see, it's quite easy to connect Jenkins to GitLab. You can choose
    to let Jenkins react to different kinds of events in GitLab.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，将 Jenkins 连接到 GitLab 非常简单。你可以选择让 Jenkins 对 GitLab 中的不同类型事件作出响应。
- en: Integrating with Mattermost
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成 Mattermost
- en: Mattermost is the number one open source Slack alternative, and can be hosted
    on a proprietary platform that you manage yourself.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Mattermost 是最受欢迎的开源 Slack 替代品，可以托管在你自己管理的专有平台上。
- en: When teams use these tools, they can become more productive because of direct
    communication via chat in specialized channels. There, they can exchange quick
    information bits – even files (images/video, anything) and datafiles that are
    used by applications.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当团队使用这些工具时，他们可以通过专门的频道直接进行聊天交流，从而提高生产力。在这些频道中，他们可以交换快速信息片段——甚至是文件（图片/视频，任何文件）和应用程序使用的数据文件。
- en: You can use Mattermost via a browser, or use the platform-specific app on your
    mobile device. No specific personal data is used other than your email address.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过浏览器使用 Mattermost，或者在移动设备上使用平台专用的应用程序。除了你的电子邮件地址外，不会使用任何特定的个人数据。
- en: What is also one of its killer features is that it easily connects to third-party
    applications and systems such as GitLab, Jira Jenkins, Nagios, Zabbix, Kopano,
    and many more! The company has actually been bought by GitLab, and Mattermost
    is part of the omnibus installation. In other words, you can easily enable it
    and run it together with GitLab. ChatOps has been supported since GitLab Ultimate
    10.6, but came to GitLab Core in 11.9.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 它的一个杀手级功能是，它能够轻松连接到 GitLab、Jira Jenkins、Nagios、Zabbix、Kopano 等第三方应用和系统！事实上，这家公司已被
    GitLab 收购，Mattermost 也成为了 GitLab 全套软件包的一部分。换句话说，你可以轻松启用它并与 GitLab 一起运行。从 GitLab
    Ultimate 10.6 开始支持 ChatOps，但在 11.9 版本中引入了 GitLab Core。
- en: As an example, we will set up a new Mattermost server to integrate with a GitLab
    instance in order to use slash commands.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们将设置一个新的 Mattermost 服务器与 GitLab 实例集成，以便使用斜杠命令。
- en: Because Mattermost is part of the GitLab omnibus package, you can enable/install
    it by editing the `gitlab.rb` file, and use `gitlab-ctl` afterwards to reconfigure
    your instance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Mattermost 是 GitLab 全套软件包的一部分，你可以通过编辑 `gitlab.rb` 文件来启用/安装它，之后使用 `gitlab-ctl`
    重新配置你的实例。
- en: 'The configuration key to change in `gitlab.rb` is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `gitlab.rb` 中需要更改的配置项如下：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After Mattermost has been started, you can go the integrations page of the settings
    of your project and search for the Mattermost slash command service. Click on
    Add to Mattermost. This will only work automatically on Mattermost 3.4, so make
    sure that your omnibus package isn't too old.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动 Mattermost 后，你可以进入项目设置的集成页面，搜索 Mattermost 斜杠命令服务。点击添加到 Mattermost。此操作仅在
    Mattermost 3.4 版本上自动有效，因此请确保你的 Omnibus 包不是太旧。
- en: 'If Mattermost isn''t installed on your server, you can pull a simple Mattermost
    image from Docker Hub. `mattermost/mattermost-preview` will do fine. Let''s get
    started:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的服务器上没有安装 Mattermost，你可以从 Docker Hub 拉取一个简单的 Mattermost 镜像。`mattermost/mattermost-preview`
    就可以了。我们开始吧：
- en: 'When you log in for the first time in your container (by default, this is via
    `http://localhost:8065`), you have to create a user:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你第一次在容器中登录时（默认情况下是通过 `http://localhost:8065`），你需要创建一个用户：
- en: '![](img/6d527181-4175-465f-a20d-3fe0a8fde5ef.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d527181-4175-465f-a20d-3fe0a8fde5ef.png)'
- en: 'After you have created the user, you will want to create a team:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用户后，你需要创建一个团队：
- en: '![](img/99e8a251-803f-4a3f-8d80-40d555ac161e.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99e8a251-803f-4a3f-8d80-40d555ac161e.png)'
- en: 'That team needs a URL as well:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该团队还需要一个 URL：
- en: '![](img/394ebdc4-c7a8-4582-93f4-cfd0a9cb09b1.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/394ebdc4-c7a8-4582-93f4-cfd0a9cb09b1.png)'
- en: 'You can click the hamburger menu to reveal options for the team:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以点击汉堡菜单来查看团队的选项：
- en: '![](img/d4ac96fd-5819-44b9-a9b6-79f3dd2a35a3.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4ac96fd-5819-44b9-a9b6-79f3dd2a35a3.png)'
- en: 'Go to the system console:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到系统控制台：
- en: '![](img/cbe266b9-04a1-4246-a784-5dbcce55c6f4.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbe266b9-04a1-4246-a784-5dbcce55c6f4.png)'
- en: 'Look for Custom Integrations and check that slash commands are enabled. Save
    the settings:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找自定义集成（Custom Integrations），并确保斜杠命令已启用。保存设置：
- en: '![](img/16ddc1f3-237f-4607-8b01-2fcbf4a43054.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16ddc1f3-237f-4607-8b01-2fcbf4a43054.png)'
- en: 'After this, click the hamburger menu and click Switch back to.... Clicking
    the hamburger menu in the team context, you can click Integrations. Here, you
    can click on Slash Command, where you will find a page where you can define a
    slash command that can be triggered by Mattermost:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，点击汉堡菜单，然后点击切换回去.... 在团队上下文中点击汉堡菜单，你可以点击集成（Integrations）。在这里，你可以点击斜杠命令（Slash
    Command），你将看到一个页面，在该页面中你可以定义一个可以由 Mattermost 触发的斜杠命令：
- en: '![](img/492f2e6d-19fb-4eea-bed7-2ac27b988dff.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/492f2e6d-19fb-4eea-bed7-2ac27b988dff.png)'
- en: 'The information we need to fill in here can be got from GitLab:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要填写的信息可以从 GitLab 获取：
- en: '![](img/a0b3dc65-146a-4af0-aa9b-5455813077dc.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0b3dc65-146a-4af0-aa9b-5455813077dc.png)'
- en: 'Log in to GitLab and go to Integrations in the settings part of your repository.
    Then, click Mattermost slash command. Here is the information you need to fill
    in in Mattermost:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到 GitLab，并进入你的仓库设置部分中的集成（Integrations）。然后点击 Mattermost 斜杠命令。这里是你需要在 Mattermost
    中填写的信息：
- en: '![](img/9ebaf1b4-a128-4b43-a414-795ebecc44ca.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ebaf1b4-a128-4b43-a414-795ebecc44ca.png)'
- en: 'In the following screenshot, you can see the settings as we copied them. Click
    Save or Update when you are done:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下截图中，你可以看到我们复制的设置。完成后点击保存（Save）或更新（Update）：
- en: '![](img/8f311cf7-1898-4c2c-b02f-4995ea08273a.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f311cf7-1898-4c2c-b02f-4995ea08273a.png)'
- en: 'You will now be presented with a token to be used in GitLab. Copy the Mattermost
    token:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你将获得一个在 GitLab 中使用的令牌。复制 Mattermost 令牌：
- en: '![](img/8aac56da-f37e-4eda-bf77-5ae2d7f4b6ed.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8aac56da-f37e-4eda-bf77-5ae2d7f4b6ed.png)'
- en: 'Paste it into the settings page for your Mattermost integration in GitLab,
    and save the changes:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其粘贴到 GitLab 中的 Mattermost 集成设置页面，并保存更改：
- en: '![](img/1aff3dc7-5b3d-4f7e-b8ac-71931517af83.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1aff3dc7-5b3d-4f7e-b8ac-71931517af83.png)'
- en: 'Now, go to your team channel in Mattermost and press `*/*`. If you issue `/gitlab
    help`, Mattermost will ask you to connect your GitLab account:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到你的 Mattermost 团队频道，按下 `*/*`。如果你发出 `/gitlab help`，Mattermost 会要求你连接你的 GitLab
    账户：
- en: '![](img/09de6f24-794b-4a9e-8517-bcc1e451fcf5.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09de6f24-794b-4a9e-8517-bcc1e451fcf5.png)'
- en: 'You will be redirected to GitLab, where you will have to authorize the connection:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将被重定向到 GitLab，在那里你需要授权连接：
- en: '![](img/9e9150a1-7789-4773-807d-ff534d587f2d.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e9150a1-7789-4773-807d-ff534d587f2d.png)'
- en: 'Now, by going back to Mattermost and issuing `/gitlab help` once more, you
    will be presented with the options for the command. There are several, and these
    can help your support people run ChatOps:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过返回到 Mattermost 并再次发出 `/gitlab help`，你将看到命令的选项。有几种选项，这些选项可以帮助你的支持人员进行 ChatOps
    操作：
- en: '![](img/58376bf2-502f-47e0-bd60-a069ec887dff.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58376bf2-502f-47e0-bd60-a069ec887dff.png)'
- en: 'Let''s create a new issue called `gitlab issue new test`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新的问题，命名为 `gitlab issue new test`：
- en: '![](img/ec97f6b7-db38-4a3b-bbd5-3c28c625ca46.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec97f6b7-db38-4a3b-bbd5-3c28c625ca46.png)'
- en: 'If you go back to GitLab, you will find that a new issue has been created for
    the GitLab project:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你返回 GitLab，你会发现为 GitLab 项目创建了一个新的 issue：
- en: '![](img/f740d6ac-6d12-4504-8d40-6dc08e3dfce7.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f740d6ac-6d12-4504-8d40-6dc08e3dfce7.png)'
- en: 'The ultimate integration is to use CI command functions, as described here:
    [https://docs.gitlab.com/ee/ci/chatops/](https://docs.gitlab.com/ee/ci/chatops/).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的集成是使用 CI 命令功能，详见此处：[https://docs.gitlab.com/ee/ci/chatops/](https://docs.gitlab.com/ee/ci/chatops/)。
- en: Since GitLab 11.9, ChatOps is even part of GitLab Core, so its functionality
    isn't limited to the GitLab Enterprise Edition.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从 GitLab 11.9 版本开始，ChatOps 已经是 GitLab Core 的一部分，因此其功能不再局限于 GitLab 企业版。
- en: In this section, we have showed you how to integrate your GitLab repository
    issues with the Mattermost chat application. There are endless possibilities if
    you create your own slash commands. Now, let's take a look at using webhooks for
    events.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示了如何将 GitLab 仓库的 issue 与 Mattermost 聊天应用程序集成。如果你创建自己的斜杠命令，可能性是无穷无尽的。现在，让我们来看看如何使用
    webhook 来处理事件。
- en: Using webhooks for events
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 webhook 处理事件
- en: Webhooks are used as a signal between applications. You can see it as a callback
    from a different context. This call is made with the HTTP protocol (possibly with
    SSL). An attempt is made to provide information as efficiently as possible and
    in real time, and JSON is usually used as a data format.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Webhook 被用作应用程序之间的信号。你可以把它看作是来自不同上下文的回调。此调用是通过 HTTP 协议（可能带有 SSL）发起的。尝试以最有效的方式实时提供信息，通常使用
    JSON 作为数据格式。
- en: The strength lies in the fact that as few operations as possible are necessary
    in order to get feedback. Usually, the most work lies in the implementation of
    the *signal*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 其强大之处在于，只需尽可能少的操作就能获得反馈。通常，最多的工作是实现 *信号* 的部分。
- en: For a proof of concept, consider the following. Let's assume that when we push
    new code to GitLab, we have to send a signal from GitLab to an application that
    we have built ourselves.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 作为概念验证，请考虑以下情况。假设当我们将新代码推送到 GitLab 时，我们需要从 GitLab 向我们自己构建的应用程序发送信号。
- en: 'To implement this model, we''ve chose the lightweight Flask micro-framework
    for Python:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个模型，我们选择了 Python 的轻量级 Flask 微框架：
- en: '[PRE5]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s run through this code step by step. In the following code, the basic
    app has been initiated. The imports are purely the basic Flask framework and,
    in particular, the request object. The app is instantiated:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地走过这段代码。在以下代码中，基本的应用程序已经初始化。导入的内容主要是 Flask 框架的基础内容，特别是 request 对象。应用程序被实例化：
- en: '[PRE6]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following function can be used to do the real work:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数可以用来执行实际的工作：
- en: '[PRE7]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then follows the method that is decorated with a route, and parses the request
    for certain information. There''s no check here – just reading the information
    from the JSON webhook, running the `real work` function, and returning `OK`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是带有路由装饰器的方法，它解析请求中的特定信息。这里没有检查 —— 只是从 JSON webhook 中读取信息，运行 `real work` 函数，并返回
    `OK`：
- en: '[PRE8]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following `main` part, combined with the first block, is part of the basic
    Flask implementation:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的 `main` 部分与第一个代码块一起，构成了 Flask 的基本实现：
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When you run this code with `python server.py`, it will open port `5000` on
    the localhost:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `python server.py` 运行这段代码时，它将在本地主机上打开端口 `5000`：
- en: '[PRE10]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we want something on the internet to connect to it, we can use the venerable
    ngrok to link the port:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望互联网中的某些东西连接到它，我们可以使用老牌的 ngrok 来链接端口：
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'ngrok is now running, as shown in the following screenshot:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ngrok 现在正在运行，如下图所示：
- en: '![](img/ce383744-7d32-4ecf-8250-99aa35a80f65.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce383744-7d32-4ecf-8250-99aa35a80f65.png)'
- en: 'We can now define the webhook in GitLab. You can find it in the Settings |
    Integrations section of your GitLab project. After you have defined the hook,
    you can run a test to verify its operation:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在 GitLab 中定义 webhook。你可以在 GitLab 项目的设置 | 集成部分找到它。定义好钩子后，你可以运行测试以验证其操作：
- en: '![](img/a9b63b7d-0496-46ce-b7c6-458c43efbbc2.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9b63b7d-0496-46ce-b7c6-458c43efbbc2.png)'
- en: 'We get the following result when a call is triggered through GitLab. This is
    the connection going through the ngrok proxy:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过 GitLab 触发调用时，我们会得到以下结果。这是通过 ngrok 代理的连接：
- en: '![](img/596697cd-7869-4197-ba32-653667394906.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/596697cd-7869-4197-ba32-653667394906.png)'
- en: 'In GitLab, if you click the Edit button, you will see the result of the webhook
    call. It will contain the body that was sent:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitLab 中，如果你点击编辑按钮，你将看到 webhook 调用的结果。它将包含已发送的主体：
- en: '![](img/ebc6d6f9-aca8-4e30-81f6-dbe054499fb6.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ebc6d6f9-aca8-4e30-81f6-dbe054499fb6.png)'
- en: 'You will also see the response that was given by the other end. You can see
    the OK response clearly:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将看到另一端返回的响应。你可以清楚地看到 OK 响应：
- en: '![](img/de6afa45-058e-4058-b30d-231a73d8b96c.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de6afa45-058e-4058-b30d-231a73d8b96c.png)'
- en: 'The result of this call was that our custom method was triggered and some specific
    information such as author, email, and message was printed on stdout:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用的结果是我们的自定义方法被触发，并且一些特定信息，如作者、电子邮件和消息，打印在标准输出上：
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have seen that it is also possible to use a generic event mechanism such
    as webhooks. You can modify your own software or **commercial-off-the-shelf**
    (**COTS**) application to receive events from GitLab.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，也可以使用像 webhook 这样的通用事件机制。你可以修改自己的软件或 **商业现成** (**COTS**) 应用程序，以接收来自 GitLab
    的事件。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed the ways of integrating GitLab with other products.
    Every integration has its own special instruction, but the basic idea is that
    you have to set up trust relationships and map attributes. GitLab is already shipped
    with a lot of possible integrations out of the box. These are called **project
    services**, and the documentation can be found here: [https://docs.gitlab.com/ee/user/project/integrations/project_services.html](https://docs.gitlab.com/ee/user/project/integrations/project_services.html). This
    chapter concludes the third section of this book, in which we've discussed the
    GitLab workflow and the underlying rationale behind it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了将 GitLab 与其他产品集成的方法。每种集成都有自己的特殊说明，但基本思路是你需要建立信任关系并映射属性。GitLab 已经提供了许多开箱即用的集成功能，这些称为
    **项目服务**，文档可以在这里找到：[https://docs.gitlab.com/ee/user/project/integrations/project_services.html](https://docs.gitlab.com/ee/user/project/integrations/project_services.html)。本章结束了本书的第三部分，我们讨论了
    GitLab 的工作流及其背后的基本原理。
- en: 'In the next part of this book, we will discuss the most successful part of
    GitLab: GitLab CI and runners. We will start by talking about how to set up a
    project for GitLab CI.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一部分，我们将讨论 GitLab 最成功的部分：GitLab CI 和 Runner。我们将首先讲解如何为 GitLab CI 设置项目。
- en: Questions
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is Jira used for?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jira 用于什么？
- en: Jira is from which company?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jira 是哪家公司开发的？
- en: Which ID or IDs are needed to manipulate issues in Jira?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Jira 中，操作问题需要哪些 ID？
- en: Which project is Jenkins forked from?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jenkins 是从哪个项目分叉出来的？
- en: What mechanism does Jenkins use to extend functionality?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jenkins 使用什么机制来扩展功能？
- en: What is ChatOps?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 ChatOps？
- en: How can you control things from a Mattermost channel?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何从 Mattermost 渠道控制事务？
- en: In GitLab, where can you find the status of a webhook?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 GitLab 中，在哪里可以找到 webhook 的状态？
- en: Further reading
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Jira 8 Essentials - Fifth Edition*, by *Patrick Lee*: [https://www.packtpub.com/in/application-development/jira-8-essentials-fifth-edition](https://www.packtpub.com/in/application-development/jira-8-essentials-fifth-edition)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Jira 8 精要 - 第五版*，由 *Patrick Lee* 编写： [https://www.packtpub.com/in/application-development/jira-8-essentials-fifth-edition](https://www.packtpub.com/in/application-development/jira-8-essentials-fifth-edition)'
- en: '*Jenkins 2.x Continuous Integration Cookbook - Third Edition*, by *Mitesh Soni*
    and *Alan Mark Berg*: [https://www.packtpub.com/in/networking-and-servers/jenkins-2x-continuous-integration-cookbook-third-edition](https://www.packtpub.com/in/networking-and-servers/jenkins-2x-continuous-integration-cookbook-third-edition)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Jenkins 2.x 持续集成食谱 - 第三版*，由 *Mitesh Soni* 和 *Alan Mark Berg* 编写： [https://www.packtpub.com/in/networking-and-servers/jenkins-2x-continuous-integration-cookbook-third-edition](https://www.packtpub.com/in/networking-and-servers/jenkins-2x-continuous-integration-cookbook-third-edition)'
- en: '*Jenkins Fundamentals*, by *Joseph Muli* and *Arnold Okoth*: [https://www.packtpub.com/in/networking-and-servers/jenkins-fundamentals](https://www.packtpub.com/in/networking-and-servers/jenkins-fundamentals)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Jenkins 基础*，由 *Joseph Muli* 和 *Arnold Okoth* 编写： [https://www.packtpub.com/in/networking-and-servers/jenkins-fundamentals](https://www.packtpub.com/in/networking-and-servers/jenkins-fundamentals)'
- en: '*GitLab ChatOps*: [https://docs.gitlab.com/ee/ci/chatops/](https://docs.gitlab.com/ee/ci/chatops/)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GitLab ChatOps*： [https://docs.gitlab.com/ee/ci/chatops/](https://docs.gitlab.com/ee/ci/chatops/)'
