<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Setting Up Your Project for GitLab Continuous Integration</h1>
                </header>
            
            <article>
                
<p><span><strong>Continuous Integration</strong> (<strong>CI</strong>) is one of the most important pillars of</span> <strong>Extreme Programming</strong> <span>(<strong>XP</strong>). Continuous Integration has been one of GitLab's most popular features since it was built in version 8. It is very popular with independent developers and open source projects and is currently gaining popularity in other market segments.</span></p>
<p><span>Getting started is easy. As we showed you earlier, in <a href="1eceee2e-41d6-41cc-95eb-3d225f25f3fa.xhtml">Chapter 10</a>, <em>Create Your Product, Verify, and Package it</em> (in the <em>Release</em> and <em>Configure</em> sections), Auto DevOps is switched on by default, so that when adding code to a project, a deployment pipeline is automatically set up in which various jobs are running. These jobs will be run by a GitLab Runner, which you will have to set up. This is completely configurable to the wishes of the developer. The results of the jobs are collected and showed as passed or failed and are part of the logic in the pipeline. Based on the result, other automation in the pipeline can be triggered<strong>. </strong></span><span>The basis for this functionality is in the <kbd>.gitlab-ci.yml</kbd> file. If this file is present in a project, it will be parsed and different pipelines and jobs will start running.</span></p>
<p>In this chapter, we will be covering the following topics:</p>
<ul>
<li class="mce-root">Pipelines</li>
<li class="mce-root">Jobs</li>
<li class="mce-root">Creating <kbd><span>.gitlab-ci.yml</span></kbd></li>
<li class="mce-root">Configuring a Runner</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p><span>To follow along with the instructions in this chapter, please download the Git repository with the examples available at GitHub:</span><span> <a href="https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter14" target="_blank">https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/Chapter14</a></span>.<a href="https://github.com/PacktPublishing/Mastering-GitLab-12/tree/master/CHP13"/></p>
<p>GitLab CI must be enabled in your GitLab instance (see <a href="f6e9da35-95c5-4938-8afe-7bcc7590f5be.xhtml">Chapter 3</a>, <em>Configuring GitLab Using the Web UI</em>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pipelines</h1>
                </header>
            
            <article>
                
<p><span>A pipeline in the software engineering world is understood as a chain of events (of processes, components, and so on) that automatically triggers and delivers input to the next element. It resembles the physical pipelines that exist in the real world.</span></p>
<p>In a CI context, a pipeline is a collection of sequential steps that integrate code from different developers. The chain of events is triggered by a commit or push to a source code repository such as GitLab. The build system (for example, Jenkins or GitLab CI) is notified of a new version, compile, and source code and runs unit testing.</p>
<p class="mce-root">Before we go any further, you should understand that without unit tests, or other automated tests, the effort of integrating pieces of code by different developers is very difficult. So, before you begin building pipelines, make sure that your developers have written test code. That way, you can make sure that the code is checked and at least adheres to certain quality checks.</p>
<p class="mce-root">If the unit tests succeed in your pipeline, the next step is to run integration tests. If they also succeed, the artefact that was built can be pushed or saved in a binary repository, or it can be directly deployed to a staging environment where the code will run.</p>
<p class="mce-root">Some pipelines can even be deployed to an acceptance or semi-production environment, where user validation of the solution built takes place. This is called <strong>Continuous Deployment</strong> (<strong>CD</strong>). Some call this Deployment to Production CD, but it depends on your definition of the concept.</p>
<p><span>Modern build software has the concept of building pipelines as part of their architecture. Products such as Jenkins have adopted it in their workflow, but cloud solutions, such as Azure DevOps (which is TFS in the cloud), have too.</span></p>
<p><span>You can find pipelines in GitLab for your project in the left-hand menu bar, under CI/CD, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a7efbc24-7051-4bce-a67f-47e2fdc7010e.png"/></p>
<p>The first item in the menu is a link to an overview of your <span class="packt_screen">Pipelines</span>. Here, you can see whether pipelines have passed or failed, retry pipelines, or download artifacts, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9296263c-f44e-447b-9d9e-0b146c846dca.png" style="width:7.67em;height:12.58em;"/></p>
<p>The second link in the menu takes you to the list of <span class="packt_screen">Jobs</span> for a project (which we will cover shortly), <span>as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f0310268-768a-45a5-9055-6cf0b6c23679.png"/></p>
<p>The third link is <span>a feature of GitLab CI called <span class="packt_screen">Schedules</span>. As you can see in the following screenshot, we have created a schedule for a run of the pipeline to be executed for the <kbd>Eventmanager</kbd> project:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/262c3e27-b64b-4615-a3fc-49ed283e8330.png"/></p>
<p>If you click an item in the schedule list, you will see that there are many configurable items in it. For example, you can specify which branch to run on, <span>as shown in the following screenshot</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e4f89993-7f54-4b94-98b6-560b4efd3978.png"/></p>
<p>A nice way of discovering more about your build is the chart feature in GitLab CI, where insight into the metrics of your pipelines is provided, <span>as shown in the following screenshot</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/14c93c65-ba93-484c-a366-a11572227a2f.png" style="width:56.08em;height:54.58em;"/></p>
<p class="mce-root"/>
<p><span>The following screenshot shows a high-level design of a pipeline that runs in GitLab:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dd062d76-bf43-4fe7-bbb9-46952976a161.png" style="width:58.00em;height:32.17em;"/></p>
<p>We have now demonstrated that GitLab CI incorporates the general concept of a build pipeline and also records several metrics about the successes or failures of the pipeline's steps. In the following section, we will take a look at these individual steps.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Jobs</h1>
                </header>
            
            <article>
                
<p><span>Pipeline configuration begins with jobs:</span></p>
<ul>
<li><span>Jobs are the most fundamental element of a pipeline and are executed by GitLab Runners</span></li>
<li><span>Jobs are created with constraints, which govern under what conditions they should be executed</span></li>
<li>Jobs are top-level elements that can have an arbitrary name and must contain the script element as a minimum requirement</li>
<li>There can be an unlimited number of jobs</li>
</ul>
<p class="mce-root"/>
<p><span>In the pipeline overview, you'll find several jobs. They have a status, an ID, are part of a stage, and have a name, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ea77f8a6-5477-4e65-b393-cffc656f2c7f.png"/></p>
<p>You can create jobs by adding them to a configuration file called <kbd>.gitlab-ci.yml</kbd>. We will discuss this file in more depth in the following section.</p>
<p><span>An example of a pipeline containing two jobs is as follows:</span></p>
<pre><span>job1:<br/></span><span> script: "execute-this-script-for-job1"<br/></span><span>job2:<br/></span><span> script: "execute-this-script-for-job2"</span></pre>
<p class="mce-root"><span>The preceding example is a basic CI/CD pipeline that consists of two named jobs (<kbd>job1</kbd> and <kbd>job2</kbd>), which execute a script section (in our example, this does nothing). In the script section, you can specify a command, script, or a chain of commands. For instance, to build a JavaScript, you can set <kbd>script</kbd> as <kbd>npm build</kbd> or run a shell unit test called <kbd>unit-test.sh</kbd>.</span></p>
<p class="mce-root">Jobs are not run on the GitLab application server, but are picked up by GitLab Runners. The runners execute the jobs in their own environment; for example, runner A can build <kbd>job1</kbd> and runner B can build <kbd>job2</kbd>. Note that the jobs are independent from each other. The results from these jobs are aggregated on the GitLab server.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating .gitlab-ci.yml</h1>
                </header>
            
            <article>
                
<p><span>How GitLab CI interacts with your profile is largely controlled by the <kbd>.gitlab-ci.yml</kbd></span> file<span>, which must be added to the root of your project. When you push code to your repository, GitLab will test whether it's there and start a pipeline with jobs for that specific commit.</span></p>
<p><span>The format of the file is <strong>YAML Ain't Markup Language</strong> (<strong>YAML</strong>). YAML is currently a widely used format for configuration files and is best described as a data serialization language.</span></p>
<p><span>We have already given you an example of a <kbd>.gitlab-ci.yml</kbd> file with two jobs in an earlier section. In other chapters, we used a <kbd>.gitlab-ci.yml</kbd> file to describe a deployment. So, what are the available possibilities of this file?</span></p>
<p>A lot of combinations are possible, but the fundamental way of working is to first define stages in the file and then add script sections. The complete reference of this file can be found here: <a href="https://docs.gitlab.com/ee/ci/yaml/README.html">https://docs.gitlab.com/ee/ci/yaml/README.html</a>.</p>
<p><span>When you are creating your YAML file, it is nice to know that, after saving, it will be checked by a linter to verify the syntax of the file, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/543779bd-93e2-49bb-acde-b542365a5ca6.png" style="width:24.17em;height:7.58em;"/></p>
<p>The possibilities for this file are endless, so the best way to figure out what works for you is to look at open source projects on the GitLab website for inspiration, available at: <a href="https://docs.gitlab.com/ee/ci/examples/README.html">https://docs.gitlab.com/ee/ci/examples/README.html</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring a runner</h1>
                </header>
            
            <article>
                
<p>We briefly described the concept of GitLab Runners in <a href="384dcfd9-ef7f-470d-89dc-3af7502a2d09.xhtml"/><a href="384dcfd9-ef7f-470d-89dc-3af7502a2d09.xhtml"/><a href="384dcfd9-ef7f-470d-89dc-3af7502a2d09.xhtml">Chapter 1</a>, <em>Introducing the GitLab Architecture</em>. Runners are essentially build environments that run on a separate machine that connects to the GitLab application's server and asks jobs to execute. Runners help to automate product development and achieve DevOps integration.</p>
<p><span>We configure a runner on the GitLab side, and on the GitLab Runner client side. Remember that there is not a single type of runner.</span></p>
<p><span>There are different kind of runners, including:</span></p>
<ul>
<li>A<span> Shell executor</span></li>
<li>A<span> Docker executor</span></li>
<li>A<span><span> Docker Machine and Docker Machine SSH (auto-scaling) executor</span></span></li>
<li>A<span> Parallels executor</span></li>
<li>A<span> VirtualBox executor</span></li>
<li>A SSH executor</li>
<li><span>A Kubernetes executor</span></li>
</ul>
<p><span>For the GitLab CI interface, this does not matter. All runners look the same.</span></p>
<p><span>The GitLab Runner clients are available on multiple platforms, as it is a Go binary that runs on many platforms. The configuration file is called <kbd>config.toml</kbd> and is in the TOML format, which is less complex than the YAML format.</span></p>
<p><span>The specification of this format is publicly available and can be found at <a href="https://github.com/toml-lang/toml">https://github.com/toml-lang/toml</a>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GitLab Runner features</h1>
                </header>
            
            <article>
                
<p>Features of GitLab Runner include the following:</p>
<ul>
<li><span>The ability to run multiple jobs concurrently</span></li>
<li><span>The use of multiple tokens with multiple servers (even per project)</span></li>
<li><span>The ability to limit the number of concurrent jobs per token</span></li>
</ul>
<p><span>The jobs GitLab Runner can execute can do the following:</span></p>
<ul>
<li><span>Run on a local computer without containers or virtualization</span></li>
<li><span>Run inside Docker containers</span></li>
<li><span>Run inside Docker containers</span> and execute<span> jobs over SSH</span></li>
<li><span>Run using Docker containers with autoscaling on different clouds and virtualization hypervisors</span></li>
<li><span>Run by connecting to a remote SSH server, where it can be executed</span></li>
</ul>
<p>Additional features include the following:</p>
<ul>
<li><span>GitLab Runner supports Bash, Windows Batch, and Windows PowerShell</span></li>
<li><span>The runner binary works on GNU/Linux, macOS, and Windows (all Docker-supported platforms)</span></li>
<li><span>A runner allows the customization of a job-running environment</span></li>
<li><span>A runner can have an automatic configuration reload without restart</span></li>
<li><span><span>It is to easy set up, with support for Docker, Docker SSH, Parallels, or SSH-running environments</span></span></li>
<li><span>Runners also support the caching of Docker containers</span></li>
<li><span>The Runner package supports installation as a service for GNU/Linux, macOS, and Windows</span></li>
<li><span>You can enable an embedded Prometheus metrics HTTP server in a runner</span></li>
</ul>
<p class="FirstParagraph"><span>You can find an overview of the registered runners in GitLab by logging in as an admin and checking the <span class="packt_screen">Runners</span> menu on the left, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c20b8547-3149-4f46-96c0-09fe409c9c24.png" style="width:8.17em;height:16.83em;"/></p>
<p>You should now see a list of runners that have registered on your GitLab instance, <span>as shown in the following screenshot</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ad7d5f65-5971-453d-875d-c20f1adf6aae.png"/></p>
<p>As shown in the following screenshot, if you click a runner, you will see that it is possible to do the following:</p>
<ul>
<li>Configure a paused runner not to accept new jobs</li>
<li>Designate a runner as protected</li>
<li>Set a runner to pick up jobs with or without tags</li>
<li>Lock a runner to projects</li>
<li>Set a maximum timeout for a job</li>
<li>Tag runners</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8d4c1934-181d-4bb0-b415-37e0beef9419.png" style="width:59.42em;height:33.50em;"/></p>
<p>On the left, you will be able to see which jobs have been recently processed by a runner, <span>as shown in the following screenshot</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/683b67da-934c-43b0-8554-541e9e528d0c.png" style="width:34.08em;height:9.42em;"/></p>
<p>So far, you have seen how GitLab CI fits in with the GitLab product and also how GitLab Runners are registered with an instance. <span>We have also looked at the basic features of GitLab Runners and showed you how to create a configuration file for jobs to be picked up and executed by a runner.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="FirstParagraph"><span>In this chapter, we discussed GitLab CI, the most critical feature of GitLab after offering version control. We explained how to trigger pipelines and how to design them using the <kbd>.gitlab-ci.yml</kbd> file. Then, we showed you the jobs that make up the pipelines. We finished with some information on how GitLab runners fit into this architecture. In the next chapter, we are going to show you more about the GitLab Runner client.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">Name one of the pillars of Extreme Programming.</li>
<li>What file is used to describe jobs and pipelines?</li>
<li><span>How does a build system know when to build software in a pipeline?</span></li>
<li>What tests are necessary for reaching the integration phase?</li>
<li><span>Which tag is used in the <kbd>.gitlab-ci.yml</kbd> file to execute a job?</span></li>
<li><span>What is the name of the configuration file used by the runner?</span></li>
<li><span>How many concurrent sessions can a runner start?</span></li>
<li><span>How can you get metrics about the execution of a GitLab runner?</span></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li><em>gRPC [Golang] Master Class: Build Modern API and Microservices [Video]</em> <span>by <em>Stephane Maarek</em>: </span><a href="https://www.packtpub.com/web-development/grpc-golang-master-class-build-modern-api-and-microservices-video">https://www.packtpub.com/web-development/grpc-golang-master-class-build-modern-api-and-microservices-video</a><span>.</span></li>
<li><em>Hands-On Auto DevOps with GitLab CI [Video]</em> by <em>Alan Hohn</em>: <a href="https://www.packtpub.com/in/application-development/hands-auto-devops-gitlab-ci-video">https://www.packtpub.com/in/application-development/hands-auto-devops-gitlab-ci-video</a>.</li>
</ul>


            </article>

            
        </section>
    </body></html>