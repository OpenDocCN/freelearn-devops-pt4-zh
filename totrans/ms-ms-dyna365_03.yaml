- en: Mastering a Modern Development Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced Dynamics 365 Business Central and revealed
    that its skeleton is Microsoft cloud microservices.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take a close look at the development environment. We
    will discuss the main shortcuts, tips, and tricks related to Visual Studio Code,
    the official development platform, and the AL language, the development language
    extension. The union between Visual Studio Code and AL defines the so-called modern
    development environment.
  prefs: []
  type: TYPE_NORMAL
- en: AL is the official extension provided by Microsoft, free of charge, through
    the online marketplace. Officially released in 2017 to extend what was then called
    Dynamics 365 for Financials, it is now a solid fully fledged development language
    that extends Dynamics 365 Business Central. It comes equipped with a lot of features
    that greatly enhance developers' productivity and coding quality.
  prefs: []
  type: TYPE_NORMAL
- en: The main goal of this chapter is to help Dynamics 365 Business Central developers
    understand what the development platform offers, unleash all their potential,
    and become proficient in their daily coding activities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What the Visual Studio Code user interface is composed of, and the purpose of
    each section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to be proficient in using the most powerful Visual Studio Code editing features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the AL language extension is, and what it consists of
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering Visual Studio Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio Code is one of the most widely used development environments worldwide.
    It is engineered to make it easy and quick to design cloud- and web-based applications,
    using a plethora of extensible languages. The application is focused on maximizing
    code editing and also unleashing the developer's potential by providing useful
    shortcuts to provide quick access to all that is needed in a specific development
    context.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you start Visual Studio Code, freshly installed, it will show you the
    typical Welcome page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7f9c7c7-a01f-41c0-b3ca-69be7d020562.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Welcome page contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start**: Shortcuts for creating and opening files and folders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recent**: A list of recently opened files and folders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Help**: A list of documentation sheets, product docs, videos, and useful
    resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customize**: How to customize Visual Studio Code through extensions, keyboard
    shortcuts, background color themes, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Learn**: Additional shortcuts to learning resources that are related to the
    most widely used commands, and how to master the user interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Welcome page is loaded whenever you run the Visual Studio Code as a new
    window (*Ctrl* + *Shift* + *N*). It is possible to change this behavior by unchecking
    show welcome page on startup or clicking File | Preferences | Settings and searching
    for Welcome page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Visual Studio Code environment is divided into five main areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Code editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Status bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sidebar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Panels area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at each of them in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Code editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code editor is where you write your code and where you spend most of your
    time. It is activated when creating a new file, or when opening an existing file
    or folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are allowed to edit just one single file, or you can even load and work
    with multiple files at the same time, side by side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f708006-72d4-4eb9-8294-030702726dc6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are different ways to have multiple file views; three are mentioned here:'
  prefs: []
  type: TYPE_NORMAL
- en: Select a filename in the EXPLORER bar, then right-click and select Open to the
    Side (*Ctrl* + *Enter*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl* + click on a filename in the EXPLORER bar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl* + *\* to split the editor into two parts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will accommodate several files, dividing the space equally between them.
    You can move through the different file editors by simply pressing *Ctrl* + *1*,
    *Ctrl* + *2*, *Ctrl* + *3*, …, *Ctrl *+ *N*.
  prefs: []
  type: TYPE_NORMAL
- en: Editor windows can be resized, reordered, and zoomed in/out according to your
    needs. To zoom in/out press *Ctrl* + *+ */ *Ctrl* + *-*, or View | Zoom in / Zoom
    out.
  prefs: []
  type: TYPE_NORMAL
- en: Zooming applies to all Visual Studio Code areas, not only to the code editor.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code also provides an easy way of navigating between files with
    shortcuts. The quickest way is to press *Ctrl* + *Tab*. This will open the list
    of files that have been opened since Visual Studio Code started.
  prefs: []
  type: TYPE_NORMAL
- en: Status bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The status bar typically contains information about the currently selected
    file or folder. It also provides some actionable shortcuts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27851c2c-a1e8-4fac-acbd-16d4361fabe5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From left to right, the status bar contains the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: If Git is enabled, it will report version control information, such as the current
    branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Number of errors and/or warnings detected in the current code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cursor position (line position and column position).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Indentation size and type (spaces or tabs).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encoding of the currently selected file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Line terminator: **Carriage return** (**CR**) and/or **line feed** (**LF**).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Language used to process the code in the selected file. If you click on the
    language, a menu will appear, and you should be able to change the processing
    programming language.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feedback button, which you can use to share your feedback about Visual Studio
    Code on Twitter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notification icon. This shows the number of new notifications, which are typically
    related to product updates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The status bar has a conventional colorization, and it changes depending on
    what's processing. It is purple when opening a file, blue when opening a folder,
    orange when debugging, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: View bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is on the left side of the workspace, and contains shortcuts to the sidebar.
    If a shortcut is clicked, the sidebar that belongs to the tool that has been chosen
    becomes visible. Clicking again, or pressing *Ctrl* + *B*, makes it disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Sidebar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sidebar is the place where you will interact the most with the code editor.
    It is context-sensitive, and you will find five standard activities, each enabled
    by the corresponding icon in the view bar.
  prefs: []
  type: TYPE_NORMAL
- en: EXPLORER (Ctrl + Shift + E)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'EXPLORER provides a structured and organized view of the folder and files that
    you are currently working with. The OPEN EDITORS sub-view contains the list of
    active files in the code editor. Below this section, there might be another sub-view
    with the name of the folder that is open:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa48f11f-e75f-46e3-ab38-92cc85b3ed93.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you hover over the OPEN EDITORS sub-view, three action buttons will be shown:
    Toggle Vertical/Horizontal Editor Layout (*Shift* + *Alt* + *O*), Save All (*Ctrl*
    + *K* + *S*), and Close All Files (*Ctrl* + *K* or *Ctrl* + *W*). They are all
    self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c29f2344-95cf-4321-922a-994a3d1a1382.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Hovering over the folder name (in this example `PW_V2`) will make four action
    buttons visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c92ee73d-c3bd-45d5-93e2-c3482cba03e4.png)'
  prefs: []
  type: TYPE_IMG
- en: From left to right, these are New File, New Folder, Refresh, and Collapse All.
    They are self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: Right-clicking on a folder or filename will open a context menu that shows common
    commands such as Reveal in Explorer(*Shift* + *Alt* + *R*), which opens the folder
    that contains the selected file. You can also copy the file path via Copy Path (*Shift*
    + *Alt* + *C*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Down in the EXPLORER bar, there is another section called OUTLINE. It gives
    a very useful tree-view of members and types for a specific file. Consider the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc0c3d16-ed4a-416d-85ef-30d6fa793a63.png)'
  prefs: []
  type: TYPE_IMG
- en: This is indeed a powerful option when you are developing complex objects and
    you want to jump into a specific area in one click.
  prefs: []
  type: TYPE_NORMAL
- en: SEARCH (Ctrl + Shift + F)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a powerful tool for searching for and replacing text in files. It is
    possible to opt for a simple search with one or more keywords, and you can use
    wildcards such as * and ?. Alternatively, you can opt for creating a complex search
    based on regular expressions (regex). There are also advanced options to include
    and/or exclude files or file types.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is really helpful for developers when searching the *where used* field
    or variables in all files within an extension folder. Consider the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5654c6c-42b5-45b6-a987-ac5e247a165b.png)'
  prefs: []
  type: TYPE_IMG
- en: Search outputs are listed in a tree-view that lists all files containing the
    search keyword, and shows a small piece of code related to the line that they
    belong to in the file. The keyword match is highlighted in the tree-view, as well
    as within the code editor. These can be all collapsed by clicking the Collapse
    All button.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to reset the search results by clicking the Clear Search Results button.
  prefs: []
  type: TYPE_NORMAL
- en: SOURCE CONTROL (Ctrl + Shift + G)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Visual Studio Code provides native integration with one of the most widely
    known source control management systems: Git. The basics and integration of Git
    will be discussed in [Chapter 11](bc01dacb-fdbe-496b-82a0-e45d2435e574.xhtml),
    *Source Control Management and DevOps with Business Central*.'
  prefs: []
  type: TYPE_NORMAL
- en: DEBUG (Ctrl + Shift + D)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio Code is not just a code editor for editing flat files. It also
    ships with an out-of-the-box integrated debugger framework that can be extended
    to debug different platforms and languages.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code does not provide any debugging capability for Dynamics 365
    Business Central. This comes embedded in the AL language extension for Visual
    Studio Code, which extends the existing .NET core debugger. In [Chapter 9](076505ca-e2a0-40ab-8640-c720c9aa68ee.xhtml),
    *Debugging*, we will discuss this argument in detail.
  prefs: []
  type: TYPE_NORMAL
- en: EXTENSIONS (Ctrl + Shift + X)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extensions are used to browse the online marketplace for extensions for Visual
    Studio Code, which include a growing plethora of additional languages, debuggers,
    tools, helpers, and much more. AL is an extension for Visual Studio Code that
    was developed by Microsoft. In the Visual Studio Code marketplace, you can also
    download several helpful extensions that extend (extensions for an extension)
    the AL Language extension and help Dynamics 365 Business Central developers be
    more efficient and productive and write code professionally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following screenshot, which shows typical Visual Studio Code extensions
    installed for Dynamics 365 Business Central:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d275b3b5-962b-4c68-96a5-cf7c8c157c41.png)'
  prefs: []
  type: TYPE_IMG
- en: In the EXTENSIONS bar, it is possible to search the online marketplace or install
    an extension manually. You can also see the list of installed, outdated, recommended,
    and disabled extensions and sort them according to different criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Some extension packages are meant to download and install a set of extensions.
    With Dynamics 365 Business Central, you might think of downloading and installing
    AL Extension Pack from [https://marketplace.visualstudio.com/items?itemName=waldo.al-extension-pack](https://marketplace.visualstudio.com/items?itemName=waldo.al-extension-pack) or
    SD Extension Pack for Dynamics 365 Business Central from [https://marketplace.visualstudio.com/items?itemName=StefanoDemiliani.sd-extpack-d365bc](https://marketplace.visualstudio.com/items?itemName=StefanoDemiliani.sd-extpack-d365bc).
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to perform actions on a single extension by right-clicking
    on it. An extension could be enabled, disabled, disabled per workspace (a workspace
    could be a project or a folder), and so on. One of the newest – and coolest –
    features that has been added is the ability to install another version of the
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is very useful for Dynamics 365 Business Central developers, in case there
    are regression behaviors or bugs in high-AL Language extension versions. Consider
    the following screenshot, which shows the current online AL Language extension
    versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61b66e0d-7a6a-4415-ae84-9a75f4efa0e6.png)'
  prefs: []
  type: TYPE_IMG
- en: This is also useful when developments target a specific platform version.
  prefs: []
  type: TYPE_NORMAL
- en: Manage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Manage button is shown with a gear icon at the very bottom of the view
    bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78f519d1-07cc-4959-9bc8-1d0cccf3c727.png)'
  prefs: []
  type: TYPE_IMG
- en: If you click on it, a pop-up menu with a list of commands appears. These commands
    are used to customize Visual Studio Code, or to search for updates.
  prefs: []
  type: TYPE_NORMAL
- en: Command Palette
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Command Palette is one of the most important tools in Visual Studio Code.
    Its purpose is to give quick access to standard and extended commands. There are
    different ways to run the Command Palette:'
  prefs: []
  type: TYPE_NORMAL
- en: Manage | Command Palette
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View | Command Palette
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keyboard shortcut: *Ctrl* + *Shift* + *P* (mostly used by all developers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Command Palette is not only good for showing menu commands, but it can also
    perform other actions, such as installing extensions. You can browse through it
    to review the huge list of available commands. Commands are indexed and searchable.
    Just type a few letters to get a filtered list. It's worth mentioning the long
    list of keyboard shortcut(s) that are available for most of these commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'One very important thing to know about the Command Palette is the use of the `>` sign.
    When you press *Ctrl* + *Shift* + *P*, the Command Palette pops up with the `>` sign
    and shows the list of commands available. Consider the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a066bda5-23f0-4bb2-8513-3393964c45d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you remove the `>` symbol, Visual Studio Code uses the Command Palette to
    show a list of the recently opened files. The following screenshot shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b7b15e3-3221-4eec-a1eb-fa5af09c2265.png)'
  prefs: []
  type: TYPE_IMG
- en: The power of this feature is that, without using the mouse, you can open the
    Command Palette, run a command, remove the `**>**` character, and select a file
    to edit. That's fantastic for development productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Panels area
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio Code not only shows detailed analysis and information related
    to your code, but also has access and display information coming from other sources
    such as Git, installed extensions, and debuggers. These outputs are logged into
    the panels area, which, by default, is at the bottom, but could be easily moved
    to one side of the workspace using the Move Panel Right button, enabled by right-clicking
    on the panel's title bar. It is possible to restore the original layout with the
    Move Panel to Bottom button, or even Hide Panel (*Ctrl* + *J*).
  prefs: []
  type: TYPE_NORMAL
- en: The Panels area is not visible by default. It is typically enabled and shown
    when the information needed is requested, such as when the debugger is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Panels area, there are four different windows: PROBLEMS, OUTPUT, DEBUG
    CONSOLE, and TERMINAL. Let''s examine them in the following sections.'
  prefs: []
  type: TYPE_NORMAL
- en: PROBLEMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With languages that have advanced editing features, such as AL, Visual Studio
    Code is able to identify code problems while typing. Problems lines have a specific
    colorization. There are three types of notifications: errors, warnings, and info.
    All of these can be shown in the PROBLEMS window. The following screenshot shows
    an example of the PROBLEMS window showing three errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad029571-2909-437c-b64e-357397394937.png)'
  prefs: []
  type: TYPE_IMG
- en: Typically, blocking errors are shown in red, while warnings are marked in green.
  prefs: []
  type: TYPE_NORMAL
- en: OUTPUT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The OUTPUT panel is the place where Visual Studio Code typically displays messages
    during or after command execution.
  prefs: []
  type: TYPE_NORMAL
- en: Because built-in tool actions and multiple extension commands can run concurrently,
    it is possible to make use of a drop-down box in the OUTPUT panel to change the
    view, and see the output for each standard or extension-based command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the OUTPUT window in the Panels area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c61fee8b-c3b0-4b1c-9d02-81aad6e2ada3.png)'
  prefs: []
  type: TYPE_IMG
- en: Typically, when working with Dynamics 365 Business Central extensions, the AL
    language is selected.
  prefs: []
  type: TYPE_NORMAL
- en: DEBUG CONSOLE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a special window used by native and extension-based debuggers, such
    as the AL language debugger, to display information about code execution. This
    window and its output will be analyzed in detail in [Chapter 9](076505ca-e2a0-40ab-8640-c720c9aa68ee.xhtml), *Debugging*.
  prefs: []
  type: TYPE_NORMAL
- en: TERMINAL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio Code allows us to execute commands in the same way as the Command
    Prompt, directly from within the development environment. The Terminal session
    is based on PowerShell by default.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all elements that are in related to Visual Studio Code place,
    we can move onto the next section and analyze the powerful editing features that
    it offers.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code – the editing features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio Code provides many of the features that you would expect from
    the best-in-class code editor. If you are familiar with Visual Studio, you might
    have noticed that some features have been inherited from this IDE, or engineered
    in a similar way.
  prefs: []
  type: TYPE_NORMAL
- en: '*Developed by developers for developers*, Visual Studio Code has keyboard shortcuts
    for almost every editing command, giving you the option to edit code faster, and
    completely forget about the mouse.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's study these features in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Comment lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio Code provides out-of-the-box commands for text selection and professional
    editing in the Edit menu. The Edit menu also includes Toggle Line Comment (*Ctrl *+ *U*),
    which adds a line comment for the selected line. This means that if you select
    10 lines of code, Visual Studio Code will add 10 comment lines. The beauty of
    this command is that it works in reverse as well. If you select the 10 commented
    lines and press Toggle Line Comment, the comments will be magically removed.
  prefs: []
  type: TYPE_NORMAL
- en: For developers working with CSIDE, the old legacy language for on-premises Dynamics
    365 Business Central, this command is the equivalent of Comment Selection (*Shift*
    + *Ctrl* + *K*) and Uncomment Selection (*Shift *+ *Ctrl *+ *O*).
  prefs: []
  type: TYPE_NORMAL
- en: Delimiter matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Visual Studio Code is capable of detecting pairs of delimiters, such as brackets
    and parentheses. This feature is really helpful if you want to delimit code blocks,
    and it kicks in when the mouse is placed near one of the delimiter pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89e5b9dc-75f4-43e5-9c85-af684ad075a4.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding code is an example ofdelimiter matching.
  prefs: []
  type: TYPE_NORMAL
- en: Text selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Selection menu also has commands that relate to text selection, but most
    of them are used to move or duplicate lines of code above and below the selected
    line.
  prefs: []
  type: TYPE_NORMAL
- en: If you position the cursor near an AL function, variable, or constant, you can
    use Add Next Occurrence (*Ctrl* + *D)*, Add Previous Occurrence, or Select All
    Occurrence***s*** (*Shift* + *Ctrl* + *D*) to select occurrences of the selected
    item, and occurrences will be highlighted in a different color.
  prefs: []
  type: TYPE_NORMAL
- en: In the code editor, you can also press *Ctrl* + *D* for a word or identifier
    selection on the right of the cursor. You can then easily expand (*Shift* + *Alt*
    + →) or shrink (*Shift* + *Alt* + ←) text blocks within delimiters.
  prefs: []
  type: TYPE_NORMAL
- en: Code block folding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you hover over line numbers in the code editor, a `-` will appear close
    to the initial part of a code block. Click on it to fold it, and a `+` will appear.
    Click on this, and the code block unfolds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5002d69-7f9f-4594-872c-e0e05641d6c0.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the code block folding depicted with `+`.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple cursors (or multi-cursor)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each cursor operates independently. *Alt* + click will generate a secondary
    cursor at the desired position.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common development situation in which you want to go for multiple
    cursors is when you need to add or replace the same text in different positions,
    but within the same source file. The following screenshot shows three cursors
    in action when editing the `DataClassification` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9cc8d80f-aa7b-42ec-be6f-c5919670e0fb.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a great feature for AL language developers, especially when they have
    to write down the same sentence many times in the same place (for example, `Caption` or `DataClassification`
    in a table object and for each table field).
  prefs: []
  type: TYPE_NORMAL
- en: Mini-map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, when working with very long files such as report source files (RDLs)
    or codeunits, it is pretty difficult to know where the pointer should be positioned
    – or is positioned – within a source file. Visual Studio Code has a full-fledged
    mini-map feature: a small preview of the source code file. The following is an
    example of an RDL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/feba5994-d844-48b3-8842-e3a1040feaf7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The mini-map feature can be disabled/enabled through View | Toggle Minimap,
    or by running the Command Palette (*Ctrl* + *Shift* + *P*) and selecting View:
    Toggle Minimap.'
  prefs: []
  type: TYPE_NORMAL
- en: Breadcrumbs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Show Breadcrumbs command is available in the View menu. With AL files,
    there is an icon in the top-left corner of the code editor. This can be expanded
    to double-check the definitions of properties, functions, fields, keys, and so
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49acd2a0-3d17-436b-b698-7b3cf2032347.png)'
  prefs: []
  type: TYPE_IMG
- en: If you click on an element in the expanded list, the cursor will jump to its
    primary definition, making code navigation quite fast.
  prefs: []
  type: TYPE_NORMAL
- en: IntelliSense
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In visual editors, IntelliSense is a word completion tool that appears as a
    pop-up list while you type. Visual Studio Code IntelliSense can provide smart
    suggestions, showing the definition and purpose – like online help – related to
    a specific element. The following screenshot shows IntelliSense in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efe59c67-97ef-442c-bfaa-c34e8d82c6fa.png)'
  prefs: []
  type: TYPE_IMG
- en: IntelliSense is context-sensitive, and if you need to enable it directly without
    typing anything, just press *Ctrl* + spacebar. Depending on the context where
    the cursor is placed, IntelliSense will show all the items that can be used in
    that context. For example, inside a `Table Field` declaration, it will list all
    the specific field properties, such as `Caption` and `CaptionML`, while in an
    empty codeunit definition, it will show all the properties that are exposed by
    a codeunit object.
  prefs: []
  type: TYPE_NORMAL
- en: Word completion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Through the IntelliSense feature, the code editor in Visual Studio Code implements
    word completion for all native (such as JSON) and extension-based supported languages
    (such as AL). Just press *Enter* or *Tab* to insert the suggested word:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cf2e797-aaba-49c1-90b1-8fc4ee162fdd.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows an AL variable suggested by the word completion
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: The Go To Definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a super-cool, must-know feature. You can hover over a variable, constant,
    function, or whatever code element you want with the mouse, and if you press *Ctrl*,
    the word or identifier (known also as a symbol) will magically switch into a hyperlink.
  prefs: []
  type: TYPE_NORMAL
- en: If you click on the word while pressing *Ctrl*, you will be automatically redirected
    to the code that defines that word. *Ctrl* + hovering over a code element also
    enables the Go To Definition feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other possible ways to enable this feature are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Select a code element and press *F12*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right-click on a code element and then select Go To Definition from the context
    menu.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find All References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Find All References makes it very easy to parse how many times and where an
    object, a function, or any code element has been used across source code. You
    can simply right-click on any variable, function, or element name and then select
    Find All References, or use the keyboard shortcut *Shift* + *Alt* + *F12*.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it''s enabled, the code editor will create a result list in the activity
    bar showing how many times it has been referenced, and in which object files and
    position(s). A shortcut icon is created in the sidebar called References. The
    following screenshot shows how to find all references in AL files for a specific
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8a84e83-55b5-4157-9ae4-69c40c107ff6.png)'
  prefs: []
  type: TYPE_IMG
- en: If you expand an occurrence in the reference list on the left and click on a
    record, the code editor will open the file where it is referenced and position
    the cursor in editing mode, selecting the element searched in that file.
  prefs: []
  type: TYPE_NORMAL
- en: The reference list can be cleared and refreshed, and you can collapse all the
    elements in it. If you clear the list, you can always run the previous search
    again, since the history is maintained for you.
  prefs: []
  type: TYPE_NORMAL
- en: Peek Definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you have a large number of code files, and you need to edit the
    definition of a variable or field that you are currently using. With many other
    editors – or development environments – you most likely have to save all the files
    in text format, then search through all these code files and be sure to replace
    that variable name. This task not only can be annoying, but can also distract
    you from the original code you were writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio Code brilliantly solves this problem by providing the Peek feature,
    which can be enabled in different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click a variable, field, or function name and select Peek Definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the *Alt* + *F12* keyboard shortcut.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An interactive pop-up window should appear, showing source code that defines
    the selected element. The following screenshot shows the Peek Definition for a
    table source in a report:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/067889db-7662-4f38-ade8-fe051f70dbc0.png)'
  prefs: []
  type: TYPE_IMG
- en: You can then see what has been written, and also directly edit it.
  prefs: []
  type: TYPE_NORMAL
- en: Renaming symbols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a developer, it is very common to rename a variable, constant, field, or
    function name. These coding elements are technically called symbols. Visual Studio
    Code provides a very powerful feature to rename symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you press *F2* on the coding element that you wish to rename, or right-click
    and then select Rename Symbol, a small interactive popup appears in edit mode.
    There, you can write the new element name without using a distracting dialog window,
    allowing you to concentrate on your coding. All references to that code element
    will be renamed accordingly. The following screenshot shows renaming the XMLport
    symbol reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79a77faa-f447-4432-b5bd-aa42e2566001.png)'
  prefs: []
  type: TYPE_IMG
- en: All of the features shown so far are the most useful features provided by Visual
    Studio Code that support proficient code editing for AL developers.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, it is important to take a closer look at the AL Language extension
    and see how to configure it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the AL Language extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AL is now a cross-platform language that is deployed through an extension for
    Visual Studio Code. This extension not only supports deployment on Windows OSes,
    but is also supported for the macOS version of Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: The free AL Language extension ([https://marketplace.visualstudio.com/items?itemName=ms-dynamics-smb.al](https://marketplace.visualstudio.com/items?itemName=ms-dynamics-smb.al))
    is available for download from the Visual Studio Code marketplace. This provides
    an optimized experience for Dynamics 365 Business Central extension development,
    and includes all the support and tools that you need to build apps (from now on,
    a synonym for extension), including the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to get the extension installed without further information
    is by opening any Dynamics 365 Business Central code file (`.al`) and following
    the instructions shown by Visual Studio Code when it detects that an extension
    is available for that file type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e2e7c53-68da-48b4-a4fa-bbc04c788db0.png)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, you might want to install other extensions that add other languages
    (such as PowerShell), tools (such as Docker), or enhanced editing features to
    the AL Language extension. A list of the most useful marketplace extensions used
    by Dynamics 365 Business Central in combination with AL Language will be provided
    in [Chapter 18](00676a8a-c821-432e-b39f-4f39ea2c55f9.xhtml), *Useful and Proficient
    Tools for AL Developers*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand what these extensions are in AL Language in the sections ahead.
  prefs: []
  type: TYPE_NORMAL
- en: AL Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Created by the Dynamics 365 Business Central development team, AL Language is
    the official Visual Studio Code extension for developing apps for small, single-tenant
    personalization's and complex add-on vertical solutions that are deployed through
    the online Dynamics 365 Business Central AppSource marketplace.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be deployed in two different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Directly, as a downloadable package from the Visual Studio Code marketplace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Manually, as an installable package (`.vsix`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The installable package is dispatched when creating a Docker-contained sandbox
    from the official Dynamics 365 Business Central image.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloaded from Dynamics 365 Business Central on-premises DVD.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To start directly with AL Language, simply download it from the marketplace
    by following these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Extensions view bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the search field, type Dynamics 365 Business Central.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select AL Language.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on Install and when the installation finishes, reload Visual Studio Code
    as requested. It shows the following AL Language extension:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c45e562c-0b5f-43a5-a69c-693260ebbcf1.png)'
  prefs: []
  type: TYPE_IMG
- en: The AL Language build number, also known as the development build, is shown
    close to the title. In the preceding screenshot, the AL Language development build
    (or runtime) is `4.0.182565`.
  prefs: []
  type: TYPE_NORMAL
- en: The development build is very important, because new language features and enhancements
    are typically not backported to older builds, so they could be outdated and not
    compatible with the more recent Dynamics 365 Business Central platform updates.
  prefs: []
  type: TYPE_NORMAL
- en: AL developers should always select the latest AL Language development build
    in order to benefit from the latest enhancements and stability features.
  prefs: []
  type: TYPE_NORMAL
- en: 'The AL Language development model relates to creating, editing, and organizing
    flat text files with the typical `.al` extension. In short: AL Language development
    is simply folder and file based.'
  prefs: []
  type: TYPE_NORMAL
- en: It's worth mentioning that the Visual Studio Code terminology calls a root folder
    a workspace. The AL Language root folder represents the source code container
    for an extension. Therefore, the AL Language root folder is also called the Visual
    Studio Code development workspace.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating whatever kind of extension, the workspace consists of the following
    items:'
  prefs: []
  type: TYPE_NORMAL
- en: '`launch.json` file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.json` file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbol files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.al` object files (such as table, page, report, and codeunit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complementary files (such as `WebService.xml` files, the extension logo in `.bmp`
    format, and the `permissions.xml` file)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will analyze AL Language objects and complementary files in more depth all
    throughout this book and in later chapters. We will focus now on the backbone
    of the app development: `launch.json`, `app.json`, and symbol files.'
  prefs: []
  type: TYPE_NORMAL
- en: launch.json
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This file is stored in the extension workspace in a subfolder called `.vscode` and
    mainly determines the specific parameter settings for downloading and uploading
    AL Language commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the download and upload AL commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Download commands** | **Upload commands** |'
  prefs: []
  type: TYPE_TB
- en: '| `AL: Download symbols` | `AL: Publish` (*F5*) |'
  prefs: []
  type: TYPE_TB
- en: '| `AL: Download source code` (*F7*) | `AL: Publish and open in the designer`
    (*F6*) |'
  prefs: []
  type: TYPE_TB
- en: '|  | `AL: Publish without debugging` (*Ctrl* + *F5*) |'
  prefs: []
  type: TYPE_TB
- en: '|  | `AL: Rapid Application Publish` (*Alt* + *F5*) |'
  prefs: []
  type: TYPE_TB
- en: '|  | `AL: Rapid Application Publish without debugging` (*Ctrl* + *Alt* + *F5*)
    |'
  prefs: []
  type: TYPE_TB
- en: 'It is also used just to establish a connection, as in the case of AL: debug
    without the publishing (*Ctrl* + *Shift* + *F5*) command, or to launch a specific
    debugging feature such as AL: open Event Recorder. The Event Recorder feature
    will be covered in [Chapter 9](076505ca-e2a0-40ab-8640-c720c9aa68ee.xhtml), *Debugging*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `launch.json` file is a JSON array that might have different JSON values,
    each representing a set of attributes targeting different deployment: on-premises
    or SaaS. Attributes could be mandatory or optional, depending on the target deployment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the `launch.json` attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute** | **Mandatory** | **Deployment type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Name` | Yes | All | Name shown in the debugger window to identify the set
    of launch parameters.Default values: Publish to your own server (on-premises),
    Publish to Microsoft cloud (SaaS). |'
  prefs: []
  type: TYPE_TB
- en: '| `Type` | Yes | All | Constant value: `al`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Request` | Yes | All | Constant value: `launch`. |'
  prefs: []
  type: TYPE_TB
- en: '| `startupObjectType` | No | All | Object type to run after publishing: Table
    or Page. |'
  prefs: []
  type: TYPE_TB
- en: '| `startupObjectId` | No | All | Used together with `StartupObjectType`.Defines
    the object ID to run. |'
  prefs: []
  type: TYPE_TB
- en: '| `tenant` | No | All | AAD tenant (SaaS) or tenant name (on-premises with
    multitenancy) to connect to extract symbols and/or publish the app package. |'
  prefs: []
  type: TYPE_TB
- en: '| `sandbox` | No | Online | Specifies the sandbox name in case of multiple
    online sandboxes created for the same AAD tenant. |'
  prefs: []
  type: TYPE_TB
- en: '| `breakOnError` | No | All | Specifies whether the debugger should stop when
    an error occurs.Default value: `true`. |'
  prefs: []
  type: TYPE_TB
- en: '| `breakOnErrorWrite` | No | All | Specifies whether the debugger should stop
    on record changes (insert, modify, and delete).Default value: `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `schemaUpdateMode` | No | All | Determines the data synchronization mode.`Synchronize`:
    This is the default value. If there is already data deployed for this extension,
    it will be preserved and not removed. The extension metadata will be synchronized
    with the existing one, if any.`Recreate`: Wipe out previous metadata (tables and
    table extensions, typically) and use the new metadata from scratch.`ForceSync`:
    Force the schema synchronization. This should be used with extreme caution since
    it might lead to data loss scenarios. |'
  prefs: []
  type: TYPE_TB
- en: '| `DependencyPublishingOption` | No | All | This parameter was introduced with
    the Dynamics 365 Business Central Fall 2019 update. It applies in complex environments
    where multiple dependent apps are loaded from the same root folder. Possible values
    are as follows:`Default`: Enable rebuilding and publishing of all dependent apps.`Ignore`:
    Does not apply dependency publishing. This option should be used quite carefully
    since it risks breaking existing interdependent solutions.`Strict`: Publishing
    will fail if there are any installed extensions that have a dependency on the
    startup folder. |'
  prefs: []
  type: TYPE_TB
- en: '| `Server` | Yes | On-premises | Server name. Default value: `http://localhost`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `serverInstance` | Yes | On-premises | Dynamics 365 Business Central Server
    service name. |'
  prefs: []
  type: TYPE_TB
- en: '| `authentication` | Yes | On-premises | Authentication type: Windows or User
    Password.At the time of writing, AAD is not supported for on-premises deployment
    and it is the default, and only, value for online deployments. |'
  prefs: []
  type: TYPE_TB
- en: '| `Port` | No | On-premises | Dynamics 365 Business Central port number.Default
    value: `7049`. |'
  prefs: []
  type: TYPE_TB
- en: '| `applicationFamily` | No | AppSource | Used to develop an embedded extension
    for AppSource. This is a tag for Microsoft to determine the targeted upgrade operation
    if specific AppSource extensions have been deployed in the tenant. |'
  prefs: []
  type: TYPE_TB
- en: '| `launchBrowser` | No | All |'
  prefs: []
  type: TYPE_TB
- en: Specifies whether or not to launch a browser when publishing extensions.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `enableLongRunningSqlStatements` | No | All |'
  prefs: []
  type: TYPE_TB
- en: Enable the capability of displaying long-running T-SQL statements while debugging.
    This feature is planned to work for on-premises and online sandbox environments.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `enableSqlInformationDebugger` | No | All | Enable the capability of retrieving
    T-SQL query info. This feature is planned to work for on-premises and online sandbox
    environments.  |'
  prefs: []
  type: TYPE_TB
- en: If you have set up more than one value in the JSON array, when you perform upload
    or download AL Language commands, you will be prompted to choose one of the parameter
    set names defined in the JSON array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot is an example of a `launch.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fce6197b-48ec-4bbf-9e6f-995eb2dc5204.png)'
  prefs: []
  type: TYPE_IMG
- en: This shows the file with two parameter set values.
  prefs: []
  type: TYPE_NORMAL
- en: app.json
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically stored in the extension workspace root folder, this represents the
    app manifest written in JSON. Inside the JSON file, there are parameters referencing
    base and system applications, and platform and runtime definitions.
  prefs: []
  type: TYPE_NORMAL
- en: These terms need to be well understood when developing for Dynamics 365 Business
    Central.
  prefs: []
  type: TYPE_NORMAL
- en: System and base application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the Fall 2019 update, Microsoft converted all legacy C/AL code into AL
    objects. Currently, the big application monolith has been split into two apps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**System application**: with approximately 200 objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Base application**: depending on the localized version, it spans from 6,000
    to 8,000 objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To be extended, these need to be referenced as dependencies in the `app.json`
    file, and their symbols pulled on-premises or from an online sandbox through the `AL:
    Download symbols` AL Language command.'
  prefs: []
  type: TYPE_NORMAL
- en: When pulled in the `.alpackages` folder, they are typically referenced through
    a version number in the major, minor, build, and revision notations, and this
    is reflected in the name of the symbols that are downloaded (for example, `Microsoft_System
    Application_15.0.36560.0` and `Microsoft_Base Application_15.0.36626.36918`).
  prefs: []
  type: TYPE_NORMAL
- en: The major version digit typically corresponds to the Dynamics 365 Business Central
    major update release.
  prefs: []
  type: TYPE_NORMAL
- en: The October 2019 (or Fall 2019) release update is major version 15\. The Spring
    2020 (or April 2020) update release will be major version 16, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The minor version typically corresponds to minor updates. The November 2019
    update 1 is minor version 15.1, December 2019 update 2 should be minor version
    15.2, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The build number is a progressive number that is incremented by Microsoft as
    soon as there are changes committed to the branch that is related to feature enhancements
    or bug fixing.
  prefs: []
  type: TYPE_NORMAL
- en: When developing an extension, you must be aware of what system and application
    object level is needed as a minimum requirement, as defined in the `dependency`
    parameter of the `app.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: Platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Platform represents the results of the final compilation of the Dynamics 365
    Business Central platform components (client, server, web server, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: It is shown with the same notation as the application. Application and platform
    builds typically have a different build number, since platform code changes and
    application code changes are following different compilation paths and are merged
    together in the end.
  prefs: []
  type: TYPE_NORMAL
- en: When targeting a platform development, you must be aware of the minimum requirement
    that files and APIs should have to make use of the features, properties, and functions
    that they expose in order to avoid unpredictable behaviors from the application.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Runtime represents the results of the final compilation of the Dynamics 365
    Business Central AL Language extension file.
  prefs: []
  type: TYPE_NORMAL
- en: The notation is simpler and consists of a major, minor, and build version. For
    example, the Spring 2018 update (or the April 2018 update) is named major version
    1, while the Fall 2018 update (or the October 2018 update) is version 2, and so
    on. The current major version that targets the Dynamics 365 Business Central Fall
    2019 update is version 4.
  prefs: []
  type: TYPE_NORMAL
- en: When developing extensions, within the `app.json` file, you can define what
    runtime version the application is targeting. This enables or disables different
    sets of features that cannot be part of the target platform deployment, and the
    AL Language extension's runtime will detect that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the `app.json` attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute** | **Mandatory** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Id` | Yes | **Global Unique Identifier** (**GUID**) of the extension. |'
  prefs: []
  type: TYPE_TB
- en: '| `Name` | Yes | Extension name. |'
  prefs: []
  type: TYPE_TB
- en: '| `Publisher` | Yes | Publisher name. |'
  prefs: []
  type: TYPE_TB
- en: '| `Version` | Yes | Version of the extension package (for example, 1.0.0.0).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Brief` | No (Yes for AppSource) | Short description of the extension. |'
  prefs: []
  type: TYPE_TB
- en: '| `Description` | No (Yes for AppSource) | Long and verbose description of
    the extension. |'
  prefs: []
  type: TYPE_TB
- en: '| `privacyStatement` | No (Yes for AppSource) | URL to the privacy statement.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `EULA` | No (Yes for AppSource) | URL to the license terms and conditions
    for the app. |'
  prefs: []
  type: TYPE_TB
- en: '| `Help` | No (Yes for AppSource) | URL to app helpdesk support. |'
  prefs: []
  type: TYPE_TB
- en: '| `url` | No (Yes for AppSource) | URL to the extension package''s home page.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Logo` | No (Yes for AppSource) | Relative or full path to the app logo from
    the root directory of the extension |'
  prefs: []
  type: TYPE_TB
- en: '| `Dependencies` | Yes | List of dependencies from other extensions. Since
    the Fall 2019 update, it is mandatory to reference at least system application
    and base application extensions.  |'
  prefs: []
  type: TYPE_TB
- en: '| `Screenshots` | No | Relative or absolute path to app screenshots. |'
  prefs: []
  type: TYPE_TB
- en: '| `Platform` | Yes  | Minimum platform version supported (for example, 15.0.0.0).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `idRanges` | Yes | Range of application object IDs or an array of object
    ID ranges. |'
  prefs: []
  type: TYPE_TB
- en: '| `showMyCode` | No | Enables viewing extension source code while debugging
    and/or downloading source code from the extension management page.Default value:
    `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Target` | No | Default value: `Cloud`. Extension with the same font as Cloud.
    It''s one of the possible values for Target option (`Cloud` for the new version,
    `Extension` for the previous version).. These are the only two values allowed
    by Dynamics 365 Business Central SaaS.Set this value to `OnPrem` or `Internal`
    if you need to target the extension to on-premises. |'
  prefs: []
  type: TYPE_TB
- en: '| `helpBaseUrl` | No | URL for the extension''s online help. |'
  prefs: []
  type: TYPE_TB
- en: '| `contextSensitiveHelpUrl` | No (Yes for AppSource) | URL for the context-sensitive
    help for an AppSource extension. |'
  prefs: []
  type: TYPE_TB
- en: '| `supportedLocales` | No | Comma-separated list of the local languages supported
    by the app. |'
  prefs: []
  type: TYPE_TB
- en: '| `features` | No | Optional features in preview that could be enabled by the
    compiler. An example is `TranslationFile`. Adding this parameter flag in the features
    enables the generation of a directory called **Translations** in the extension
    folder and a `.xlf` translation file containing all the labels used in all extension
    objects. |'
  prefs: []
  type: TYPE_TB
- en: '| `Runtime` | No | Minimum runtime version targeted by the extension. |'
  prefs: []
  type: TYPE_TB
- en: 'The following screenshot is an example of an `app.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7680dcb-1845-4959-9cba-e5a1849f1386.png)'
  prefs: []
  type: TYPE_IMG
- en: With all of this information, we should now be able to master app configuration
    files and tweak them according to the runtime version. In the next section, we
    will introduce symbols and explain their vital importance in extension development.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding symbols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like in all other languages, symbols represent references to a collection of
    standard objects, properties, and functions. They are a special extension file
    themselves with the typical `.app` naming convention and are used to maintain
    object reference consistency while compiling, and they also populate valid IntelliSense
    entries.
  prefs: []
  type: TYPE_NORMAL
- en: Symbols are typically stored inside the database in a BLOB field in JSON for
    each object record. It is worth mentioning that in multitenancy, the `Object Metadata`
    table is part of the application database, so in customer tenant databases there
    are no system symbols or metadata stored, only data.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Dynamics 365 Business Central, symbols are already preloaded inside the
    application database, and these can be grouped into two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: Standard symbols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extension symbols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prior to the Fall 2019 update, standard application symbols were all generated
    by Microsoft through a special compilation of standard legacy objects using the
    CSIDE development environment. The same happened for the on-premises version:
    symbols were generated asynchronously, or could have been imported as a normal
    extension through PowerShell scripts.'
  prefs: []
  type: TYPE_NORMAL
- en: Standard application symbols were stored in the Symbol Reference BLOB field
    in the `Object Metadata` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find out more on this topic by reading the following official reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/it-it/dynamics365/business-central/dev-itpro/developer/devenv-running-cside-and-al-side-by-side](https://docs.microsoft.com/it-it/dynamics365/business-central/dev-itpro/developer/devenv-running-cside-and-al-side-by-side)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows us the standard symbols. Understanding what they
    are and their importance is vital for the successful compilation and deployment
    of any kind of extension prior to the Fall 2019 update:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Application | Contains symbols for all the application objects described
    in the CSIDE object designer, except system tables in the 2000000004 to 2000000199
    ID range and standard Test Toolkit objects. With an on-premises version or Docker-contained
    sandbox, if you''re making changes to a standard legacy object, you must opt for
    (re)generating symbols through the CSIDE development environment, as described
    in the following blog post:Generate Symbols in a Modern Development environment
    with Microsoft Dynamics NAV 2018 ([https://blogs.msdn.microsoft.com/nav/2018/01/16/generate-symbols-in-a-modern-development-environment-with-microsoft-dynamics-nav-2018/](https://blogs.msdn.microsoft.com/nav/2018/01/16/generate-symbols-in-a-modern-development-environment-with-microsoft-dynamics-nav-2018/)).With
    the upgraded on-premises version, symbols coming from earlier versions must be
    extracted from a standard on-premises database (or from the product DVD), imported
    in the upgrade database, and regenerated, as described in the following blog post:[https://blogs.msdn.microsoft.com/nav/2018/02/02/import-symbols-in-new-or-upgrade-databases-with-microsoft-dynamics-nav-2018/](https://blogs.msdn.microsoft.com/nav/2018/02/02/import-symbols-in-new-or-upgrade-databases-with-microsoft-dynamics-nav-2018/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| System | Contains symbols for system tables in the 2000000004 to 2000000199
    ID range, and also virtual table definitions.System and virtual table structures
    cannot be modified through extensions.System and virtual table symbols cannot
    be regenerated.For this reason, if you are developing extensions, they should
    never be considered for any changes within the CSIDE development environment.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Test | Contains symbols for application Test Toolkit objects. Standard application
    Test Toolkit object symbols cannot be regenerated. Developers should create their
    own test objects.For this reason, in a modern development environment for SaaS
    deployment, they should never be considered for any changes within the CSIDE development
    environment. |'
  prefs: []
  type: TYPE_TB
- en: 'Whenever you extend an application, you always need to have the appropriate
    symbols in place. You can achieve this in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect to a sandbox environment, run the Command Palette (*Ctrl* + *Shift*
    + *P*), and type and select `AL: Download Symbols`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download the required symbols from another place (such as the product DVD, for
    on-premises deployment) and store them in the defined symbol storage directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For on-premises deployment, you will find the `System.app` and `Test.app` symbols
    on the Dynamics 365 Business Central Spring 2019 product DVD in the following
    directory: `\ModernDev\program files\Microsoft Dynamics NAV\140\AL Development`
    `Environment`. In the Dynamics 365 Business Central Fall 2019 DVD you will only
    find `System.app` in the following directory: `\ModernDev\program files\Microsoft
    Dynamics NAV\150\AL Development Environment`. Since the Fall 2019 update, application
    and test symbols are no longer downloaded automatically by the AL Language runtime,
    and they no longer need to be stored inside the database, since all of the objects
    that belong to the application, including Test Toolkit ones, have been converted
    into AL objects. These AL objects are now part of standard extension packages.
    Extension packages contain symbols natively.'
  prefs: []
  type: TYPE_NORMAL
- en: If you have a multiuser environment with developers that are working on the
    same staging tenant, you might think of downloading symbols through the Command
    Palette once and then setting a common path for storing the symbols for all users.
    In this way, it is possible to avoid downloading the same set of symbols every
    time, thereby increasing the development productivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default symbol-storing path can be changed using one of the following shortcuts:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Menu bar, go to File (*Alt* + *F*) | Preferences (*P*) | Settings (*S*)
    and then select AL Language settings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the settings shortcuts (*Ctrl*) and then select AL Language settings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The parameter to change is *Al: Package Cache Path*, the default value of which
    is set to the relative path, `./.alpackages`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you could run the Command Palette (*Ctrl* + *Shift* + *P*),
    type and select Preferences: Configure language specific settings…, then choose
    AL. The `settings.json` file will open, and you can then add or change the values
    of the `al.packageCachePath` parameter. The following screenshot shows the AL
    settings symbol path when it has been changed to a storage location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c14ca852-89f4-4fd1-865c-7c4319f350eb.png)'
  prefs: []
  type: TYPE_IMG
- en: Later in this chapter, we will also discuss other AL Language configuration
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Together with system application extension, base application extension, and
    standard symbols, your extension might also depend on other custom or third-party
    extensions. These extensions, then, should emit symbols that you should be able
    to download from the application database when invoking AL: Download Symbols from
    the Command Palette.'
  prefs: []
  type: TYPE_NORMAL
- en: Extension symbols are stored in the Symbols BLOB field in the `NAV App` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify that your extension has a dependency on another extension(s), you
    must populate the relevant JSON array parameter in the `app.json` file. This is
    what the `app.json` file parameter looks like for an extension that depends on
    two other apps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you have installed the CRS AL language Extension toolbox from Cloud Ready
    Software ([https://marketplace.visualstudio.com/items?itemName=waldo.crs-al-language-extension](https://marketplace.visualstudio.com/items?itemName=waldo.crs-al-language-extension)
    ), you could type `tdependency` to enable the code snippet to easily edit each
    JSON array element for this parameter. This will make your coding faster and prevent
    syntax errors. We will discuss the standard and custom code snippet features in
    the last section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The version parameter of the dependent extension(s) represents the lower bound
    for the compiler to accept the symbols. In other words, symbol versions of the
    dependent extension lower than the one reported are not considered valid for download
    or compile operations.
  prefs: []
  type: TYPE_NORMAL
- en: Inside symbols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Symbols are the result of a compression (`.zip`) operation of several files
    that are used by the AL Language extension. To demonstrate what is under the hood,
    just use the most common decompression tool (for example, 7-zip) to extract their
    content after renaming the `.app` package with the `.navx` extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following tables show the standard symbol components (files and directories)
    for the base application extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **File name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `[Content_Types.xml]` | Specify the content of the package: XML and JSON
    files. |'
  prefs: []
  type: TYPE_TB
- en: '| `MediaIdListing.xml` | Specify the extension logo filename and its ID.  |'
  prefs: []
  type: TYPE_TB
- en: '| `navigation.xml` | It contains an entry for the Departments menu. |'
  prefs: []
  type: TYPE_TB
- en: '| `NavxManifest.xml` | It will report the manifest for the standard symbol
    or extension. The most relevant parameters for the base application symbols are
    as follows:`- version`: Identify the application version of the JSON file (such
    as 15.0.36626.36675)`- platform`: Target the recommended major platform version
    that''s compatible with these symbols (such as 15.0.0.0)`- runtime`: Recommended
    runtime version to be used for these symbols (such as 4.0)System symbols typically
    only specify the version and the runtime. |'
  prefs: []
  type: TYPE_TB
- en: '| `SymbolReference.json` | Contains all references in JSON notation to AL objects.These
    JSON files are heavily used by the AL Language extension to maintain reference
    integrity while compiling/building the app package and to enable all IntelliSense-related
    features.Basically, it is structured as an array containing a list of valid AL
    object parameters, as shown in the following snippet:`"Tables": [],``  "Codeunits":
    [],``  "Pages": [],``  "PageExtensions": [],`For each of these object elements,
    there are specified fields, properties, functions, and so on. |'
  prefs: []
  type: TYPE_TB
- en: Symbol JSON files cannot be hacked/changed to manually generate or modify a
    symbol file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s also have a look at what the various directories do:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Directory name** | **Content description** |'
  prefs: []
  type: TYPE_TB
- en: '| `addin` | Controls add-ins definitions. |'
  prefs: []
  type: TYPE_TB
- en: '| `layout` | RDL and DOCX report layouts. |'
  prefs: []
  type: TYPE_TB
- en: '| `logo` | Extension logo. |'
  prefs: []
  type: TYPE_TB
- en: '| `ProfileSymbolReferences` | Symbols for profiles and related page customizations.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `src` | AL files. Their content is used typically to show the code while
    debugging. |'
  prefs: []
  type: TYPE_TB
- en: '| `Translations` | Translation files in the XLIFF format. |'
  prefs: []
  type: TYPE_TB
- en: Symbols are the beating heart of the extension validation mechanism and, as
    shown in the previous tables, they also carry out the code (if the `showmycode`
    parameter has been set to true in the extension `app.json` file).
  prefs: []
  type: TYPE_NORMAL
- en: Based on AL symbols, in the Visual Studio Code marketplace you could find very
    useful extensions that are targeting AL development environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most commonly used ones are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: AL Object Designer by Marton Sagi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AZ AL Dev Tools/AL Code Outline by Andrzej Zwierzchowski
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both are very easy to use and are useful for inspecting symbols and their content.
  prefs: []
  type: TYPE_NORMAL
- en: After learning about symbols, we have completed an overview of the main items
    that are needed to build an app. Let's have a look now at AL Language extension
    configuration, and how to set them up in order to have a more productive development
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding AL Language extension configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'General and per workspace settings can be easily shown through the shortcut
    key, *Ctrl*+. An intuitive menu will be shown, and by selecting Extension | AL
    language extension configuration, a set of configuration parameters is listed.
    The following screenshot shows the AL Language extension configuration parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e292a06b-c8f1-4464-b78c-0731b5fcc917.png)'
  prefs: []
  type: TYPE_IMG
- en: Basically, these configuration values are saved into a file called `settings.json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of the description and values of the most common ones:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the following Path parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"al.packageCachePath": "./.alpackages"`: It is possible to change the default
    value to a local folder or to a shared folder for multi-developer environments.
    It represents the path to store and look for symbols.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"al.assemblyProbingPaths": ["./.netpackages"]`: This parameter is fundamental
    to compiling extensions when there are references to external assemblies. Its
    data type is a JSON array, so the developer has to specify a comma-separated list
    of paths where the assemblies are stored.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"al.ruleSetPath": null`: This is used if developers would like to provide
    a custom override of standard code analyzer rules. It will be discussed in more depth
    in [Chapter 9](076505ca-e2a0-40ab-8640-c720c9aa68ee.xhtml), *Debugging*.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the following Code Analyzer parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"al.enableCodeAnalysis": false`: This helps to enable code analysis and is
    discussed in more depth in [Chapter 9](076505ca-e2a0-40ab-8640-c720c9aa68ee.xhtml),
    *Debugging*. In large projects, with several thousands of objects, it would be
    better if it was turned off, in order to prevent performance issues while coding
    or compiling.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"al.codeAnalyzers": []`: This has the type of code analyzers. It will be discussed
    in more depth in [Chapter 9](076505ca-e2a0-40ab-8640-c720c9aa68ee.xhtml), *Debugging*.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"al.enableCodeActions": false`: Enables code actions such as automatically
    converting multiple `if` statements to a `CASE` statement or spell check. It is
    disabled by default.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"al.backgroundCodeAnalysis": true`: This is enabled by default. In large projects,
    this could be a real performance killer, and it is recommended that it is turned
    off in such scenarios.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the following Compilation parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"al.compilationOptions": {"generateReportLayout": true, "parallel": true}`:
    Used to specify if a report layout should be generated or not when compiling,
    if it does not exist, and to have a serialized or parallel build of the package.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"al.incrementalBuild": false`: In complex extension development environments,
    where multiple extension folders are loaded from a root folder, this parameter
    specifies if the reference resolution will happen from the referenced project,
    instead of happening from the symbols that are stored in the package cache path.
    Switching this parameter to true will result in an increase in performance in
    such scenarios.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the following Service Log parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"al.editorServicesLogLevel": null`: This is very useful for debugging situations
    where compilation reports unhandled errors or crashes. Logging could include errors
    up to a very verbose description of what is happening behind the scenes. It will
    be discussed more in deep in [Chapter 9](076505ca-e2a0-40ab-8640-c720c9aa68ee.xhtml),
    *Debugging*.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"al.editorServicesPath": "bin/"`: If the service log is enabled, it determines
    the log path.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the following Browser parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"al.browser": "Edge"`: Choose your preferred browser to launch your Dynamics
    365 Business Central application from Visual Studio Code. Options are SystemDefault,
    Edge, Chrome, or Firefox. This is useful if you have multiple browsers installed.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"al.incognito": false`: Choose to start the browser in a normal session that
    stores existing credentials or use private/incognito browsing.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After exploring the core settings that are needed to develop an extension,
    let''s analyze one of the best code-editing features that is provided with AL
    Language: code snippets.'
  prefs: []
  type: TYPE_NORMAL
- en: Mastering AL Language code snippets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AL Language standard code snippets in Visual Studio Code are available after
    installing the AL Language extension. These are triggered as you type within the
    code editor, and you can recognize them by a squared prefix symbol.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, they start with the letter `t` and are followed by a meaningful name
    that describes what the snippet is about, for example, `ttable` or `tpage`. A
    tooltip shows a preview of the code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the standard snippet for an if-then-else conditional
    sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1623b328-1ca2-46c8-b716-0bbf99fa40da.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that if the snippet contains variable names or code identifiers, they
    could be highlighted, suggesting that you should give them a different name and
    that they act as a sort of placeholder. When you rename a highlighted identifier,
    all occurrences will be also renamed, making snippet usage very flexible. This
    will not only reduce coding time, preventing writing or copying and pasting repeating
    sentences, but it also uses the appropriate complex structure syntax that a developer
    might not keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to download code snippets that have been produced by other developers
    in the form of extensions directly from the Visual Studio marketplace. Typically,
    many of the extensions that extend support for AL Language also include a series
    of code snippets of their own.
  prefs: []
  type: TYPE_NORMAL
- en: A typical example is the free CRS AL Language extension.
  prefs: []
  type: TYPE_NORMAL
- en: Together with several very useful developer tools, this extension also implements
    a set of AL code snippets that integrate with and enrich the existing standard
    ones. Currently, it implements 68 extra AL code snippets, and the list is growing
    with every extension update.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows all the available extra snippets that appear
    if you type CRS in an `.al` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2063ec22-341a-43e3-ae8d-9be56b4556c4.png)'
  prefs: []
  type: TYPE_IMG
- en: Another way to search for code snippets while coding is to run the Command Palette
    (*Ctrl* + *Shift* + *P*) and then type snippet or insert snippet to bring up a
    drop-down list of the AL snippets that are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the drop-down list of AL snippets from the Command
    Palette:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/438bb2db-46b4-4c30-aa5a-c0d6aeaaee32.png)'
  prefs: []
  type: TYPE_IMG
- en: If you still did not find the code snippets that are useful to you in the marketplace,
    with Visual Studio Code it is also possible to manually add new code snippets
    from scratch. To accomplish this, you have to click on the Menu bar and go to
    File (*Alt* + *F*) | Preferences (*P*) | User Snippets (*S + S*)***.***
  prefs: []
  type: TYPE_NORMAL
- en: The shortcut sequence, *Alt* + *F*, *P*, *S*, *S*, *Enter* will bring you straight
    there without needing to use the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: You can then select whether to create a global snippet for all languages, a
    local snippet for the current workspace, or one that's specific for a target language.
    In this example, we will create a new snippet to be used with AL Language files
    by choosing al (AL) from the language list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the available options when creating a specific
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e66e468e-6db6-4a4d-9973-9f74ba95e6ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you have enabled the breadcrumb feature, you might have noticed that a specific
    configuration file is open in editing mode for custom AL Language snippets. Typically,
    the file is called `al.json`, and it is stored in the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Each snippet is defined by a unique name and is composed of three elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prefix**: Used to search and trigger the snippet in the editor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Body**: The section that is pasted inside the editor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description**: A verbose description of what the snipper is for'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside the body, you could use a specific syntax to enable placeholders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$1`, `$2`, `$3`, `…`, `$n` are used to move the cursor position within the
    snippet by pressing the Tab key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$0` is used as the final cursor position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${1:labelX}`, `${2:labelY}`, and `${3:labelZ}` are used for placeholders.
    Placeholders with the same IDs are connected to each other, enabling the multiple
    cursors feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we'll go through a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you would like to add a standard code header block on top of the
    object, like it was in the old designer (the CSIDE development environment), and
    you need a smart way to implement this repeatedly and quickly on every object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest solution is to create an ad hoc custom snippet to be invoked on
    every new object file creation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `al.json` file and save it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can enable the amazing autosave feature by simply going to the Menu bar
    and selecting File (*Alt *+ *F*) | Auto Save (*U*). A check mark will appear beside
    the Auto Save menu item. Another way to accomplish this task is to run the Command
    Palette (*Ctrl* + *Shift* + *P*) and type `File: Toggle Auto Save` (or type part
    of it and select the entry from the drop-down action list).'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file inside your extension and save it with the `.al` extension (for
    example, `MyCodeunit.al`). The cursor should be automatically positioned in the
    first line and column of the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start typing `tcomment` and IntelliSense will detect the existence of your custom
    snippet. Select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The cursor will be placed in the first placeholder element. Just type the current
    date in the `YY.MM.DD` format and press Tab. You might notice that since two placeholders
    share the same ID, they are edited together, enabling the multiple cursor feature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, it is time to write down something useful that is related to the object
    description, and what it is for.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the custom comment block snippet in action with
    multiple cursors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/218bb777-f46d-4d80-8416-6fd7f3941407.png)'
  prefs: []
  type: TYPE_IMG
- en: These code snippets make it easy to understand Visual Studio Code. Try them
    out and master them!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio Code is a code-centric tool that supports, out of the box, a wide
    variety of languages, providing coding features such as syntax colorization, delimiter
    matching, code block folding, multiple cursors, code snippets, IntelliSense, and
    so much more.
  prefs: []
  type: TYPE_NORMAL
- en: By installing the AL Language extension, this modern development environment
    is fully set up as an app playground for beginner and skilled developers. We have
    unleashed some tips and tricks in this chapter that enable you to be proficient
    in the developer's daily work of creating modern apps for Dynamics 365 Business
    Central.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on to learn about the powerful coding features that this modern
    development environment offers. After all of this, it is time to see the AL Language
    in action throughout this book. But before moving to structured and advanced extension
    development, it is important to understand how to implement and maintain a sandbox/staging
    environment. This is what we will do in the next chapter.
  prefs: []
  type: TYPE_NORMAL
