- en: Developing a Customized Solution for Dynamics 365 Business Central
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw the fundamentals of extension development for
    Dynamics 365 Business Central and we analyzed all of the building blocks for creating
    extensions, such as events and basic objects definitions, and how to extend standard
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll put all of these concepts together and create a real-world
    extension for Dynamics 365 Business Central. These extensions will be created
    by using **AppSource** guidelines and best code practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Translating a business case into a real-world extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding dependent extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Translating a business case into a real-world extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, let's imagine having a Dynamics 365 Business Central customer
    with various business requirements. We want to create an extension to satisfy
    this customer's needs.
  prefs: []
  type: TYPE_NORMAL
- en: Our customer is a big commercial company that has adopted Dynamics 365 Business
    Central as the company's ERP and has various business requirements that require
    customization of the standard features to be satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: 'The business requirements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sales: These requirements include the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The company wants to classify customers based on custom categories that they
    can define as needed and that can change in the future. Each `Customer Category`
    must have its own details that can be used for some business processes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The sales office must be able to create a default `Customer Category` and assign
    this default value to a customer automatically.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The sales office needs the possibility to create gift campaigns for customer
    categories. A gift campaign is related to a limited period of time and a limited
    set of items.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A gift campaign can be set to inactive for a certain period of time.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When a gift campaign is active, the sales order manager must be able to automatically
    assign free gifts on a customer's sales order (they need a button on a sales order
    document that analyzes the order content, checks whether a campaign is active,
    and creates the free gift lines accordingly).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When a sales operator inserts a sales order line, they should be alerted if
    the customer is ordering an item quantity near to an active campaign promotion.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When a sales order is posted, the generated item ledger entry must store the
    `Customer Category` value (at the time of this order) for reporting purposes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vendor quality: These requirements include the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The company has a quality process in place (CSQ, international institute for
    the certification of business quality) and they need to classify vendors according
    to their CSQ requirements:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Score related to item quality (from 1 to 10)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Score related to delivery on time (from 1 to 10)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Score related to item packaging (from 1 to 10)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Score related to pricing (from 1 to 10)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Vendor Quality Card` must also display some financial data:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoiced for current year *N*
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoiced for the year *N-1*
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoiced for the year *N-2*
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Amount due for this vendor
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Amount to pay (not already due) for this vendor
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The assigned scores determine a vendor rating (a numeric value) based on an
    algorithm.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The purchase office cannot release a purchase order if the vendor does not meet
    standard company requirements (the vendor rating).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The application's behavior could be extended in the future.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These customizations will be developed as a single extension by using the per-tenant
    range (50.000 – 99.999). We will use AppSource rules and we'll use the **PKT**
    tag (registered with Microsoft as our AppSource prefix/suffix) to target all of
    our objects. The project's `.al` files will be named according to the AppSource
    naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: We start our development tasks by opening Visual Studio Code and creating a
    new extension project (View | Command Palette | AL:GO!), selecting the Wave 2
    release as the target.
  prefs: []
  type: TYPE_NORMAL
- en: 'We set the extension''s manifest file (`app.json`) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set the extension details, such as the name, publisher, version, description,
    the path of the logo image, the admitted object range IDs (from 50100 to 50149),
    and the supported runtime version.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also set the following option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `TranslationFile` feature means that we want to have an XLIFF translation
    file that handles the multilanguage capabilities of this extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to organize our project structure with subfolders for functionalities
    and then for object types. Our base project structure will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ab7a209-2c6d-4bdf-9985-db65ddf18427.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we have an `Src` folder, and inside that, we have three main folders
    for functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CustomerCategory`: This contains the implementation of the `Customer Category`
    requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Gifts`: This contains the implementation of the gift campaign requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VendorQuality`: This contains the implementation of the vendor quality requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside each of these folders, we have subfolders organized into object types.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start working on each of these three modules.
  prefs: []
  type: TYPE_NORMAL
- en: Customer Category implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To handle the customer category management requirements, we need to do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the `Customer Category` table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the pages (user interface) that will handle the `Customer Category` entity
    (the `List` and `Card` pages).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new `Customer Category` field to the standard `Customer` table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the new field to the standard `Customer Card` page and add some actions
    to the `Customer` pages to handle some tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the business logic to handle the requirements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next sections, we'll see the definitions and implementations of the various
    objects in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Tables definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By using the `ttable` snippet, we define the `Customer Category` table as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The name of the object has the registered `_PKT` suffix (to be unique across
    the application).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this table definition, we have defined the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Code`: This is the code of the category (the `key` field).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Description`: This is the description of the category.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Default`: This is a `Boolean` field used to set the default category.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FreeGiftsAvailable`: This is a `Boolean` field used to set whether the category
    can be used with gift campaigns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Blocked`: This is a `Boolean` field used to set the category as blocked (cannot
    be used).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EnableNewsletter`: This is an option field used to select the newsletter type
    to send for this category (commercial purposes). This field is of the `enum` type.
    As described in the previous chapter, the `enum` type allows us to have an extendable
    option field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TotalCustomersForCategory`: This is a calculated field (`flowfield`) used
    to automatically calculate the number of customers associated with the selected
    category.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This table''s definition has a keys section, where we have defined a primary
    key (the `No` field) and a secondary key with the `Description` field. This secondary
    key is defined with the `Unique` property set to `true`, and this ensures that
    you cannot have records in this table with the same value as this field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `NewsletterType` enum is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As a generic programming rule, a table acts like a class and, in the table definition,
    we want to expose the methods related to that class. This is why we have defined
    a method (procedure) here called `GetSalesAmount` (which is used to return the
    total sales amount for the selected category). The method's implementation will
    be on an external codeunit (which will contain our business logic).
  prefs: []
  type: TYPE_NORMAL
- en: We've also defined a setup table for this extension (the `Packt Extension Setup`
    table, which we'll use also in the next sections) to handle all of the variable
    parameters needed for the company's business configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'This setup table is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Having a dedicated setup table for an extension is a best practice because it
    permits you to consolidate the settings in a single place. If possible, please
    avoid adding setup settings to different standard Dynamics 365 Business Central
    setup tables.
  prefs: []
  type: TYPE_NORMAL
- en: Pages definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To handle the `Customer Category` records (insert, modify, delete, and select),
    we need to have a list page and a card page.
  prefs: []
  type: TYPE_NORMAL
- en: By using the `tpage` snippet, we have defined a card page (`PageType = Card`)
    and a list page (`PageType = List`).
  prefs: []
  type: TYPE_NORMAL
- en: The list page (`Customer Category List_PKT`) has an action for creating a default
    `Customer Category` record (it calls a method defined in an external codeunit
    because we don't want business logic on pages).
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the list page definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As a best practice, to improve the search experience and help users to easily
    find the correct page by using the search feature of Dynamics 365 Business Central,
    we have also defined the `AdditionalSearchTerms` property. These terms will be
    used in addition to the `Caption` page property to find the page via the search
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CUSTOMER CATEGORY LIST page appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80a4f4e9-52f6-4453-a81e-d4d6069aafe6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `card` page (`CustomerCategoryCard_PKT`) has different groups for displaying
    data on separate `FastTabs`. In the `OnAfterGetRecord` trigger, we calculate the
    total sales amount for the category, we assign that value to a global decimal
    field (called `TotalSalesAmount`), and we display this variable as a page field.
    The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The ...CUSTOMER CATEGORY CARD page looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbb62da8-8cf4-4fa0-9a84-9855f2944d59.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ve also created a page for the extension setup (called `Packt Extension
    Setup`), defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This page looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f722db3c-e640-4c86-b330-9fe63288a840.png)'
  prefs: []
  type: TYPE_IMG
- en: This will permit the users to handle the settings for our extension.
  prefs: []
  type: TYPE_NORMAL
- en: The tableextension definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to create a new field in the `Customer` table to handle the `Customer
    Category` assignment and, in order to do that, we need to create a `tableextension`
    object. This can be done in AL by using the `ttableext` snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tableextension` object for the `Customer` table is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've also handled the `OnValidate` trigger for this field to avoid the
    insertion of a blocked category.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve also created a new secondary key on the `Customer` table based on this
    new field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the requirements for this is to also add the `Customer Category Code`
    field to the `Item Ledger Entry` table (this must be written during posting for
    reporting purposes), so we have also defined the following `tableextension` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This new custom field will be used for statistical purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The pageextension definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This newly created `Customer Category` field must be visible on the `Customer
    Card` and `Customer List` pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we have defined two `pageextension` objects (by using the `tpageext`
    snippet). The following is the definition of the `pageextension` object for the
    `Customer Card` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the `pageextension` object definition for the `Customer List` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, on the `Customer List` page, we've added an action to assign the category
    set as default to all customers. On `Customer Card`, the same action works on
    the currently selected record.
  prefs: []
  type: TYPE_NORMAL
- en: You can see here that these two functions call a method on an external codeunit
    called `AssignDefaultCategory`. This method has two implementations (it is overloaded),
    which we'll look at later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard `Customer List` page now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da668ba5-c50a-47f4-a193-0a27fce01d42.png)'
  prefs: []
  type: TYPE_IMG
- en: '`Customer Card` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0093a3a5-03ab-4e12-87ef-47114f1a8508.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we have the newly added `Customer Category` field and the new action for
    assigning `Customer Category`.
  prefs: []
  type: TYPE_NORMAL
- en: Codeunit definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To handle the `Customer Category` business requirements that our customer has,
    all of the required business logic is defined in a dedicated codeunit called `Customer
    Category Mgt_PKT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The codeunit is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CreateDefaultCategory`: This creates an entry in the `Customer Category` table
    with a predefined code and with the `Default` flag set to `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AssignDefaultCategory`: This assigns the default category to customers. Here,
    we use overloading (supported in AL) and we have the same function with the following
    two different implementations (one without parameters and one with a `Code[20]`
    parameter):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AssignDefaultCategory(CustomerCode: Code[20])`: Works on the current customer'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AssignDefaultCategory()`: Works on all customers'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetTotalCustomersWithoutCategory`: This returns the number of customers without
    a category assigned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetSalesAmount`: This returns the total amount of the sales order for the
    `Customer Category` selected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this, we move on to implementing the gift campaign's business requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Gift campaign implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To handle the gift campaign requirements, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `Gift Campaign` table. This table must be able to store data as
    follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Customer Category** | **Item** | **Start Date** | **End Date** | **Minimum
    Quantity Ordered** | **Gift Quantity** |'
  prefs: []
  type: TYPE_TB
- en: '| GOLD | ITEM1 | 01/01/2019 | 30/03/2019 | 5 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| GOLD | ITEM2 | 01/01/2019 | 30/03/2019 | 10 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| SILVER | ITEM1 | 01/01/2019 | 30/03/2019 | 7 | 1 |'
  prefs: []
  type: TYPE_TB
- en: Create the page (user interface) for handling the gift campaign data (a list
    page).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling the business logic for assigning gifts to a sales order is based on `Customer
    Category` and the active campaign for this category. This will be done in an external
    codeunit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a new function to the `Sales Order` page interface in order to permit the
    sales operator to automatically insert a gift line when the sales order is finished.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the sales operator inserts the `Quantity` in a sales order line, we want
    to check the active campaigns and alert the user if the ordered quantity is near
    to an active promotion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By using the `ttable` snippet, we define the `Gift Campaign` table as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The primary key for this table is a composite key, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve handled the `OnValidate` trigger of the `CustomerCategoryCode`
    field, which performs some validations:'
  prefs: []
  type: TYPE_NORMAL
- en: If the `Customer Category` selected is blocked, an error is thrown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `Customer Category` selected is not available for gift promotions (`FreeGiftsAvailable
    = false`), then an error is thrown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Page definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By using the `tpage` snippet, we define the `Gift Campaign List` page as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When published, the page appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62fea46d-9cc6-432b-badc-c3ec3fc474bd.png)'
  prefs: []
  type: TYPE_IMG
- en: To handle the gift assignment logic in a sales order, by creating a `pageextension`
    object, we have added a new action to the `Sales Order` page, and from this action,
    we call the `AddGifts` method defined in a codeunit in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pageextension` object is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Sales Order` page (with the new action) now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58c20b38-2516-488f-b3b7-6b88574ac181.png)'
  prefs: []
  type: TYPE_IMG
- en: Codeunit definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All of the business logic for handling the requirements is defined in a `GiftManagement`
    codeunit, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have some procedures, some event subscribers, and some event publishers.
    The main procedure is called `AddGifts` and it adds the gift lines (promotions)
    to the sales order passed as the argument. It raises some integration events,
    and the main code is handled by the `AddFreeGiftSalesLine` procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The integration events defined in this codeunit are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've implemented the `Handled` pattern (to guarantee extensibility).
    In this way, a dependent extension can change the gift assignment logic as needed
    without modifying the base code of the main extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Handled` pattern implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We have a global variable called `Handled` set to `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We raise an integration event called `OnBeforeFreeGiftSalesLineAdded` by passing
    the sales line we're working on and the `Handled` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We implement the business logic in a procedure called `AddFreeGiftSalesLine`.
    In this procedure, if the event is handled, we skip the standard logic:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: At the end of the process, we raise an integration event called `OnAfterFreeGiftSalesLineAdded`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, why does this pattern guarantee extensibility? This is because, in a dependent
    extension, you can subscribe to the `OnBeforeFreeGiftSalesLineAdded` event and
    set the `Handled` variable to `true`and implement your new business logic for
    adding gifts.Then, the standard business logic (`AddFreeGiftSalesLine`) is skipped.
  prefs: []
  type: TYPE_NORMAL
- en: After this, you can subscribe to the `OnAfterFreeGiftSalesLineAdded` event and
    implement other custom business logic that must be executed after the process
    of adding gifts. We'll see an example of a dependent extension that alters the
    standard business logic of our extension in the *Understanding dependent extensions* section
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this codeunit, we''ve also created a procedure called `CheckGiftEligibility`,
    which is an event subscriber of the `OnAfterValidateEvent` event of the `Quantity`
    field of the `Sales Line` table. The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this function, we handle the business logic for the alert that must be triggered
    when the sales operator inserts the quantity in a sales line. As you can see in
    the preceding code, we've implemented the `Handled` pattern again here to provide
    extensibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this codeunit, we''ve also handled the event subscriber for the `OnAfterInsertEvent`
    event of the `Item Ledger Entry` table to transfer the `Customer Category` data
    to the `Item Ledger Entry` field (this was one of the requested requirements):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens when, from a sales order, you trigger the Add Free Gifts action?
    Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c91fbaf-d9af-4a31-9046-d71ef5ed419d.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the events are raised, the `AddGifts` function is executed,
    and the gift promotions (if any) are inserted in the `Sales Line` table (a new
    line with the LINE DISCOUNT % field value set to `100`).
  prefs: []
  type: TYPE_NORMAL
- en: We've now implemented all of the business requirements needed to manage the
    customer's gift campaigns. Now, let's move on to the vendor quality implementation
    details.
  prefs: []
  type: TYPE_NORMAL
- en: Vendor quality implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To handle the vendor quality management requirements, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a `Vendor Quality` table (related to the standard `Vendor` table) that
    will contain details about the quality scores for vendor and quality-related financial
    data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the relevant card page and attach it to the vendor card (this will be
    the quality detail card for a vendor as per our requirements).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a new action to the standard `Vendor card` page to open `Vendor Quality
    card`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a codeunit that handles all of the business logic related to this implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we'll see the various object implementations in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Table definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By using the `ttable` snippet, we define the `Vendor Quality` table as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this table, we have the definitions of the required score fields (rating)
    and the required financial fields. For the score rates, we handle the `OnValidate`
    trigger to dynamically update the rate calculation when the user inserts values
    in the fields (this is done by calling the `UpdateVendorRate` function defined
    in the table (as a class method) but implemented in the external codeunit that
    we'll see later).
  prefs: []
  type: TYPE_NORMAL
- en: We've also handled the table's `OnInsert` and `OnModify` triggers to save the
    insertion or modification date of the record (business requirements).
  prefs: []
  type: TYPE_NORMAL
- en: Page definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our business requirements, we need to create a `Vendor Quality card` page.
    We create a new page of the `Card` type by using the `tpage` snippet, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This page is designed by creating different groups (`FastTabs` in the UI):'
  prefs: []
  type: TYPE_NORMAL
- en: '`General`: Contains the general quality classification of the selected vendor,
    such as the name, a description of the activity, and the calculation rate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Scoring`: Contains the quality scores (as assigned by the company''s quality
    manager)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Financials`: Contains the financial data required from the quality requirements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This page has the `InsertAllowed` property set to `true` because the record
    here is inserted automatically when the page is opened from `Vendor card` (we
    handle the `OnOpenPage` trigger here) and the user can't directly insert new records
    from this page.
  prefs: []
  type: TYPE_NORMAL
- en: We also handle the `OnAfterGetRecord` page trigger, and from here, we call a
    function that refreshes the financial statistics.
  prefs: []
  type: TYPE_NORMAL
- en: The pageextension definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need a `pageextension` object to create the action of opening the previously
    created `Vendor Quality card` page from the standard `Vendor Card` page. By using
    the `tpageext` snippet, we create the following object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have defined a `QualityClassification` action, which opens the `Vendor
    Quality card` page for the selected `Vendor` record (by using the `RunPageLink`
    property).
  prefs: []
  type: TYPE_NORMAL
- en: 'The page action appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e38809fe-84d4-4ffc-a92c-7c71120423d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When triggering the action, the `Vendor Quality Card` is opened and looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b1082df-0cf4-488c-b16a-b6239f2b49a8.png)'
  prefs: []
  type: TYPE_IMG
- en: When the quality manager inserts score values, the `Vendor Rate` value is automatically
    calculated. Financial statistics are automatically calculated when opening the
    page (in real time).
  prefs: []
  type: TYPE_NORMAL
- en: Codeunit definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As usual, we define all of our business logic in an external codeunit called `VendorQualityMgt`using
    the `tcodeunit` snippet, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have defined the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CalculateVendorRate`: This is the function that calculates the vendor rate
    based on the quality scores assigned by the quality manager. We want this function
    to be extendable to be able to change the standard rate algorithm as needed in
    the future. To do that, we use the HANDLE pattern:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We raise an `OnBeforeCalculateVendorRate` event with the current `Vendor Quality`
    record and the `Handled` Boolean variable as event parameters.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We perform the standard rate calculation in the `VendorRateCalculation` function
    by checking the `Handled` parameter, and we exit from the function if we want
    to skip the standard calculation (by setting `Handled = true`).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We raise an `OnAfterCalculateVendorRate` event for handling post calculation
    operations or for handling a totally new calculation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UpdateVendorQualityStatistics`: This function calculates the financial statistics
    required by the quality manager:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetInvoicedAmount`: For a given `Vendor No.` field and date period (start/end
    date), it calculates the invoiced amount by checking the `Vendor Ledger Entry`
    table (the `Purchase (LCY)` field). The returned result is `-1` because we want
    the absolute value.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetDueAmount`: For a given `Vendor No.` field, it calculates the due amount
    (the `Due` parameter is set to `true`) or the amount to pay (the `Due` parameter
    is set to `false`) by checking the `Vendor Ledger Entry` table (the `Remaining
    Amt. (LCY)` field). The returned result is multiplied by `-1` because we want
    the absolute value.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The codeunits events are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In this codeunit, we''ve also defined an event subscriber (the `teventsub`
    snippet) for the `OnBeforeManualReleasePurchaseDoc` standard event defined in
    Microsoft''s `Release Purchase Document` codeunit, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We use this event to raise an error during the order release phase if the vendor
    does not meet the company's rate criteria (that is, the minimum acceptable rate)
    defined in the extension's setup table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The event subscriber implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: All of the customer's business requirements are now handled by our extension.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll see how to enhance the customer's user experience
    by creating customized page views in Dynamics 365 Business Central.
  prefs: []
  type: TYPE_NORMAL
- en: Creating page views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the fall 2019 release of Dynamics 365 Business Central, you can create
    customized views for your list pages. These customized views can be used in a
    dedicated section of the Dynamics 365 Business Central user interface to immediately
    apply filters to the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a view definition in a page object by using the `tview` snippet.
    In the previously created `Gift Campaign List` page, we have defined the following
    `view` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The first view (called `ActiveCampaigns`) shows all of the active gift campaigns
    (the `Inactive` field is set to `false`), while the second view (called `InactiveCampaigns`)
    shows all of the inactive gift campaigns (the `Inactive` field is set to `true`).
  prefs: []
  type: TYPE_NORMAL
- en: 'These views in the Dynamics 365 Business Central user interface look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/317615a4-6c30-4733-8565-c33d99454f72.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you select the Active Gift Campaigns view, the list is filtered accordingly
    (`Inactive` is set to `false`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1183bc8a-9e40-42cf-8732-76051f877e02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you select the `Inactive Gift Campaigns` view, the list is automatically
    filtered by `Inactive` being set to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e63e6244-df4e-4612-b836-bc0269edea95.png)'
  prefs: []
  type: TYPE_IMG
- en: We have also added a view to the `Customer List` page to show all of the customers
    who do not have an associated category.
  prefs: []
  type: TYPE_NORMAL
- en: 'The view definition in the `Customer List pageextension` object is defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We have placed this newly created view as the last of the available views for
    the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10530861-a83c-4560-908f-62cba1d3c183.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, this view appears in the user interface
    of the application and, when selected, it automatically filters all of the customers
    without an associated category (so `Customer Category = Blank`). In this way,
    our customers can immediately filter records by selecting a pre-defined view (just
    a click) and without reinserting the required filters.
  prefs: []
  type: TYPE_NORMAL
- en: After this, let's move on and see how installing and upgrading codeunits works.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and upgrading codeunits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you create an extension, you need to check some conditions for the installation
    to be successful, or you need to initiate some setup tables or pre-populate other
    tables. To do this, you need to create **Install codeunit**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The extension''s install logic must be written in a codeunit with the `SubType`
    property set to `Install`. This logic is triggered when the following is true:'
  prefs: []
  type: TYPE_NORMAL
- en: You're installing the extension for the first time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have uninstalled the extension and then you're installing it again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An `Install` codeunit supports the following system triggers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnInstallAppPerCompany()`: The code inside this trigger runs once for each
    company in the Dynamics 365 Business Central database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnInstallAppPerDatabase()`: The code inside this trigger runs once for the
    entire install process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same logic occurs when upgrading the extension. If you need to create a
    new version of your extension (the version number in the `app.json` file must
    be greater than the previous version number) and this version involves data modifications
    from previous versions, you need to create **Upgrade codeunit**.
  prefs: []
  type: TYPE_NORMAL
- en: The extension's upgrade logic must be written in a codeunit with the `SubType`
    property set to `Upgrade`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `Upgrade` codeunit supports the following system triggers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnCheckPreconditionsPerCompany()`: The code inside this trigger is used to
    check the preconditions for the upgrade process. This code runs once for each
    company in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnCheckPreconditionsPerDatabase()`: The code inside this trigger is used to
    check the preconditions for the upgrade process. This code runs once for the entire
    upgrade process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnUpgradePerCompany()`: The code inside this trigger contains the upgrade
    logic. This code runs once for each company in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnUpgradePerDatabase()`: The code inside this trigger contains the upgrade
    logic. This code runs once for the entire upgrade process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnValidateUpgradePerCompany()`: The code inside this trigger is used to check
    the results of the upgrade process. This code runs once for each company in the
    database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnValidateUpgradePerDatabase()`: The code inside this trigger is used to check
    the results of the upgrade process. This code runs once for the entire upgrade
    process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our extension, we have created an `Install` codeunit as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `OnInstallAppPerCompany` trigger, we check whether there''s an archived
    version of our extension (this could happen if someone has uninstalled the extension):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If so, we restore the archived data from the `NavApp` system table (so the user
    has their old data retrieved automatically).
  prefs: []
  type: TYPE_NORMAL
- en: If there's nothing restored, we initialize the `Customer Category` table and
    the extension's setup table (`Packt Extension Setup` table) with default data.
  prefs: []
  type: TYPE_NORMAL
- en: 'More information about the `Install` and `Upgrade` codeunits can be found in
    [Chapter 9](076505ca-e2a0-40ab-8640-c720c9aa68ee.xhtml), *Debugging*, of this
    book and at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/devenv-extension-install-code](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/devenv-extension-install-code)[ and ](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/devenv-upgrading-extensions)[https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/devenv-upgrading-extensions](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/devenv-upgrading-extensions)[.](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/devenv-upgrading-extensions)'
  prefs: []
  type: TYPE_NORMAL
- en: 'When published from Visual Studio Code on Dynamics 365 Business Central, our
    extension appears as *installed* on the EXTENSION MANAGEMENTpage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d1b194b-8d7d-4299-b41c-3bc6617635f2.png)'
  prefs: []
  type: TYPE_IMG
- en: We have now learned how to handle the install and upgrade operations required
    when publishing an extension in Dynamics 365 Business Central.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll explore the concept of dependent extensions and learn
    how to use a dependency to make customizations to our previously deployed application.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding a dependent extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we developed our extension and deployed it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine now that you''ve deployed this extension to a customer tenant and now
    the customer asks you for some customization:'
  prefs: []
  type: TYPE_NORMAL
- en: They want to add the `Certification No.` field to the Vendor Quality table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They want to change the gift assignment logic by always assigning a fixed gift
    quantity of 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create a customization for your customer, you should *never* directly modify
    your standard extension code, but instead, you should create a new extension that
    will be *dependent* on your base extension.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we create a new extension project in Visual Studio Code called `PacktDemoDependencyExtension`.
    This new extension must be dependent on our previously created `PacktDemoExtension`;
    otherwise, we won't be able to see the objects defined in that extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to retrieve the `appId`, `name`, `publisher`, and `version`
    of the base extension. Then, we have to open the `app.json` file of our new extension,
    go to the `dependencies` block, and insert the details of the dependent extension
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we download the symbols (`AL:Download Symbols`), you will see that
    the symbols of our dependent extension are downloaded into the `.alpackages` folder
    in our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74be4420-7834-407d-bed8-b5316994ae0e.png)'
  prefs: []
  type: TYPE_IMG
- en: We're now ready to create our new extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the `Certification No.` field to `Vendor Quality Card`, we need to do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend the `Vendor Quality` table by adding a new field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extend the `Vendor Quality Card` page to add the new field to the UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can do that because we have the symbols downloaded; otherwise, it's impossible
    to see the objects defined in another extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tableextension` object code that extends the `Vendor Quality` table is
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pageextension` object that extends the `Vendor Quality Card` page is defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The second requirement is to customize a standard business process defined in
    the base extension (`PacktDemoExtension`*)* that creates the gifts line on a sales
    order if there's an active campaign (in the standard business process, the gift
    quantity is the quantity defined in the `Gift Campaign` table).
  prefs: []
  type: TYPE_NORMAL
- en: You can do that **only** if the base extension has events to subscribe because
    you cannot directly modify the code of another extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle extensibility, we used the `Handled` pattern in our base extension.
    In the `PacktDemoExtension` extension, we have the `AddGifts` procedure defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To skip the standard business process (`AddFreeGiftSalesLine`) and add a new
    custom gift assignment process, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We subscribe to the `OnBeforeFreeGiftSalesLineAdded` event, and we set the
    `Handled` parameter to `true`. This ensures that the standard business logic will
    be skipped because, in the `AddFreeGiftSalesLine` procedure, we have used the
    following code as the first line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We call our custom business logic from this event subscriber.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All of this logic is defined in a codeunit object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'When published, we now have two extensions installed (the standard extension
    and the new customization extension):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc3cdd5c-f700-4285-905e-81b0b7751fec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To test whether our customization works, we create a new sales order with an
    item that has an associated gift campaign, and then we start the gift assignment
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/756a266d-f924-4369-8163-01b39e11eadc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, what happens now? The `OnBeforeFreeGiftSalesLineAdded` event is raised,
    we skip the standard event (`Handled = true`), and then our new custom function
    (`CreateCustomGiftLine`) is triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4cc8499-c1ab-4b0a-b4f5-8374e5ffba22.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding screenshot, a new gift line with a fixed quantity
    of 2 and a discount of 100% is inserted in our sales order.
  prefs: []
  type: TYPE_NORMAL
- en: We have customized our gift campaign business logic without modifying the base
    code (our base extension), but instead by creating a new dependent extension.
    This should be the mandatory model to use with Dynamics 365 Business Central.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw the implementation of a real-world extension for Dynamics
    365 Business Central. We defined the backend of our solution (tables) and we created
    the pages (the user interface) and the required business logic (codeunits and
    events) according to the initial needs of the business. We saw how to make our
    code extensible by using the `Handled` pattern and how to create installation
    and upgrade code.
  prefs: []
  type: TYPE_NORMAL
- en: In the last part of this chapter, we created a new extension that modifies the
    standard behavior of our base extension, and we looked at the concept of dependency
    between extensions.
  prefs: []
  type: TYPE_NORMAL
- en: You have also learned how to create extensions with objects and events, how
    to use coding rules, and how to create customizations without modifying the base
    code of your application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll see how to handle some advanced topics with AL and
    the extension model, such as files, media, XML and JSON objects, web services,
    and asynchronous programming.
  prefs: []
  type: TYPE_NORMAL
