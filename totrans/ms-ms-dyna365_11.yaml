- en: Installing and Upgrading Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Acquiring the Installed status for an extension is a four-step procedure: publish,
    synchronize, upgrade (if and where needed), and install. In this chapter, we will
    cover each of these steps in detail.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing a simple or even a complex extension with the most exotic code artifacts
    might turn out to be an easy task compared to its maintenance. The maintenance
    of an extension is done through the upgrade process of the extension. An upgrade
    may be needed because of the introduction of a new feature, bug fixes or, quite
    frequently with SaaS, because of dependency changes from the base app.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we will explore both basic extension installation and
    complex dependency upgrades in order to help AL developers have a better understanding
    of how to review their `SaaSified` private IPs.
  prefs: []
  type: TYPE_NORMAL
- en: With a continuous upgrade process that happens roughly every month, Dynamics
    365 Business Central online is an ever-changing and evolutionary product. Therefore,
    partners and customers should be ready to upgrade their extensions to cope with
    the monthly update releases of both platforms and applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploy extensions in an online sandbox and production environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the status for published, synchronized, and installed extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle install codeunits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle breaking changes through upgrade codeunits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define app dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with a simple upgrade scenario
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrade extensions with dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like in any other programming language, the terminology is very important. It
    is vital to clearly understand and distinguish the different deployment phases
    and statuses for the extension in order to target the appropriate troubleshooting,
    where necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the development life cycle and deployment, extensions fall into
    two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Per tenant extensions (PTE)**: This resembles the old-school development,
    tailored per customer. Development is typically performed per tenant in a sandbox
    that contains a copy of the production configuration and data. The CSP partner
    and/or its reseller, together with the customer, manage the development and deployment
    the life cycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Despite the fact that this is, historically, the most common scenario for on-premises
    ERP development, partners are encouraged to create their own standard extension
    to be deployed and/or sold through the Dynamics 365 Business Central Marketplace.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**AppSource extensions**: These are published on AppSource and their destiny
    is to be consumed by any/all tenants on a given system, acquired via the official
    Dynamics Marketplace. AppSource extensions follow a very strict process of technical
    and marketing validation before being approved and pushed as being worldwide (globally)
    available for production tenant deployments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different from PTEs, AppSource-credited extensions are already published by
    Microsoft in every application database, ready to be installed per tenant on demand.
    This makes the extension deployment process faster, more reliable, and more professional.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'PTEs can be deployed in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at both of these deployments here.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Visual Studio Code, you have to set up `launch.json` to work against a specific
    target sandbox tenant environment (`"tenant": ""`) and provide the appropriate
    credentials to establish a connection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you may have several sandboxes within the same environment, you can also
    specify which tenant you want to connect to download symbols and/or publish the
    extension (`"sandboxName": ""`).'
  prefs: []
  type: TYPE_NORMAL
- en: This is not possible in online production environments, only in sandboxes. This
    is only possible for PTEs. PTEs that are deployed in this way are often called
    developer extensions, since they can only target developer sandboxes.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the deployment is executed by applying a synchronization to the
    existing schema (`"schemaUpdateMode": "Synchronize"`). The default option, then,
    is useful for preserving the data, just in case the developer has made some changes
    that do not involve any breaking changes. It is, however, possible to completely
    clean up any previous extension deployment and deploy it from scratch (`"schemaUpdateMode":
    "Recreate"`) or even force the synchronization (`"schemaUpdateMode": "ForceSync"`)
    to guarantee fast deployment and further tests to the extension.'
  prefs: []
  type: TYPE_NORMAL
- en: ForceSync has to be used with caution and should be avoided as much as possible.
    Even if we speed up deployment and tests, it will not work in a production environment
    where an upgrade codeunit job is required. Sometimes, lazy developers might use
    ForceSync and forget to handle the appropriate upgrade and synchronization in
    production.
  prefs: []
  type: TYPE_NORMAL
- en: Manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The typical production deployment is done manually. It is also possible in
    online sandboxes since the April 2019 update, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect to your production or sandbox tenant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search (*Alt* + *Q*) for the Extension Management page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Extension Management page, click on the Manage action group (you could
    pin it if you wanted to), choose Upload Extension, and pick up the extension (`.app`)
    you developed. The following screenshot shows the upload and deploy page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ad01b062-d2fc-46f5-9da7-79dd59bc2b4c.png)'
  prefs: []
  type: TYPE_IMG
- en: In the screenshot, we see that the Deploy to parameter is very important, because
    it triggers when the extension has to be deployed by the platform.
  prefs: []
  type: TYPE_NORMAL
- en: By specifying Current version, the deployment is performed immediately and the
    extension attempts to be synchronized. Developers can check whether the task has
    completed successfully, or if there have been failure errors in the Deployment
    status page.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting Next Minor Version or Next Major Version defers the deployment to
    when the next minor or major update would happen.
  prefs: []
  type: TYPE_NORMAL
- en: To find out more about this topic, visit [https://demiliani.com/2019/04/29/dynamics-365-business-central-and-per-tenant-extensions-check-page-control-names-between-platform-upgrades/](https://demiliani.com/2019/04/29/dynamics-365-business-central-and-per-tenant-extensions-check-page-control-names-between-platform-upgrades/).
  prefs: []
  type: TYPE_NORMAL
- en: Some deployment tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Developers must have it etched on their mind that Dynamics 365 Business Central
    is a multitenant environment that declares the following paradigms:'
  prefs: []
  type: TYPE_NORMAL
- en: Applications and data are decoupled and stored in different databases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single application database, bound to an application service, could serve
    hundreds of tenants (customer data databases). This is the pillar of the one-to-many
    concept of multitenancy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the application, the database is stored as the extension manifests (records
    that store the definition of the extension as it appears in the `app.json` file).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounting and synchronizing tenants in a service bound to an application database
    would expose these extensions to the tenants.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tenant extensions could then be chosen for installation by users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever a minor update (typically monthly) or major update (typically every
    six months) happens, the extensions will be uninstalled. Subsequently, the tenant
    will be dismounted from the old application service and mounted to another application
    service that is bound to the new application version.
  prefs: []
  type: TYPE_NORMAL
- en: Even if the new application service has not published the PTE, the tenant structure
    and its data will be totally preserved.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever this operation happens, developers just have to publish and install
    the extension once again, to resynchronize everything. This is valid, as mentioned,
    for all online sandboxes.
  prefs: []
  type: TYPE_NORMAL
- en: PTEs that are deployed in the production environment have a more global scope,
    and extensions are automatically ported into the new application service. Within
    this context, if an extension is chosen to be deployed with the next minor/major
    version, when the upgrade happens, the new extension will be triggered for installation.
  prefs: []
  type: TYPE_NORMAL
- en: To get a deeper overview of this topic, visit [https://demiliani.com/2019/01/24/dynamics-365-business-central-tenant-upgrade-extensions-disappeared-in-sandbox-environment/](https://demiliani.com/2019/01/24/dynamics-365-business-central-tenant-upgrade-extensions-disappeared-in-sandbox-environment/).
  prefs: []
  type: TYPE_NORMAL
- en: 'PTEs must maintain their uniqueness across the ecosystem, and developers should
    not violate this principle. The uniqueness of a PTE, or any extension in general,
    is defined by the composition of the following values in the `app.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Package ID**: A new GUID assigned to the .app file every time the extension
    is built (*Ctrl* + *Shift* + *B*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application ID**: The unique GUID that defines the extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Name**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Publisher**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version**: (in the form of `x.x.x.x`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever one of these values is changed, the extension is considered to be a
    new extension. If a developer is considering reusing a PTE for another customer
    tenant, then they have to deal with this uniqueness paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Trying to deploy the very same PTE in another tenant, or even redeploying the
    same after rebuilding the package, might lead to a failure with an error like
    the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5565a9cc-79bb-479d-b704-8e23db0c0674.png)'
  prefs: []
  type: TYPE_IMG
- en: In this case, it might be necessary to simply increase (bump) the application
    version to make the deployment work smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: If this happens in the tenant in which the PTE has never been installed before,
    then the root cause might be a duplicate within the same application service.
    To resolve the issue, the developer has to change the application ID and the name,
    and redeploy it in order to install the PTE successfully.
  prefs: []
  type: TYPE_NORMAL
- en: For a deeper overview of this issue, visit [https://demiliani.com/2019/03/14/dynamics-365-business-central-online-sandbox-makes-you-crazy-maybe-remember-these-points/](https://demiliani.com/2019/03/14/dynamics-365-business-central-online-sandbox-makes-you-crazy-maybe-remember-these-points/).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are another two error messages that might typically arise when deploying
    extensions. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: Cannot install the extension `<name>` by `<publisher>` because the tenant `<Tenant`
    Id> already uses a different version of it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application extension with app id `'<Extension Id>'` is already configured
    for use by the global tenant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first error occurs because it has tried to publish a Per tenant extension
    with the same Application Id and Version parameters as another Per tenant extension
    which is present on the system, but with potentially different contents. The easiest
    solution to this error is to increase the version of the extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second error occurs because it has tried to upload a Per tenant extension
    using the same Id as one assigned to an AppSource Extension or a standard Microsoft
    owned extension. In this case, the solution is quite straightforward: change the
    extension Id and republish.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll see what happens under the hood when you deploy an
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment under the hood
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deploying any type of extension in an online sandbox means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The extension is published in a specific application service with a specific
    application version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same extension is synchronized (the Azure SQL database structure matches
    the object metadata definition) and installed in the sandbox tenant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Extension deployment can be summarized in four phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Publish**: The extension is uploaded into the application database onto which
    the reference tenant is mounted during the publishing process. There are no changes
    in the physical structure of the tables in the tenant database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing means a declaration of the object contents (metadata) and the database
    structure changes that need to be applied on demand by a specific tenant. These
    contents and relative changes are defined by the AL objects (such as tables, pages,
    and page extensions).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Synchronize**: The contents that are published might be transferred to the
    tenant as is (such as pages or codeunits) or they might require an extra action
    to be taken against the tenant data structure (such as a table or a table extension).
    The most important step in the synchronization process is to apply changes to
    the underlying database, typically a table structure as defined in the AL objects.
    This is the step where tables are created or new fields are added or modified
    inside the tenant database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data Upgrade**: If there are changes in the application version, then, after
    the synchronization, it must follow a data upgrade. When running the data upgrade,
    the application will search for upgrade codeunits and run the code inside them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A data upgrade is typically necessary when you have to handle breaking changes,
    such as changing a data type for a field, or when you are enhancing existing extension
    features that are already deployed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Install**: When both metadata changes and data upgrades are performed successfully,
    everything is ready in the tenant to provide all the functionality to the users.
    This last operation changes the status of the extension to Installed, and the
    application is extended and is ready to be used with the new functionalities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To demonstrate these phases in a prototype real-life development scenario, let's
    create a simple extension and double-check what's happening behind the scenes
    using a Docker-contained environment.
  prefs: []
  type: TYPE_NORMAL
- en: At the time we are writing, Dynamics 365 Business Central Spring 2019 release
    is the latest version available, hence, what will follow is based on that major
    release.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a PowerShell script that will perform the following activities:'
  prefs: []
  type: TYPE_NORMAL
- en: Install or update the `NavContainerHelper` library to the latest version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prompt you to provide a name and password for a user to be used inside the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate a Docker-contained sandbox using the latest Dynamics 365 Business Central
    version and update.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a folder in the desktop with the same name as the container and move
    all the relevant shortcuts created by the `New-NAVContainer` cmdlet in to there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The script can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the script, there should be a new directory in the desktop named
    `BC14MTW1`, with six shortcuts inside, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27b28765-fc3d-42f9-aaa0-7e0cccb6d01e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By running SQL Server Management Studio (SSMS – see [https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017)),
    we can connect to the BC14MTW1\SQLEXPRESS server inside the container using SQL
    Server authentication. The following screenshot shows a list of the databases
    in the BC14MTW1\SQLEXPRESS instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9d5cb4e-d7dd-4a63-9677-0207445a61c7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s worth noticing that there are three databases allocated with a multitenancy
    Docker-contained environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'CRONUS: This is an application database. It contains all the system tables
    that are needed to manage the application objects (such as objects and object
    metadata) that are shared through customer tenants.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: default and tenant: default is the sandbox that is mounted against the CRONUS
    application. tenant is just a dismounted copy of default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this environment, we will now focus on the following deployments:'
  prefs: []
  type: TYPE_NORMAL
- en: The main extension, which contains a new table and a table extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second extension, which depends on the main extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new version of the main extension that contains a breaking change (a change
    that impacts the schema synchronization)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new version of the second extension to cope with the main extension breaking
    change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to perform the aforementioned deployments is vital in order
    to master both simple and complex extension deployments.
  prefs: []
  type: TYPE_NORMAL
- en: 'To download symbols from this multitenant, on-premises, Docker-contained environment,
    we will use the following `launch.json` file parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using this very simple script, we have created our own Docker-contained multitenant
    environment to mimic a sandbox SaaS deployment. We are now ready to start our
    extension deployment journey, and analyze what is happening at the database level
    and in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the main extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make it very simple, we will create a brand new table (`Tab50105.NewTable.al`)
    with a few fields in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create a table extension (`Tab-Ext50105.NewTableExtension.al`) that
    extends the standard `Item` table with a new field called `Catalogue No***.***`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be the very first version of the extension, with the following parameters
    in the manifest file (`app.json`), which define the extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Typically (but it's not mandatory), extensions use a special codeunit called
    the installation codeunit. The installation codeunit is defined with `Subtype
    = Install`, and its execution is triggered every time the extension is installed.
    Its main purpose is to configure the extension during the installation by creating
    a record in a setup table, or by populating the table with default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code example, we will design an installation codeunit (`Cod50100.MainExtensionInstall.al`):'
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by creating a record in the new table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Since you can install and uninstall the extension at will, and however many
    times you want, the key point here is to check whether `NewTable.IsEmpty()` performs
    the activity exactly in the first installation. That code snippet will make sure
    to populate the table with some default values, but only if it is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Uninstalling an extension with Dynamics 365 Business Central SaaS will always
    be performed while preserving the data. They are not cleaned up, but are simply
    made not visible as the extension uninstalls. Re-installing the extension will
    bring the old saved data back again. The cloud paradigm is to be conservative
    in all shapes, and no data will ever be deleted behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'After building the extension (*Ctrl* + *Shift* + *B*), we are ready to deploy
    the app file using the following sequence of PowerShell cmdlets, which are contained
    in the `NavContainerHelper` PowerShell library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Publish-BCContainerApp`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sync-BCContainerApp`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Start-BCContainerAppDataUpgrade`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Install-BCContainerApp`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After the execution of each PowerShell cmdlet, we will check the content of
    the relevant system tables that are involved in the extension deployment, synchronization,
    and upgrade mechanism. We will use the following simple T-SQL script by swapping `[Name]`
    and `[Version Major]` in the `DECLARE` sections with the appropriate extension
    name and major version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you will observe in the following code that the publish action will declare
    the extension manifest in the `[NAV App]` table with a specific package ID, and
    its application ID in the application database (which is called `CRONUS`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The source code for the `Publish-BCContainerApp` script is available here: [https://github.com/Microsoft/navcontainerhelper/blob/master/AppHandling/Publish-NavContainerApp.ps1](https://github.com/Microsoft/navcontainerhelper/blob/master/AppHandling/Publish-NavContainerApp.ps1)
  prefs: []
  type: TYPE_NORMAL
- en: Then, the object that is contained in the extension is extracted and populates `[NAV
    App Object Metadata]`, the table in the application database.
  prefs: []
  type: TYPE_NORMAL
- en: A metadata record is also created in the `[NAV App Resource]` table, and contains
    the permission object.
  prefs: []
  type: TYPE_NORMAL
- en: 'No action is performed in the tenant database (named `default`) at this stage.
    The following screenshot shows the relevant query result snippet after the main
    extension has been published:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0357f059-0bc9-4095-8ca5-505aaacefe07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After publishing the main extension, we need to synchronize its content and
    apply metadata changes to the database structure, if and where needed. Consider
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The source code of the `Sync.BCContainerApp` script is available here: [https://github.com/microsoft/navcontainerhelper/blob/master/AppHandling/Sync-NavContainerApp.ps1](https://github.com/microsoft/navcontainerhelper/blob/master/AppHandling/Sync-NavContainerApp.ps1).
  prefs: []
  type: TYPE_NORMAL
- en: This action will synchronize the extension metadata content of the main extension
    in the application database (in this example, CRONUS) against a specific mounted
    tenant (in this example, default). Practically, it will create records in the
    tenant `[$ndo$navappschemasnapshot]` table for every object that has an impact
    on schema changes at the database level, such as tables and/or table extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'One record is also created in the `[$ndo$navappschematracking]` table to correlate
    the objects in the snapshot table with the extension ID, name, publisher, and
    version. The following screenshot shows the relevant query result snippet after
    the main app synchronizes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/550eb0d7-c281-4855-976c-a5f9e207c8d4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the extension is synchronized, the next step is to perform a data upgrade,
    if and where needed. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The source code for the `Start-BCContainerAppDataUpgrade` script is available
    here: [https://github.com/microsoft/navcontainerhelper/blob/master/AppHandling/Start-NavContainerAppDataUpgrade.ps1](https://github.com/microsoft/navcontainerhelper/blob/master/AppHandling/Start-NavContainerAppDataUpgrade.ps1).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the data upgrade now, this has no effect, since there is no previous
    extension from which to upgrade. The PowerShell cmdlet will return an error as
    shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is installing the extension:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The source code for the `Install-BCContainerApp` script is available here:
    [https://github.com/microsoft/navcontainerhelper/blob/master/AppHandling/Install-NavContainerApp.ps1](https://github.com/microsoft/navcontainerhelper/blob/master/AppHandling/Install-NavContainerApp.ps1).'
  prefs: []
  type: TYPE_NORMAL
- en: During the installation task, one record is inserted in the application database
    `[NAV App Tenant App]` table in order to report and link the tenant ID (in this
    case, `default`) and the app package ID. The same is reflected in the tenant database
    where a record is inserted in the `[NAV App Installed App]` table, reporting the
    package ID and the app ID.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, the synchronization mechanism between the application database
    and the tenant database is completed and the metadata structure changes are also
    applied to the SQL Server database structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, you will find the following in the tenant database:'
  prefs: []
  type: TYPE_NORMAL
- en: A new table called `$item$<appID>` that contains the new field, `Catalogue No.`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new table called `$NewTable$<appID>` that contains all the relevant fields
    that have been defined for that table in the AL table object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the overview of the two new tables that were
    created during the installation process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4247e96f-a255-4f6f-96b8-721662c94f9b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The installation process also executes the code that is contained in the installation
    codeunit and, in this example, populates `New Table` with three records. You can
    easily inspect the table''s content by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b87595a9-ee44-4545-984b-6372029bb363.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that the main extension has been installed, let's move forward in our example,
    by creating and deploying another extension that has a dependency on the objects
    declared by the main extension.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a dependent extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The dependency to the main extension is declared in the `app.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that the dependency must define four parameters:
    the application ID, name, publisher, and version. These are mandatory if we want
    to define a unique extension target.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the dependency in the `app.json` file is defined, it is mandatory to download
    the appropriate symbols from the tenant. To perform this action, just run the
    command palette (*Ctrl* + *Shift* + *P*) and choose AL: Download symbols.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it very simple, we will create a second extension as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second extension will be with just a page extension object that is based
    on the table extension field implemented with the main extension (`Pag-Ext50115.NewTablePageExtension.al`). Hence,
    the second extension must declare a dependency on the main extension. Consider
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to publish the second extension using the following PowerShell
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Like in the main extension, the publish action will declare the extension manifest
    in the `[NAV App]` table and the object contained in the extension is extracted
    into the `[NAV App Object Metadata]` table in the application database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A record is also created in the `[NAV App Resource]` table of type metadata.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The significant change, compared to the previous extension, is a new record
    in the `[NAV App Dependencies]` table that links the second extension package
    ID with the main extension application ID, name, publisher, and version. The following
    screenshot shows the relevant query result snippet, after the dependent app is
    published:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fdbf554a-0837-4132-90b2-4ec81068db66.png)'
  prefs: []
  type: TYPE_IMG
- en: No action is performed; hence, there are no changes in the tenant database.
  prefs: []
  type: TYPE_NORMAL
- en: 'After publishing, we need to synchronize the second extension:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This action will synchronize the extension metadata content of the second extension
    in the application database against a specific mounted tenant. In this case, since
    we have a page object in the extension and nothing more, no records will be created
    in the nav app schema snapshot table in the tenant database.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, one record will be created in the `[$ndo$navappschematracking]` table,
    just to correlate the extension objects in the snapshot table with the extension
    ID, name, publisher, and version, no matter whether or not there are objects that
    need to be tracked. The following screenshot shows the relevant query result snippet
    after the main app has been synchronized:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab203fad-3665-4ef8-aaac-8fb39338e4ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After synchronizing the second extension, we could check whether there is some
    data that needs to be upgraded. We could then use the following PowerShell script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As with the main extension, an error will be thrown, stating that there is nothing
    to upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to install the second extension:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this case, it will be a super-fast task, because we do not have any objects
    that will cause a schema change (we only have a page extension in the second extension).
  prefs: []
  type: TYPE_NORMAL
- en: One record is inserted in the application database's `[NAV App Tenant App]`
    table to report and link the tenant ID and the app package ID, and the same record
    is inserted in the tenant database's `[NAV App Installed App]` table, reporting
    the package ID and the app ID.
  prefs: []
  type: TYPE_NORMAL
- en: Everything is now ready to work in our solution (that is, a combination of two
    dependent extensions) and, in the `BC14MTW1` folder, just run the `BC14MTW1 Web
    Client` shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: 'After providing access credentials and creating a 30-day trial version, go
    to the Item list and create three items called ITEM1, ITEM2, and ITEM3, or whatever
    you like, and assign them Catalogue No. `111`, `222`, and `333`, respectively.
    The following screenshot shows the Item card:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33276a9b-e5c5-42af-acb3-83645258cd4f.png)'
  prefs: []
  type: TYPE_IMG
- en: This will make sure that we now have some data to upgrade, as required in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a new version of the main extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Again, in order to make it very simple, we will create a second version of
    the main extension where one field, `Catalogue No.`, will change its data type
    from integer to `text 30`. This is a data type conversion that constitutes a breaking
    change in the data schema. The second version of the extension must then cope
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Increase (bump) the extension version**: Change the `app.json` file version
    field as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**Table or table extension object changes**: We should declare the original
    `Catalogue No.` field with the `ObsoleteState` property set to `Removed` (for
    a definition of `ObsoleteState` and an overview of how it is used, please visit [https://docs.microsoft.com/en-us/dyn](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/properties/devenv-obsoletestate-property)[amics365/business-central/dev-itpro/developer/properties/devenv-obsoletestate-propert](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/properties/devenv-obsoletestate-property)**[y](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/properties/devenv-obsoletestate-property)**).
    We should also declare a brand new field with the `text 30` data type, and with
    the same `Caption` as the `Catalogue No.` field, in order to make these changes
    with a smooth transition. The following code shows this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Installation codeunit changes**: If there will be some code referencing the
    `Catalogue No.` and pre-populated values during the initial installation phase,
    these need to be changed according to the new data type in the installation codeunit.
    We do not have such cases in our example, but it might happen in real-life scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Upgrade codeunit**: The code changes that are declared in the table or table
    extension objects might involve data handling. A brand new codeunit with the `Subtype`
    property set to `Upgrade` is now needed to handle this data transit from the old
    field to the new one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To find out more about upgrade codeunits, check out the online documentation
    at [https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/devenv-upgrading-extensions](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/devenv-upgrading-extensions).
  prefs: []
  type: TYPE_NORMAL
- en: Within this codeunit and in a specific function, it is possible to write the
    upgrade code and check whether a specific version of an extension has been installed
    and performs actionable tasks based on this information. All of this information
    is retrieved in an upgrade codeunit using a combination of the `NavApp` and `ModuleInfo`
    data types.
  prefs: []
  type: TYPE_NORMAL
- en: This would make an upgrade codeunit very powerful and flexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we will retrieve the information of the currently installed version
    (`NavApp.GetCurrentModuleInfo(Module)`), and transform the existing integer value
    for the `Catalogue No.` field into text with the `C` as a prefix. Consider the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now able to publish the new version of the main extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The extension manifest for version 2 will be loaded in the `[NAV App]` table,
    and the object that is contained in the extension is extracted into the `[NAV
    App Object Metadata]` table in the application database. A metadata record is
    also created in the `[NAV App Resource]` table. The following screenshot shows
    the relevant query result snippet after the new version of the main extension
    has been published:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1accb7d9-9fd1-4291-bf79-001ed1b6af81.png)'
  prefs: []
  type: TYPE_IMG
- en: No action is performed in the tenant database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s synchronize the new version of the main extension with the following
    PowerShell snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Records will be created in the tenant's `[$ndo$navappschemasnapshot]` table
    for every object that has an impact on schema changes at the database level.
  prefs: []
  type: TYPE_NORMAL
- en: The record that is created in the `[$ndo$navappschematracking]` table has been
    updated to correlate the objects in the snapshot table with the extension ID,
    name, publisher, and the new version. The record updates the `version` field to
    2.0.0.0 and changes the `baselineversion` field to `1.0.0.0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also the crucial stage at which metadata changes are applied. Let''s
    run a simple query from SSMS as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding query will show that the new `NewCatalogueNo` field has been
    created. The following screenshot shows the result of the query in the extended
    item table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42fc3d5c-b7b1-4b12-93e5-938d2d49b991.png)'
  prefs: []
  type: TYPE_IMG
- en: It is worth noticing that users are still able to work seamlessly and without
    any problems, continuing to assign values to the old `Catalogue No.` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step in the deployment of version 2.x of the main extension is to
    perform the data upgrade:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The previous step synchronized the metadata structure at the database level
    and created the new field, leaving the old field with its values untouched.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is in this step where all the upgrade magic happens and the data is moved
    into the new field. Run the following query again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that the values in `NewCatalogueNo` have been updated according
    to the upgrade codeunit code. The following screenshot shows the result of the
    query in the extended item table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8937767a-8937-4820-9cb0-424c59f272a3.png)'
  prefs: []
  type: TYPE_IMG
- en: The record in the application database's `[NAV App Tenant App]` table that linked
    the tenant ID and the app package ID is also updated with the version 2 package
    ID. This is also reflected in the tenant database by updating the relevant record
    in the `[NAV App Installed App]` table with the new package ID from version 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dependent extension is, then, broken at this stage, because it is bound
    to a field that is effectively marked as removed; hence, the page text box control
    related to the old `Catalogue No.` field will not be shown in the client anymore.
    The following screenshot shows a snippet of the Item card after upgrading to the
    new version of the main extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b7b929e-91d5-47e2-bf25-3040d3be4bdf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The last step to check is whether there are changes when installing the extension
    using the following PowerShell statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this case, no action is performed, because the extension was already installed,
    and it has just been upgraded to another version.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should, then, receive the following message when running the PowerShell
    cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: After this, let's see how we can deploy to a new independent version.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a new version of the dependent extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After performing the data upgrade of the main extension to a new version, we
    saw that the dependent extension has been broken. It is crucial at this stage
    to let the user read or update the new `NewCatalogueNo.` field from the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first. We must bump the `app.json` version of the dependent extension
    to 2.0.0.0, and also update the dependency to the appropriate version of the main
    extension. See the following updated snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `app.json` file is updated, we must download the new symbols from
    our multitenant environment in order to have them set appropriately. The results
    of the `.alpackages` directory content, right after the downloading symbols, are
    shown in the following screenshot. This shows a list of symbols that are needed
    to build the new version for the dependent extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0170bbb2-8f04-4903-bc7f-8961fdc39217.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The updated page extension object will then have the appropriate reference
    to the new `NewCatalogueNo` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We could then publish the new version of the second extension using the following
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As in version 2 of the main extension, the manifest will be loaded in the `[NAV
    App]` table, and the object contained in the extension is extracted into the `[NAV
    App Object Metadata]` table in the application database. A metadata record is
    also created in the `[NAV App Resource]` table, and also in the `[NAV App Dependency]`
    table, reflecting the dependency of the second extension version 2 on main extension
    version 2.
  prefs: []
  type: TYPE_NORMAL
- en: No action is performed in the tenant database.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should, then, synchronize the app in the tenant using the following PowerShell
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Once you run the synchronization, the original record that was created in the
    `[$ndo$navappschematracking]` table will be updated in order to correlate the
    objects in the snapshot table with the extension ID, name, publisher, and the
    new version.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `version` field for the dependent extension will be `2.0.0.0`, while the
    `baselineversion` field remains `1.0.0.0`. The following screenshot shows the
    query result after the new version of the dependent extension has been synchronized:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9b829ea-63c9-4425-88b1-7dff1e8f7106.png)'
  prefs: []
  type: TYPE_IMG
- en: If we stop now, we have a hybrid half-deployment state, where schema synchronization
    is now enabled for the new version, but the installed version is still the old
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is now time to start the data upgrade for the second extension. See the
    following simple script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The record in the application database's `[NAV App Tenant App]` table that linked
    the tenant ID and the app package ID is updated with the new version's package
    ID. The same thing happened in the tenant database by updating the relevant record
    in the `[NAV App Installed App]` table with the new version's package ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dependent extension is, then, consistent at this stage and the new page
    extension is used to read and update the `NewCatalogueNo` field. The following
    screenshot shows the Item card after upgrading to the new version of the dependent
    extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bca6c89-e81a-4cb3-834a-522deab1414b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Just to be consistent in following the four deployment phases, we could also
    execute the installation statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It is trivial to say that we will receive the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the life cycle of our simple extension that covers complex upgrade
    scenarios. It is left to you, as an exercise, to deploy all four extensions manually
    in an online Dynamics 365 Business Central production environment, and see whether
    there are any differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, you could filter the extension that is deployed online, and you
    might notice that you will find all of them in the extension management list:
    two installed (version 2) and two not installed (version 1). The following screenshot
    explains the situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3b2cd07-fc73-4a74-bfdb-d7fa2bc8d5ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Handling installation and upgrade operations are two important steps that you
    need to handle with your applications. Upgrading in particular is mandatory if
    you want to upgrade an extension without data loss.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we took a close look at the various options for deploying
    an extension targeted at Dynamics 365 Business Central sandbox or production.
    We have also covered all four stages of extension deployment in detail: publish,
    synchronize, data upgrade, and installation.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter closes the development section, and now you're ready to start working
    with extensions on real-world projects (you know how to create extensions, how
    to deploy them, and how to extend them).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll begin a brand new section that looks at debugging
    and testing extensions. The final chapter relates to source code management and
    its life cycle.
  prefs: []
  type: TYPE_NORMAL
