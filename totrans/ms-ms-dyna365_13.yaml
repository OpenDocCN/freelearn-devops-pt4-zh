- en: Automated Test Development with AL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how to debug AL extensions with Visual Studio
    Code.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will have a look at how to write automated tests for an
    extension in AL. We need to do this in order to have a modern development life
    cycle, and it's mandatory if you want to publish your extensions on AppSource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the demo extension that was developed in [Chapter 5](d8553d40-bf59-4aef-983c-89519ef30e29.xhtml),
    *Developing a Customized Solution for Dynamics 365 Business Central*, we will
    cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing tests using the Acceptance Test-Driven Development pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a test extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The technique behind testing code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing test code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test automation and testing design principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application testing is not rocket science. Neither is automated application
    testing. It's just another learnable skill. From a developer's perspective, however,
    you need a change of mindset to write code with a totally different purpose than
    you're used to do. It's common knowledge that developers should never test their
    own code, as they, consciously or unconsciously, know how to use the software
    and how to evade issues. They write code to make something work.
  prefs: []
  type: TYPE_NORMAL
- en: Testing, however, is not about *how to make it*; rather, it's about *how to
    break it*. But this knowledge applies to manual, exploratory testing, where tests
    are executed based on knowledge and experience, not to scripts. And automatic
    tests are scripts.
  prefs: []
  type: TYPE_NORMAL
- en: To code these scripts into automated tests, we'll need developers. And more
    often than not, it will be the same developer that did the application coding.
  prefs: []
  type: TYPE_NORMAL
- en: In order for developers to code automated tests, they need to be provided with
    well-defined scripts. If there is **no design**, there will be **no test**. And
    that's the approach we will take in this chapter—we will first design tests and
    then show you how to code them.
  prefs: []
  type: TYPE_NORMAL
- en: Designing tests with ATDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In his book, *Automated Testing in Microsoft Dynamics 365 Business Central*,
    Luc van Vugt delves into how to design and implement your tests. Based on the
    so-called **Acceptance Test-Driven Development** (**ATDD**) methodology, he shows
    how to write your requirements like a test design using the ATDD pattern. This
    pattern introduces five tags:'
  prefs: []
  type: TYPE_NORMAL
- en: 'FEATURE: Defines what feature(s) the test or collection of test cases is testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SCENARIO: Defines the scenario being tested for a single test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GIVEN: Defines what data setup is needed; a test case can have multiple GIVEN
    tags when the data setup is more complex.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'WHEN: Defines the action under test; each test case should have only one WHEN
    tag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'THEN: Defines the result of the action, or more specifically, the verification
    of the result. If multiple results apply, multiple THEN tags will be needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is what a ATDD scenario would look like for our customer category
    feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[FEATURE]** Customer Category'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[SCENARIO #0002]** Assign blocked customer category to customer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[GIVEN]** A blocked customer category'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[GIVEN]** A customer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[WHEN]** Set customer category on customer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[THEN]** Blocked category error thrown'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can acquire Luc's book at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/automated-testing-in-microsoft-dynamics-365-business-central](https://www.packtpub.com/automated-testing-in-microsoft-dynamics-365-business-central).'
  prefs: []
  type: TYPE_NORMAL
- en: After learning how to design, we will now look at how to prepare the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to start writing automated tests on your AL extension, you need to
    import *Microsoft Test Framework* into your Dynamics 365 Business Central environment.
    If you're working with Dynamics 365 Business Central on-premise (standalone installation),
    you can import it from the product DVD. If you are using a Docker-based development
    sandbox, you can import the Test Toolkit automatically with the `navcontainerhelper` module by
    adding the `-includeTestToolkit` switch parameter to the `New-BcContainer` cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have an already-running Docker container with Dynamics 365 Business
    Central, you can import the Test Toolkit by using the following cmdlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The Test Toolkit Test Libraries consist of the following five apps (included
    in the latest Docker images in the `C:\Applications folder`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`Microsoft_Any.app`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft_Library Assert.app`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft_System Application Test Library.app`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft_Tests-TestLibraries.app`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft_Test Runner.app`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your environment now contains all that you need to write and execute automatic
    tests. In the next section, we'll see how to set up tests for your extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up test development for extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we take the most restrictive requirement for extensions (the requirement
    that Microsoft considers mandatory for approving your extension for release to
    AppSource), app and test code should be placed in separate extensions. As such,
    the test extension should have a dependency on the app extension.
  prefs: []
  type: TYPE_NORMAL
- en: This separation, however, might restrict the parallel development of the app
    and test code, since any change to an app extension results in its redeployment.
    This potentially also results in an update and redeployment of the test extension.
  prefs: []
  type: TYPE_NORMAL
- en: Before you realize it, you are continuously juggling your extensions, thereby
    reducing the productivity of the development team. The best course of action,
    while developing, is to have the app and test code placed in the same extension.
    Once it's ready, you can split up the code and create the two mandatory extensions
    by means of an automated build script or a specific merging strategy.
  prefs: []
  type: TYPE_NORMAL
- en: If your extension is not to be put on AppSource, I still strongly advise you
    not to release the test code in the app extension, in order to prevent automated
    tests from being run in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the specific case of our demo extension, where the app code is already completed,
    we can set up our test in a separate, dependent extension. In the next section,
    we'll see how to do that in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our Visual Studio Code test project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To set up a new project for our test automation, perform the operation we carried
    out in [Chapter 5](d8553d40-bf59-4aef-983c-89519ef30e29.xhtml), *Developing a
    Customized Solution for Dynamics 365 Business Central*, when we started our demo
    extension. Make sure that the `app.json` of our new test project is updated as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have added the dependencies from the extension to the test,
    and from all the *Test Toolkit Libraries* apps that are needed for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the technique behind test code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start coding tests, we need to learn a couple of things about the
    technique behind test code, the so-called **testability framework**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since NAV 2009 Service Pack 1, Microsoft has allowed the platform to let you
    build test suites by means of *test functions* in *test codeunits*. When executing
    a test codeunit, the platform will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `OnRun` trigger and each test function that resides in the test codeunit,
    from top to bottom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Record the result of each test function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is what Luc van Vugt calls the **first pillar** of the testability framework.
    Our first test example will implement this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **second pillar** allows you to create so-called *positive–negative*, or
    *rainy-path*, tests, in which we test the circumstances that led to failure. To
    achieve this, we use the AL `asserterror` keyword, which should be applied in
    front of the calling statement to catch the error and let the test pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Our second scenario, which was used in a previous example, will make use of
    this testability feature.
  prefs: []
  type: TYPE_NORMAL
- en: In various parts of our code, we will interact with the user, asking them, for
    example, to confirm a certain action, or by simply displaying a message. When
    automating tests, we need to be able to handle these user interactions.
  prefs: []
  type: TYPE_NORMAL
- en: For this, the **third pillar**, the **user interface** (**UI**) *handler functions*,
    has been conceived. *Handler functions* are a special type of function that can
    only be created in test codeunits, and aim to handle UI interactions that exist
    in the code under test. They enable us to fully automate tests without the need
    for a real user to interact with them. Our third test example will show us how
    to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **fourth pillar** is the *test runner*. This is a specific codeunit that
    can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Run tests that are stored in multiple codeunits, control their execution, and
    collect and secure the results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do this run in isolation so that write transactions, in the end, do not alter
    the database that we run the test on, and so that each rerun of a test is done
    using the same initial data setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When running the test that we are going to build, we will make use of the standard
    test runner that resides in Dynamics 365 Business Central.
  prefs: []
  type: TYPE_NORMAL
- en: The initial trigger for adding the testability framework to the platform was
    implemented to get away from testing the business logic through the UI. As such,
    the testability framework is enabled headless, and thus there is faster testing
    of the business logic and it is not possible to test the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving ahead, it became clear that sole headless tests excluded too much. How
    do we test business logic that typically resides on pages, such as a product configurator,
    in which options are displayed or hidden depending on the values entered by the
    user? So, later, Microsoft added a **fifth pillar** to the testability framework:
    the *test page*.'
  prefs: []
  type: TYPE_NORMAL
- en: A test page is a logical representation of a page and is strictly handled in
    memory, displaying no UI. It adds methods that allow you to code the behavior
    of the user when accessing a page and its subparts, reading and changing data
    on it, and performing its actions. The fourth test example (in the *UI handlers
    – test example 4* section) will include a test page. So, let's see how we go about
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: Find out more details of the five pillars of the testability framework in Luc's
    book at [https://www.packtpub.com/business/automated-testing-microsoft-dynamics-365-business-central](https://www.packtpub.com/business/automated-testing-microsoft-dynamics-365-business-central).
  prefs: []
  type: TYPE_NORMAL
- en: Designing our test scenarios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we''ve already mentioned, we will illustrate four of the five pillars of
    testability in a test example:'
  prefs: []
  type: TYPE_NORMAL
- en: Test codeunit and test function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asserterror`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to have designed each scenario to enable us to code a test efficiently
    and effectively. This is what we will do first in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: In his book, Luc shows extensively how to get from requirements to an automated
    test, or as he calls it *From customer wish to test automation*.
  prefs: []
  type: TYPE_NORMAL
- en: Test codeunit and test function – Test example 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As test codeunits and test functions are the basis of test coding in AL, we
    could take any scenario as an example. But let''s keep it simple and start with
    the basic requirement of our demo extension: the company wants to classify customers
    based on custom categories that they can define over time, and that can change
    in the future.'
  prefs: []
  type: TYPE_NORMAL
- en: This has been implemented by adding a new table called *Customer Category* with
    a related page, and a new field in the *Customer* table called *Customer Category
    Code*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A first test scenario when testing a basic part of this requirement would be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[FEATURE]** Customer Category'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[SCENARIO #0001]** Assign non-blocked customer category to customer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[GIVEN]** A non-blocked customer category'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[GIVEN]** A customer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[WHEN]** Set customer category on customer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[THEN]** Customer has customer category code field populated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As each scenario should be self-explanatory, we are not going to elaborate on
    each of the tags.
  prefs: []
  type: TYPE_NORMAL
- en: asserterror – Test example 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can easily illustrate the usage of the asserterror keyword with the scenario
    discussed previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[FEATURE]** Customer Category'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[SCENARIO #0002]** Assign blocked customer category to customer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[GIVEN]** A blocked customer category'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[GIVEN]** A customer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[WHEN]** Set customer category on customer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[THEN]** Blocked category error thrown'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This tests the same feature that was defined by the requirement to classify
    customers. However, even though the blocked pattern that was applied to the *Customer
    Category* was not mentioned in the requirements, it has been implemented in the
    extension, throwing an error when assigning a blocked customer category to a customer,
    and therefore it needs to be tested.
  prefs: []
  type: TYPE_NORMAL
- en: Test page – Test example 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the business requirements described in [Chapter 5](d8553d40-bf59-4aef-983c-89519ef30e29.xhtml),
    *Developing a Customized Solution for Dynamics 365 Business Central*, the user
    must be <q>"able to create a default customer category and assign this default value
    to a customer automatically."</q>
  prefs: []
  type: TYPE_NORMAL
- en: 'This perfectly illustrates the use of a test page using the following scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[FEATURE]** Customer Category UI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[SCENARIO #0007]** Assign default category to customer from customer card'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[GIVEN]** A non-blocked default customer category'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[GIVEN]** A customer with customer category not equal to default customer
    category'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[WHEN]** Select Assign Default Category action on customer card'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[THEN]** Customer has default customer category'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It should be noted that we have *UI* in the `[FEATURE]` tag, which denotes
    that the feature is tested by making use of the UI. Preferably, test automation
    is about creating so-called *headless* tests; that is, tests that do not make
    use of the UI, as UI tests are 5 to 10 times slower than headless tests and non-UI
    tests. This is demonstrated by Luc in his book with the following screenshot,
    which compares a similar headless test and a UI test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b5eca60-a41e-4254-b7d5-52ab7b14b0b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The average execution duration for UI tests is 1.35 s, while the headless average
    is almost seven times faster: 0.20 s.'
  prefs: []
  type: TYPE_NORMAL
- en: UI handlers – Test example 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might have already inspected all the application code of our demo extension
    on GitHub, and as such you might have seen that few UI elements triggered by code
    need a handler function. Actually, there is only one to be found in the `DoGiftCheck`
    function of the `50101 GiftManagement_PKT`codeunit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Getting it triggered is not as simple as the other examples, as a lot of conditions
    need to be met. For that reason, it appears here the fourth, and last, example.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the scenario is indeed somewhat more extensive:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Feature]** Gifts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Scenario #0010]** Assign quantity on sales line to trigger activepromotion
    message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Given]** Packt setup with Gift Tolerance Qty set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Given]** Customer with non-blocked customer category with Free Gifts Available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Given]** Item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Given]** Gift campaign for item and customer category with Minimum Order
    Quantity set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Given]** Sales invoice for customer with line for item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[When]** Set quantity on invoice line smaller than Minimum Order Quantity and
    within Gift Tolerance Qty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Then]** Active promotion message is displayed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we have designed our required test scenarios. In the next section, we'll
    see how to implement them effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our test scenarios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given an ATDD scenario, we can effectively implement test code using the following
    four steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a test codeunit with a name based on the `[FEATURE]` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Embed the requirement into a test function with a name based on the `[SCENARIO]`
    tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the test story based on the `[GIVEN]`, `[WHEN]`, and `[THEN]` tags.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Construct the real code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test codeunit and test function – Test example 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform this four-step recipe for our first test example with the following
    ATDD scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[FEATURE]** Customer Category'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[SCENARIO #0001]** Assign non-blocked customer category to customer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[GIVEN]** A non-blocked customer category'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[GIVEN]** A customer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[WHEN]** Set customer category on customer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[THEN]** Customer has customer category code field populated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a test codeunit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the `[FEATURE]` tag and applying the unique suffix for our extension
    is the basic structure of our codeunit, and will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a test codeunit is defined by setting its `SubType` to `Test`.
  prefs: []
  type: TYPE_NORMAL
- en: Embed the requirement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we create a test function with a name based on the SCENARIO description
    and embed the scenario, the `GIVEN-WHEN-THEN` part, in this function. I call this
    embedding `green`, as it's the commented-out `GIVEN-WHEN-THEN` sentences, before
    you start programming the black part (the `.al` test code).
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at what the codeunit has now become:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A test function is denoted by the `[Test]`tag. If you forget to add this tag
    to a function, it will be a normal function.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the test story
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing the first `black` parts is about writing pseudo-English, defining what
    needs to be achieved with a test. It makes a test readable by any non-technical
    peer in the project, and in the event their support is needed, the threshold for
    them to read the test is substantially lower than if the code had been written
    as technical code. And, maybe an even stronger argument is that the code will
    be embedded in reusable helper functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here we go; let''s write the `black` parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This `story` sets up four helper functions in which the content will be constructed
    in the next step. Note how close the names of the helper functions are to the
    descriptions of the tags that they belong to, and that no arguments or return
    values have been defined yet.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the real code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing the test story showed us that we need four helper functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CreateNonBlockedCustomerCategory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateCustomer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetCustomerCategoryOnCustomer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VerifyCustomerCategoryOnCustomer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's construct and discuss them.
  prefs: []
  type: TYPE_NORMAL
- en: CreateNonBlockedCustomerCategory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`CreateNonBlockedCustomerCategory` is a manifold reusable helper function that
    creates a pseudo-random `Customer Category` record. At a later stage, we could
    promote this to become a library codeunit. The implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To populate the primary key field, we make use of the `GenerateRandomCode` function
    from the standard test library's `LibraryUtility` codeunit (`131000`). The `LibraryUtility`
    variable is declared globally as Microsoft does in their test codeunits, making
    it reusable in other helper functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can observe the following from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo-random means that whenever our test is executed in the same context,
    the `GenerateRandomCode` function will yield the same value, contributing to a
    reproducible test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Description` field is populated by the same value as the `Code` field,
    as the specific value of `Description` has no meaning, and this way it's most
    effective.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `with-do` construct in helper functions allows easy reuse of the code
    for similar purposes, but is applied to other tables as it only needs a change
    in the record variable (and the table it is referencing).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CreateCustomer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the `CreateCustomer` function in the standard library''s `LibrarySales`
    codeunit (`130509`), our `CreateCustomer` creates a useable customer record and
    makes this helper function a straightforward exercise. Have a look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As with the `LibraryUtility` variable, we will declare the `LibrarySales` variable
    globally.
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder why we create a helper function that only has one statement
    line. As we've already mentioned, using helper functions makes the test readable
    for non-technical peers, and makes it reusable. What we haven't mentioned is that
    it also makes it more maintainable/extendable. If we need to update the customer
    record created by the `CreateCustomer` function in the `Library - Sales` codeunit,
    we only need to add that to our local `CreateCustomer` function.
  prefs: []
  type: TYPE_NORMAL
- en: SetCustomerCategoryOnCustomer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Have a look at the implementation of `SetLookupValueOnCustomer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Calling `Validate` is essential here. `SetLookupValueOnCustomer` is not just
    about assigning a value to the `Customer Category Code_PKT` field, but also about
    making sure it is validated against existing values in the `Customer Category`
    table. Note that the `OnValidate` trigger of the `Customer Category Code_PKT`
    field does not contain code.
  prefs: []
  type: TYPE_NORMAL
- en: VerifyCustomerCategoryOnCustomer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each test needs to verify its outcome. Put bluntly, a test without verification
    is not a test. And for the current test, we need to verify that the customer category
    code that is assigned to the `Customer Category Code_PKT` field of the customer
    record is indeed the value that was created in the `Customer Category` table.
    We therefore retrieve the record from the database and verify the content of the
    `Customer Category Code_PKT` field as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify that the expected value (first argument) and the actual value (second
    argument) are equal, we make use of the `AreEqual` function in the standard library
    `Assert` codeunit (`130000`). Of course, we could build our own verification logic
    using the error system function, and that''s what `AreEqual` is doing too. Have
    a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: By using the `AreEqual` function, however, we ensure that we get a standardized
    error message in case the expected and actual values are not equal. Over time,
    when reading the error of any failing test, you will be able to easily recognize
    the kind of error that occurred, given that your verification helper functions
    make use of the `Assert` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The completed test function would look like the following code, which is ready
    for execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice the variables and arguments that have been added to the test codeunit
    and functions.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the GitHub repository for this book to have a look at the full implementation
    of the test codeunit: [https://github.com/PacktPublishing/Mastering-Microsoft-Dynamics-365-Business-Central](https://github.com/PacktPublishing/Mastering-Microsoft-Dynamics-365-Business-Central).
  prefs: []
  type: TYPE_NORMAL
- en: Running the test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The proof of the pudding is in the eating, as they say, so let''s run our test.
    The easiest and most instructive way to do this is by making use of the **Test
    Tool** in the application. You can easily access the Test Tool using the Tell
    Me... feature in Dynamics 365 Business Central:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03f6cd3b-2ed6-4ba4-91fe-88bc0d30214d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When in a clean database, or at least a database or company where the Test
    Tool has not been used yet, this is what the Test Tool looks like, a suite called
    DEFAULT with no records in it, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec02762c-bcdd-443f-93cd-27ba2253551b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To add our test to the suite, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Get Test Codeunits** action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the dialog that opens, you have two options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Select Test Codeunits**:This will open a page with a list showing all test
    codeunits that are present in the database, from which you can select specific
    test codeunits; once you have selected them and clicked OK, these codeunits will
    be added to the suite.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**All Test Codeunits**:This will add all test codeunits that exist in the database
    to the test suite.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s select the first option, **Select Test Codeunits**. This will open the CAL
    TEST GET CODEUNITS page. It shows the test codeunit that we have just created
    and a bunch of tests that reside in the database, mainly due to standard extensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9570ab20-81c7-40ef-9bc4-36bd225e9750.png)'
  prefs: []
  type: TYPE_IMG
- en: Select the test codeunit and click **OK**. The suite now shows for each test
    codeunit, a line with `Codeunit` in the Line Type column, and linked to this line
    (and indented), all its test functions (with `Function` in the Line Type column).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To run the tests, select the **Run** action in the dialog that opens, with
    the Active Codeunit and Alloptions. Since we have only one codeunit in the `DEFAULT`
    test suite, it does not matter which option we choose, so click **OK**. Now our
    test codeunit will be run, and each test will yield a `Success`result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ec4ddf14-ff08-48fc-a3c1-b4744d5c92af.png)'
  prefs: []
  type: TYPE_IMG
- en: Had we selected the **Active Codeunit **option, only the selected codeunit would
    have been executed.
  prefs: []
  type: TYPE_NORMAL
- en: For each failure, the First Error field will display the error that caused the
    failure. As you can see, First Error is `FlowField`. If you drill down into it,
    the CAL Test Result window opens. This displays the whole test run history for
    a specific test.
  prefs: []
  type: TYPE_NORMAL
- en: Running the test by clicking on **Run** will call the standard test runner codeunit, CAL
    Test Runner (130400), and will make sure that tests run from the Test Tool will
    be run in isolation, and the results of each test function will be logged.
  prefs: []
  type: TYPE_NORMAL
- en: asserterror – Test example 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, we will illustrate the use of *asserterror* with scenario
    #0002:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[FEATURE]** Customer Category'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[SCENARIO #0002]** Assign blocked customer category to customer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[GIVEN]** A blocked customer category'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[GIVEN]** A customer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[WHEN]** Set customer category on customer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[THEN]** Blocked category error thrown'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a test codeunit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sharing the same `[FEATURE]` tag value as test example 1, our new test case
    will also share the same test codeunit, that is, `60100 Customer Category PKT`.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding the requirement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to the previous requirements, we need to create the following new
    test function in the `60100` codeunit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Writing the test story
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given test example 1, writing the test story isn''t a difficult exercise. Have
    a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First of all, note how `asserterror` has been applied – in front of the call
    to the `SetCustomerCategoryOnCustomer` helper function. This ensures that the
    platform will expect `SetCustomerCategoryOnCustomer` to throw an error. `asserterror`
    enables the test to continue with the next statement and it will not check the
    error, as such. So, it is up to us to verify that the expected did occur. If there
    is no verification of the specific error following `asserterror`, any error will
    make your test pass.
  prefs: []
  type: TYPE_NORMAL
- en: Next, note that, based on test example 1, the required variables have already
    been provided.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the real code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we reuse the `CreateCustomer` and `SetCustomerCategoryOnCustomer` functions
    from test example 1, we only need to create two new helper functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CreateBlockedCustomerCategory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VerifyBlockedCategoryErrorThrown`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's learn more about them both next.
  prefs: []
  type: TYPE_NORMAL
- en: CreateBlockedCustomerCategory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the goal of `CreateBlockedCustomerCategory` being very similar to the
    `CreateNonBlockedCustomerCategory` helper function from test example 1, its construction
    is as simple, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: VerifyBlockedCategoryErrorThrown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier, it was noted that, when `asserterror` enables the test to continue
    with the next statement, it will not check the error as such. And that is what
    this helper function needs to do, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Running the test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's redeploy our extension and add the second test to the Test Tool by selecting
    **Actions | Functions | Get Test Methods**. Get Test Methods will update the selected
    test codeunit by adding all current test functions in the codeunit as lines in
    the Test Tool. Note that the RESULT column will be cleared. Now, run the test
    codeunit and see that both tests are successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the next screenshot, which shows the results of the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57d7de52-64a5-4f13-bb78-aafe526453f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Running the test codeunit will show that both tests have been executed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How do we verify that success is a real success? We can do this in a simple
    way – by providing a different expected value to the verification function of
    our test case. So let''s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Running our second test will now yield a failure with the next error text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The *actual error*, indeed, is the one that should occur. After this, we move
    on to test example 3.
  prefs: []
  type: TYPE_NORMAL
- en: Test page – Test example 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll illustrate the usage of a test page in the next scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[FEATURE]** Customer Category'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[SCENARIO #0007]** Assign default category to customer from customer card'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[GIVEN]** A non-blocked default customer category'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[GIVEN]** A customer with customer category not equal to default customer
    category'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[WHEN]** Select Assign Default Category action on customer card'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[THEN]** Customer has default customer category'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you should now know the first steps in the four-step recipe, let's go faster
    and *create*, *embed*, and *write* in one fell swoop.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test codeunit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sharing the same `[FEATURE]` tag value as test examples 1 and 2, our new test
    case will share the same test codeunit, which is `60100 Customer Category PKT`.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding and writing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the already-existing `60100 Customer Category PKT` codeunit, we embed the
    requirements and write the test story, which leads us to the following test function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Constructing the real code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to have the `#0007` scenario working properly, we need to create these
    four helper functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CreateNonBlockedDefaultCustomerCategory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateCustomerWithCustomerCategoryNotEqualToDefault`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectAssignDefaultCategoryActionOnCustomerCard`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VerifyCustomerHasDefaultCustomerCategory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But, as you will see, and as you will also experience when writing more tests,
    the majority of these helper functions are easy to construct by making use of
    previously developed helper functions.
  prefs: []
  type: TYPE_NORMAL
- en: CreateNonBlockedDefaultCustomerCategory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`CreateNonBlockedDefaultCustomerCategory` resembles the `CreateBlockedCustomerCategory`
    helper function that was created for test example 2\. We can use the same approach
    that was used there. Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `FindFirst` construction has been added to guarantee that only
    one default customer category will be added.
  prefs: []
  type: TYPE_NORMAL
- en: CreateCustomerWithCustomerCategoryNotEqualToDefault
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Calling the `CreateCustomer` helper function suffices as the customer record
    that is created will have an empty `Customer Category Code` field. This makes
    the construction of this helper function a very easy exercise, as you can see
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: SelectAssignDefaultCategoryActionOnCustomerCard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the helper function, we touch on the core of this test example – making
    use of a test page to achieve `#0007`, that is, testing that the user can assign
    a default customer category to a specific customer. The following is what the
    helper function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that I did not use a `with-do` construct to unambiguously show that the
    three statements in the function are referencing methods that you will only find
    on test page objects, and not on normal pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OpenView`: Opens the test page in view mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GoToKey`: Finds the row in a dataset that is identified by the specified values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Invoke`: Invokes an action on a test page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a complete listing of all test page methods, take a look at the following
    URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TestPage`: [https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testpage/testpage-data-type](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testpage/testpage-data-type)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TestField`: [https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testfield/testfield-data-type](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testfield/testfield-data-type)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TestAction`: [https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testaction/testaction-data-type](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testaction/testaction-data-type)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find more details on test pages in Luc's book at [https://www.packtpub.com/business/automated-testing-microsoft-dynamics-365-business-central](https://www.packtpub.com/business/automated-testing-microsoft-dynamics-365-business-central).
  prefs: []
  type: TYPE_NORMAL
- en: VerifyCustomerHasDefaultCustomerCategory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the code for the default customer category is stored in the local `CustomerCategoryCode`
    variable in test example 4, verifying that the `CustomerCategoryCode` field on
    the customer record has indeed been populated with the default customer category
    is just a case of calling the already-existing `VerifyCustomerCategoryOnCustomer` helper
    function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Running the test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running both test codeunits will show that all tests are executed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: More examples for the Customer Category feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the GitHub repository for this book, you will find an extra number of test
    scenarios regarding the Customer Category feature. Go there and study them, and
    see how various helper functions have to be reused, showing that building up a
    bigger test suite often involves the reuse of existing elements. You might have
    wondered why the test examples weren't consecutively numbered. Inspecting the
    other scenarios on GitHub will show you why.
  prefs: []
  type: TYPE_NORMAL
- en: UI handler – Test example 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to show you how to implement a `UI handler` function, we are going
    to have a go at the following scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Feature]** Gifts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Scenario #0010]** Assign quantity on sales line to trigger active promotion
    message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Given]** Packt setup with Gift Tolerance Qty set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Given]** Customer with non-blocked customer category with Free Gifts Available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Given]** Item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Given]** Gift campaign for item and customer category with Minimum Order
    Quantity set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Given]** Sales invoice for customer with line for item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[When]** Set quantity on invoice line smaller than Minimum Order Quantity and
    within Gift Tolerance Qty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Then]** Active promotion message is displayed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As this is quite an extensive scenario, you will also explore and learn from
    a somewhat more complex test code sample.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test codeunit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Typically, a test codeunit can be viewed as a test suite that tests a feature.
    As this feature, `Gifts`, is different from the one addressed in the previous
    test examples, we should contain this test in a new test codeunit, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Embedding and writing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Embedding and writing would now lead to a test function with the following
    pseudo-code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is the pseudo-code that describes the process for assigning gifts. In the
    next section, we'll see the real implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, due to their length, some function names have been cut into two and
    spread over two lines.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the real code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given the *written story* (in the previous section), we now need to create
    the following seven helper functions in order to implement real test code effectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CreatePacktSetupWithGiftToleranceQty`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateCustomerWithNonBlockedCustomerCategoryWith`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FreeGiftsAvailable`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: '`CreateGiftCampaignForItemAndCustomerCategory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`` `CreateSalesInvoiceForCustomerWithLineForItem` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AssignQuantityOnInvoiceLineSmallerThanMinimumOrderQuantity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AndWithinGiftToleranceQty`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`VerifyActivePromotionMessageIsDisplayed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's jump through the *real code* and take a look at a couple of specifics.
  prefs: []
  type: TYPE_NORMAL
- en: CreatePacktSetupWithGiftToleranceQty
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `CreatePacktSetupWithGiftToleranceQty` helper function''s main purpose
    is to set `GiftToleranceQty` on the extension setup, and is given by the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The CreateCustomerWithNonBlockedCustomerCategoryWithFreeGiftsAvailable helper
    function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`CreateCustomerWithNonBlockedCustomerCategoryWithFreeGiftsAvailable` is a helper
    function that creates a customer with a non-blocking customer category set, and
    it''s implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that, like our previous helper function, `CreateCustomer` (see test examples
    1 and 2), this test function also makes use of the standard `CreateCustomer` function
    in the standard library `LibrarySales` codeunit (`130509`).
  prefs: []
  type: TYPE_NORMAL
- en: CreateItem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`CreateItem` is a similar construction to the `CreateCustomer` function, as
    it makes use of the `CreateItem` function in the standard library `LibraryInventory`
    codeunit (`132201`). As a matter of fact, it''s just a wrapper around it, as seen
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: CreateGiftCampaignForItemAndCustomerCategoryWithMinimumOrderQuantity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`CreateGiftCampaignForItemAndCustomerCategoryWithMinimumOrderQuantity` has
    to create a gift campaign record that combines the item that has just been created
    and the customer category that is linked to the newly created customer, and defines
    the period of time within the campaign will be valid and active. Have a look at
    what the functions look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: CreateSalesInvoiceForCustomerWithLineForItem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When provided with the numbers of our item and customer, the `CreateSalesInvoiceForCustomerWithLineForItem`
    helper function has to create a new sales invoice with one line, making use of
    the `CreateSalesDocumentWithItem` helper function from the standard library `Library
    - Sales` codeunit (`130509`). The following is what its implementation looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note that no quantity is yet set on the line, as per the sixth parameter in
    the call to `CreateSalesDocumentWithItem`. The last two parameters of `CreateSalesDocumentWithItem`
    denote an undefined location and shipment date.
  prefs: []
  type: TYPE_NORMAL
- en: SetQuantityOnInvoiceLineSmallerThanMinimumOrderQuantityAndWithinGiftToleranceQty
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main purpose of this helper function is to set and validate the quantity
    on the sales invoice line, so that, when it is smaller than the minimum order
    quantity on the gift campaign and everything is within the gift tolerance as defined
    in the setup, calling `Validate` will trigger the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'A very useful exercise before coding the `[THEN]` part is to run the test.
    In the case of this test, it will show us something that''s very relevant. But
    before we do, we need to update the last details in our test function, as we haven''t
    specified the various parameters when calling the helper functions. So, the following
    is what the new test codeunit has become:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Running the test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, let''s run the test, even though it''s not ready yet. As the screenshot
    demonstrates, there is an `unhandled UI` element, `Message`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23f13168-714a-49b0-afd0-2a71883895dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we read the error message more closely, we see that it''s the message that
    we wanted to evoke:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows us two things:'
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully evoked the message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to implement a so-called `MessageHandler` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is what the simplest `MessageHandler` function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This will handle the message; that is, it will mimic a user pressing the **OK**
    button on the message dialog. Note that the name of this function doesn't need
    to be `MessageHandler`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a `MessageHandler` function is not sufficient. It also needs to be bound
    to the test function that is triggering the message. This is done by setting the
    `HandlerFunctions` property of the test function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Running the test again demonstrates that it is successful now, but remember: *a
    test with no verification is no test*. The `MessageHandler` function could be
    triggered by any message. The last helper function we have to tackle, `VerifyActivePromotionMessageIsDisplayed`,
    needs to verify that our test did indeed evoke the right message.
  prefs: []
  type: TYPE_NORMAL
- en: VerifyActivePromotionMessageIsDisplayed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's leave something for you to discover. Go to GitHub and have a look at how
    this is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned how to create automatic tests for your extensions
    according to your business scenarios. Automatic testing is absolutely a must-have
    with Dynamics 365 Business Central (it's mandatory for AppSource apps, but it's
    also a best practice to follow in general).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed the basics of how to create automated tests
    in Dynamics 365 Business Central.
  prefs: []
  type: TYPE_NORMAL
- en: We utilized the ATDD test case pattern in order to design each test, and then
    used it as a base structure in our four-step recipe to create a test codeunit,
    embed the customer choice into a test, write a test story, and finally construct
    your real code. You should now be comfortable with writing tests for your extensions
    according to your business needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''ll explore another important aspect to master when
    developing solutions for Dynamics 365 Business Central: source code management
    and DevOps practices.'
  prefs: []
  type: TYPE_NORMAL
