- en: Automated Test Development with AL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AL进行自动化测试开发
- en: In the previous chapter, we saw how to debug AL extensions with Visual Studio
    Code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用Visual Studio Code调试AL扩展。
- en: In this chapter, we will have a look at how to write automated tests for an
    extension in AL. We need to do this in order to have a modern development life
    cycle, and it's mandatory if you want to publish your extensions on AppSource.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何为AL扩展编写自动化测试。我们需要这样做，才能拥有现代的开发生命周期，如果你想在AppSource上发布扩展，这也是强制要求的。
- en: 'Using the demo extension that was developed in [Chapter 5](d8553d40-bf59-4aef-983c-89519ef30e29.xhtml),
    *Developing a Customized Solution for Dynamics 365 Business Central*, we will
    cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在[第5章](d8553d40-bf59-4aef-983c-89519ef30e29.xhtml)中开发的演示扩展，*为Dynamics 365
    Business Central开发定制解决方案*，我们将讨论以下主题：
- en: Designing tests using the Acceptance Test-Driven Development pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用验收测试驱动开发模式设计测试
- en: Setting up a test extension
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置测试扩展
- en: The technique behind testing code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试代码背后的技术
- en: Implementing test code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现测试代码
- en: Test automation and testing design principles
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试自动化和测试设计原则
- en: Application testing is not rocket science. Neither is automated application
    testing. It's just another learnable skill. From a developer's perspective, however,
    you need a change of mindset to write code with a totally different purpose than
    you're used to do. It's common knowledge that developers should never test their
    own code, as they, consciously or unconsciously, know how to use the software
    and how to evade issues. They write code to make something work.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序测试并不是火箭科学，自动化应用程序测试也不是。它只是另一种可以学习的技能。然而，从开发人员的角度来看，你需要转变思维方式，编写与通常不同目的的代码。大家都知道，开发人员不应该测试自己的代码，因为他们无论有意还是无意，都知道如何使用软件并规避问题。他们编写代码是为了让某个功能工作。
- en: Testing, however, is not about *how to make it*; rather, it's about *how to
    break it*. But this knowledge applies to manual, exploratory testing, where tests
    are executed based on knowledge and experience, not to scripts. And automatic
    tests are scripts.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，测试并不是关于*如何做成*，而是关于*如何让它崩溃*。但这一知识适用于手动的探索性测试，其中测试是根据知识和经验来执行的，而非脚本。而自动化测试是脚本。
- en: To code these scripts into automated tests, we'll need developers. And more
    often than not, it will be the same developer that did the application coding.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这些脚本编写成自动化测试，我们需要开发人员。往往，进行应用程序编码的开发人员也是编写自动化测试的开发人员。
- en: In order for developers to code automated tests, they need to be provided with
    well-defined scripts. If there is **no design**, there will be **no test**. And
    that's the approach we will take in this chapter—we will first design tests and
    then show you how to code them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让开发人员能够编写自动化测试代码，他们需要提供明确定义的脚本。如果没有**设计**，就没有**测试**。这是我们在本章中的方法——我们将首先设计测试，然后展示如何编写它们。
- en: Designing tests with ATDD
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ATDD设计测试
- en: 'In his book, *Automated Testing in Microsoft Dynamics 365 Business Central*,
    Luc van Vugt delves into how to design and implement your tests. Based on the
    so-called **Acceptance Test-Driven Development** (**ATDD**) methodology, he shows
    how to write your requirements like a test design using the ATDD pattern. This
    pattern introduces five tags:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的书《*Microsoft Dynamics 365 Business Central中的自动化测试*》中，Luc van Vugt深入探讨了如何设计和实现你的测试。基于所谓的**验收测试驱动开发**（**ATDD**）方法论，他展示了如何像编写测试设计一样编写需求，使用ATDD模式。这种模式引入了五个标签：
- en: 'FEATURE: Defines what feature(s) the test or collection of test cases is testing.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'FEATURE: 定义测试或测试用例集正在测试的功能。'
- en: 'SCENARIO: Defines the scenario being tested for a single test.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SCENARIO: 定义单个测试的测试场景。'
- en: 'GIVEN: Defines what data setup is needed; a test case can have multiple GIVEN
    tags when the data setup is more complex.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GIVEN: 定义所需的数据设置；当数据设置较为复杂时，一个测试用例可以包含多个GIVEN标签。'
- en: 'WHEN: Defines the action under test; each test case should have only one WHEN
    tag.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'WHEN: 定义被测试的动作；每个测试用例应该只有一个WHEN标签。'
- en: 'THEN: Defines the result of the action, or more specifically, the verification
    of the result. If multiple results apply, multiple THEN tags will be needed.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'THEN: 定义该动作的结果，或者更具体地说，定义结果的验证。如果有多个结果，可能需要多个THEN标签。'
- en: 'The following is what a ATDD scenario would look like for our customer category
    feature:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们客户类别功能的ATDD场景示例：
- en: '**[FEATURE]** Customer Category'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[FEATURE]** 客户类别'
- en: '**[SCENARIO #0002]** Assign blocked customer category to customer'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[SCENARIO #0002]** 将被阻止的客户类别分配给客户'
- en: '**[GIVEN]** A blocked customer category'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[给定]** 一个被阻止的客户类别'
- en: '**[GIVEN]** A customer'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[给定]** 一个客户'
- en: '**[WHEN]** Set customer category on customer'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[当]** 设置客户的客户类别'
- en: '**[THEN]** Blocked category error thrown'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[然后]** 抛出被阻止类别错误'
- en: You can acquire Luc's book at
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下网址获取 Luc 的书：
- en: '[https://www.packtpub.com/automated-testing-in-microsoft-dynamics-365-business-central](https://www.packtpub.com/automated-testing-in-microsoft-dynamics-365-business-central).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/automated-testing-in-microsoft-dynamics-365-business-central](https://www.packtpub.com/automated-testing-in-microsoft-dynamics-365-business-central)。'
- en: After learning how to design, we will now look at how to prepare the environment.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何设计之后，我们现在来看一下如何准备环境。
- en: Preparing the environment
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备环境
- en: In order to start writing automated tests on your AL extension, you need to
    import *Microsoft Test Framework* into your Dynamics 365 Business Central environment.
    If you're working with Dynamics 365 Business Central on-premise (standalone installation),
    you can import it from the product DVD. If you are using a Docker-based development
    sandbox, you can import the Test Toolkit automatically with the `navcontainerhelper` module by
    adding the `-includeTestToolkit` switch parameter to the `New-BcContainer` cmdlet.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始在你的 AL 扩展上编写自动化测试，你需要将 *Microsoft Test Framework* 导入到你的 Dynamics 365 Business
    Central 环境中。如果你使用的是 Dynamics 365 Business Central 本地版（独立安装），可以从产品 DVD 中导入。如果你使用的是基于
    Docker 的开发沙盒，可以通过将 `-includeTestToolkit` 开关参数添加到 `New-BcContainer` cmdlet 中，使用
    `navcontainerhelper` 模块自动导入测试工具包。
- en: 'If you have an already-running Docker container with Dynamics 365 Business
    Central, you can import the Test Toolkit by using the following cmdlets:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有一个运行中的 Docker 容器，并且正在使用 Dynamics 365 Business Central，你可以通过以下 cmdlet 导入测试工具包：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The Test Toolkit Test Libraries consist of the following five apps (included
    in the latest Docker images in the `C:\Applications folder`):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 测试工具包测试库包括以下五个应用（包含在 `C:\Applications folder` 目录下的最新 Docker 镜像中）：
- en: '`Microsoft_Any.app`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft_Any.app`'
- en: '`Microsoft_Library Assert.app`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft_Library Assert.app`'
- en: '`Microsoft_System Application Test Library.app`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft_System Application Test Library.app`'
- en: '`Microsoft_Tests-TestLibraries.app`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft_Tests-TestLibraries.app`'
- en: '`Microsoft_Test Runner.app`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft_Test Runner.app`'
- en: Your environment now contains all that you need to write and execute automatic
    tests. In the next section, we'll see how to set up tests for your extensions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的环境已经包含了编写和执行自动化测试所需的一切。在接下来的章节中，我们将看到如何为你的扩展设置测试。
- en: Setting up test development for extensions
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为扩展设置测试开发环境
- en: If we take the most restrictive requirement for extensions (the requirement
    that Microsoft considers mandatory for approving your extension for release to
    AppSource), app and test code should be placed in separate extensions. As such,
    the test extension should have a dependency on the app extension.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们采用最为严格的扩展要求（即微软认为在批准你的扩展发布到 AppSource 时是强制性的要求），应用和测试代码应该放在不同的扩展中。因此，测试扩展应依赖于应用扩展。
- en: This separation, however, might restrict the parallel development of the app
    and test code, since any change to an app extension results in its redeployment.
    This potentially also results in an update and redeployment of the test extension.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种分离可能会限制应用和测试代码的并行开发，因为对应用扩展的任何更改都会导致它的重新部署。这也可能导致测试扩展的更新和重新部署。
- en: Before you realize it, you are continuously juggling your extensions, thereby
    reducing the productivity of the development team. The best course of action,
    while developing, is to have the app and test code placed in the same extension.
    Once it's ready, you can split up the code and create the two mandatory extensions
    by means of an automated build script or a specific merging strategy.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不知不觉中，你会不断地在管理扩展之间切换，从而降低开发团队的生产力。在开发过程中，最好的做法是将应用和测试代码放在同一个扩展中。一旦准备好，你可以通过自动化构建脚本或特定的合并策略拆分代码并创建两个必需的扩展。
- en: If your extension is not to be put on AppSource, I still strongly advise you
    not to release the test code in the app extension, in order to prevent automated
    tests from being run in a production environment.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的扩展不打算发布到 AppSource，我仍然强烈建议你不要在应用扩展中发布测试代码，以防止在生产环境中运行自动化测试。
- en: In the specific case of our demo extension, where the app code is already completed,
    we can set up our test in a separate, dependent extension. In the next section,
    we'll see how to do that in practice.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们演示扩展的具体案例中，由于应用代码已经完成，我们可以在一个独立的依赖扩展中设置我们的测试。在接下来的章节中，我们将看到如何在实践中操作。
- en: Setting up our Visual Studio Code test project
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的 Visual Studio Code 测试项目
- en: 'To set up a new project for our test automation, perform the operation we carried
    out in [Chapter 5](d8553d40-bf59-4aef-983c-89519ef30e29.xhtml), *Developing a
    Customized Solution for Dynamics 365 Business Central*, when we started our demo
    extension. Make sure that the `app.json` of our new test project is updated as
    follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们的测试自动化设置一个新项目，请执行我们在[第5章](d8553d40-bf59-4aef-983c-89519ef30e29.xhtml)中进行的操作，*为
    Dynamics 365 Business Central 开发定制化解决方案*，当时我们启动了演示扩展。确保我们的新测试项目的 `app.json` 文件已按如下所示更新：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, we have added the dependencies from the extension to the test,
    and from all the *Test Toolkit Libraries* apps that are needed for testing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们已经将扩展中的依赖项添加到测试中，并且加入了所有需要用于测试的*测试工具库*应用。
- en: Learning about the technique behind test code
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解测试代码背后的技术
- en: Before we start coding tests, we need to learn a couple of things about the
    technique behind test code, the so-called **testability framework**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写测试之前，我们需要了解一些关于测试代码背后技术的内容，也就是所谓的**可测试性框架**。
- en: 'Since NAV 2009 Service Pack 1, Microsoft has allowed the platform to let you
    build test suites by means of *test functions* in *test codeunits*. When executing
    a test codeunit, the platform will do the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 自 NAV 2009 Service Pack 1 起，微软允许平台通过*测试函数*在*测试代码单元*中构建测试套件。当执行测试代码单元时，平台会执行以下操作：
- en: Run the `OnRun` trigger and each test function that resides in the test codeunit,
    from top to bottom
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 `OnRun` 触发器和每个测试函数，按从上到下的顺序，在测试代码单元中依次执行
- en: Record the result of each test function
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录每个测试函数的结果
- en: This is what Luc van Vugt calls the **first pillar** of the testability framework.
    Our first test example will implement this.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Luc van Vugt 所称的**可测试性框架的第一支柱**。我们的第一个测试示例将实现这一点。
- en: 'The **second pillar** allows you to create so-called *positive–negative*, or
    *rainy-path*, tests, in which we test the circumstances that led to failure. To
    achieve this, we use the AL `asserterror` keyword, which should be applied in
    front of the calling statement to catch the error and let the test pass:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二个支柱**允许你创建所谓的*正向-负向*，或者*异常路径*测试，在这些测试中，我们测试导致失败的情况。为了实现这一点，我们使用 AL `asserterror`
    关键字，该关键字应放在调用语句前，以捕获错误并使测试通过：'
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our second scenario, which was used in a previous example, will make use of
    this testability feature.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个场景，之前的示例中已使用，将利用这个可测试性功能。
- en: In various parts of our code, we will interact with the user, asking them, for
    example, to confirm a certain action, or by simply displaying a message. When
    automating tests, we need to be able to handle these user interactions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们代码的各个部分，我们会与用户互动，询问他们确认某个操作，或者仅仅是显示一条消息。在自动化测试时，我们需要能够处理这些用户交互。
- en: For this, the **third pillar**, the **user interface** (**UI**) *handler functions*,
    has been conceived. *Handler functions* are a special type of function that can
    only be created in test codeunits, and aim to handle UI interactions that exist
    in the code under test. They enable us to fully automate tests without the need
    for a real user to interact with them. Our third test example will show us how
    to do this.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，**第三个支柱**，即**用户界面**（**UI**）*处理函数*应运而生。*处理函数*是只能在测试代码单元中创建的一种特殊类型的函数，旨在处理测试代码中存在的用户界面交互。它们使我们能够完全自动化测试，而无需真实用户的交互。我们的第三个测试示例将展示如何实现这一点。
- en: 'The **fourth pillar** is the *test runner*. This is a specific codeunit that
    can do the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**第四个支柱**是*测试运行器*。这是一个特定的代码单元，能够执行以下操作：'
- en: Run tests that are stored in multiple codeunits, control their execution, and
    collect and secure the results
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行存储在多个代码单元中的测试，控制它们的执行，并收集和保护结果
- en: Do this run in isolation so that write transactions, in the end, do not alter
    the database that we run the test on, and so that each rerun of a test is done
    using the same initial data setup
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在隔离的环境中运行，以确保写入事务最终不会改变我们运行测试时所使用的数据库，并确保每次重新运行测试时都使用相同的初始数据设置
- en: When running the test that we are going to build, we will make use of the standard
    test runner that resides in Dynamics 365 Business Central.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将要构建的测试中，我们将利用存储在 Dynamics 365 Business Central 中的标准测试运行器。
- en: The initial trigger for adding the testability framework to the platform was
    implemented to get away from testing the business logic through the UI. As such,
    the testability framework is enabled headless, and thus there is faster testing
    of the business logic and it is not possible to test the UI.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 向平台添加可测试性框架的初始触发点是为了避免通过UI测试业务逻辑。因此，启用可测试性框架时是无头的，从而可以更快速地测试业务逻辑，但无法测试UI。
- en: 'Moving ahead, it became clear that sole headless tests excluded too much. How
    do we test business logic that typically resides on pages, such as a product configurator,
    in which options are displayed or hidden depending on the values entered by the
    user? So, later, Microsoft added a **fifth pillar** to the testability framework:
    the *test page*.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进时，显而易见，单独的无头测试排除了太多内容。我们如何测试通常存在于页面上的业务逻辑，例如产品配置器，在其中选项会根据用户输入的值显示或隐藏？因此，后来，微软为可测试性框架添加了**第五个支柱**：*测试页面*。
- en: A test page is a logical representation of a page and is strictly handled in
    memory, displaying no UI. It adds methods that allow you to code the behavior
    of the user when accessing a page and its subparts, reading and changing data
    on it, and performing its actions. The fourth test example (in the *UI handlers
    – test example 4* section) will include a test page. So, let's see how we go about
    testing.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 测试页面是页面的逻辑表示，并严格在内存中处理，不显示UI。它添加了允许你编写用户行为的功能，包括访问页面及其子部分、读取和更改数据、执行操作等。第四个测试示例（在*UI
    处理器 – 测试示例 4*部分）将包含一个测试页面。那么，让我们看看如何进行测试。
- en: Find out more details of the five pillars of the testability framework in Luc's
    book at [https://www.packtpub.com/business/automated-testing-microsoft-dynamics-365-business-central](https://www.packtpub.com/business/automated-testing-microsoft-dynamics-365-business-central).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多关于可测试性框架五个支柱的详细信息，请参阅Luc的书：[https://www.packtpub.com/business/automated-testing-microsoft-dynamics-365-business-central](https://www.packtpub.com/business/automated-testing-microsoft-dynamics-365-business-central)。
- en: Designing our test scenarios
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计我们的测试场景
- en: 'As we''ve already mentioned, we will illustrate four of the five pillars of
    testability in a test example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们将在一个测试示例中演示可测试性框架的五个支柱中的四个：
- en: Test codeunit and test function
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试代码单元和测试函数
- en: '`asserterror`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asserterror`'
- en: Test page
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试页面
- en: UI handlers
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI 处理器
- en: We need to have designed each scenario to enable us to code a test efficiently
    and effectively. This is what we will do first in the following section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设计每个场景，以便能够高效有效地编写测试。这是我们在下一节中首先要做的。
- en: In his book, Luc shows extensively how to get from requirements to an automated
    test, or as he calls it *From customer wish to test automation*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的书中，Luc详细展示了如何从需求到自动化测试，或者说他所称的*从客户需求到测试自动化*。
- en: Test codeunit and test function – Test example 1
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试代码单元和测试函数 – 测试示例 1
- en: 'As test codeunits and test functions are the basis of test coding in AL, we
    could take any scenario as an example. But let''s keep it simple and start with
    the basic requirement of our demo extension: the company wants to classify customers
    based on custom categories that they can define over time, and that can change
    in the future.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于测试代码单元和测试函数是AL中测试编码的基础，我们可以以任何场景作为例子。但为了简单起见，我们从演示扩展的基本需求开始：公司希望根据客户可以随时间定义的自定义类别来对客户进行分类，这些类别将来可能会发生变化。
- en: This has been implemented by adding a new table called *Customer Category* with
    a related page, and a new field in the *Customer* table called *Customer Category
    Code*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加一个名为*客户类别*的新表格，并在*客户*表中添加一个名为*客户类别代码*的新字段，已实现此功能。
- en: 'A first test scenario when testing a basic part of this requirement would be
    as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试这个需求的基本部分时，第一个测试场景将如下：
- en: '**[FEATURE]** Customer Category'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[功能]** 客户类别'
- en: '**[SCENARIO #0001]** Assign non-blocked customer category to customer'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[场景 #0001]** 为客户分配非阻塞客户类别'
- en: '**[GIVEN]** A non-blocked customer category'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[给定]** 一个未被阻塞的客户类别'
- en: '**[GIVEN]** A customer'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[给定]** 一个客户'
- en: '**[WHEN]** Set customer category on customer'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[当]** 设置客户类别到客户'
- en: '**[THEN]** Customer has customer category code field populated'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[然后]** 客户的客户类别代码字段已填充'
- en: As each scenario should be self-explanatory, we are not going to elaborate on
    each of the tags.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个场景应该是自解释的，我们不会详细讨论每个标签。
- en: asserterror – Test example 2
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: asserterror – 测试示例 2
- en: 'We can easily illustrate the usage of the asserterror keyword with the scenario
    discussed previously:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过前面讨论的场景，轻松地演示asserterror关键字的使用：
- en: '**[FEATURE]** Customer Category'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[功能]** 客户类别'
- en: '**[SCENARIO #0002]** Assign blocked customer category to customer'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[场景 #0002]** 将阻止的客户类别分配给客户'
- en: '**[GIVEN]** A blocked customer category'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[给定]** 一个被阻止的客户类别'
- en: '**[GIVEN]** A customer'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[给定]** 一个客户'
- en: '**[WHEN]** Set customer category on customer'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[当]** 在客户上设置客户类别'
- en: '**[THEN]** Blocked category error thrown'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[然后]** 抛出阻止类别错误'
- en: This tests the same feature that was defined by the requirement to classify
    customers. However, even though the blocked pattern that was applied to the *Customer
    Category* was not mentioned in the requirements, it has been implemented in the
    extension, throwing an error when assigning a blocked customer category to a customer,
    and therefore it needs to be tested.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这测试了与需求中定义的客户分类功能相同的功能。然而，尽管需求中没有提到应用于*客户类别*的阻止模式，但它已在扩展中实现，当将阻止的客户类别分配给客户时会抛出错误，因此需要进行测试。
- en: Test page – Test example 3
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试页面 – 测试示例 3
- en: According to the business requirements described in [Chapter 5](d8553d40-bf59-4aef-983c-89519ef30e29.xhtml),
    *Developing a Customized Solution for Dynamics 365 Business Central*, the user
    must be <q>"able to create a default customer category and assign this default value
    to a customer automatically."</q>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[第 5 章](d8553d40-bf59-4aef-983c-89519ef30e29.xhtml)中描述的业务需求，*为 Dynamics 365
    Business Central 开发定制解决方案*，用户必须是<q>“能够创建一个默认客户类别，并自动将此默认值分配给客户。”</q>
- en: 'This perfectly illustrates the use of a test page using the following scenario:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这完美地展示了使用以下场景的测试页面：
- en: '**[FEATURE]** Customer Category UI'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[功能]** 客户类别 UI'
- en: '**[SCENARIO #0007]** Assign default category to customer from customer card'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[场景 #0007]** 从客户卡分配默认类别给客户'
- en: '**[GIVEN]** A non-blocked default customer category'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[给定]** 一个非阻止的默认客户类别'
- en: '**[GIVEN]** A customer with customer category not equal to default customer
    category'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[给定]** 客户的客户类别不等于默认客户类别'
- en: '**[WHEN]** Select Assign Default Category action on customer card'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[当]** 在客户卡上选择分配默认类别操作'
- en: '**[THEN]** Customer has default customer category'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[然后]** 客户拥有默认客户类别'
- en: 'It should be noted that we have *UI* in the `[FEATURE]` tag, which denotes
    that the feature is tested by making use of the UI. Preferably, test automation
    is about creating so-called *headless* tests; that is, tests that do not make
    use of the UI, as UI tests are 5 to 10 times slower than headless tests and non-UI
    tests. This is demonstrated by Luc in his book with the following screenshot,
    which compares a similar headless test and a UI test:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，我们在 `[功能]` 标签中使用了*UI*，这表示该功能通过使用 UI 进行测试。理想情况下，测试自动化是指创建所谓的*无头*测试；即不使用
    UI 的测试，因为 UI 测试比无头测试和非 UI 测试慢 5 到 10 倍。Luc 在他的书中通过以下截图展示了这一点，比较了类似的无头测试和 UI 测试：
- en: '![](img/9b5eca60-a41e-4254-b7d5-52ab7b14b0b3.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b5eca60-a41e-4254-b7d5-52ab7b14b0b3.png)'
- en: 'The average execution duration for UI tests is 1.35 s, while the headless average
    is almost seven times faster: 0.20 s.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: UI 测试的平均执行时长为 1.35 秒，而无头测试的平均执行时长几乎快七倍：0.20 秒。
- en: UI handlers – Test example 4
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI 处理程序 – 测试示例 4
- en: 'You might have already inspected all the application code of our demo extension
    on GitHub, and as such you might have seen that few UI elements triggered by code
    need a handler function. Actually, there is only one to be found in the `DoGiftCheck`
    function of the `50101 GiftManagement_PKT`codeunit:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在 GitHub 上检查了我们演示扩展的所有应用程序代码，因此你可能已经看到一些由代码触发的 UI 元素需要处理程序函数。实际上，在 `50101
    GiftManagement_PKT` 代码单元的 `DoGiftCheck` 函数中只找到一个：
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Getting it triggered is not as simple as the other examples, as a lot of conditions
    need to be met. For that reason, it appears here the fourth, and last, example.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 触发它并不像其他示例那么简单，因为需要满足很多条件。因此，它作为第四个也是最后一个示例出现。
- en: 'As you can see, the scenario is indeed somewhat more extensive:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，场景确实要广泛一些：
- en: '**[Feature]** Gifts'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[功能]** 赠品'
- en: '**[Scenario #0010]** Assign quantity on sales line to trigger activepromotion
    message'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[场景 #0010]** 分配销售行的数量以触发活动促销消息'
- en: '**[Given]** Packt setup with Gift Tolerance Qty set'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[给定]** 配置了赠品容忍数量的 Packt 设置'
- en: '**[Given]** Customer with non-blocked customer category with Free Gifts Available'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[给定]** 非阻止客户类别的客户，并且有可用的赠品'
- en: '**[Given]** Item'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[给定]** 商品'
- en: '**[Given]** Gift campaign for item and customer category with Minimum Order
    Quantity set'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[给定]** 设置了最小订单数量的商品和客户类别赠品活动'
- en: '**[Given]** Sales invoice for customer with line for item'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[给定]** 带有商品项目行的客户销售发票'
- en: '**[When]** Set quantity on invoice line smaller than Minimum Order Quantity and
    within Gift Tolerance Qty'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[When]** 设置发票行上的数量小于最小订单数量，并且在赠品容差数量范围内。'
- en: '**[Then]** Active promotion message is displayed'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[Then]** 显示活跃的促销信息。'
- en: Here, we have designed our required test scenarios. In the next section, we'll
    see how to implement them effectively.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们已经设计好了所需的测试场景。接下来的部分，我们将看到如何有效地实现这些场景。
- en: Implementing our test scenarios
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现我们的测试场景
- en: 'Given an ATDD scenario, we can effectively implement test code using the following
    four steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个ATDD场景，我们可以通过以下四个步骤有效地实现测试代码：
- en: Create a test codeunit with a name based on the `[FEATURE]` tag.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基于`[FEATURE]`标签命名的测试代码单元。
- en: Embed the requirement into a test function with a name based on the `[SCENARIO]`
    tag.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将需求嵌入到一个基于`[SCENARIO]`标签命名的测试函数中。
- en: Write the test story based on the `[GIVEN]`, `[WHEN]`, and `[THEN]` tags.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于`[GIVEN]`、`[WHEN]`和`[THEN]`标签编写测试故事。
- en: Construct the real code.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建真正的代码。
- en: Test codeunit and test function – Test example 1
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试代码单元和测试函数 - 测试示例 1
- en: 'Let''s perform this four-step recipe for our first test example with the following
    ATDD scenario:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们根据以下ATDD场景，按四步法进行第一个测试示例：
- en: '**[FEATURE]** Customer Category'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[FEATURE]** 客户类别'
- en: '**[SCENARIO #0001]** Assign non-blocked customer category to customer'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[SCENARIO #0001]** 将非阻止客户类别分配给客户'
- en: '**[GIVEN]** A non-blocked customer category'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[GIVEN]** 一个非阻止的客户类别'
- en: '**[GIVEN]** A customer'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[GIVEN]** 一个客户'
- en: '**[WHEN]** Set customer category on customer'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[WHEN]** 设置客户类别到客户'
- en: '**[THEN]** Customer has customer category code field populated'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[THEN]** 客户已填充客户类别代码字段。'
- en: Create a test codeunit
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个测试代码单元
- en: 'Using the `[FEATURE]` tag and applying the unique suffix for our extension
    is the basic structure of our codeunit, and will look as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`[FEATURE]`标签并应用我们扩展的唯一后缀是我们代码单元的基本结构，结构如下所示：
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, a test codeunit is defined by setting its `SubType` to `Test`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，测试代码单元是通过将其`SubType`设置为`Test`来定义的。
- en: Embed the requirement
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入需求
- en: Now, we create a test function with a name based on the SCENARIO description
    and embed the scenario, the `GIVEN-WHEN-THEN` part, in this function. I call this
    embedding `green`, as it's the commented-out `GIVEN-WHEN-THEN` sentences, before
    you start programming the black part (the `.al` test code).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建一个基于SCENARIO描述命名的测试函数，并将场景（`GIVEN-WHEN-THEN`部分）嵌入到该函数中。我称这种嵌入为`green`，因为它是被注释掉的`GIVEN-WHEN-THEN`语句，在你开始编写`black`部分（`.al`测试代码）之前。
- en: 'Look at what the codeunit has now become:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 看看代码单元现在变成了什么样子：
- en: '[PRE5]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A test function is denoted by the `[Test]`tag. If you forget to add this tag
    to a function, it will be a normal function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 测试函数由`[Test]`标签标识。如果忘记给一个函数添加此标签，它将变成普通函数。
- en: Writing the test story
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试故事
- en: Writing the first `black` parts is about writing pseudo-English, defining what
    needs to be achieved with a test. It makes a test readable by any non-technical
    peer in the project, and in the event their support is needed, the threshold for
    them to read the test is substantially lower than if the code had been written
    as technical code. And, maybe an even stronger argument is that the code will
    be embedded in reusable helper functions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 编写第一部分`black`内容时，实际上是在编写伪英语，定义测试需要达到的目标。这使得任何非技术同行都能轻松阅读测试，如果需要他们的支持，他们读取测试的门槛就远低于如果代码是技术性代码时的难度。更强的论点可能是，代码将嵌入到可重用的辅助函数中。
- en: 'So, here we go; let''s write the `black` parts:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，开始吧；让我们编写`black`部分：
- en: '[PRE6]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This `story` sets up four helper functions in which the content will be constructed
    in the next step. Note how close the names of the helper functions are to the
    descriptions of the tags that they belong to, and that no arguments or return
    values have been defined yet.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`story`设置了四个辅助函数，内容将在下一步中构建。请注意，这些辅助函数的名称与它们所属标签的描述有多么接近，而且还没有定义任何参数或返回值。
- en: Constructing the real code
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建真正的代码
- en: 'Writing the test story showed us that we need four helper functions, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试故事让我们了解到我们需要四个辅助函数，如下所示：
- en: '`CreateNonBlockedCustomerCategory`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateNonBlockedCustomerCategory`'
- en: '`CreateCustomer`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateCustomer`'
- en: '`SetCustomerCategoryOnCustomer`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetCustomerCategoryOnCustomer`'
- en: '`VerifyCustomerCategoryOnCustomer`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VerifyCustomerCategoryOnCustomer`'
- en: Let's construct and discuss them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建并讨论它们。
- en: CreateNonBlockedCustomerCategory
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CreateNonBlockedCustomerCategory
- en: '`CreateNonBlockedCustomerCategory` is a manifold reusable helper function that
    creates a pseudo-random `Customer Category` record. At a later stage, we could
    promote this to become a library codeunit. The implementation is as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateNonBlockedCustomerCategory`是一个多用途的可重用辅助函数，用于创建一个伪随机的`Customer Category`记录。在稍后的阶段，我们可以将其提升为库代码单元。其实现如下：'
- en: '[PRE7]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To populate the primary key field, we make use of the `GenerateRandomCode` function
    from the standard test library's `LibraryUtility` codeunit (`131000`). The `LibraryUtility`
    variable is declared globally as Microsoft does in their test codeunits, making
    it reusable in other helper functions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了填充主键字段，我们使用标准测试库`LibraryUtility`代码单元（`131000`）中的`GenerateRandomCode`函数。`LibraryUtility`变量像Microsoft在他们的测试代码单元中那样被全局声明，使其在其他辅助函数中可重用。
- en: 'We can observe the following from the preceding code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从前面的代码中观察到以下几点：
- en: Pseudo-random means that whenever our test is executed in the same context,
    the `GenerateRandomCode` function will yield the same value, contributing to a
    reproducible test.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伪随机意味着每当我们的测试在相同的上下文中执行时，`GenerateRandomCode`函数将产生相同的值，从而有助于测试的可重复性。
- en: The `Description` field is populated by the same value as the `Code` field,
    as the specific value of `Description` has no meaning, and this way it's most
    effective.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Description`字段由与`Code`字段相同的值填充，因为`Description`的具体值没有意义，这样做是最有效的。'
- en: Using the `with-do` construct in helper functions allows easy reuse of the code
    for similar purposes, but is applied to other tables as it only needs a change
    in the record variable (and the table it is referencing).
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在辅助函数中使用`with-do`结构可以方便地将代码用于类似的目的，只需要改变记录变量（以及它引用的表），就能将代码应用到其他表上。
- en: CreateCustomer
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CreateCustomer
- en: 'Using the `CreateCustomer` function in the standard library''s `LibrarySales`
    codeunit (`130509`), our `CreateCustomer` creates a useable customer record and
    makes this helper function a straightforward exercise. Have a look at the following
    code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准库`LibrarySales`代码单元（`130509`）中的`CreateCustomer`函数，我们的`CreateCustomer`创建一个可用的客户记录，使得这个辅助函数变得非常简便。看看以下代码：
- en: '[PRE8]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As with the `LibraryUtility` variable, we will declare the `LibrarySales` variable
    globally.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 和`LibraryUtility`变量一样，我们将全局声明`LibrarySales`变量。
- en: You might wonder why we create a helper function that only has one statement
    line. As we've already mentioned, using helper functions makes the test readable
    for non-technical peers, and makes it reusable. What we haven't mentioned is that
    it also makes it more maintainable/extendable. If we need to update the customer
    record created by the `CreateCustomer` function in the `Library - Sales` codeunit,
    we only need to add that to our local `CreateCustomer` function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么我们创建一个只有一行语句的辅助函数。正如我们之前提到的，使用辅助函数可以让测试对非技术同事更具可读性，并且使其可重用。我们没有提到的一点是，它还使得代码更易于维护和扩展。如果我们需要更新`Library
    - Sales`代码单元中`CreateCustomer`函数创建的客户记录，我们只需将其添加到本地的`CreateCustomer`函数中。
- en: SetCustomerCategoryOnCustomer
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SetCustomerCategoryOnCustomer
- en: 'Have a look at the implementation of `SetLookupValueOnCustomer`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`SetLookupValueOnCustomer`的实现：
- en: '[PRE9]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Calling `Validate` is essential here. `SetLookupValueOnCustomer` is not just
    about assigning a value to the `Customer Category Code_PKT` field, but also about
    making sure it is validated against existing values in the `Customer Category`
    table. Note that the `OnValidate` trigger of the `Customer Category Code_PKT`
    field does not contain code.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里调用`Validate`是至关重要的。`SetLookupValueOnCustomer`不仅仅是将一个值分配给`Customer Category
    Code_PKT`字段，还要确保它与`Customer Category`表中现有的值进行验证。请注意，`Customer Category Code_PKT`字段的`OnValidate`触发器没有代码。
- en: VerifyCustomerCategoryOnCustomer
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VerifyCustomerCategoryOnCustomer
- en: 'Each test needs to verify its outcome. Put bluntly, a test without verification
    is not a test. And for the current test, we need to verify that the customer category
    code that is assigned to the `Customer Category Code_PKT` field of the customer
    record is indeed the value that was created in the `Customer Category` table.
    We therefore retrieve the record from the database and verify the content of the
    `Customer Category Code_PKT` field as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试都需要验证其结果。直白地说，没有验证的测试就不是测试。对于当前的测试，我们需要验证分配给客户记录中`Customer Category Code_PKT`字段的客户类别代码确实是`Customer
    Category`表中创建的值。因此，我们从数据库中检索记录，并验证`Customer Category Code_PKT`字段的内容如下：
- en: '[PRE10]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To verify that the expected value (first argument) and the actual value (second
    argument) are equal, we make use of the `AreEqual` function in the standard library
    `Assert` codeunit (`130000`). Of course, we could build our own verification logic
    using the error system function, and that''s what `AreEqual` is doing too. Have
    a look at the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证预期值（第一个参数）和实际值（第二个参数）是否相等，我们使用标准库 `Assert` 代码单元（`130000`）中的 `AreEqual` 函数。当然，我们也可以使用错误系统函数构建自己的验证逻辑，而
    `AreEqual` 实际上就是这样做的。请看以下代码：
- en: '[PRE11]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By using the `AreEqual` function, however, we ensure that we get a standardized
    error message in case the expected and actual values are not equal. Over time,
    when reading the error of any failing test, you will be able to easily recognize
    the kind of error that occurred, given that your verification helper functions
    make use of the `Assert` library.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `AreEqual` 函数，我们确保在预期值和实际值不相等时，能够得到一个标准化的错误信息。随着时间的推移，当你查看任何失败测试的错误时，由于你的验证辅助函数使用了
    `Assert` 库，你将能够轻松识别发生的错误类型。
- en: 'The completed test function would look like the following code, which is ready
    for execution:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的测试函数如下所示，已经准备好执行：
- en: '[PRE12]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice the variables and arguments that have been added to the test codeunit
    and functions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，已经添加到测试代码单元和函数中的变量和参数。
- en: Go to the GitHub repository for this book to have a look at the full implementation
    of the test codeunit: [https://github.com/PacktPublishing/Mastering-Microsoft-Dynamics-365-Business-Central](https://github.com/PacktPublishing/Mastering-Microsoft-Dynamics-365-Business-Central).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 前往本书的 GitHub 仓库查看完整的测试代码单元实现：[https://github.com/PacktPublishing/Mastering-Microsoft-Dynamics-365-Business-Central](https://github.com/PacktPublishing/Mastering-Microsoft-Dynamics-365-Business-Central)。
- en: Running the test
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'The proof of the pudding is in the eating, as they say, so let''s run our test.
    The easiest and most instructive way to do this is by making use of the **Test
    Tool** in the application. You can easily access the Test Tool using the Tell
    Me... feature in Dynamics 365 Business Central:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如人们常说的，“实践出真知”，让我们运行我们的测试。最简单且最具指导性的方法是通过应用程序中的**测试工具**。你可以通过 Dynamics 365
    Business Central 中的“告诉我...”功能轻松访问测试工具：
- en: '![](img/03f6cd3b-2ed6-4ba4-91fe-88bc0d30214d.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03f6cd3b-2ed6-4ba4-91fe-88bc0d30214d.png)'
- en: 'When in a clean database, or at least a database or company where the Test
    Tool has not been used yet, this is what the Test Tool looks like, a suite called
    DEFAULT with no records in it, as shown here:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个干净的数据库中，或者至少在没有使用过测试工具的数据库或公司中，测试工具的界面如下所示，显示为一个名为 DEFAULT 的套件，其中没有任何记录：
- en: '![](img/ec02762c-bcdd-443f-93cd-27ba2253551b.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec02762c-bcdd-443f-93cd-27ba2253551b.png)'
- en: 'To add our test to the suite, follow these steps:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的测试添加到测试套件中，请按照以下步骤操作：
- en: Select the **Get Test Codeunits** action.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**获取测试代码单元**操作。
- en: 'In the dialog that opens, you have two options:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的对话框中，你有两个选项：
- en: '**Select Test Codeunits**:This will open a page with a list showing all test
    codeunits that are present in the database, from which you can select specific
    test codeunits; once you have selected them and clicked OK, these codeunits will
    be added to the suite.'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选择测试代码单元**：这将打开一个页面，列出数据库中所有存在的测试代码单元，你可以从中选择特定的测试代码单元；选择后点击确定，这些代码单元将被添加到套件中。'
- en: '**All Test Codeunits**:This will add all test codeunits that exist in the database
    to the test suite.'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**所有测试代码单元**：这将把数据库中所有现有的测试代码单元添加到测试套件中。'
- en: 'Let''s select the first option, **Select Test Codeunits**. This will open the CAL
    TEST GET CODEUNITS page. It shows the test codeunit that we have just created
    and a bunch of tests that reside in the database, mainly due to standard extensions:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择第一个选项，**选择测试代码单元**。这将打开 CAL TEST GET CODEUNITS 页面。页面显示了我们刚刚创建的测试代码单元以及数据库中存在的一堆测试，主要是由于标准扩展的存在：
- en: '![](img/9570ab20-81c7-40ef-9bc4-36bd225e9750.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9570ab20-81c7-40ef-9bc4-36bd225e9750.png)'
- en: Select the test codeunit and click **OK**. The suite now shows for each test
    codeunit, a line with `Codeunit` in the Line Type column, and linked to this line
    (and indented), all its test functions (with `Function` in the Line Type column).
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择测试代码单元并点击**确定**。现在，套件中会显示每个测试代码单元，在“行类型”列中显示`Codeunit`，并且与该行（并且缩进）关联的所有测试函数将在“行类型”列中显示为`Function`。
- en: 'To run the tests, select the **Run** action in the dialog that opens, with
    the Active Codeunit and Alloptions. Since we have only one codeunit in the `DEFAULT`
    test suite, it does not matter which option we choose, so click **OK**. Now our
    test codeunit will be run, and each test will yield a `Success`result:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行测试，在打开的对话框中选择**运行**操作，并选中活动代码单元和所有选项。由于在`DEFAULT`测试套件中只有一个代码单元，因此选择哪个选项无关紧要，所以点击**确定**。现在，我们的测试代码单元将会运行，每个测试都会产生`成功`结果：
- en: '![](img/ec4ddf14-ff08-48fc-a3c1-b4744d5c92af.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec4ddf14-ff08-48fc-a3c1-b4744d5c92af.png)'
- en: Had we selected the **Active Codeunit **option, only the selected codeunit would
    have been executed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择了**活动代码单元**选项，那么只有选定的代码单元会被执行。
- en: For each failure, the First Error field will display the error that caused the
    failure. As you can see, First Error is `FlowField`. If you drill down into it,
    the CAL Test Result window opens. This displays the whole test run history for
    a specific test.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个失败，"第一个错误"字段将显示导致失败的错误。如您所见，第一个错误是`FlowField`。如果进一步查看，会打开CAL测试结果窗口，显示特定测试的整个测试运行历史。
- en: Running the test by clicking on **Run** will call the standard test runner codeunit, CAL
    Test Runner (130400), and will make sure that tests run from the Test Tool will
    be run in isolation, and the results of each test function will be logged.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击**运行**来运行测试，将调用标准测试运行器代码单元，CAL测试运行器（130400），并确保从测试工具运行的测试会在隔离状态下执行，每个测试函数的结果将被记录。
- en: asserterror – Test example 2
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: asserterror – 测试示例2
- en: 'As mentioned earlier, we will illustrate the use of *asserterror* with scenario
    #0002:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用*asserterror*来说明场景#0002：
- en: '**[FEATURE]** Customer Category'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[功能]** 客户类别'
- en: '**[SCENARIO #0002]** Assign blocked customer category to customer'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[场景#0002]** 将被阻止的客户类别分配给客户'
- en: '**[GIVEN]** A blocked customer category'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[给定]** 一个被阻止的客户类别'
- en: '**[GIVEN]** A customer'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[给定]** 一个客户'
- en: '**[WHEN]** Set customer category on customer'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[当]** 设置客户的客户类别'
- en: '**[THEN]** Blocked category error thrown'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[然后]** 抛出阻止类别错误'
- en: Creating a test codeunit
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建测试代码单元
- en: Sharing the same `[FEATURE]` tag value as test example 1, our new test case
    will also share the same test codeunit, that is, `60100 Customer Category PKT`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 与测试示例1共享相同的`[功能]`标签值，我们的新测试用例也将共享相同的测试代码单元，即`60100 Customer Category PKT`。
- en: Embedding the requirement
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入需求
- en: 'According to the previous requirements, we need to create the following new
    test function in the `60100` codeunit:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前的要求，我们需要在`60100`代码单元中创建以下新的测试函数：
- en: '[PRE13]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Writing the test story
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试用例
- en: 'Given test example 1, writing the test story isn''t a difficult exercise. Have
    a look at the following code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 基于测试示例1，编写测试用例并不是一个困难的练习。请查看以下代码：
- en: '[PRE14]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First of all, note how `asserterror` has been applied – in front of the call
    to the `SetCustomerCategoryOnCustomer` helper function. This ensures that the
    platform will expect `SetCustomerCategoryOnCustomer` to throw an error. `asserterror`
    enables the test to continue with the next statement and it will not check the
    error, as such. So, it is up to us to verify that the expected did occur. If there
    is no verification of the specific error following `asserterror`, any error will
    make your test pass.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意`asserterror`是如何应用的——在调用`SetCustomerCategoryOnCustomer`辅助函数之前。这确保了平台期望`SetCustomerCategoryOnCustomer`抛出一个错误。`asserterror`使得测试可以继续执行下一个语句，并且不会检查错误。因此，我们需要验证预期的错误是否确实发生。如果在`asserterror`之后没有验证特定错误，任何错误都会使测试通过。
- en: Next, note that, based on test example 1, the required variables have already
    been provided.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请注意，基于测试示例1，所需的变量已经提供。
- en: Constructing the real code
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造真实的代码
- en: 'If we reuse the `CreateCustomer` and `SetCustomerCategoryOnCustomer` functions
    from test example 1, we only need to create two new helper functions:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重用测试示例1中的`CreateCustomer`和`SetCustomerCategoryOnCustomer`函数，我们只需要创建两个新的辅助函数：
- en: '`CreateBlockedCustomerCategory`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateBlockedCustomerCategory`'
- en: '`VerifyBlockedCategoryErrorThrown`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VerifyBlockedCategoryErrorThrown`'
- en: Let's learn more about them both next.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入了解它们俩。
- en: CreateBlockedCustomerCategory
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CreateBlockedCustomerCategory
- en: 'With the goal of `CreateBlockedCustomerCategory` being very similar to the
    `CreateNonBlockedCustomerCategory` helper function from test example 1, its construction
    is as simple, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是`CreateBlockedCustomerCategory`与测试示例1中的`CreateNonBlockedCustomerCategory`辅助函数非常相似，因此其构造也非常简单，如下所示：
- en: '[PRE15]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: VerifyBlockedCategoryErrorThrown
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VerifyBlockedCategoryErrorThrown
- en: 'Earlier, it was noted that, when `asserterror` enables the test to continue
    with the next statement, it will not check the error as such. And that is what
    this helper function needs to do, as shown in the following code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到过，当 `asserterror` 使测试继续执行到下一个语句时，它不会检查错误。因此，这正是此辅助函数需要做的事情，如下代码所示：
- en: '[PRE16]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Running the test
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试
- en: Let's redeploy our extension and add the second test to the Test Tool by selecting
    **Actions | Functions | Get Test Methods**. Get Test Methods will update the selected
    test codeunit by adding all current test functions in the codeunit as lines in
    the Test Tool. Note that the RESULT column will be cleared. Now, run the test
    codeunit and see that both tests are successful.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新部署扩展并通过选择 **操作 | 函数 | 获取测试方法** 将第二个测试添加到测试工具中。获取测试方法会通过将代码单元中的所有当前测试函数作为行添加到测试工具中来更新所选的测试代码单元。请注意，RESULT
    列将被清除。现在，运行测试代码单元并查看两个测试是否都成功。
- en: 'Consider the next screenshot, which shows the results of the tests:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请看下一个截图，显示了测试结果：
- en: '![](img/57d7de52-64a5-4f13-bb78-aafe526453f5.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57d7de52-64a5-4f13-bb78-aafe526453f5.png)'
- en: Running the test codeunit will show that both tests have been executed successfully.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试代码单元将显示两个测试都已成功执行。
- en: Testing the test
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试测试
- en: 'How do we verify that success is a real success? We can do this in a simple
    way – by providing a different expected value to the verification function of
    our test case. So let''s do it:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何验证成功是真正的成功？我们可以通过简单的方式做到这一点——通过为测试案例的验证函数提供一个不同的期望值。所以我们来做：
- en: '[PRE17]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Running our second test will now yield a failure with the next error text:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 运行第二个测试时，当前将出现失败，并显示以下错误文本：
- en: '[PRE18]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The *actual error*, indeed, is the one that should occur. After this, we move
    on to test example 3.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*实际错误*确实是应该发生的错误。完成此步骤后，我们继续测试示例 3。'
- en: Test page – Test example 3
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试页面 – 测试示例 3
- en: 'We''ll illustrate the usage of a test page in the next scenario:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个场景中展示如何使用测试页面：
- en: '**[FEATURE]** Customer Category'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[功能]** 客户类别'
- en: '**[SCENARIO #0007]** Assign default category to customer from customer card'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[场景 #0007]** 从客户卡片为客户分配默认类别'
- en: '**[GIVEN]** A non-blocked default customer category'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[假设]** 非阻止的默认客户类别'
- en: '**[GIVEN]** A customer with customer category not equal to default customer
    category'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[假设]** 客户的客户类别与默认客户类别不相等'
- en: '**[WHEN]** Select Assign Default Category action on customer card'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[当]** 在客户卡片上选择分配默认类别操作'
- en: '**[THEN]** Customer has default customer category'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[假设]** 客户有默认客户类别'
- en: As you should now know the first steps in the four-step recipe, let's go faster
    and *create*, *embed*, and *write* in one fell swoop.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该知道四步法中的第一步，让我们加快速度，一次性*创建*、*嵌入*和*编写*。
- en: Creating a test codeunit
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建测试代码单元
- en: Sharing the same `[FEATURE]` tag value as test examples 1 and 2, our new test
    case will share the same test codeunit, which is `60100 Customer Category PKT`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 与测试示例 1 和 2 共享相同的 `[功能]` 标签值，我们的新测试案例将共享相同的测试代码单元，即 `60100 Customer Category
    PKT`。
- en: Embedding and writing
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入和编写
- en: 'In the already-existing `60100 Customer Category PKT` codeunit, we embed the
    requirements and write the test story, which leads us to the following test function:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在已经存在的 `60100 Customer Category PKT` 代码单元中，我们嵌入了需求并编写了测试故事，这引导我们到了以下的测试功能：
- en: '[PRE19]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Constructing the real code
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建实际代码
- en: 'In order to have the `#0007` scenario working properly, we need to create these
    four helper functions:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 `#0007` 场景正常工作，我们需要创建以下四个辅助函数：
- en: '`CreateNonBlockedDefaultCustomerCategory`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateNonBlockedDefaultCustomerCategory`'
- en: '`CreateCustomerWithCustomerCategoryNotEqualToDefault`'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateCustomerWithCustomerCategoryNotEqualToDefault`'
- en: '`SelectAssignDefaultCategoryActionOnCustomerCard`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectAssignDefaultCategoryActionOnCustomerCard`'
- en: '`VerifyCustomerHasDefaultCustomerCategory`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VerifyCustomerHasDefaultCustomerCategory`'
- en: But, as you will see, and as you will also experience when writing more tests,
    the majority of these helper functions are easy to construct by making use of
    previously developed helper functions.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如你将看到的，并且在编写更多测试时你也会体会到，这些辅助函数大部分都可以通过利用之前开发的辅助函数轻松构建。
- en: CreateNonBlockedDefaultCustomerCategory
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CreateNonBlockedDefaultCustomerCategory
- en: '`CreateNonBlockedDefaultCustomerCategory` resembles the `CreateBlockedCustomerCategory`
    helper function that was created for test example 2\. We can use the same approach
    that was used there. Have a look at the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateNonBlockedDefaultCustomerCategory` 类似于为测试示例 2 创建的 `CreateBlockedCustomerCategory`
    辅助函数。我们可以使用那里使用的相同方法。看看以下代码：'
- en: '[PRE20]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that the `FindFirst` construction has been added to guarantee that only
    one default customer category will be added.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，已添加`FindFirst`构造，以确保只会添加一个默认客户类别。
- en: CreateCustomerWithCustomerCategoryNotEqualToDefault
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CreateCustomerWithCustomerCategoryNotEqualToDefault
- en: 'Calling the `CreateCustomer` helper function suffices as the customer record
    that is created will have an empty `Customer Category Code` field. This makes
    the construction of this helper function a very easy exercise, as you can see
    in the following code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`CreateCustomer`助手函数即可，因为创建的客户记录将会有一个空的`Customer Category Code`字段。这使得构建这个助手函数变得非常简单，正如你在以下代码中看到的：
- en: '[PRE21]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: SelectAssignDefaultCategoryActionOnCustomerCard
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SelectAssignDefaultCategoryActionOnCustomerCard
- en: 'With the helper function, we touch on the core of this test example – making
    use of a test page to achieve `#0007`, that is, testing that the user can assign
    a default customer category to a specific customer. The following is what the
    helper function looks like:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个助手函数，我们触及了这个测试示例的核心——利用测试页面实现`#0007`，即测试用户能否将默认客户类别分配给特定客户。以下是这个助手函数的样子：
- en: '[PRE22]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that I did not use a `with-do` construct to unambiguously show that the
    three statements in the function are referencing methods that you will only find
    on test page objects, and not on normal pages:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我没有使用`with-do`结构，以明确展示该函数中的三个语句是引用了你只能在测试页面对象上找到的方法，而不是普通页面上的方法：
- en: '`OpenView`: Opens the test page in view mode'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OpenView`：以查看模式打开测试页面'
- en: '`GoToKey`: Finds the row in a dataset that is identified by the specified values'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GoToKey`：在数据集中查找由指定值标识的行'
- en: '`Invoke`: Invokes an action on a test page'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Invoke`：在测试页面上调用一个动作'
- en: 'For a complete listing of all test page methods, take a look at the following
    URLs:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有测试页面方法的完整列表，请查看以下网址：
- en: '`TestPage`: [https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testpage/testpage-data-type](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testpage/testpage-data-type)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestPage`：[https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testpage/testpage-data-type](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testpage/testpage-data-type)'
- en: '`TestField`: [https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testfield/testfield-data-type](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testfield/testfield-data-type)'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestField`：[https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testfield/testfield-data-type](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testfield/testfield-data-type)'
- en: '`TestAction`: [https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testaction/testaction-data-type](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testaction/testaction-data-type)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestAction`：[https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testaction/testaction-data-type](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testaction/testaction-data-type)'
- en: You can find more details on test pages in Luc's book at [https://www.packtpub.com/business/automated-testing-microsoft-dynamics-365-business-central](https://www.packtpub.com/business/automated-testing-microsoft-dynamics-365-business-central).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Luc的书中找到更多关于测试页面的详细信息：[https://www.packtpub.com/business/automated-testing-microsoft-dynamics-365-business-central](https://www.packtpub.com/business/automated-testing-microsoft-dynamics-365-business-central)
- en: VerifyCustomerHasDefaultCustomerCategory
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VerifyCustomerHasDefaultCustomerCategory
- en: 'As the code for the default customer category is stored in the local `CustomerCategoryCode`
    variable in test example 4, verifying that the `CustomerCategoryCode` field on
    the customer record has indeed been populated with the default customer category
    is just a case of calling the already-existing `VerifyCustomerCategoryOnCustomer` helper
    function, as shown in the following code:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 由于默认客户类别的代码存储在测试示例4中的本地`CustomerCategoryCode`变量中，验证`CustomerCategoryCode`字段是否确实已经填充了默认客户类别，只需调用已存在的`VerifyCustomerCategoryOnCustomer`助手函数，正如以下代码所示：
- en: '[PRE23]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Running the test
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试
- en: Running both test codeunits will show that all tests are executed successfully.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这两个测试代码单元会显示所有测试都已成功执行。
- en: More examples for the Customer Category feature
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户类别功能的更多示例
- en: In the GitHub repository for this book, you will find an extra number of test
    scenarios regarding the Customer Category feature. Go there and study them, and
    see how various helper functions have to be reused, showing that building up a
    bigger test suite often involves the reuse of existing elements. You might have
    wondered why the test examples weren't consecutively numbered. Inspecting the
    other scenarios on GitHub will show you why.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的 GitHub 仓库中，你将找到一些关于客户类别功能的额外测试场景。去那里学习它们，看看如何重用各种辅助函数，这表明构建一个更大的测试套件通常涉及到现有元素的重用。你可能会想知道为什么测试示例没有连续编号。检查
    GitHub 上的其他场景，你会明白为什么。
- en: UI handler – Test example 4
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI 处理器 – 测试示例 4
- en: 'In order to show you how to implement a `UI handler` function, we are going
    to have a go at the following scenario:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向你展示如何实现`UI handler`函数，我们将尝试以下场景：
- en: '**[Feature]** Gifts'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[Feature]** 礼品'
- en: '**[Scenario #0010]** Assign quantity on sales line to trigger active promotion
    message'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[Scenario #0010]** 在销售行上分配数量以触发激活的促销消息'
- en: '**[Given]** Packt setup with Gift Tolerance Qty set'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[Given]** 设置了礼品容差数量的 Packt 设置'
- en: '**[Given]** Customer with non-blocked customer category with Free Gifts Available'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[Given]** 具有免费礼品可用的非阻塞客户类别的客户'
- en: '**[Given]** Item'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[Given]** 商品'
- en: '**[Given]** Gift campaign for item and customer category with Minimum Order
    Quantity set'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[Given]** 为商品和客户类别设置了最小订购数量的礼品活动'
- en: '**[Given]** Sales invoice for customer with line for item'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[Given]** 客户的销售发票，包含商品的行'
- en: '**[When]** Set quantity on invoice line smaller than Minimum Order Quantity and
    within Gift Tolerance Qty'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[When]** 设置发票行上的数量小于最小订购数量，并且在礼品容差数量范围内'
- en: '**[Then]** Active promotion message is displayed'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[Then]** 显示激活的促销消息'
- en: As this is quite an extensive scenario, you will also explore and learn from
    a somewhat more complex test code sample.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个相当广泛的场景，你还将探索并学习一个相对复杂的测试代码示例。
- en: Creating a test codeunit
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个测试代码单元
- en: 'Typically, a test codeunit can be viewed as a test suite that tests a feature.
    As this feature, `Gifts`, is different from the one addressed in the previous
    test examples, we should contain this test in a new test codeunit, as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个测试代码单元可以看作是一个测试套件，用于测试某个功能。由于此功能`Gifts`与前面测试示例中处理的功能不同，我们应该将此测试包含在一个新的测试代码单元中，如下所示：
- en: '[PRE24]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Embedding and writing
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入和编写
- en: 'Embedding and writing would now lead to a test function with the following
    pseudo-code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入和编写现在将导致一个具有以下伪代码的测试函数：
- en: '[PRE25]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is the pseudo-code that describes the process for assigning gifts. In the
    next section, we'll see the real implementation.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这是描述分配礼品过程的伪代码。在下一节中，我们将看到实际的实现。
- en: Note that, due to their length, some function names have been cut into two and
    spread over two lines.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于函数名称较长，部分函数名称已被拆分并分布在两行。
- en: Constructing the real code
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建真实代码
- en: 'Given the *written story* (in the previous section), we now need to create
    the following seven helper functions in order to implement real test code effectively:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 基于*书面故事*（在前一节中），我们现在需要创建以下七个辅助函数，以便有效地实现真实的测试代码：
- en: '`CreatePacktSetupWithGiftToleranceQty`'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreatePacktSetupWithGiftToleranceQty`'
- en: '`CreateCustomerWithNonBlockedCustomerCategoryWith`'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateCustomerWithNonBlockedCustomerCategoryWith`'
- en: '`FreeGiftsAvailable`'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`FreeGiftsAvailable`'
- en: '[PRE26]'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`CreateGiftCampaignForItemAndCustomerCategory`'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateGiftCampaignForItemAndCustomerCategory`'
- en: '[PRE27]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`` `CreateSalesInvoiceForCustomerWithLineForItem` ``'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `CreateSalesInvoiceForCustomerWithLineForItem` ``'
- en: '`AssignQuantityOnInvoiceLineSmallerThanMinimumOrderQuantity`'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AssignQuantityOnInvoiceLineSmallerThanMinimumOrderQuantity`'
- en: '`AndWithinGiftToleranceQty`'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`AndWithinGiftToleranceQty`'
- en: '`VerifyActivePromotionMessageIsDisplayed`'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VerifyActivePromotionMessageIsDisplayed`'
- en: Let's jump through the *real code* and take a look at a couple of specifics.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳过*真实代码*，看看几个具体细节。
- en: CreatePacktSetupWithGiftToleranceQty
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CreatePacktSetupWithGiftToleranceQty
- en: 'The `CreatePacktSetupWithGiftToleranceQty` helper function''s main purpose
    is to set `GiftToleranceQty` on the extension setup, and is given by the following
    code:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreatePacktSetupWithGiftToleranceQty` 辅助函数的主要目的是在扩展设置中设置`GiftToleranceQty`，其代码如下：'
- en: '[PRE28]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The CreateCustomerWithNonBlockedCustomerCategoryWithFreeGiftsAvailable helper
    function
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CreateCustomerWithNonBlockedCustomerCategoryWithFreeGiftsAvailable 辅助函数
- en: '`CreateCustomerWithNonBlockedCustomerCategoryWithFreeGiftsAvailable` is a helper
    function that creates a customer with a non-blocking customer category set, and
    it''s implemented as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateCustomerWithNonBlockedCustomerCategoryWithFreeGiftsAvailable` 是一个辅助函数，用于创建一个具有非阻塞客户类别设置的客户，其实现如下：'
- en: '[PRE29]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that, like our previous helper function, `CreateCustomer` (see test examples
    1 and 2), this test function also makes use of the standard `CreateCustomer` function
    in the standard library `LibrarySales` codeunit (`130509`).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，像我们之前的辅助函数`CreateCustomer`（参见测试示例1和2）一样，这个测试函数也使用了标准库`LibrarySales`代码单元（`130509`）中的标准`CreateCustomer`函数。
- en: CreateItem
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CreateItem
- en: '`CreateItem` is a similar construction to the `CreateCustomer` function, as
    it makes use of the `CreateItem` function in the standard library `LibraryInventory`
    codeunit (`132201`). As a matter of fact, it''s just a wrapper around it, as seen
    in the following code:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateItem`是一个类似于`CreateCustomer`函数的构造，它利用标准库`LibraryInventory`代码单元（`132201`）中的`CreateItem`函数。实际上，它只是对它的封装，如以下代码所示：'
- en: '[PRE30]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: CreateGiftCampaignForItemAndCustomerCategoryWithMinimumOrderQuantity
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CreateGiftCampaignForItemAndCustomerCategoryWithMinimumOrderQuantity
- en: '`CreateGiftCampaignForItemAndCustomerCategoryWithMinimumOrderQuantity` has
    to create a gift campaign record that combines the item that has just been created
    and the customer category that is linked to the newly created customer, and defines
    the period of time within the campaign will be valid and active. Have a look at
    what the functions look like:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateGiftCampaignForItemAndCustomerCategoryWithMinimumOrderQuantity`必须创建一个赠品活动记录，结合刚刚创建的项目和与新创建的客户关联的客户类别，并定义活动有效和激活的时间段。看看这些函数的样子：'
- en: '[PRE31]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: CreateSalesInvoiceForCustomerWithLineForItem
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CreateSalesInvoiceForCustomerWithLineForItem
- en: 'When provided with the numbers of our item and customer, the `CreateSalesInvoiceForCustomerWithLineForItem`
    helper function has to create a new sales invoice with one line, making use of
    the `CreateSalesDocumentWithItem` helper function from the standard library `Library
    - Sales` codeunit (`130509`). The following is what its implementation looks like:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 当提供我们项目和客户的编号时，`CreateSalesInvoiceForCustomerWithLineForItem`辅助函数必须创建一个新的销售发票，其中包含一行，并利用标准库`Library
    - Sales`代码单元（`130509`）中的`CreateSalesDocumentWithItem`辅助函数。以下是它的实现方式：
- en: '[PRE32]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that no quantity is yet set on the line, as per the sixth parameter in
    the call to `CreateSalesDocumentWithItem`. The last two parameters of `CreateSalesDocumentWithItem`
    denote an undefined location and shipment date.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，行上尚未设置数量，正如在调用`CreateSalesDocumentWithItem`时的第六个参数所示。`CreateSalesDocumentWithItem`的最后两个参数表示一个未定义的位置和发货日期。
- en: SetQuantityOnInvoiceLineSmallerThanMinimumOrderQuantityAndWithinGiftToleranceQty
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SetQuantityOnInvoiceLineSmallerThanMinimumOrderQuantityAndWithinGiftToleranceQty
- en: The main purpose of this helper function is to set and validate the quantity
    on the sales invoice line, so that, when it is smaller than the minimum order
    quantity on the gift campaign and everything is within the gift tolerance as defined
    in the setup, calling `Validate` will trigger the message.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这个辅助函数的主要目的是设置和验证销售发票行上的数量，以便当数量小于赠品活动中的最小订购数量，且一切都在设置中定义的赠品容差范围内时，调用`Validate`将触发消息。
- en: 'Have a look at the following code:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下代码：
- en: '[PRE33]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A very useful exercise before coding the `[THEN]` part is to run the test.
    In the case of this test, it will show us something that''s very relevant. But
    before we do, we need to update the last details in our test function, as we haven''t
    specified the various parameters when calling the helper functions. So, the following
    is what the new test codeunit has become:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写`[THEN]`部分之前，做一个非常有用的练习就是运行测试。在这个测试的情况下，它将展示一些非常相关的内容。但在我们进行之前，我们需要更新测试函数中的最后细节，因为我们在调用辅助函数时没有指定各种参数。因此，以下是新的测试代码单元的样子：
- en: '[PRE34]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Running the test
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'So, let''s run the test, even though it''s not ready yet. As the screenshot
    demonstrates, there is an `unhandled UI` element, `Message`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们运行测试，尽管它还没有准备好。正如截图所示，存在一个`未处理的UI`元素，`消息`：
- en: '![](img/23f13168-714a-49b0-afd0-2a71883895dd.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23f13168-714a-49b0-afd0-2a71883895dd.png)'
- en: 'If we read the error message more closely, we see that it''s the message that
    we wanted to evoke:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细阅读错误消息，我们会看到这是我们想要触发的消息：
- en: '[PRE35]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This shows us two things:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们展示了两件事：
- en: We have successfully evoked the message.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经成功触发了消息。
- en: We need to implement a so-called `MessageHandler` function.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要实现一个所谓的`MessageHandler`函数。
- en: 'The following is what the simplest `MessageHandler` function looks like:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最简单的`MessageHandler`函数的样子：
- en: '[PRE36]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will handle the message; that is, it will mimic a user pressing the **OK**
    button on the message dialog. Note that the name of this function doesn't need
    to be `MessageHandler`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这将处理消息；也就是说，它将模拟用户按下消息对话框中的**确定**按钮。请注意，这个函数的名称不一定需要是`MessageHandler`。
- en: 'Having a `MessageHandler` function is not sufficient. It also needs to be bound
    to the test function that is triggering the message. This is done by setting the
    `HandlerFunctions` property of the test function as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个`MessageHandler`函数是不够的。它还需要绑定到触发消息的测试函数。这是通过以下方式设置测试函数的`HandlerFunctions`属性来完成的：
- en: '[PRE37]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Running the test again demonstrates that it is successful now, but remember: *a
    test with no verification is no test*. The `MessageHandler` function could be
    triggered by any message. The last helper function we have to tackle, `VerifyActivePromotionMessageIsDisplayed`,
    needs to verify that our test did indeed evoke the right message.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试表明现在测试是成功的，但请记住：*没有验证的测试就不是测试*。`MessageHandler`函数可能会被任何消息触发。我们需要处理的最后一个辅助函数`VerifyActivePromotionMessageIsDisplayed`，需要验证我们的测试确实触发了正确的消息。
- en: VerifyActivePromotionMessageIsDisplayed
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VerifyActivePromotionMessageIsDisplayed
- en: Let's leave something for you to discover. Go to GitHub and have a look at how
    this is implemented.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们留点东西给你去发现吧。去GitHub看一下这是如何实现的。
- en: In this section, we have learned how to create automatic tests for your extensions
    according to your business scenarios. Automatic testing is absolutely a must-have
    with Dynamics 365 Business Central (it's mandatory for AppSource apps, but it's
    also a best practice to follow in general).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何根据业务场景为扩展创建自动化测试。自动化测试在Dynamics 365 Business Central中绝对是必不可少的（它对于AppSource应用是强制要求的，但总的来说它也是一个最佳实践）。
- en: Summary
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have discussed the basics of how to create automated tests
    in Dynamics 365 Business Central.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，我们讨论了如何在Dynamics 365 Business Central中创建自动化测试的基础知识。
- en: We utilized the ATDD test case pattern in order to design each test, and then
    used it as a base structure in our four-step recipe to create a test codeunit,
    embed the customer choice into a test, write a test story, and finally construct
    your real code. You should now be comfortable with writing tests for your extensions
    according to your business needs.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了ATDD测试用例模式来设计每个测试，然后在我们的四步流程中将其作为基础结构：创建测试代码单元、将客户选择嵌入到测试中、编写测试故事，最后构建你的实际代码。现在你应该能根据业务需求轻松编写扩展测试了。
- en: 'In the next chapter, we''ll explore another important aspect to master when
    developing solutions for Dynamics 365 Business Central: source code management
    and DevOps practices.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探索在开发Dynamics 365 Business Central解决方案时需要掌握的另一个重要方面：源代码管理和DevOps实践。
