- en: Automated Test Development with AL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how to debug AL extensions with Visual Studio
    Code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will have a look at how to write automated tests for an
    extension in AL. We need to do this in order to have a modern development life
    cycle, and it's mandatory if you want to publish your extensions on AppSource.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the demo extension that was developed in [Chapter 5](d8553d40-bf59-4aef-983c-89519ef30e29.xhtml),
    *Developing a Customized Solution for Dynamics 365 Business Central*, we will
    cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Designing tests using the Acceptance Test-Driven Development pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a test extension
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The technique behind testing code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing test code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test automation and testing design principles
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application testing is not rocket science. Neither is automated application
    testing. It's just another learnable skill. From a developer's perspective, however,
    you need a change of mindset to write code with a totally different purpose than
    you're used to do. It's common knowledge that developers should never test their
    own code, as they, consciously or unconsciously, know how to use the software
    and how to evade issues. They write code to make something work.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Testing, however, is not about *how to make it*; rather, it's about *how to
    break it*. But this knowledge applies to manual, exploratory testing, where tests
    are executed based on knowledge and experience, not to scripts. And automatic
    tests are scripts.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: To code these scripts into automated tests, we'll need developers. And more
    often than not, it will be the same developer that did the application coding.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: In order for developers to code automated tests, they need to be provided with
    well-defined scripts. If there is **no design**, there will be **no test**. And
    that's the approach we will take in this chapter—we will first design tests and
    then show you how to code them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Designing tests with ATDD
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In his book, *Automated Testing in Microsoft Dynamics 365 Business Central*,
    Luc van Vugt delves into how to design and implement your tests. Based on the
    so-called **Acceptance Test-Driven Development** (**ATDD**) methodology, he shows
    how to write your requirements like a test design using the ATDD pattern. This
    pattern introduces five tags:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'FEATURE: Defines what feature(s) the test or collection of test cases is testing.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SCENARIO: Defines the scenario being tested for a single test.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GIVEN: Defines what data setup is needed; a test case can have multiple GIVEN
    tags when the data setup is more complex.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'WHEN: Defines the action under test; each test case should have only one WHEN
    tag.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'THEN: Defines the result of the action, or more specifically, the verification
    of the result. If multiple results apply, multiple THEN tags will be needed.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is what a ATDD scenario would look like for our customer category
    feature:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '**[FEATURE]** Customer Category'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[SCENARIO #0002]** Assign blocked customer category to customer'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[GIVEN]** A blocked customer category'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[GIVEN]** A customer'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[WHEN]** Set customer category on customer'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[THEN]** Blocked category error thrown'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can acquire Luc's book at
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/automated-testing-in-microsoft-dynamics-365-business-central](https://www.packtpub.com/automated-testing-in-microsoft-dynamics-365-business-central).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: After learning how to design, we will now look at how to prepare the environment.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the environment
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to start writing automated tests on your AL extension, you need to
    import *Microsoft Test Framework* into your Dynamics 365 Business Central environment.
    If you're working with Dynamics 365 Business Central on-premise (standalone installation),
    you can import it from the product DVD. If you are using a Docker-based development
    sandbox, you can import the Test Toolkit automatically with the `navcontainerhelper` module by
    adding the `-includeTestToolkit` switch parameter to the `New-BcContainer` cmdlet.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have an already-running Docker container with Dynamics 365 Business
    Central, you can import the Test Toolkit by using the following cmdlets:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The Test Toolkit Test Libraries consist of the following five apps (included
    in the latest Docker images in the `C:\Applications folder`):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '`Microsoft_Any.app`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft_Library Assert.app`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft_System Application Test Library.app`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft_Tests-TestLibraries.app`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft_Test Runner.app`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your environment now contains all that you need to write and execute automatic
    tests. In the next section, we'll see how to set up tests for your extensions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Setting up test development for extensions
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we take the most restrictive requirement for extensions (the requirement
    that Microsoft considers mandatory for approving your extension for release to
    AppSource), app and test code should be placed in separate extensions. As such,
    the test extension should have a dependency on the app extension.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: This separation, however, might restrict the parallel development of the app
    and test code, since any change to an app extension results in its redeployment.
    This potentially also results in an update and redeployment of the test extension.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Before you realize it, you are continuously juggling your extensions, thereby
    reducing the productivity of the development team. The best course of action,
    while developing, is to have the app and test code placed in the same extension.
    Once it's ready, you can split up the code and create the two mandatory extensions
    by means of an automated build script or a specific merging strategy.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: If your extension is not to be put on AppSource, I still strongly advise you
    not to release the test code in the app extension, in order to prevent automated
    tests from being run in a production environment.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: In the specific case of our demo extension, where the app code is already completed,
    we can set up our test in a separate, dependent extension. In the next section,
    we'll see how to do that in practice.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our Visual Studio Code test project
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To set up a new project for our test automation, perform the operation we carried
    out in [Chapter 5](d8553d40-bf59-4aef-983c-89519ef30e29.xhtml), *Developing a
    Customized Solution for Dynamics 365 Business Central*, when we started our demo
    extension. Make sure that the `app.json` of our new test project is updated as
    follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, we have added the dependencies from the extension to the test,
    and from all the *Test Toolkit Libraries* apps that are needed for testing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the technique behind test code
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start coding tests, we need to learn a couple of things about the
    technique behind test code, the so-called **testability framework**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Since NAV 2009 Service Pack 1, Microsoft has allowed the platform to let you
    build test suites by means of *test functions* in *test codeunits*. When executing
    a test codeunit, the platform will do the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Run the `OnRun` trigger and each test function that resides in the test codeunit,
    from top to bottom
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Record the result of each test function
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is what Luc van Vugt calls the **first pillar** of the testability framework.
    Our first test example will implement this.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'The **second pillar** allows you to create so-called *positive–negative*, or
    *rainy-path*, tests, in which we test the circumstances that led to failure. To
    achieve this, we use the AL `asserterror` keyword, which should be applied in
    front of the calling statement to catch the error and let the test pass:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our second scenario, which was used in a previous example, will make use of
    this testability feature.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: In various parts of our code, we will interact with the user, asking them, for
    example, to confirm a certain action, or by simply displaying a message. When
    automating tests, we need to be able to handle these user interactions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: For this, the **third pillar**, the **user interface** (**UI**) *handler functions*,
    has been conceived. *Handler functions* are a special type of function that can
    only be created in test codeunits, and aim to handle UI interactions that exist
    in the code under test. They enable us to fully automate tests without the need
    for a real user to interact with them. Our third test example will show us how
    to do this.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'The **fourth pillar** is the *test runner*. This is a specific codeunit that
    can do the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Run tests that are stored in multiple codeunits, control their execution, and
    collect and secure the results
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do this run in isolation so that write transactions, in the end, do not alter
    the database that we run the test on, and so that each rerun of a test is done
    using the same initial data setup
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When running the test that we are going to build, we will make use of the standard
    test runner that resides in Dynamics 365 Business Central.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: The initial trigger for adding the testability framework to the platform was
    implemented to get away from testing the business logic through the UI. As such,
    the testability framework is enabled headless, and thus there is faster testing
    of the business logic and it is not possible to test the UI.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 向平台添加可测试性框架的初始触发点是为了避免通过UI测试业务逻辑。因此，启用可测试性框架时是无头的，从而可以更快速地测试业务逻辑，但无法测试UI。
- en: 'Moving ahead, it became clear that sole headless tests excluded too much. How
    do we test business logic that typically resides on pages, such as a product configurator,
    in which options are displayed or hidden depending on the values entered by the
    user? So, later, Microsoft added a **fifth pillar** to the testability framework:
    the *test page*.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进时，显而易见，单独的无头测试排除了太多内容。我们如何测试通常存在于页面上的业务逻辑，例如产品配置器，在其中选项会根据用户输入的值显示或隐藏？因此，后来，微软为可测试性框架添加了**第五个支柱**：*测试页面*。
- en: A test page is a logical representation of a page and is strictly handled in
    memory, displaying no UI. It adds methods that allow you to code the behavior
    of the user when accessing a page and its subparts, reading and changing data
    on it, and performing its actions. The fourth test example (in the *UI handlers
    – test example 4* section) will include a test page. So, let's see how we go about
    testing.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 测试页面是页面的逻辑表示，并严格在内存中处理，不显示UI。它添加了允许你编写用户行为的功能，包括访问页面及其子部分、读取和更改数据、执行操作等。第四个测试示例（在*UI
    处理器 – 测试示例 4*部分）将包含一个测试页面。那么，让我们看看如何进行测试。
- en: Find out more details of the five pillars of the testability framework in Luc's
    book at [https://www.packtpub.com/business/automated-testing-microsoft-dynamics-365-business-central](https://www.packtpub.com/business/automated-testing-microsoft-dynamics-365-business-central).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多关于可测试性框架五个支柱的详细信息，请参阅Luc的书：[https://www.packtpub.com/business/automated-testing-microsoft-dynamics-365-business-central](https://www.packtpub.com/business/automated-testing-microsoft-dynamics-365-business-central)。
- en: Designing our test scenarios
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计我们的测试场景
- en: 'As we''ve already mentioned, we will illustrate four of the five pillars of
    testability in a test example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们将在一个测试示例中演示可测试性框架的五个支柱中的四个：
- en: Test codeunit and test function
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试代码单元和测试函数
- en: '`asserterror`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asserterror`'
- en: Test page
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试页面
- en: UI handlers
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI 处理器
- en: We need to have designed each scenario to enable us to code a test efficiently
    and effectively. This is what we will do first in the following section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设计每个场景，以便能够高效有效地编写测试。这是我们在下一节中首先要做的。
- en: In his book, Luc shows extensively how to get from requirements to an automated
    test, or as he calls it *From customer wish to test automation*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的书中，Luc详细展示了如何从需求到自动化测试，或者说他所称的*从客户需求到测试自动化*。
- en: Test codeunit and test function – Test example 1
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试代码单元和测试函数 – 测试示例 1
- en: 'As test codeunits and test functions are the basis of test coding in AL, we
    could take any scenario as an example. But let''s keep it simple and start with
    the basic requirement of our demo extension: the company wants to classify customers
    based on custom categories that they can define over time, and that can change
    in the future.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于测试代码单元和测试函数是AL中测试编码的基础，我们可以以任何场景作为例子。但为了简单起见，我们从演示扩展的基本需求开始：公司希望根据客户可以随时间定义的自定义类别来对客户进行分类，这些类别将来可能会发生变化。
- en: This has been implemented by adding a new table called *Customer Category* with
    a related page, and a new field in the *Customer* table called *Customer Category
    Code*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加一个名为*客户类别*的新表格，并在*客户*表中添加一个名为*客户类别代码*的新字段，已实现此功能。
- en: 'A first test scenario when testing a basic part of this requirement would be
    as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试这个需求的基本部分时，第一个测试场景将如下：
- en: '**[FEATURE]** Customer Category'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[功能]** 客户类别'
- en: '**[SCENARIO #0001]** Assign non-blocked customer category to customer'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[场景 #0001]** 为客户分配非阻塞客户类别'
- en: '**[GIVEN]** A non-blocked customer category'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[给定]** 一个未被阻塞的客户类别'
- en: '**[GIVEN]** A customer'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[给定]** 一个客户'
- en: '**[WHEN]** Set customer category on customer'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[当]** 设置客户类别到客户'
- en: '**[THEN]** Customer has customer category code field populated'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[然后]** 客户的客户类别代码字段已填充'
- en: As each scenario should be self-explanatory, we are not going to elaborate on
    each of the tags.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个场景应该是自解释的，我们不会详细讨论每个标签。
- en: asserterror – Test example 2
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: asserterror – 测试示例 2
- en: 'We can easily illustrate the usage of the asserterror keyword with the scenario
    discussed previously:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过前面讨论的场景，轻松地演示asserterror关键字的使用：
- en: '**[FEATURE]** Customer Category'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[SCENARIO #0002]** Assign blocked customer category to customer'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[GIVEN]** A blocked customer category'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[GIVEN]** A customer'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[WHEN]** Set customer category on customer'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[THEN]** Blocked category error thrown'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This tests the same feature that was defined by the requirement to classify
    customers. However, even though the blocked pattern that was applied to the *Customer
    Category* was not mentioned in the requirements, it has been implemented in the
    extension, throwing an error when assigning a blocked customer category to a customer,
    and therefore it needs to be tested.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Test page – Test example 3
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the business requirements described in [Chapter 5](d8553d40-bf59-4aef-983c-89519ef30e29.xhtml),
    *Developing a Customized Solution for Dynamics 365 Business Central*, the user
    must be <q>"able to create a default customer category and assign this default value
    to a customer automatically."</q>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'This perfectly illustrates the use of a test page using the following scenario:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '**[FEATURE]** Customer Category UI'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[SCENARIO #0007]** Assign default category to customer from customer card'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[GIVEN]** A non-blocked default customer category'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[GIVEN]** A customer with customer category not equal to default customer
    category'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[WHEN]** Select Assign Default Category action on customer card'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[THEN]** Customer has default customer category'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It should be noted that we have *UI* in the `[FEATURE]` tag, which denotes
    that the feature is tested by making use of the UI. Preferably, test automation
    is about creating so-called *headless* tests; that is, tests that do not make
    use of the UI, as UI tests are 5 to 10 times slower than headless tests and non-UI
    tests. This is demonstrated by Luc in his book with the following screenshot,
    which compares a similar headless test and a UI test:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b5eca60-a41e-4254-b7d5-52ab7b14b0b3.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: 'The average execution duration for UI tests is 1.35 s, while the headless average
    is almost seven times faster: 0.20 s.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: UI handlers – Test example 4
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might have already inspected all the application code of our demo extension
    on GitHub, and as such you might have seen that few UI elements triggered by code
    need a handler function. Actually, there is only one to be found in the `DoGiftCheck`
    function of the `50101 GiftManagement_PKT`codeunit:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Getting it triggered is not as simple as the other examples, as a lot of conditions
    need to be met. For that reason, it appears here the fourth, and last, example.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the scenario is indeed somewhat more extensive:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '**[Feature]** Gifts'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Scenario #0010]** Assign quantity on sales line to trigger activepromotion
    message'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Given]** Packt setup with Gift Tolerance Qty set'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Given]** Customer with non-blocked customer category with Free Gifts Available'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Given]** Item'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Given]** Gift campaign for item and customer category with Minimum Order
    Quantity set'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Given]** Sales invoice for customer with line for item'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[When]** Set quantity on invoice line smaller than Minimum Order Quantity and
    within Gift Tolerance Qty'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[When]** 设置发票行上的数量小于最小订单数量，并且在赠品容差数量范围内。'
- en: '**[Then]** Active promotion message is displayed'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[Then]** 显示活跃的促销信息。'
- en: Here, we have designed our required test scenarios. In the next section, we'll
    see how to implement them effectively.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们已经设计好了所需的测试场景。接下来的部分，我们将看到如何有效地实现这些场景。
- en: Implementing our test scenarios
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现我们的测试场景
- en: 'Given an ATDD scenario, we can effectively implement test code using the following
    four steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个ATDD场景，我们可以通过以下四个步骤有效地实现测试代码：
- en: Create a test codeunit with a name based on the `[FEATURE]` tag.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基于`[FEATURE]`标签命名的测试代码单元。
- en: Embed the requirement into a test function with a name based on the `[SCENARIO]`
    tag.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将需求嵌入到一个基于`[SCENARIO]`标签命名的测试函数中。
- en: Write the test story based on the `[GIVEN]`, `[WHEN]`, and `[THEN]` tags.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于`[GIVEN]`、`[WHEN]`和`[THEN]`标签编写测试故事。
- en: Construct the real code.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建真正的代码。
- en: Test codeunit and test function – Test example 1
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试代码单元和测试函数 - 测试示例 1
- en: 'Let''s perform this four-step recipe for our first test example with the following
    ATDD scenario:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们根据以下ATDD场景，按四步法进行第一个测试示例：
- en: '**[FEATURE]** Customer Category'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[FEATURE]** 客户类别'
- en: '**[SCENARIO #0001]** Assign non-blocked customer category to customer'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[SCENARIO #0001]** 将非阻止客户类别分配给客户'
- en: '**[GIVEN]** A non-blocked customer category'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[GIVEN]** 一个非阻止的客户类别'
- en: '**[GIVEN]** A customer'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[GIVEN]** 一个客户'
- en: '**[WHEN]** Set customer category on customer'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[WHEN]** 设置客户类别到客户'
- en: '**[THEN]** Customer has customer category code field populated'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[THEN]** 客户已填充客户类别代码字段。'
- en: Create a test codeunit
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个测试代码单元
- en: 'Using the `[FEATURE]` tag and applying the unique suffix for our extension
    is the basic structure of our codeunit, and will look as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`[FEATURE]`标签并应用我们扩展的唯一后缀是我们代码单元的基本结构，结构如下所示：
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, a test codeunit is defined by setting its `SubType` to `Test`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，测试代码单元是通过将其`SubType`设置为`Test`来定义的。
- en: Embed the requirement
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入需求
- en: Now, we create a test function with a name based on the SCENARIO description
    and embed the scenario, the `GIVEN-WHEN-THEN` part, in this function. I call this
    embedding `green`, as it's the commented-out `GIVEN-WHEN-THEN` sentences, before
    you start programming the black part (the `.al` test code).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建一个基于SCENARIO描述命名的测试函数，并将场景（`GIVEN-WHEN-THEN`部分）嵌入到该函数中。我称这种嵌入为`green`，因为它是被注释掉的`GIVEN-WHEN-THEN`语句，在你开始编写`black`部分（`.al`测试代码）之前。
- en: 'Look at what the codeunit has now become:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 看看代码单元现在变成了什么样子：
- en: '[PRE5]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A test function is denoted by the `[Test]`tag. If you forget to add this tag
    to a function, it will be a normal function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 测试函数由`[Test]`标签标识。如果忘记给一个函数添加此标签，它将变成普通函数。
- en: Writing the test story
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试故事
- en: Writing the first `black` parts is about writing pseudo-English, defining what
    needs to be achieved with a test. It makes a test readable by any non-technical
    peer in the project, and in the event their support is needed, the threshold for
    them to read the test is substantially lower than if the code had been written
    as technical code. And, maybe an even stronger argument is that the code will
    be embedded in reusable helper functions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 编写第一部分`black`内容时，实际上是在编写伪英语，定义测试需要达到的目标。这使得任何非技术同行都能轻松阅读测试，如果需要他们的支持，他们读取测试的门槛就远低于如果代码是技术性代码时的难度。更强的论点可能是，代码将嵌入到可重用的辅助函数中。
- en: 'So, here we go; let''s write the `black` parts:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，开始吧；让我们编写`black`部分：
- en: '[PRE6]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This `story` sets up four helper functions in which the content will be constructed
    in the next step. Note how close the names of the helper functions are to the
    descriptions of the tags that they belong to, and that no arguments or return
    values have been defined yet.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`story`设置了四个辅助函数，内容将在下一步中构建。请注意，这些辅助函数的名称与它们所属标签的描述有多么接近，而且还没有定义任何参数或返回值。
- en: Constructing the real code
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建真正的代码
- en: 'Writing the test story showed us that we need four helper functions, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试故事让我们了解到我们需要四个辅助函数，如下所示：
- en: '`CreateNonBlockedCustomerCategory`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateNonBlockedCustomerCategory`'
- en: '`CreateCustomer`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateCustomer`'
- en: '`SetCustomerCategoryOnCustomer`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetCustomerCategoryOnCustomer`'
- en: '`VerifyCustomerCategoryOnCustomer`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VerifyCustomerCategoryOnCustomer`'
- en: Let's construct and discuss them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建并讨论它们。
- en: CreateNonBlockedCustomerCategory
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CreateNonBlockedCustomerCategory
- en: '`CreateNonBlockedCustomerCategory` is a manifold reusable helper function that
    creates a pseudo-random `Customer Category` record. At a later stage, we could
    promote this to become a library codeunit. The implementation is as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateNonBlockedCustomerCategory`是一个多用途的可重用辅助函数，用于创建一个伪随机的`Customer Category`记录。在稍后的阶段，我们可以将其提升为库代码单元。其实现如下：'
- en: '[PRE7]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To populate the primary key field, we make use of the `GenerateRandomCode` function
    from the standard test library's `LibraryUtility` codeunit (`131000`). The `LibraryUtility`
    variable is declared globally as Microsoft does in their test codeunits, making
    it reusable in other helper functions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了填充主键字段，我们使用标准测试库`LibraryUtility`代码单元（`131000`）中的`GenerateRandomCode`函数。`LibraryUtility`变量像Microsoft在他们的测试代码单元中那样被全局声明，使其在其他辅助函数中可重用。
- en: 'We can observe the following from the preceding code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从前面的代码中观察到以下几点：
- en: Pseudo-random means that whenever our test is executed in the same context,
    the `GenerateRandomCode` function will yield the same value, contributing to a
    reproducible test.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伪随机意味着每当我们的测试在相同的上下文中执行时，`GenerateRandomCode`函数将产生相同的值，从而有助于测试的可重复性。
- en: The `Description` field is populated by the same value as the `Code` field,
    as the specific value of `Description` has no meaning, and this way it's most
    effective.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Description`字段由与`Code`字段相同的值填充，因为`Description`的具体值没有意义，这样做是最有效的。'
- en: Using the `with-do` construct in helper functions allows easy reuse of the code
    for similar purposes, but is applied to other tables as it only needs a change
    in the record variable (and the table it is referencing).
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在辅助函数中使用`with-do`结构可以方便地将代码用于类似的目的，只需要改变记录变量（以及它引用的表），就能将代码应用到其他表上。
- en: CreateCustomer
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CreateCustomer
- en: 'Using the `CreateCustomer` function in the standard library''s `LibrarySales`
    codeunit (`130509`), our `CreateCustomer` creates a useable customer record and
    makes this helper function a straightforward exercise. Have a look at the following
    code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准库`LibrarySales`代码单元（`130509`）中的`CreateCustomer`函数，我们的`CreateCustomer`创建一个可用的客户记录，使得这个辅助函数变得非常简便。看看以下代码：
- en: '[PRE8]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As with the `LibraryUtility` variable, we will declare the `LibrarySales` variable
    globally.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 和`LibraryUtility`变量一样，我们将全局声明`LibrarySales`变量。
- en: You might wonder why we create a helper function that only has one statement
    line. As we've already mentioned, using helper functions makes the test readable
    for non-technical peers, and makes it reusable. What we haven't mentioned is that
    it also makes it more maintainable/extendable. If we need to update the customer
    record created by the `CreateCustomer` function in the `Library - Sales` codeunit,
    we only need to add that to our local `CreateCustomer` function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么我们创建一个只有一行语句的辅助函数。正如我们之前提到的，使用辅助函数可以让测试对非技术同事更具可读性，并且使其可重用。我们没有提到的一点是，它还使得代码更易于维护和扩展。如果我们需要更新`Library
    - Sales`代码单元中`CreateCustomer`函数创建的客户记录，我们只需将其添加到本地的`CreateCustomer`函数中。
- en: SetCustomerCategoryOnCustomer
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SetCustomerCategoryOnCustomer
- en: 'Have a look at the implementation of `SetLookupValueOnCustomer`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`SetLookupValueOnCustomer`的实现：
- en: '[PRE9]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Calling `Validate` is essential here. `SetLookupValueOnCustomer` is not just
    about assigning a value to the `Customer Category Code_PKT` field, but also about
    making sure it is validated against existing values in the `Customer Category`
    table. Note that the `OnValidate` trigger of the `Customer Category Code_PKT`
    field does not contain code.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里调用`Validate`是至关重要的。`SetLookupValueOnCustomer`不仅仅是将一个值分配给`Customer Category
    Code_PKT`字段，还要确保它与`Customer Category`表中现有的值进行验证。请注意，`Customer Category Code_PKT`字段的`OnValidate`触发器没有代码。
- en: VerifyCustomerCategoryOnCustomer
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VerifyCustomerCategoryOnCustomer
- en: 'Each test needs to verify its outcome. Put bluntly, a test without verification
    is not a test. And for the current test, we need to verify that the customer category
    code that is assigned to the `Customer Category Code_PKT` field of the customer
    record is indeed the value that was created in the `Customer Category` table.
    We therefore retrieve the record from the database and verify the content of the
    `Customer Category Code_PKT` field as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试都需要验证其结果。直白地说，没有验证的测试就不是测试。对于当前的测试，我们需要验证分配给客户记录中`Customer Category Code_PKT`字段的客户类别代码确实是`Customer
    Category`表中创建的值。因此，我们从数据库中检索记录，并验证`Customer Category Code_PKT`字段的内容如下：
- en: '[PRE10]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To verify that the expected value (first argument) and the actual value (second
    argument) are equal, we make use of the `AreEqual` function in the standard library
    `Assert` codeunit (`130000`). Of course, we could build our own verification logic
    using the error system function, and that''s what `AreEqual` is doing too. Have
    a look at the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证预期值（第一个参数）和实际值（第二个参数）是否相等，我们使用标准库 `Assert` 代码单元（`130000`）中的 `AreEqual` 函数。当然，我们也可以使用错误系统函数构建自己的验证逻辑，而
    `AreEqual` 实际上就是这样做的。请看以下代码：
- en: '[PRE11]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By using the `AreEqual` function, however, we ensure that we get a standardized
    error message in case the expected and actual values are not equal. Over time,
    when reading the error of any failing test, you will be able to easily recognize
    the kind of error that occurred, given that your verification helper functions
    make use of the `Assert` library.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `AreEqual` 函数，我们确保在预期值和实际值不相等时，能够得到一个标准化的错误信息。随着时间的推移，当你查看任何失败测试的错误时，由于你的验证辅助函数使用了
    `Assert` 库，你将能够轻松识别发生的错误类型。
- en: 'The completed test function would look like the following code, which is ready
    for execution:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的测试函数如下所示，已经准备好执行：
- en: '[PRE12]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice the variables and arguments that have been added to the test codeunit
    and functions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，已经添加到测试代码单元和函数中的变量和参数。
- en: Go to the GitHub repository for this book to have a look at the full implementation
    of the test codeunit: [https://github.com/PacktPublishing/Mastering-Microsoft-Dynamics-365-Business-Central](https://github.com/PacktPublishing/Mastering-Microsoft-Dynamics-365-Business-Central).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 前往本书的 GitHub 仓库查看完整的测试代码单元实现：[https://github.com/PacktPublishing/Mastering-Microsoft-Dynamics-365-Business-Central](https://github.com/PacktPublishing/Mastering-Microsoft-Dynamics-365-Business-Central)。
- en: Running the test
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'The proof of the pudding is in the eating, as they say, so let''s run our test.
    The easiest and most instructive way to do this is by making use of the **Test
    Tool** in the application. You can easily access the Test Tool using the Tell
    Me... feature in Dynamics 365 Business Central:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如人们常说的，“实践出真知”，让我们运行我们的测试。最简单且最具指导性的方法是通过应用程序中的**测试工具**。你可以通过 Dynamics 365
    Business Central 中的“告诉我...”功能轻松访问测试工具：
- en: '![](img/03f6cd3b-2ed6-4ba4-91fe-88bc0d30214d.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03f6cd3b-2ed6-4ba4-91fe-88bc0d30214d.png)'
- en: 'When in a clean database, or at least a database or company where the Test
    Tool has not been used yet, this is what the Test Tool looks like, a suite called
    DEFAULT with no records in it, as shown here:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个干净的数据库中，或者至少在没有使用过测试工具的数据库或公司中，测试工具的界面如下所示，显示为一个名为 DEFAULT 的套件，其中没有任何记录：
- en: '![](img/ec02762c-bcdd-443f-93cd-27ba2253551b.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec02762c-bcdd-443f-93cd-27ba2253551b.png)'
- en: 'To add our test to the suite, follow these steps:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的测试添加到测试套件中，请按照以下步骤操作：
- en: Select the **Get Test Codeunits** action.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**获取测试代码单元**操作。
- en: 'In the dialog that opens, you have two options:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的对话框中，你有两个选项：
- en: '**Select Test Codeunits**:This will open a page with a list showing all test
    codeunits that are present in the database, from which you can select specific
    test codeunits; once you have selected them and clicked OK, these codeunits will
    be added to the suite.'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选择测试代码单元**：这将打开一个页面，列出数据库中所有存在的测试代码单元，你可以从中选择特定的测试代码单元；选择后点击确定，这些代码单元将被添加到套件中。'
- en: '**All Test Codeunits**:This will add all test codeunits that exist in the database
    to the test suite.'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**所有测试代码单元**：这将把数据库中所有现有的测试代码单元添加到测试套件中。'
- en: 'Let''s select the first option, **Select Test Codeunits**. This will open the CAL
    TEST GET CODEUNITS page. It shows the test codeunit that we have just created
    and a bunch of tests that reside in the database, mainly due to standard extensions:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择第一个选项，**选择测试代码单元**。这将打开 CAL TEST GET CODEUNITS 页面。页面显示了我们刚刚创建的测试代码单元以及数据库中存在的一堆测试，主要是由于标准扩展的存在：
- en: '![](img/9570ab20-81c7-40ef-9bc4-36bd225e9750.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9570ab20-81c7-40ef-9bc4-36bd225e9750.png)'
- en: Select the test codeunit and click **OK**. The suite now shows for each test
    codeunit, a line with `Codeunit` in the Line Type column, and linked to this line
    (and indented), all its test functions (with `Function` in the Line Type column).
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择测试代码单元并点击**确定**。现在，套件中会显示每个测试代码单元，在“行类型”列中显示`Codeunit`，并且与该行（并且缩进）关联的所有测试函数将在“行类型”列中显示为`Function`。
- en: 'To run the tests, select the **Run** action in the dialog that opens, with
    the Active Codeunit and Alloptions. Since we have only one codeunit in the `DEFAULT`
    test suite, it does not matter which option we choose, so click **OK**. Now our
    test codeunit will be run, and each test will yield a `Success`result:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ec4ddf14-ff08-48fc-a3c1-b4744d5c92af.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: Had we selected the **Active Codeunit **option, only the selected codeunit would
    have been executed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: For each failure, the First Error field will display the error that caused the
    failure. As you can see, First Error is `FlowField`. If you drill down into it,
    the CAL Test Result window opens. This displays the whole test run history for
    a specific test.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Running the test by clicking on **Run** will call the standard test runner codeunit, CAL
    Test Runner (130400), and will make sure that tests run from the Test Tool will
    be run in isolation, and the results of each test function will be logged.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: asserterror – Test example 2
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, we will illustrate the use of *asserterror* with scenario
    #0002:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '**[FEATURE]** Customer Category'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[SCENARIO #0002]** Assign blocked customer category to customer'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[GIVEN]** A blocked customer category'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[GIVEN]** A customer'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[WHEN]** Set customer category on customer'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[THEN]** Blocked category error thrown'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a test codeunit
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sharing the same `[FEATURE]` tag value as test example 1, our new test case
    will also share the same test codeunit, that is, `60100 Customer Category PKT`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Embedding the requirement
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to the previous requirements, we need to create the following new
    test function in the `60100` codeunit:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Writing the test story
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given test example 1, writing the test story isn''t a difficult exercise. Have
    a look at the following code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First of all, note how `asserterror` has been applied – in front of the call
    to the `SetCustomerCategoryOnCustomer` helper function. This ensures that the
    platform will expect `SetCustomerCategoryOnCustomer` to throw an error. `asserterror`
    enables the test to continue with the next statement and it will not check the
    error, as such. So, it is up to us to verify that the expected did occur. If there
    is no verification of the specific error following `asserterror`, any error will
    make your test pass.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Next, note that, based on test example 1, the required variables have already
    been provided.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the real code
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we reuse the `CreateCustomer` and `SetCustomerCategoryOnCustomer` functions
    from test example 1, we only need to create two new helper functions:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '`CreateBlockedCustomerCategory`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VerifyBlockedCategoryErrorThrown`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's learn more about them both next.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: CreateBlockedCustomerCategory
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the goal of `CreateBlockedCustomerCategory` being very similar to the
    `CreateNonBlockedCustomerCategory` helper function from test example 1, its construction
    is as simple, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: VerifyBlockedCategoryErrorThrown
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier, it was noted that, when `asserterror` enables the test to continue
    with the next statement, it will not check the error as such. And that is what
    this helper function needs to do, as shown in the following code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Running the test
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's redeploy our extension and add the second test to the Test Tool by selecting
    **Actions | Functions | Get Test Methods**. Get Test Methods will update the selected
    test codeunit by adding all current test functions in the codeunit as lines in
    the Test Tool. Note that the RESULT column will be cleared. Now, run the test
    codeunit and see that both tests are successful.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the next screenshot, which shows the results of the tests:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57d7de52-64a5-4f13-bb78-aafe526453f5.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: Running the test codeunit will show that both tests have been executed successfully.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Testing the test
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How do we verify that success is a real success? We can do this in a simple
    way – by providing a different expected value to the verification function of
    our test case. So let''s do it:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Running our second test will now yield a failure with the next error text:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The *actual error*, indeed, is the one that should occur. After this, we move
    on to test example 3.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Test page – Test example 3
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll illustrate the usage of a test page in the next scenario:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '**[FEATURE]** Customer Category'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[SCENARIO #0007]** Assign default category to customer from customer card'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[GIVEN]** A non-blocked default customer category'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[GIVEN]** A customer with customer category not equal to default customer
    category'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[WHEN]** Select Assign Default Category action on customer card'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[THEN]** Customer has default customer category'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you should now know the first steps in the four-step recipe, let's go faster
    and *create*, *embed*, and *write* in one fell swoop.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test codeunit
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sharing the same `[FEATURE]` tag value as test examples 1 and 2, our new test
    case will share the same test codeunit, which is `60100 Customer Category PKT`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Embedding and writing
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the already-existing `60100 Customer Category PKT` codeunit, we embed the
    requirements and write the test story, which leads us to the following test function:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Constructing the real code
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to have the `#0007` scenario working properly, we need to create these
    four helper functions:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '`CreateNonBlockedDefaultCustomerCategory`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateCustomerWithCustomerCategoryNotEqualToDefault`'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectAssignDefaultCategoryActionOnCustomerCard`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VerifyCustomerHasDefaultCustomerCategory`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But, as you will see, and as you will also experience when writing more tests,
    the majority of these helper functions are easy to construct by making use of
    previously developed helper functions.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: CreateNonBlockedDefaultCustomerCategory
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`CreateNonBlockedDefaultCustomerCategory` resembles the `CreateBlockedCustomerCategory`
    helper function that was created for test example 2\. We can use the same approach
    that was used there. Have a look at the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that the `FindFirst` construction has been added to guarantee that only
    one default customer category will be added.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: CreateCustomerWithCustomerCategoryNotEqualToDefault
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Calling the `CreateCustomer` helper function suffices as the customer record
    that is created will have an empty `Customer Category Code` field. This makes
    the construction of this helper function a very easy exercise, as you can see
    in the following code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: SelectAssignDefaultCategoryActionOnCustomerCard
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the helper function, we touch on the core of this test example – making
    use of a test page to achieve `#0007`, that is, testing that the user can assign
    a default customer category to a specific customer. The following is what the
    helper function looks like:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that I did not use a `with-do` construct to unambiguously show that the
    three statements in the function are referencing methods that you will only find
    on test page objects, and not on normal pages:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '`OpenView`: Opens the test page in view mode'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GoToKey`: Finds the row in a dataset that is identified by the specified values'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Invoke`: Invokes an action on a test page'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a complete listing of all test page methods, take a look at the following
    URLs:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '`TestPage`: [https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testpage/testpage-data-type](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testpage/testpage-data-type)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TestField`: [https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testfield/testfield-data-type](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testfield/testfield-data-type)'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TestAction`: [https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testaction/testaction-data-type](https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testaction/testaction-data-type)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find more details on test pages in Luc's book at [https://www.packtpub.com/business/automated-testing-microsoft-dynamics-365-business-central](https://www.packtpub.com/business/automated-testing-microsoft-dynamics-365-business-central).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: VerifyCustomerHasDefaultCustomerCategory
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the code for the default customer category is stored in the local `CustomerCategoryCode`
    variable in test example 4, verifying that the `CustomerCategoryCode` field on
    the customer record has indeed been populated with the default customer category
    is just a case of calling the already-existing `VerifyCustomerCategoryOnCustomer` helper
    function, as shown in the following code:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Running the test
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running both test codeunits will show that all tests are executed successfully.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: More examples for the Customer Category feature
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the GitHub repository for this book, you will find an extra number of test
    scenarios regarding the Customer Category feature. Go there and study them, and
    see how various helper functions have to be reused, showing that building up a
    bigger test suite often involves the reuse of existing elements. You might have
    wondered why the test examples weren't consecutively numbered. Inspecting the
    other scenarios on GitHub will show you why.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: UI handler – Test example 4
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to show you how to implement a `UI handler` function, we are going
    to have a go at the following scenario:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '**[Feature]** Gifts'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Scenario #0010]** Assign quantity on sales line to trigger active promotion
    message'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Given]** Packt setup with Gift Tolerance Qty set'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Given]** Customer with non-blocked customer category with Free Gifts Available'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Given]** Item'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Given]** Gift campaign for item and customer category with Minimum Order
    Quantity set'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Given]** Sales invoice for customer with line for item'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[When]** Set quantity on invoice line smaller than Minimum Order Quantity and
    within Gift Tolerance Qty'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Then]** Active promotion message is displayed'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As this is quite an extensive scenario, you will also explore and learn from
    a somewhat more complex test code sample.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test codeunit
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Typically, a test codeunit can be viewed as a test suite that tests a feature.
    As this feature, `Gifts`, is different from the one addressed in the previous
    test examples, we should contain this test in a new test codeunit, as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Embedding and writing
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Embedding and writing would now lead to a test function with the following
    pseudo-code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is the pseudo-code that describes the process for assigning gifts. In the
    next section, we'll see the real implementation.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Note that, due to their length, some function names have been cut into two and
    spread over two lines.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the real code
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given the *written story* (in the previous section), we now need to create
    the following seven helper functions in order to implement real test code effectively:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '`CreatePacktSetupWithGiftToleranceQty`'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateCustomerWithNonBlockedCustomerCategoryWith`'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FreeGiftsAvailable`'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`CreateGiftCampaignForItemAndCustomerCategory`'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`` `CreateSalesInvoiceForCustomerWithLineForItem` ``'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AssignQuantityOnInvoiceLineSmallerThanMinimumOrderQuantity`'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AndWithinGiftToleranceQty`'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`VerifyActivePromotionMessageIsDisplayed`'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's jump through the *real code* and take a look at a couple of specifics.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: CreatePacktSetupWithGiftToleranceQty
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `CreatePacktSetupWithGiftToleranceQty` helper function''s main purpose
    is to set `GiftToleranceQty` on the extension setup, and is given by the following
    code:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The CreateCustomerWithNonBlockedCustomerCategoryWithFreeGiftsAvailable helper
    function
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`CreateCustomerWithNonBlockedCustomerCategoryWithFreeGiftsAvailable` is a helper
    function that creates a customer with a non-blocking customer category set, and
    it''s implemented as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that, like our previous helper function, `CreateCustomer` (see test examples
    1 and 2), this test function also makes use of the standard `CreateCustomer` function
    in the standard library `LibrarySales` codeunit (`130509`).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: CreateItem
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`CreateItem` is a similar construction to the `CreateCustomer` function, as
    it makes use of the `CreateItem` function in the standard library `LibraryInventory`
    codeunit (`132201`). As a matter of fact, it''s just a wrapper around it, as seen
    in the following code:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: CreateGiftCampaignForItemAndCustomerCategoryWithMinimumOrderQuantity
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`CreateGiftCampaignForItemAndCustomerCategoryWithMinimumOrderQuantity` has
    to create a gift campaign record that combines the item that has just been created
    and the customer category that is linked to the newly created customer, and defines
    the period of time within the campaign will be valid and active. Have a look at
    what the functions look like:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: CreateSalesInvoiceForCustomerWithLineForItem
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When provided with the numbers of our item and customer, the `CreateSalesInvoiceForCustomerWithLineForItem`
    helper function has to create a new sales invoice with one line, making use of
    the `CreateSalesDocumentWithItem` helper function from the standard library `Library
    - Sales` codeunit (`130509`). The following is what its implementation looks like:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that no quantity is yet set on the line, as per the sixth parameter in
    the call to `CreateSalesDocumentWithItem`. The last two parameters of `CreateSalesDocumentWithItem`
    denote an undefined location and shipment date.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: SetQuantityOnInvoiceLineSmallerThanMinimumOrderQuantityAndWithinGiftToleranceQty
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main purpose of this helper function is to set and validate the quantity
    on the sales invoice line, so that, when it is smaller than the minimum order
    quantity on the gift campaign and everything is within the gift tolerance as defined
    in the setup, calling `Validate` will trigger the message.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following code:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A very useful exercise before coding the `[THEN]` part is to run the test.
    In the case of this test, it will show us something that''s very relevant. But
    before we do, we need to update the last details in our test function, as we haven''t
    specified the various parameters when calling the helper functions. So, the following
    is what the new test codeunit has become:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Running the test
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, let''s run the test, even though it''s not ready yet. As the screenshot
    demonstrates, there is an `unhandled UI` element, `Message`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23f13168-714a-49b0-afd0-2a71883895dd.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
- en: 'If we read the error message more closely, we see that it''s the message that
    we wanted to evoke:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This shows us two things:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully evoked the message.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to implement a so-called `MessageHandler` function.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is what the simplest `MessageHandler` function looks like:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will handle the message; that is, it will mimic a user pressing the **OK**
    button on the message dialog. Note that the name of this function doesn't need
    to be `MessageHandler`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a `MessageHandler` function is not sufficient. It also needs to be bound
    to the test function that is triggering the message. This is done by setting the
    `HandlerFunctions` property of the test function as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Running the test again demonstrates that it is successful now, but remember: *a
    test with no verification is no test*. The `MessageHandler` function could be
    triggered by any message. The last helper function we have to tackle, `VerifyActivePromotionMessageIsDisplayed`,
    needs to verify that our test did indeed evoke the right message.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: VerifyActivePromotionMessageIsDisplayed
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's leave something for you to discover. Go to GitHub and have a look at how
    this is implemented.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned how to create automatic tests for your extensions
    according to your business scenarios. Automatic testing is absolutely a must-have
    with Dynamics 365 Business Central (it's mandatory for AppSource apps, but it's
    also a best practice to follow in general).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed the basics of how to create automated tests
    in Dynamics 365 Business Central.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: We utilized the ATDD test case pattern in order to design each test, and then
    used it as a base structure in our four-step recipe to create a test codeunit,
    embed the customer choice into a test, write a test story, and finally construct
    your real code. You should now be comfortable with writing tests for your extensions
    according to your business needs.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''ll explore another important aspect to master when
    developing solutions for Dynamics 365 Business Central: source code management
    and DevOps practices.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
