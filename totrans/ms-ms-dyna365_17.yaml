- en: Serverless Business Processes with Business Central and Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 12](2df1402e-b606-4d66-8ae6-13b8aa0fcb3e.xhtml)*, Dynamics 365*
    *Business Central APIs*, we looked at an overview of the various APIs that are
    exposed by Dynamics 365 Business Central. We learned how to use them in our applications,
    as well as how to create our custom APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover an important concept that arises when we architect
    business applications in a cloud environment: *serverless processing*. As you
    already know, with SaaS, you cannot use all the functionalities that are available
    in an on-premise environment (such as files and .NET DLLs), and, in a cloud environment,
    you need to rethink about these functionalities by using services that are provided
    by the cloud infrastructure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the serverless functionalities offered by the Azure platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Azure Functions with Dynamics 365 Business Central
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serverless processing scenarios with Dynamics 365 Business Central in real-world
    applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a clear understanding of how you can
    implement serverless processes with Dynamics 365 Business Central by using Azure
    Functions.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to follow this chapter, you''ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A valid Azure subscription (a paid subscription, or a trial subscription that
    you can activate for free at [https://azure.microsoft.com/free/](https://azure.microsoft.com/free/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio or Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Azure Functions extensions for Visual Studio or Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of Microsoft Azure serverless services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serverless technologies are key in the cloud world. They allow you to focus
    on your business application and your code instead of taking care of provisioning
    and managing resources, scaling, and, more generally speaking, handling the underlying
    infrastructure that's needed to run your apps.
  prefs: []
  type: TYPE_NORMAL
- en: Azure offers a full suite of managed serverless services that you can use as
    building blocks of your applications, and these services include compute resources,
    database, storage, orchestration, monitoring, intelligence, and analytics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Azure serverless offering can be grouped into the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compute:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serverless functions (Azure Functions)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Serverless application environments (Azure App Service)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Serverless Kubernetes (Azure Kubernetes Service)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Storage:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure serverless storage (Blob Storage)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Workflow and integration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Logic Apps
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure API Management
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Event Grid
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Monitoring:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Monitor
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Analytics:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Stream Analytics
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AI and machine learning:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Cognitive Services
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Machine Learning Service
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Bot Service
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DevOps:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure DevOps
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The infrastructure that''s needed to handle your service is fully managed by
    Microsoft in its data centers around the globe. You have these main three advantages
    when you use serverless processing in your applications with Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**You can scale your service as needed**: You can scale a service in/out (add
    more instances or reduce the number of instances) or you can scale up/down a service
    (increase/decrease resources).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pay per use**: You only pay for the time your code is running or for the
    resources you use when executing your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrated security and monitoring** features managed by the Azure platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about the serverless offering provided by Azure can be found
    at [https://azure.microsoft.com/en-us/solutions/serverless/](https://azure.microsoft.com/en-us/solutions/serverless/).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've had an overview of Microsoft Azure Serverless services, let's
    look at an overview of Azure Functions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting an overview of Azure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Azure Functions** is a service offered by Azure that provides functions as
    a service. You write code (in different languages) without worrying about the
    infrastructure, and your code executes in the cloud. With Azure Functions, you
    can run your code on demand (after a request to the function), on schedule, or
    automatically in response to different events.'
  prefs: []
  type: TYPE_NORMAL
- en: You can write an Azure function directly via the Azure portal or you can develop
    it locally on your development machine. You can also debug and test an Azure function
    locally before deploying it to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure Functions has the following key features:'
  prefs: []
  type: TYPE_NORMAL
- en: Develop in the language you are most familiar with or reuse your existing code
    in the cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrated security; you can specify what security you want to have and the
    platform will handle it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalability management; you can have service tiers according to your loads and
    usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pay-per-use pricing model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the time of writing, the following Azure function types are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTPTrigger**: This is the classical function, where your code execution
    is triggered using an HTTP request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TimerTrigger**: Your code is executed on a predefined schedule.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BlobTrigger**: Your code is executed when a blob is added to an Azure Blob
    Storage container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**QueueTrigger**: Your code is executed when a message arrives in an Azure
    Storage queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EventGridTrigger**: Your code is executed when events are delivered to a
    subscription in Azure Event Grid (event-based architectures).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EventHubTrigger**: Your code is executed when events are delivered to an
    Azure Event Hub (frequently used in IoT scenarios).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ServiceBusQueueTrigger**: Your code is executed when a message arrives in
    an Azure Service Bus queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ServiceBusTopicTrigger**: Your code is executed when a message for a subscribed
    topic arrives at the Azure Service Bus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CosmosDBTrigger**: Your code is executed when documents are added or updated
    in a document collection stored in Azure Cosmos DB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Functions has the following pricing plans:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Consumption plan**: You pay for how long your code is being executed for
    in the cloud.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**App Service plan**: You pay for the hosting plan, just like a normal web
    app. You can run different functions on the same app service plan.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we mentioned previously, direct usage of .NET DLLs (.NET variables in AL)
    is not available on the SaaS environment. Azure Functions is the recommended way
    to use .NET code with Dynamics 365 Business Central in a SaaS environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we'll look at the implementation of an Azure function
    that validates email addresses. We'll use this function to validate the email
    address associated with a customer record in Dynamics 365 Business Central. This
    function will be developed using Visual Studio and then Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: Developing an Azure function with Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create an Azure function with Visual Studio, you need to have the Azure SDK
    tools installed. These tools can be installed directly when installing Visual
    Studio or later, by going to [https://azure.microsoft.com/en-us/downloads/](https://azure.microsoft.com/en-us/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, follow these steps to learn how to develop an Azure function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With Visual Studio (I''m using the 2019 version), create a new project and
    select the Azure Functions template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4840e6bd-9ad4-481d-bccf-a66d5b29956f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Choose a name for your project (here, I''m using EmailValidator), choose a
    location to save the project files in, and click Create:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e7543e69-8394-42ec-953a-29aa1c5b9d62.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, you have to select the runtime version of your Azure function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Azure Functions v2 (.NET Standard): Based on .NET Core (cross-platform), this
    is the new available runtime.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Functions v1 (.NET Framework): Based on .NET Framework, this only supports
    development and hosting in the Azure portal or on Windows computers.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, I've selected Azure Functions v2 (.NET Core).
  prefs: []
  type: TYPE_NORMAL
- en: Then, you have to select the Azure function type (I selected Http trigger because
    I want a function that can be called via HTTP) and for simplicity, I have selected *Anonymous*
    as the Access rights for our function (no authentication and everyone can use
    it; we'll talk about this in the *Managing Azure function keys* section of this
    chapter).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, click OK to create the solution. This is the project tree that you will
    see in Visual Studio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1cb717dc-d7aa-45b8-9ee8-49b957b989ff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, you have the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`host.json`: This file contains global configuration options that affect all
    the functions in your project. In our project, we have the runtime version (2.0).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`local.settings.json`: This file contains the settings of your project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EmailValidator.cs`: This is your function''s source code (C#).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our function's implementation is quite simple. It receives an `email` parameter
    as input (via a GET or POST request), it validates the email address, and it returns
    a JSON response stating whether the address is valid or not (this is a custom
    object called `EmailValidationResult`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The function code is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This function retrieves the `email` parameter from the input and calls the `IsEmailValid`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function validates an email address by using the `System.Net.Mail.MailAddress`
    class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After email validation, the function creates an `EmailValidationResult` object
    with the response values, serializes it, and returns the JSON response. This `EmailValidationResult`
    object is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've tested the function, it's time to publish it locally.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Azure function locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Visual Studio provides an emulator that we can use to test and debug our Azure
    function before deploying it to Azure. If you run the project, the emulator starts
    and you have a local URL to use for testing your function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed490f89-9772-48fb-b4f7-b06d4913814c.png)'
  prefs: []
  type: TYPE_IMG
- en: We can test our function by opening a browser and calling a URL, such as [http://localhost:7071/api/EmailValidator?email=masteringd365bc@packt.com](http://localhost:7071/api/EmailValidator?email=masteringd365bc@packt.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'When invoked, the emulator shows the request details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83106311-74da-4e77-aca9-d2dfcc928a6d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see the JSON response in the browser. The previous call gives us the
    following response object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we call the function with a bad email address, such as `http://localhost:7071/api/EmailValidator?email=masteringd365bc`,
    we get the following response object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our function is working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've tested the Azure function, we are ready to deploy it.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the function to Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we need to deploy our function to Azure. We can do this directly from
    Visual Studio, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by right-clicking on the project and selecting Publish...:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5beab55b-38ea-427e-bbdd-8c9166a9d486.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to choose an Azure App Service to deploy the function to. To do this,
    we can select an existing one or create a new one. Here, I have created a new
    Azure App Service instance for this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/765bb82d-5cee-4334-8032-598f93a7f1c8.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on Publish.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, we select the Subscription, a Resource Group (create a new one
    or use an existing one), a Hosting Plan, and a storage account to use for the
    deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f058c639-82d9-422e-a27e-fbd2c1d555a3.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, click Create – our function (and all the associated resources) will be
    deployed to Azure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our function has been published on the Azure data centers and we have
    a public URL so that we can use it, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9e48115e-fee4-4718-a23c-e575f6c64045.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: In my example, the public URL is [https://emailvalidator20190603055323.azurewebsites.net](https://emailvalidator20190603055323.azurewebsites.net)
    (you can customize it).
  prefs: []
  type: TYPE_NORMAL
- en: To test your function, use the following URL: `https://emailvalidator20190603055323.azurewebsites.net/**api/EmailValidator?email=masteringd365bc****@packt.com**`**.**
  prefs: []
  type: TYPE_NORMAL
- en: The function now runs in the Azure cloud and you're ready to use it.
  prefs: []
  type: TYPE_NORMAL
- en: There is an alternative way of developing an Azure function that's extremely
    important for any Dynamics 365 Business Central developer. We'll take a look at
    this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Developing an Azure function with Visual Studio Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start developing Azure functions with Visual Studio Code, you need to install
    the following extensions:'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Account, which you can download from [https://marketplace.visualstudio.com/items?itemName=ms-vscode.azure-account](https://marketplace.visualstudio.com/items?itemName=ms-vscode.azure-account).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Functions, which you can download from [https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azurefunctions](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azurefunctions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You also need to install Azure Functions Core Tools, a set of tools that allow
    you to develop and test your functions on your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: You need to install the version that supports the Azure Functions runtime you're
    using. You can install this at [https://github.com/Azure/azure-functions-core-tools](https://github.com/Azure/azure-functions-core-tools).
  prefs: []
  type: TYPE_NORMAL
- en: 'To develop Azure functions with Visual Studio Code, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to do is log into your Azure subscription by using
    the Azure: Sign In command from the Visual Studio Code Command Palette:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1ec18be7-968c-4595-9c2f-af123e6c6cdf.png)'
  prefs: []
  type: TYPE_IMG
- en: After entering your credentials, you will see the account connected to your
    subscription at the bottom bar of Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, on the Visual Studio Code sidebar, select the Azure Functions extension
    and click on the Create New Project button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0d2e84b2-407e-4ef6-b2eb-3bb9572f2ee5.png)'
  prefs: []
  type: TYPE_IMG
- en: Select a folder that you want to place your Azure Functions project in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you will be prompted to choose a language to develop your function in.
    From the list of supported languages, I''ve selected C#, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9c3ee88c-e9ab-4521-bbfc-e45e78b492f8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, you have to select either of the following runtime versions for your
    Azure function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Azure Functions v2 (.NET Standard): Based on .NET Core (cross-platform), this
    is the new available runtime.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A**zure Functions v1 (.NET Framework): Based on .NET Framework, this only
    supports development and hosting in the Azure portal or on Windows computers.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, I''ve selected Azure Functions v2 (.NET Standard):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34fb3c07-942c-4653-b110-d12729c20e95.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, set a name for your Azure Functions project (here, I''ve named it `EmailValidatorCore`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/558b7f94-7f61-4c2d-b12e-e6676028c982.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After naming the project, provide a namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cb46ae58-b5a9-4b9e-955b-e3fba0dddad0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, you need to select the authentication type for your function. For simplicity,
    I''ve selected Anonymous (everyone can call our function):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/33c9710b-dc04-4072-8c75-8d34eb61917f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, choose where to open the project that will be created (Current window,
    New window, and Add to workspace are the available options).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Visual Studio Code will start downloading the required packages for your Azure
    Functions project, and, when it''s finished, a set of files will be created. The
    following is the template of your Azure function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c3edb55-182d-47a9-b2f1-66b9a9a1fd32.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, you have the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`host.json`: This file contains the global configuration options that affect
    all the functions in your project. In our project, we have the runtime version
    (2.0).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`local.settings.json`: This file contains the settings of your project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EmailValidatorCore.cs`: This is your function''s source code (C#).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Please note that you may have some temporary errors in your code (missing references).
    This occurs when Visual Studio Code needs to download all the .NET Core packages.
    To get the correct references, you need to execute the .NET: Restore Project command
    from the Command Palette, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17c61411-bb61-40a8-bcc5-0607d8ac99a5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the proposed option and click OK, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ad494d1-b0a7-4f97-a16b-9b0b84b1e244.png)'
  prefs: []
  type: TYPE_IMG
- en: Your project's references are now fixed and you can start coding your function.
  prefs: []
  type: TYPE_NORMAL
- en: As in the previous example, we want to create a function for validating email
    addresses, and we can reuse the same C# code to do so. Here, you've seen how to
    start creating an Azure Functions project by using Visual Studio Code directly.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your Azure function locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test your function locally, you need to install the Azure Functions Core
    Tools. This can be installed using the following command on the Command Prompt
    (or from the Visual Studio Code Terminal):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To use npm with Visual Studio Code, you need to have Node.js installed on your
    machine. You can install it from [https://nodejs.org/en/](https://nodejs.org/en/).
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the `npm` command, some packages will be downloaded and installed
    on your local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e231f0f-1b58-48a5-8a23-e0b6cfe57bbd.png)'
  prefs: []
  type: TYPE_IMG
- en: After installing the tools, you need to restart Visual Studio Code in order
    for this to take effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start testing your function locally, you can press *F5* directly in Visual
    Studio Code. The local Azure Function Host environment will start and Visual Studio
    Code will give you a local URL so that you can call your function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a78c85f8-0b31-4c91-8d9f-472a7d11516a.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we can test the function by passing the email parameter via a URL in a
    browser (like we did in the *Deploying the function to Azure* section).
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with this, we can debug the code directly from Visual Studio Code by
    placing breakpoints, moving step by step, checking variables and outputs, and
    so on, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd3f6abe-1786-4d91-b3f4-2ea341081d7b.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, you've debugged and tested your Azure function in your local environment.
    In the next section, we'll learn how to publish the function to the Azure cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing your function to Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To deploy your Azure function to Azure, follow these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Azure Functions icon in the Visual Studio Code sidebar and click
    on the blue arrow icon called Deploy to Function App, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/660d64e1-7c5d-4d0f-85cf-0022fe6d2f65.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Visual Studio Code will ask you to choose an Azure subscription as the location
    to deploy your function to from the list of the available subscriptions for your
    account, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d2a27f5d-0ec7-4894-a38a-cbe6ff47f4bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, select Create New Function App in Azure and give it a globally unique
    name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0f86ea16-c64a-43a9-969b-701b643a5ee0.png)'
  prefs: []
  type: TYPE_IMG
- en: I've called it `SDEmailValidatorCore`*.*
  prefs: []
  type: TYPE_NORMAL
- en: From here, you can create a new resource group and a new storage account. Choose
    the region where you want to deploy your function. Then, resource deployment will
    start.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the deployment process is finished, Visual Studio Code will show you a
    confirmation message in the bottom-right corner. You can see the deployed function
    in the subscription tree view on the left:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4d737d43-2329-48eb-b2a2-04fc0d429d09.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, your Azure function is running on an Azure data center and you can start
    using it with AL code. We will look at this in more detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Calling an Azure function from AL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have deployed our function to Azure, we can use it from the AL code
    in our extensions.
  prefs: []
  type: TYPE_NORMAL
- en: As we explained in [Chapter 6](512b0690-f392-4f82-b006-cacdeec1bacc.xhtml), *Advanced
    AL Development*, in the *Consuming web services and APIs from AL* section, we
    can call an Azure function with AL by using the `HttpClient` data type, which
    provides a data type for sending HTTP requests and receiving HTTP responses from
    a resource that's been identified by a URI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test our Azure function, we will create a simple extension (a new project
    with **AL:Go!**) that allows us to validate an email address associated with a
    customer record. Our `CustomerEmailValidation` extension is made up of a single
    codeunit object where we define an event subscriber to the `OnAfterValidate` event
    of the E-Mail field in the `Customer` table. In this `EventSubscriber` procedure
    (called `ValidateCustomerEmail`), we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Call the Azure function using the `HttpClient` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the response from the Azure function using the `HttpResponse` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parse the JSON response in order to extract the `Valid` token.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throw an error if `Valid = false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Press *F5* and deploy your extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open a customer card, go to the Address & Contact tab and insert a value
    into the Email field. You will receive the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46ab5b45-695c-4291-9316-3eccc92eb978.png)'
  prefs: []
  type: TYPE_IMG
- en: This happens the first time you do this because outbound HTTP calls are blocked
    by default in a sandbox environment. Select Allow Once and click OK.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, our Azure function is called, the JSON response is retrieved and parsed,
    and the validation occurs. If you insert a valid email address, the value is correctly
    inserted into the Email field; otherwise, you will receive an error, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e660b2dd-634a-4961-a65e-05c19a4acfdf.png)'
  prefs: []
  type: TYPE_IMG
- en: To allow external calls in a sandbox environment automatically, in the `NAV
    App Settings` table, there is a Boolean field called `Allow HttpClient Requests`,
    and, when the user selects one of the Always options (Allow Always or Block Always),
    then a record is inserted into this table with the field set to `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also control this setting programmatically in your AL code. In our
    extension, we have added the following procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code retrieves the information about the current extension (`ModuleInfo`)
    and then checks whether the extension is running in a sandbox environment. If
    so, it sets the `Allow HttpClient Requests` field to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our previous event subscriber (`ValidateCustomerEmail` procedure), we enable
    the external calls when needed by calling the `EnableExternalCallsInSandbox` procedure,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This allows you to avoid seeing the confirmation request on every external HTTP
    call.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll learn how to use Azure Functions and Azure Blob Storage
    to handle files in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with Azure Blob Storage to handle files in the cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main problems we have in the cloud environment with Dynamics 365
    Business Central is related to saving files. As we mentioned previously, in the
    cloud environment, you don't have a filesystem and you cannot access local resources
    such as network shares or local disks.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to save files with Dynamics 365 Business Central SaaS, the solution
    is to call an Azure function and store the file in cloud-based storage. You can
    create a function that saves a file in Azure Blob Storage, and from here you can
    share Azure Storage as a network drive. This is the scenario that we will cover
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Azure Blob Storage account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the first step in implementing our solution, we need to have a storage account
    on Azure and we need to create a Blob container inside that storage account.
  prefs: []
  type: TYPE_NORMAL
- en: 'To manually create an Azure Storage account (called `d365bcfilestorage`, in
    this case), follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select Storage Accounts from the Azure portal, click Create, and follow the
    instructions on the screen. To create a Blob container inside this storage account,
    select Blobs from the Services section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d3c3a374-0559-48a9-ad6c-9172a194b8ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, click on Container, give it a name (here, I''ve chosen d365bcfiles),
    select the public access level (by default, container data is private to the account
    owner), and click OK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8c6c7a05-854a-40cc-9aaa-6bdd7febf6a6.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, the Blob container has been created in your Azure Storage account.
  prefs: []
  type: TYPE_NORMAL
- en: 'The connection string for accessing your Azure Storage account (which must
    be used in your Azure functions) can be retrieved by selecting the storage account
    and clicking on Access keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/402218f9-682b-42f4-beef-412953308047.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we'll embed this connection string inside the function project, but, in
    a production environment, you can store it in an Azure Key Vault and retrieve
    it from there for better security.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our Blob container, I''ve manually uploaded a file (PNG image) in order
    to store a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24789192-0a65-4d50-93ab-4d94eb33b680.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have created a Blob container on Azure Storage so that we can host our
    files. In the next section, we'll create an Azure function for saving and retrieving
    files from this Blob storage.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Azure functions with Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open Visual Studio and create a new Azure Functions project by selecting the
    HttpTrigger template. Name your function `SaaSFileMgt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our project, we want to create the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UploadFile`: This function will receive an object with binary data (file content)
    and some metadata (file details) via an HTTP POST request. It will store the file
    in a container in an Azure Blob Storage account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DownloadFile`: This function will receive an object with the URI of the file
    to download and its details (via an HTTP POST request) and returns the binary
    of the file stored in the Azure Blob Storage container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListFiles`: This function will retrieve (via an HTTP GET request) a list of
    all the URIs of the files stored in the Azure Blob Storage container. These files
    will be explained in the upcoming sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The functions to upload/download a file must only support the HTTP POST method,
    so, in the `HttpTrigger` definition template, we have removed the `get` parameter.
    The signatures of these functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The function to list files in Blob storage must only support the GET method,
    and the signature is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let's explore each of these functions.
  prefs: []
  type: TYPE_NORMAL
- en: The UploadFile function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `UploadFile` function receives a JSON object in the body via an HTTP POST
    request, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `UploadFile` function parses the JSON in the request body and then calls
    the `UploadBlobAsync` function. In this function, we upload the file to the Azure Blob Storage
    container and we return the URI of the uploaded file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UploadFile` function''s code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`UploadBlobAsync` is a function that performs the Blob upload to the `d365bcfiles`
    container in the Azure Storage account. Its code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The DownloadFile function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `DownloadFile` function receives a JSON object in the body via an HTTP POST
    request, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This function retrieves the details of the file to download from the request
    body and calls the `DownloadBlobAsync` function. Then, it returns the content
    of the downloaded file (`Base64-encoded` string):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`DownloadBlobAsync` is the function that connects to the Azure Storage Blob
    container, checks for the file, and (if it is found) returns the byte array (stream)
    of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The ListFiles function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ListFiles` function is called via an HTTP GET request (no parameters).
    It calls the `ListBlobAsync` function and then returns the list of the URI of
    the files in the blob container (JSON format).
  prefs: []
  type: TYPE_NORMAL
- en: 'Its code is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `ListBlobAsync` function connects to the Azure Storage container and retrieves
    the list of blob files stored on it by using the `ListBlobsSegmentedAsync` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method returns the list of files in segments by using a `BlobContinuationToken`.
    When this token is `null`, all the files are retrieved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, that we've created our Azure functions, it's time to deploy them. We'll
    learn how to do this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the Azure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our Azure functions can be deployed to our Azure subscription directly from
    Visual Studio. To deploy these functions to Azure, you need to create a new Azure App
    Service instance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/292d5a02-7c3e-406f-b1c1-2eccca5cc001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After that, publish your functions to this Azure App Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e786f1bc-3529-4e23-9ff8-e4e001f556f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you go to the Azure portal, you will see that the functions have been published
    and that you now have a public URL to test them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70efcc40-93fa-4736-883a-6b578331ae11.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, the functions run on an Azure data center. In the next section, we'll learn
    how we can manage the access keys of our deployed functions (authorization).
  prefs: []
  type: TYPE_NORMAL
- en: Managing Azure Functions keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Azure Functions uses authorization keys to protect access to your HTTP-triggered
    functions. When you deploy a function, you can choose between the following authorization
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Anonymous: No access key is required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Function: A specific access key is required in order to access the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Admin: A master host key is required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can manage these access keys directly from the Azure portal by selecting
    your function and clicking on Manage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f41732fd-9acb-4a01-8baa-3ea5357fb8ba.png)'
  prefs: []
  type: TYPE_IMG
- en: You can also use the Key Management API ([https://github.com/Azure/azure-functions-host/wiki/Key-management-API](https://github.com/Azure/azure-functions-host/wiki/Key-management-API))
    if you want to manage keys programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: More information on how you can manage the authorization keys for your Azure
    Functions can be found here: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-http-webhook#authorization-keys](https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-http-webhook#authorization-keys).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you've learned how to handle access keys for our Azure function.
    In the next section, we'll learn how to test our previously deployed Azure function
    (uploading and downloading files from Blob storage).
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Azure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our scenario, the Azure functions have been deployed with the Function authorization
    level, so we need to call the desired function by passing a `code` parameter with
    the function key (which we can obtain from the portal). For example, to test the
    `ListFiles` function, we need to call the following URL: [https://saasfilemgt.azurewebsites.net/api/ListFiles?code=FUNCTIONKEY](https://saasfilemgt.azurewebsites.net/api/ListFiles?code=FUNCTIONKEY).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the response we get (a list of our Blob files'' URIs):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2db0a962-b694-4ef5-848f-0bb31af85d01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To test the `DownloadFile` function, we need to send a POST request to the
    function''s URL by passing a JSON object with the following parameters (which
    identify the file to retrieve):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Launching the HTTP request from Visual Studio Code gives us the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd884e9c-701c-4d9c-bee9-063b5dd6bdbb.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the function downloads the requested file from Azure Blob Storage
    (the function returns the Base64 string).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll learn how to call our Azure function from an AL extension
    in Dynamics 365 Business Central.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Dynamics 365 Business Central extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The extension we want to create here is a simple application that adds two actions
    to the *Item List* page for uploading and downloading files to/from Azure Blob
    Storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'This AL extension will define two objects:'
  prefs: []
  type: TYPE_NORMAL
- en: A `codeunit` object with the logic to call our Azure functions that handle the
    files with Azure Blob Storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `pageextension` object that adds the actions on the Item List page and calls
    the relative procedures defined in our codeunit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at these in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Codeunit definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The codeunit is called `SaaSFileMgt` and contains two procedures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UploadFile`: This function will handle the file upload to Azure Blob Storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DownloadFile`: This function will handle the file download from Azure Blob
    Storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the codeunit, we have two global variables, both of which contain the URLs
    of the Azure functions to call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, `YOURFUNCTIONKEY` is the key we use to access the Azure function (retrieved
    from the Azure portal by selecting the function and clicking on Manage).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UploadFile` procedure is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We ask for a file to upload.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We read the file into a `Stream` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We retrieve some parameters related to the file (name and extension).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a JSON message, as requested by the function (as we described previously).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we send an HTTP POST request to our Azure function (by using the `HttpClient`
    object), passing the JSON in the body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `DownloadFile` procedure is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This procedure receives the name of the file to retrieve as input. This is
    how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: It calls a custom function (`GetMimeType`) that returns the content type of
    this file, and then we compose the JSON message for the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we send an HTTP POST request to our Azure function (by using the `HttpClient`
    object), passing the JSON in the body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We read the `HttpResponse` object (Base64 of the retrieved file) and download
    it to the client-side by using an `InStream` object and calling the `DownloadFromStream`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `GetMimeType` utility is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This simply receives a filename as input, retrieves the file extension, and
    then returns the MIME type associated with the file.
  prefs: []
  type: TYPE_NORMAL
- en: The pageextension definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `pageextension` object extends the Item List page by adding the two actions
    we described previously. The object definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: These two actions simply call the methods defined in our codeunit by passing
    the required parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll test the integrated solution (an Azure function being
    called by Dynamics 365 Business Central).
  prefs: []
  type: TYPE_NORMAL
- en: Testing our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it''s time to test our application and see how it works. When published,
    our extension adds two functions to the *Item List* page for uploading/downloading
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/603088b6-2b73-4541-bd2a-f47057f92fd9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click the Upload file to Azure Blob Storage action, you can select a
    file from your local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e21b0c5b-f7ce-4a8c-bc58-b905753d9c2d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This file will be uploaded to the Azure Blob Storage container via an HTTP POST
    request to our Azure function. We can debug the `httpResponse` object and see
    that it returns `HttpStatusCode = 200 (success)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d315bb5a-8ebf-449e-b794-29c16b150cf2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will receive a message that tells us that the file has been uploaded to
    Azure Blob Storage, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/234275d8-b469-407b-ab85-bc5ba1908627.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we check the blob container in our Azure Storage account, we will see that
    the file has been uploaded into the blob storage correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f4d69e6-1705-4465-8f16-30013b6a7718.png)'
  prefs: []
  type: TYPE_IMG
- en: When you click on the Download file from Azure Blob Storage action, an HTTP POST
    request to the `DownloadFile` Azure function is performed (by passing a JSON body,
    as we described previously) and the `httpResponse` object returns `HttpStatusCode
    = 200 (success)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `httpResponse` object is a Base64 encoding of the retrieved file. Here,
    the Base64 string is decoded and the file is downloaded to the client-side by
    using an `InStream`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5295bfba-9cdf-4ee7-9aec-83f649c36721.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the file is retrieved from the stream and the browser prompts
    the user to download it locally.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can handle files in a cloud environment (upload and download). Azure
    also allows us to map the Blob storage to our on-premise network so that we can
    have a serverless filesystem that's totally transparent for the end user.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at what Azure functions are and how we can use them
    in our Dynamics 365 Business Central extensions to execute .NET code on a cloud
    environment and to implement serverless processes.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to create a simple Azure function using Visual Studio and Visual
    Studio Code and how to use Azure Functions with other Azure services (in particular,
    how to use Azure Functions and Azure Blob Storage to implement a filesystem in
    the cloud with Dynamics 365 Business Central).
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you should understand how to develop, deploy, and
    use Azure functions to implement business tasks in the cloud in a totally serverless
    way. In a modern cloud-based ERP, this is a really important feature to master
    in order to extend the platform's functionalities and to embrace other cloud services.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn how to monitor and scale our functions in the
    cloud and how to apply DevOps techniques (continuous integration and continuous
    deployment) to our Azure Functions projects by using Azure DevOps.
  prefs: []
  type: TYPE_NORMAL
