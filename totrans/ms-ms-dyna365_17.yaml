- en: Serverless Business Processes with Business Central and Azure
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 12](2df1402e-b606-4d66-8ae6-13b8aa0fcb3e.xhtml)*, Dynamics 365*
    *Business Central APIs*, we looked at an overview of the various APIs that are
    exposed by Dynamics 365 Business Central. We learned how to use them in our applications,
    as well as how to create our custom APIs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover an important concept that arises when we architect
    business applications in a cloud environment: *serverless processing*. As you
    already know, with SaaS, you cannot use all the functionalities that are available
    in an on-premise environment (such as files and .NET DLLs), and, in a cloud environment,
    you need to rethink about these functionalities by using services that are provided
    by the cloud infrastructure.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the serverless functionalities offered by the Azure platform
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Azure Functions with Dynamics 365 Business Central
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serverless processing scenarios with Dynamics 365 Business Central in real-world
    applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a clear understanding of how you can
    implement serverless processes with Dynamics 365 Business Central by using Azure
    Functions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to follow this chapter, you''ll need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: A valid Azure subscription (a paid subscription, or a trial subscription that
    you can activate for free at [https://azure.microsoft.com/free/](https://azure.microsoft.com/free/))
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio or Visual Studio Code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Azure Functions extensions for Visual Studio or Visual Studio Code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of Microsoft Azure serverless services
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serverless technologies are key in the cloud world. They allow you to focus
    on your business application and your code instead of taking care of provisioning
    and managing resources, scaling, and, more generally speaking, handling the underlying
    infrastructure that's needed to run your apps.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Azure offers a full suite of managed serverless services that you can use as
    building blocks of your applications, and these services include compute resources,
    database, storage, orchestration, monitoring, intelligence, and analytics.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'The Azure serverless offering can be grouped into the following categories:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Compute:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serverless functions (Azure Functions)
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Serverless application environments (Azure App Service)
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Serverless Kubernetes (Azure Kubernetes Service)
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Storage:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure serverless storage (Blob Storage)
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Database
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Workflow and integration:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Logic Apps
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure API Management
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Event Grid
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Monitoring:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Monitor
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Analytics:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Stream Analytics
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AI and machine learning:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Cognitive Services
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Machine Learning Service
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Bot Service
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DevOps:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure DevOps
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The infrastructure that''s needed to handle your service is fully managed by
    Microsoft in its data centers around the globe. You have these main three advantages
    when you use serverless processing in your applications with Azure:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '**You can scale your service as needed**: You can scale a service in/out (add
    more instances or reduce the number of instances) or you can scale up/down a service
    (increase/decrease resources).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pay per use**: You only pay for the time your code is running or for the
    resources you use when executing your code.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrated security and monitoring** features managed by the Azure platform.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about the serverless offering provided by Azure can be found
    at [https://azure.microsoft.com/en-us/solutions/serverless/](https://azure.microsoft.com/en-us/solutions/serverless/).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've had an overview of Microsoft Azure Serverless services, let's
    look at an overview of Azure Functions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Getting an overview of Azure Functions
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Azure Functions** is a service offered by Azure that provides functions as
    a service. You write code (in different languages) without worrying about the
    infrastructure, and your code executes in the cloud. With Azure Functions, you
    can run your code on demand (after a request to the function), on schedule, or
    automatically in response to different events.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: You can write an Azure function directly via the Azure portal or you can develop
    it locally on your development machine. You can also debug and test an Azure function
    locally before deploying it to the cloud.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure Functions has the following key features:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Develop in the language you are most familiar with or reuse your existing code
    in the cloud
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrated security; you can specify what security you want to have and the
    platform will handle it
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalability management; you can have service tiers according to your loads and
    usage
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pay-per-use pricing model
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the time of writing, the following Azure function types are available:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTPTrigger**: This is the classical function, where your code execution
    is triggered using an HTTP request.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TimerTrigger**: Your code is executed on a predefined schedule.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BlobTrigger**: Your code is executed when a blob is added to an Azure Blob
    Storage container.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**QueueTrigger**: Your code is executed when a message arrives in an Azure
    Storage queue.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EventGridTrigger**: Your code is executed when events are delivered to a
    subscription in Azure Event Grid (event-based architectures).'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EventHubTrigger**: Your code is executed when events are delivered to an
    Azure Event Hub (frequently used in IoT scenarios).'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ServiceBusQueueTrigger**: Your code is executed when a message arrives in
    an Azure Service Bus queue.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ServiceBusTopicTrigger**: Your code is executed when a message for a subscribed
    topic arrives at the Azure Service Bus.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CosmosDBTrigger**: Your code is executed when documents are added or updated
    in a document collection stored in Azure Cosmos DB.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Functions has the following pricing plans:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '**Consumption plan**: You pay for how long your code is being executed for
    in the cloud.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**App Service plan**: You pay for the hosting plan, just like a normal web
    app. You can run different functions on the same app service plan.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用服务计划**：你为托管计划付费，就像正常的 Web 应用一样。你可以在同一个应用服务计划上运行不同的函数。'
- en: As we mentioned previously, direct usage of .NET DLLs (.NET variables in AL)
    is not available on the SaaS environment. Azure Functions is the recommended way
    to use .NET code with Dynamics 365 Business Central in a SaaS environment.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，直接使用 .NET DLLs（AL 中的 .NET 变量）在 SaaS 环境中不可用。Azure Functions 是在 SaaS
    环境中将 .NET 代码与 Dynamics 365 Business Central 结合使用的推荐方式。
- en: In the following sections, we'll look at the implementation of an Azure function
    that validates email addresses. We'll use this function to validate the email
    address associated with a customer record in Dynamics 365 Business Central. This
    function will be developed using Visual Studio and then Visual Studio Code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将查看一个验证邮箱地址的 Azure 函数的实现。我们将使用这个函数来验证 Dynamics 365 Business Central
    中客户记录关联的邮箱地址。这个函数将使用 Visual Studio 开发，然后使用 Visual Studio Code 开发。
- en: Developing an Azure function with Visual Studio
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 开发 Azure 函数
- en: To create an Azure function with Visual Studio, you need to have the Azure SDK
    tools installed. These tools can be installed directly when installing Visual
    Studio or later, by going to [https://azure.microsoft.com/en-us/downloads/](https://azure.microsoft.com/en-us/downloads/).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Visual Studio 创建 Azure 函数，你需要安装 Azure SDK 工具。这些工具可以在安装 Visual Studio 时直接安装，也可以稍后通过访问
    [https://azure.microsoft.com/en-us/downloads/](https://azure.microsoft.com/en-us/downloads/)
    安装。
- en: 'Now, follow these steps to learn how to develop an Azure function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下步骤学习如何开发 Azure 函数：
- en: 'With Visual Studio (I''m using the 2019 version), create a new project and
    select the Azure Functions template:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Visual Studio（我使用的是 2019 版本），创建一个新项目并选择 Azure Functions 模板：
- en: '![](img/4840e6bd-9ad4-481d-bccf-a66d5b29956f.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4840e6bd-9ad4-481d-bccf-a66d5b29956f.png)'
- en: 'Choose a name for your project (here, I''m using EmailValidator), choose a
    location to save the project files in, and click Create:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的项目选择一个名称（在这里，我使用 EmailValidator），选择一个保存项目文件的位置，并点击创建：
- en: '![](img/e7543e69-8394-42ec-953a-29aa1c5b9d62.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7543e69-8394-42ec-953a-29aa1c5b9d62.png)'
- en: 'Next, you have to select the runtime version of your Azure function:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要选择你的 Azure 函数的运行时版本：
- en: 'Azure Functions v2 (.NET Standard): Based on .NET Core (cross-platform), this
    is the new available runtime.'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Functions v2 (.NET Standard)：基于 .NET Core（跨平台），这是新的可用运行时。
- en: 'Azure Functions v1 (.NET Framework): Based on .NET Framework, this only supports
    development and hosting in the Azure portal or on Windows computers.'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Functions v1 (.NET Framework)：基于 .NET Framework，仅支持在 Azure 门户或 Windows
    计算机上进行开发和托管。
- en: Here, I've selected Azure Functions v2 (.NET Core).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我选择了 Azure Functions v2 (.NET Core)。
- en: Then, you have to select the Azure function type (I selected Http trigger because
    I want a function that can be called via HTTP) and for simplicity, I have selected *Anonymous*
    as the Access rights for our function (no authentication and everyone can use
    it; we'll talk about this in the *Managing Azure function keys* section of this
    chapter).
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你需要选择 Azure 函数类型（我选择了 Http 触发器，因为我希望创建一个可以通过 HTTP 调用的函数），为了简单起见，我选择了*匿名*作为我们函数的访问权限（无需身份验证，任何人都可以使用；我们将在本章的
    *管理 Azure 函数密钥* 部分讨论这一点）。
- en: 'Now, click OK to create the solution. This is the project tree that you will
    see in Visual Studio:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击 OK 来创建解决方案。这是你在 Visual Studio 中看到的项目树：
- en: '![](img/1cb717dc-d7aa-45b8-9ee8-49b957b989ff.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1cb717dc-d7aa-45b8-9ee8-49b957b989ff.png)'
- en: 'Here, you have the following files:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你会看到以下文件：
- en: '`host.json`: This file contains global configuration options that affect all
    the functions in your project. In our project, we have the runtime version (2.0).'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host.json`：这个文件包含影响项目中所有函数的全局配置选项。在我们的项目中，我们有运行时版本（2.0）。'
- en: '`local.settings.json`: This file contains the settings of your project.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local.settings.json`：这个文件包含你的项目设置。'
- en: '`EmailValidator.cs`: This is your function''s source code (C#).'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmailValidator.cs`：这是你函数的源代码（C#）。'
- en: Our function's implementation is quite simple. It receives an `email` parameter
    as input (via a GET or POST request), it validates the email address, and it returns
    a JSON response stating whether the address is valid or not (this is a custom
    object called `EmailValidationResult`).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们函数的实现非常简单。它接收一个 `email` 参数作为输入（通过 GET 或 POST 请求），验证邮箱地址，然后返回一个 JSON 响应，说明该地址是否有效（这是一个名为
    `EmailValidationResult` 的自定义对象）。
- en: 'The function code is defined as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 函数代码定义如下：
- en: '[PRE0]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This function retrieves the `email` parameter from the input and calls the `IsEmailValid`
    function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'This function validates an email address by using the `System.Net.Mail.MailAddress`
    class, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After email validation, the function creates an `EmailValidationResult` object
    with the response values, serializes it, and returns the JSON response. This `EmailValidationResult`
    object is defined as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we've tested the function, it's time to publish it locally.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Azure function locally
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Visual Studio provides an emulator that we can use to test and debug our Azure
    function before deploying it to Azure. If you run the project, the emulator starts
    and you have a local URL to use for testing your function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed490f89-9772-48fb-b4f7-b06d4913814c.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: We can test our function by opening a browser and calling a URL, such as [http://localhost:7071/api/EmailValidator?email=masteringd365bc@packt.com](http://localhost:7071/api/EmailValidator?email=masteringd365bc@packt.com).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'When invoked, the emulator shows the request details:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83106311-74da-4e77-aca9-d2dfcc928a6d.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: 'We can see the JSON response in the browser. The previous call gives us the
    following response object:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we call the function with a bad email address, such as `http://localhost:7071/api/EmailValidator?email=masteringd365bc`,
    we get the following response object:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our function is working correctly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've tested the Azure function, we are ready to deploy it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the function to Azure
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we need to deploy our function to Azure. We can do this directly from
    Visual Studio, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by right-clicking on the project and selecting Publish...:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5beab55b-38ea-427e-bbdd-8c9166a9d486.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: 'We need to choose an Azure App Service to deploy the function to. To do this,
    we can select an existing one or create a new one. Here, I have created a new
    Azure App Service instance for this function:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/765bb82d-5cee-4334-8032-598f93a7f1c8.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: Click on Publish.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, we select the Subscription, a Resource Group (create a new one
    or use an existing one), a Hosting Plan, and a storage account to use for the
    deployment:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f058c639-82d9-422e-a27e-fbd2c1d555a3.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: Now, click Create – our function (and all the associated resources) will be
    deployed to Azure.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our function has been published on the Azure data centers and we have
    a public URL so that we can use it, as shown in the following screenshot:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9e48115e-fee4-4718-a23c-e575f6c64045.png)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: In my example, the public URL is [https://emailvalidator20190603055323.azurewebsites.net](https://emailvalidator20190603055323.azurewebsites.net)
    (you can customize it).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: To test your function, use the following URL: `https://emailvalidator20190603055323.azurewebsites.net/**api/EmailValidator?email=masteringd365bc****@packt.com**`**.**
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The function now runs in the Azure cloud and you're ready to use it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: There is an alternative way of developing an Azure function that's extremely
    important for any Dynamics 365 Business Central developer. We'll take a look at
    this in the next section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Developing an Azure function with Visual Studio Code
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start developing Azure functions with Visual Studio Code, you need to install
    the following extensions:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Azure Account, which you can download from [https://marketplace.visualstudio.com/items?itemName=ms-vscode.azure-account](https://marketplace.visualstudio.com/items?itemName=ms-vscode.azure-account).
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Functions, which you can download from [https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azurefunctions](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azurefunctions).
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You also need to install Azure Functions Core Tools, a set of tools that allow
    you to develop and test your functions on your local machine.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: You need to install the version that supports the Azure Functions runtime you're
    using. You can install this at [https://github.com/Azure/azure-functions-core-tools](https://github.com/Azure/azure-functions-core-tools).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'To develop Azure functions with Visual Studio Code, follow these steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to do is log into your Azure subscription by using
    the Azure: Sign In command from the Visual Studio Code Command Palette:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1ec18be7-968c-4595-9c2f-af123e6c6cdf.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: After entering your credentials, you will see the account connected to your
    subscription at the bottom bar of Visual Studio Code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, on the Visual Studio Code sidebar, select the Azure Functions extension
    and click on the Create New Project button:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0d2e84b2-407e-4ef6-b2eb-3bb9572f2ee5.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: Select a folder that you want to place your Azure Functions project in.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you will be prompted to choose a language to develop your function in.
    From the list of supported languages, I''ve selected C#, as shown here:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9c3ee88c-e9ab-4521-bbfc-e45e78b492f8.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: 'Next, you have to select either of the following runtime versions for your
    Azure function:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Azure Functions v2 (.NET Standard): Based on .NET Core (cross-platform), this
    is the new available runtime.'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A**zure Functions v1 (.NET Framework): Based on .NET Framework, this only
    supports development and hosting in the Azure portal or on Windows computers.'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, I''ve selected Azure Functions v2 (.NET Standard):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34fb3c07-942c-4653-b110-d12729c20e95.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: 'Now, set a name for your Azure Functions project (here, I''ve named it `EmailValidatorCore`):'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/558b7f94-7f61-4c2d-b12e-e6676028c982.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: 'After naming the project, provide a namespace:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cb46ae58-b5a9-4b9e-955b-e3fba0dddad0.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: 'Now, you need to select the authentication type for your function. For simplicity,
    I''ve selected Anonymous (everyone can call our function):'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/33c9710b-dc04-4072-8c75-8d34eb61917f.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: Now, choose where to open the project that will be created (Current window,
    New window, and Add to workspace are the available options).
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Visual Studio Code will start downloading the required packages for your Azure
    Functions project, and, when it''s finished, a set of files will be created. The
    following is the template of your Azure function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c3edb55-182d-47a9-b2f1-66b9a9a1fd32.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: 'Here, you have the following files:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '`host.json`: This file contains the global configuration options that affect
    all the functions in your project. In our project, we have the runtime version
    (2.0).'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`local.settings.json`: This file contains the settings of your project.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EmailValidatorCore.cs`: This is your function''s source code (C#).'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Please note that you may have some temporary errors in your code (missing references).
    This occurs when Visual Studio Code needs to download all the .NET Core packages.
    To get the correct references, you need to execute the .NET: Restore Project command
    from the Command Palette, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17c61411-bb61-40a8-bcc5-0607d8ac99a5.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: 'Select the proposed option and click OK, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ad494d1-b0a7-4f97-a16b-9b0b84b1e244.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: Your project's references are now fixed and you can start coding your function.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: As in the previous example, we want to create a function for validating email
    addresses, and we can reuse the same C# code to do so. Here, you've seen how to
    start creating an Azure Functions project by using Visual Studio Code directly.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Testing your Azure function locally
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test your function locally, you need to install the Azure Functions Core
    Tools. This can be installed using the following command on the Command Prompt
    (or from the Visual Studio Code Terminal):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To use npm with Visual Studio Code, you need to have Node.js installed on your
    machine. You can install it from [https://nodejs.org/en/](https://nodejs.org/en/).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the `npm` command, some packages will be downloaded and installed
    on your local machine:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e231f0f-1b58-48a5-8a23-e0b6cfe57bbd.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: After installing the tools, you need to restart Visual Studio Code in order
    for this to take effect.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'To start testing your function locally, you can press *F5* directly in Visual
    Studio Code. The local Azure Function Host environment will start and Visual Studio
    Code will give you a local URL so that you can call your function:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a78c85f8-0b31-4c91-8d9f-472a7d11516a.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: Now, we can test the function by passing the email parameter via a URL in a
    browser (like we did in the *Deploying the function to Azure* section).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with this, we can debug the code directly from Visual Studio Code by
    placing breakpoints, moving step by step, checking variables and outputs, and
    so on, as shown in the following screenshot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd3f6abe-1786-4d91-b3f4-2ea341081d7b.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: Now, you've debugged and tested your Azure function in your local environment.
    In the next section, we'll learn how to publish the function to the Azure cloud.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Publishing your function to Azure
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To deploy your Azure function to Azure, follow these simple steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Azure Functions icon in the Visual Studio Code sidebar and click
    on the blue arrow icon called Deploy to Function App, as shown here:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Visual Studio Code侧边栏中的Azure Functions图标，然后点击名为“部署到Function App”的蓝色箭头图标，如下所示：
- en: '![](img/660d64e1-7c5d-4d0f-85cf-0022fe6d2f65.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/660d64e1-7c5d-4d0f-85cf-0022fe6d2f65.png)'
- en: 'Visual Studio Code will ask you to choose an Azure subscription as the location
    to deploy your function to from the list of the available subscriptions for your
    account, as shown here:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio Code将要求您从帐户的可用订阅列表中选择一个Azure订阅作为部署函数的目标位置，如下所示：
- en: '![](img/d2a27f5d-0ec7-4894-a38a-cbe6ff47f4bc.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2a27f5d-0ec7-4894-a38a-cbe6ff47f4bc.png)'
- en: 'Now, select Create New Function App in Azure and give it a globally unique
    name:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择在Azure中创建新的Function App并为其指定一个全球唯一的名称：
- en: '![](img/0f86ea16-c64a-43a9-969b-701b643a5ee0.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f86ea16-c64a-43a9-969b-701b643a5ee0.png)'
- en: I've called it `SDEmailValidatorCore`*.*
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我称之为`SDEmailValidatorCore`*。
- en: From here, you can create a new resource group and a new storage account. Choose
    the region where you want to deploy your function. Then, resource deployment will
    start.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里，您可以创建一个新的资源组和一个新的存储帐户。选择您希望部署函数的区域。然后，资源部署将开始。
- en: 'When the deployment process is finished, Visual Studio Code will show you a
    confirmation message in the bottom-right corner. You can see the deployed function
    in the subscription tree view on the left:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署过程完成后，Visual Studio Code将在右下角显示确认消息。你可以在左侧的订阅树视图中看到已部署的功能：
- en: '![](img/4d737d43-2329-48eb-b2a2-04fc0d429d09.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d737d43-2329-48eb-b2a2-04fc0d429d09.png)'
- en: Now, your Azure function is running on an Azure data center and you can start
    using it with AL code. We will look at this in more detail in the next section.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的Azure函数已在Azure数据中心运行，您可以开始在AL代码中使用它。我们将在下一节中更详细地讨论这一点。
- en: Calling an Azure function from AL
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从AL调用Azure函数
- en: Now that we have deployed our function to Azure, we can use it from the AL code
    in our extensions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已将函数部署到Azure，可以在扩展中的AL代码中使用它。
- en: As we explained in [Chapter 6](512b0690-f392-4f82-b006-cacdeec1bacc.xhtml), *Advanced
    AL Development*, in the *Consuming web services and APIs from AL* section, we
    can call an Azure function with AL by using the `HttpClient` data type, which
    provides a data type for sending HTTP requests and receiving HTTP responses from
    a resource that's been identified by a URI.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第6章](512b0690-f392-4f82-b006-cacdeec1bacc.xhtml)《*高级AL开发*》中的*从AL调用Web服务和API*一节所解释的那样，我们可以通过使用`HttpClient`数据类型来调用Azure函数，该数据类型提供了一种发送HTTP请求和接收来自通过URI标识的资源的HTTP响应的方式。
- en: 'To test our Azure function, we will create a simple extension (a new project
    with **AL:Go!**) that allows us to validate an email address associated with a
    customer record. Our `CustomerEmailValidation` extension is made up of a single
    codeunit object where we define an event subscriber to the `OnAfterValidate` event
    of the E-Mail field in the `Customer` table. In this `EventSubscriber` procedure
    (called `ValidateCustomerEmail`), we do the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的Azure函数，我们将创建一个简单的扩展（一个使用**AL:Go!**的新项目），它允许我们验证与客户记录关联的电子邮件地址。我们的`CustomerEmailValidation`扩展由一个代码单元对象组成，我们在其中定义了一个事件订阅者来监听`Customer`表中电子邮件字段的`OnAfterValidate`事件。在这个`EventSubscriber`过程（名为`ValidateCustomerEmail`）中，我们做了以下操作：
- en: Call the Azure function using the `HttpClient` object.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`HttpClient`对象调用Azure函数。
- en: Read the response from the Azure function using the `HttpResponse` object.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`HttpResponse`对象读取Azure函数的响应。
- en: Parse the JSON response in order to extract the `Valid` token.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析JSON响应以提取`Valid`标记。
- en: Throw an error if `Valid = false`.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`Valid = false`，则抛出错误。
- en: 'The code for this is as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码如下所示：
- en: '[PRE6]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Press *F5* and deploy your extension.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*F5*并部署你的扩展。
- en: 'If you open a customer card, go to the Address & Contact tab and insert a value
    into the Email field. You will receive the following message:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果打开客户卡，转到地址和联系方式标签页，并在电子邮件字段中插入一个值，您将收到以下消息：
- en: '![](img/46ab5b45-695c-4291-9316-3eccc92eb978.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46ab5b45-695c-4291-9316-3eccc92eb978.png)'
- en: This happens the first time you do this because outbound HTTP calls are blocked
    by default in a sandbox environment. Select Allow Once and click OK.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您第一次这样做时发生的，因为默认情况下，沙箱环境会阻止外部HTTP调用。请选择“允许一次”并点击“确定”。
- en: 'Then, our Azure function is called, the JSON response is retrieved and parsed,
    and the validation occurs. If you insert a valid email address, the value is correctly
    inserted into the Email field; otherwise, you will receive an error, as shown
    in the following screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的 Azure 函数被调用，JSON 响应被检索并解析，验证过程开始。如果你插入一个有效的电子邮件地址，值会正确插入到电子邮件字段中；否则，你将收到一个错误，如下图所示：
- en: '![](img/e660b2dd-634a-4961-a65e-05c19a4acfdf.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e660b2dd-634a-4961-a65e-05c19a4acfdf.png)'
- en: To allow external calls in a sandbox environment automatically, in the `NAV
    App Settings` table, there is a Boolean field called `Allow HttpClient Requests`,
    and, when the user selects one of the Always options (Allow Always or Block Always),
    then a record is inserted into this table with the field set to `true` or `false`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动允许沙盒环境中的外部调用，在 `NAV App Settings` 表中，有一个名为 `Allow HttpClient Requests` 的布尔字段，当用户选择其中一个始终选项（始终允许或始终阻止）时，会在此表中插入一条记录，并将字段设置为
    `true` 或 `false`。
- en: 'You can also control this setting programmatically in your AL code. In our
    extension, we have added the following procedure:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过 AL 代码以编程方式控制此设置。在我们的扩展中，我们添加了以下过程：
- en: '[PRE7]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code retrieves the information about the current extension (`ModuleInfo`)
    and then checks whether the extension is running in a sandbox environment. If
    so, it sets the `Allow HttpClient Requests` field to `true`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码检索当前扩展的信息（`ModuleInfo`），然后检查扩展是否在沙盒环境中运行。如果是，它将 `Allow HttpClient Requests`
    字段设置为 `true`。
- en: 'In our previous event subscriber (`ValidateCustomerEmail` procedure), we enable
    the external calls when needed by calling the `EnableExternalCallsInSandbox` procedure,
    as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的事件订阅者（`ValidateCustomerEmail` 过程）中，当需要时，我们通过调用 `EnableExternalCallsInSandbox`
    过程来启用外部调用，如下所示：
- en: '[PRE8]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This allows you to avoid seeing the confirmation request on every external HTTP
    call.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以避免在每次外部 HTTP 调用时看到确认请求。
- en: In the next section, we'll learn how to use Azure Functions and Azure Blob Storage
    to handle files in the cloud.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用 Azure Functions 和 Azure Blob 存储来处理云中的文件。
- en: Interacting with Azure Blob Storage to handle files in the cloud
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Azure Blob 存储交互以处理云中的文件
- en: One of the main problems we have in the cloud environment with Dynamics 365
    Business Central is related to saving files. As we mentioned previously, in the
    cloud environment, you don't have a filesystem and you cannot access local resources
    such as network shares or local disks.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Dynamics 365 Business Central 的云环境中遇到的主要问题之一与文件保存有关。正如我们之前提到的，在云环境中，你没有文件系统，无法访问本地资源，如网络共享或本地磁盘。
- en: If you want to save files with Dynamics 365 Business Central SaaS, the solution
    is to call an Azure function and store the file in cloud-based storage. You can
    create a function that saves a file in Azure Blob Storage, and from here you can
    share Azure Storage as a network drive. This is the scenario that we will cover
    in this section.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在 Dynamics 365 Business Central SaaS 中保存文件，解决方案是调用 Azure 函数并将文件存储到基于云的存储中。你可以创建一个将文件保存到
    Azure Blob 存储的函数，之后你可以将 Azure 存储共享为网络驱动器。这是我们将在本节中介绍的场景。
- en: Creating an Azure Blob Storage account
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Azure Blob 存储帐户
- en: As the first step in implementing our solution, we need to have a storage account
    on Azure and we need to create a Blob container inside that storage account.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 实现我们解决方案的第一步是需要在 Azure 上拥有一个存储帐户，并且我们需要在该存储帐户中创建一个 Blob 容器。
- en: 'To manually create an Azure Storage account (called `d365bcfilestorage`, in
    this case), follow these steps:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动创建一个 Azure 存储帐户（在本例中为 `d365bcfilestorage`），请按照以下步骤操作：
- en: 'Select Storage Accounts from the Azure portal, click Create, and follow the
    instructions on the screen. To create a Blob container inside this storage account,
    select Blobs from the Services section:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Azure 门户中选择存储帐户，点击创建，并按照屏幕上的指示操作。要在此存储帐户中创建 Blob 容器，请从服务部分选择 Blobs：
- en: '![](img/d3c3a374-0559-48a9-ad6c-9172a194b8ab.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3c3a374-0559-48a9-ad6c-9172a194b8ab.png)'
- en: 'Then, click on Container, give it a name (here, I''ve chosen d365bcfiles),
    select the public access level (by default, container data is private to the account
    owner), and click OK:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击容器，给它命名（在这里，我选择了 `d365bcfiles`），选择公共访问级别（默认情况下，容器数据对帐户所有者是私密的），然后点击确定：
- en: '![](img/8c6c7a05-854a-40cc-9aaa-6bdd7febf6a6.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c6c7a05-854a-40cc-9aaa-6bdd7febf6a6.png)'
- en: Now, the Blob container has been created in your Azure Storage account.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Blob 容器已经在你的 Azure 存储帐户中创建。
- en: 'The connection string for accessing your Azure Storage account (which must
    be used in your Azure functions) can be retrieved by selecting the storage account
    and clicking on Access keys:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/402218f9-682b-42f4-beef-412953308047.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: Here, we'll embed this connection string inside the function project, but, in
    a production environment, you can store it in an Azure Key Vault and retrieve
    it from there for better security.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'In our Blob container, I''ve manually uploaded a file (PNG image) in order
    to store a file:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24789192-0a65-4d50-93ab-4d94eb33b680.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
- en: Now, we have created a Blob container on Azure Storage so that we can host our
    files. In the next section, we'll create an Azure function for saving and retrieving
    files from this Blob storage.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Creating Azure functions with Visual Studio
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open Visual Studio and create a new Azure Functions project by selecting the
    HttpTrigger template. Name your function `SaaSFileMgt`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'In our project, we want to create the following functions:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '`UploadFile`: This function will receive an object with binary data (file content)
    and some metadata (file details) via an HTTP POST request. It will store the file
    in a container in an Azure Blob Storage account.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DownloadFile`: This function will receive an object with the URI of the file
    to download and its details (via an HTTP POST request) and returns the binary
    of the file stored in the Azure Blob Storage container.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListFiles`: This function will retrieve (via an HTTP GET request) a list of
    all the URIs of the files stored in the Azure Blob Storage container. These files
    will be explained in the upcoming sections.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The functions to upload/download a file must only support the HTTP POST method,
    so, in the `HttpTrigger` definition template, we have removed the `get` parameter.
    The signatures of these functions are as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The function to list files in Blob storage must only support the GET method,
    and the signature is as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let's explore each of these functions.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The UploadFile function
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `UploadFile` function receives a JSON object in the body via an HTTP POST
    request, as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `UploadFile` function parses the JSON in the request body and then calls
    the `UploadBlobAsync` function. In this function, we upload the file to the Azure Blob Storage
    container and we return the URI of the uploaded file.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UploadFile` function''s code is as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`UploadBlobAsync` is a function that performs the Blob upload to the `d365bcfiles`
    container in the Azure Storage account. Its code is as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The DownloadFile function
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `DownloadFile` function receives a JSON object in the body via an HTTP POST
    request, as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This function retrieves the details of the file to download from the request
    body and calls the `DownloadBlobAsync` function. Then, it returns the content
    of the downloaded file (`Base64-encoded` string):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`DownloadBlobAsync` is the function that connects to the Azure Storage Blob
    container, checks for the file, and (if it is found) returns the byte array (stream)
    of this file:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The ListFiles function
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ListFiles` function is called via an HTTP GET request (no parameters).
    It calls the `ListBlobAsync` function and then returns the list of the URI of
    the files in the blob container (JSON format).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Its code is defined as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `ListBlobAsync` function connects to the Azure Storage container and retrieves
    the list of blob files stored on it by using the `ListBlobsSegmentedAsync` method.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'This method returns the list of files in segments by using a `BlobContinuationToken`.
    When this token is `null`, all the files are retrieved:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, that we've created our Azure functions, it's time to deploy them. We'll
    learn how to do this in the next section.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the Azure functions
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our Azure functions can be deployed to our Azure subscription directly from
    Visual Studio. To deploy these functions to Azure, you need to create a new Azure App
    Service instance, as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/292d5a02-7c3e-406f-b1c1-2eccca5cc001.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
- en: 'After that, publish your functions to this Azure App Service:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e786f1bc-3529-4e23-9ff8-e4e001f556f4.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: 'If you go to the Azure portal, you will see that the functions have been published
    and that you now have a public URL to test them:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70efcc40-93fa-4736-883a-6b578331ae11.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
- en: Now, the functions run on an Azure data center. In the next section, we'll learn
    how we can manage the access keys of our deployed functions (authorization).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Managing Azure Functions keys
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Azure Functions uses authorization keys to protect access to your HTTP-triggered
    functions. When you deploy a function, you can choose between the following authorization
    levels:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Anonymous: No access key is required.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Function: A specific access key is required in order to access the function.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Admin: A master host key is required.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can manage these access keys directly from the Azure portal by selecting
    your function and clicking on Manage:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f41732fd-9acb-4a01-8baa-3ea5357fb8ba.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
- en: You can also use the Key Management API ([https://github.com/Azure/azure-functions-host/wiki/Key-management-API](https://github.com/Azure/azure-functions-host/wiki/Key-management-API))
    if you want to manage keys programmatically.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: More information on how you can manage the authorization keys for your Azure
    Functions can be found here: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-http-webhook#authorization-keys](https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-http-webhook#authorization-keys).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you've learned how to handle access keys for our Azure function.
    In the next section, we'll learn how to test our previously deployed Azure function
    (uploading and downloading files from Blob storage).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Azure functions
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our scenario, the Azure functions have been deployed with the Function authorization
    level, so we need to call the desired function by passing a `code` parameter with
    the function key (which we can obtain from the portal). For example, to test the
    `ListFiles` function, we need to call the following URL: [https://saasfilemgt.azurewebsites.net/api/ListFiles?code=FUNCTIONKEY](https://saasfilemgt.azurewebsites.net/api/ListFiles?code=FUNCTIONKEY).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the response we get (a list of our Blob files'' URIs):'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2db0a962-b694-4ef5-848f-0bb31af85d01.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
- en: 'To test the `DownloadFile` function, we need to send a POST request to the
    function''s URL by passing a JSON object with the following parameters (which
    identify the file to retrieve):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Launching the HTTP request from Visual Studio Code gives us the following response:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd884e9c-701c-4d9c-bee9-063b5dd6bdbb.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
- en: As you can see, the function downloads the requested file from Azure Blob Storage
    (the function returns the Base64 string).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll learn how to call our Azure function from an AL extension
    in Dynamics 365 Business Central.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Dynamics 365 Business Central extension
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The extension we want to create here is a simple application that adds two actions
    to the *Item List* page for uploading and downloading files to/from Azure Blob
    Storage.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'This AL extension will define two objects:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: A `codeunit` object with the logic to call our Azure functions that handle the
    files with Azure Blob Storage
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `pageextension` object that adds the actions on the Item List page and calls
    the relative procedures defined in our codeunit
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at these in more detail.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Codeunit definition
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The codeunit is called `SaaSFileMgt` and contains two procedures:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '`UploadFile`: This function will handle the file upload to Azure Blob Storage.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DownloadFile`: This function will handle the file download from Azure Blob
    Storage.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the codeunit, we have two global variables, both of which contain the URLs
    of the Azure functions to call:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, `YOURFUNCTIONKEY` is the key we use to access the Azure function (retrieved
    from the Azure portal by selecting the function and clicking on Manage).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UploadFile` procedure is defined as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'From the preceding code, we can see the following:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: We ask for a file to upload.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We read the file into a `Stream` object.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We retrieve some parameters related to the file (name and extension).
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a JSON message, as requested by the function (as we described previously).
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we send an HTTP POST request to our Azure function (by using the `HttpClient`
    object), passing the JSON in the body.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `DownloadFile` procedure is defined as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This procedure receives the name of the file to retrieve as input. This is
    how it works:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: It calls a custom function (`GetMimeType`) that returns the content type of
    this file, and then we compose the JSON message for the request.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we send an HTTP POST request to our Azure function (by using the `HttpClient`
    object), passing the JSON in the body.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We read the `HttpResponse` object (Base64 of the retrieved file) and download
    it to the client-side by using an `InStream` object and calling the `DownloadFromStream`
    method.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `GetMimeType` utility is defined as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This simply receives a filename as input, retrieves the file extension, and
    then returns the MIME type associated with the file.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: The pageextension definition
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `pageextension` object extends the Item List page by adding the two actions
    we described previously. The object definition is as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: These two actions simply call the methods defined in our codeunit by passing
    the required parameters.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll test the integrated solution (an Azure function being
    called by Dynamics 365 Business Central).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Testing our application
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it''s time to test our application and see how it works. When published,
    our extension adds two functions to the *Item List* page for uploading/downloading
    files:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/603088b6-2b73-4541-bd2a-f47057f92fd9.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
- en: 'If you click the Upload file to Azure Blob Storage action, you can select a
    file from your local machine:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e21b0c5b-f7ce-4a8c-bc58-b905753d9c2d.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
- en: 'This file will be uploaded to the Azure Blob Storage container via an HTTP POST
    request to our Azure function. We can debug the `httpResponse` object and see
    that it returns `HttpStatusCode = 200 (success)`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d315bb5a-8ebf-449e-b794-29c16b150cf2.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
- en: 'We will receive a message that tells us that the file has been uploaded to
    Azure Blob Storage, as shown here:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/234275d8-b469-407b-ab85-bc5ba1908627.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
- en: 'If we check the blob container in our Azure Storage account, we will see that
    the file has been uploaded into the blob storage correctly:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f4d69e6-1705-4465-8f16-30013b6a7718.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
- en: When you click on the Download file from Azure Blob Storage action, an HTTP POST
    request to the `DownloadFile` Azure function is performed (by passing a JSON body,
    as we described previously) and the `httpResponse` object returns `HttpStatusCode
    = 200 (success)`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'The `httpResponse` object is a Base64 encoding of the retrieved file. Here,
    the Base64 string is decoded and the file is downloaded to the client-side by
    using an `InStream`:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5295bfba-9cdf-4ee7-9aec-83f649c36721.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
- en: As you can see, the file is retrieved from the stream and the browser prompts
    the user to download it locally.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can handle files in a cloud environment (upload and download). Azure
    also allows us to map the Blob storage to our on-premise network so that we can
    have a serverless filesystem that's totally transparent for the end user.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at what Azure functions are and how we can use them
    in our Dynamics 365 Business Central extensions to execute .NET code on a cloud
    environment and to implement serverless processes.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to create a simple Azure function using Visual Studio and Visual
    Studio Code and how to use Azure Functions with other Azure services (in particular,
    how to use Azure Functions and Azure Blob Storage to implement a filesystem in
    the cloud with Dynamics 365 Business Central).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you should understand how to develop, deploy, and
    use Azure functions to implement business tasks in the cloud in a totally serverless
    way. In a modern cloud-based ERP, this is a really important feature to master
    in order to extend the platform's functionalities and to embrace other cloud services.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn how to monitor and scale our functions in the
    cloud and how to apply DevOps techniques (continuous integration and continuous
    deployment) to our Azure Functions projects by using Azure DevOps.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
