<html><head></head><body>
		<div id="_idContainer012">
			<h1 id="_idParaDest-16"><em class="italic"><a id="_idTextAnchor015"/>Chapter 1</em>: Introduction to Container Technology</h1>
			<p><strong class="bold">Container technology</strong> has old roots in operating system history. For example, do you know that part of container technology was born back in the 1970s? Despite their simple and intuitive approach, there are many concepts behind containers that deserve a deeper analysis to fully grasp and appreciate how they made their way in the IT industry.</p>
			<p>We're going to explore this technology to better understand how it works under the hood, the theory behind it, and its basic concepts. Knowing the mechanics and the technology behind the tools will let you easily approach and learn the whole technology's key concepts. </p>
			<p>Then, we will also explore container technology's purpose and why it has spread to every company today. Do you know that 50% of the world's organizations are running half of their application base as containers in production nowadays? </p>
			<p>Let's dive into this great technology!</p>
			<p>In this chapter, we're going to ask the following questions:</p>
			<ul>
				<li>What are containers?</li>
				<li>Why do I need a container?</li>
				<li>Where do containers come from?</li>
				<li>Where are containers used today?</li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Technical requirements</h1>
			<p>This chapter does not require any technical prerequisites, so feel free to read it without worrying about installing or setting up any kind of software on your workstation!</p>
			<p>Anyway, if you are new to containers, you will find here many technical concepts useful to understand the next chapters. We recommend going through it carefully and coming back when needed. Previous knowledge of the Linux operating system would be helpful in understanding the technical concepts covered in this book.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Book conventions</h1>
			<p>In the following chapters, we will learn many new concepts with practical examples that will require active interaction with a Linux shell environment. In the practical examples, we will use the following conventions:</p>
			<ul>
				<li>For any shell command that will be anticipated by the <strong class="source-inline">$</strong> character, we will use a standard user (not root) for the Linux system.</li>
				<li>For any shell command that will be anticipated by the <strong class="source-inline">#</strong> character, we will use the root user for the Linux system.</li>
				<li>Any output or shell command that would be too long to display in a single line for the code block will be interrupted with the <strong class="source-inline">\</strong> character, and then it will continue to a new line.</li>
			</ul>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>What are containers?</h1>
			<p>This section describes the container technology from the ground up, beginning from basic concepts such <a id="_idIndexMarker000"/>as processes, filesystems, system calls, the process isolation up to container engines, and runtimes. The purpose of this section is to describe how containers implement process isolation. We also describe what differentiates containers from virtual machines and highlight the best use case of both scenarios. </p>
			<p>Before asking ourselves what a container is, we should answer another question: what is a process?</p>
			<p>According to <em class="italic">The Linux Programming Interface</em>, an enjoyable book by <em class="italic">Michael Kerrisk</em>, a <em class="italic">process</em> is an instance of an <a id="_idIndexMarker001"/>executing program. A program is a file holding information necessary to <a id="_idIndexMarker002"/>execute the process. A program can be dynamically linked to external libraries, or it can be statically linked in the program <a id="_idIndexMarker003"/>itself (the Go programming language uses this approach by default).</p>
			<p>This leads us to an important concept: a process is executed in the machine CPU and allocates a portion of memory containing program code and variables used by the code itself. The process is instantiated in the machine's user space and its execution is orchestrated by the <a id="_idIndexMarker004"/>operating system kernel. When a process is executed, it needs to access different machine resources such as I/O (disk, network, terminals, and so on) or memory. When the process needs to access those resources, it performs a system call into the kernel space (for example, to read a disk block or send packets via the network interface).</p>
			<p>The process indirectly interacts with the host disks using a filesystem, a multi-layer storage abstraction, that <a id="_idIndexMarker005"/>facilitates the write and read access to files and directories. </p>
			<p>How many processes usually run in a machine? A lot. They are orchestrated by the OS kernel with complex scheduling logics that make the processes behave like they are running on a dedicated CPU core, while the same is shared among many of them.</p>
			<p>The same program can instantiate many processes of its kind (for example, multiple web server instances running on the same machine). Conflicts, such as many processes trying to access the same network port, must be managed accordingly.</p>
			<p>Nothing prevents us from running a different version of the same program on the host, assuming that system administrators will have the burden of managing potential conflicts of binaries, libraries, and their dependencies. This could become a complex task, which is not always easy to solve with common practices. </p>
			<p>This brief introduction was necessary to set the context. </p>
			<p>Containers are a simple and smart answer to the need of running isolated process instances. We can safely affirm that containers are a form of application isolation that works on many levels:</p>
			<ul>
				<li><strong class="bold">Filesystem isolation</strong>: Containerized processes have a separated filesystem view, and their programs <a id="_idIndexMarker006"/>are executed from the isolated filesystem itself.</li>
				<li><strong class="bold">Process ID isolation</strong>: This is a <a id="_idIndexMarker007"/>containerized process run <a id="_idIndexMarker008"/>under an independent set of <strong class="bold">process IDs</strong> (<strong class="bold">PIDs</strong>).</li>
				<li><strong class="bold">User isolation</strong>: <strong class="bold">User IDs</strong> (<strong class="bold">UIDs</strong>) and <strong class="bold">group IDs</strong> (<strong class="bold">GIDs</strong>) are isolated to the container. A process' UID and GID can be different inside a container <a id="_idIndexMarker009"/>and run with a privileged UID or GID inside <a id="_idIndexMarker010"/>the container only.</li>
				<li><strong class="bold">Network isolation</strong>: This kind of isolation relates to the host network resources, such <a id="_idIndexMarker011"/>as network devices, IPv4 and IPv6 stacks, routing tables, and firewall rules.</li>
				<li><strong class="bold">IPC isolation</strong>: Containers <a id="_idIndexMarker012"/>provide isolation for host IPC resources, such as POSIX message queues or System V IPC objects. </li>
				<li><strong class="bold">Resource usage isolation</strong>: Containers rely on Linux <strong class="bold">control groups</strong> (<strong class="bold">cgroups</strong>) to limit <a id="_idIndexMarker013"/>or monitor the usage of certain resources, such as CPU, memory, or disk. We will discuss more about cgroups later in this chapter.</li>
			</ul>
			<p>From an adoption point <a id="_idIndexMarker014"/>of view, the main purpose of containers, or at least the most common use case, is to run applications in isolated environments. To better understand this concept, we can look at the following diagram:</p>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="image/B17908_01_01.jpg" alt="Figure 1.1 – Native applications versus containerized ones&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – Native applications versus containerized ones</p>
			<p>Applications running natively on a system that does not provide containerization features share the same binaries and libraries, as well as the same kernel, filesystem, network, and users. This could lead to many issues when an updated version of an application is deployed, especially conflicting library issues or unsatisfied dependencies.</p>
			<p>On other hand, containers offer a consistent layer of isolation for applications and their related dependencies <a id="_idIndexMarker015"/>that ensures seamless coexistence on the same host. A new deployment only consists of the execution of the new containerized version, as it will not interact or conflict with the other containers or native applications.</p>
			<p>Linux containers are enabled by different native kernel features, with the most important being <strong class="bold">Linux namespaces</strong>. Namespaces abstract specific system resources (notably, the ones <a id="_idIndexMarker016"/>described before, such as network, filesystem mount, users, and so on) and make them appear as unique to the isolated process. In this way, the process has the illusion of interacting with the host resource, for example, the host filesystem, while an alternative and isolated version is being exposed.</p>
			<p>Currently, we have a total of eight kinds of namespaces:</p>
			<ul>
				<li><strong class="bold">PID namespaces</strong>: These <a id="_idIndexMarker017"/>isolate the process ID number in a separate space, allowing processes <a id="_idIndexMarker018"/>in different PID namespaces to retain the same PID.</li>
				<li><strong class="bold">User namespaces</strong>: These isolate user and group IDs, root directory, keyrings, and capabilities. This <a id="_idIndexMarker019"/>allows a process to have <a id="_idIndexMarker020"/>a privileged UID and GID inside the container while simultaneously having unprivileged ones outside the namespace.</li>
				<li><strong class="bold">UTS namespaces</strong>: These allow <a id="_idIndexMarker021"/>the isolation <a id="_idIndexMarker022"/>of hostname and NIS domain name.</li>
				<li><strong class="bold">Network namespaces</strong>: These allow <a id="_idIndexMarker023"/>isolation of networking <a id="_idIndexMarker024"/>system resources, such as network devices, IPv4 and IPv6 protocol stacks, routing tables, firewall rules, port numbers, and <a id="_idIndexMarker025"/>so on. Users can create virtual network devices called <strong class="bold">veth pairs</strong> to build tunnels between network namespaces.</li>
				<li><strong class="bold">IPC namespaces</strong>: These isolate IPC resources such as System V IPC objects and POSIX <a id="_idIndexMarker026"/>message queues. Objects created in an IPC namespace can <a id="_idIndexMarker027"/>be accessed only by the processes that are members of the namespace. Processes use IPC to exchange data, events, and messages in a client-server mechanism.</li>
				<li><strong class="bold">cgroup namespaces</strong>: These isolate <a id="_idIndexMarker028"/>cgroup directories, providing a virtualized view <a id="_idIndexMarker029"/>of the process's cgroups.</li>
				<li><strong class="bold">Mount namespaces</strong>: These <a id="_idIndexMarker030"/>provide isolation of the mount <a id="_idIndexMarker031"/>point list that is seen by the processes in the namespace.</li>
				<li><strong class="bold">Time namespaces</strong>: These <a id="_idIndexMarker032"/>provide an isolated <a id="_idIndexMarker033"/>view of system time, letting processes in the namespace run with a time offset against the host time.</li>
			</ul>
			<p>Now's, let's move on to resource usage.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Resource usage with cgroups</h2>
			<p>cgroups are a native <a id="_idIndexMarker034"/>feature of the Linux kernel whose purpose is to <a id="_idIndexMarker035"/>organize processes in a hierarchical tree and limit or monitor their resource usage.</p>
			<p>The kernel cgroups interface, similar to what happens with <strong class="source-inline">/proc</strong>, is exposed with a <strong class="source-inline">cgroupfs</strong> pseudo-filesystem. This filesystem is usually mounted under <strong class="source-inline">/sys/fs/cgroup</strong> in the host.</p>
			<p>cgroups offer a series <a id="_idIndexMarker036"/>of controllers (also called subsystems) that can be used for different purposes, such as limiting the CPU time share of a process, memory usage, freeze and resume processes, and so on. </p>
			<p>The organizational hierarchy of controllers has changed through time, and there are currently two versions, V1 and V2. In cgroups V1, different controllers could be mounted against different hierarchies. Instead, cgroups V2 provide a unified hierarchy of controllers, with processes residing in the leaf nodes of the tree.</p>
			<p>cgroups are used by containers to limit CPU or memory usage. For example, users can limit CPU <a id="_idIndexMarker037"/>quota, which means limiting the number of microseconds the <a id="_idIndexMarker038"/>container can use the CPU over a given period, or limit CPU shares, the weighted proportion of CPU cycles for each container.</p>
			<p>Now that we have illustrated how process isolation works (both for namespaces and resources), we can illustrate a few basic examples.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Running isolated processes</h2>
			<p>A useful fact to know is that GNU/Linux operating systems offer all the features necessary to <a id="_idIndexMarker039"/>run a container manually. This result can be achieved by working with a specific system call (notably <strong class="source-inline">unshare()</strong> and <strong class="source-inline">clone()</strong>) and utilities such as the <strong class="source-inline">unshare</strong> command.</p>
			<p>For example, to run a process, let's say <strong class="source-inline">/bin/sh</strong>, in an isolated PID namespace, users can rely on the <strong class="source-inline">unshare</strong> command:</p>
			<p class="source-code"># unshare --fork --pid --mount-proc /bin/sh </p>
			<p>The result is the execution of a new shell process in an isolated PID namespace. Users can try to monitor the process view and will get an output such as the following:</p>
			<p class="source-code">sh-5.0# ps aux</p>
			<p class="source-code">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</p>
			<p class="source-code">root           1  0.0  0.0 226164  4012 pts/4    S    22:56   0:00 /bin/sh</p>
			<p class="source-code">root           4  0.0  0.0 227968  3484 pts/4    R+   22:56   0:00 ps aux</p>
			<p>Interestingly, the shell process of the preceding example is running with PID 1, which is correct, since it is the very first process running in the new isolated namespace.</p>
			<p>Anyway, the PID namespace will be the only one to be abstracted, while all the other system resources still remain the original host ones. If we want to add more isolation, for example on a network stack, we can add the <strong class="source-inline">--net</strong> flag to the previous command:</p>
			<p class="source-code"> # unshare --fork --net --pid --mount-proc /bin/sh</p>
			<p>The result is a shell process isolated on both PID and network namespaces. Users can inspect the network IP configuration and realize that the host native devices are no longer directly seen by the unshared process:</p>
			<p class="source-code">sh-5.0# ip addr show</p>
			<p class="source-code">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000</p>
			<p class="source-code">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</p>
			<p>The preceding examples are useful to understand a very important concept: containers are strongly <a id="_idIndexMarker040"/>related to Linux native features. The OS provided a solid and complete interface that helped container runtime development, and the capability to isolate namespaces and resources was the key that unlocked containers adoption. The role of the container runtime is to abstract the complexity of the underlying isolation mechanisms, with the mount point isolation being probably the most crucial of them. Therefore, it deserves a better explanation. </p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Isolating mounts</h2>
			<p>We have seen so far examples of unsharing that did not impact mount points and the filesystem view <a id="_idIndexMarker041"/>from the process side. To gain the filesystem isolation that prevents binary and library conflicts, users need to create another layer of abstraction for the exposed mount points.</p>
			<p>This result is achieved by leveraging mount namespaces and bind mounts. First introduced in 2002 with the Linux kernel 2.4.19, mount namespaces isolate the list of mount points seen by the process. Each mount namespace exposes a discrete list of mount points, thus making processes in different namespaces aware of different directory hierarchies.</p>
			<p>With this technique, it is possible to expose to the executing process an alternative directory tree that contains all the necessary binaries and libraries of choice.</p>
			<p>Despite seeming a simple task, the management of a mount namespace is all but straightforward and easy to master. For example, users should handle different archive versions of directory trees from different distributions, extract them, and bind mount on separate namespaces. We will see later that the first approaches with containers in Linux followed this approach. </p>
			<p>The success of containers is also bound to an innovative, multi-layered, copy-on-write approach of managing the <a id="_idIndexMarker042"/>directory trees that introduced a simple and fast method of copying, deploying, and using the tree necessary to run the container – container images.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Container images to the rescue</h2>
			<p>We must thank Docker <a id="_idIndexMarker043"/>for the introduction of this smart method of <a id="_idIndexMarker044"/>storing data for containers. Later, images would become an <strong class="bold">Open Container Initiative</strong> (<strong class="bold">OCI</strong>) standard specification (<a href="https://github.com/opencontainers/image-spec">https://github.com/opencontainers/image-spec</a>). </p>
			<p>Images can be seen as a filesystem bundle that is downloaded (pulled) and unpacked in the host before running the container for the first time.</p>
			<p>Images are downloaded from repositories called <strong class="bold">image registries</strong>. Those repositories can be seen as <a id="_idIndexMarker045"/>specialized object storages that hold image data and related metadata. There are both public and free-to-use registries (such as <strong class="source-inline">quay.io</strong> or <strong class="source-inline">docker.io</strong>) and private registries that can be executed in the customer private infrastructure, on-premises, or in the cloud.</p>
			<p>Images can be built by DevOps teams to fulfill special needs or embed artifacts that must be deployed and executed on a host. </p>
			<p>During the image build, process developers can inject pre-built artifacts or source code that can be compiled in the build container itself. To optimize image size, it is possible to create multi-stage builds with a first stage that compiles the source code using a base image with the necessary compilers and runtimes, and a second stage where the built artifacts are injected into a minimal, lightweight image, optimized for fast startup and minimal storage footprint. </p>
			<p>The <em class="italic">recipe</em> of the build process is defined in a special text file called a <strong class="bold">Dockerfile</strong>, which defines <a id="_idIndexMarker046"/>all the necessary steps to assemble the final image.</p>
			<p>After building them, users can push their own images on public or private registries for later use or complex, orchestrated deployments. </p>
			<p>The following diagram summarizes the build workflow:</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/B17908_01_02.jpg" alt="Figure 1.2 – Image build workflow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – Image build workflow</p>
			<p>We will cover the build topic more extensively later in this book.</p>
			<p>What makes a container image so special? The smart idea behind images is that they can be considered <a id="_idIndexMarker047"/>as a packaging technology. When users build their own image with all the binaries and dependencies installed in the OS directory tree, they are effectively creating a self-consistent object that can be deployed everywhere with no further software dependencies. From this point of view, container images are an answer to the long-debated sentence, <em class="italic">It works on my machine</em>. </p>
			<p>Developer teams love them because they can be certain of the execution environment of their applications, and operations teams love them because they simplify the deployment process by removing the tedious task of maintaining and updating a server's library dependencies.</p>
			<p>Another smart feature of container images is their copy-on-write, multi-layered approach. Instead of having <a id="_idIndexMarker048"/>a single bulk binary archive, an image is made up of many <strong class="source-inline">tar</strong> archives called <em class="italic">blobs</em> or <em class="italic">layers</em>. Layers are composed together using image metadata and <a id="_idIndexMarker049"/>squashed into a single filesystem view. This result can be achieved in many ways, but the <a id="_idIndexMarker050"/>most common approach today is by using <strong class="bold">union filesystems</strong>.</p>
			<p><strong class="bold">OverlayFS</strong> (<a href="https://www.kernel.org/doc/html/latest/filesystems/overlayfs.html">https://www.kernel.org/doc/html/latest/filesystems/overlayfs.html</a>) is the most used union <a id="_idIndexMarker051"/>filesystem nowadays. It is maintained in the kernel tree, despite not being completely POSIX-compliant.</p>
			<p>According to kernel documentation, <em class="italic">"An overlay filesystem combines two filesystems – an 'upper' filesystem and a 'lower' filesystem."</em> This means that it can combine more directory trees and provide a unique, squashed view. The directories are the layers and are referred to as <strong class="source-inline">lowerdir</strong> and <strong class="source-inline">upperdir</strong> to respectively define the low-level directory <a id="_idIndexMarker052"/>and the one stacked on top of it. The unified view is called <em class="italic">merged</em>. It supports <a id="_idIndexMarker053"/>up to 128 layers.</p>
			<p>OverlayFS is not aware of the concept of container image; it is merely used as a foundation technology to implement the multi-layered solution used by OCI images.</p>
			<p>OCI images also implement the concept of <strong class="bold">immutability</strong>. The layers of an image are all read-only and <a id="_idIndexMarker054"/>cannot be modified. The only way to change something in the lower layers is to rebuild the image with appropriate changes.</p>
			<p>Immutability is an important pillar of the cloud computing approach. It simply means that an infrastructure (such as an instance, container, or even complex clusters) can only be replaced by a different version and not modified to achieve the target deployment. Therefore, we usually do not change anything inside a running container (for example, installing packages or updating config files manually), even though it could be possible in some contexts. Rather, we replace its base image with a new updated version. This also ensures that every copy of the running containers stays in sync with others.</p>
			<p>When a container is executed, a new read/write thin layer is created on top of the image. This layer is ephemeral, thus any changes on top of it will be lost after the container is destroyed:</p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/B17908_01_03.jpg" alt="Figure 1.3 – A container's layers&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – A container's layers</p>
			<p>This leads to another important statement: we do not store anything inside containers. Their only purpose <a id="_idIndexMarker055"/>is to offer a working and consistent runtime environment for our <a id="_idIndexMarker056"/>applications. Data must be accessed <a id="_idIndexMarker057"/>externally, by using bind mounts inside the container itself <a id="_idIndexMarker058"/>or network storage (such as <strong class="bold">Network File System</strong> (<strong class="bold">NFS</strong>), <strong class="bold">Simple Storage Service</strong> (<strong class="bold">S3</strong>), <strong class="bold">Internet Small Computer System Interface</strong> (<strong class="bold">iSCSI</strong>), and so on).</p>
			<p>Containers' mount isolation and images layered design provide a consistent immutable infrastructure, but more security restrictions are necessary to prevent processes with malicious behaviors escape the container sandbox to steal the host's sensitive information or use the host to attack other machines. The following subsection introduces security considerations to show how container runtimes can limit those behaviors.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Security considerations</h2>
			<p>From a security point <a id="_idIndexMarker059"/>of view, there is a hard truth to share: if a process is running inside a container, it simply does not mean it is more secure than others. </p>
			<p>A malicious attacker can still make its way through the host filesystem and memory resources. To achieve better security isolation, additional features are available:</p>
			<ul>
				<li><strong class="bold">Mandatory access control</strong>: <em class="italic">SELinux</em> or <em class="italic">AppArmor</em> can be used to enforce container isolation <a id="_idIndexMarker060"/>against the parent host. These <a id="_idIndexMarker061"/>subsystems, and their related command-line utilities, use a policy-based <a id="_idIndexMarker062"/>approach to better isolate the running processes in terms of filesystem and network access.</li>
				<li><strong class="bold">Capabilities</strong>: When an unprivileged process is executed in the system (which means a process with an effective UID different from <strong class="source-inline">0</strong>), it is subject to permission checking based on the process credentials (its effective UID). Those permissions, or privileges, are called capabilities and can be enabled independently, assigning to an unprivileged process limited privileged permissions to access specific resources. When running a container, we can add or drop capabilities.</li>
				<li><strong class="bold">Secure Computing Mode</strong> (<strong class="bold">Seccomp</strong>): This is a native kernel feature that can be used to restrict <a id="_idIndexMarker063"/>the syscall that a process is able to make from user space to kernel space. By identifying the strictly necessary privileges needed by a process to run, administrators can apply seccomp profiles to limit the attack surface.</li>
			</ul>
			<p>Applying the preceding security features manually is not always easy and immediate, as some of them require a shallow learning curve. Instruments that automate and simplify (possibly in a declarative way) these security constraints provide a high value.</p>
			<p>We will discuss security topics in further detail later in this book.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Container engines and runtimes</h2>
			<p>Despite being feasible <a id="_idIndexMarker064"/>and particularly useful from a learning point of view, running <a id="_idIndexMarker065"/>and securing containers manually is an unreliable and complex approach. It is too hard to reproduce and automate on production environments and can easily lead to configuration drift among different hosts.</p>
			<p>This is the reason container engines and runtimes were born – to help automate the creation of a container and all the related tasks necessary that culminate with a running container.</p>
			<p>The two concepts are quite different and tend to be often confused, thus requiring a clearance:</p>
			<ul>
				<li>A <strong class="bold">container engine</strong> is a software tool that accepts and processes requests from users to create a container with all the necessary arguments and parameters. It can be <a id="_idIndexMarker066"/>seen as a sort of orchestrator, since it takes care of putting in place all the necessary actions to have the container up and running; yet it is not the effective executor of the container (the container runtime's role). </li>
			</ul>
			<p>Engines usually <a id="_idIndexMarker067"/>solve the following problems:</p>
			<ul>
				<li>Providing a command line and/or REST interface for user interaction</li>
				<li>Pulling and extracting container images (discussed later in this book)</li>
				<li>Managing container mount point and bind-mounting the extracted image</li>
				<li>Handling container metadata</li>
				<li>Interacting with the container runtime</li>
			</ul>
			<p>We have already stated that when a new container is instantiated, a thin R/W layer is created on top of the image; this task is achieved by the container engine, which takes care of presenting a working stack of the merged directories to the container runtime.</p>
			<p>The container <a id="_idIndexMarker068"/>ecosystem offers a wide choice of container engines. <strong class="bold">Docker</strong> is, without <a id="_idIndexMarker069"/>doubt, the most <a id="_idIndexMarker070"/>well-known (despite not being the first) engine <a id="_idIndexMarker071"/>implementation, along <a id="_idIndexMarker072"/>with <strong class="bold">Podman</strong> (the core subject of this book), <strong class="bold">CRI-O</strong>, <strong class="bold">rkt</strong>, and <strong class="bold">LXD</strong>.</p>
			<p>A <strong class="bold">container runtime</strong> is a low-level piece of software used by container engines to run containers <a id="_idIndexMarker073"/>in the host. The container runtime provides the following functionalities:</p>
			<p>Starting the containerized process in the target mount point (usually provided by the <a id="_idIndexMarker074"/>container engine) with a set of custom metadata </p>
			<p>Managing the cgroups' resource allocation</p>
			<p>Managing mandatory access control policies (SELinux and AppArmor) and capabilities</p>
			<p>There are many container runtimes nowadays, and most of them implement the <strong class="bold">OCI runtime spec</strong> reference (<a href="https://github.com/opencontainers/runtime-spec">https://github.com/opencontainers/runtime-spec</a>). This is an industry standard that defines how a runtime should behave and the interface it should implement. </p>
			<p>The most <a id="_idIndexMarker075"/>common <a id="_idIndexMarker076"/>OCI runtime is <strong class="bold">runc</strong>, used by most notable <a id="_idIndexMarker077"/>engines, along <a id="_idIndexMarker078"/>with <a id="_idIndexMarker079"/>other implementations <a id="_idIndexMarker080"/>such as <strong class="bold">crun</strong>, <strong class="bold">kata-containers</strong>, <strong class="bold">railcar</strong>, <strong class="bold">rkt</strong>, and <strong class="bold">gVisor</strong>. </p>
			<p>This modular approach lets container engines swap the container runtime as needed. For example, when Fedora 33 came out, it introduced a new default cgroups hierarchy called cgroups V2. runc did not support cgroups V2 in the beginning, and Podman simply swapped runc with another OCI-compatible container runtime (<strong class="bold">crun</strong>) that was already compliant with the new hierarchy. Now that runc finally supports cgroups V2, Podman will be able to safely use it again with no impact for the end user.</p>
			<p>After introducing container runtimes and engines, it's time for one of the most debated and asked questions during container introductions – the difference between containers and virtual machines.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Containers versus virtual machines</h2>
			<p>Until now, we have talked about <a id="_idIndexMarker081"/>isolation achieved with native OS <a id="_idIndexMarker082"/>features and enhanced with container engines and runtimes. Many users could be tricked into thinking that containers are a form of virtualization.</p>
			<p>There is nothing <a id="_idIndexMarker083"/>farther from the truth; containers are <a id="_idIndexMarker084"/>not virtual machines.</p>
			<p>So, what is the main difference between a container and a virtual machine? Before answering, we can look at the following diagram:</p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/B17908_01_04.jpg" alt="Figure 1.4 – A system call to a kernel from a container&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – A system call to a kernel from a container</p>
			<p>A container, despite being isolated, holds a process that directly interacts with the host kernel using system calls. The process may not be aware of the host namespaces, but it still needs to context-switch into kernel space to perform operations such as I/O access.</p>
			<p>On the other hand, a virtual machine is always executed on top of a <strong class="bold">hypervisor</strong>, running a guest operating <a id="_idIndexMarker085"/>system with its own filesystem, networking, storage (usually as image files), and kernel. The hypervisor is software that provides a layer of hardware abstraction and virtualization to the guest OS, enabling a single bare-metal machine running on capable hardware to instantiate many virtual machines. The hardware seen by the guest OS kernel is mostly virtualized hardware, with some exceptions:</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B17908_01_05.jpg" alt="Figure 1.5 – Architecture – virtualization versus containers&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – Architecture – virtualization versus containers</p>
			<p>This means that when a process performs a system call inside a virtual machine, it is always directed to the guest OS kernel.</p>
			<p>To recap, we <a id="_idIndexMarker086"/>can affirm that containers share the same kernel <a id="_idIndexMarker087"/>with the host, while virtual machines have their own guest OS kernel.</p>
			<p>This statement implies a lot of considerations.</p>
			<p>From a security point of view, virtual machines provide better isolation from potential attacks. Anyway, some of the latest CPU-based attacks (Spectre or Meltdown, most notably) could exploit CPU vulnerabilities to access VMs' address spaces.</p>
			<p>Containers have refined the isolation features and can be configured with strict security policies (such as CIS Docker, NIST, HIPAA, and so on) that make them quite hard to exploit.</p>
			<p>From a scalability point of view, containers are faster to spin up than VMs. Running a new container instance is a matter of milliseconds if the image is already available in the host. These fast results are also achieved by the kernel-less nature of the container. Virtual machines must boot a kernel and initramfs, pivot into the root filesystem, run some kind of init (such as <strong class="source-inline">systemd</strong>), and start a variable number of services. </p>
			<p>A VM will usually consume more resources than a container. To spin up a guest OS, we usually need to allocate more RAM, CPU, and storage than the resources needed to start a container.</p>
			<p>Another great differentiator between VMs and containers is the focus on workloads. The best practice for containers is to spin up a container for every specific workload. On the other hand, a VM can run different workloads together.</p>
			<p>Imagine a LAMP or WordPress architecture: on non-production or small production environments, it would <a id="_idIndexMarker088"/>not be strange to have <a id="_idIndexMarker089"/>everything (Apache, PHP, MySQL, and WordPress) installed on the same virtual machine. This design would be split into a multi-container (or multi-tier) architecture, with one container running the frontend (Apache-PHP-WordPress) and one container running the MySQL database. The container running MySQL could access storage volumes to persist the database files. At the same time, it would be easier to scale up/down the frontend containers. </p>
			<p>Now that we understand how containers work and what differentiates them from virtual machines, we can move on to the next big question: why do I need a container?</p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Why do I need a container?</h1>
			<p>This section describes the benefits and the value of containers in modern IT systems, and how containers <a id="_idIndexMarker090"/>can provide benefits for both technology and business. </p>
			<p>The preceding question could be rephrased as, what is the value of adopting containers in production?</p>
			<p>IT has become a fast, market-driven environment where changes are dictated by business and technological <a id="_idIndexMarker091"/>enhancements. When adopting emerging <a id="_idIndexMarker092"/>technologies, companies are always looking to their <strong class="bold">Return of Investment</strong> (<strong class="bold">ROI</strong>) while striving to keep the <strong class="bold">Total Cost of Ownership</strong> (<strong class="bold">TCO</strong>) under reasonable thresholds. This is not always easy to attain.</p>
			<p>This section will try to uncover the most important ones.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>Open source</h2>
			<p>The technologies that power container technology are open source and became open standards widely <a id="_idIndexMarker093"/>adopted by many vendors or communities. Open source software, today adopted by large companies, vendors, and cloud providers, has many advantages, and provides great value for the enterprise. Open source is often associated with high-value and innovative solutions – that's simply the truth!</p>
			<p>First, community-driven projects usually have a great evolutionary boost that helps mature the code and bring new features continuously. Open source software is available to the public and can be inspected and analyzed. This is a great transparency feature that also has an impact on software reliability, both in terms of robustness and security.</p>
			<p>One of the key aspects is that it promotes an evolutionary paradigm where only the best software is adopted, contributed, and supported; container technology is a perfect example of this behavior. </p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Portability</h2>
			<p>We have already stated that containers are a technology that enables users to package and isolate applications <a id="_idIndexMarker094"/>with their entire runtime environment, which means all the files necessary to run. This feature unlocks one key benefit – portability. </p>
			<p>This means that a container image can be pulled and executed on any host that has a container engine running, regardless of the OS distribution underneath. A CentOS or nginx image can be pulled indifferently from a Fedora or Debian Linux distribution running a container engine and executed with the same configuration. </p>
			<p>Again, if we have a fleet of many identical hosts, we can choose to schedule the application instance on one of them (for example, using load metrics to choose the best fit) with the awareness of having the same result when running the container.</p>
			<p>Container portability also reduces vendor lock-ins and provides better interoperability between platforms.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>DevOps facilitators</h2>
			<p>As stated before, containers help solve the old <em class="italic">it works on my machine</em> pattern between development <a id="_idIndexMarker095"/>and operations teams when it comes to deploying applications for production. </p>
			<p>As a smart and easy packaging solution for applications, they meet the developers' need to create self-consistent bundles with all the necessary binaries and configurations to run their workloads seamlessly. As a self-consistent way to isolate processes and guarantee separation of namespaces and resource usage, they are appreciated by operations teams who are no more forced to maintain complex dependencies constraints or segregate every single application inside VMs.</p>
			<p>From this point of view, containers can be seen as facilitators of DevOps best practices, where developers and operators work closer to deploy and manage applications without rigid separations.</p>
			<p>Developers who want to build their own container images are expected to be more aware of the OS layer built into the image and work closely with operations teams to define build templates and automations.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Cloud readiness</h2>
			<p>Containers are built for the cloud, designed with an immutable approach in mind. The immutability pattern clearly states that changes in the infrastructure (be it a single container or <a id="_idIndexMarker096"/>a complex cluster) must be applied by redeploying a modified version and not by patching the current one. This helps to increase a system's predictability and reliability.</p>
			<p>When a new application version must be rolled out, it is built into a new image and a new container is deployed in place of the previous version. Build pipelines can be implemented to manage complex workflows, from application build and image creation, image registry push and tagging, until deployment in the target host. This approach drastically shortens provisioning time while reducing inconsistencies.</p>
			<p>We will see later in this book that dedicated container orchestration solutions such as Kubernetes also provide ways to automate the scheduling patterns of large fleets of hosts and make containerized workloads easy to deploy, monitor, and scale.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>Infrastructure optimization</h2>
			<p>Compared to virtual machines, containers have a lightweight footprint that drives much greater efficiency <a id="_idIndexMarker097"/>in the consumption of compute and memory resources. By providing a way to simplify workload execution, container adoption brings great cost savings. </p>
			<p>IT resources optimization is achieved by reducing the computational cost of applications; if an application server that was running on top of a virtual machine can be containerized and executed on a host along with other containers (with dedicated resource limits and requests), computing resources can be saved and reused.</p>
			<p>Whole infrastructures can be re-modulated with this new paradigm in mind; a bare-metal machine previously configured as a hypervisor can be reallocated as a worker node of a container orchestration system that simply runs more granular containerized applications as containers.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>Microservices </h2>
			<p>Microservice architectures <a id="_idIndexMarker098"/>split applications into multiple services that perform fine-grained functions and are part of the application as a whole. </p>
			<p>Traditional applications have a monolithic approach where all the functions are part of the same instance. The purpose of microservices is to break the monolith into smaller parts that interact independently. </p>
			<p>Monolithic applications fit well into containers, but microservice applications have an ideal match with them.</p>
			<p>Having one container <a id="_idIndexMarker099"/>for every single microservice helps to achieve important benefits, such as the following:</p>
			<ul>
				<li>Independent scalability of microservices</li>
				<li>More defined responsibilities for development teams' cloud access program</li>
				<li>Potential adoption of different technology stacks over the different microservices</li>
				<li>More control over <a id="_idIndexMarker100"/>security aspects (such as public-facing exposed services, mTLS connections, and so on)</li>
			</ul>
			<p>Orchestrating microservices can be a daunting task when dealing with large and articulated architectures. The adoption of orchestration platforms such as <strong class="bold">Kubernetes</strong>, service mesh <a id="_idIndexMarker101"/>solutions <a id="_idIndexMarker102"/>such as <strong class="bold">Istio</strong> or <strong class="bold">Linkerd</strong>, and tracing <a id="_idIndexMarker103"/>tools such as <strong class="bold">Jaeger</strong> and <strong class="bold">Kiali</strong> becomes <a id="_idIndexMarker104"/>crucial to achieving <a id="_idIndexMarker105"/>control over complexity. </p>
			<p>Where do containers come from? Containers' technology is not a new topic in the computer industry, as we <a id="_idIndexMarker106"/>will see in the next paragraphs. It has deep roots in OS history, and we'll discover that it could be even older than us!</p>
			<p>This section rewinds the tape and recaps the most important milestones of containers in OS history, from Unix to GNU/Linux machines. A useful glance in the past to understand how the underlying idea evolved through the years.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>Chroot and Unix v7</h2>
			<p>If we want to create <a id="_idIndexMarker107"/>an events timeline for our travel time in the containers' history, the <a id="_idIndexMarker108"/>first <a id="_idIndexMarker109"/>and older destination is 1979 – the year <a id="_idIndexMarker110"/>of Unix V7. At that time, way back in 1979, an important system call was introduced in the Unix kernel – the <em class="italic">chroot</em> system call. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">A system call (or syscall) is a method used by an application to request something from the OS's kernel.</p>
			<p>This system call allows the application to change the root directory of the running copy of itself and its children, removing <a id="_idIndexMarker111"/>any capability of the running software to escape that jail. This feature allows you to prohibit the running application access to any kind of files or directory outside the given subtree, which was really a game changer for that time.</p>
			<p>After some years, way back in 1982, this system call was then introduced, also in BSD systems.</p>
			<p>Unfortunately, this feature was not built with security in mind, and over the years, OS documentation and <a id="_idIndexMarker112"/>security literature strongly discouraged the use of <em class="italic">chroot</em> jails as a security <a id="_idIndexMarker113"/>mechanism to achieve isolation.</p>
			<p>Chroot was only the first milestone in the journey towards complete process isolation in *nix systems. The next was, from a historic point of view, the introduction of FreeBSD jails. </p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>FreeBSD jails</h2>
			<p>Making some steps forward in our history trip, we jump back (or forward, depending on where we're looking from) to <a id="_idIndexMarker114"/>2000, when the FreeBSD OS approved and released a new concept that extends the old and good <em class="italic">chroot</em> system call – FreeBSD jails.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">FreeBSD is a free and open source Unix-like operating system first released in 1993, born from the <a id="_idIndexMarker115"/>Berkeley Software Distribution, which was originally based on Research Unix.</p>
			<p>As we briefly reported previously, <em class="italic">chroot</em> was a great feature back in the '80s, but the jail it creates can easily be escaped and has many limitations, so it was not adequate for complex scenarios. For that reason, FreeBSD jails were built on top of the <em class="italic">chroot</em> syscall with the goal of extending and enlarging its feature set. </p>
			<p>In a standard <em class="italic">chroot</em> environment, a running process has limitations and isolation only at the filesystem level; all the other stuff, such as running processes, system resources, the networking subsystem, and system users, is shared by the processes inside the <em class="italic">chroot</em> and the host system's processes.</p>
			<p>Looking at FreeBSD jails, its main feature is the virtualization of the networking subsystem, system users, and its processes; as you can imagine, this improves so much the flexibility and the overall security of the solution.</p>
			<p>Let's schematize the four key features of a FreeBSD jail:</p>
			<ul>
				<li><strong class="bold">A directory subtree</strong>: This is what we already saw also for the <em class="italic">chroot</em> jail. Basically, once defined as <a id="_idIndexMarker116"/>a subtree, the running process is limited to that, and it cannot escape from it.</li>
				<li><strong class="bold">An IP address</strong>: This is a great revolution; finally, we can define an independent IP address for our jail and let our running process be isolated even from the host system.</li>
				<li><strong class="bold">A hostname</strong>: Used inside the jail, this is, of course, different from the host system.</li>
				<li><strong class="bold">A command</strong>: This is the running executable and has an option to be run inside the system jail. The executable has a relative path that is self-contained in the jail.</li>
			</ul>
			<p>One plus of this kind <a id="_idIndexMarker117"/>of jail is that every instance has also its own users and root account that has no kind of privileges or permissions over the other jails or the underlying host system.</p>
			<p>Another interesting feature of FreeBSD jails is that we have two ways of installing/creating a jail:</p>
			<ul>
				<li>From binary-reflecting the ones we might install with the underlying OS</li>
				<li>From the source, building from scratch what's needed by the final application</li>
			</ul>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/>Solaris Containers (also known as Solaris Zones)</h2>
			<p>Moving back to our <a id="_idIndexMarker118"/>time machine, we must jump forward only a few years, to 2004 to be exact, to finally meet the first wording we can recognize – Solaris Containers.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Solaris is a proprietary Unix OS born <a id="_idIndexMarker119"/>from SunOS in 1993, originally developed by Sun Microsystems. </p>
			<p>To be honest, Solaris Containers was only a transitory naming of <strong class="bold">Solaris Zones</strong>, a virtualization <a id="_idIndexMarker120"/>technology built-in Solaris OS, with help also from a special filesystem, ZFS, that allows storage snapshots and cloning.</p>
			<p>A <em class="italic">zone</em> is a virtualized application environment, built from the underlying operating system, that allows <a id="_idIndexMarker121"/>complete isolation between the base host system and any other applications running inside other <em class="italic">zones</em>.</p>
			<p>The cool feature that Solaris Zones introduced is the concept of a branded zone. A branded zone is a completely different environment compared to the underlying OS, and can container different binaries, toolkits, or even a different OS!</p>
			<p>Finally, for ensuring isolation, a Solaris zone can have its own networking, its own users, and even its own time zone.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>Linux Containers (LXC)</h2>
			<p>Let's jump forward four years more and meet <strong class="bold">Linux Containers</strong> (<strong class="bold">LXC</strong>). We're in 2008, when Linux's first <a id="_idIndexMarker122"/>complete container management solution was released. </p>
			<p>LXC cannot just be simplified as a manager for one of the first container implementations of Linux containers, because its authors developed a lot of the kernel features that now are also used for other container runtimes in Linux.</p>
			<p>LXC has its own low-level container runtime, and its authors made it with the goal of offering an isolated environment as close as possible to VMs but without the overhead needed for simulating the hardware and running a brand-new kernel instance. LXC achieves this a goal and isolation thanks to the following kernel functionalities:</p>
			<ul>
				<li>Namespaces</li>
				<li>Mandatory access control</li>
				<li>Control groups (also known as cgroups)</li>
			</ul>
			<p>Let's recap the kernel functionalities that we saw earlier in the chapter.</p>
			<h3>Linux namespaces</h3>
			<p>A namespace isolates processes that abstract a global system resource. If a process makes changes to a <a id="_idIndexMarker123"/>system resource in a namespace, these changes are visible only to other processes within the same namespace. The common use of the namespaces feature is to implement containers.</p>
			<h3>Mandatory access control</h3>
			<p>In the Linux <a id="_idIndexMarker124"/>ecosystem, there are several MAC implementations <a id="_idIndexMarker125"/>available; the most well-known <a id="_idIndexMarker126"/>project is <strong class="bold">Security Enhanced Linux</strong> (<strong class="bold">SELinux</strong>), developed by the USA's <strong class="bold">National Security Agency</strong> (<strong class="bold">NSA</strong>).</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">SELinux is a mandatory access control architecture implementation used in Linux operating systems. It provides role-based access control and multi-level security through a labeling mechanism. Every file, device, and directory has an associated label (often described as a security context) that extends the common filesystem's attributes.</p>
			<h3>Control groups</h3>
			<p><strong class="bold">Control groups</strong> (<strong class="bold">cgroups</strong>) is a built-in Linux kernel feature that can help to organize in hierarchical groups <a id="_idIndexMarker127"/>various types of resources, including processes. These resources can then be limited and monitored. The common interface used for interacting with cgroups is a pseudo-filesystem called <strong class="bold">cgroupfs</strong>. This kernel feature is really useful for <a id="_idIndexMarker128"/>tracking and limiting processes' resources, such as memory, CPU, and so on.</p>
			<p>The main and greatest LXC feature coming from these three kernels' functionalities is, for sure, the <em class="italic">unprivileged containers.</em></p>
			<p>Thanks to namespaces, MAC, and cgroups, in fact, LXC can isolate a certain number of UIDs and GIDs, mapping them with the underlying operating system. This ensures that a UID of 0 in the container is (in reality) mapped to a higher UID at the base system host.</p>
			<p>Depending on the privileges and the feature set we want to assign to our container, we can choose from a vast set of pre-built namespace types, such as the following:</p>
			<ul>
				<li>Network: Offering access to network devices, stacks, ports, and so on</li>
				<li>Mount: Offering access to mount points</li>
				<li>PID: Offering access to PIDs</li>
			</ul>
			<p>The next main <a id="_idIndexMarker129"/>evolution from LXC (and, without doubt, the one that triggered the success of container adoption) was certainly Docker.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>Docker</h2>
			<p>After just 5 years, back in 2013, Docker arises in the container landscape, and it rapidly became so popular. But what <a id="_idIndexMarker130"/>features were used back in those days? Well, we can easily discover that one of the first Docker container engines was LXC!</p>
			<p>Just after one year of development, Docker's team introduced <em class="italic">libcontainer</em> and finally replaced the LXC container engine with their own implementation. Docker, similar to its predecessor, LXC, requires a daemon running on the base host system to keep the containers running and working properly.</p>
			<p>One most notable feature (apart from the use of namespaces, MAC, and cgroups) was, for sure, OverlayFS, an overlay filesystem that helps combine multiple filesystems in just one single filesystem.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">OverlayFS is a Linux union filesystem. It can combine multiple mount points into one, creating a single <a id="_idIndexMarker131"/>directory structure that contains all the underlying files and subdirectories from sources.</p>
			<p>At a high level, the Docker team introduced the concept of container images and container registries, which really was the functionality game changer. The registry and image concepts enabled the creation of a whole ecosystem to which every developer, sysadmin, or tech enthusiast could collaborate and contribute with their own custom container images. They also created a special file format for creating brand-new container images (Dockerfile) to easily automate the steps needed for building the container images from scratch.</p>
			<p>Along with Docker, there is another engine/runtime project that caught the interest of the communities – rkt.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>rkt</h2>
			<p>Just a few years after Docker's arise, across 2014 and 2015, the CoreOS company (acquired then by Red Hat) launched <a id="_idIndexMarker132"/>its own implementation of a container engine that has a very particular main feature – it was <strong class="bold">daemon-less</strong>.</p>
			<p>This choice had an important impact: instead of having a central daemon administering a bunch of containers, every container was on its own, like any other standard process we may start on our base host system.</p>
			<p>But the rkt (pronounced <em class="italic">rocket</em>) project became very popular in 2017 when the young <strong class="bold">Cloud Native Computing Foundation</strong> (<strong class="bold">CNCF</strong>), which aims to help and coordinate container and <a id="_idIndexMarker133"/>cloud-related projects, decided to adopt the project under their umbrella, together with another project donated by Docker itself – <em class="italic">containerd</em>.</p>
			<p>In a few words, the Docker team extracted the project's core runtime from its daemon and donated it to the CNCF, which was a great step that motivated and enabled a great community around the topic of containers, as well as helping to develop and improve rising container orchestration tools, such as Kubernetes.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Kubernetes (from the Greek term <strong class="bold">κυβερνήτης</strong>, meaning "helmsman"), also abbreviated as K8s, is an <a id="_idIndexMarker134"/>open source container-orchestration system for simplifying the application deployment and management in a multi-hosts environment. It was released as an open source project by Google, but it is now maintained by the CNCF.</p>
			<p>Even if this book's main topic is Podman, we cannot mention now and in the following chapters the rising need of orchestrating complex projects made of many containers on multi-machine environments; that's the scenario where Kubernetes rose as the ecosystem leader.</p>
			<p>After Red Hat's acquisition of CoreOS, the rkt project was discontinued, but its legacy was not lost and influenced the development of the Podman project. But before introducing the main topic of this book, let's dive into the OCI specifications. </p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>OCI and CRI-O</h2>
			<p>As mentioned earlier, the <em class="italic">extraction</em> of containerd from Docker and the consequent donation to the CNCF motivated the open source community to start working seriously on container engines that could be injected under an orchestration layer, such as Kubernetes.</p>
			<p>On the <a id="_idIndexMarker135"/>same wave, in 2015, Docker, with the help of many other companies (Red Hat, AWS, Google, Microsoft, IBM, and so on), started a governance committee under the umbrella of the Linux Foundation, the <strong class="bold">Open Container Initiative</strong> (<strong class="bold">OCI</strong>).</p>
			<p>Under this initiative, the working team developed the runtime specification (<strong class="bold">runtime spec</strong>) and the image <a id="_idIndexMarker136"/>specification (<strong class="bold">image spec</strong>) for describing how the API and the <a id="_idIndexMarker137"/>architecture for new container engines should be created in the future.</p>
			<p>The same year, the OCI team also released the first implementation of a container runtime adhering to the OCI specifications; the project was named <strong class="source-inline">runc</strong>.</p>
			<p>The OCI defined not only a specification for running standalone containers but also provided the base for linking the Kubernetes layer with the underlying container engine more easily. At the same time, the Kubernetes community released the <strong class="bold">Container Runtime Interface</strong> (<strong class="bold">CRI</strong>), a plugin interface to enable the adoption of <a id="_idIndexMarker138"/>a wide variety of container runtimes.</p>
			<p>That's where CRI-O jumps to 2017; released as an open source project by Red Hat, it was one of the first implementations of the Kubernetes Container Runtime Interface, enabling the use of OCI compatible runtimes. CRI-O represents a lightweight alternative to using Docker, rkt, or any other engines as Kubernetes' runtime.</p>
			<p>As the ecosystem continues to grow, standards and specifications become more and more adopted, leading to a wider container ecosystem. The OCI specifications showed previously were crucial to the development of the runc container runtime, adopted by the Podman project.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Podman</h2>
			<p>We finally arrive at the end of our time travel; we reached 2017 in the previous paragraph and, in <a id="_idIndexMarker139"/>the same year, the first commit of the Podman project was made on GitHub.</p>
			<p>The project's name reveals a lot about its purpose – <em class="italic">PODMAN = POD MANager</em>. We are now ready to look at the basic definition of a <em class="italic">pod</em> in a container's world.</p>
			<p>A pod is the smallest deployable computing unit that can be handled by Kubernetes; it can be made of one or more containers. In the case of multiple containers in the same pod, they are scheduled and run side by side in a shared context.</p>
			<p>Podman manages containers and containers' images, their storage volumes, and pods made of one or multiple containers, and it was built from scratch to adhere to the OCI standards.</p>
			<p>Podman, like its predecessor, rkt, has no central daemon managing the containers but starts them as standard system processes. It also defines a Docker-compatible CLI interface to ease the transition from Docker.</p>
			<p>One of the great features introduced by Podman is <em class="italic">rootless containers</em>. Usually, when we think about Linux <a id="_idIndexMarker140"/>containers, we immediately think about a system administrator that should set up some prerequisites at the OS level to prepare the environment that lets our container get up and running. </p>
			<p>Rootless containers can easily run as a normal user, without requiring root. Using Podman with a non-privileged user will start restricted containers without any privileges, such as the user running it.</p>
			<p>Without a doubt, Podman introduced greater flexibility and is a highly active project whose adoption grows constantly. Every major release brings many new features; for example, the 3.0 release introduced support for Docker Compose, which was a highly requested feature. This is also a good health metric of the community support.</p>
			<p>Let's close the chapter with an overview of the most common container adoption use cases.</p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor041"/>Where are containers used today?</h1>
			<p>This is an open-ended section. The intent is to tell where and how containers are used today in a production environment. This section also introduces the concept of container orchestration <a id="_idIndexMarker141"/>with Kubernetes, the most used open source orchestrator solution, adopted by thousands of companies worldwide. Container adoption is spreading across every enterprise company in every business sector.</p>
			<p>But if we investigate the success stories of companies already using containers or a Kubernetes distribution, we'll discover that containerization and container orchestration are accelerating the project development and delivery, speeding up the creation of new use cases in every kind of industry – from automotive to healthcare. And regardless of the economics, this is really has a great impact on computer technology in general.</p>
			<p>Companies are shifting from the old VM deployment model to a container one for new applications. As we briefly introduced in the previous paragraphs, a container could be easily represented as a new way for packaging applications.</p>
			<p>Taking a step back to the VMs, what was their main purpose? It was creating an isolated environment with a reserved number of resources for a target application to be run.</p>
			<p>With the introduction of containers, the enterprise companies realized that they can better optimize their infrastructure, speeding up the development and the deployment of new services introducing some kind of innovation.</p>
			<p>Looking back (again) to the history of containers' adoption and their usage, we can see that at the beginning, they were used as a packaging method for old-style, monolithic application runtimes, but then once the cloud-native wave rose and concepts such as microservices became popular, containers became the de facto standard for packaging next-generation, cloud-native applications.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Cloud-native computing is a software <a id="_idIndexMarker142"/>development practice to build and deploy scalable applications in public, private, or hybrid clouds.</p>
			<p>On the other hand, containers' format and orchestration tools were influenced by the rise of microservice development and deployment; that's why today we find in Kubernetes a lot of additional services and resources, such as a service mesh and serverless <a id="_idIndexMarker143"/>computing, which are useful in a <strong class="bold">microservice architecture</strong>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Microservice architecture is a practice to create applications based on loosely coupled, fine-grained services, using lightweight protocols.</p>
			<p>From our daily job with customers adopting containers, we can confirm that customers started packaging <a id="_idIndexMarker144"/>only standard applications in containers and orchestrated them with a container orchestrator, such as Kubernetes, but once new development models arrived at the developers' teams, the containers and their orchestrators started to also manage this new type of service more and more:</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B17908_01_06.jpg" alt="Figure 1.6 – Microservice architecture on a real application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6 – Microservice architecture on a real application</p>
			<p>Just to give us a bit more context around the microservice architecture topic, consider the previous picture, where we find a simple web store application built with microservices.</p>
			<p>As we can see, depending on the type of client we're using (mobile phone or web browser), we'll then be able to interact with the three underlying services, all decoupled, communicating with a REST API. One of the great new features is also decoupling <a id="_idIndexMarker145"/>at the data level; every microservice has its own database and data structure, which makes them independent in every phase of development and deployment.</p>
			<p>Now, if we match a container for every microservice shown in the architecture and we also add an orchestrator, such as Kubernetes, we'll find that the solution is almost complete! Thanks to the containers' technology, every service could have its own container base image with just the needed runtimes on board, which ensures a lightweight pre-built package with all the resources needed by the service once started.</p>
			<p>On the other hand, looking at the various automated processes around application development and their maintenance, an architecture based on containers could also be easily fitted on the tools of <strong class="bold">CI/CD</strong> for automating all the needed steps to develop, test, and run an application.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">CI/CD stands for <strong class="bold">continuous integration and continuous delivery/deployment</strong>. These practices <a id="_idIndexMarker146"/>try to fill the gap between development and operation activities, increasing the automation in the process of building, testing, and deployment applications.</p>
			<p>We can say that containers' technology was born to fulfill system administrator needs but ended up being the beloved tool of developers! This technology represented in many companies the conjunction ring between the developers team and the operations one, which enabled and speeded up the adoption of DevOps practices that were previously isolated to increase collaboration between these two teams.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">DevOps is the group of practices that help link software development (Dev) and IT operations (Ops). The goal of DevOps is to <a id="_idIndexMarker147"/>shorten an application's development life cycle and to increase an application's delivery release. </p>
			<p>Even though microservices and containers love to live together, enterprise companies have a lot of applications, software, and solutions that are not based on microservices architecture <a id="_idIndexMarker148"/>but previous monolithic approaches, for example, using clustered application servers! But we don't have to worry too much, as containers and their orchestrators evolved at the same time to support this kind of workload too.</p>
			<p>Containers technology can be considered an evolved application packaging format that can be optimized for containing all the necessary libraries and tools, even complex monolithic applications. Over the years, the base container images evolved to optimize the size and content for creating smaller runtimes, capable of improving the overall management, even for complex monolithic applications.</p>
			<p>If we look at the size of a Red Hat Enterprise Linux container base image in its minimal flavor, we can see that the image is around 30 MB during download and only 84 MB once extracted (through Podman, of course) in the target base system.</p>
			<p>Even the orchestrators adopted internal features and resources for handling monolithic applications, too far from the cloud-native concepts. Kubernetes, for example, introduced in the platform's core some features for ensuring the statefulness of containers, as well as the concepts of persistent storage for saving locally cached data or important stuff for the application.</p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor042"/>Summary</h1>
			<p>In this chapter, we discovered the underlying functionalities of container technology, from process isolation to container runtimes. Then, we looked at the main purposes and advantages of containers against VMs. After that, we started our time machines, looking into container history from 1979 to the current day. Finally, we discovered today's market trends and current container adoption in enterprise companies.</p>
			<p>This chapter provided an introduction to container technology and its history. Podman is very close to Docker in terms of usability and CLI, and the next chapter will cover the differences between the two projects, from an architectural point of view and a user experience point of view.</p>
			<p>After introducing Docker high-level architecture, Podman daemon-less architecture will be described in detail to understand how this container engine can manage containers without the need for a running daemon.</p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/>Further reading</h1>
			<p>For more information on the topics covered in this chapter, please refer to the following:</p>
			<ul>
				<li><em class="italic">The Linux Programming Interface</em>, <em class="italic">Michael Kerrisk</em> (ISBN 978-1-59327-220-3)</li>
				<li><em class="italic">Demystifying namespaces and containers in Linux</em>: <a href="https://opensource.com/article/19/10/namespaces-and-containers-linux">https://opensource.com/article/19/10/namespaces-and-containers-linux</a></li>
				<li><em class="italic">OCI Runtime Specs</em>: <a href="https://github.com/opencontainers/runtime-spec">https://github.com/opencontainers/runtime-spec</a></li>
				<li><em class="italic">OCI Image Specs</em>: <a href="https://github.com/opencontainers/image-spec">https://github.com/opencontainers/image-spec</a></li>
				<li><em class="italic">Container Runtime Interface announcement</em>: <a href="https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/">https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/</a></li>
			</ul>
		</div>
	</body></html>