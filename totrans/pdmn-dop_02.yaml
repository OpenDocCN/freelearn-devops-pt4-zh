- en: '*Chapter 1*: Introduction to Container Technology'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：容器技术简介'
- en: '**Container technology** has old roots in operating system history. For example,
    do you know that part of container technology was born back in the 1970s? Despite
    their simple and intuitive approach, there are many concepts behind containers
    that deserve a deeper analysis to fully grasp and appreciate how they made their
    way in the IT industry.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器技术**在操作系统历史中有着悠久的根基。例如，你知道容器技术的部分内容是在1970年代就诞生了吗？尽管它们的方式简单直观，但容器背后有许多值得深入分析的概念，只有完全理解和欣赏它们，才能明白它们是如何在IT行业中崭露头角的。'
- en: We're going to explore this technology to better understand how it works under
    the hood, the theory behind it, and its basic concepts. Knowing the mechanics
    and the technology behind the tools will let you easily approach and learn the
    whole technology's key concepts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索这项技术，以更好地理解它的工作原理、背后的理论以及基本概念。了解工具背后的机制和技术将使你能够轻松地掌握并学习整个技术的关键概念。
- en: Then, we will also explore container technology's purpose and why it has spread
    to every company today. Do you know that 50% of the world's organizations are
    running half of their application base as containers in production nowadays?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们还将探讨容器技术的目的，以及它为何如今已经在每家公司得到广泛应用。你知道吗，现在世界上50%的组织在生产环境中运行着一半以上的应用程序作为容器？
- en: Let's dive into this great technology!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解这项伟大的技术！
- en: 'In this chapter, we''re going to ask the following questions:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将提出以下问题：
- en: What are containers?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是容器？
- en: Why do I need a container?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我为什么需要容器？
- en: Where do containers come from?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器来自哪里？
- en: Where are containers used today?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天容器在哪里被使用？
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter does not require any technical prerequisites, so feel free to read
    it without worrying about installing or setting up any kind of software on your
    workstation!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不要求任何技术前提，因此可以放心阅读，无需担心在工作站上安装或设置任何软件！
- en: Anyway, if you are new to containers, you will find here many technical concepts
    useful to understand the next chapters. We recommend going through it carefully
    and coming back when needed. Previous knowledge of the Linux operating system
    would be helpful in understanding the technical concepts covered in this book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，如果你是容器的新手，在这里你会发现许多技术概念有助于理解后续章节。我们建议仔细阅读，并在需要时再回来查看。了解Linux操作系统的基础知识有助于理解本书中的技术概念。
- en: Book conventions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本书约定
- en: 'In the following chapters, we will learn many new concepts with practical examples
    that will require active interaction with a Linux shell environment. In the practical
    examples, we will use the following conventions:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将通过实践示例学习许多新概念，这些示例将需要与Linux shell环境进行积极互动。在实践示例中，我们将使用以下约定：
- en: For any shell command that will be anticipated by the `$` character, we will
    use a standard user (not root) for the Linux system.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何以`$`字符开头的shell命令，我们将使用Linux系统的标准用户（非root用户）。
- en: For any shell command that will be anticipated by the `#` character, we will
    use the root user for the Linux system.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何以`#`字符开头的shell命令，我们将使用Linux系统的root用户。
- en: Any output or shell command that would be too long to display in a single line
    for the code block will be interrupted with the `\` character, and then it will
    continue to a new line.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何输出或shell命令，如果代码块中显示的内容太长而无法在一行中显示，将会通过`\`字符中断，并继续到新的一行。
- en: What are containers?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是容器？
- en: This section describes the container technology from the ground up, beginning
    from basic concepts such as processes, filesystems, system calls, the process
    isolation up to container engines, and runtimes. The purpose of this section is
    to describe how containers implement process isolation. We also describe what
    differentiates containers from virtual machines and highlight the best use case
    of both scenarios.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本节从基础概念入手，逐步介绍容器技术，从进程、文件系统、系统调用、进程隔离，到容器引擎和运行时。该节的目的是描述容器如何实现进程隔离。我们还将描述容器与虚拟机的区别，并强调这两种场景的最佳使用案例。
- en: 'Before asking ourselves what a container is, we should answer another question:
    what is a process?'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在问容器是什么之前，我们应该先回答另一个问题：什么是进程？
- en: According to *The Linux Programming Interface*, an enjoyable book by *Michael
    Kerrisk*, a *process* is an instance of an executing program. A program is a file
    holding information necessary to execute the process. A program can be dynamically
    linked to external libraries, or it can be statically linked in the program itself
    (the Go programming language uses this approach by default).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*《Linux编程接口》*（作者：*Michael Kerrisk*）一书，*进程*是一个正在执行的程序的实例。程序是一个包含执行进程所需信息的文件。程序可以动态链接外部库，或者可以在程序本身中静态链接（Go编程语言默认使用这种方式）。
- en: 'This leads us to an important concept: a process is executed in the machine
    CPU and allocates a portion of memory containing program code and variables used
    by the code itself. The process is instantiated in the machine''s user space and
    its execution is orchestrated by the operating system kernel. When a process is
    executed, it needs to access different machine resources such as I/O (disk, network,
    terminals, and so on) or memory. When the process needs to access those resources,
    it performs a system call into the kernel space (for example, to read a disk block
    or send packets via the network interface).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了一个重要概念：进程在机器的CPU中执行，并分配一部分内存，包含程序代码和代码本身使用的变量。进程实例化在机器的用户空间中，其执行由操作系统内核协调。当进程被执行时，它需要访问不同的机器资源，如I/O（磁盘、网络、终端等）或内存。当进程需要访问这些资源时，它会执行系统调用进入内核空间（例如，读取磁盘块或通过网络接口发送数据包）。
- en: The process indirectly interacts with the host disks using a filesystem, a multi-layer
    storage abstraction, that facilitates the write and read access to files and directories.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 进程通过文件系统间接与主机磁盘交互，文件系统是一种多层存储抽象，方便对文件和目录的读写访问。
- en: How many processes usually run in a machine? A lot. They are orchestrated by
    the OS kernel with complex scheduling logics that make the processes behave like
    they are running on a dedicated CPU core, while the same is shared among many
    of them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一台机器通常运行多少个进程？很多。它们由操作系统内核进行调度，通过复杂的调度逻辑使得这些进程像是在独立的CPU核心上运行一样，尽管同一个核心是多个进程共享的。
- en: The same program can instantiate many processes of its kind (for example, multiple
    web server instances running on the same machine). Conflicts, such as many processes
    trying to access the same network port, must be managed accordingly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个程序可以实例化多个相同类型的进程（例如，在同一台机器上运行多个Web服务器实例）。冲突，如多个进程尝试访问相同的网络端口，必须相应地进行管理。
- en: Nothing prevents us from running a different version of the same program on
    the host, assuming that system administrators will have the burden of managing
    potential conflicts of binaries, libraries, and their dependencies. This could
    become a complex task, which is not always easy to solve with common practices.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么可以阻止我们在主机上运行同一个程序的不同版本，假设系统管理员需要承担管理潜在的二进制文件、库及其依赖项的冲突的任务。这可能会变得非常复杂，通常使用常见的实践并不容易解决。
- en: This brief introduction was necessary to set the context.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这段简短的介绍是为了设定背景。
- en: 'Containers are a simple and smart answer to the need of running isolated process
    instances. We can safely affirm that containers are a form of application isolation
    that works on many levels:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是一个简单而聪明的答案，解决了运行隔离进程实例的需求。我们可以安全地断言，容器是一种在多个层面上有效的应用隔离形式：
- en: '**Filesystem isolation**: Containerized processes have a separated filesystem
    view, and their programs are executed from the isolated filesystem itself.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件系统隔离**：容器化进程具有独立的文件系统视图，它们的程序是从隔离的文件系统中执行的。'
- en: '**Process ID isolation**: This is a containerized process run under an independent
    set of **process IDs** (**PIDs**).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程ID隔离**：这是在独立的**进程ID**（**PIDs**）集下运行的容器化进程。'
- en: '**User isolation**: **User IDs** (**UIDs**) and **group IDs** (**GIDs**) are
    isolated to the container. A process'' UID and GID can be different inside a container
    and run with a privileged UID or GID inside the container only.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户隔离**：**用户ID**（**UIDs**）和**组ID**（**GIDs**）是容器内隔离的。一个进程的UID和GID在容器内可能不同，并且只能在容器内部以特权的UID或GID运行。'
- en: '**Network isolation**: This kind of isolation relates to the host network resources,
    such as network devices, IPv4 and IPv6 stacks, routing tables, and firewall rules.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络隔离**：这种隔离与主机网络资源相关，例如网络设备、IPv4和IPv6栈、路由表和防火墙规则。'
- en: '**IPC isolation**: Containers provide isolation for host IPC resources, such
    as POSIX message queues or System V IPC objects.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IPC 隔离**：容器为主机的 IPC 资源提供隔离，例如 POSIX 消息队列或 System V IPC 对象。'
- en: '**Resource usage isolation**: Containers rely on Linux **control groups** (**cgroups**)
    to limit or monitor the usage of certain resources, such as CPU, memory, or disk.
    We will discuss more about cgroups later in this chapter.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源使用隔离**：容器依赖于 Linux **控制组**（**cgroups**）来限制或监控某些资源的使用，如 CPU、内存或磁盘。我们将在本章后面讨论更多关于
    cgroups 的内容。'
- en: 'From an adoption point of view, the main purpose of containers, or at least
    the most common use case, is to run applications in isolated environments. To
    better understand this concept, we can look at the following diagram:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从采纳的角度来看，容器的主要目的是，或者说最常见的用例，是在隔离的环境中运行应用程序。为了更好地理解这个概念，我们可以看一下下面的图示：
- en: '![Figure 1.1 – Native applications versus containerized ones'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.1 – 原生应用与容器化应用对比'
- en: '](img/B17908_01_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17908_01_01.jpg)'
- en: Figure 1.1 – Native applications versus containerized ones
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 原生应用与容器化应用对比
- en: Applications running natively on a system that does not provide containerization
    features share the same binaries and libraries, as well as the same kernel, filesystem,
    network, and users. This could lead to many issues when an updated version of
    an application is deployed, especially conflicting library issues or unsatisfied
    dependencies.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在不提供容器化功能的系统上本地运行的应用程序共享相同的二进制文件和库，以及相同的内核、文件系统、网络和用户。这可能在部署更新版本的应用程序时引发许多问题，尤其是冲突的库问题或未满足的依赖关系。
- en: On other hand, containers offer a consistent layer of isolation for applications
    and their related dependencies that ensures seamless coexistence on the same host.
    A new deployment only consists of the execution of the new containerized version,
    as it will not interact or conflict with the other containers or native applications.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，容器为应用程序及其相关依赖提供了一致的隔离层，确保它们在同一主机上无缝共存。新的部署仅由执行新容器化版本组成，因为它不会与其他容器或原生应用程序互动或冲突。
- en: Linux containers are enabled by different native kernel features, with the most
    important being **Linux namespaces**. Namespaces abstract specific system resources
    (notably, the ones described before, such as network, filesystem mount, users,
    and so on) and make them appear as unique to the isolated process. In this way,
    the process has the illusion of interacting with the host resource, for example,
    the host filesystem, while an alternative and isolated version is being exposed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 容器通过不同的本地内核特性启用，其中最重要的是 **Linux 命名空间**。命名空间抽象了特定的系统资源（特别是前面描述的资源，如网络、文件系统挂载、用户等），并使它们对隔离的进程显得是唯一的。通过这种方式，进程看似在与主机资源交互，例如主机文件系统，实际上暴露的是一个替代的、隔离的版本。
- en: 'Currently, we have a total of eight kinds of namespaces:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有总共八种命名空间：
- en: '**PID namespaces**: These isolate the process ID number in a separate space,
    allowing processes in different PID namespaces to retain the same PID.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PID 命名空间**：这些命名空间将进程 ID 号隔离到一个独立的空间中，允许不同 PID 命名空间中的进程保持相同的 PID。'
- en: '**User namespaces**: These isolate user and group IDs, root directory, keyrings,
    and capabilities. This allows a process to have a privileged UID and GID inside
    the container while simultaneously having unprivileged ones outside the namespace.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户命名空间**：这些命名空间隔离用户和组 ID、根目录、密钥环和权限。这允许一个进程在容器内具有特权的 UID 和 GID，同时在命名空间外部具有非特权的
    UID 和 GID。'
- en: '**UTS namespaces**: These allow the isolation of hostname and NIS domain name.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UTS 命名空间**：这些命名空间允许主机名和 NIS 域名的隔离。'
- en: '**Network namespaces**: These allow isolation of networking system resources,
    such as network devices, IPv4 and IPv6 protocol stacks, routing tables, firewall
    rules, port numbers, and so on. Users can create virtual network devices called
    **veth pairs** to build tunnels between network namespaces.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络命名空间**：这些命名空间允许隔离网络系统资源，如网络设备、IPv4 和 IPv6 协议栈、路由表、防火墙规则、端口号等。用户可以创建名为 **veth
    对** 的虚拟网络设备，在网络命名空间之间构建隧道。'
- en: '**IPC namespaces**: These isolate IPC resources such as System V IPC objects
    and POSIX message queues. Objects created in an IPC namespace can be accessed
    only by the processes that are members of the namespace. Processes use IPC to
    exchange data, events, and messages in a client-server mechanism.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IPC 命名空间**：这些命名空间隔离 IPC 资源，如 System V IPC 对象和 POSIX 消息队列。在 IPC 命名空间中创建的对象只能由命名空间中的进程访问。进程使用
    IPC 在客户端-服务器机制中交换数据、事件和消息。'
- en: '**cgroup namespaces**: These isolate cgroup directories, providing a virtualized
    view of the process''s cgroups.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cgroup 命名空间**：这些命名空间隔离 cgroup 目录，提供进程 cgroup 的虚拟化视图。'
- en: '**Mount namespaces**: These provide isolation of the mount point list that
    is seen by the processes in the namespace.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂载命名空间**：这些命名空间提供了隔离进程在命名空间中看到的挂载点列表。'
- en: '**Time namespaces**: These provide an isolated view of system time, letting
    processes in the namespace run with a time offset against the host time.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间命名空间**：这些命名空间提供了系统时间的隔离视图，允许命名空间中的进程在与主机时间的偏移下运行。'
- en: Now's, let's move on to resource usage.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论资源使用情况。
- en: Resource usage with cgroups
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 cgroups 管理资源
- en: cgroups are a native feature of the Linux kernel whose purpose is to organize
    processes in a hierarchical tree and limit or monitor their resource usage.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: cgroups 是 Linux 内核的本地功能，目的是将进程组织成一个层级树，并限制或监控它们的资源使用。
- en: The kernel cgroups interface, similar to what happens with `/proc`, is exposed
    with a `cgroupfs` pseudo-filesystem. This filesystem is usually mounted under
    `/sys/fs/cgroup` in the host.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 内核的 cgroups 接口，与 `/proc` 的情况类似，通过 `cgroupfs` 伪文件系统暴露出来。这个文件系统通常挂载在主机的 `/sys/fs/cgroup`
    下。
- en: cgroups offer a series of controllers (also called subsystems) that can be used
    for different purposes, such as limiting the CPU time share of a process, memory
    usage, freeze and resume processes, and so on.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: cgroups 提供了一系列控制器（也叫子系统），可用于不同的目的，例如限制进程的 CPU 时间配额、内存使用、冻结和恢复进程等。
- en: The organizational hierarchy of controllers has changed through time, and there
    are currently two versions, V1 and V2\. In cgroups V1, different controllers could
    be mounted against different hierarchies. Instead, cgroups V2 provide a unified
    hierarchy of controllers, with processes residing in the leaf nodes of the tree.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的组织层次结构随着时间的推移发生了变化，目前有两个版本，V1 和 V2。在 cgroups V1 中，不同的控制器可以挂载到不同的层级上。而 cgroups
    V2 提供了一个统一的控制器层级结构，进程位于树的叶节点上。
- en: cgroups are used by containers to limit CPU or memory usage. For example, users
    can limit CPU quota, which means limiting the number of microseconds the container
    can use the CPU over a given period, or limit CPU shares, the weighted proportion
    of CPU cycles for each container.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: cgroups 被容器用来限制 CPU 或内存的使用。例如，用户可以限制 CPU 配额，这意味着限制容器在给定时间段内可以使用的 CPU 微秒数，或者限制
    CPU 配额，容器占用的 CPU 周期的加权比例。
- en: Now that we have illustrated how process isolation works (both for namespaces
    and resources), we can illustrate a few basic examples.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经展示了进程隔离的工作原理（无论是对于命名空间还是资源），接下来我们可以举几个基本示例。
- en: Running isolated processes
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行隔离的进程
- en: A useful fact to know is that GNU/Linux operating systems offer all the features
    necessary to run a container manually. This result can be achieved by working
    with a specific system call (notably `unshare()` and `clone()`) and utilities
    such as the `unshare` command.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 了解一个有用的事实是，GNU/Linux 操作系统提供了运行容器所需的所有功能。这个结果可以通过使用特定的系统调用（特别是 `unshare()` 和
    `clone()`）以及如 `unshare` 命令等工具来实现。
- en: 'For example, to run a process, let''s say `/bin/sh`, in an isolated PID namespace,
    users can rely on the `unshare` command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要在隔离的 PID 命名空间中运行一个进程（比如 `/bin/sh`），用户可以依赖 `unshare` 命令：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The result is the execution of a new shell process in an isolated PID namespace.
    Users can try to monitor the process view and will get an output such as the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是在隔离的 PID 命名空间中执行一个新的 shell 进程。用户可以尝试监控该进程视图，并将获得类似以下的输出：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Interestingly, the shell process of the preceding example is running with PID
    1, which is correct, since it is the very first process running in the new isolated
    namespace.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，前面例子中的 shell 进程正在以 PID 1 运行，这是正确的，因为它是在新的隔离命名空间中运行的第一个进程。
- en: 'Anyway, the PID namespace will be the only one to be abstracted, while all
    the other system resources still remain the original host ones. If we want to
    add more isolation, for example on a network stack, we can add the `--net` flag
    to the previous command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，PID命名空间将是唯一被抽象的命名空间，而所有其他系统资源仍然保持为原主机资源。如果我们希望增加更多的隔离，例如在网络栈上，我们可以向之前的命令添加`--net`标志：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The result is a shell process isolated on both PID and network namespaces.
    Users can inspect the network IP configuration and realize that the host native
    devices are no longer directly seen by the unshared process:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个在PID和网络命名空间上都被隔离的shell进程。用户可以检查网络IP配置，并意识到主机原生设备不再被unshared进程直接看到：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding examples are useful to understand a very important concept: containers
    are strongly related to Linux native features. The OS provided a solid and complete
    interface that helped container runtime development, and the capability to isolate
    namespaces and resources was the key that unlocked containers adoption. The role
    of the container runtime is to abstract the complexity of the underlying isolation
    mechanisms, with the mount point isolation being probably the most crucial of
    them. Therefore, it deserves a better explanation.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例有助于理解一个非常重要的概念：容器与Linux原生特性紧密相关。操作系统提供了一个坚实而完整的接口，帮助容器运行时的开发，而隔离命名空间和资源的能力是开启容器应用的关键。容器运行时的作用是抽象底层隔离机制的复杂性，而挂载点隔离可能是其中最关键的。因此，它值得更详细的解释。
- en: Isolating mounts
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隔离挂载
- en: We have seen so far examples of unsharing that did not impact mount points and
    the filesystem view from the process side. To gain the filesystem isolation that
    prevents binary and library conflicts, users need to create another layer of abstraction
    for the exposed mount points.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的示例是没有影响挂载点和进程端文件系统视图的unsharing。为了获得能够防止二进制文件和库冲突的文件系统隔离，用户需要为暴露的挂载点创建另一个抽象层。
- en: This result is achieved by leveraging mount namespaces and bind mounts. First
    introduced in 2002 with the Linux kernel 2.4.19, mount namespaces isolate the
    list of mount points seen by the process. Each mount namespace exposes a discrete
    list of mount points, thus making processes in different namespaces aware of different
    directory hierarchies.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果是通过利用挂载命名空间和绑定挂载实现的。挂载命名空间最早在2002年随Linux内核2.4.19版本引入，它隔离了进程所看到的挂载点列表。每个挂载命名空间暴露一个独立的挂载点列表，从而使不同命名空间中的进程能够感知到不同的目录层级结构。
- en: With this technique, it is possible to expose to the executing process an alternative
    directory tree that contains all the necessary binaries and libraries of choice.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种技术，可以向执行进程暴露一个包含所有必要的二进制文件和库的替代目录树。
- en: Despite seeming a simple task, the management of a mount namespace is all but
    straightforward and easy to master. For example, users should handle different
    archive versions of directory trees from different distributions, extract them,
    and bind mount on separate namespaces. We will see later that the first approaches
    with containers in Linux followed this approach.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管看似简单，挂载命名空间的管理并非直截了当，也不容易掌握。例如，用户需要处理来自不同发行版的目录树的不同归档版本，提取它们，并在独立的命名空间上进行绑定挂载。我们稍后会看到，Linux中最初的容器方法遵循了这种方法。
- en: The success of containers is also bound to an innovative, multi-layered, copy-on-write
    approach of managing the directory trees that introduced a simple and fast method
    of copying, deploying, and using the tree necessary to run the container – container
    images.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的成功还与一种创新的、多层次的写时复制方法密切相关，该方法用于管理目录树，介绍了一种简单而快速的复制、部署和使用容器所需树的方法——容器镜像。
- en: Container images to the rescue
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器镜像来拯救
- en: We must thank Docker for the introduction of this smart method of storing data
    for containers. Later, images would become an **Open Container Initiative** (**OCI**)
    standard specification ([https://github.com/opencontainers/image-spec](https://github.com/opencontainers/image-spec)).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须感谢Docker引入了这种存储容器数据的智能方法。随后，镜像将成为**开放容器倡议**（**OCI**）标准规范的一部分（[https://github.com/opencontainers/image-spec](https://github.com/opencontainers/image-spec)）。
- en: Images can be seen as a filesystem bundle that is downloaded (pulled) and unpacked
    in the host before running the container for the first time.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像可以被视为一种文件系统捆绑包，它在运行容器之前会被下载（拉取）并解压到主机中。
- en: Images are downloaded from repositories called `quay.io` or `docker.io`) and
    private registries that can be executed in the customer private infrastructure,
    on-premises, or in the cloud.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像从名为`quay.io`或`docker.io`的仓库以及可以在客户私有基础设施、内部部署或云环境中执行的私有注册中心下载。
- en: Images can be built by DevOps teams to fulfill special needs or embed artifacts
    that must be deployed and executed on a host.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像可以由DevOps团队构建，以满足特殊需求或嵌入必须在主机上部署和执行的工件。
- en: During the image build, process developers can inject pre-built artifacts or
    source code that can be compiled in the build container itself. To optimize image
    size, it is possible to create multi-stage builds with a first stage that compiles
    the source code using a base image with the necessary compilers and runtimes,
    and a second stage where the built artifacts are injected into a minimal, lightweight
    image, optimized for fast startup and minimal storage footprint.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在镜像构建过程中，开发人员可以注入预构建的工件或源代码，这些代码可以在构建容器中进行编译。为了优化镜像大小，可以创建多阶段构建，第一阶段使用包含必要编译器和运行时的基础镜像来编译源代码，第二阶段则将构建好的工件注入到一个精简、轻量级的镜像中，优化启动速度和存储占用。
- en: The *recipe* of the build process is defined in a special text file called a
    **Dockerfile**, which defines all the necessary steps to assemble the final image.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程的*配方*定义在一个特殊的文本文件中，称为**Dockerfile**，它定义了组装最终镜像所需的所有步骤。
- en: After building them, users can push their own images on public or private registries
    for later use or complex, orchestrated deployments.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建完成后，用户可以将自己的镜像推送到公共或私有注册中心，供以后使用或进行复杂的编排部署。
- en: 'The following diagram summarizes the build workflow:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表总结了构建工作流：
- en: '![Figure 1.2 – Image build workflow'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2 – 镜像构建工作流'
- en: '](img/B17908_01_02.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17908_01_02.jpg)'
- en: Figure 1.2 – Image build workflow
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – 镜像构建工作流
- en: We will cover the build topic more extensively later in this book.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书后续部分更详细地讨论构建主题。
- en: What makes a container image so special? The smart idea behind images is that
    they can be considered as a packaging technology. When users build their own image
    with all the binaries and dependencies installed in the OS directory tree, they
    are effectively creating a self-consistent object that can be deployed everywhere
    with no further software dependencies. From this point of view, container images
    are an answer to the long-debated sentence, *It works on my machine*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 是什么让容器镜像如此特别？镜像的智能理念在于，它们可以被视为一种打包技术。当用户构建自己的镜像，并在操作系统目录树中安装所有二进制文件和依赖项时，他们实际上是在创建一个自洽的对象，可以在任何地方部署，而无需进一步的软件依赖。从这个角度来看，容器镜像是对长期争论的“*它在我的机器上能运行*”这一说法的答案。
- en: Developer teams love them because they can be certain of the execution environment
    of their applications, and operations teams love them because they simplify the
    deployment process by removing the tedious task of maintaining and updating a
    server's library dependencies.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 开发团队喜欢它们，因为他们可以确保其应用程序的执行环境，而运维团队喜欢它们，因为它们通过消除维护和更新服务器库依赖的繁琐任务简化了部署过程。
- en: Another smart feature of container images is their copy-on-write, multi-layered
    approach. Instead of having a single bulk binary archive, an image is made up
    of many `tar` archives called *blobs* or *layers*. Layers are composed together
    using image metadata and squashed into a single filesystem view. This result can
    be achieved in many ways, but the most common approach today is by using **union
    filesystems**.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像的另一个智能特点是它们的写时复制、多层次方法。镜像不是由单一的大型二进制归档组成，而是由多个名为*blobs*或*layers*的`tar`归档文件组成。各层通过镜像元数据组合在一起，并压缩成一个单一的文件系统视图。这个结果可以通过多种方式实现，但目前最常见的方式是使用**联合文件系统**。
- en: '**OverlayFS** ([https://www.kernel.org/doc/html/latest/filesystems/overlayfs.html](https://www.kernel.org/doc/html/latest/filesystems/overlayfs.html))
    is the most used union filesystem nowadays. It is maintained in the kernel tree,
    despite not being completely POSIX-compliant.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**OverlayFS**（[https://www.kernel.org/doc/html/latest/filesystems/overlayfs.html](https://www.kernel.org/doc/html/latest/filesystems/overlayfs.html)）是目前使用最广泛的联合文件系统。它被维护在内核树中，尽管它并不完全符合POSIX标准。'
- en: According to kernel documentation, *"An overlay filesystem combines two filesystems
    – an 'upper' filesystem and a 'lower' filesystem."* This means that it can combine
    more directory trees and provide a unique, squashed view. The directories are
    the layers and are referred to as `lowerdir` and `upperdir` to respectively define
    the low-level directory and the one stacked on top of it. The unified view is
    called *merged*. It supports up to 128 layers.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 根据内核文档，*"一个覆盖文件系统结合了两个文件系统——一个是'上层'文件系统，另一个是'下层'文件系统。"* 这意味着它可以结合多个目录树，提供一个独特的、压缩的视图。这些目录就是层，分别称为
    `lowerdir` 和 `upperdir`，用于定义低级目录和位于其上层的目录。统一视图被称为 *merged*。它最多支持 128 层。
- en: OverlayFS is not aware of the concept of container image; it is merely used
    as a foundation technology to implement the multi-layered solution used by OCI
    images.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: OverlayFS 并不意识到容器镜像的概念；它仅作为一种基础技术，用于实现 OCI 镜像所使用的多层解决方案。
- en: OCI images also implement the concept of **immutability**. The layers of an
    image are all read-only and cannot be modified. The only way to change something
    in the lower layers is to rebuild the image with appropriate changes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: OCI 镜像也实现了 **不可变性** 的概念。镜像的所有层都是只读的，无法修改。更改下层内容的唯一方法是重新构建镜像并进行适当的修改。
- en: Immutability is an important pillar of the cloud computing approach. It simply
    means that an infrastructure (such as an instance, container, or even complex
    clusters) can only be replaced by a different version and not modified to achieve
    the target deployment. Therefore, we usually do not change anything inside a running
    container (for example, installing packages or updating config files manually),
    even though it could be possible in some contexts. Rather, we replace its base
    image with a new updated version. This also ensures that every copy of the running
    containers stays in sync with others.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性是云计算方法的重要支柱。它意味着基础设施（如实例、容器或甚至复杂的集群）只能通过不同版本替换，而不能修改以实现目标部署。因此，我们通常不会修改正在运行的容器内部的任何内容（例如手动安装软件包或更新配置文件），即使在某些情况下可能是可行的。相反，我们会用新的更新版本替换其基础镜像。这也确保了每个运行中的容器副本与其他副本保持同步。
- en: 'When a container is executed, a new read/write thin layer is created on top
    of the image. This layer is ephemeral, thus any changes on top of it will be lost
    after the container is destroyed:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器执行时，会在镜像上创建一个新的读/写薄层。这个层是短暂的，因此在容器销毁后，所有在其上的更改都会丢失：
- en: '![Figure 1.3 – A container''s layers'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.3 – 容器的层'
- en: '](img/B17908_01_03.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17908_01_03.jpg)'
- en: Figure 1.3 – A container's layers
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 容器的层
- en: 'This leads to another important statement: we do not store anything inside
    containers. Their only purpose is to offer a working and consistent runtime environment
    for our applications. Data must be accessed externally, by using bind mounts inside
    the container itself or network storage (such as **Network File System** (**NFS**),
    **Simple Storage Service** (**S3**), **Internet Small Computer System Interface**
    (**iSCSI**), and so on).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了另一个重要的观点：我们不在容器内部存储任何东西。它们的唯一目的是为我们的应用程序提供一个稳定一致的运行时环境。数据必须通过外部访问，使用容器内部的绑定挂载或网络存储（如
    **网络文件系统** (**NFS**)、**简单存储服务** (**S3**)、**互联网小型计算机系统接口** (**iSCSI**) 等）。
- en: Containers' mount isolation and images layered design provide a consistent immutable
    infrastructure, but more security restrictions are necessary to prevent processes
    with malicious behaviors escape the container sandbox to steal the host's sensitive
    information or use the host to attack other machines. The following subsection
    introduces security considerations to show how container runtimes can limit those
    behaviors.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的挂载隔离和镜像的分层设计提供了一致的、不可变的基础设施，但仍然需要更多的安全限制，以防止具有恶意行为的进程逃离容器沙箱，窃取主机的敏感信息或利用主机攻击其他机器。以下小节介绍了安全性考虑因素，展示容器运行时如何限制这些行为。
- en: Security considerations
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性考虑
- en: 'From a security point of view, there is a hard truth to share: if a process
    is running inside a container, it simply does not mean it is more secure than
    others.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，有一个硬性事实需要分享：如果一个进程正在容器内运行，这并不意味着它比其他进程更安全。
- en: 'A malicious attacker can still make its way through the host filesystem and
    memory resources. To achieve better security isolation, additional features are
    available:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意攻击者仍然能够通过主机的文件系统和内存资源进行攻击。为了实现更好的安全隔离，可以使用以下附加功能：
- en: '**Mandatory access control**: *SELinux* or *AppArmor* can be used to enforce
    container isolation against the parent host. These subsystems, and their related
    command-line utilities, use a policy-based approach to better isolate the running
    processes in terms of filesystem and network access.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强制访问控制**：*SELinux* 或 *AppArmor* 可用于加强容器与宿主机之间的隔离。这些子系统及其相关命令行工具使用基于策略的方法，在文件系统和网络访问方面更好地隔离正在运行的进程。'
- en: '`0`), it is subject to permission checking based on the process credentials
    (its effective UID). Those permissions, or privileges, are called capabilities
    and can be enabled independently, assigning to an unprivileged process limited
    privileged permissions to access specific resources. When running a container,
    we can add or drop capabilities.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`)，它会根据进程凭证（其有效的 UID）进行权限检查。这些权限或特权称为能力，可以独立启用，赋予一个无特权进程有限的特权权限以访问特定资源。在运行容器时，我们可以添加或删除能力。'
- en: '**Secure Computing Mode** (**Seccomp**): This is a native kernel feature that
    can be used to restrict the syscall that a process is able to make from user space
    to kernel space. By identifying the strictly necessary privileges needed by a
    process to run, administrators can apply seccomp profiles to limit the attack
    surface.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全计算模式**（**Seccomp**）：这是一个原生内核特性，可用于限制进程从用户空间到内核空间所能发出的系统调用。通过识别进程运行所需的严格必要权限，管理员可以应用
    seccomp 配置文件来限制攻击面。'
- en: Applying the preceding security features manually is not always easy and immediate,
    as some of them require a shallow learning curve. Instruments that automate and
    simplify (possibly in a declarative way) these security constraints provide a
    high value.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 手动应用前述安全特性并不总是容易和直接的，因为其中一些需要一定的学习曲线。自动化并简化（可能是声明式方式）这些安全约束的工具具有很高的价值。
- en: We will discuss security topics in further detail later in this book.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本书稍后将更详细地讨论安全主题。
- en: Container engines and runtimes
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器引擎和运行时
- en: Despite being feasible and particularly useful from a learning point of view,
    running and securing containers manually is an unreliable and complex approach.
    It is too hard to reproduce and automate on production environments and can easily
    lead to configuration drift among different hosts.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管从学习角度来看，手动运行和保护容器是可行且特别有用的，但这种方法不可靠且复杂。它在生产环境中难以重现和自动化，并且很容易导致不同主机之间的配置漂移。
- en: This is the reason container engines and runtimes were born – to help automate
    the creation of a container and all the related tasks necessary that culminate
    with a running container.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是容器引擎和运行时诞生的原因——它们帮助自动化创建容器以及完成所有与容器运行相关的任务。
- en: 'The two concepts are quite different and tend to be often confused, thus requiring
    a clearance:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个概念是完全不同的，往往容易混淆，因此需要澄清：
- en: A **container engine** is a software tool that accepts and processes requests
    from users to create a container with all the necessary arguments and parameters.
    It can be seen as a sort of orchestrator, since it takes care of putting in place
    all the necessary actions to have the container up and running; yet it is not
    the effective executor of the container (the container runtime's role).
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器引擎** 是一个软件工具，接受并处理来自用户的请求，创建一个包含所有必要参数和参数的容器。它可以被视为一种协调器，因为它负责执行所有必要的操作，使容器能够启动并运行；然而，它并不是容器的实际执行者（容器运行时的角色）。'
- en: 'Engines usually solve the following problems:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎通常解决以下问题：
- en: Providing a command line and/or REST interface for user interaction
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供命令行和/或 REST 接口供用户交互
- en: Pulling and extracting container images (discussed later in this book)
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉取并提取容器镜像（本书稍后会讨论）
- en: Managing container mount point and bind-mounting the extracted image
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理容器挂载点和绑定挂载提取的镜像
- en: Handling container metadata
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理容器元数据
- en: Interacting with the container runtime
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与容器运行时交互
- en: We have already stated that when a new container is instantiated, a thin R/W
    layer is created on top of the image; this task is achieved by the container engine,
    which takes care of presenting a working stack of the merged directories to the
    container runtime.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经指出，当实例化一个新容器时，会在镜像上方创建一个薄的读写层；这个任务由容器引擎完成，它负责向容器运行时呈现合并目录的工作堆栈。
- en: The container ecosystem offers a wide choice of container engines. **Docker**
    is, without doubt, the most well-known (despite not being the first) engine implementation,
    along with **Podman** (the core subject of this book), **CRI-O**, **rkt**, and
    **LXD**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 容器生态系统提供了多种容器引擎选择。**Docker** 毫无疑问是最著名的（尽管不是第一个）引擎实现，还有 **Podman**（本书的核心主题）、**CRI-O**、**rkt**
    和 **LXD** 等。
- en: 'A **container runtime** is a low-level piece of software used by container
    engines to run containers in the host. The container runtime provides the following
    functionalities:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器运行时** 是由容器引擎用于在主机上运行容器的低级软件。容器运行时提供以下功能：'
- en: Starting the containerized process in the target mount point (usually provided
    by the container engine) with a set of custom metadata
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标挂载点（通常由容器引擎提供）启动容器化进程，并设置一组自定义元数据
- en: Managing the cgroups' resource allocation
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 管理 cgroups 的资源分配
- en: Managing mandatory access control policies (SELinux and AppArmor) and capabilities
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 管理强制访问控制策略（SELinux 和 AppArmor）和能力
- en: There are many container runtimes nowadays, and most of them implement the **OCI
    runtime spec** reference ([https://github.com/opencontainers/runtime-spec](https://github.com/opencontainers/runtime-spec)).
    This is an industry standard that defines how a runtime should behave and the
    interface it should implement.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如今有许多容器运行时，它们中的大多数都实现了 **OCI 运行时规范** 参考（[https://github.com/opencontainers/runtime-spec](https://github.com/opencontainers/runtime-spec)）。这是一个行业标准，定义了运行时应该如何行为以及它应实现的接口。
- en: The most common OCI runtime is **runc**, used by most notable engines, along
    with other implementations such as **crun**, **kata-containers**, **railcar**,
    **rkt**, and **gVisor**.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的 OCI 运行时是 **runc**，它被大多数著名引擎使用，还有其他实现，如 **crun**、**kata-containers**、**railcar**、**rkt**
    和 **gVisor**。
- en: This modular approach lets container engines swap the container runtime as needed.
    For example, when Fedora 33 came out, it introduced a new default cgroups hierarchy
    called cgroups V2\. runc did not support cgroups V2 in the beginning, and Podman
    simply swapped runc with another OCI-compatible container runtime (**crun**) that
    was already compliant with the new hierarchy. Now that runc finally supports cgroups
    V2, Podman will be able to safely use it again with no impact for the end user.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模块化方法使得容器引擎可以根据需要更换容器运行时。例如，当 Fedora 33 发布时，它引入了一个新的默认 cgroups 层级，称为 cgroups
    V2。最初，runc 不支持 cgroups V2，而 Podman 只需将 runc 替换为另一个已兼容新层级的 OCI 兼容容器运行时（**crun**）。现在，runc
    终于支持 cgroups V2，Podman 将能够安全地再次使用它，且对最终用户没有任何影响。
- en: After introducing container runtimes and engines, it's time for one of the most
    debated and asked questions during container introductions – the difference between
    containers and virtual machines.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了容器运行时和引擎之后，是时候回答容器入门中最具争议和最常被问到的问题——容器和虚拟机之间的区别。
- en: Containers versus virtual machines
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器与虚拟机
- en: Until now, we have talked about isolation achieved with native OS features and
    enhanced with container engines and runtimes. Many users could be tricked into
    thinking that containers are a form of virtualization.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了通过原生操作系统特性和容器引擎与运行时增强实现的隔离。许多用户可能会被误导，认为容器是一种虚拟化形式。
- en: There is nothing farther from the truth; containers are not virtual machines.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全是误解；容器并不是虚拟机。
- en: 'So, what is the main difference between a container and a virtual machine?
    Before answering, we can look at the following diagram:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，容器和虚拟机之间的主要区别是什么呢？在回答之前，我们可以查看以下图示：
- en: '![Figure 1.4 – A system call to a kernel from a container'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4 – 容器中的系统调用与内核的交互'
- en: '](img/B17908_01_04.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17908_01_04.jpg)'
- en: Figure 1.4 – A system call to a kernel from a container
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 容器中的系统调用与内核的交互
- en: A container, despite being isolated, holds a process that directly interacts
    with the host kernel using system calls. The process may not be aware of the host
    namespaces, but it still needs to context-switch into kernel space to perform
    operations such as I/O access.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管容器是隔离的，但它持有一个直接与主机内核通过系统调用交互的进程。该进程可能不清楚主机的命名空间，但它仍然需要切换到内核空间进行 I/O 访问等操作。
- en: 'On the other hand, a virtual machine is always executed on top of a **hypervisor**,
    running a guest operating system with its own filesystem, networking, storage
    (usually as image files), and kernel. The hypervisor is software that provides
    a layer of hardware abstraction and virtualization to the guest OS, enabling a
    single bare-metal machine running on capable hardware to instantiate many virtual
    machines. The hardware seen by the guest OS kernel is mostly virtualized hardware,
    with some exceptions:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，虚拟机总是运行在**虚拟化管理程序**（hypervisor）上，运行一个具有独立文件系统、网络、存储（通常是镜像文件）和内核的来宾操作系统。虚拟化管理程序是提供硬件抽象和虚拟化的软体，它使得在具备能力的硬件上运行的单一裸机可以实例化多个虚拟机。来宾操作系统内核看到的硬件大多是虚拟化的硬件，尽管有一些例外：
- en: '![Figure 1.5 – Architecture – virtualization versus containers'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.5 – 架构 – 虚拟化与容器'
- en: '](img/B17908_01_05.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17908_01_05.jpg)'
- en: Figure 1.5 – Architecture – virtualization versus containers
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 架构 – 虚拟化与容器
- en: This means that when a process performs a system call inside a virtual machine,
    it is always directed to the guest OS kernel.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当一个进程在虚拟机内执行系统调用时，它总是会被指向来宾操作系统内核。
- en: To recap, we can affirm that containers share the same kernel with the host,
    while virtual machines have their own guest OS kernel.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们可以肯定地说，容器与主机共享相同的内核，而虚拟机则拥有独立的来宾操作系统内核。
- en: This statement implies a lot of considerations.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这一说法暗示了许多考量因素。
- en: From a security point of view, virtual machines provide better isolation from
    potential attacks. Anyway, some of the latest CPU-based attacks (Spectre or Meltdown,
    most notably) could exploit CPU vulnerabilities to access VMs' address spaces.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，虚拟机提供了更好的隔离，以防止潜在的攻击。尽管如此，一些最新的基于 CPU 的攻击（例如 Spectre 或 Meltdown 等）可能会利用
    CPU 漏洞来访问虚拟机的地址空间。
- en: Containers have refined the isolation features and can be configured with strict
    security policies (such as CIS Docker, NIST, HIPAA, and so on) that make them
    quite hard to exploit.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 容器优化了隔离功能，并可以配置严格的安全策略（例如 CIS Docker、NIST、HIPAA 等），使其非常难以被利用。
- en: From a scalability point of view, containers are faster to spin up than VMs.
    Running a new container instance is a matter of milliseconds if the image is already
    available in the host. These fast results are also achieved by the kernel-less
    nature of the container. Virtual machines must boot a kernel and initramfs, pivot
    into the root filesystem, run some kind of init (such as `systemd`), and start
    a variable number of services.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从可扩展性角度来看，容器的启动速度比虚拟机快。如果镜像已经存在于主机中，启动一个新的容器实例只需几毫秒。这些快速的结果也是由于容器没有内核的特性实现的。而虚拟机必须启动内核和
    initramfs，切换到根文件系统，运行某种 init（例如 `systemd`），并启动一定数量的服务。
- en: A VM will usually consume more resources than a container. To spin up a guest
    OS, we usually need to allocate more RAM, CPU, and storage than the resources
    needed to start a container.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机通常会消耗比容器更多的资源。要启动一个来宾操作系统，通常需要分配比启动容器更多的 RAM、CPU 和存储资源。
- en: Another great differentiator between VMs and containers is the focus on workloads.
    The best practice for containers is to spin up a container for every specific
    workload. On the other hand, a VM can run different workloads together.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机与容器之间的另一个重要区别在于对工作负载的关注。容器的最佳实践是为每个特定的工作负载启动一个容器。另一方面，虚拟机可以同时运行多个工作负载。
- en: 'Imagine a LAMP or WordPress architecture: on non-production or small production
    environments, it would not be strange to have everything (Apache, PHP, MySQL,
    and WordPress) installed on the same virtual machine. This design would be split
    into a multi-container (or multi-tier) architecture, with one container running
    the frontend (Apache-PHP-WordPress) and one container running the MySQL database.
    The container running MySQL could access storage volumes to persist the database
    files. At the same time, it would be easier to scale up/down the frontend containers.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个 LAMP 或 WordPress 架构：在非生产环境或小规模生产环境中，将所有组件（Apache、PHP、MySQL 和 WordPress）安装在同一个虚拟机上并不罕见。这个设计可以拆分为一个多容器（或多层）架构，其中一个容器运行前端（Apache-PHP-WordPress），另一个容器运行
    MySQL 数据库。运行 MySQL 的容器可以访问存储卷来持久化数据库文件。同时，扩展前端容器的规模也会更加容易。
- en: 'Now that we understand how containers work and what differentiates them from
    virtual machines, we can move on to the next big question: why do I need a container?'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了容器是如何工作的，以及它们与虚拟机的区别，我们可以进入下一个重要问题：我为什么需要一个容器？
- en: Why do I need a container?
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我为什么需要一个容器？
- en: This section describes the benefits and the value of containers in modern IT
    systems, and how containers can provide benefits for both technology and business.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了容器在现代 IT 系统中的好处和价值，以及容器如何为技术和业务带来好处。
- en: The preceding question could be rephrased as, what is the value of adopting
    containers in production?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 上述问题可以重新表述为：在生产环境中采用容器的价值是什么？
- en: IT has become a fast, market-driven environment where changes are dictated by
    business and technological enhancements. When adopting emerging technologies,
    companies are always looking to their **Return of Investment** (**ROI**) while
    striving to keep the **Total Cost of Ownership** (**TCO**) under reasonable thresholds.
    This is not always easy to attain.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: IT 已经成为一个快速变化的市场驱动环境，其中变化由商业需求和技术提升所决定。在采用新兴技术时，企业总是关注其**投资回报率**（**ROI**），同时力求将**总拥有成本**（**TCO**）控制在合理的范围内。这并不总是容易实现的。
- en: This section will try to uncover the most important ones.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将尝试揭示最重要的几点。
- en: Open source
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开源
- en: The technologies that power container technology are open source and became
    open standards widely adopted by many vendors or communities. Open source software,
    today adopted by large companies, vendors, and cloud providers, has many advantages,
    and provides great value for the enterprise. Open source is often associated with
    high-value and innovative solutions – that's simply the truth!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 支撑容器技术的技术是开源的，并已成为许多厂商或社区广泛采用的开放标准。如今，大公司、厂商和云服务提供商都采用了开源软件，开源软件具有许多优点，并为企业提供了巨大的价值。开源软件通常与高价值和创新解决方案相关联——这就是事实！
- en: First, community-driven projects usually have a great evolutionary boost that
    helps mature the code and bring new features continuously. Open source software
    is available to the public and can be inspected and analyzed. This is a great
    transparency feature that also has an impact on software reliability, both in
    terms of robustness and security.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，社区驱动的项目通常具有很大的演进动力，这有助于代码的成熟并不断带来新功能。开源软件对公众开放，且可以被检查和分析。这是一个极好的透明性特性，且对软件的可靠性产生影响，无论是在稳健性还是安全性方面。
- en: One of the key aspects is that it promotes an evolutionary paradigm where only
    the best software is adopted, contributed, and supported; container technology
    is a perfect example of this behavior.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个关键方面是，它推动了一个进化模式，即只有最优秀的软件才会被采用、贡献和支持；容器技术是这一行为的完美例证。
- en: Portability
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可移植性
- en: We have already stated that containers are a technology that enables users to
    package and isolate applications with their entire runtime environment, which
    means all the files necessary to run. This feature unlocks one key benefit – portability.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经指出，容器是一种技术，它使用户能够将应用程序及其整个运行时环境打包并隔离开来，这意味着运行所需的所有文件。这个特性解锁了一个关键的好处——可移植性。
- en: This means that a container image can be pulled and executed on any host that
    has a container engine running, regardless of the OS distribution underneath.
    A CentOS or nginx image can be pulled indifferently from a Fedora or Debian Linux
    distribution running a container engine and executed with the same configuration.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着容器镜像可以在任何运行容器引擎的主机上拉取并执行，而不管其底层操作系统的分发版本。无论是从运行容器引擎的 Fedora 还是 Debian Linux
    分发版中，CentOS 或 nginx 镜像都可以被无差别地拉取并以相同的配置执行。
- en: Again, if we have a fleet of many identical hosts, we can choose to schedule
    the application instance on one of them (for example, using load metrics to choose
    the best fit) with the awareness of having the same result when running the container.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果我们拥有许多相同的主机集群，我们可以选择将应用实例调度到其中一台主机上（例如，使用负载指标来选择最合适的主机），并且在运行容器时，可以确保得到相同的结果。
- en: Container portability also reduces vendor lock-ins and provides better interoperability
    between platforms.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的可移植性还减少了厂商锁定，并提高了平台之间的互操作性。
- en: DevOps facilitators
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DevOps 促进者
- en: As stated before, containers help solve the old *it works on my machine* pattern
    between development and operations teams when it comes to deploying applications
    for production.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前所述，容器帮助解决了开发团队和运维团队之间老旧的*在我的机器上能运行*模式，特别是在将应用部署到生产环境时。
- en: As a smart and easy packaging solution for applications, they meet the developers'
    need to create self-consistent bundles with all the necessary binaries and configurations
    to run their workloads seamlessly. As a self-consistent way to isolate processes
    and guarantee separation of namespaces and resource usage, they are appreciated
    by operations teams who are no more forced to maintain complex dependencies constraints
    or segregate every single application inside VMs.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 作为应用程序的智能且简易打包解决方案，容器满足开发人员创建自包含的包的需求，其中包括运行工作负载所需的所有必要二进制文件和配置。作为一种自包含的方式来隔离进程并保证命名空间和资源使用的分离，容器受到运维团队的青睐，因为他们不再需要维护复杂的依赖关系约束或将每个应用程序单独隔离在虚拟机中。
- en: From this point of view, containers can be seen as facilitators of DevOps best
    practices, where developers and operators work closer to deploy and manage applications
    without rigid separations.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，容器可以被视为DevOps最佳实践的促进者，开发人员和运维人员可以更加紧密地合作，部署和管理应用程序，而不再有严格的隔离。
- en: Developers who want to build their own container images are expected to be more
    aware of the OS layer built into the image and work closely with operations teams
    to define build templates and automations.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 想要构建自己容器镜像的开发人员应当更加关注镜像中构建的操作系统层，并与运维团队密切合作，定义构建模板和自动化流程。
- en: Cloud readiness
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云就绪性
- en: Containers are built for the cloud, designed with an immutable approach in mind.
    The immutability pattern clearly states that changes in the infrastructure (be
    it a single container or a complex cluster) must be applied by redeploying a modified
    version and not by patching the current one. This helps to increase a system's
    predictability and reliability.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是为云环境构建的，设计时考虑了不可变的方式。不可变模式明确指出，基础设施（无论是单个容器还是复杂的集群）中的变更必须通过重新部署一个修改过的版本来应用，而不是通过修补当前版本。这有助于提高系统的可预测性和可靠性。
- en: When a new application version must be rolled out, it is built into a new image
    and a new container is deployed in place of the previous version. Build pipelines
    can be implemented to manage complex workflows, from application build and image
    creation, image registry push and tagging, until deployment in the target host.
    This approach drastically shortens provisioning time while reducing inconsistencies.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当必须推出新的应用版本时，它会被构建为一个新的镜像，并部署一个新的容器来替代旧版本。可以实现构建流水线来管理复杂的工作流程，从应用构建和镜像创建，到镜像注册表推送和标签，再到目标主机的部署。这种方式大大缩短了资源配置时间，同时减少了不一致性。
- en: We will see later in this book that dedicated container orchestration solutions
    such as Kubernetes also provide ways to automate the scheduling patterns of large
    fleets of hosts and make containerized workloads easy to deploy, monitor, and
    scale.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 本书后续将看到，像Kubernetes这样的专用容器编排解决方案也提供了自动化调度大量主机的模式，使得容器化的工作负载可以轻松地部署、监控和扩展。
- en: Infrastructure optimization
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础设施优化
- en: Compared to virtual machines, containers have a lightweight footprint that drives
    much greater efficiency in the consumption of compute and memory resources. By
    providing a way to simplify workload execution, container adoption brings great
    cost savings.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与虚拟机相比，容器具有更轻量的占用，极大地提高了计算和内存资源的效率。通过提供简化工作负载执行的方式，容器的应用可以带来显著的成本节省。
- en: IT resources optimization is achieved by reducing the computational cost of
    applications; if an application server that was running on top of a virtual machine
    can be containerized and executed on a host along with other containers (with
    dedicated resource limits and requests), computing resources can be saved and
    reused.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过减少应用的计算成本来实现IT资源优化；如果运行在虚拟机上的应用服务器可以被容器化，并与其他容器一起在主机上运行（具有专用资源限制和请求），计算资源可以节省并重复使用。
- en: Whole infrastructures can be re-modulated with this new paradigm in mind; a
    bare-metal machine previously configured as a hypervisor can be reallocated as
    a worker node of a container orchestration system that simply runs more granular
    containerized applications as containers.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 整个基础设施可以根据这一新范式重新调整；一个之前配置为虚拟化管理程序的裸金属机器可以重新分配为容器编排系统的工作节点，该节点简单地运行更细粒度的容器化应用。
- en: Microservices
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务
- en: Microservice architectures split applications into multiple services that perform
    fine-grained functions and are part of the application as a whole.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构将应用程序拆分为多个执行精细功能的服务，这些服务是应用程序整体的一部分。
- en: Traditional applications have a monolithic approach where all the functions
    are part of the same instance. The purpose of microservices is to break the monolith
    into smaller parts that interact independently.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 传统应用程序采用单体架构，其中所有功能都属于同一个实例。微服务的目的是将单体架构拆分成多个独立交互的小模块。
- en: Monolithic applications fit well into containers, but microservice applications
    have an ideal match with them.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用程序很适合容器，但微服务应用程序与容器的匹配更加理想。
- en: 'Having one container for every single microservice helps to achieve important
    benefits, such as the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个微服务创建一个容器有助于实现一些重要的好处，例如：
- en: Independent scalability of microservices
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的独立可扩展性
- en: More defined responsibilities for development teams' cloud access program
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发团队云访问程序的责任更加明确
- en: Potential adoption of different technology stacks over the different microservices
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同微服务可能采用不同技术栈的潜在可能
- en: More control over security aspects (such as public-facing exposed services,
    mTLS connections, and so on)
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对安全性方面（例如暴露的公共服务、mTLS 连接等）的更多控制
- en: Orchestrating microservices can be a daunting task when dealing with large and
    articulated architectures. The adoption of orchestration platforms such as **Kubernetes**,
    service mesh solutions such as **Istio** or **Linkerd**, and tracing tools such
    as **Jaeger** and **Kiali** becomes crucial to achieving control over complexity.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当面对复杂且庞大的架构时，协调微服务可能是一项艰巨的任务。采用如**Kubernetes**的编排平台、如**Istio**或**Linkerd**的服务网格解决方案，以及如**Jaeger**和**Kiali**的追踪工具，对于控制复杂性至关重要。
- en: Where do containers come from? Containers' technology is not a new topic in
    the computer industry, as we will see in the next paragraphs. It has deep roots
    in OS history, and we'll discover that it could be even older than us!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 容器技术源自哪里？容器技术在计算机行业并不是一个新话题，正如我们将在接下来的段落中看到的，它深深植根于操作系统的历史中，甚至可能比我们还要古老！
- en: This section rewinds the tape and recaps the most important milestones of containers
    in OS history, from Unix to GNU/Linux machines. A useful glance in the past to
    understand how the underlying idea evolved through the years.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将回顾容器在操作系统历史中的重要里程碑，从 Unix 到 GNU/Linux 系统。回顾过去有助于理解底层思想是如何随着时间演变的。
- en: Chroot and Unix v7
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Chroot 和 Unix v7
- en: If we want to create an events timeline for our travel time in the containers'
    history, the first and older destination is 1979 – the year of Unix V7\. At that
    time, way back in 1979, an important system call was introduced in the Unix kernel
    – the *chroot* system call.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想为容器历史中的旅行时间创建一个事件时间线，那么第一个也是最早的时间点是 1979 年——Unix V7 诞生的年份。那时，在 1979 年，Unix
    内核引入了一个重要的系统调用——*chroot* 系统调用。
- en: Important Note
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: A system call (or syscall) is a method used by an application to request something
    from the OS's kernel.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用（或 syscall）是应用程序用来向操作系统内核请求某些操作的一种方法。
- en: This system call allows the application to change the root directory of the
    running copy of itself and its children, removing any capability of the running
    software to escape that jail. This feature allows you to prohibit the running
    application access to any kind of files or directory outside the given subtree,
    which was really a game changer for that time.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统调用允许应用程序更改其运行副本及其子进程的根目录，从而移除运行软件逃脱该监狱的能力。此功能使您可以禁止运行中的应用程序访问给定子树之外的任何文件或目录，这对于当时而言是一次真正的技术变革。
- en: After some years, way back in 1982, this system call was then introduced, also
    in BSD systems.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 数年之后，在 1982 年，这一系统调用也在 BSD 系统中引入。
- en: Unfortunately, this feature was not built with security in mind, and over the
    years, OS documentation and security literature strongly discouraged the use of
    *chroot* jails as a security mechanism to achieve isolation.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这一特性最初并未考虑到安全性，多年来，操作系统文档和安全文献强烈不推荐将*chroot*监狱作为实现隔离的安全机制。
- en: Chroot was only the first milestone in the journey towards complete process
    isolation in *nix systems. The next was, from a historic point of view, the introduction
    of FreeBSD jails.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Chroot 只是朝着在 *nix 系统中实现完全进程隔离迈出的第一个里程碑。从历史角度来看，下一个里程碑是 FreeBSD 监狱的引入。
- en: FreeBSD jails
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FreeBSD 监狱
- en: Making some steps forward in our history trip, we jump back (or forward, depending
    on where we're looking from) to 2000, when the FreeBSD OS approved and released
    a new concept that extends the old and good *chroot* system call – FreeBSD jails.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们历史之旅中迈出一些步伐，我们回到（或者前进，取决于我们从哪里看）2000 年，当时 FreeBSD 操作系统批准并发布了一个新概念，扩展了旧而有效的
    *chroot* 系统调用——FreeBSD 监狱。
- en: Important Note
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: FreeBSD is a free and open source Unix-like operating system first released
    in 1993, born from the Berkeley Software Distribution, which was originally based
    on Research Unix.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 是一个自由开源的类似 Unix 的操作系统，首次发布于 1993 年，源自伯克利软件分发（BSD），最初基于研究 Unix。
- en: As we briefly reported previously, *chroot* was a great feature back in the
    '80s, but the jail it creates can easily be escaped and has many limitations,
    so it was not adequate for complex scenarios. For that reason, FreeBSD jails were
    built on top of the *chroot* syscall with the goal of extending and enlarging
    its feature set.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前简要提到的，*chroot* 在 80 年代是一个很棒的功能，但它创建的监狱很容易被逃逸，并且有很多限制，因此不适用于复杂的场景。为此，FreeBSD
    监狱是在 *chroot* 系统调用的基础上构建的，目的是扩展和增加其功能集。
- en: In a standard *chroot* environment, a running process has limitations and isolation
    only at the filesystem level; all the other stuff, such as running processes,
    system resources, the networking subsystem, and system users, is shared by the
    processes inside the *chroot* and the host system's processes.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准的 *chroot* 环境中，运行进程的限制和隔离仅在文件系统层面；其他所有内容，例如运行的进程、系统资源、网络子系统和系统用户，都被 *chroot*
    内的进程与主机系统的进程共享。
- en: Looking at FreeBSD jails, its main feature is the virtualization of the networking
    subsystem, system users, and its processes; as you can imagine, this improves
    so much the flexibility and the overall security of the solution.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 看 FreeBSD 监狱，它的主要特性是虚拟化网络子系统、系统用户和其进程；正如你可以想象的，这大大提高了该解决方案的灵活性和整体安全性。
- en: 'Let''s schematize the four key features of a FreeBSD jail:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们概括 FreeBSD 监狱的四个关键特性：
- en: '**A directory subtree**: This is what we already saw also for the *chroot*
    jail. Basically, once defined as a subtree, the running process is limited to
    that, and it cannot escape from it.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个目录子树**：这就是我们在 *chroot* 监狱中也看过的内容。基本上，一旦被定义为子树，运行的进程就被限制在该范围内，并且无法逃逸出去。'
- en: '**An IP address**: This is a great revolution; finally, we can define an independent
    IP address for our jail and let our running process be isolated even from the
    host system.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个 IP 地址**：这是一次伟大的革命；终于，我们可以为我们的监狱定义一个独立的 IP 地址，并让我们的运行进程即使与主机系统隔离也能正常工作。'
- en: '**A hostname**: Used inside the jail, this is, of course, different from the
    host system.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个主机名**：在监狱内使用，这当然不同于主机系统的主机名。'
- en: '**A command**: This is the running executable and has an option to be run inside
    the system jail. The executable has a relative path that is self-contained in
    the jail.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个命令**：这是正在运行的可执行文件，并且有一个选项可以在系统监狱内运行。该可执行文件具有相对路径，并且是监狱内自包含的。'
- en: One plus of this kind of jail is that every instance has also its own users
    and root account that has no kind of privileges or permissions over the other
    jails or the underlying host system.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这种监狱的一个优点是，每个实例都有自己的用户和根账户，这些账户在其他监狱或底层主机系统上没有任何权限或权限。
- en: 'Another interesting feature of FreeBSD jails is that we have two ways of installing/creating
    a jail:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 监狱的另一个有趣特性是我们有两种方式来安装/创建监狱：
- en: From binary-reflecting the ones we might install with the underlying OS
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从二进制反射到我们可能会与底层操作系统一起安装的内容
- en: From the source, building from scratch what's needed by the final application
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从源代码开始，构建最终应用所需的内容
- en: Solaris Containers (also known as Solaris Zones)
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Solaris 容器（也称为 Solaris 区域）
- en: Moving back to our time machine, we must jump forward only a few years, to 2004
    to be exact, to finally meet the first wording we can recognize – Solaris Containers.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的时光机，我们必须只跳跃几年，确切地说是到 2004 年，才能最终遇到我们能识别的第一个术语——Solaris 容器。
- en: Important Note
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Solaris is a proprietary Unix OS born from SunOS in 1993, originally developed
    by Sun Microsystems.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Solaris 是一个专有的 Unix 操作系统，源自 1993 年的 SunOS，最初由 Sun Microsystems 开发。
- en: To be honest, Solaris Containers was only a transitory naming of **Solaris Zones**,
    a virtualization technology built-in Solaris OS, with help also from a special
    filesystem, ZFS, that allows storage snapshots and cloning.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，Solaris 容器只不过是 **Solaris 区域**的过渡名称，Solaris 区域是 Solaris 操作系统内置的一种虚拟化技术，同时也借助了一个特殊的文件系统
    ZFS，该文件系统允许存储快照和克隆。
- en: A *zone* is a virtualized application environment, built from the underlying
    operating system, that allows complete isolation between the base host system
    and any other applications running inside other *zones*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*区域*是从底层操作系统构建的虚拟化应用环境，它允许基础主机系统与在其他*区域*内运行的任何应用程序之间进行完全隔离。'
- en: The cool feature that Solaris Zones introduced is the concept of a branded zone.
    A branded zone is a completely different environment compared to the underlying
    OS, and can container different binaries, toolkits, or even a different OS!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Solaris Zones引入的酷炫功能是品牌化区域的概念。品牌化区域与底层操作系统相比是完全不同的环境，可以容纳不同的二进制文件、工具包，甚至是一个不同的操作系统！
- en: Finally, for ensuring isolation, a Solaris zone can have its own networking,
    its own users, and even its own time zone.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了确保隔离，Solaris区域可以拥有自己的网络、用户，甚至自己的时区。
- en: Linux Containers (LXC)
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux 容器（LXC）
- en: Let's jump forward four years more and meet **Linux Containers** (**LXC**).
    We're in 2008, when Linux's first complete container management solution was released.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再向前跳四年，认识一下**Linux 容器**（**LXC**）。我们来到了2008年，那时Linux发布了首个完整的容器管理解决方案。
- en: LXC cannot just be simplified as a manager for one of the first container implementations
    of Linux containers, because its authors developed a lot of the kernel features
    that now are also used for other container runtimes in Linux.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: LXC不能仅仅被简化为Linux容器的最早容器实现之一的管理工具，因为它的作者开发了许多现在也被用于其他Linux容器运行时的内核功能。
- en: 'LXC has its own low-level container runtime, and its authors made it with the
    goal of offering an isolated environment as close as possible to VMs but without
    the overhead needed for simulating the hardware and running a brand-new kernel
    instance. LXC achieves this a goal and isolation thanks to the following kernel
    functionalities:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: LXC有自己的低级容器运行时，它的作者旨在提供一个尽可能接近虚拟机的隔离环境，但无需模拟硬件并运行全新的内核实例所需的开销。LXC通过以下内核功能实现了这一目标和隔离性：
- en: Namespaces
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: Mandatory access control
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制访问控制
- en: Control groups (also known as cgroups)
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制组（也叫cgroups）
- en: Let's recap the kernel functionalities that we saw earlier in the chapter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下本章之前看到的内核功能。
- en: Linux namespaces
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux命名空间
- en: A namespace isolates processes that abstract a global system resource. If a
    process makes changes to a system resource in a namespace, these changes are visible
    only to other processes within the same namespace. The common use of the namespaces
    feature is to implement containers.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间将进程隔离开来，抽象出一个全局系统资源。如果一个进程在命名空间内对系统资源进行更改，这些更改仅对同一命名空间内的其他进程可见。命名空间功能的常见应用是实现容器。
- en: Mandatory access control
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强制访问控制
- en: In the Linux ecosystem, there are several MAC implementations available; the
    most well-known project is **Security Enhanced Linux** (**SELinux**), developed
    by the USA's **National Security Agency** (**NSA**).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux生态系统中，有多种MAC实现可供选择；最著名的项目是**安全增强Linux**（**SELinux**），由美国的**国家安全局**（**NSA**）开发。
- en: Important Note
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: SELinux is a mandatory access control architecture implementation used in Linux
    operating systems. It provides role-based access control and multi-level security
    through a labeling mechanism. Every file, device, and directory has an associated
    label (often described as a security context) that extends the common filesystem's
    attributes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux是一种在Linux操作系统中使用的强制访问控制架构实现。它通过标签机制提供基于角色的访问控制和多级安全性。每个文件、设备和目录都有一个关联的标签（通常称为安全上下文），它扩展了常见文件系统的属性。
- en: Control groups
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制组
- en: '**Control groups** (**cgroups**) is a built-in Linux kernel feature that can
    help to organize in hierarchical groups various types of resources, including
    processes. These resources can then be limited and monitored. The common interface
    used for interacting with cgroups is a pseudo-filesystem called **cgroupfs**.
    This kernel feature is really useful for tracking and limiting processes'' resources,
    such as memory, CPU, and so on.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制组**（**cgroups**）是Linux内核的内建功能，可以帮助以层级方式组织各种资源类型，包括进程。这些资源随后可以被限制和监控。与cgroups交互的常用接口是一个名为**cgroupfs**的伪文件系统。这个内核功能对于跟踪和限制进程的资源（如内存、CPU等）非常有用。'
- en: The main and greatest LXC feature coming from these three kernels' functionalities
    is, for sure, the *unprivileged containers.*
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 来自这三种内核功能的LXC最主要和最强大的特性无疑是*非特权容器*。
- en: Thanks to namespaces, MAC, and cgroups, in fact, LXC can isolate a certain number
    of UIDs and GIDs, mapping them with the underlying operating system. This ensures
    that a UID of 0 in the container is (in reality) mapped to a higher UID at the
    base system host.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于命名空间、MAC 和 cgroups，实际上，LXC 可以隔离一定数量的 UID 和 GID，并将它们映射到底层操作系统。这确保了容器中的 UID
    0（实际上）会映射到主机系统上的更高 UID。
- en: 'Depending on the privileges and the feature set we want to assign to our container,
    we can choose from a vast set of pre-built namespace types, such as the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们希望为容器分配的权限和功能集，我们可以从大量预构建的命名空间类型中选择，例如以下几种：
- en: 'Network: Offering access to network devices, stacks, ports, and so on'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络：提供对网络设备、栈、端口等的访问
- en: 'Mount: Offering access to mount points'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载：提供对挂载点的访问
- en: 'PID: Offering access to PIDs'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PID：提供对 PID 的访问
- en: The next main evolution from LXC (and, without doubt, the one that triggered
    the success of container adoption) was certainly Docker.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: LXC 的下一次主要演进（毫无疑问，也是触发容器采用成功的关键因素）无疑就是 Docker。
- en: Docker
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker
- en: After just 5 years, back in 2013, Docker arises in the container landscape,
    and it rapidly became so popular. But what features were used back in those days?
    Well, we can easily discover that one of the first Docker container engines was
    LXC!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅五年后，在 2013 年，Docker 在容器领域崭露头角，并迅速变得非常流行。那么，那时使用了哪些特性呢？我们很容易发现，最早的 Docker 容器引擎之一就是
    LXC！
- en: Just after one year of development, Docker's team introduced *libcontainer*
    and finally replaced the LXC container engine with their own implementation. Docker,
    similar to its predecessor, LXC, requires a daemon running on the base host system
    to keep the containers running and working properly.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一年的开发，Docker 团队推出了 *libcontainer*，并最终用自己的实现替换了 LXC 容器引擎。与其前身 LXC 相似，Docker
    需要在基础主机系统上运行一个守护进程，以保持容器的正常运行。
- en: One most notable feature (apart from the use of namespaces, MAC, and cgroups)
    was, for sure, OverlayFS, an overlay filesystem that helps combine multiple filesystems
    in just one single filesystem.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最显著的特点之一（除了命名空间、MAC 和 cgroups 的使用）无疑是 OverlayFS，一种叠加文件系统，可以帮助将多个文件系统组合成一个单一的文件系统。
- en: Important Note
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: OverlayFS is a Linux union filesystem. It can combine multiple mount points
    into one, creating a single directory structure that contains all the underlying
    files and subdirectories from sources.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: OverlayFS 是一种 Linux 联合文件系统。它可以将多个挂载点合并为一个，创建一个包含所有底层文件和子目录的单一目录结构。
- en: At a high level, the Docker team introduced the concept of container images
    and container registries, which really was the functionality game changer. The
    registry and image concepts enabled the creation of a whole ecosystem to which
    every developer, sysadmin, or tech enthusiast could collaborate and contribute
    with their own custom container images. They also created a special file format
    for creating brand-new container images (Dockerfile) to easily automate the steps
    needed for building the container images from scratch.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，Docker 团队引入了容器镜像和容器注册表的概念，这实际上是功能上的重大变革。注册表和镜像的概念使得创建一个完整的生态系统成为可能，开发者、系统管理员或技术爱好者都可以在这个生态系统中合作，并贡献自己的自定义容器镜像。他们还创建了一种特殊的文件格式（Dockerfile），用于创建全新的容器镜像，从而轻松自动化从零开始构建容器镜像所需的步骤。
- en: Along with Docker, there is another engine/runtime project that caught the interest
    of the communities – rkt.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Docker，还有另一个引擎/运行时项目引起了社区的兴趣——rkt。
- en: rkt
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: rkt
- en: Just a few years after Docker's arise, across 2014 and 2015, the CoreOS company
    (acquired then by Red Hat) launched its own implementation of a container engine
    that has a very particular main feature – it was **daemon-less**.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 出现的几年后，即 2014 和 2015 年，CoreOS 公司（后来被 Red Hat 收购）推出了自己的容器引擎实现，具有一个非常特别的主要特性——它是
    **无守护进程**的。
- en: 'This choice had an important impact: instead of having a central daemon administering
    a bunch of containers, every container was on its own, like any other standard
    process we may start on our base host system.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这一选择产生了重要影响：与其让一个中央守护进程管理一堆容器，不如让每个容器都独立存在，就像我们在基础主机系统上启动的任何其他标准进程一样。
- en: But the rkt (pronounced *rocket*) project became very popular in 2017 when the
    young **Cloud Native Computing Foundation** (**CNCF**), which aims to help and
    coordinate container and cloud-related projects, decided to adopt the project
    under their umbrella, together with another project donated by Docker itself –
    *containerd*.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，rkt（发音为*rocket*）项目在2017年变得非常受欢迎，当时年轻的**云原生计算基金会**（**CNCF**）决定将该项目纳入其支持范围，CNCF的目标是帮助和协调与容器及云相关的项目，同时还将另一个由Docker本身捐赠的项目——*containerd*，也纳入了其支持。
- en: In a few words, the Docker team extracted the project's core runtime from its
    daemon and donated it to the CNCF, which was a great step that motivated and enabled
    a great community around the topic of containers, as well as helping to develop
    and improve rising container orchestration tools, such as Kubernetes.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Docker团队从其守护进程中提取了项目的核心运行时，并将其捐赠给了CNCF，这是一个重要的步骤，激励并推动了围绕容器主题的强大社区的发展，也有助于开发和改进新兴的容器编排工具，如Kubernetes。
- en: Important Note
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Kubernetes (from the Greek term **κυβερνήτης**, meaning "helmsman"), also abbreviated
    as K8s, is an open source container-orchestration system for simplifying the application
    deployment and management in a multi-hosts environment. It was released as an
    open source project by Google, but it is now maintained by the CNCF.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes（来自希腊词**κυβερνήτης**，意为“舵手”），简称K8s，是一个开源容器编排系统，用于简化多主机环境中的应用部署和管理。它由Google发布为开源项目，但现在由CNCF维护。
- en: Even if this book's main topic is Podman, we cannot mention now and in the following
    chapters the rising need of orchestrating complex projects made of many containers
    on multi-machine environments; that's the scenario where Kubernetes rose as the
    ecosystem leader.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 即使本书的主要主题是Podman，我们也不能不提及现在以及接下来的章节中，容器化多机环境下的复杂项目编排需求的不断增长；正是这个场景中，Kubernetes崛起为生态系统的领导者。
- en: After Red Hat's acquisition of CoreOS, the rkt project was discontinued, but
    its legacy was not lost and influenced the development of the Podman project.
    But before introducing the main topic of this book, let's dive into the OCI specifications.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在Red Hat收购CoreOS后，rkt项目被停止，但它的遗产并未丧失，反而影响了Podman项目的发展。在介绍本书的主要主题之前，让我们深入了解OCI规范。
- en: OCI and CRI-O
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OCI 和 CRI-O
- en: As mentioned earlier, the *extraction* of containerd from Docker and the consequent
    donation to the CNCF motivated the open source community to start working seriously
    on container engines that could be injected under an orchestration layer, such
    as Kubernetes.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，从Docker中提取containerd并将其捐赠给CNCF，激励了开源社区开始认真研发可以在如Kubernetes这样的编排层下注入的容器引擎。
- en: On the same wave, in 2015, Docker, with the help of many other companies (Red
    Hat, AWS, Google, Microsoft, IBM, and so on), started a governance committee under
    the umbrella of the Linux Foundation, the **Open Container Initiative** (**OCI**).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，在2015年，Docker在许多其他公司（如Red Hat、AWS、Google、Microsoft、IBM等）的帮助下，在Linux基金会的支持下，启动了治理委员会，即**开放容器倡议**（**OCI**）。
- en: Under this initiative, the working team developed the runtime specification
    (**runtime spec**) and the image specification (**image spec**) for describing
    how the API and the architecture for new container engines should be created in
    the future.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个倡议下，工作团队制定了运行时规范（**runtime spec**）和镜像规范（**image spec**），用于描述未来如何创建新容器引擎的API和架构。
- en: The same year, the OCI team also released the first implementation of a container
    runtime adhering to the OCI specifications; the project was named `runc`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 同年，OCI团队还发布了第一个符合OCI规范的容器运行时实现；该项目被命名为`runc`。
- en: The OCI defined not only a specification for running standalone containers but
    also provided the base for linking the Kubernetes layer with the underlying container
    engine more easily. At the same time, the Kubernetes community released the **Container
    Runtime Interface** (**CRI**), a plugin interface to enable the adoption of a
    wide variety of container runtimes.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: OCI不仅定义了运行独立容器的规范，还为更轻松地将Kubernetes层与底层容器引擎链接提供了基础。同时，Kubernetes社区发布了**容器运行时接口**（**CRI**），这是一种插件接口，旨在支持各种容器运行时的采用。
- en: That's where CRI-O jumps to 2017; released as an open source project by Red
    Hat, it was one of the first implementations of the Kubernetes Container Runtime
    Interface, enabling the use of OCI compatible runtimes. CRI-O represents a lightweight
    alternative to using Docker, rkt, or any other engines as Kubernetes' runtime.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: As the ecosystem continues to grow, standards and specifications become more
    and more adopted, leading to a wider container ecosystem. The OCI specifications
    showed previously were crucial to the development of the runc container runtime,
    adopted by the Podman project.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Podman
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We finally arrive at the end of our time travel; we reached 2017 in the previous
    paragraph and, in the same year, the first commit of the Podman project was made
    on GitHub.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: The project's name reveals a lot about its purpose – *PODMAN = POD MANager*.
    We are now ready to look at the basic definition of a *pod* in a container's world.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: A pod is the smallest deployable computing unit that can be handled by Kubernetes;
    it can be made of one or more containers. In the case of multiple containers in
    the same pod, they are scheduled and run side by side in a shared context.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Podman manages containers and containers' images, their storage volumes, and
    pods made of one or multiple containers, and it was built from scratch to adhere
    to the OCI standards.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Podman, like its predecessor, rkt, has no central daemon managing the containers
    but starts them as standard system processes. It also defines a Docker-compatible
    CLI interface to ease the transition from Docker.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: One of the great features introduced by Podman is *rootless containers*. Usually,
    when we think about Linux containers, we immediately think about a system administrator
    that should set up some prerequisites at the OS level to prepare the environment
    that lets our container get up and running.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Rootless containers can easily run as a normal user, without requiring root.
    Using Podman with a non-privileged user will start restricted containers without
    any privileges, such as the user running it.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Without a doubt, Podman introduced greater flexibility and is a highly active
    project whose adoption grows constantly. Every major release brings many new features;
    for example, the 3.0 release introduced support for Docker Compose, which was
    a highly requested feature. This is also a good health metric of the community
    support.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Let's close the chapter with an overview of the most common container adoption
    use cases.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Where are containers used today?
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is an open-ended section. The intent is to tell where and how containers
    are used today in a production environment. This section also introduces the concept
    of container orchestration with Kubernetes, the most used open source orchestrator
    solution, adopted by thousands of companies worldwide. Container adoption is spreading
    across every enterprise company in every business sector.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: But if we investigate the success stories of companies already using containers
    or a Kubernetes distribution, we'll discover that containerization and container
    orchestration are accelerating the project development and delivery, speeding
    up the creation of new use cases in every kind of industry – from automotive to
    healthcare. And regardless of the economics, this is really has a great impact
    on computer technology in general.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Companies are shifting from the old VM deployment model to a container one for
    new applications. As we briefly introduced in the previous paragraphs, a container
    could be easily represented as a new way for packaging applications.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Taking a step back to the VMs, what was their main purpose? It was creating
    an isolated environment with a reserved number of resources for a target application
    to be run.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of containers, the enterprise companies realized that
    they can better optimize their infrastructure, speeding up the development and
    the deployment of new services introducing some kind of innovation.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Looking back (again) to the history of containers' adoption and their usage,
    we can see that at the beginning, they were used as a packaging method for old-style,
    monolithic application runtimes, but then once the cloud-native wave rose and
    concepts such as microservices became popular, containers became the de facto
    standard for packaging next-generation, cloud-native applications.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-native computing is a software development practice to build and deploy
    scalable applications in public, private, or hybrid clouds.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, containers' format and orchestration tools were influenced
    by the rise of microservice development and deployment; that's why today we find
    in Kubernetes a lot of additional services and resources, such as a service mesh
    and serverless computing, which are useful in a **microservice architecture**.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Microservice architecture is a practice to create applications based on loosely
    coupled, fine-grained services, using lightweight protocols.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'From our daily job with customers adopting containers, we can confirm that
    customers started packaging only standard applications in containers and orchestrated
    them with a container orchestrator, such as Kubernetes, but once new development
    models arrived at the developers'' teams, the containers and their orchestrators
    started to also manage this new type of service more and more:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – Microservice architecture on a real application'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17908_01_06.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.6 – Microservice architecture on a real application
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Just to give us a bit more context around the microservice architecture topic,
    consider the previous picture, where we find a simple web store application built
    with microservices.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, depending on the type of client we're using (mobile phone or
    web browser), we'll then be able to interact with the three underlying services,
    all decoupled, communicating with a REST API. One of the great new features is
    also decoupling at the data level; every microservice has its own database and
    data structure, which makes them independent in every phase of development and
    deployment.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we match a container for every microservice shown in the architecture
    and we also add an orchestrator, such as Kubernetes, we'll find that the solution
    is almost complete! Thanks to the containers' technology, every service could
    have its own container base image with just the needed runtimes on board, which
    ensures a lightweight pre-built package with all the resources needed by the service
    once started.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, looking at the various automated processes around application
    development and their maintenance, an architecture based on containers could also
    be easily fitted on the tools of **CI/CD** for automating all the needed steps
    to develop, test, and run an application.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD stands for **continuous integration and continuous delivery/deployment**.
    These practices try to fill the gap between development and operation activities,
    increasing the automation in the process of building, testing, and deployment
    applications.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: We can say that containers' technology was born to fulfill system administrator
    needs but ended up being the beloved tool of developers! This technology represented
    in many companies the conjunction ring between the developers team and the operations
    one, which enabled and speeded up the adoption of DevOps practices that were previously
    isolated to increase collaboration between these two teams.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: DevOps is the group of practices that help link software development (Dev) and
    IT operations (Ops). The goal of DevOps is to shorten an application's development
    life cycle and to increase an application's delivery release.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Even though microservices and containers love to live together, enterprise companies
    have a lot of applications, software, and solutions that are not based on microservices
    architecture but previous monolithic approaches, for example, using clustered
    application servers! But we don't have to worry too much, as containers and their
    orchestrators evolved at the same time to support this kind of workload too.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Containers technology can be considered an evolved application packaging format
    that can be optimized for containing all the necessary libraries and tools, even
    complex monolithic applications. Over the years, the base container images evolved
    to optimize the size and content for creating smaller runtimes, capable of improving
    the overall management, even for complex monolithic applications.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the size of a Red Hat Enterprise Linux container base image in
    its minimal flavor, we can see that the image is around 30 MB during download
    and only 84 MB once extracted (through Podman, of course) in the target base system.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Even the orchestrators adopted internal features and resources for handling
    monolithic applications, too far from the cloud-native concepts. Kubernetes, for
    example, introduced in the platform's core some features for ensuring the statefulness
    of containers, as well as the concepts of persistent storage for saving locally
    cached data or important stuff for the application.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discovered the underlying functionalities of container technology,
    from process isolation to container runtimes. Then, we looked at the main purposes
    and advantages of containers against VMs. After that, we started our time machines,
    looking into container history from 1979 to the current day. Finally, we discovered
    today's market trends and current container adoption in enterprise companies.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provided an introduction to container technology and its history.
    Podman is very close to Docker in terms of usability and CLI, and the next chapter
    will cover the differences between the two projects, from an architectural point
    of view and a user experience point of view.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: After introducing Docker high-level architecture, Podman daemon-less architecture
    will be described in detail to understand how this container engine can manage
    containers without the need for a running daemon.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information on the topics covered in this chapter, please refer to
    the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '*The Linux Programming Interface*, *Michael Kerrisk* (ISBN 978-1-59327-220-3)'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Demystifying namespaces and containers in Linux*: [https://opensource.com/article/19/10/namespaces-and-containers-linux](https://opensource.com/article/19/10/namespaces-and-containers-linux)'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*OCI Runtime Specs*: [https://github.com/opencontainers/runtime-spec](https://github.com/opencontainers/runtime-spec)'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*OCI Image Specs*: [https://github.com/opencontainers/image-spec](https://github.com/opencontainers/image-spec)'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Container Runtime Interface announcement*: [https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/](https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/)'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
