- en: '*Chapter 2*: Comparing Podman and Docker'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned from the previous chapter, container technology is not as new
    as we may think and therefore its implementation and architecture has been influenced
    over the years to reach its current status.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll go through a bit of the history and the main architecture
    of Docker and Podman container engines, completing the picture with a side-by-side
    comparison to let readers with some Docker experience easily get on board and
    learn the main differences before going into a deep exploration of Podman.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t have much experience with Docker, you can easily jump to the next
    chapter and return to this one once you feel it is time to learn the differences
    between Podman and Docker container engines.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker container daemon architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Podman daemonless architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main differences between Docker and Podman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter does not require any technical prerequisites; feel free to read
    it without worrying too much about installing or setting up any kind of software
    on your workstation!
  prefs: []
  type: TYPE_NORMAL
- en: If you want to replicate some of the examples that will be described in this
    chapter, you’ll need to install and configure Podman and Docker on your workstation.
    As we described before, you can easily jump to the next chapter and come back
    to this one once you feel it’s time to learn the differences between Podman and
    Docker container engines.
  prefs: []
  type: TYPE_NORMAL
- en: Please consider that in the next chapter, you’ll be introduced to Podman’s installation
    and configuration, so you’ll be soon able to replicate any example you’ll see
    in this chapter and in the following ones.
  prefs: []
  type: TYPE_NORMAL
- en: Docker container daemon architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers are a simple and smart answer to the need to run isolated process
    instances. We can safely affirm that containers are a form of application isolation
    that works at many levels, such as filesystem, network, resource usage, process,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in [*Chapter 1*](B17908_01_epub.xhtml#_idTextAnchor015), *Introduction
    to Container Technology*, in the *Containers versus virtual machines* section,
    containers also differ from virtual machines because containers share the same
    kernel with the host, while virtual machines have their own guest OS kernel. From
    a security point of view, virtual machines provide better isolation from potential
    attacks, but a virtual machine will usually consume more resources than a container.
    To spin up a guest OS, we usually need to allocate more RAM, CPU, and storage
    than the resources needed to start a container.
  prefs: []
  type: TYPE_NORMAL
- en: Back in 2013, the Docker container engine appeared in the container landscape,
    and it rapidly became very popular.
  prefs: []
  type: TYPE_NORMAL
- en: As we explained before, a container engine is a software tool that accepts and
    processes requests from users to create a container; it can be seen as a sort
    of orchestrator. On the other hand, a container runtime is a lower-level piece
    of software used by container engines to run containers in the host, managing
    isolation, storage, networking, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In the early stages, the Docker container engine used LXC as a container runtime
    but then replaced it after a while with their own implementation, *libcontainer*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker container engine consists of three fundamental pillars:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker daemon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These three pillars are represented in the following architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Docker architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17908_02_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – Docker architecture
  prefs: []
  type: TYPE_NORMAL
- en: Once a Docker daemon is running, as shown in the preceding diagram, you can
    interact with it through a Docker client or a remote API. The Docker daemon is
    responsible for many local container activities as well as interacting with external
    registries to pull or push container images.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker daemon is the most critical piece of the architecture, and it should
    always be up and running, otherwise your beloved containers will not survive for
    long! Let’s see its details in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker daemon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A daemon is a process that runs in the background; it supervises the system
    or provides functionality to other processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker daemon is the background process that is responsible for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Listening for Docker API requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling, managing, and checking for running containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Docker images, networks, and storage volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with external/remote container image registries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these actions should be instructed to the daemon through a client or by
    calling its API, but let’s see how to communicate with it.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the Docker daemon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Docker daemon can be contacted through the socket of a process, usually
    available in the filesystem of the host machine: `/var/run/docker.sock`.'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the Linux distribution of your choice, you may need to set the
    right permission for your non-root users to be able to interact with the Docker
    daemon or simply add your non-privileged users to the `docker` group.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following command, these are the permissions set for
    the Docker daemon in a Fedora 34 operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There is no other kind of security or authentication for a Docker daemon enabled
    by default, so be careful not to publicly expose the daemon to untrusted networks.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker REST API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once a Docker daemon is up and running, you can communicate through a client
    or directly through the REST API. Through the Docker API, you can do every kind
    of activity you can perform through the command-line tool, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: List containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspect a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get container logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Export a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start or stop a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kill a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rename a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pause a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list goes on. Looking at one of these APIs, we can easily discover how they
    work and what the sample output returned by the daemon is.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following command, we are going to use the Linux command line tool `curl`
    for making an HTTP request to get details about any container image already stored
    in the daemon’s local cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding command, the output is in JSON format, very
    detailed with multiple metadata information, from container image name to its
    size. In this example, we pre-fetched a **RHEL Universal Base Image** version
    7 in its minimal flavour that is only 80 MB!
  prefs: []
  type: TYPE_NORMAL
- en: Of course, APIs are not made for human consumption or interaction; they fit
    well with machine-to-machine interaction and so they are commonly used for software
    integration. For this reason, let’s now explore how the command-line client works
    and which options are available.
  prefs: []
  type: TYPE_NORMAL
- en: Docker client commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Docker daemon has its own companion that instructs and configures it – a
    command-line client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker command-line client has more than 30 commands with respective options
    that will enable any system administrator or Docker user to instruct and control
    the daemon and its containers. The following is an overview of the most common
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`build`: Build an image from a Dockerfile'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cp`: Copy files/folders between a container and the local filesystem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exec`: Run a command in a running container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`images`: List images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inspect`: Return low-level information on Docker objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kill`: Kill one or more running containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`load`: Load an image from a TAR archive or stdin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`login`: Log in to a Docker registry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logs`: Fetch the logs of a container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ps`: List running containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pull`: Pull an image or a repository from a registry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`push`: Push an image or a repository to a registry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restart`: Restart one or more containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rm`: Remove one or more containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rmi`: Remove one or more images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run`: Run a command in a new container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`save`: Save one or more images to a TAR archive (streamed to stdout by default)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start`: Start one or more stopped containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stop`: Stop one or more running containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tag`: Create a `TARGET_IMAGE` tag that refers to `SOURCE_IMAGE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list goes on. As you can see from this subset, there are many commands available
    for managing the container images and the running containers, even exporting a
    container image or building a new one.
  prefs: []
  type: TYPE_NORMAL
- en: Once you launch the Docker client with one of these commands and its respective
    options, the client will contact the Docker daemon, where it’ll instruct it in
    what is needed, and which action must be performed. Again, the daemon here is
    the key element of the architecture and it needs to be up and running, so ensure
    this before trying to use the Docker client as well as any of its REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Docker images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Docker image is a format introduced by Docker for managing binary data and
    metadata as a template for container creation. Docker images are packages for
    shipping and transferring runtimes, libraries, and all the stuff needed for a
    given process to be up and running.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in [*Chapter 1*](B17908_01_epub.xhtml#_idTextAnchor015), *Introduction
    to Container Technology*, in the *Where do containers come from?* section, the
    creation of this format was really a game changer and significantly different
    from the various other container technologies that arose in the past.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from version 1.12, Docker started adopting an image specification that
    has over the years evolved into the current version that adheres to the **OCI
    Image Format Specification**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first Docker Image Specification included many concepts and fields that
    are now part of the OCI Image Format Specification, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A list of layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creation date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration parameters for use within a container runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Docker image’s content (binaries, libraries, filesystem data) is organized
    in layers. A layer is just a set of filesystem changes that does not contain any
    environment variable or default arguments for a given command. This data is stored
    in the **Image Manifest** that owns the configuration parameters.
  prefs: []
  type: TYPE_NORMAL
- en: But how are these layers created and then aggregated in a Docker image? The
    answer is not so simple. The layers in a container image are composed together
    using image metadata and merged into a single filesystem view. This result can
    be achieved in many ways, but as anticipated in the previous chapter, the most
    common approach today is by using union filesystems – combining two filesystems
    and providing a unique, *squashed* view. Finally, when a container is executed,
    a new, *read/write* ephemeral layer is created on top of the image, which will
    be lost after the container is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: As we said earlier in this chapter, container images and their distribution
    were the killer feature of Docker containers. So, in the next section, let’s look
    at the key element for container distribution, **Docker registries**.
  prefs: []
  type: TYPE_NORMAL
- en: Docker registries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Docker registry is just a repository of Docker container images that holds
    the metadata and the layers of container images for making them available to several
    Docker daemons.
  prefs: []
  type: TYPE_NORMAL
- en: A Docker daemon acts as a client to a Docker registry through an HTTP API, pushing
    and pulling container images depending on the action that the Docker client instructs.
  prefs: []
  type: TYPE_NORMAL
- en: Using a container registry could really help the use of containers on many independent
    machines that could be configured to ask to a registry some container images if
    they are not present in the Docker daemon local cache. The default registry that
    is preconfigured in Docker daemon settings is **Dockerhub**, a **Software-as-a-Service**
    container registry hosted by Docker company in the cloud. However, Dockerhub is
    not the only registry; many other container registries have appeared in recent
    years.
  prefs: []
  type: TYPE_NORMAL
- en: Almost every company or community working with containers created their own
    container registry with a different web interface. One of the free alternative
    services to Dockerhub is **Quay.io**, a Software-as-a-Service container registry
    hosted by the Red Hat company.
  prefs: []
  type: TYPE_NORMAL
- en: 'One great alternative to cloud services is the on-premises Docker registry,
    which can be created through a container on a machine running the Docker daemon
    with just one command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is not the objective of this book to go through the various Docker options
    and configuration, but if you want to know more about the Docker registry, you
    can refer to the main Docker documentation at [https://docs.docker.com/registry/deploying/](https://docs.docker.com/registry/deploying/).
  prefs: []
  type: TYPE_NORMAL
- en: We have looked at a lot of stuff so far, namely the Docker API, client, daemon,
    images, and finally the registry, but, as we mentioned earlier, it’s all dependent
    on the correct usage of the Docker daemon that should be always healthy and up
    and running. So, let’s explore now what happens in the event that it stops working.
  prefs: []
  type: TYPE_NORMAL
- en: What does a running Docker architecture look like?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Docker daemon is the central key element of the whole Docker architecture.
    We will explore in this section what a Docker daemon and a bunch of running containers
    look like.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will not dive into the steps needed for installing and setting up the Docker
    daemon; instead, we will directly analyze a preconfigured operating system with
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding command, we just verified that the Docker
    daemon is up and running, but it’s not the only container service running on the
    system. The Docker daemon has a companion that we skipped in the previous part
    to keep the description easy to understand: **Containerd**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand the workflow, have a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Running a Docker container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17908_02_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – Running a Docker container
  prefs: []
  type: TYPE_NORMAL
- en: Containerd is the project that decouples the container management (kernel interaction
    included) from the Docker daemon, and it also adheres to the OCI standard using
    `runc` as container runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s check the status of Containerd in our preconfigured operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding console output, the service is up and running
    and it has started three child processes: `/usr/bin/containerd-shim-runc-v2`.
    This matches perfectly what we just saw in *Figure 2.2*!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s check our running containers interacting with the Docker CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the Docker client confirms that we have three running containers
    on our system, all started through the `runc` container runtime, managed by the
    Containerd system service and configured through a Docker daemon.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have introduced this new element, Containerd, let’s look at it in
    more depth in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Containerd architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Containerd architecture is composed of several components that are organized
    in subsystems. Components that link different subsystems are also referred to
    as modules in the Containerd architecture, as can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Containerd architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17908_02_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Containerd architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'The two main subsystems available are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The bundle service that extracts bundles from disk images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The runtime service that executes the bundles, creating the runtime containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main modules that make the architecture fully functional are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Executor` module, which implements the container runtime that is represented
    in the preceding architecture as the **Runtimes** block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Supervisor` module, which monitors and reports container state that is
    part of the **Containers** block in the preceding architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Snapshot` module, which manages filesystem snapshots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Events` module, which collects and consumes events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Metrics` module, which exports several metrics via the metrics API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The steps needed by Containerd to place a container in a running state are
    too complex to be described in this section, but we can sum them up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Pull metadata and content through a **Distribution Controller**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the **Bundle Controller** to unpack the retrieved data, creating snapshots
    that will compose bundles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the container through the bundle just created through the **Runtime
    Controller**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Containerd data flow diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17908_02_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – Containerd data flow diagram
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have described the key features and design principles of
    the Docker container engine, with its daemon-centric approach. We can now move
    on to analyze the Podman daemonless architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Podman daemonless architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Podman (short for *POD MANager*) is a daemonless container engine that enables
    users to manage containers, images, and their related resources such as storage
    volumes or network resources. First-time users installing Podman soon realize
    that there is no service to start after the installation is complete. No background
    running daemon is required to run containers with Podman!
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, the Podman binary acts both as a **command-line interface**
    (**CLI**) and as a container engine that orchestrates the container runtime execution.
    The following subsections will explore the details of the Podman behavior and
    building blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Podman commands and REST API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Podman CLI provides a growing set of commands. The curated list is available
    at [https://docs.podman.io/en/latest/Commands.html](https://docs.podman.io/en/latest/Commands.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list explores a subset of the most commonly used commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`build`: Build an image from a Containerfile or Dockerfile'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cp`: Copy files/folders between a container and the local filesystem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exec`: Run a command in a running container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`events`: Show Podman events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`generate`: Generate structured data such as Kubernetes YAML or systemd units'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`images`: List local cached images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inspect`: Return low-level information on containers or images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kill`: Kill one or more running containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`load`: Load an image from a container TAR archive or stdin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`login`: Log in to a container registry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logs`: Fetch the logs of a container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pod`: Manage pods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ps`: List running containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pull`: Pull an image or a repository from a registry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`push`: Push an image or a repository to a registry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restart`: Restart one or more containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rm`: Remove one or more containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rmi`: Remove one or more images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run`: Run a command in a new container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`save`: Save one or more images to a TAR archive (streamed to stdout by default)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start`: Start one or more stopped containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stop`: Stop one or more running containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`system`: Manage Podman (disk usage, container migration, REST API services,
    storage management, and pruning)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tag`: Create a `TARGET_IMAGE` tag that refers to `SOURCE_IMAGE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unshare`: Run a command in a modified user namespace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`volume`: Manage container volumes (list, pruning, creation, inspection)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the upcoming chapters of the book, we will cover the preceding commands in
    greater detail and understand how to use them to manage the full container life
    cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Users who have already worked with Docker will immediately spot the same commands
    they used to execute with the Docker CLI. Podman CLI commands are compatible with
    Docker ones to help a smooth transition between the two tools.
  prefs: []
  type: TYPE_NORMAL
- en: Differently from Docker, Podman does not need a running Docker daemon listening
    on a Unix socket to execute the preceding commands. Users can still choose to
    run a Podman service and make it listen to a Unix socket to expose native REST
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'By running the following command, Podman will create a socket endpoint on a
    path of preference and listen to API calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If not provided, the default socket endpoint is `unix://run/podman/podman.sock`
    for rootful services and `unix://run/user/<UID>/podman/podman.sock` for rootless
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, users can then make REST API calls to the socket endpoint. The
    following example queries Podman for the available local images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The Podman project maintains OpenAPI-compliant documentation of available REST
    API calls at [https://docs.podman.io/en/latest/_static/api.html](https://docs.podman.io/en/latest/_static/api.html).
  prefs: []
  type: TYPE_NORMAL
- en: The piped `jq` command in the preceding example is useful to produce a more
    readable JSON-pretty output. We will explore the Podman REST API and systemd socket-based
    activation in greater detail in the post-installation customization section of
    [*Chapter 3*](B17908_03_epub.xhtml#_idTextAnchor068), *Running the First Container*.
    Let’s now describe Podman building blocks in greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: Podman building blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Podman aims to adhere to open standards as much as possible; therefore, most
    of the runtime, build, storage, and networking components rely on community projects
    and standards. The components described in the following list can be seen as the
    main Podman building blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The container life cycle is managed with the **libpod** library, already included
    in the Podman main repository: [https://github.com/containers/podman/tree/main/libpod.](https://github.com/containers/podman/tree/main/libpod'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: The container runtime is based on the OCI specs implemented by OCI-compliant
    runtimes, such as **crun** and **runc**. We will see in this chapter how container
    runtimes work and the main difference between the above-mentioned ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the same time, image management implements the **containers/image** library
    ([https://github.com/containers/image](https://github.com/containers/image)).
    This is a set of Go libraries used both by container engines and container registries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container and image storage is implemented adopting the **containers/storage**
    library ([https://github.com/containers/storage](https://github.com/containers/storage)),
    another Go library to manage filesystem layers, container images, and container
    volumes at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image builds are implemented with Buildah ([https://github.com/containers/buildah](https://github.com/containers/buildah)),
    which is both a binary tool and a library for building OCI images. We will cover
    Buildah later in this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container runtime monitoring and communication with the engine is implemented
    with **Conmon**, a tool for monitoring OCI runtimes, used by both Podman and **CRI-O**
    ([https://github.com/containers/conmon](https://github.com/containers/conmon)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Container networking support is implemented through the Kubernetes `bridge`
    CNI plugin. An extended list of plugins is available in the following repository:
    https://github.com/containernetworking/plugins.'
  prefs: []
  type: TYPE_NORMAL
- en: As stated earlier, Podman orchestrates the container life cycle thanks to the
    libpod library, described in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: The libpod library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Podman core foundations are based on the libpod library, which is also adopted
    by other open source projects such as CRI-O. This library contains all the necessary
    logic to orchestrate the container life cycle and we can safely say that the development
    of this library was the key to the birth of the Podman project as we know it today.
  prefs: []
  type: TYPE_NORMAL
- en: 'The library is written in Go and is thus accessed as a **Go package** and is
    intended to implement all the high-level functionalities of the engine. According
    to the libpod and Podman documentation, its scope includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing container image format, which includes both OCI and Docker images.
    This includes the full image life cycle management, from authenticating and pulling
    from a container registry, and local storage of the image layers and metadata,
    to the building of new images and pushing to remote registries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container life cycle management – from container creation (with all the necessary
    preliminary steps involved) and running the container to all the other runtime
    functionalities such as stop, kill, resume, and delete, process execution on running
    containers, and logging.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing both simple containers and **pods**, which are groups of sandboxed
    containers that share namespaces together (notably UTC, IPC, Network, and recently
    Pid) and are also managed together as a whole.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting **rootless** containers and pods that can be executed by standard
    users with no need for privilege escalation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing container resource isolation. This is achieved at a low level with
    CGroup but Podman users can interact using CLI options during container execution
    to manage memory and CPU reservation or limit read/write rate on a storage device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting a CLI that can be used as a Docker-compatible alternative. Most Podman
    commands are the same as in the Docker CLI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a Docker-compatible REST API with local Unix sockets (not enabled
    by default). Libpod REST APIs provide all the functionalities provided by the
    Podman CLI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lidpod package interacts, at a lower level, with container runtimes, Conmon,
    and packages such as container/storage, container/image, Buildah, and CNI. In
    the next section, we will focus on the container runtime execution.
  prefs: []
  type: TYPE_NORMAL
- en: The runc and crun OCI container runtimes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As illustrated in the previous chapter, a container engine takes care of the
    high-level orchestration of the container life cycle, while the low-level actions
    necessary to create and run the container are delivered by a container runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'An industry standard has emerged in the last few years, with the help of the
    major container environment contributors: the **OCI Runtime Specification**. The
    full specification is available at [https://github.com/opencontainers/runtime-spec](https://github.com/opencontainers/runtime-spec).'
  prefs: []
  type: TYPE_NORMAL
- en: 'From this repository, the *Runtime and Lifecycle* document provides a full
    description of how the container runtime should handle the container creation
    and execution: [https://github.com/opencontainers/runtime-spec/blob/master/runtime.md](https://github.com/opencontainers/runtime-spec/blob/master/runtime.md).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Runc** ([https://github.com/opencontainers/runc](https://github.com/opencontainers/runc))
    is currently the most widely adopted OCI container runtime. Its history leads
    back to 2015, when Docker announced the spin out of all its infrastructure plumbing
    into a dedicated project called runC.'
  prefs: []
  type: TYPE_NORMAL
- en: RunC fully supports Linux containers and OCI runtime specs. The project repository
    includes the **libcontainer** package, which is a Go package for creating containers
    with namespaces, cgroups, capabilities, and filesystem access controls. Libcontainer
    was an independent Docker project before, and when the runC project was created,
    it was moved inside its main repository for the sake of consistence and clarity.
  prefs: []
  type: TYPE_NORMAL
- en: The libcontainer package defines the inner logic and the low-level system interaction
    to bootstrap a container from scratch, from the initial isolation of namespaces
    to the execution as PID 1 of the binary program inside the container itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The runtime recalls the libcontainer library to fulfil the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Consume the container mount point and the container metadata provided by Podman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interact with the kernel to start the container and execute the isolated process
    using the `clone()` and `unshare()` syscalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up CGroup resource reservations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up SELinux Policy, Seccomp, and App Armor rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along with running processes, libcontainer handles the initialization of namespaces
    and file descriptors, the creation of the container rootFS and bind mounts, exporting
    logs from container processes, managing security restrictions with seccomp, SELinux
    and AppArmor, and creating and mapping users and groups
  prefs: []
  type: TYPE_NORMAL
- en: The libcontainer architecture is quite a complex topic for this book and obviously
    needs further investigation to better understand its internals.
  prefs: []
  type: TYPE_NORMAL
- en: For readers interested in viewing the code and understanding Podman internals,
    the container interface that adheres to the OCI runtime specs is defined in the
    [https://github.com/opencontainers/runc/blob/master/libcontainer/container.go](https://github.com/opencontainers/runc/blob/master/libcontainer/container.go)
    source file.
  prefs: []
  type: TYPE_NORMAL
- en: The methods for the Linux OS that implement the interface are defined in [https://github.com/opencontainers/runc/blob/master/libcontainer/container_linux.go](https://github.com/opencontainers/runc/blob/master/libcontainer/container_linux.go).
  prefs: []
  type: TYPE_NORMAL
- en: The low-level execution of `clone()` and `unshare() syscall` to isolate the
    process namespaces is handled by the `nsexec()` function. This is a C function
    embedded in the Go code thanks using **cgo**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of `nsexec()` can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/opencontainers/runc/blob/master/libcontainer/nsenter/nsexec.c](https://github.com/opencontainers/runc/blob/master/libcontainer/nsenter/nsexec.c'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: Along with `runC`, many other container runtimes have been created. An alternative
    runtime we will discuss in this book is `crun` was to provide an improved OCI
    runtime that could leverage the C design approach for a cleaner and lightweight
    runtime. Since they are both OCI runtimes, `runC` and `crun` can be used interchangeably
    by a container engine.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in 2019, the Fedora project made a brave move and chose to release
    Fedora 31 with CGroup V2 as the default ([https://www.redhat.com/sysadmin/fedora-31-control-group-v2](https://www.redhat.com/sysadmin/fedora-31-control-group-v2)).
    At the time of this choice, `runC` was not yet capable of managing containers
    under CGroup V2\.
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, the Podman release for Fedora adopted `crun` as the default runtime
    since it was already capable of managing both CGroup V1 and V2\. This switch was
    almost seamless for end users, who continued to use Podman in the same way with
    the same commands and behaviors. Later, `runC` finally introduced support for
    CGroup V2, from v1.0.0-rc93, and can now be used on newer distributions seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: However, the CGroup topic was not the only differentiator between `runC` and
    `crun`.
  prefs: []
  type: TYPE_NORMAL
- en: '`crun` provides some interesting advantages against `runC`, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`crun` build is approximately 50 times smaller than a `runC` build.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crun` is faster on instrumenting the container than `runC` under the same
    execution conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crun` consumes less than half the memory of `runC`. A smaller memory footprint
    is extremely helpful when dealing with massive container deployments or IoT appliances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crun` can also be used as a library and integrated in other OCI-compliant
    projects. Both `crun` and `runC` provide a CLI but are not meant to be used manually
    by end users, who are supposed to use a container engine such as Podman or Docker
    to manage the container life cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'How easy is it to switch between the two runtimes in Podman? Let’s see the
    following examples. Both examples run a container using the `–runtime` flag to
    provide an OCI runtime binary path. The first one runs the container using `runC`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The second line runs the same container with the `crun` binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The examples assume that both runtimes are already installed in the system.
  prefs: []
  type: TYPE_NORMAL
- en: Both `crun` and `runC` support **eBPF** and **CRIU**.
  prefs: []
  type: TYPE_NORMAL
- en: '**eBPF** stands for **Extended Berkeley Packet Filter** and is a kernel-based
    technology that allows the execution of user-defined programs in the Linux kernel
    to add extra capabilities to the system without the need to recompile the kernel
    or load extra modules. All eBPF programs are executed inside a sandbox virtual
    machine and their execution is secure by design. Today, eBPF is gaining momentum
    and attracting industry interest, leading to wide adoption in different use cases,
    most notably networking, security, observability, and tracing.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Checkpoint Restore in Userspace** (**CRIU**) is a piece of software that
    enables users to freeze a running container and save its state to disk for further
    resume. Data structures saved in memory are dumped and restored accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: Another important architectural component used by Podman is Conmon, a tool for
    monitoring container runtime status. Let’s investigate this in more detail in
    the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Conmon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We may still have some questions about runtime execution.
  prefs: []
  type: TYPE_NORMAL
- en: How do Podman (the container engine) and `runC`/`crun` (the OCI container runtime)
    interact with each other? Which is responsible for launching the container runtime
    process? Is there a way to monitor the container execution?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s introduce the Conmon project ([https://github.com/containers/conmon](https://github.com/containers/conmon)).
    Conmon is a monitoring and communication tool that sits between the container
    engine and the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Every time a new container is created, a new instance of Conmon is launched.
    It detaches from the container manager process and runs daemonized, launching
    the container runtime as a child process.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we attach a tracing tool to a Podman container, we can see in the following
    the order it’s written in:'
  prefs: []
  type: TYPE_NORMAL
- en: The container engine runs the Conmon process, which detaches and daemonizes
    itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Conmon process runs a container runtime instance that starts the container
    and exits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Conmon process continues to run to provide a monitoring interface, while
    the manager/engine process has exited or detached.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram shows the logical workflow, from Podman execution to
    the running container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Running a Podman container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17908_02_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – Running a Podman container
  prefs: []
  type: TYPE_NORMAL
- en: On a system with many running containers, users will find many instances of
    the Conmon process, one for every container created. In other words, Conmon acts
    as a small, dedicated daemon to the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the following example, where a simple shell loop is used to create
    three identical nginx containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After running the containers, a simple regular expression pattern applied to
    the output of the `ps aux` command shows three Conmon process instances.
  prefs: []
  type: TYPE_NORMAL
- en: Even if Podman is not running anymore (since there is no daemon), it is still
    possible to connect to the Conmon process and attach to the container. At the
    same time, Conmon exposes console sockets and container logs to log files or the
    systemd journal.
  prefs: []
  type: TYPE_NORMAL
- en: Conmon is a lightweight project written in C. It also provides Go language bindings
    to pass config structures between the manager and the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Rootless containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most interesting features of Podman is the capability to run rootless
    containers, which means that users without elevated privileges can run their own
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rootless containers provide better security isolation and let different users
    run their own container instances independently and, thanks to **fork/exec**,
    a daemonless approach adopted by Podman, rootless containers are amazingly easy
    to manage. A rootless container is simply run by the standard user with the usual
    commands and arguments, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When this command is issued, Podman creates a new user namespace and maps UIDs
    between the two namespaces using a `man user_namespaces`). This method allows
    you to have, for example, a root user inside the container mapped to an ordinary
    user in the host.
  prefs: []
  type: TYPE_NORMAL
- en: Rootless containers and image data are stored under the user home directory,
    usually under `$HOME/.local/share/containers/storage`.
  prefs: []
  type: TYPE_NORMAL
- en: Podman manages network connectivity for rootless containers in a different way
    than rootful containers. An in-depth technical comparison between rootless and
    rootful containers, especially from the network and security point of view, will
    be covered later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: After an in-depth analysis of the runtime workflow, it is useful to provide
    an overview of the OCI image specs used by Podman.
  prefs: []
  type: TYPE_NORMAL
- en: OCI images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Podman and the container/image package implement the **OCI Image Format Specification**.
    The full specification is available on GitHub at the following link and pairs
    with the OCI runtime specification: [https://github.com/opencontainers/image-spec](https://github.com/opencontainers/image-spec).'
  prefs: []
  type: TYPE_NORMAL
- en: 'An OCI image is made of the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: Manifest
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An image index (optional)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An image layout
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A filesystem layer changeset archive that will be unpacked to create a final
    filesystem
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An image configuration document to define layer ordering, as well as application
    arguments and environments
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s see in detail what kinds of information and data are managed by the most
    relevant of the preceding elements.
  prefs: []
  type: TYPE_NORMAL
- en: Manifest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An image manifest specification should provide content-addressable images. The
    image manifest contains image layers and configurations for a specific architecture
    and operating system, such as Linux x86_64.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specification: [https://github.com/opencontainers/image-spec/blob/main/manifest.md](https://github.com/opencontainers/image-spec/blob/main/manifest.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Image index
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An image index is an object that contains a list of manifests related to different
    architectures (for example, amd64, arm64, or 386) and operating systems, along
    with custom annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specification: [https://github.com/opencontainers/image-spec/blob/main/image-index.md](https://github.com/opencontainers/image-spec/blob/main/image-index.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Image layout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The OCI image layout represents the directory structure of image blobs. The
    image layout also provides the necessary manifest location references as well
    as image index (in JSON format) and the image configuration. The image `index.json`
    contains the reference to the image manifest, stored as a blob in the OCI image
    bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specification: [https://github.com/opencontainers/image-spec/blob/main/image-layout.md](https://github.com/opencontainers/image-spec/blob/main/image-layout.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem layers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inside an image, one or more layers are applied on top of each other to create
    a filesystem that the container can use.
  prefs: []
  type: TYPE_NORMAL
- en: At a low level, layers are packaged as TAR archives (with compression options
    with gzip and zstd). The filesystem layer implements the logic of layers stacking
    and how the changeset layers (layers containing file changes) are applied.
  prefs: []
  type: TYPE_NORMAL
- en: As described in the previous chapter, a copy-on-write or union filesystem has
    become a standard to manage stacking in a graph-like approach. To manage layers
    stacking, Podman uses **overlayfs** by default as a graph driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specification: [https://github.com/opencontainers/image-spec/blob/main/layer.md](https://github.com/opencontainers/image-spec/blob/main/layer.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Image configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An image configuration defines the image layer composition and the corresponding
    execution parameters such as entry points, volumes, execution arguments, or environment
    variables, as well as additional image metadata.
  prefs: []
  type: TYPE_NORMAL
- en: The image JSON holding the configurations is an **immutable** object; changing
    it means creating a new derived image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specification: [https://github.com/opencontainers/image-spec/blob/main/config.md](https://github.com/opencontainers/image-spec/blob/main/config.md)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram represents an OCI image implementation, composed of image
    layer(s), image index, and image configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – OCI image implementation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17908_02_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – OCI image implementation
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s inspect a realistic example from a basic, lightweight **alpine** image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The directory layout contains an `index.json` file, with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The index contains a manifests array with only one item inside. The object
    digest is a SHA256 and corresponds to filename as one of the blobs listed previously.
    The file is the image manifest and can be inspected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The manifest contains references to the image configuration and layers. In this
    particular case, the image has only one layer. Again, their digests correspond
    to the blob filenames listed before.
  prefs: []
  type: TYPE_NORMAL
- en: 'The config file shows image metadata, environment variables, and command execution.
    At the same time, it contains `DiffID` references to the layers used by the image
    and image creation information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The image layer is the third blob file. This is a TAR archive that could be
    exploded and inspected. For space reasons, in this book the example is limited
    to an inspection of the file type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The result demonstrates that the file is a TAR gzipped archive.
  prefs: []
  type: TYPE_NORMAL
- en: The main differences between Docker and Podman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we went through the key features of Docker and Podman,
    looking into the underlying layer, discovering the companion open source projects
    that made these two tools unique in their container engine role, but now it’s
    time to compare them.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw earlier, the significant difference between the two is that Docker
    has a daemon-centric approach while Podman instead has a daemonless architecture.
    The Podman binary acts as CLI as well as a container engine and uses Conmon to
    orchestrate and monitor the container runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking under the hood into the internals of both projects, we will also find
    many other differences but, in the end, once the container has started, they both
    leverage OCI standard container runtimes but with some differences: Docker uses
    `runc` while Podman uses `crun` in most distributions, with some exceptions; for
    example, it still uses `runc` in the most conservative Red Hat Enterprise Linux
    8 with `crun` as an option.'
  prefs: []
  type: TYPE_NORMAL
- en: Despite the `crun` performance advantages described in the previous section,
    it is not the objective of this book to make a detailed performance comparison
    between the two. Anyway, readers interested in the topic will easily find literature
    about the performance differences between the two runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: Another big gap that was recently filled by the Docker team was the rootless
    container. Podman was the first container engine to bring out this excellent feature
    that increases security and improve the usage of containers in many contexts but,
    as we mentioned, this feature is now available in Docker too.
  prefs: []
  type: TYPE_NORMAL
- en: But let’s go more practical in the next sections, by comparing them side by
    side through the command line first and then by running a container.
  prefs: []
  type: TYPE_NORMAL
- en: Command-line interface comparison
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will go through a side-by-side comparison looking at the
    Docker and Podman CLIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the available commands for both CLIs, it is easy to spot the many
    similarities. The following table was truncated to improve readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.1 – Comparison of Docker and Podman commands'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_2.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2.1 – Comparison of Docker and Podman commands
  prefs: []
  type: TYPE_NORMAL
- en: 'As we stated many times in the preceding section, as well as in the previous
    chapter, Docker was born in 2013 while Podman only arrived 4 years later in 2017\.
    Podman was built keeping in mind how experienced container administrators were
    with the most famous container engine available at that time: Docker. For this
    reason, the Podman development team decided to not change too much the *look and
    feel* of the command-line tools for improving Docker users’ migration to the new-born
    Podman.'
  prefs: []
  type: TYPE_NORMAL
- en: There was a claim, in fact, at the beginning of the distribution of Podman that
    if you have any existing scripts that run Docker you can create an alias and it
    should work (`alias docker=podman`). It was also created a package that places
    a *fake* Docker command under `/usr/bin` that points to *Podman* binary instead.
    For this reason, if you are a Docker user, you can expect a smooth transition
    to Podman once you are ready.
  prefs: []
  type: TYPE_NORMAL
- en: Another important point is that the images created with Docker are compatible
    with the OCI standard, so you can easily migrate or pull again any image you previously
    used with Docker.
  prefs: []
  type: TYPE_NORMAL
- en: If we take a deep look into the command options available for Podman, you will
    notice that there are some additional commands that are not present in Docker,
    while some others are missing.
  prefs: []
  type: TYPE_NORMAL
- en: For example, Podman can manage, along with containers, **pods** (the name Podman
    is quite telling here). The pod concept was introduced with Kubernetes and represents
    the smallest execution unit in a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Podman, users can create empty pods and then run containers inside them
    easily using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is not as easy with Docker, where users must first run a container and
    then create new ones attaching to the network namespace of the first container.
  prefs: []
  type: TYPE_NORMAL
- en: Podman has additional features that could help users to move their containers
    in Kubernetes environments. Using the command `podman generate kube`, Podman can
    create a Kubernetes YAML file for a running container that can be used to create
    a pod inside a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Running containers as systemd services is equally easy with the `podman generate
    systemd` command, which takes a running container or pod and generates a systemd
    unit file that can be used to automatically run services at system startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'A notable example: the **OpenStack** project, an open source cloud computing
    infrastructure, adopted Podman as the default manager for its containerized services
    when deployed with TripleO. All the services are executed by Podman and orchestrated
    by systemd in the control plane and compute nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: Having checked the surface of these container engines and having looked at their
    command lines, let’s recap the under-the-hood differences in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Running a container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Running a container in a Docker environment, as we mentioned earlier, consists
    of using the Docker command-line client to communicate with the Docker daemon
    that will do the actions required to get the container up and running. Just to
    summarize the concepts we explained in this chapter, we can take a look the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Docker simplified architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17908_02_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7 – Docker simplified architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'Podman, instead, interacts directly with the image registry, storage, and with
    the Linux kernel through the container runtime process (not a daemon), with Conmon
    as a monitoring process executed between Podman and the OCI runtime, as we can
    schematize in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Podman simplified architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17908_02_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8 – Podman simplified architecture
  prefs: []
  type: TYPE_NORMAL
- en: The core difference between the two architectures is the daemon-centric Docker
    vision versus the fork/exec approach of Podman.
  prefs: []
  type: TYPE_NORMAL
- en: 'This book does not get into the pros and cons of the Docker daemon architecture
    and features. Anyway, we safely can tell that a significant number of Docker users
    were concerned about this daemon-centric approach for many reasons, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: The daemon could be a single point of failure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If for some reason a failure occurs, then there will be orphaned processes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The daemon owns all the running containers as child processes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Despite the architectural differences, and the aliasing solutions described
    before to easily migrate projects without changing any script, running a container
    from the command line with Docker or Podman is pretty much the same thing for
    the end user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For the same reason, most of the command-line arguments of CLI commands have
    been kept as close as possible to the original version in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed the main differences between Podman and Docker,
    both from architectural and usage points of view. We described the main building
    blocks of the two container engines and highlighted the different community projects
    that fuel the Podman project, especially OCI specifications and the `runC` and
    `crun` runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this book is not to debate why and how Podman could be a better
    choice than Docker. We think that everybody who works with containers should be
    extremely grateful to the Docker company and community for the great work they
    did in bringing containers to the masses and freeing them from niche adoption.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, the evolutionary approach of open source software facilitates
    the birth of new projects that try to compete to be adopted. Ever since it was
    born, the Podman project has grown exponentially and gained a wider user base
    day by day.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the engine internals is still an important task, anyway. For troubleshooting,
    performance tuning, or even just curiosity, investing time in understanding how
    each component relates to each other, reading the code, and testing builds is
    a smart choice that will pay back someday.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters, we will uncover in detail the features and behavior of
    this great container engine.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information about the topics covered in this chapter, you can refer
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developers.redhat.com/blog/2020/09/25/rootless-containers-with-podman-the-basics](https://developers.redhat.com/blog/2020/09/25/rootless-containers-with-podman-the-basics)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developers.redhat.com/blog/2020/11/19/transitioning-from-docker-to-podman](https://developers.redhat.com/blog/2020/11/19/transitioning-from-docker-to-podman)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/opencontainers/runc/blob/master/docs/cgroup-v2.md](https://github.com/opencontainers/runc/blob/master/docs/cgroup-v2.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.redhat.com/sysadmin/introduction-crun](https://www.redhat.com/sysadmin/introduction-crun)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://ebpf.io/what-is-ebpf/](https://ebpf.io/what-is-ebpf/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
