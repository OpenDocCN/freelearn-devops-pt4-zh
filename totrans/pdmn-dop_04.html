<html><head></head><body>
		<div id="_idContainer023">
			<h1 id="_idParaDest-69"><em class="italic"><a id="_idTextAnchor068"/>Chapter 3</em>: Running the First Container</h1>
			<p>In the previous chapters, we discussed the history of containers, their adoption, and the various technologies that contribute to their spread, while also looking at the main differences between <strong class="bold">Docker</strong> and <strong class="bold">Podman</strong>.</p>
			<p>Now, it’s time to start working with real examples: in this chapter, we will learn about how to get Podman up and running on your preferred Linux operating system so that we can start our first container. We will discover the various installation methods, all the prerequisites, and then start a container.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>Choosing an operating system and installation method</li>
				<li>Preparing your environment</li>
				<li>Running your first container</li>
			</ul>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor069"/>Technical requirements</h1>
			<p>Having good technical experience in administering a Linux operating system would be preferable for understanding the key concepts provided in this chapter.</p>
			<p>We will go through the main steps of installing new software on various Linux distributions, so having some experience as a Linux sysadmin could be helpful in troubleshooting possible issues during installation.</p>
			<p>In addition, some of the theoretical concepts that were explained in the previous chapters could help you understand the procedures described in this chapter.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor070"/>Choosing an operating system and installation method</h1>
			<p>Podman is supported on different distributions and operating systems. It is very easy to install, and the <a id="_idIndexMarker253"/>various distributions now provide their own <a id="_idIndexMarker254"/>maintained packages that can be installed with their specific package managers.</p>
			<p>In this section, we will cover the different installation steps for the most common GNU/Linux distributions, as well as on macOS and Windows, despite the focus of this book being on Linux-based environments. </p>
			<p>As a bonus topic, we will also learn how to build Podman directly from source.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>Choosing between Linux distributions and another OS</h2>
			<p>The choice between the different distributions of the GNU/Linux operating system is something that is <a id="_idIndexMarker255"/>dictated by the user’s preferences <a id="_idIndexMarker256"/>and needs, which are usually influenced by several factors that are outside the scope of this book. </p>
			<p>Many advanced users today choose Linux distributions as their main operating systems. However, there is a large quota, especially among developers, who stick to macOS as their standard operating system. Microsoft Windows still retains the largest market share on desktop workstations and laptops.</p>
			<p>Today, we have a huge ecosystem of Linux distributions that have evolved from a smaller subset of core, historical distributions such as Debian, Fedora, Red Hat Enterprise Linux, Gentoo, Arch, and <a id="_idIndexMarker257"/>openSUSE. Specialized websites such as <strong class="bold">DistroWatch</strong> (<a href="https://distrowatch.com">https://distrowatch.com</a>) keep track of the many releases of Linux and BSD-based distributions.</p>
			<p>Despite running a Linux kernel, the various distributions have different architectural approaches for userspace behavior, such as filesystem structure, libraries, or packaging systems used to deliver software releases.</p>
			<p>Another significant difference is related to security and mandatory access control subsystems: for <a id="_idIndexMarker258"/>example, Fedora, CentOS, Red Hat Enterprise Linux, and all the derivates lean on <strong class="bold">SELinux</strong> as their mandatory access control subsystem. On the other hand, Debian, Ubuntu, and <a id="_idIndexMarker259"/>their derivates are based on a similar solution called <strong class="bold">AppArmor</strong>.</p>
			<p>Podman interacts with both SELinux and AppArmor to provide better container isolation, but the underlying interfaces are different.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">All this book’s examples and <a id="_idIndexMarker260"/>source code has been written and tested using <strong class="bold">Fedora Workstation 34</strong> as the reference OS.</p>
			<p>Those of you <a id="_idIndexMarker261"/>who want to reproduce an environment <a id="_idIndexMarker262"/>as close as possible to the book in their lab have different options:</p>
			<ul>
				<li>Use the Fedora 34 Vagrant Box (<a href="https://app.vagrantup.com/fedora/boxes/34-cloud-base">https://app.vagrantup.com/fedora/boxes/34-cloud-base</a>). <strong class="bold">Vagrant</strong> is a software solution developed by <strong class="bold">Hashicorp</strong> to create fast, lightweight <a id="_idIndexMarker263"/>VMs, especially suitable for development use. See <a href="https://www.vagrantup.com/">https://www.vagrantup.com/</a> for further details about Vagrant and <a id="_idIndexMarker264"/>how to use it on your operating system of choice. </li>
				<li>Directly download <a id="_idIndexMarker265"/>the cloud image (<a href="https://alt.fedoraproject.org/cloud/">https://alt.fedoraproject.org/cloud/</a>) and create instances on the public/private cloud or just deploy it on a hypervisor of your choice.</li>
				<li>Manually install Fedora Workstation. In this case, the official installation guide (<a href="https://docs.fedoraproject.org/en-US/fedora/f34/install-guide/">https://docs.fedoraproject.org/en-US/fedora/f34/install-guide/</a>) provides detailed instructions on deploying the OS.</li>
			</ul>
			<p>Running instances on public clouds is the best option for users who are not able to run virtual machines locally.</p>
			<p>Providers such as Amazon Web Services, Google Cloud Platform, Microsoft Azure, and DigitalOcean also offer ready-to-use Fedora-based cloud instances with low monthly prices for smaller sizes. </p>
			<p>Prices can vary in time and across tiers and keeping track of them is beyond the purpose of this book. Almost all providers offer free plans for learning or basic use, with small/micro tiers at very low prices. </p>
			<p>Containers are Linux-based, and the different container engines and runtimes interact with the Linux kernel and <a id="_idIndexMarker266"/>libraries to operate. Windows <a id="_idIndexMarker267"/>has recently introduced support for native containers with an approach to isolation that’s quite close to the Linux namespace concepts described previously. However, only Windows-based images can run natively and not all container engines support native execution.</p>
			<p>The same considerations are <a id="_idIndexMarker268"/>valid for macOS: its architecture is not based on Linux but on a hybrid Mach/BSD kernel called <strong class="bold">XNU</strong>. For this reason, it does not offer the Linux kernel features necessary to run containers natively.</p>
			<p>For both Windows and macOS, a virtualization layer that abstracts the Linux machine is necessary to run native Linux containers.</p>
			<p>Podman offers remote client functions for Windows and macOS, enabling users to connect to a local or remote Linux box.</p>
			<p>Windows users can also benefit from an alternative approach based on the <strong class="bold">Windows Subsystem for Linux</strong> (<strong class="bold">WSL</strong>) <strong class="bold">2.0</strong>, a compatibility layer that runs a lightweight VM to expose Linux kernel <a id="_idIndexMarker269"/>interfaces along with Linux userspace binaries, thanks to Hyper-V virtualization support.</p>
			<p>The following sections will cover the necessary steps for installing Podman on the most popular Linux distributions, as well as macOS and Windows.</p>
			<h3>Installing Podman on Fedora</h3>
			<p>Fedora packages <a id="_idIndexMarker270"/>are maintained by its wide community <a id="_idIndexMarker271"/>and managed with the <strong class="bold">DNF </strong>package manager. To install Podman, run the following command from a terminal:</p>
			<p class="source-code"># dnf install –y podman </p>
			<p>This command installs Podman and configures the environment with config files (covered in the next section). It also installs <strong class="source-inline">systemd</strong> units to provide additional features such as REST API services or container auto-updates.</p>
			<h3>Installing Podman on CentOS</h3>
			<p>Podman can be installed on <a id="_idIndexMarker272"/>CentOS 7, CentOS 8, and CentOS Stream (<a href="https://www.centos.org/">https://www.centos.org/</a>). Users installing on CentOS 7 must have the <strong class="bold">Extras</strong> repository <a id="_idIndexMarker273"/>enabled, while users installing on CentOS 8 and Stream <a id="_idIndexMarker274"/>must have the Podman package available from the already enabled <strong class="bold">AppStream</strong> repository.</p>
			<p>To install Podman, run the following command from a terminal:</p>
			<p class="source-code"># yum install –y podman</p>
			<p>Like in Fedora, this command installs Podman and all its dependencies, including config files and <strong class="source-inline">systemd</strong> unit files.</p>
			<h3>Installing Podman on RHEL</h3>
			<p>To install <a id="_idIndexMarker275"/>Podman on <strong class="bold">Red Hat Enterprise Linux</strong> (<strong class="bold">RHEL</strong>) (<a href="https://www.redhat.com/en/technologies/linux-platforms/enterprise-linux">https://www.redhat.com/en/technologies/linux-platforms/enterprise-linux</a>), users <a id="_idIndexMarker276"/>should follow <a id="_idIndexMarker277"/>two different procedures on RHEL 7 and RHEL 8.</p>
			<p>On RHEL 7, users must enable the extra channel and then install the Podman package:</p>
			<p class="source-code"># subscription-manager repos \</p>
			<p class="source-code">--enable=rhel-7-server-extras-rpms</p>
			<p class="source-code"># yum -y install podman</p>
			<p>On RHEL 8, the Podman package is available on a dedicated module called <strong class="bold">container-tools</strong>. Modules are custom <a id="_idIndexMarker278"/>sets of RPM packages that can be organized in streams with independent release cycles:</p>
			<p class="source-code"># yum module enable -y container-tools:rhel8</p>
			<p class="source-code"># yum module install -y container-tools:rhel8</p>
			<p>The <strong class="source-inline">container-tools</strong> module installs, along with Podman, two useful tools, both of which will be covered later in this book:</p>
			<ul>
				<li><strong class="bold">Skopeo</strong>, a tool for <a id="_idIndexMarker279"/>managing OCI images and registries</li>
				<li><strong class="bold">Buildah</strong>, a specialized <a id="_idIndexMarker280"/>tool for <a id="_idIndexMarker281"/>building <a id="_idIndexMarker282"/>custom OCI images from Dockerfiles and from scratch</li>
			</ul>
			<h3>(Not) Installing Podman on Fedora CoreOS and Fedora Silverblue</h3>
			<p>The title of this <a id="_idIndexMarker283"/>subsection is a bit of a joke. The reality is that <a id="_idIndexMarker284"/>Podman is already installed on <a id="_idIndexMarker285"/>both distributions and is a crucial tool for <a id="_idIndexMarker286"/>running containerized workloads.</p>
			<p>The <strong class="bold">Fedora CoreOS</strong> and <strong class="bold">Fedora SilverBlue</strong> distributions are immutable, atomic operating systems <a id="_idIndexMarker287"/>aimed to be <a id="_idIndexMarker288"/>used on server/cloud and desktop environments, respectively.</p>
			<p>Fedora CoreOS (<a href="https://getfedora.org/en/coreos/">https://getfedora.org/en/coreos/</a>) is the upstream of Red Hat CoreOS, the operating <a id="_idIndexMarker289"/>system used to run Red Hat OpenShift and the base OS of <strong class="bold">OpenShift Kubernetes Distribution</strong> (<strong class="bold">OKD</strong>), the community-based <a id="_idIndexMarker290"/>Kubernetes distribution used as the upstream of Red Hat OpenShift.</p>
			<p>Fedora Silverblue (<a href="https://silverblue.fedoraproject.org/">https://silverblue.fedoraproject.org/</a>) is a desktop-focused immutable <a id="_idIndexMarker291"/>operating system that aims to provide a stable and comfortable desktop user experience, especially for developers working with containers.</p>
			<p>So, on both Fedora CoreOS and Fedora Silverblue, just open a terminal and run Podman.</p>
			<h3>Installing Podman on Debian</h3>
			<p>The Podman package <a id="_idIndexMarker292"/>is available on <strong class="bold">Debian</strong> (<a href="https://www.debian.org/">https://www.debian.org/</a>) since <a id="_idIndexMarker293"/>version 11, codename <a id="_idIndexMarker294"/>Bullseye (named after the famous toy horse from the Toy Story 2 and 3 movies).</p>
			<p>Debian uses the <strong class="source-inline">apt-get</strong> package handling utility to install and upgrade system packages.</p>
			<p>To install Podman on a Debian system, run the following command from the terminal:</p>
			<p class="source-code"># apt-get –y install podman</p>
			<p>The preceding <a id="_idIndexMarker295"/>command installs the Podman binary and its <a id="_idIndexMarker296"/>dependencies, along with its config files, <strong class="source-inline">systemd</strong> units, and man pages.</p>
			<h3>Installing Podman on Ubuntu</h3>
			<p>Being built <a id="_idIndexMarker297"/>on Debian, <strong class="bold">Ubuntu</strong> (<a href="https://ubuntu.com/">https://ubuntu.com/</a>) behaves in an analogous <a id="_idIndexMarker298"/>way for package management. To install Podman <a id="_idIndexMarker299"/>on Ubuntu 20.10 or later, run the following commands:</p>
			<p class="source-code"># apt-get -y update</p>
			<p class="source-code"># apt-get -y install podman</p>
			<p>These two commands update the system packages and then install the Podman binaries and related dependencies.</p>
			<h3>Installing Podman on openSUSE</h3>
			<p>The <strong class="bold">openSUSE</strong> distribution (<a href="https://www.opensuse.org/">https://www.opensuse.org/</a>) is backed by SUSE and is available in <a id="_idIndexMarker300"/>two different flavors – the rolling release <a id="_idIndexMarker301"/>known as <strong class="bold">Tumbleweed,</strong> and the <a id="_idIndexMarker302"/>LTS distribution <a id="_idIndexMarker303"/>known as <strong class="bold">Leap</strong>. Podman is available in the openSUSE repositories and <a id="_idIndexMarker304"/>can be installed with the following command:</p>
			<p class="source-code"># zypper install podman</p>
			<p>The Zypper package manager will download and install all the necessary packages and dependencies.</p>
			<h3>Installing Podman on Gentoo</h3>
			<p><strong class="bold">Gentoo</strong> (<a href="https://www.gentoo.org/">https://www.gentoo.org/</a>) is a <a id="_idIndexMarker305"/>clever <a id="_idIndexMarker306"/>distribution that is characterized <a id="_idIndexMarker307"/>by building installed packages directly on the target machine with the optional extra user customizations. To achieve this, it uses the <strong class="bold">Portage</strong> package manager, inspired by FreeBSD ports.</p>
			<p>To install <a id="_idIndexMarker308"/>Podman <a id="_idIndexMarker309"/>on Gentoo, run the following command:</p>
			<p class="source-code"># emerge app-emulation/podman</p>
			<p>The <strong class="source-inline">emerge</strong> utility will download and automatically build the Podman sources on the system.</p>
			<h3>Installing Podman on Arch Linux</h3>
			<p><strong class="bold">Arch Linux</strong> (<a href="https://archlinux.org/">https://archlinux.org/</a>) is a <a id="_idIndexMarker310"/>rolling Linux distribution that shines for being highly <a id="_idIndexMarker311"/>customizable. It uses the <strong class="bold">pacman</strong> package <a id="_idIndexMarker312"/>manager to install and update packages from official and users' custom repositories.</p>
			<p>To install Podman on Arch Linux and derivate distributions, run the following command from the terminal:</p>
			<p class="source-code"># pacman –S podman</p>
			<p>By default, Podman’s installation on Arch Linux does not permit rootless containers. To enable them, follow the official Arch wiki instructions: <a href="https://wiki.archlinux.org/title/Podman#Rootless_Podman">https://wiki.archlinux.org/title/Podman#Rootless_Podman</a>.</p>
			<h3>Installing Podman on Raspberry Pi OS</h3>
			<p>The famous <a id="_idIndexMarker313"/>Raspberry Pi single-board computer <a id="_idIndexMarker314"/>has achieved enormous success among developers, makers, and hobbyists. </p>
			<p>It runs the <a id="_idIndexMarker315"/>Raspberry Pi OS (<a href="https://www.raspberrypi.org/software/operating-systems/#raspberry-pi-os-32-bit">https://www.raspberrypi.org/software/operating-systems/#raspberry-pi-os-32-bit</a>), which is based on Debian. </p>
			<p>Podman’s arm64 build is available and can be installed by following the same steps described previously for the Debian distribution.</p>
			<h3>Installing Podman on macOS</h3>
			<p>Apple users who develop and run Linux containers can install and use Podman as a remote client, while <a id="_idIndexMarker316"/>the containers are executed on a remote Linux box. The Linux <a id="_idIndexMarker317"/>machine can also be a VM that’s executed on macOS and directly managed by Podman.</p>
			<p>To install Podman using the Homebrew package manager, run the following command from the terminal:</p>
			<p class="source-code">$ brew install podman</p>
			<p>To initialize the VM running the Linux box, run the following commands:</p>
			<p class="source-code">$ podman machine init</p>
			<p class="source-code">$ podman machine start</p>
			<p>Alternatively, users can create and connect to an external Linux host. </p>
			<p>Another valid approach on macOS to creating fast, lightweight VMs for development use is Vagrant. When the Vagrant machine is created, users can manually or automatically provision additional software such as Podman and start using the customized instance using the remote client.</p>
			<h3>Installing Podman on Windows</h3>
			<p>To run Podman <a id="_idIndexMarker318"/>as a remote client, simply download and <a id="_idIndexMarker319"/>install the latest release from the GitHub releases page (<a href="https://github.com/containers/podman/releases/">https://github.com/containers/podman/releases/</a>). Extract the archive in a suitable location and edit the TOML-encoded <strong class="source-inline">containers.conf</strong> file to configure a remote URI for the Linux machine or pass additional options.</p>
			<p>The following code snippet shows an example configuration:</p>
			<p class="source-code">[engine]</p>
			<p class="source-code">remote_uri= " ssh://root@10.10.1.9:22/run/podman/podman.sock"</p>
			<p>The remote Linux machine exposes Podman on a UNIX socket managed by a <strong class="source-inline">systemd</strong> unit. We will cover this topic in greater detail later in this book.</p>
			<p>To run Podman on WSL 2.0, users must first install a Linux distribution from the Microsoft Store on their Windows host. There is a variety of available distributions under the Microsoft catalog. </p>
			<p>The following example is based on Ubuntu 20.10:</p>
			<p class="source-code"># apt-get –y install podman</p>
			<p class="source-code"># mkdir -p /etc/containers</p>
			<p class="source-code"># echo -e "[registries.search]\nregistries = \</p>
			<p class="source-code">[‘docker.io’, ‘quay.io’]" | tee \ /etc/containers/registries.conf</p>
			<p>The preceding <a id="_idIndexMarker320"/>commands install the latest Podman stable <a id="_idIndexMarker321"/>release and configure the <strong class="source-inline">/etc/containers/registries.conf</strong> file to provide a registries whitelist.</p>
			<p>After its installation, some minor customizations are necessary to adapt it to the WSL 2.0 environment:</p>
			<p class="source-code"># cp /usr/share/containers/libpod.conf /etc/containers</p>
			<p class="source-code"># sed –i  ‘s/ cgroup_manager = "systemd"/ cgroup_manager = "cgroupfs"/g’ /etc/containers/libpod.conf</p>
			<p class="source-code"># sed –i ‘s/ events_logger = "journald"/ events_logger = "file"/g’ /etc/containers/libpod.conf</p>
			<p>The preceding command configures logging and CGroup management to successfully run rootful containers in the subsystem.</p>
			<h3>Building Podman from source</h3>
			<p>Building an application from source has many advantages: users can inspect and customize code <a id="_idIndexMarker322"/>before building, cross-compile for different architectures, or selectively build only a subset of binaries. It is also a great learning opportunity to get into the project’s structure and understand its evolution. Last but not least, building from source lets the users get the latest development versions with cool new features, bugs included.</p>
			<p>The following steps assume that the building machine is a Fedora distribution. First, we must install the necessary dependencies needed to compile Podman:</p>
			<p class="source-code"># dnf install -y \</p>
			<p class="source-code">  btrfs-progs-devel \</p>
			<p class="source-code">  conmon \</p>
			<p class="source-code">  containernetworking-plugins \</p>
			<p class="source-code">  containers-common \</p>
			<p class="source-code">  crun \</p>
			<p class="source-code">  device-mapper-devel \</p>
			<p class="source-code">  git \</p>
			<p class="source-code">  glib2-devel \</p>
			<p class="source-code">  glibc-devel \</p>
			<p class="source-code">  glibc-static \</p>
			<p class="source-code">  go \</p>
			<p class="source-code">  golang-github-cpuguy83-md2man \</p>
			<p class="source-code">  gpgme-devel \</p>
			<p class="source-code">  iptables \</p>
			<p class="source-code">  libassuan-devel \</p>
			<p class="source-code">  libgpg-error-devel \</p>
			<p class="source-code">  libseccomp-devel \</p>
			<p class="source-code">  libselinux-devel \</p>
			<p class="source-code">  make \</p>
			<p class="source-code">  pkgconfig</p>
			<p>This command will <a id="_idIndexMarker323"/>take a while to install all the packages and their cascading dependencies.</p>
			<p>When the installation is complete, choose a working directory and clone the Podman repository using the <strong class="source-inline">git</strong> command:</p>
			<p class="source-code">$ git clone https://github.com/containers/podman.git</p>
			<p>This command will clone the entire repository in the working directory.</p>
			<p>Change to the project directory and start the build:</p>
			<p class="source-code">$ cd podman</p>
			<p class="source-code">$ make package-install</p>
			<p>The <strong class="source-inline">make package-install</strong> command compiles the source code, builds the RPM files, and installs the <a id="_idIndexMarker324"/>packages locally. Remember that the RPM format is associated with Fedora/CentOS/RHEL distributions and managed by the <strong class="source-inline">dnf</strong> and <strong class="source-inline">yum</strong> package managers. </p>
			<p>The build process will take a few minutes to complete. To test the successful installation of the packages, simply run the following code:</p>
			<p class="source-code">$ podman version</p>
			<p class="source-code">Version:      4.0.0-dev</p>
			<p class="source-code">API Version:  4.0.0-dev</p>
			<p class="source-code">Go Version:   go1.16.6</p>
			<p class="source-code">Git Commit:   cffc747fccf38a91be5cd106d2e507afaaa23e14</p>
			<p class="source-code">Built:        Sat Aug  4 00:00:00 2018</p>
			<p class="source-code">OS/Arch:      linux/amd64</p>
			<p>Sometimes, it is useful to build the binaries on a dedicated build host and then deploy them on other machines, using either package managers or simple archives. To only build the binaries, run the following command:</p>
			<p class="source-code">$ make</p>
			<p>At the end of the build, the binaries will be available under the <strong class="source-inline">bin/</strong> folder. To install the compiled binaries and config files locally by simply copying them into the target directories defined in the Makefile, run the following command:</p>
			<p class="source-code">$ make install</p>
			<p>To create a binary release similar to the <strong class="source-inline">.tar.gz</strong> archive, which is available on the GitHub release page, run the following command:</p>
			<p class="source-code">$ make podman-release.tar.gz</p>
			<p><strong class="bold">Bonus tip</strong>: Building a different <a id="_idIndexMarker325"/>version is very easy – just switch to the tag of the target release using the <strong class="source-inline">git</strong> command. For example, to build v3.3.1, use the following command:</p>
			<p class="source-code">$ git checkout v3.3.1</p>
			<p>In this section, we learned how to install binary releases of Podman on different distributions using their respective package managers. We also learned how to install the Podman remote client on macOS and Windows, along with Windows WSL 2.0 mode. We closed this section by showing you how to build from source.</p>
			<p>In the next section, we will learn how to configure Podman for the first run by preparing the system environment. </p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor072"/>Preparing your environment</h1>
			<p>Once the Podman packages have been installed, Podman is ready to be used <em class="italic">out of the box</em>. However, some minor customizations can be useful to provide better interoperability with external registries or to customize runtime behaviors.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor073"/>Customizing the container registries search list</h2>
			<p>Podman searches for and downloads images from a list of trusted container registries. The <strong class="source-inline">/etc/containers/registries.conf</strong> file is a TOML config file that can be used to customize <a id="_idIndexMarker326"/>whitelisted registries that are allowed to be searched and used as image sources, as well as registry mirroring and insecure registries without TLS termination. </p>
			<p>In this config file, the <strong class="source-inline">unqualified-search-registries</strong> key is populated with an array of unqualified registries with no specification regarding images repositories and tags.</p>
			<p>On a Fedora system, with a new installation of Podman, this key has the following content:</p>
			<p class="source-code">unqualified-search-registries = ["registry.fedoraproject.org", "registry.access.redhat.com", "docker.io", "quay.io"]</p>
			<p>Users can add or remove registries from this array to let Podman search and pull from them. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Be very cautious when adding registries and use only trusted registries to avoid pulling images containing malicious code.</p>
			<p>The default list is adequate to search for and run all the book examples. Those of you who are already <a id="_idIndexMarker327"/>running private registries can try to add them to the unqualified search registries array.</p>
			<p>Since registries are both private and public, please keep in mind that private registries usually require additional authentication to be accessed. This can be accomplished with the <strong class="source-inline">podman login</strong> command, which will be covered later in this book.</p>
			<p>If the <strong class="source-inline">$HOME/.config/containers/registries.conf</strong> file is found in the user home, it overrides the <strong class="source-inline">/etc/containers/registries.conf</strong> file. In this way, different users on the same system will be able to run Podman with their custom registry whitelists and mirrors.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor074"/>Optional – enable socket-based services</h2>
			<p>This is an optional step and, in the absence of specific needs, this section’s contents can be safely skipped.</p>
			<p>As we mentioned previously, Podman is a daemonless container manager that needs no background service <a id="_idIndexMarker328"/>to run containers. However, users may need to interact with the Libpod APIs exposed by Podman, especially when migrating from a Docker-based environment.</p>
			<p>Podman can expose its APIs using a UNIX socket (default behavior) or a TCP socket. The latter option is less secure because it makes Podman accessible from the outside world, but it is necessary in some cases, such as when it should be accessed by a Podman client on a Windows or macOS workstation.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Be careful when running the API service using a TCP endpoint on a machine exposed to the internet since the service will be globally accessible.</p>
			<p>The following command exposes the Podman APIs on a UNIX socket:</p>
			<p class="source-code">$ sudo podman system service --time=0 \</p>
			<p class="source-code">  unix:///run/podman/podman.sock</p>
			<p>After running this <a id="_idIndexMarker329"/>command, users can connect to the API service. </p>
			<p>Having to run this <a id="_idIndexMarker330"/>command on a terminal window is not a handy approach. Instead, the best approach is to use a <strong class="bold">systemd socket</strong> (see <strong class="source-inline">man systemd.socket</strong>). </p>
			<p>Socket units in <strong class="source-inline">systemd</strong> are special kinds of service activators: when a request reaches the pre-defined endpoint of the socket, <strong class="source-inline">systemd</strong> immediately spawns the homonymous service. </p>
			<p>When Podman is installed, the <strong class="source-inline">podman.socket</strong> and <strong class="source-inline">podman.service</strong> unit files are created. <strong class="source-inline">podman.socket</strong> has the following content:</p>
			<p class="source-code"># cat /usr/lib/systemd/system/podman.socket</p>
			<p class="source-code">[Unit]</p>
			<p class="source-code">Description=Podman API Socket</p>
			<p class="source-code">Documentation=man:podman-system-service(1) </p>
			<p class="source-code">[Socket]</p>
			<p class="source-code">ListenStream=%t/podman/podman.sock</p>
			<p class="source-code">SocketMode=0660</p>
			<p class="source-code">[Install]</p>
			<p class="source-code">WantedBy=sockets.target</p>
			<p>The <strong class="source-inline">ListenStream</strong> key holds the relative path of the socket, which is expanded to <strong class="source-inline">/run/podman/podman.sock</strong>:</p>
			<p>The podman.service has the following content:</p>
			<p class="source-code"># cat /usr/lib/systemd/system/podman.service</p>
			<p class="source-code">[Unit]</p>
			<p class="source-code">Description=Podman API Service</p>
			<p class="source-code">Requires=podman.socket</p>
			<p class="source-code">After=podman.socket</p>
			<p class="source-code">Documentation=man:podman-system-service(1)</p>
			<p class="source-code">StartLimitIntervalSec=0</p>
			<p class="source-code">[Service]</p>
			<p class="source-code">Type=exec</p>
			<p class="source-code">KillMode=process</p>
			<p class="source-code">Environment=LOGGING="--log-level=info"</p>
			<p class="source-code">ExecStart=/usr/bin/podman $LOGGING system service</p>
			<p class="source-code">[Install]</p>
			<p class="source-code">WantedBy=multi-user.target</p>
			<p>The <strong class="source-inline">ExecStart=</strong> field indicates the command to be launched by the service, which is the same <strong class="source-inline">podman system service</strong> command we showed previously.</p>
			<p>The <strong class="source-inline">Requires=</strong> field <a id="_idIndexMarker331"/>indicates that the <strong class="source-inline">podman.service</strong> unit needs <strong class="source-inline">podman.socket</strong> to be activated.</p>
			<p>So, what happens when we enable and start the <strong class="source-inline">podman.socket</strong> unit? <strong class="source-inline">systemd</strong> handles the socket and waits for a connection to the socket endpoint. When this event happens, it immediately starts the <strong class="source-inline">podman.service</strong> unit. After a period of inactivity, the service is stopped again.</p>
			<p>To enable and start the socket unit, run the following command:</p>
			<p class="source-code"># systemctl enable --now podman.socket</p>
			<p>We can test the results with a simple <strong class="source-inline">curl</strong> command:</p>
			<p class="source-code"># curl --unix-socket /run/podman/podman.sock \   </p>
			<p class="source-code">  http://d/v3.0.0/libpod/info</p>
			<p>The printed output will be a JSON payload that contains the container engine configuration. </p>
			<p>What happened when we hit the URL? Under the hood, the service unit was immediately started <a id="_idIndexMarker332"/>and triggered by the socket when the connection was issued. Some of you may have noticed a slight delay (in the order of a 1/10th of a second) the very first time the command was executed. </p>
			<p>After 5 seconds of inactivity, <strong class="source-inline">podman.service</strong> deactivates again. This is due to the default behavior of the <strong class="source-inline">podman system service</strong> command, which runs for 5 seconds only by default unless the <strong class="source-inline">–time</strong> option is passed to provide a different timeout (a value of 0 means forever).</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>Optional – customize Podman’s behavior</h2>
			<p>Podman’s default <a id="_idIndexMarker333"/>configuration works out of the box for most use cases, but its configuration is highly flexible. The following configuration files are available for customizing its behavior:</p>
			<ul>
				<li><strong class="source-inline">containers.conf</strong>: This TOML-formatted file holds Podman runtime configurations, as well as search paths for <strong class="source-inline">conmon</strong> and container runtime binaries. It is installed by default under the <strong class="source-inline">/usr/share/containers/</strong> path and can be overridden by the <strong class="source-inline">/etc/containers/containers.conf</strong> and <strong class="source-inline">$HOME/.config/containers/containers.conf</strong> files for system-wide and user-wide settings, respectively.</li>
			</ul>
			<p>This file can be used to customize the behavior of the engine. Users can influence how the container is created and its life cycle by customizing settings such as logging, DNS resolution, environment variables, shared memory usage, Cgroup management, and many others. </p>
			<p>For a full list of settings, check out the related <strong class="source-inline">man</strong> page, which was installed along with the Podman package. (<strong class="source-inline">man containers.conf</strong>)</p>
			<ul>
				<li><strong class="source-inline">storage.conf</strong>: This TOML-formatted file is used to customize the storage settings that are <a id="_idIndexMarker334"/>used by the container engine. In particular, this file enables you to customize the default storage driver, as well as the read/write directory of the container storage (also known as the graph root), which is an additional driver storage option. By default, the driver is set to <strong class="bold">overlay</strong>. </li>
			</ul>
			<p>The default path of this file is <strong class="source-inline">/usr/share/containers/storage.conf</strong> and overrides can be found or created under <strong class="source-inline">/etc/containers/storage.conf</strong> for system-wide customizations. </p>
			<p>User-scoped configurations that impact rootless containers can be found under <strong class="source-inline">$XDG_CONFIG_HOME/containers/storage.conf</strong> or <strong class="source-inline">$HOME/.config/containers/storage.conf</strong>.</p>
			<ul>
				<li><strong class="source-inline">mounts.conf</strong>: This file defines the volume mounts that should be automatically mounted inside a container when it is started. This is useful, for example, to automatically pass secrets such as keys and certificates inside a container.</li>
			</ul>
			<p>It can be found under <strong class="source-inline">/usr/share/containers/mounts.conf</strong> and overridden by a file located at <strong class="source-inline">/etc/containers/mounts.conf</strong>.</p>
			<p>In rootless mode, the override file can be placed under <strong class="source-inline">$HOME/.config/containers/mounts.conf</strong>.</p>
			<ul>
				<li><strong class="source-inline">seccomp.json</strong>: This is a JSON file that lets users customize the allowed <strong class="source-inline">syscalls</strong> that a process inside a container can perform and define the blocked ones at the same time. This topic will be covered again in <a href="B17908_11_epub.xhtml#_idTextAnchor206"><em class="italic">Chapter 11</em></a>, <em class="italic">Securing Containers</em>, which will provide a deeper understanding of the security constraints of containers. </li>
			</ul>
			<p>The default path for this file is <strong class="source-inline">/usr/share/containers/seccomp.json</strong>. The seccomp man page (<strong class="source-inline">man seccomp</strong>) provides an overview of how seccomp works on a Linux system.</p>
			<ul>
				<li><strong class="source-inline">policy.json</strong>: This is a JSON file that defines how Podman will perform signature <a id="_idIndexMarker335"/>verification. The default path of this file is <strong class="source-inline">/etc/containers/policy.json</strong> and can be overridden by the user-scoped <strong class="source-inline">$HOME/.config/containers/policy.json</strong>. </li>
			</ul>
			<p>This config file accepts three kinds of policies: </p>
			<ul>
				<li><strong class="bold">insecureAcceptAnything</strong>: Accept any image from the specified registry. </li>
				<li><strong class="bold">reject</strong>: Reject any image from the specified registry. </li>
				<li><strong class="bold">signedBy</strong>: Accept only images signed by a specific, known entity.</li>
			</ul>
			<p>The default configuration is to accept every image (the <strong class="source-inline">insecureAcceptAnything</strong> policy), but it can be modified to pull only trusted images that can be verified by a signature. Users can define custom GPG keys to verify the signatures and the identity that signed them. For extra details about the possible policies and configuration examples, please refer to the related man page (<strong class="source-inline">man containers-policy.json</strong>).</p>
			<p>In this section, we discussed some basic configurations of Podman that are useful to know from when Podman is first installed. In the next section, we will cover our first container execution examples.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor076"/>Running your first container</h1>
			<p>Now, it’s time to finally run our first container.</p>
			<p>In the previous section, we uncovered how to install Podman on our favorite Linux distribution, as well <a id="_idIndexMarker336"/>as what’s included in the base packages once installed. Now, we can start using our daemonless container engine.</p>
			<p>Running containers in Podman is handled through the <strong class="source-inline">podman run</strong> command, which accepts many options for controlling the behavior of the just ran container, its isolation, its communication, its storage, and so on.</p>
			<p>The easiest and shortest Podman command for running a brand-new container is as follows:</p>
			<p class="source-code">$ podman run &lt;imageID&gt;</p>
			<p>We have to replace the <strong class="source-inline">imageID</strong> string with the image name/location/tag we want to run. If the image is not present in the cache or we have not downloaded it before, Podman will pull the image for us from the respective container registry.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/>Interactive and pseudo-tty</h2>
			<p>To introduce this command <a id="_idIndexMarker337"/>and its options, let’s start simple and run the following command:</p>
			<p class="source-code"><strong class="bold">$ podman run -i -t fedora /bin/bash </strong></p>
			<p class="source-code">Resolved "fedora" as an alias (/etc/containers/registries.conf.d/000-shortnames.conf)</p>
			<p class="source-code">Trying to pull registry.fedoraproject.org/fedora:latest...</p>
			<p class="source-code">Getting image source signatures</p>
			<p class="source-code">Copying blob ecfb9899f4ce done  </p>
			<p class="source-code">Copying config 37e5619f4a done  </p>
			<p class="source-code">Writing manifest to image destination</p>
			<p class="source-code">Storing signatures</p>
			<p class="source-code">[root@ec444ad299ab /]#</p>
			<p>Let’s see what Podman did once we executed the previous command: </p>
			<ol>
				<li>It recognized the image’s name, <strong class="source-inline">fedora</strong>, as an alias for the latest Fedora container image.</li>
				<li>It then realized that the image was missing from the local cache because it was the first time that we tried to run it.</li>
				<li>It pulled down the image from the right registry. It chose the Fedora Project registry because <a id="_idIndexMarker338"/>it matched the aliases contained in the registries’ configurations.</li>
				<li>Finally, it started the container and presented us with an interactive shell, executing the Bash shell program that we requested.</li>
			</ol>
			<p>The previous command prompted an interactive shell thanks to the two options that we can analyze, as follows:</p>
			<ul>
				<li><strong class="source-inline">--tty, -t</strong>: With this option, Podman allocates a <strong class="bold">pseudo-tty</strong> (see <strong class="source-inline">man pty</strong>) and attaches it to the container’s standard input.</li>
				<li><strong class="source-inline">--interactive, -i</strong>: With this option, Podman keeps <strong class="source-inline">stdin</strong> open and ready to be attached to the previous pseudo-tty.</li>
			</ul>
			<p>As stated in the previous chapters, when a container is created, the isolated processes inside it will run on a writable root filesystem, as a result of a layered overlay. </p>
			<p>This allows any process to write files, but don’t forget that they will last until the container is running, as containers are ephemeral by default.</p>
			<p>Now, you can execute any command and check its output in the console we just brought up:</p>
			<p class="source-code">[root@ec444ad299ab /]# dnf install -y iputils iproute</p>
			<p class="source-code">Last metadata expiration check: 0:01:50 ago on Mon Sep 13 08:54:20 2021.</p>
			<p class="source-code">Dependencies resolved.</p>
			<p class="source-code">=============================================================================================================================================================================</p>
			<p class="source-code">Package                                           Architecture                      Version                                        Repository                          Size</p>
			<p class="source-code">=============================================================================================================================================================================</p>
			<p class="source-code">Installing:</p>
			<p class="source-code">iproute                                           x86_64                            5.10.0-2.fc34                                  fedora                             679 k</p>
			<p class="source-code">iputils                                           x86_64                            20210202-2.fc34                                fedora                             170 k</p>
			<p class="source-code">Installing dependencies:</p>
			<p class="source-code">...</p>
			<p class="source-code">[root@ec444ad299ab /]# ip r</p>
			<p class="source-code">default via 10.0.2.2 dev tap0 </p>
			<p class="source-code">10.0.2.0/24 dev tap0 proto kernel scope link src 10.0.2.100 </p>
			<p class="source-code">[root@ec444ad299ab /]# ping -c2 10.0.2.2</p>
			<p class="source-code">PING 10.0.2.2 (10.0.2.2) 56(84) bytes of data.</p>
			<p class="source-code">64 bytes from 10.0.2.2: icmp_seq=1 ttl=255 time=0.030 ms</p>
			<p class="source-code">64 bytes from 10.0.2.2: icmp_seq=2 ttl=255 time=0.200 ms</p>
			<p class="source-code"> </p>
			<p class="source-code">--- 10.0.2.2 ping statistics ---</p>
			<p class="source-code">2 packets transmitted, 2 received, 0% packet loss, time 1034ms</p>
			<p class="source-code">rtt min/avg/max/mdev = 0.030/0.115/0.200/0.085 ms</p>
			<p>As you can see, in the <a id="_idIndexMarker339"/>previous example, we just installed two packages for inspecting the container’s network configuration and then executing a ping to the default router that’s assigned to the virtual networking of our running container. Again, if we stop this container, any changes will be lost.</p>
			<p>To exit this interactive shell, we can just press <em class="italic">Ctrl</em> + <em class="italic">D</em> or execute the <strong class="source-inline">exit</strong> command. By doing this, the <a id="_idIndexMarker340"/>container will be terminated because the main running process we requested to execute (<strong class="source-inline">/bin/bash</strong>) will stop!</p>
			<p>Now, let’s look at some other nice and useful options we can use with the <strong class="source-inline">podman run</strong> command.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor078"/>Detaching from a running container</h2>
			<p>As we learned previously, Podman <a id="_idIndexMarker341"/>gives us the chance to attach an interactive shell to our running container. However, we will soon discover that this is not the preferred way to run our containers.</p>
			<p>Once a container has been started, we can easily detach from it, even if we start it with an interactive <strong class="source-inline">tty</strong> attached:</p>
			<p class="source-code">$ podman run -i -t registry.fedoraproject.org/f29/httpd</p>
			<p class="source-code">Trying to pull registry.fedoraproject.org/f29/httpd:latest...</p>
			<p class="source-code">Getting image source signatures</p>
			<p class="source-code">Copying blob aaf5ad2e1aa3 done  </p>
			<p class="source-code">Copying blob 7692efc5f81c done  </p>
			<p class="source-code">Copying blob d77ff9f653ce done  </p>
			<p class="source-code">Copying config 25c76f9dcd done  </p>
			<p class="source-code">Writing manifest to image destination</p>
			<p class="source-code">Storing signatures</p>
			<p class="source-code">=&gt; sourcing 10-set-mpm.sh ...</p>
			<p class="source-code">=&gt; sourcing 20-copy-config.sh ...</p>
			<p class="source-code">=&gt; sourcing 40-ssl-certs.sh ...</p>
			<p class="source-code">AH00558: httpd: Could not reliably determine the server’s fully qualified domain name, using 10.0.2.100. Set the ‘ServerName’ directive globally to suppress this message</p>
			<p class="source-code">[Tue Sep 14 09:26:05.691906 2021] [ssl:warn] [pid 1:tid 140416655523200] AH01882: Init: this version of mod_ssl was compiled against a newer library (OpenSSL 1.1.1b FIPS  26 Feb 2019, version currently loaded is OpenSSL 1.1.1 FIPS  11 Sep 2018) - may result in undefined or erroneous behavior</p>
			<p class="source-code">[Tue Sep 14 09:26:05.692610 2021] [ssl:warn] [pid 1:tid 140416655523200] AH01909: 10.0.2.100:8443:0 server certificate does NOT include an ID which matches the server name</p>
			<p class="source-code">AH00558: httpd: Could not reliably determine the server’s fully qualified domain name, using 10.0.2.100. Set the ‘ServerName’ directive globally to suppress this message</p>
			<p class="source-code">[Tue Sep 14 09:26:05.752028 2021] [ssl:warn] [pid 1:tid 140416655523200] AH01882: Init: this version of mod_ssl was compiled against a newer library (OpenSSL 1.1.1b FIPS  26 Feb 2019, version currently loaded is OpenSSL 1.1.1 FIPS  11 Sep 2018) - may result in undefined or erroneous behavior</p>
			<p class="source-code">[Tue Sep 14 09:26:05.752806 2021] [ssl:warn] [pid 1:tid 140416655523200] AH01909: 10.0.2.100:8443:0 server certificate does NOT include an ID which matches the server name</p>
			<p class="source-code">[Tue Sep 14 09:26:05.752933 2021] [lbmethod_heartbeat:notice] [pid 1:tid 140416655523200] AH02282: No slotmem from mod_heartmonitor</p>
			<p class="source-code">[Tue Sep 14 09:26:05.755334 2021] [mpm_event:notice] [pid 1:tid 140416655523200] AH00489: Apache/2.4.39 (Fedora) OpenSSL/1.1.1 configured -- resuming normal operations</p>
			<p class="source-code">[Tue Sep 14 09:26:05.755346 2021] [core:notice] [pid 1:tid 140416655523200] AH00094: Command line: ‘httpd -D FOREGROUND’</p>
			<p>What now? To detach from our running container, we just need to press these special keyboard shortcuts: <em class="italic">Ctrl</em> + <em class="italic">P</em>, <em class="italic">Ctrl</em> + <em class="italic">Q</em>. With this sequence, we will return to our shell prompt while the container will keep running.</p>
			<p>To recover our detached container’s <strong class="source-inline">tty</strong>, we must get the list of running containers:</p>
			<p class="source-code"><strong class="bold">$ podman ps</strong></p>
			<p class="source-code">CONTAINER ID  IMAGE                                        COMMAND               CREATED        STATUS            PORTS       NAMES</p>
			<p class="source-code">685a339917e7  registry.fedoraproject.org/f29/httpd:latest  /usr/bin/run-http...  3 minutes ago  Up 3 minutes ago              clever_zhukovsky</p>
			<p>We will explore <a id="_idIndexMarker342"/>this command in more detail in the next chapter, but for the moment, just take note of <strong class="source-inline">Container ID</strong> and then execute the following command to re-attach to the previous <strong class="source-inline">tty</strong>:</p>
			<p class="source-code">$ podman attach 685a339917e7</p>
			<p>Note that we can easily start a container in <em class="italic">detached</em> mode by simply adding the <strong class="source-inline">-d</strong> option to <strong class="source-inline">podman run</strong>, like this:</p>
			<p class="source-code">$ podman run -d -i -t registry.fedoraproject.org/f29/httpd</p>
			<p>In the next section, we’ll learn how to use the detach option for special purposes.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>Network port publishing</h2>
			<p>As we mentioned in the previous chapters, Podman, like any other container engine, attaches a virtual <a id="_idIndexMarker343"/>network to a container in a running state that has been isolated from the original host network. For this reason, if we want to easily reach our container or even expose it outside our host network, we need to instruct Podman to do port mapping.</p>
			<p>The Podman <strong class="source-inline">-p</strong> option publishes a container’s port to the host:</p>
			<p class="source-code">-p=ip:hostPort:containerPort</p>
			<p>Both <strong class="source-inline">hostPort</strong> and <strong class="source-inline">containerPort</strong> could be a range of ports, and if the host IP is not set or it is set to <strong class="source-inline">0.0.0.0</strong>, then the port will be bound to all the IP addresses of the host.</p>
			<p>If we take back the command we used in the previous section, it becomes the following:</p>
			<p class="source-code">$ podman run -p 8080:8080 -d -i -t \ registry.fedoraproject.org/f29/httpd</p>
			<p>Now, we can take note of what <strong class="source-inline">Container ID</strong> has been assigned to our running container:</p>
			<p class="source-code"><strong class="bold">$ podman ps</strong></p>
			<p class="source-code">CONTAINER ID  IMAGE                                        COMMAND               CREATED         STATUS             PORTS                   NAMES</p>
			<p class="source-code">fc9d97642801  registry.fedoraproject.org/f29/httpd:latest  /usr/bin/run-http...  10 minutes ago  Up 10 minutes ago  0.0.0.0:8080-&gt;8080/tcp  confident_snyder</p>
			<p>Then, we can look at the port mapping we just defined:</p>
			<p class="source-code"><strong class="bold">$ podman port fc9d97642801</strong></p>
			<p class="source-code"><strong class="bold">8080/tcp -&gt; 0.0.0.0:8080</strong></p>
			<p>Next, we can test whether this <a id="_idIndexMarker344"/>port mapping works using <strong class="source-inline">curl</strong>, an easy-to-use HTTP web client. Alternatively, you can point your favorite web browser to the same URL, as follows:</p>
			<p class="source-code"><strong class="bold">$ curl –s 127.0.0.1:8080 | head</strong></p>
			<p class="source-code">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</p>
			<p class="source-code">                                 Dload  Upload   Total   Spent    Left  Speed</p>
			<p class="source-code">100  &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"&gt;</p>
			<p class="source-code">4</p>
			<p class="source-code">6&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;</p>
			<p class="source-code">5    &lt;head&gt;</p>
			<p class="source-code">0         &lt;title&gt;Test Page for the Apache HTTP Server on Fedora&lt;/title&gt;</p>
			<p class="source-code">          &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;</p>
			<p class="source-code">          &lt;style type="text/css"&gt;</p>
			<p class="source-code">1               /*&lt;![CDATA[*/</p>
			<p class="source-code">0               body {</p>
			<p class="source-code">0                     background-color: #fff;</p>
			<p>Before concluding this <a id="_idIndexMarker345"/>chapter, let’s take a look at other interesting options that could be useful for managing configuration and container behavior at runtime.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/>Configuration and environment variables</h2>
			<p>The <strong class="source-inline">podman run</strong> command has tons of options for letting us configure the container behavior at runtime – we <a id="_idIndexMarker346"/>are talking about around 120 options at the time of writing this book. </p>
			<p>For example, we have an option for changing the time zone of our running containers; that is, <strong class="source-inline">--tz</strong>:</p>
			<p class="source-code">$ date</p>
			<p class="source-code">Tue Sep 14 17:44:59 CEST 2021</p>
			<p class="source-code">$ podman run --tz=Asia/Shanghai fedora date</p>
			<p class="source-code">Tue Sep 14 23:45:11 CST 2021</p>
			<p>We can change the DNS of our brand-new container with the <strong class="source-inline">--dns</strong> option:</p>
			<p class="source-code">$ podman run --dns=1.1.1.1 fedora cat /etc/resolv.conf</p>
			<p class="source-code">search lan</p>
			<p class="source-code">nameserver 1.1.1.1</p>
			<p>We can also add a host to the <strong class="source-inline">/etc/hosts</strong> file to override a local internal address:</p>
			<p class="source-code">$ podman run --add-host=my.server.local:192.168.1.10 \</p>
			<p class="source-code">fedora cat /etc/hosts</p>
			<p class="source-code">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</p>
			<p class="source-code">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</p>
			<p class="source-code">192.168.1.10 my.server.local</p>
			<p>We can even add an HTTP proxy to let our container use a proxy for HTTP requests. The default Podman <a id="_idIndexMarker347"/>behavior is to pass many environment variables from the host, some of which are <strong class="source-inline">http_proxy</strong>, <strong class="source-inline">https_proxy</strong>, <strong class="source-inline">ftp_proxy</strong>, and <strong class="source-inline">no_proxy</strong>.</p>
			<p>On the other hand, we can also define custom environment variables that we can pass to our <a id="_idIndexMarker348"/>container thanks to the <strong class="source-inline">–env</strong> option:</p>
			<p class="source-code">$ podman run --env MYENV=podman fedora printenv</p>
			<p class="source-code">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</p>
			<p class="source-code">TERM=xterm</p>
			<p class="source-code">container=oci</p>
			<p class="source-code">DISTTAG=f34container</p>
			<p class="source-code">FGC=f34</p>
			<p class="source-code">MYENV=podman</p>
			<p class="source-code">HOME=/root</p>
			<p class="source-code">HOSTNAME=93f2541180d2</p>
			<p>Adding and using environment variables with our containers is a best practice for passing configuration parameters to the application and influencing the service’s behavior from the operating system host. As we saw in <a href="B17908_01_epub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to Container Technology</em>, containers <a id="_idIndexMarker349"/>are immutable and <a id="_idIndexMarker350"/>ephemeral by default. So, for this reason, we should leverage environment variables, as we did in the preceding example, to configure a container at runtime.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor081"/>Summary</h1>
			<p>In this chapter, we started playing around with Podman’s basic commands, we learned how to run a container by looking at the most interesting options available, and we are now ready to move on to the next level: container management. To work as a system administrator in the container world, we must understand and learn about the management commands that let us inspect and check the health of our running containerized services; that’s what we saw in this chapter.</p>
			<p>In the next chapter, which is deeply focused on container management, we are going to learn how to manage image and container life cycles with Podman. We will learn how to inspect and extract logs from running containers and will also introduce pods, how to create them, and how to run containers within them. </p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor082"/>Further reading</h1>
			<p>For more information about the topics that were covered in this chapter, you can refer to the following resources:</p>
			<ul>
				<li>Installing Podman on MacOS:  <a href="https://podman.io/blogs/2021/09/06/podman-on-macs.html">https://podman.io/blogs/2021/09/06/podman-on-macs.html</a></li>
				<li>Installing Podman on Windows:  <a href="https://www.redhat.com/sysadmin/podman-windows-wsl2">https://www.redhat.com/sysadmin/podman-windows-wsl2</a></li>
				<li>Managing container registries:  <a href="https://www.redhat.com/sysadmin/manage-container-registries">https://www.redhat.com/sysadmin/manage-container-registries</a></li>
				<li>Podman API documentation:  <a href="https://docs.podman.io/en/latest/_static/api.html">https://docs.podman.io/en/latest/_static/api.html</a></li>
				<li>Systemd socker manual:  <a href="https://www.freedesktop.org/software/systemd/man/systemd.socket.html">https://www.freedesktop.org/software/systemd/man/systemd.socket.html</a></li>
				<li>Podman and seccomp profiles:  <a href="https://podman.io/blogs/2019/10/15/generate-seccomp-profiles.html">https://podman.io/blogs/2019/10/15/generate-seccomp-profiles.html</a></li>
			</ul>
		</div>
	</body></html>