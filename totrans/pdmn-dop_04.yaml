- en: '*Chapter 3*: Running the First Container'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we discussed the history of containers, their adoption,
    and the various technologies that contribute to their spread, while also looking
    at the main differences between **Docker** and **Podman**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time to start working with real examples: in this chapter, we will
    learn about how to get Podman up and running on your preferred Linux operating
    system so that we can start our first container. We will discover the various
    installation methods, all the prerequisites, and then start a container.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an operating system and installation method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing your environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running your first container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having good technical experience in administering a Linux operating system would
    be preferable for understanding the key concepts provided in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will go through the main steps of installing new software on various Linux
    distributions, so having some experience as a Linux sysadmin could be helpful
    in troubleshooting possible issues during installation.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, some of the theoretical concepts that were explained in the previous
    chapters could help you understand the procedures described in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an operating system and installation method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Podman is supported on different distributions and operating systems. It is
    very easy to install, and the various distributions now provide their own maintained
    packages that can be installed with their specific package managers.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will cover the different installation steps for the most
    common GNU/Linux distributions, as well as on macOS and Windows, despite the focus
    of this book being on Linux-based environments.
  prefs: []
  type: TYPE_NORMAL
- en: As a bonus topic, we will also learn how to build Podman directly from source.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between Linux distributions and another OS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The choice between the different distributions of the GNU/Linux operating system
    is something that is dictated by the user’s preferences and needs, which are usually
    influenced by several factors that are outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Many advanced users today choose Linux distributions as their main operating
    systems. However, there is a large quota, especially among developers, who stick
    to macOS as their standard operating system. Microsoft Windows still retains the
    largest market share on desktop workstations and laptops.
  prefs: []
  type: TYPE_NORMAL
- en: Today, we have a huge ecosystem of Linux distributions that have evolved from
    a smaller subset of core, historical distributions such as Debian, Fedora, Red
    Hat Enterprise Linux, Gentoo, Arch, and openSUSE. Specialized websites such as
    **DistroWatch** ([https://distrowatch.com](https://distrowatch.com)) keep track
    of the many releases of Linux and BSD-based distributions.
  prefs: []
  type: TYPE_NORMAL
- en: Despite running a Linux kernel, the various distributions have different architectural
    approaches for userspace behavior, such as filesystem structure, libraries, or
    packaging systems used to deliver software releases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another significant difference is related to security and mandatory access
    control subsystems: for example, Fedora, CentOS, Red Hat Enterprise Linux, and
    all the derivates lean on **SELinux** as their mandatory access control subsystem.
    On the other hand, Debian, Ubuntu, and their derivates are based on a similar
    solution called **AppArmor**.'
  prefs: []
  type: TYPE_NORMAL
- en: Podman interacts with both SELinux and AppArmor to provide better container
    isolation, but the underlying interfaces are different.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: All this book’s examples and source code has been written and tested using **Fedora
    Workstation 34** as the reference OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those of you who want to reproduce an environment as close as possible to the
    book in their lab have different options:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the Fedora 34 Vagrant Box ([https://app.vagrantup.com/fedora/boxes/34-cloud-base](https://app.vagrantup.com/fedora/boxes/34-cloud-base)).
    **Vagrant** is a software solution developed by **Hashicorp** to create fast,
    lightweight VMs, especially suitable for development use. See [https://www.vagrantup.com/](https://www.vagrantup.com/)
    for further details about Vagrant and how to use it on your operating system of
    choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directly download the cloud image ([https://alt.fedoraproject.org/cloud/](https://alt.fedoraproject.org/cloud/))
    and create instances on the public/private cloud or just deploy it on a hypervisor
    of your choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually install Fedora Workstation. In this case, the official installation
    guide ([https://docs.fedoraproject.org/en-US/fedora/f34/install-guide/](https://docs.fedoraproject.org/en-US/fedora/f34/install-guide/))
    provides detailed instructions on deploying the OS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running instances on public clouds is the best option for users who are not
    able to run virtual machines locally.
  prefs: []
  type: TYPE_NORMAL
- en: Providers such as Amazon Web Services, Google Cloud Platform, Microsoft Azure,
    and DigitalOcean also offer ready-to-use Fedora-based cloud instances with low
    monthly prices for smaller sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Prices can vary in time and across tiers and keeping track of them is beyond
    the purpose of this book. Almost all providers offer free plans for learning or
    basic use, with small/micro tiers at very low prices.
  prefs: []
  type: TYPE_NORMAL
- en: Containers are Linux-based, and the different container engines and runtimes
    interact with the Linux kernel and libraries to operate. Windows has recently
    introduced support for native containers with an approach to isolation that’s
    quite close to the Linux namespace concepts described previously. However, only
    Windows-based images can run natively and not all container engines support native
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same considerations are valid for macOS: its architecture is not based
    on Linux but on a hybrid Mach/BSD kernel called **XNU**. For this reason, it does
    not offer the Linux kernel features necessary to run containers natively.'
  prefs: []
  type: TYPE_NORMAL
- en: For both Windows and macOS, a virtualization layer that abstracts the Linux
    machine is necessary to run native Linux containers.
  prefs: []
  type: TYPE_NORMAL
- en: Podman offers remote client functions for Windows and macOS, enabling users
    to connect to a local or remote Linux box.
  prefs: []
  type: TYPE_NORMAL
- en: Windows users can also benefit from an alternative approach based on the **Windows
    Subsystem for Linux** (**WSL**) **2.0**, a compatibility layer that runs a lightweight
    VM to expose Linux kernel interfaces along with Linux userspace binaries, thanks
    to Hyper-V virtualization support.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections will cover the necessary steps for installing Podman
    on the most popular Linux distributions, as well as macOS and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Podman on Fedora
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fedora packages are maintained by its wide community and managed with the **DNF**
    package manager. To install Podman, run the following command from a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This command installs Podman and configures the environment with config files
    (covered in the next section). It also installs `systemd` units to provide additional
    features such as REST API services or container auto-updates.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Podman on CentOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Podman can be installed on CentOS 7, CentOS 8, and CentOS Stream ([https://www.centos.org/](https://www.centos.org/)).
    Users installing on CentOS 7 must have the **Extras** repository enabled, while
    users installing on CentOS 8 and Stream must have the Podman package available
    from the already enabled **AppStream** repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Podman, run the following command from a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Like in Fedora, this command installs Podman and all its dependencies, including
    config files and `systemd` unit files.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Podman on RHEL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To install Podman on **Red Hat Enterprise Linux** (**RHEL**) ([https://www.redhat.com/en/technologies/linux-platforms/enterprise-linux](https://www.redhat.com/en/technologies/linux-platforms/enterprise-linux)),
    users should follow two different procedures on RHEL 7 and RHEL 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'On RHEL 7, users must enable the extra channel and then install the Podman
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'On RHEL 8, the Podman package is available on a dedicated module called **container-tools**.
    Modules are custom sets of RPM packages that can be organized in streams with
    independent release cycles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `container-tools` module installs, along with Podman, two useful tools,
    both of which will be covered later in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Skopeo**, a tool for managing OCI images and registries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Buildah**, a specialized tool for building custom OCI images from Dockerfiles
    and from scratch'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Not) Installing Podman on Fedora CoreOS and Fedora Silverblue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The title of this subsection is a bit of a joke. The reality is that Podman
    is already installed on both distributions and is a crucial tool for running containerized
    workloads.
  prefs: []
  type: TYPE_NORMAL
- en: The **Fedora CoreOS** and **Fedora SilverBlue** distributions are immutable,
    atomic operating systems aimed to be used on server/cloud and desktop environments,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Fedora CoreOS ([https://getfedora.org/en/coreos/](https://getfedora.org/en/coreos/))
    is the upstream of Red Hat CoreOS, the operating system used to run Red Hat OpenShift
    and the base OS of **OpenShift Kubernetes Distribution** (**OKD**), the community-based
    Kubernetes distribution used as the upstream of Red Hat OpenShift.
  prefs: []
  type: TYPE_NORMAL
- en: Fedora Silverblue ([https://silverblue.fedoraproject.org/](https://silverblue.fedoraproject.org/))
    is a desktop-focused immutable operating system that aims to provide a stable
    and comfortable desktop user experience, especially for developers working with
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: So, on both Fedora CoreOS and Fedora Silverblue, just open a terminal and run
    Podman.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Podman on Debian
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Podman package is available on **Debian** ([https://www.debian.org/](https://www.debian.org/))
    since version 11, codename Bullseye (named after the famous toy horse from the
    Toy Story 2 and 3 movies).
  prefs: []
  type: TYPE_NORMAL
- en: Debian uses the `apt-get` package handling utility to install and upgrade system
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Podman on a Debian system, run the following command from the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command installs the Podman binary and its dependencies, along
    with its config files, `systemd` units, and man pages.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Podman on Ubuntu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Being built on Debian, **Ubuntu** ([https://ubuntu.com/](https://ubuntu.com/))
    behaves in an analogous way for package management. To install Podman on Ubuntu
    20.10 or later, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: These two commands update the system packages and then install the Podman binaries
    and related dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Podman on openSUSE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **openSUSE** distribution ([https://www.opensuse.org/](https://www.opensuse.org/))
    is backed by SUSE and is available in two different flavors – the rolling release
    known as **Tumbleweed,** and the LTS distribution known as **Leap**. Podman is
    available in the openSUSE repositories and can be installed with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The Zypper package manager will download and install all the necessary packages
    and dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Podman on Gentoo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Gentoo** ([https://www.gentoo.org/](https://www.gentoo.org/)) is a clever
    distribution that is characterized by building installed packages directly on
    the target machine with the optional extra user customizations. To achieve this,
    it uses the **Portage** package manager, inspired by FreeBSD ports.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Podman on Gentoo, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `emerge` utility will download and automatically build the Podman sources
    on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Podman on Arch Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Arch Linux** ([https://archlinux.org/](https://archlinux.org/)) is a rolling
    Linux distribution that shines for being highly customizable. It uses the **pacman**
    package manager to install and update packages from official and users'' custom
    repositories.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Podman on Arch Linux and derivate distributions, run the following
    command from the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, Podman’s installation on Arch Linux does not permit rootless containers.
    To enable them, follow the official Arch wiki instructions: [https://wiki.archlinux.org/title/Podman#Rootless_Podman](https://wiki.archlinux.org/title/Podman#Rootless_Podman).'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Podman on Raspberry Pi OS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The famous Raspberry Pi single-board computer has achieved enormous success
    among developers, makers, and hobbyists.
  prefs: []
  type: TYPE_NORMAL
- en: It runs the Raspberry Pi OS ([https://www.raspberrypi.org/software/operating-systems/#raspberry-pi-os-32-bit](https://www.raspberrypi.org/software/operating-systems/#raspberry-pi-os-32-bit)),
    which is based on Debian.
  prefs: []
  type: TYPE_NORMAL
- en: Podman’s arm64 build is available and can be installed by following the same
    steps described previously for the Debian distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Podman on macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apple users who develop and run Linux containers can install and use Podman
    as a remote client, while the containers are executed on a remote Linux box. The
    Linux machine can also be a VM that’s executed on macOS and directly managed by
    Podman.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Podman using the Homebrew package manager, run the following command
    from the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To initialize the VM running the Linux box, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, users can create and connect to an external Linux host.
  prefs: []
  type: TYPE_NORMAL
- en: Another valid approach on macOS to creating fast, lightweight VMs for development
    use is Vagrant. When the Vagrant machine is created, users can manually or automatically
    provision additional software such as Podman and start using the customized instance
    using the remote client.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Podman on Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To run Podman as a remote client, simply download and install the latest release
    from the GitHub releases page ([https://github.com/containers/podman/releases/](https://github.com/containers/podman/releases/)).
    Extract the archive in a suitable location and edit the TOML-encoded `containers.conf`
    file to configure a remote URI for the Linux machine or pass additional options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows an example configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The remote Linux machine exposes Podman on a UNIX socket managed by a `systemd`
    unit. We will cover this topic in greater detail later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: To run Podman on WSL 2.0, users must first install a Linux distribution from
    the Microsoft Store on their Windows host. There is a variety of available distributions
    under the Microsoft catalog.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is based on Ubuntu 20.10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding commands install the latest Podman stable release and configure
    the `/etc/containers/registries.conf` file to provide a registries whitelist.
  prefs: []
  type: TYPE_NORMAL
- en: 'After its installation, some minor customizations are necessary to adapt it
    to the WSL 2.0 environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command configures logging and CGroup management to successfully
    run rootful containers in the subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: Building Podman from source
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Building an application from source has many advantages: users can inspect
    and customize code before building, cross-compile for different architectures,
    or selectively build only a subset of binaries. It is also a great learning opportunity
    to get into the project’s structure and understand its evolution. Last but not
    least, building from source lets the users get the latest development versions
    with cool new features, bugs included.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps assume that the building machine is a Fedora distribution.
    First, we must install the necessary dependencies needed to compile Podman:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This command will take a while to install all the packages and their cascading
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the installation is complete, choose a working directory and clone the
    Podman repository using the `git` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This command will clone the entire repository in the working directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change to the project directory and start the build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `make package-install` command compiles the source code, builds the RPM
    files, and installs the packages locally. Remember that the RPM format is associated
    with Fedora/CentOS/RHEL distributions and managed by the `dnf` and `yum` package
    managers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The build process will take a few minutes to complete. To test the successful
    installation of the packages, simply run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, it is useful to build the binaries on a dedicated build host and
    then deploy them on other machines, using either package managers or simple archives.
    To only build the binaries, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the build, the binaries will be available under the `bin/` folder.
    To install the compiled binaries and config files locally by simply copying them
    into the target directories defined in the Makefile, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a binary release similar to the `.tar.gz` archive, which is available
    on the GitHub release page, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`git` command. For example, to build v3.3.1, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we learned how to install binary releases of Podman on different
    distributions using their respective package managers. We also learned how to
    install the Podman remote client on macOS and Windows, along with Windows WSL
    2.0 mode. We closed this section by showing you how to build from source.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to configure Podman for the first run
    by preparing the system environment.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing your environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the Podman packages have been installed, Podman is ready to be used *out
    of the box*. However, some minor customizations can be useful to provide better
    interoperability with external registries or to customize runtime behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the container registries search list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Podman searches for and downloads images from a list of trusted container registries.
    The `/etc/containers/registries.conf` file is a TOML config file that can be used
    to customize whitelisted registries that are allowed to be searched and used as
    image sources, as well as registry mirroring and insecure registries without TLS
    termination.
  prefs: []
  type: TYPE_NORMAL
- en: In this config file, the `unqualified-search-registries` key is populated with
    an array of unqualified registries with no specification regarding images repositories
    and tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a Fedora system, with a new installation of Podman, this key has the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Users can add or remove registries from this array to let Podman search and
    pull from them.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Be very cautious when adding registries and use only trusted registries to avoid
    pulling images containing malicious code.
  prefs: []
  type: TYPE_NORMAL
- en: The default list is adequate to search for and run all the book examples. Those
    of you who are already running private registries can try to add them to the unqualified
    search registries array.
  prefs: []
  type: TYPE_NORMAL
- en: Since registries are both private and public, please keep in mind that private
    registries usually require additional authentication to be accessed. This can
    be accomplished with the `podman login` command, which will be covered later in
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: If the `$HOME/.config/containers/registries.conf` file is found in the user
    home, it overrides the `/etc/containers/registries.conf` file. In this way, different
    users on the same system will be able to run Podman with their custom registry
    whitelists and mirrors.
  prefs: []
  type: TYPE_NORMAL
- en: Optional – enable socket-based services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is an optional step and, in the absence of specific needs, this section’s
    contents can be safely skipped.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, Podman is a daemonless container manager that needs
    no background service to run containers. However, users may need to interact with
    the Libpod APIs exposed by Podman, especially when migrating from a Docker-based
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Podman can expose its APIs using a UNIX socket (default behavior) or a TCP socket.
    The latter option is less secure because it makes Podman accessible from the outside
    world, but it is necessary in some cases, such as when it should be accessed by
    a Podman client on a Windows or macOS workstation.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when running the API service using a TCP endpoint on a machine exposed
    to the internet since the service will be globally accessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command exposes the Podman APIs on a UNIX socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: After running this command, users can connect to the API service.
  prefs: []
  type: TYPE_NORMAL
- en: Having to run this command on a terminal window is not a handy approach. Instead,
    the best approach is to use a `man systemd.socket`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Socket units in `systemd` are special kinds of service activators: when a request
    reaches the pre-defined endpoint of the socket, `systemd` immediately spawns the
    homonymous service.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When Podman is installed, the `podman.socket` and `podman.service` unit files
    are created. `podman.socket` has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ListenStream` key holds the relative path of the socket, which is expanded
    to `/run/podman/podman.sock`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The podman.service has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `ExecStart=` field indicates the command to be launched by the service,
    which is the same `podman system service` command we showed previously.
  prefs: []
  type: TYPE_NORMAL
- en: The `Requires=` field indicates that the `podman.service` unit needs `podman.socket`
    to be activated.
  prefs: []
  type: TYPE_NORMAL
- en: So, what happens when we enable and start the `podman.socket` unit? `systemd`
    handles the socket and waits for a connection to the socket endpoint. When this
    event happens, it immediately starts the `podman.service` unit. After a period
    of inactivity, the service is stopped again.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable and start the socket unit, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test the results with a simple `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The printed output will be a JSON payload that contains the container engine
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: What happened when we hit the URL? Under the hood, the service unit was immediately
    started and triggered by the socket when the connection was issued. Some of you
    may have noticed a slight delay (in the order of a 1/10th of a second) the very
    first time the command was executed.
  prefs: []
  type: TYPE_NORMAL
- en: After 5 seconds of inactivity, `podman.service` deactivates again. This is due
    to the default behavior of the `podman system service` command, which runs for
    5 seconds only by default unless the `–time` option is passed to provide a different
    timeout (a value of 0 means forever).
  prefs: []
  type: TYPE_NORMAL
- en: Optional – customize Podman’s behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Podman’s default configuration works out of the box for most use cases, but
    its configuration is highly flexible. The following configuration files are available
    for customizing its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '`containers.conf`: This TOML-formatted file holds Podman runtime configurations,
    as well as search paths for `conmon` and container runtime binaries. It is installed
    by default under the `/usr/share/containers/` path and can be overridden by the
    `/etc/containers/containers.conf` and `$HOME/.config/containers/containers.conf`
    files for system-wide and user-wide settings, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This file can be used to customize the behavior of the engine. Users can influence
    how the container is created and its life cycle by customizing settings such as
    logging, DNS resolution, environment variables, shared memory usage, Cgroup management,
    and many others.
  prefs: []
  type: TYPE_NORMAL
- en: For a full list of settings, check out the related `man` page, which was installed
    along with the Podman package. (`man containers.conf`)
  prefs: []
  type: TYPE_NORMAL
- en: '`storage.conf`: This TOML-formatted file is used to customize the storage settings
    that are used by the container engine. In particular, this file enables you to
    customize the default storage driver, as well as the read/write directory of the
    container storage (also known as the graph root), which is an additional driver
    storage option. By default, the driver is set to **overlay**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default path of this file is `/usr/share/containers/storage.conf` and overrides
    can be found or created under `/etc/containers/storage.conf` for system-wide customizations.
  prefs: []
  type: TYPE_NORMAL
- en: User-scoped configurations that impact rootless containers can be found under
    `$XDG_CONFIG_HOME/containers/storage.conf` or `$HOME/.config/containers/storage.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: '`mounts.conf`: This file defines the volume mounts that should be automatically
    mounted inside a container when it is started. This is useful, for example, to
    automatically pass secrets such as keys and certificates inside a container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be found under `/usr/share/containers/mounts.conf` and overridden by
    a file located at `/etc/containers/mounts.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: In rootless mode, the override file can be placed under `$HOME/.config/containers/mounts.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: '`seccomp.json`: This is a JSON file that lets users customize the allowed `syscalls`
    that a process inside a container can perform and define the blocked ones at the
    same time. This topic will be covered again in [*Chapter 11*](B17908_11_epub.xhtml#_idTextAnchor206),
    *Securing Containers*, which will provide a deeper understanding of the security
    constraints of containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default path for this file is `/usr/share/containers/seccomp.json`. The
    seccomp man page (`man seccomp`) provides an overview of how seccomp works on
    a Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: '`policy.json`: This is a JSON file that defines how Podman will perform signature
    verification. The default path of this file is `/etc/containers/policy.json` and
    can be overridden by the user-scoped `$HOME/.config/containers/policy.json`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This config file accepts three kinds of policies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**insecureAcceptAnything**: Accept any image from the specified registry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**reject**: Reject any image from the specified registry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**signedBy**: Accept only images signed by a specific, known entity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default configuration is to accept every image (the `insecureAcceptAnything`
    policy), but it can be modified to pull only trusted images that can be verified
    by a signature. Users can define custom GPG keys to verify the signatures and
    the identity that signed them. For extra details about the possible policies and
    configuration examples, please refer to the related man page (`man containers-policy.json`).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed some basic configurations of Podman that are useful
    to know from when Podman is first installed. In the next section, we will cover
    our first container execution examples.
  prefs: []
  type: TYPE_NORMAL
- en: Running your first container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it’s time to finally run our first container.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we uncovered how to install Podman on our favorite
    Linux distribution, as well as what’s included in the base packages once installed.
    Now, we can start using our daemonless container engine.
  prefs: []
  type: TYPE_NORMAL
- en: Running containers in Podman is handled through the `podman run` command, which
    accepts many options for controlling the behavior of the just ran container, its
    isolation, its communication, its storage, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest and shortest Podman command for running a brand-new container is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We have to replace the `imageID` string with the image name/location/tag we
    want to run. If the image is not present in the cache or we have not downloaded
    it before, Podman will pull the image for us from the respective container registry.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive and pseudo-tty
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To introduce this command and its options, let’s start simple and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see what Podman did once we executed the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: It recognized the image’s name, `fedora`, as an alias for the latest Fedora
    container image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It then realized that the image was missing from the local cache because it
    was the first time that we tried to run it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It pulled down the image from the right registry. It chose the Fedora Project
    registry because it matched the aliases contained in the registries’ configurations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, it started the container and presented us with an interactive shell,
    executing the Bash shell program that we requested.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The previous command prompted an interactive shell thanks to the two options
    that we can analyze, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--tty, -t`: With this option, Podman allocates a `man pty`) and attaches it
    to the container’s standard input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--interactive, -i`: With this option, Podman keeps `stdin` open and ready
    to be attached to the previous pseudo-tty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As stated in the previous chapters, when a container is created, the isolated
    processes inside it will run on a writable root filesystem, as a result of a layered
    overlay.
  prefs: []
  type: TYPE_NORMAL
- en: This allows any process to write files, but don’t forget that they will last
    until the container is running, as containers are ephemeral by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can execute any command and check its output in the console we just
    brought up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in the previous example, we just installed two packages for
    inspecting the container’s network configuration and then executing a ping to
    the default router that’s assigned to the virtual networking of our running container.
    Again, if we stop this container, any changes will be lost.
  prefs: []
  type: TYPE_NORMAL
- en: To exit this interactive shell, we can just press *Ctrl* + *D* or execute the
    `exit` command. By doing this, the container will be terminated because the main
    running process we requested to execute (`/bin/bash`) will stop!
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at some other nice and useful options we can use with the `podman
    run` command.
  prefs: []
  type: TYPE_NORMAL
- en: Detaching from a running container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we learned previously, Podman gives us the chance to attach an interactive
    shell to our running container. However, we will soon discover that this is not
    the preferred way to run our containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a container has been started, we can easily detach from it, even if we
    start it with an interactive `tty` attached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'What now? To detach from our running container, we just need to press these
    special keyboard shortcuts: *Ctrl* + *P*, *Ctrl* + *Q*. With this sequence, we
    will return to our shell prompt while the container will keep running.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To recover our detached container’s `tty`, we must get the list of running
    containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We will explore this command in more detail in the next chapter, but for the
    moment, just take note of `Container ID` and then execute the following command
    to re-attach to the previous `tty`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we can easily start a container in *detached* mode by simply adding
    the `-d` option to `podman run`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we’ll learn how to use the detach option for special purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Network port publishing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned in the previous chapters, Podman, like any other container engine,
    attaches a virtual network to a container in a running state that has been isolated
    from the original host network. For this reason, if we want to easily reach our
    container or even expose it outside our host network, we need to instruct Podman
    to do port mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Podman `-p` option publishes a container’s port to the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Both `hostPort` and `containerPort` could be a range of ports, and if the host
    IP is not set or it is set to `0.0.0.0`, then the port will be bound to all the
    IP addresses of the host.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take back the command we used in the previous section, it becomes the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can take note of what `Container ID` has been assigned to our running
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can look at the port mapping we just defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can test whether this port mapping works using `curl`, an easy-to-use
    HTTP web client. Alternatively, you can point your favorite web browser to the
    same URL, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Before concluding this chapter, let’s take a look at other interesting options
    that could be useful for managing configuration and container behavior at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration and environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `podman run` command has tons of options for letting us configure the container
    behavior at runtime – we are talking about around 120 options at the time of writing
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we have an option for changing the time zone of our running containers;
    that is, `--tz`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can change the DNS of our brand-new container with the `--dns` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add a host to the `/etc/hosts` file to override a local internal
    address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We can even add an HTTP proxy to let our container use a proxy for HTTP requests.
    The default Podman behavior is to pass many environment variables from the host,
    some of which are `http_proxy`, `https_proxy`, `ftp_proxy`, and `no_proxy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, we can also define custom environment variables that we
    can pass to our container thanks to the `–env` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Adding and using environment variables with our containers is a best practice
    for passing configuration parameters to the application and influencing the service’s
    behavior from the operating system host. As we saw in [*Chapter 1*](B17908_01_epub.xhtml#_idTextAnchor015),
    *Introduction to Container Technology*, containers are immutable and ephemeral
    by default. So, for this reason, we should leverage environment variables, as
    we did in the preceding example, to configure a container at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we started playing around with Podman’s basic commands, we
    learned how to run a container by looking at the most interesting options available,
    and we are now ready to move on to the next level: container management. To work
    as a system administrator in the container world, we must understand and learn
    about the management commands that let us inspect and check the health of our
    running containerized services; that’s what we saw in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, which is deeply focused on container management, we are
    going to learn how to manage image and container life cycles with Podman. We will
    learn how to inspect and extract logs from running containers and will also introduce
    pods, how to create them, and how to run containers within them.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information about the topics that were covered in this chapter, you
    can refer to the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing Podman on MacOS: [https://podman.io/blogs/2021/09/06/podman-on-macs.html](https://podman.io/blogs/2021/09/06/podman-on-macs.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Installing Podman on Windows: [https://www.redhat.com/sysadmin/podman-windows-wsl2](https://www.redhat.com/sysadmin/podman-windows-wsl2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Managing container registries: [https://www.redhat.com/sysadmin/manage-container-registries](https://www.redhat.com/sysadmin/manage-container-registries)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Podman API documentation: [https://docs.podman.io/en/latest/_static/api.html](https://docs.podman.io/en/latest/_static/api.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Systemd socker manual: [https://www.freedesktop.org/software/systemd/man/systemd.socket.html](https://www.freedesktop.org/software/systemd/man/systemd.socket.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Podman and seccomp profiles: [https://podman.io/blogs/2019/10/15/generate-seccomp-profiles.html](https://podman.io/blogs/2019/10/15/generate-seccomp-profiles.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
