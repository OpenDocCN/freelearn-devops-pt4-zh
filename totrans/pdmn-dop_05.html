<html><head></head><body>
		<div id="_idContainer024">
			<h1 id="_idParaDest-84"><em class="italic"><a id="_idTextAnchor083"/>Chapter <a id="_idTextAnchor084"/>4</em>: Managing Running Containers</h1>
			<p>In the previous chapter, we learned how to set up the environment to run containers with Podman, covering binary installation for the major distributions, system configuration files, and a first example container run to verify that our setup was correct. This chapter will offer a more detailed overview of container execution, how to manage and inspect running containers, and how to group containers in pods. This chapter is important for gaining the right knowledge and expertise to start our experience as a system administrator for container technologies.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Managing container images</li>
				<li>Operations with running containers</li>
				<li>Inspecting container information</li>
				<li>Capturing logs from containers</li>
				<li>Executing processes in a running container</li>
				<li>Running containers in pods</li>
			</ul>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor085"/>Technical requirements</h1>
			<p>Before proceeding with this chapter and its exercises, a machine with a working Podman instance is required. As stated in <a href="B17908_03_epub.xhtml#_idTextAnchor068"><em class="italic">Chapter 3</em></a>, <em class="italic">Running the First Container</em>, all the examples in the book are executed on a Fedora 34 system, but can be reproduced on an <strong class="bold">operating system</strong> (<strong class="bold">OS</strong>) of your choice.</p>
			<p>Finally, a good understanding of the topics covered in the previous chapters is useful to easily grasp concepts regarding <strong class="bold">Open Container Initiative</strong> (<strong class="bold">OCI</strong>) images and container execution.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor086"/>Managing container images</h1>
			<p>In this section, we will see how to find and pull (download) an image in the local system, as well as <a id="_idIndexMarker351"/>inspect its contents. When a container is created and run for the first time, Podman takes care of pulling the related image automatically. However, being able to pull and inspect images in advance gives some valuable advantages, the first being that a container executes faster when images are already available in the machine's local store.</p>
			<p>As we stated in the previous chapters, containers are a way to isolate processes in a sandboxed environment with separate namespaces and resource allocation.</p>
			<p>The filesystem mounted in the container is provided by the OCI image described in <a href="B17908_02_epub.xhtml#_idTextAnchor044"><em class="italic">Chapter 2</em></a>, <em class="italic">Comparing Podman and Docker </em>. </p>
			<p>OCI images are stored <a id="_idIndexMarker352"/>and distributed by specialized services called <strong class="bold">container registries</strong>. A container registry stores images and metadata and exposes <a id="_idIndexMarker353"/>simple <strong class="bold">REpresentational State Transfer</strong> (<strong class="bold">REST</strong>) <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) services to enable <a id="_idIndexMarker354"/>users to push and pull images.</p>
			<p>There are essentially two types of registries: public and private. A public registry is accessible as a public service (with or without authentication). The main public registries such as <strong class="source-inline">docker.io</strong>, <strong class="source-inline">gcr.io</strong>, or <strong class="source-inline">quay.io</strong> are also used as the image repositories of larger open source projects.</p>
			<p>Private registries are deployed and managed inside an organization and can be more focused on security and content filtering. The main container registry projects nowadays are <a id="_idIndexMarker355"/>graduated under the <strong class="bold">Cloud Native Computing Foundation</strong> (<strong class="bold">CNCF</strong>) (<a href="https://landscape.cncf.io/card-mode?category=container-registry&amp;grouping=category">https://landscape.cncf.io/card-mode?category=container-registry&amp;grouping=category</a>) and offer advanced enterprise <a id="_idIndexMarker356"/>features to manage multitenancy, authentication, and <strong class="bold">role-based access control</strong> (<strong class="bold">RBAC</strong>), as well as image vulnerability scanning and image signing. </p>
			<p>In <a href="B17908_09_epub.xhtml#_idTextAnchor167"><em class="italic">Chapter 9</em></a>, <em class="italic">Pushing Images to a Container Registry</em>, we will provide more details and examples of interaction with container registries.</p>
			<p>The largest <a id="_idIndexMarker357"/>part of public and private registries <a id="_idIndexMarker358"/>expose Docker Registry HTTP API V2 (<a href="https://docs.docker.com/registry/spec/api/">https://docs.docker.com/registry/spec/api/</a>). Being a <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>)-based REST API, users could interact with the registry with a simple <strong class="source-inline">curl</strong> command or design their own custom clients.</p>
			<p>Podman <a id="_idIndexMarker359"/>offers a <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) to interact with public and private container registries, manage logins when registry authentication is required, search for image repositories by passing a string pattern, and handle locally cached images.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor087"/>Searching for images</h2>
			<p>The first command <a id="_idIndexMarker360"/>we will learn to use to search images across multiple registries is the <strong class="source-inline">podman search</strong> command. The following example shows how to search an nginx image:</p>
			<p class="source-code"># podman search nginx </p>
			<p>The preceding command will produce an output with many entries from all the whitelisted registries (see the <em class="italic">Preparing your environment</em> | <em class="italic">Customizing container registries' search lists</em> section of <a href="B17908_03_epub.xhtml#_idTextAnchor068"><em class="italic">Chapter 3</em></a>, <em class="italic">Running the First Container</em>). The output will be a little clumsy, with many entries from unknown and unreliable repositories.</p>
			<p>In general, the <strong class="source-inline">podman search</strong> command accepts the following pattern:</p>
			<p class="source-code">podman search [options] TERM</p>
			<p>Here, <strong class="source-inline">TERM</strong> is the search argument. The resulting output of a search has the following fields:</p>
			<ul>
				<li><strong class="source-inline">INDEX</strong>: The registry indexing the image</li>
				<li><strong class="source-inline">NAME</strong>: The full name of the image, including the registry name and associated namespaces</li>
				<li><strong class="source-inline">DESCRIPTION</strong>: A short description of the image role</li>
				<li><strong class="source-inline">STARS</strong>: The number of stars given by users (available only on registries supporting this feature, such as <strong class="source-inline">docker.io</strong>)</li>
				<li><strong class="source-inline">OFFICIAL</strong>: A Boolean for specifying whether the image is official</li>
				<li><strong class="source-inline">AUTOMATED</strong>: A field set to <strong class="source-inline">OK</strong> if the image is automated<p class="callout-heading">Important Note</p><p class="callout">Never trust unknown repositories and always prefer official images. When pulling images from a niche project, try to understand the content of the image before running it. Remember that an attacker could hide malicious code that could be executed inside containers. </p><p class="callout">Even trusted repositories can be compromised in some cases. In enterprise scenarios, implement image signature verification to avoid image tampering.</p></li>
			</ul>
			<p>It is possible <a id="_idIndexMarker361"/>to apply filters to the search and refine the output. For example, to refine the search and print only official images, we can add the following filtering option that only prints out images with the <strong class="source-inline">is-official</strong> flag:</p>
			<p class="source-code"># podman search nginx --filter=is-official</p>
			<p>This command will print one line pointing to <strong class="source-inline">docker.io/library/nginx:latest</strong>. This official image is maintained by the nginx community and can be used more confidently.</p>
			<p>Users can refine the output format of the command. The following example shows how to print only the image registry and the image name:</p>
			<p class="source-code"># podman search fedora  \</p>
			<p class="source-code">  --filter is-official \</p>
			<p class="source-code">  --format "table {{.Index}} {{.Name}}"</p>
			<p class="source-code"> </p>
			<p class="source-code">INDEX       NAME</p>
			<p class="source-code">docker.io   docker.io/library/fedora</p>
			<p>The output image name has a standard naming pattern that deserves a detailed description. The standard format is shown here:</p>
			<p class="source-code">&lt;registry&gt;[:&lt;port&gt;]/[&lt;namespace&gt;/]&lt;name&gt;:&lt;tag&gt;</p>
			<p>Let's describe the preceding fields in detail, as follows:</p>
			<ul>
				<li><strong class="source-inline">registry</strong>: This contains <a id="_idIndexMarker362"/>the registry the image is stored in. The nginx image in our example is stored in the <strong class="source-inline">docker.io</strong> public registry. Optionally, it is possible to <a id="_idIndexMarker363"/>specify a custom port number for the registry. By default, registries expose the <strong class="source-inline">5000</strong> <strong class="bold">Transmission Control Protocol</strong> (<strong class="bold">TCP</strong>) port.</li>
				<li><strong class="source-inline">namespace</strong>: This field <a id="_idIndexMarker364"/>provides a hierarchy structure that is useful for distinguishing the image context from the provider. The namespace could represent the parent organization, the username of the owner of the repository, or the image role. </li>
				<li><strong class="source-inline">name</strong>: This contains <a id="_idIndexMarker365"/>the name of the private/public image repository where all the tags are stored. It is often referred to as the application name (that is, nginx).</li>
				<li><strong class="source-inline">tag</strong>: Every image stored in the registry has <a id="_idIndexMarker366"/>a unique tag, mapped <a id="_idIndexMarker367"/>to a <strong class="bold">Secure Hash Algorithm 256</strong> (<strong class="bold">SHA256</strong>) digest. The generic <strong class="source-inline">:latest</strong> tag can be omitted in the image name.</li>
			</ul>
			<p>The generic <a id="_idIndexMarker368"/>search hides the image tags by default. To show all available tags for a given repository, we can use the <strong class="source-inline">–list-tags</strong> option to a given image name, as follows:</p>
			<p class="source-code"><strong class="bold"># podman search quay.io/prometheus/prometheus --list-tags</strong></p>
			<p class="source-code">NAME                           TAGquay.io/prometheus/prometheus  v2.5.0</p>
			<p class="source-code">quay.io/prometheus/prometheus  v2.6.0-rc.0</p>
			<p class="source-code">quay.io/prometheus/prometheus  v2.6.0-rc.1</p>
			<p class="source-code">quay.io/prometheus/prometheus  v2.6.0</p>
			<p class="source-code">quay.io/prometheus/prometheus  v2.6.1</p>
			<p class="source-code">quay.io/prometheus/prometheus  v2.7.0-rc.0</p>
			<p class="source-code">quay.io/prometheus/prometheus  v2.7.0-rc.1</p>
			<p class="source-code">quay.io/prometheus/prometheus  v2.7.0-rc.2</p>
			<p class="source-code">quay.io/prometheus/prometheus  v2.7.0</p>
			<p class="source-code">quay.io/prometheus/prometheus  v2.7.1</p>
			<p class="source-code">[...output omitted...]</p>
			<p>This option <a id="_idIndexMarker369"/>is really useful for finding a specific image tag in the registry, often associated with a release version of the application/runtime. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Using the <strong class="source-inline">:latest</strong> tag can lead to image versioning issues since it is not a descriptive tag. Also, it is usually expected to point to the latest image version. Unfortunately, this is not always true since an untagged image could retain the latest tag while the latest pushed image could have a different tag. It is up to the repository maintainer to apply tags correctly. If the repository uses semantic versioning, the best option is to pull the most recent version tag.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor088"/>Pulling and viewing images</h2>
			<p>Once we <a id="_idIndexMarker370"/>have found our desired image, it can be downloaded <a id="_idIndexMarker371"/>using the <strong class="source-inline">podman pull</strong> command, as follows:</p>
			<p class="source-code"># podman pull docker.io/library/nginx:latest</p>
			<p>Notice the root user for running the Podman command. In this case, we are pulling the image as root, and its layers and metadata are stored in the <strong class="source-inline">/var/lib/containers/storage</strong> path.</p>
			<p>We can run the same command as a standard user by executing the command in a standard user's shell, like this: </p>
			<p class="source-code">$ podman pull docker.io/library/nginx:latest</p>
			<p>In this case, the image will be downloaded in the user home directory under <strong class="source-inline">$HOME/.local/share/containers/storage/</strong> and will be available to run rootless containers.</p>
			<p>Users can inspect all locally cached images with the <strong class="source-inline">podman images</strong> command, as illustrated here:</p>
			<p class="source-code"><strong class="bold"># podman images</strong></p>
			<p class="source-code">REPOSITORY                  TAG         IMAGE ID      CREATED        SIZE</p>
			<p class="source-code">docker.io/library/nginx     latest      ad4c705f24d3  2 weeks ago    138 MB</p>
			<p class="source-code">docker.io/library/fedora    latest      dce66322d647  2 months ago   184 MB</p>
			<p class="source-code">[...omitted output...]</p>
			<p>The <a id="_idIndexMarker372"/>output <a id="_idIndexMarker373"/>shows the image repository name, its tag, the image <strong class="bold">identifier</strong> (<strong class="bold">ID</strong>), the creation date, and the image size. It is very useful to keep an updated view of the images available in the local store and understand which ones are obsolete.</p>
			<p>The <strong class="source-inline">podman images</strong> command <a id="_idIndexMarker374"/>also supports many options (a complete list is available by executing the <strong class="source-inline">man podman-images</strong> command). One of the more interesting options is <strong class="source-inline">–sort</strong>, which can be used to sort images by size, date, ID, repository, or tag. For example, we could print images sorted by creation date to find out the most obsolete ones, as follows:</p>
			<p class="source-code"># podman images --sort=created</p>
			<p>Another couple of very useful options are the <strong class="source-inline">–all</strong> (or <strong class="source-inline">–a</strong>) and <strong class="source-inline">–quiet</strong> (or <strong class="source-inline">–q</strong>) options. Together, they can be combined to print only the image IDs of all the locally stored images, even intermediate image layers. The command will print output similar to the following example:</p>
			<p class="source-code"><strong class="bold"># podman images -qa</strong></p>
			<p class="source-code">ad4c705f24d3</p>
			<p class="source-code">a56f85702a94</p>
			<p class="source-code">b5c5125e3fee</p>
			<p class="source-code">4d7fc5917f3e</p>
			<p class="source-code">625707533167</p>
			<p class="source-code">f881f1aa4d65</p>
			<p class="source-code">96ab2a326180</p>
			<p>Listing <a id="_idIndexMarker375"/>and showing the images already pulled on a system it <a id="_idIndexMarker376"/>is not the most interesting part of the job! Let's discover how to inspect images with their configuration and contents in the next section.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor089"/>Inspecting images' configurations and contents</h2>
			<p>To inspect <a id="_idIndexMarker377"/>the configuration of a pulled image, the <strong class="source-inline">podman image inspect</strong> (or the shorter <strong class="source-inline">podman inspect</strong>) command comes to help us, as illustrated here:</p>
			<p class="source-code"># podman inspect docker.io/library/nginx:latest</p>
			<p>The printed <a id="_idIndexMarker378"/>output will be a <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>)-formatted object containing the image config, architecture, layers, labels, annotation, and the image build history.</p>
			<p>The image history shows the creation history of every layer and is very useful for understanding how the image was built when the Dockerfile or the Containerfile is not available.</p>
			<p>Since the output is a JSON object, we can extract single fields to collect specific data or use them as input parameters for other commands. </p>
			<p>The following example prints out the command executed when a container is created upon this image:</p>
			<p class="source-code"># podman inspect docker.io/library/nginx:latest \</p>
			<p class="source-code">--format "{{ .Config.Cmd }}"</p>
			<p class="source-code">[nginx -g daemon off;]</p>
			<p>Notice that the formatted output is managed as a Go template.</p>
			<p>Sometimes, the inspection of an image must go further than a simple configuration check. On occasions, we need to inspect the filesystem content of an image. To achieve this result, Podman offers the useful <strong class="source-inline">podman image mount</strong> command.</p>
			<p>The following example mounts the image and prints its mount path:</p>
			<p class="source-code"><strong class="bold"># podman image mount docker.io/library/nginx</strong></p>
			<p class="source-code">/var/lib/containers/storage/overlay/ba9d21492c3939befbecd5ec32f6f1b9d564ccf8b1b279e0fb5c186e8b7 967f2/merged </p>
			<p>If we <a id="_idIndexMarker379"/>run a simple <strong class="source-inline">ls</strong> command in the provided path, we will see the image filesystem, composed from its various merged layers, as follows:</p>
			<p class="source-code"><strong class="bold"># ls -al /var/lib/containers/storage/overlay/ba9d21492c3939befbecd5ec32f6f1b9d564ccf8b1b279e0fb5c186e8b7 967f2/merged</strong></p>
			<p class="source-code">total 92</p>
			<p class="source-code">dr-xr-xr-x. 1 root root 4096 Sep 25 22:30 .</p>
			<p class="source-code">drwx------. 5 root root 4096 Sep 25 22:53 ..</p>
			<p class="source-code">drwxr-xr-x. 2 root root 4096 Sep  2 02:00 bin</p>
			<p class="source-code">drwxr-xr-x. 2 root root 4096 Jun 13 12:30 boot</p>
			<p class="source-code">drwxr-xr-x. 2 root root 4096 Sep  2 02:00 dev</p>
			<p class="source-code">drwxr-xr-x. 1 root root 4096 Sep  9 20:26 docker-entrypoint.d</p>
			<p class="source-code">-rwxrwxr-x. 1 root root 1202 Sep  9 20:25 docker-entrypoint.sh</p>
			<p class="source-code">drwxr-xr-x. 1 root root 4096 Sep  9 20:26 etc</p>
			<p class="source-code">drwxr-xr-x. 2 root root 4096 Jun 13 12:30 home</p>
			<p class="source-code">drwxr-xr-x. 1 root root 4096 Sep  9 20:26 lib</p>
			<p class="source-code">drwxr-xr-x. 2 root root 4096 Sep  2 02:00 lib64</p>
			<p class="source-code">drwxr-xr-x. 2 root root 4096 Sep  2 02:00 media</p>
			<p class="source-code">drwxr-xr-x. 2 root root 4096 Sep  2 02:00 mnt</p>
			<p class="source-code">drwxr-xr-x. 2 root root 4096 Sep  2 02:00 opt</p>
			<p class="source-code">drwxr-xr-x. 2 root root 4096 Jun 13 12:30 proc</p>
			<p class="source-code">drwx------. 2 root root 4096 Sep  2 02:00 root</p>
			<p class="source-code">drwxr-xr-x. 3 root root 4096 Sep  2 02:00 run</p>
			<p class="source-code">drwxr-xr-x. 2 root root 4096 Sep  2 02:00 sbin</p>
			<p class="source-code">drwxr-xr-x. 2 root root 4096 Sep  2 02:00 srv</p>
			<p class="source-code">drwxr-xr-x. 2 root root 4096 Jun 13 12:30 sys</p>
			<p class="source-code">drwxrwxrwt. 1 root root 4096 Sep  9 20:26 tmp</p>
			<p class="source-code">drwxr-xr-x. 1 root root 4096 Sep  2 02:00 usr</p>
			<p class="source-code">drwxr-xr-x. 1 root root 4096 Sep  2 02:00 var</p>
			<p>To <a id="_idIndexMarker380"/>unmount the image, simply run the <strong class="source-inline">podman image unmount</strong> command, as follows:</p>
			<p class="source-code"># podman image unmount docker.io/library/nginx</p>
			<p>Mounting images in rootless mode is a bit different since this execution mode only supports <a id="_idIndexMarker381"/>manual mounting of the <strong class="bold">Virtual File System</strong> (<strong class="bold">VFS</strong>) storage driver. Since we are working with a default OverlayFS storage driver, the <strong class="source-inline">mount</strong>/<strong class="source-inline">unmount</strong> commands would not work. A workaround is to run the <strong class="source-inline">podman unshare</strong> command first. It executes a new shell process inside a new namespace where the <a id="_idIndexMarker382"/>current <strong class="bold">user ID</strong> (<strong class="bold">UID</strong>)/<strong class="bold">globally unique ID</strong> (<strong class="bold">GID</strong>) are mapped <a id="_idIndexMarker383"/>to UID 0 and GID 0, respectively. From now on, we have elevated privileges to run the <strong class="source-inline">podman mount</strong> command. Let's see an example here:</p>
			<p class="source-code">$ podman unshare</p>
			<p class="source-code"># podman image mount docker.io/library/nginx:latest \</p>
			<p class="source-code">/home/&lt;username&gt;/.local/share/containers/storage/overlay/ba9d21492c3939befbecd5ec32f6f1b9d564ccf8b1b279e0fb5c186e8b7967 f2/merged</p>
			<p>Notice that the mount point is now in the <strong class="source-inline">&lt;username&gt;</strong> home directory.</p>
			<p>To unmount, simply run the podman <strong class="source-inline">unmount</strong> command, as follows:</p>
			<p class="source-code"># podman image unmount docker.io/library/nginx:latest</p>
			<p class="source-code">ad4c705f24d392b982b2f0747704b1c5162e45674294d5640cca7076eba2 865d</p>
			<p class="source-code"># exit</p>
			<p>The <strong class="source-inline">exit</strong> command <a id="_idIndexMarker384"/>is necessary to exit the temporary unshared namespace.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor090"/>Deleting images</h2>
			<p>To delete <a id="_idIndexMarker385"/>a local store image, we can use the <strong class="source-inline">podman rmi</strong> command. The following example deletes the nginx image pulled before:</p>
			<p class="source-code"># podman rmi docker.io/library/nginx:latest</p>
			<p class="source-code">Untagged: docker.io/library/nginx:latest</p>
			<p class="source-code">Deleted: ad4c705f24d392b982b2f0747704b1c5162e45674294d5640cca7 076eba2865d</p>
			<p>The same command works in rootless mode when executed by a standard user against their home local store.</p>
			<p>To remove all the cached images, use the following example, which relies on shell command expansion to get a full list of image IDs:</p>
			<p class="source-code"># podman rmi $(podman images -qa)</p>
			<p>Notice the sharp symbol at the beginning of the line that tells us that the command is executed as root. </p>
			<p>The next command removes all images in a regular user local cache (notice the dollar symbol at the beginning of the line):</p>
			<p class="source-code">$ podman rmi $(podman images -qa)</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The <strong class="source-inline">podman rmi</strong> command fails to remove images that are currently in use from a running container. First, stop the containers using the blocked images and then run the command again.</p>
			<p>Podman also offers a simpler way to clean up dangling or unused images—the <strong class="source-inline">podman image prune</strong> command. It does not delete images from containers in use, so if you have running or stopped containers, the correspondent container image will be not deleted. </p>
			<p>The following <a id="_idIndexMarker386"/>example deletes all unused images without asking for confirmation:</p>
			<p class="source-code">$ sudo podman image prune -af</p>
			<p>The same command applies in rootless mode, deleting only images in the user home local store, as illustrated in the following code snippet:</p>
			<p class="source-code">$ podman image prune -af</p>
			<p>With this, we have learned how to manage container images on our machine. Let's now learn how to handle and check running containers.  </p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor091"/>Operations with running containers</h1>
			<p>In <a href="B17908_02_epub.xhtml#_idTextAnchor044"><em class="italic">Chapter 2</em></a>, <em class="italic">Comparing Podman and Docker </em>, we learned in the <em class="italic">Running your first container</em> section how to run a container with basic examples, involving the execution of a Bash <a id="_idIndexMarker387"/>process inside a Fedora container and an <strong class="source-inline">httpd</strong> server that was also helpful for learning how to expose containers externally.</p>
			<p>We will now explore a set of commands used to monitor and check our running containers and gain insights into their behavior.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor092"/>Viewing and handling container status</h2>
			<p>Let's start <a id="_idIndexMarker388"/>by running a simple <a id="_idIndexMarker389"/>container and exposing it on port <strong class="source-inline">8080</strong> to make it accessible externally, as follows:</p>
			<p class="source-code">$ podman run -d -p 8080:80 docker.io/library/nginx</p>
			<p>The preceding example is run in rootless mode, but the same can be applied as a root user by prepending the <strong class="source-inline">sudo</strong> command. In this case, it was simply not necessary to have a container executed in that way.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Rootless containers give an extra security advantage. If a malicious process breaks the container isolation, maybe leveraging a vulnerability on the host, it will at best gain the privileges of the user who started the rootless container.</p>
			<p>Now that <a id="_idIndexMarker390"/>our container is up <a id="_idIndexMarker391"/>and running and ready to serve, we can test it by running a <strong class="source-inline">curl</strong> command on the localhost, which should <a id="_idIndexMarker392"/>produce a <strong class="bold">HyperText Markup Language</strong> (<strong class="bold">HTML</strong>) default output like this:</p>
			<p class="source-code"><strong class="bold">$ curl localhost:8080</strong></p>
			<p class="source-code">&lt;!DOCTYPE html&gt;</p>
			<p class="source-code">&lt;html&gt;</p>
			<p class="source-code">&lt;head&gt;</p>
			<p class="source-code">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</p>
			<p class="source-code">&lt;style&gt;</p>
			<p class="source-code">html { color-scheme: light dark; }</p>
			<p class="source-code">body { width: 35em; margin: 0 auto;</p>
			<p class="source-code">font-family: Tahoma, Verdana, Arial, sans-serif; }</p>
			<p class="source-code">&lt;/style&gt;</p>
			<p class="source-code">&lt;/head&gt;</p>
			<p class="source-code">&lt;body&gt;</p>
			<p class="source-code">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</p>
			<p class="source-code">&lt;p&gt;If you see this page, the nginx web server is successfully installed and </p>
			<p class="source-code">working. Further configuration is required.&lt;/p&gt;</p>
			<p class="source-code">&lt;p&gt;For online documentation and support please refer to</p>
			<p class="source-code">&lt;a href="http://nginx.org/"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</p>
			<p class="source-code">Commercial support is available at</p>
			<p class="source-code">&lt;a href="http://nginx.com/"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</p>
			<p class="source-code">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;</p>
			<p class="source-code">&lt;/body&gt;</p>
			<p class="source-code">&lt;/html&gt;</p>
			<p>Obviously, an empty nginx server without contents to serve is useless, but we will learn how to serve custom contents by using volumes or building custom images later in the next chapters.</p>
			<p>The first <a id="_idIndexMarker393"/>command we can use <a id="_idIndexMarker394"/>to check our container is <strong class="source-inline">podman ps</strong>. This simply prints out useful information from the running containers, with the option of customizing and sorting the output. Let's run the command in our host and see what is printed, as follows:</p>
			<p class="source-code"><strong class="bold">$ podman ps</strong></p>
			<p class="source-code">CONTAINER ID  IMAGE                           COMMAND               CREATED         STATUS             PORTS                 NAMES</p>
			<p class="source-code">d8bbd5da64d0  docker.io/library/nginx:latest  nginx -g daemon o...  13 minutes ago  Up 13 minutes ago  0.0.0.0:8080-&gt;80/tcp  unruffled_saha</p>
			<p>The output produces some interesting information about running containers, as detailed here:</p>
			<ul>
				<li><strong class="source-inline">CONTAINER ID</strong>: Every new container gets a unique hexadecimal ID. The full ID has a length of 64 characters, and a shortened portion of 12 characters is printed in the <strong class="source-inline">podman ps</strong> output.  </li>
				<li><strong class="source-inline">IMAGE</strong>: The image used by the container.</li>
				<li><strong class="source-inline">COMMAND</strong>: The command executed inside the container.</li>
				<li><strong class="source-inline">CREATED</strong>: The creation date of the container.</li>
				<li><strong class="source-inline">STATUS</strong>: The current container status.</li>
				<li><strong class="source-inline">PORTS</strong>: The network ports opened in the container. When a port mapping is applied, we can see one or more host <strong class="source-inline">ip:port</strong> pairs mapped to the container ports with an arrow sign. For example, the <strong class="source-inline">0.0.0.0:8080-&gt;80/tcp</strong> string means that the <strong class="source-inline">8080/tcp</strong> host port is exposed on all the listening interfaces and is mapped to the <strong class="source-inline">80/tcp</strong> container port.</li>
				<li><strong class="source-inline">NAMES</strong>: The container name. This can be assigned by the user or be randomly generated by the container engine.<p class="callout-heading">Tip</p><p class="callout">Notice the randomly generated name in the last column of the output. Podman continues the Docker <em class="italic">tradition</em> to generate random names using adjectives in the left part of the name and notable scientists and hackers in the right part. Indeed, Podman still uses the same <strong class="source-inline">github.com/docker/docker/namesgenerator</strong> Docker package, included in the vendor directory of the project.</p></li>
			</ul>
			<p>To get a <a id="_idIndexMarker395"/>full list of both running <a id="_idIndexMarker396"/>and stopped containers, we can add an <strong class="source-inline">–a</strong> option to the command. To demonstrate this, we first introduce the <strong class="source-inline">podman stop</strong> command. This changes the container status to stopped and sends a <strong class="source-inline">SIGTERM</strong> signal to the processes running inside the container. If the container becomes unresponsive, it sends a <strong class="source-inline">SIGKILL</strong> signal after a given timeout of 10 seconds.</p>
			<p>Let's try to stop the previous container and check its state by executing the following code:</p>
			<p class="source-code">$ podman stop d8bbd5da64d0  </p>
			<p class="source-code">$ podman ps</p>
			<p>This time, <strong class="source-inline">podman ps</strong> produced an empty output. This is because the container state is stopped. To get a full list of both running and stopped containers, run the following command:</p>
			<p class="source-code"><strong class="bold">$ podman ps –a</strong></p>
			<p class="source-code">CONTAINER ID  IMAGE  COMMAND  CREATED   STATUS   PORT   NAMES</p>
			<p class="source-code">d8bbd5da64d0  docker.io/library/nginx:latest  nginx -g daemon o...  About a minute ago  Exited (0) About a minute ago  0.0.0.0:8080-&gt;80/tcp  unruffled_saha</p>
			<p>Notice the status of the container, which states that the container has exited with a <strong class="source-inline">0</strong> exit code.</p>
			<p>The stopped container can be resumed by running the <strong class="source-inline">podman start</strong> command, as follows:</p>
			<p class="source-code">$ podman start d8bbd5da64d0  </p>
			<p>This command simply starts again the container we stopped before. </p>
			<p>If we <a id="_idIndexMarker397"/>now check the container <a id="_idIndexMarker398"/>status again, we will see it is up and running, as indicated here:</p>
			<p class="source-code"><strong class="bold">$ podman ps</strong></p>
			<p class="source-code">CONTAINER ID  IMAGE  COMMAND  CREATED   STATUS   PORT   NAMES</p>
			<p class="source-code">d8bbd5da64d0  docker.io/library/nginx:latest  nginx -g daemon o...  8 minutes ago  Up 1 second ago  0.0.0.0:8080-&gt;80/tcp  unruffled_saha</p>
			<p>Podman keeps the container configuration, storage, and metadata as long as it is in a stopped state. Anyway, when we resume the container, we start a new process inside it.</p>
			<p>For more options, see the related <strong class="bold">manual</strong> (<strong class="bold">man</strong>) page (<strong class="source-inline">man podman-start</strong>).</p>
			<p>If we simply need to restart a running container, we can use the <strong class="source-inline">podman restart</strong> command, as follows:</p>
			<p class="source-code">$ podman restart &lt;Container_ID_or_Name&gt;</p>
			<p>This command has the effect of immediately restarting the processes inside the container with a new <strong class="bold">process ID</strong> (<strong class="bold">PID</strong>).</p>
			<p>The <strong class="source-inline">podman start</strong> command can also be used to start containers that have been previously created but not run. To create a container without starting it, use the <strong class="source-inline">podman create</strong> command. The following example creates a container but does not start it:</p>
			<p class="source-code">$ podman create -p 8080:80 docker.io/library/nginx</p>
			<p>To start it, run <strong class="source-inline">podman start</strong> on the created container ID or name, as follows:</p>
			<p class="source-code">$ podman start &lt;Container_ID_or_Name&gt;</p>
			<p>This <a id="_idIndexMarker399"/>command is very useful <a id="_idIndexMarker400"/>for preparing an environment without running it or for mounting a container filesystem, as in the following example:</p>
			<p class="source-code">$ podman unshare</p>
			<p class="source-code">$ podman container mount &lt;Container_ID_or_Name&gt;</p>
			<p class="source-code">/home/&lt;username&gt;/.local/share/containers/storage/overlay/bf9d8df299436d80dece200a23e1b8b957f987a254a656ef94cdc5666982 3b5c/merged</p>
			<p>Let's now introduce a very frequently used command: <strong class="source-inline">podman rm</strong>. As the name indicates, it is used to remove containers from the host. By default, it removes stopped containers, but it can be forced to remove running containers with the <strong class="source-inline">–f</strong> option.</p>
			<p>Using the container from the previous example, if we stop it again and issue the <strong class="source-inline">podman rm</strong> command, as illustrated in the following code snippet, all the container storage, configs, and metadata will be discarded:</p>
			<p class="source-code">$ podman stop d8bbd5da64d0</p>
			<p class="source-code">$ podman rm d8bbd5da64d0</p>
			<p>If we now run a <strong class="source-inline">podman ps</strong> command again, even with the <strong class="source-inline">–a</strong> option, we will get an empty list, as illustrated here:</p>
			<p class="source-code"><strong class="bold">$ podman ps –a</strong></p>
			<p class="source-code">CONTAINER ID  IMAGE       COMMAND     CREATED     STATUS      PORTS       NAMES</p>
			<p>For more details, please inspect the command man page (<strong class="source-inline">man podman-rm</strong>).</p>
			<p>Sometimes, it is useful—just as with images—to print only the container ID with the <strong class="source-inline">–q</strong> option. This one, combined with the <strong class="source-inline">–a</strong> option, can print a list of all stopped and running containers in the host. Let's try another example here:</p>
			<p class="source-code">$ for i in {1..5}; do podman run -d docker.io/library/nginx; done</p>
			<p>It's interesting to notice that we have used a shell loop to start five identical containers, this time without any port mapping—just plain nginx containers. We can inspect their IDs with the following command:</p>
			<p class="source-code"><strong class="bold">$ podman ps –qa</strong></p>
			<p class="source-code">b38ebfed5921</p>
			<p class="source-code">6204efc6d6b2</p>
			<p class="source-code">762967d87657</p>
			<p class="source-code">269f1affb699</p>
			<p class="source-code">1161072ec559</p>
			<p>How can <a id="_idIndexMarker401"/>we stop and remove <a id="_idIndexMarker402"/>all our running containers quickly? We can use shell expansion to combine it with other commands and reach the desired result. Shell expansion is a powerful tool that runs the command inside round parentheses and lets us pass the output string as arguments to the external command, as illustrated in the following code snippet:</p>
			<p class="source-code">$ podman stop $(podman ps -qa)</p>
			<p class="source-code">$ podman rm $(podman ps -qa)</p>
			<p>The two commands stopped all the running containers, identified by their IDs, and removed them from the host.</p>
			<p>The <strong class="source-inline">podman ps</strong> command enables users to refine their output by applying specific filters. A full list of all applicable filters is available on the <strong class="source-inline">podman-ps</strong> man page. A simple but useful application is the status filter, which enables users to print only containers in a specific condition. Possible statuses are <strong class="source-inline">created</strong>, <strong class="source-inline">exited</strong>, <strong class="source-inline">paused</strong>, <strong class="source-inline">running</strong>, and <strong class="source-inline">unknown</strong>.</p>
			<p>The following example only prints containers in an <strong class="source-inline">exited</strong> status:</p>
			<p class="source-code">$ podman ps --filter status=exited</p>
			<p>Again, we can leverage the power of shell expansion to remove nothing but the exited containers, as follows:</p>
			<p class="source-code">$ podman rm $(podman ps -qa --filter status=exited)</p>
			<p>A similar result can be achieved with the simpler-to-remember <strong class="source-inline">podman container prune</strong> command shown here, which removes (prunes) all stopped containers from the host:</p>
			<p class="source-code">$ podman container prune</p>
			<p>Sorting is <a id="_idIndexMarker403"/>another useful option <a id="_idIndexMarker404"/>for producing ordered output when listing containers. The following example shows how to sort by container ID:</p>
			<p class="source-code">$ podman ps -q --sort id</p>
			<p>The <strong class="source-inline">podman ps</strong> command support formatting using a Go template to produce custom output. The next example prints only the container IDs and the commands executed inside them:</p>
			<p class="source-code">$ podman ps -a --format "{{.ID}}  {{.Command}}" --no-trunc </p>
			<p>Also, notice the <strong class="source-inline">--no-trunc</strong> option is added to avoid truncating the command output. This is not mandatory but is useful when we have long commands executed inside the containers.</p>
			<p>If we simply wish to extract the host PID of the process running inside the running containers, we can run the following example:</p>
			<p class="source-code">$ podman ps --format "{{ .Pid }}"</p>
			<p>Instead, if we need to also find out information about the isolated namespaces, <strong class="source-inline">podman ps</strong> can print details about the cloned namespaces of the running containers. This is a useful starting point for advanced troubleshooting and inspection. You can see the command being run here:</p>
			<p class="source-code"><strong class="bold">$ podman ps --namespace</strong></p>
			<p class="source-code">CONTAINER ID  NAMES                 PID         CGROUPNS    IPC         MNT         NET         PIDNS       USERNS      UTS</p>
			<p class="source-code">f2666ed4a46a  unruffled_hofstadter  437764      4026533088  4026533086  4026533083  4026532948  4026533087  4026532973  4026533085</p>
			<p>This <a id="_idIndexMarker405"/>subsection covered many <a id="_idIndexMarker406"/>common operations to control and view the status of containers. In the next section, we will learn how to pause and resume running containers.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor093"/>Pausing and unpausing containers</h2>
			<p>This short section covers the <strong class="source-inline">podman pause</strong> and <strong class="source-inline">podman unpause</strong> commands. Despite <a id="_idIndexMarker407"/>being a section related to container status handling, it is interesting to understand how Podman and the container <a id="_idIndexMarker408"/>runtime leverage <strong class="bold">control groups</strong> (<strong class="bold">cgroups</strong>) to achieve specific purposes.</p>
			<p>Simply put, the <strong class="source-inline">pause</strong> and <strong class="source-inline">unpause</strong> commands have the purpose of pausing and resuming the processes of a running container. Now, the reader could legitimately need clearance about the difference between <strong class="source-inline">pause</strong> and <strong class="source-inline">stop</strong> commands in Podman.</p>
			<p>While the <strong class="source-inline">podman stop</strong> command simply sends a <strong class="source-inline">SIGTERM</strong>/<strong class="source-inline">SIGKILL</strong> signal to the parent process in the container, the <strong class="source-inline">podman pause</strong> command uses cgroups to pause the process without terminating it. When the container is unpaused, the same process is resumed transparently. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The <strong class="source-inline">pause</strong>/<strong class="source-inline">unpause</strong> low-level logic is implemented in the container runtime—for the most curious, this was the implementation in <strong class="source-inline">crun</strong> at the time of writing:</p>
			<p class="callout">https://github.com/containers/crun/blob/7ef74c9330033cb884507c28fd8c267861486633/src/libcrun/cgroup.c#L1894-L1936</p>
			<p>The following example demonstrates the podman <strong class="source-inline">pause</strong> and <strong class="source-inline">unpause</strong> commands. First, let's start a Fedora container that prints a date and time string every 2 seconds in an endless loop, as follows:</p>
			<p class="source-code">$ podman run --name timer docker.io/library/fedora bash -c "while true; do echo $(date); sleep 2; done"</p>
			<p>We intentionally leave the container running in a window and open a new window/tab to manage its status. Before issuing the <strong class="source-inline">pause</strong> command, let's inspect the PID by executing the following code:</p>
			<p class="source-code">$ podman ps --format "{{ .Pid }}" --filter name=timer</p>
			<p class="source-code">816807</p>
			<p>Now, let's pause the running container with the following command:</p>
			<p class="source-code">$ podman pause timer</p>
			<p>If we <a id="_idIndexMarker409"/>go back to the <strong class="source-inline">timer</strong> container, we see that the output just paused but the container has not exited. The <strong class="source-inline">unpause</strong> action seen here will bring it back to life:</p>
			<p class="source-code">$ podman unpause timer</p>
			<p>After the <strong class="source-inline">unpause</strong> action, the timer container will start printing date outputs again. Looking at the PID here, nothing has changed, as expected:</p>
			<p class="source-code">$ podman ps --format "{{ .Pid }}" --filter name=timer</p>
			<p class="source-code">816807</p>
			<p>We can check the cgroups status of the paused/unpaused container. In a third tab, open a terminal with a root shell and access the <strong class="source-inline">cgroupfs</strong> controller hierarchy after replacing the correct container ID, as follows:</p>
			<p class="source-code">$ sudo –i</p>
			<p class="source-code">$ cd /sys/fs/cgroup/user.slice/user-1000.slice/user@1000.service/user.slice/libpod-&lt;CONTAINER_ID&gt;.scope/container</p>
			<p>Now, look at the <strong class="source-inline">cgroup.freeze</strong> file content. This file holds a Boolean value and its state changes as we pause/unpause the container from 0 to 1 and vice versa. Try to pause and unpause the container again to test the changes.</p>
			<p class="callout-heading">Cleanup Tip</p>
			<p class="callout">Since the echo loop was issued with a <strong class="source-inline">bash –c</strong> command, we need to send a <strong class="source-inline">SIGKILL</strong> signal to the process. To do this, we can stop the container and wait for the 10-second timeout, or simply run a <strong class="source-inline">podman kill</strong> command, as follows:</p>
			<p class="callout"><strong class="source-inline">$ podman kill timer</strong></p>
			<p>In this <a id="_idIndexMarker410"/>subsection, we covered in detail the most common commands for watching and modifying a container's status. We can now move on to inspect the processes running inside the running containers.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor094"/>Inspecting processes inside containers</h2>
			<p>When a container is running, processes inside it are isolated at the namespace level, but users still <a id="_idIndexMarker411"/>own total control of the processes running and can inspect their behavior. There are many levels of complexity in process inspection, but Podman offers tools that can speed up this task.</p>
			<p>Let's start with the <strong class="source-inline">podman top</strong> command: this provides a full view of the processes running inside a container. The following example shows the processes running inside an nginx container:</p>
			<p class="source-code"><strong class="bold">$ podman top  f2666ed4a46a</strong></p>
			<p class="source-code">USER        PID         PPID        %CPU        ELAPSED          TTY         TIME        COMMAND</p>
			<p class="source-code">root        1           0           0.000       3m26.540290427s  ?           0s          nginx: master process nginx -g daemon off; </p>
			<p class="source-code">nginx       26          1           0.000       3m26.540547429s  ?           0s          nginx: worker process </p>
			<p class="source-code">nginx       27          1           0.000       3m26.540788803s  ?           0s          nginx: worker process </p>
			<p class="source-code">nginx       28          1           0.000       3m26.540914386s  ?           0s          nginx: worker process </p>
			<p class="source-code">nginx       29          1           0.000       3m26.541040023s  ?           0s          nginx: worker process </p>
			<p class="source-code">nginx       30          1           0.000       3m26.541161213s  ?           0s          nginx: worker process </p>
			<p class="source-code">nginx       31          1           0.000       3m26.541297546s  ?           0s          nginx: worker process </p>
			<p class="source-code">nginx       32          1           0.000       3m26.54141773s   ?           0s          nginx: worker process </p>
			<p class="source-code">nginx       33          1           0.000       3m26.541564289s  ?           0s          nginx: worker process </p>
			<p class="source-code">nginx       34          1           0.000       3m26.541685475s  ?           0s          nginx: worker process </p>
			<p class="source-code">nginx       35          1           0.000       3m26.541808977s  ?           0s          nginx: worker process </p>
			<p class="source-code">nginx       36          1           0.000       3m26.541932099s  ?           0s          nginx: worker process </p>
			<p class="source-code">nginx       37          1           0.000       3m26.54205111s   ?           0s          nginx: worker process</p>
			<p>The result <a id="_idIndexMarker412"/>is very similar to the <strong class="source-inline">ps</strong> command output rather than the interactive one produced by the Linux <strong class="source-inline">top</strong> command. </p>
			<p>It is possible to apply custom formatting to the output. The following example only prints PIDs, commands, and arguments:</p>
			<p class="source-code"><strong class="bold">$ podman top f2666ed4a46a pid comm args</strong></p>
			<p class="source-code">PID         COMMAND     COMMAND</p>
			<p class="source-code">1           nginx       nginx: master process nginx -g daemon off; </p>
			<p class="source-code">26          nginx       nginx: worker process </p>
			<p class="source-code">27          nginx       nginx: worker process </p>
			<p class="source-code">28          nginx       nginx: worker process </p>
			<p class="source-code">29          nginx       nginx: worker process </p>
			<p class="source-code">30          nginx       nginx: worker process </p>
			<p class="source-code">31          nginx       nginx: worker process </p>
			<p class="source-code">32          nginx       nginx: worker process </p>
			<p class="source-code">33          nginx       nginx: worker process </p>
			<p class="source-code">34          nginx       nginx: worker process </p>
			<p class="source-code">35          nginx       nginx: worker process </p>
			<p class="source-code">36          nginx       nginx: worker process </p>
			<p class="source-code">37          nginx       nginx: worker process</p>
			<p>We may <a id="_idIndexMarker413"/>need to inspect container processes in greater detail. As we discussed earlier in <a href="B17908_01_epub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to Container Technology</em>, once a brand-new container is started, it will start assigning PIDs from number 0, while under the hood, the container engine will map this container's PIDs with the real ones on the host. So, we can use the output of the <strong class="source-inline">podman ps --namespace</strong> command to extract the process's original PID in the host for a given container. With that information, we can conduct advanced analysis. The following <a id="_idIndexMarker414"/>example shows how to attach the <strong class="source-inline">strace</strong> command, used to inspect processes' <strong class="bold">system calls</strong> (<strong class="bold">syscalls</strong>), to the process running inside the container:</p>
			<p class="source-code">$ sudo strace –p &lt;PID&gt;</p>
			<p>Details about the usage of the <strong class="source-inline">strace</strong> command are beyond the scope of this book. See <strong class="source-inline">man strace</strong> for more advanced examples and a more in-depth explanation of the command options.</p>
			<p>Another useful command that can be easily applied to processes running inside a container is <strong class="source-inline">pidstat</strong>. Once we have obtained the PID, we can inspect the resource usage in this way:</p>
			<p class="source-code">$ pidstat –p &lt;PID&gt; [&lt;interval&gt; &lt;count&gt;]</p>
			<p>The integers applied at the end represent, respectively, the execution interval of the command and the number of times it must print the usage stats. See <strong class="source-inline">man pidstat</strong> for more usage options.</p>
			<p>When a <a id="_idIndexMarker415"/>process in a container becomes unresponsive, it is possible to handle its abrupt termination with the <strong class="source-inline">podman kill</strong> command. By default, it sends a <strong class="source-inline">SIGKILL</strong> signal to the process inside the container. The following example creates an <strong class="source-inline">httpd</strong> container and then kills it:</p>
			<p class="source-code">$ podman run --name custom-webserver -d docker.io/library/httpd</p>
			<p class="source-code">$ podman kill custom-webserver</p>
			<p>We can optionally send custom signals (such as <strong class="source-inline">SIGTERM</strong> or <strong class="source-inline">SIGHUP</strong>) with the <strong class="source-inline">--signal</strong> option. Notice that a killed container is not removed from the host but continues to exist, is stopped, and is in an exited status.</p>
			<p>In <a href="B17908_10_epub.xhtml#_idTextAnchor193"><em class="italic">Chapter 10</em></a>, <em class="italic">Troubleshooting and Monitoring Containers</em>, we will again deal with container troubleshooting and learn how to use advanced tools such as <strong class="source-inline">nsenter</strong> to inspect container processes. We now move on to basic container statistics commands that can be useful for monitoring the overall resource usage by all containers running in a system.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor095"/>Monitoring container stats</h2>
			<p>When <a id="_idIndexMarker416"/>multiple containers are <a id="_idIndexMarker417"/>running in the same host, it is crucial to monitor the amount of <strong class="bold">central processing unit</strong> (<strong class="bold">CPU</strong>), memory, disk, and network resources they are consuming in a given interval of time. The first, simpler command that an administrator can use is the <strong class="source-inline">podman stats</strong> command, shown here:</p>
			<p class="source-code">$ podman stats</p>
			<p>Without any options, the command will open a top-like, self-refreshing window with the stats of all the running containers. The default printed values are listed here:</p>
			<ul>
				<li><strong class="source-inline">ID</strong>: The running container ID</li>
				<li><strong class="source-inline">NAME</strong>: The running container name</li>
				<li><strong class="source-inline">CPU %</strong>: The total CPU usage as a percentage</li>
				<li><strong class="source-inline">MEM USAGE / LIMIT</strong>: Memory usage against a given limit (dictated by system capabilities or by cgroups-driven limits)</li>
				<li><strong class="source-inline">MEM %</strong>: The total memory usage as a percentage</li>
				<li><strong class="source-inline">NET IO</strong>: Network <strong class="bold">input/output</strong> (<strong class="bold">I/O</strong>) operations</li>
				<li><strong class="source-inline">BLOCK IO</strong>: Disk I/O operations</li>
				<li><strong class="source-inline">PIDS</strong>: The number of PIDs inside the container</li>
				<li><strong class="source-inline">CPU TIME</strong>: Total consumed CPU time</li>
				<li><strong class="source-inline">AVG CPU %</strong>: Average CPU usage as a percentage</li>
			</ul>
			<p>In case a redirect is needed, it is possible to avoid streaming a self-refreshing output with the <strong class="source-inline">--no-stream</strong> option, as follows:</p>
			<p class="source-code">$ podman stats --no-stream</p>
			<p>Anyway, having <a id="_idIndexMarker418"/>a static output of this type is not very useful for parsing or ingestion. A better approach is to apply a JSON or Go template formatter. The following example prints out stats in a JSON format:</p>
			<p class="source-code">$ podman stats --format=json</p>
			<p class="source-code">[</p>
			<p class="source-code"> {</p>
			<p class="source-code">  "id": "e263f68bbb83",</p>
			<p class="source-code">  "name": "infallible_sinoussi",</p>
			<p class="source-code">  "cpu_time": "33.518ms",</p>
			<p class="source-code">  "cpu_percent": "2.05%",</p>
			<p class="source-code">  "avg_cpu": "2.05%",</p>
			<p class="source-code">  "mem_usage": "19.3MB / 33.38GB",</p>
			<p class="source-code">  "mem_percent": "0.06%",</p>
			<p class="source-code">  "net_io": "-- / --",</p>
			<p class="source-code">  "block_io": "-- / --",</p>
			<p class="source-code">  "pids": "13"</p>
			<p class="source-code"> }</p>
			<p class="source-code">]</p>
			<p>In a similar way, it is possible to customize the output fields using a Go template. The following <a id="_idIndexMarker419"/>example only prints out the container ID, CPU percentage usage, total memory usage in bytes, and PIDs:</p>
			<p class="source-code">$ podman stats -a --no-stream --format "{{ .ID }} {{ .CPUPerc }} {{ .MemUsageBytes }} {{ .PIDs }}"</p>
			<p>In this section, we have learned how to monitor running containers and their isolated processes. The next section shows how to inspect container configurations for analysis and troubleshooting.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor096"/>Inspecting container information</h1>
			<p>A running container exposes a set of configuration data and metadata ready to be consumed. Podman implements the <strong class="source-inline">podman inspect</strong> command to print all the container <a id="_idIndexMarker420"/>configurations and runtime information. In its simplest form, we can simply pass the container ID or name, like this:</p>
			<p class="source-code">$ podman inspect &lt;Container_ID_or_Name&gt;</p>
			<p>This command prints a JSON output with all the container configurations. For the sake of space, we will list some of the most notable fields here:</p>
			<ul>
				<li><strong class="source-inline">Path</strong>: The container entry point path. We will dig deeper into entry points later when we analyze Dockerfiles. </li>
				<li><strong class="source-inline">Args</strong>: The arguments passed to the entry point.</li>
				<li><strong class="source-inline">State</strong>: The container's current state, including crucial information such as the executed PID, the common PID, the OCI version, and the health check status.</li>
				<li><strong class="source-inline">Image</strong>: The ID of the image used to run the container.</li>
				<li><strong class="source-inline">Name</strong>: The container name.</li>
				<li><strong class="source-inline">MountLabel</strong>: Container <a id="_idIndexMarker421"/>mount label for <strong class="bold">Security-Enhanced Linux</strong> (<strong class="bold">SELinux</strong>).</li>
				<li><strong class="source-inline">ProcessLabel</strong>: Container process label for SELinux.</li>
				<li><strong class="source-inline">EffectiveCaps</strong>: Effective capabilities applied to the container.</li>
				<li><strong class="source-inline">GraphDriver</strong>: The type <a id="_idIndexMarker422"/>of storage driver (default is <strong class="source-inline">overlayfs</strong>) and a list of overlay upper, lower, and merged directories.</li>
				<li><strong class="source-inline">Mounts</strong>: The actual bind mounts in the container.</li>
				<li><strong class="source-inline">NetworkSettings</strong>: The overall <a id="_idIndexMarker423"/>container network settings, including its internal <strong class="bold">Internet Protocol</strong> (<strong class="bold">IP</strong>) address, exposed ports, and port mappings.</li>
				<li><strong class="source-inline">Config</strong>: Container runtime configuration, including environment variables, hostname, command, working directory, labels, and annotations.</li>
				<li><strong class="source-inline">HostConfig</strong>: Host configuration, including cgroups' quotas, network mode, and capabilities. </li>
			</ul>
			<p>This is a <a id="_idIndexMarker424"/>huge amount of information that most of the time is too much for our needs. When we need to extract specific fields, we can use the <strong class="source-inline">--format</strong> option to print only selected ones. The following example prints only the host-bound PID of the process executed inside the container:</p>
			<p class="source-code">$ podman inspect &lt;ID or Name&gt; --format "{{ .State.Pid }}"</p>
			<p>The result is in a Go template format. This allows for flexibility to customize the output string as we desire.</p>
			<p>The <strong class="source-inline">podman inspect</strong> command is also useful for understanding the behavior of the container engine and for gaining useful information during troubleshooting tasks. </p>
			<p>For example, when a container is launched, we learn that the <strong class="source-inline">resolv.conf</strong> file is mounted inside the container from a path that is defined in the <strong class="source-inline">{{ .ResolvConfPath }}</strong> key. The target path is <strong class="source-inline">/run/user/&lt;UID&gt;/containers/overlay-containers/&lt;Container_ID&gt;/userdata/resolv.conf</strong> when the container is executed in rootless mode, and <strong class="source-inline">/var/run/containers/storage/overlay-containers/&lt;Container_ID&gt;/userdata/resolv.conf</strong> when in rootful mode.</p>
			<p>Other interesting <a id="_idIndexMarker425"/>information is the list of all the merged layers managed by <strong class="source-inline">overlayfs</strong>. Let's try to run a new container, this time in rootful mode, and find out information about the merged layers, as follows:</p>
			<p class="source-code"># podman run --name logger -d docker.io/library/fedora bash -c "while true; do echo test &gt;&gt; /tmp/test.log; sleep 5; done"</p>
			<p>This container runs a simple loop that writes a string on a text file every 5 seconds. Now, let's run a <strong class="source-inline">podman inspect</strong> command to find out information about <strong class="source-inline">MergedDir</strong>, which is the directory where all layers are merged by <strong class="source-inline">overlayfs</strong>. The code is illustrated in the following snippet:</p>
			<p class="source-code"># podman inspect logger --format "{{ .GraphDriver.Data.MergedDir  }}"</p>
			<p class="source-code">/var/lib/containers/storage/overlay/27d89046485db7c775b108a80072eafdf9aa63d14ee1205946d746 23fc195314/merged</p>
			<p>Inside this directory, we can find the <strong class="source-inline">/tmp/test.log</strong> file, as indicated here:</p>
			<p class="source-code"># cat /var/lib/containers/storage/overlay/27d89046485db7c775b108a80072eafdf9aa63d14ee1205946d746 23fc195314/merged/tmp/test.log</p>
			<p class="source-code">test</p>
			<p class="source-code">test</p>
			<p class="source-code">test</p>
			<p class="source-code">test</p>
			<p class="source-code">test</p>
			<p class="source-code">[...]</p>
			<p>We can dig deeper—the <strong class="source-inline">LowerDir</strong> directory holds a list of the base image layers, as shown in the following code snippet:</p>
			<p class="source-code"># podman inspect logger \</p>
			<p class="source-code">--format "{{ .GraphDriver.Data.LowerDir}}"</p>
			<p class="source-code"> /var/lib/containers/storage/overlay/4c85102d65a59c6d478bfe6bc0bf32e8c79d9772689f62451c7196 380675d4af/diff</p>
			<p>In this <a id="_idIndexMarker426"/>example, the base image is made up of only one layer. Are we going to find the log file here? Let's have a look:</p>
			<p class="source-code"># cat /var/lib/containers/storage/overlay/4c85102d65a59c6d478bfe6bc0bf32e8c79d9772689f62451c7196 380675d4af/diff/tmp/test.log</p>
			<p class="source-code">cat: /var/lib/containers/storage/overlay/4c85102d65a59c6d478bfe6bc0bf32e8c79d9772689f62451c7196 380675d4af/diff/tmp/test.log: No such file or directory</p>
			<p>We are missing the log file in this layer. This is because the <strong class="source-inline">LowerDir</strong> directory is not written and represents the read-only image layers. It is merged with an <strong class="source-inline">UpperDir </strong>directory that is the read-write layer of the container. With <strong class="source-inline">podman inspect</strong>, we can find out where it resides, as illustrated here:</p>
			<p class="source-code"># podman inspect logger --format "{{ .GraphDriver.Data.UpperDir }}"</p>
			<p class="source-code">/var/lib/containers/storage/overlay/27d89046485db7c775b108a80072eafdf9aa63d14ee1205946d746 23fc195314/diff</p>
			<p>The output directory will contain only a bunch of files and directories, written since the container startup, including the <strong class="source-inline">/tmp/test.log</strong> file, as illustrated in the following code snippet:</p>
			<p class="source-code"># cat /var/lib/containers/storage/overlay/27d89046485db7c775b108a80072eafdf9aa63d14ee1205946d746 23fc195314/diff/tmp/test.log</p>
			<p class="source-code">test</p>
			<p class="source-code">test</p>
			<p class="source-code">test</p>
			<p class="source-code">test</p>
			<p class="source-code">test</p>
			<p class="source-code">[...]</p>
			<p>We can <a id="_idIndexMarker427"/>now stop and remove the logger container by running the following command:</p>
			<p class="source-code"># podman stop logger &amp;&amp; podman rm logger</p>
			<p>This example was in anticipation of the container storage topic that will be covered in <a href="B17908_05_epub.xhtml#_idTextAnchor101"><em class="italic">Chapter 5</em></a>, <em class="italic">Implementing Storage for the Container's Data</em>. The <strong class="source-inline">overlayfs</strong> mechanisms, with the lower, upper, and merged directory concepts, will be analyzed in more detail.</p>
			<p>In this section, we learned how to inspect running containers and collect runtime information and configurations. The next section is going to cover best practices for capturing logs from containers.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor097"/>Capturing logs from containers</h1>
			<p>As described <a id="_idIndexMarker428"/>earlier in this chapter, containers are made <a id="_idIndexMarker429"/>of one or more processes that can fail, printing errors and describing their current state in a log file. But where are these logs stored?</p>
			<p>Well, of course, a process in a container could write its log messages inside a file somewhere in a temporary filesystem that the container engine has made available to it (if any). But what about a read-only filesystem or any permission constraints in the running container?</p>
			<p>A container's <a id="_idIndexMarker430"/>best practice for exposing relevant logs outside <a id="_idIndexMarker431"/>the container's shield actually leverages the use of standard streams: <strong class="bold">standard output</strong> (<strong class="source-inline">STDOUT</strong>) and <strong class="bold">standard error</strong> (<strong class="source-inline">STDERR</strong>).</p>
			<p class="callout-heading">Good to Know</p>
			<p class="callout">Standard streams are communication channels interconnected to a running process in an OS. When a program is run through an interactive shell, these streams are then directly connected to the user's running terminal to let input, output, and error flow between the terminal and the process, and vice versa.</p>
			<p>Depending <a id="_idIndexMarker432"/>on the options we use for running a brand-new container, Podman will act appropriately by attaching the <strong class="source-inline">STDIN</strong>, <strong class="source-inline">STDOUT</strong>, and <strong class="source-inline">STDERR</strong> standard streams to a local file for storing the logs.</p>
			<p>In <a href="B17908_03_epub.xhtml#_idTextAnchor068"><em class="italic">Chapter 3</em></a>, <em class="italic">Running the First Container</em>, we saw how to run a container in the background, detaching from a running container. We used the <strong class="source-inline">-d</strong> option to start a container in <em class="italic">detached</em> mode through the <strong class="source-inline">podman run</strong> command, as illustrated here:</p>
			<p class="source-code">$ podman run -d -i -t registry.fedoraproject.org/f29/httpd</p>
			<p>With the previous command, we are instructing Podman to start a container in detached mode (<strong class="source-inline">-d</strong>), with a pseudo-terminal attached to the <strong class="source-inline">STDIN</strong> stream (<strong class="source-inline">-t</strong>) keeping the standard input stream open even if there is no terminal attached yet (<strong class="source-inline">-i</strong>).</p>
			<p>The standard Podman behavior is to attach to <strong class="source-inline">STDOUT</strong> and <strong class="source-inline">STDERR</strong> streams and store any container's published data in a log file on the host filesystem.</p>
			<p>If we are working with Podman as a <em class="italic">root</em> user, we can take a look at the log file available on the host system, executing the following steps:</p>
			<ol>
				<li>First, we need to start our container and take note of the ID returned by Podman, or ask Podman for a list of containers and take note of their ID. The code to accomplish this is shown in the following snippet:<p class="source-code"><strong class="bold"># podman run -d -i -t registry.fedoraproject.org/f29/httpd</strong></p><p class="source-code"><strong class="bold">c6afe22eac7c22c35a303d5fed45bc1b6442a4cec4a9060f392362bc</strong></p><p class="source-code"><strong class="bold">4cecb25d</strong></p><p class="source-code"><strong class="bold"># .</strong></p><p class="source-code"><strong class="bold">CONTAINER ID                                                      IMAGE                                        COMMAND             CREATED         STATUS             PORTS       NAMES</strong></p><p class="source-code"><strong class="bold">c6afe22eac7c22c35a303d5fed45bc1b6442a4cec4a9060f392362bc4 cecb25d  registry.fedoraproject.org/f29/httpd:latest  /usr/bin/run-httpd  27 minutes ago  Up 27 minutes ago              gifted_allen</strong></p></li>
				<li>After that, we can take a look under the <strong class="source-inline">/var/lib/containers/storage/overlay-containers/</strong> directory and search for a folder with a name that matches our container's ID, as follows:<p class="source-code"><strong class="bold"># cd /var/lib/containers/storage/overlay-containers/c6afe22eac7c22c35a303d5fed45bc1b6442a4cec4a9060f392362bc4 cecb25d/</strong></p></li>
				<li>Finally, we <a id="_idIndexMarker433"/>can check the logs of our running <a id="_idIndexMarker434"/>container by taking a look at the file named <strong class="source-inline">ctr.log</strong> in the <strong class="source-inline">userdata</strong> directory, as follows: <p class="source-code"><strong class="bold"># cat userdata/ctr.log </strong></p><p class="source-code"><strong class="bold">2021-09-27T15:42:46.925288013+00:00 stdout P =&gt; sourcing 10-set-mpm.sh ...</strong></p><p class="source-code"><strong class="bold">2021-09-27T15:42:46.925604590+00:00 stdout F </strong></p><p class="source-code"><strong class="bold">2021-09-27T15:42:46.926882725+00:00 stdout P =&gt; sourcing 20-copy-config.sh ...</strong></p><p class="source-code"><strong class="bold">2021-09-27T15:42:46.926920142+00:00 stdout F </strong></p><p class="source-code"><strong class="bold">2021-09-27T15:42:46.929405654+00:00 stdout P =&gt; sourcing 40-ssl-certs.sh ...</strong></p><p class="source-code"><strong class="bold">2021-09-27T15:42:46.929460531+00:00 stdout F </strong></p><p class="source-code"><strong class="bold">2021-09-27T15:42:46.987174441+00:00 stdout P AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 10.88.0.9. Set the 'ServerName' directive globally to suppress this message</strong></p><p class="source-code"><strong class="bold">2021-09-27T15:42:46.987242961+00:00 stdout F </strong></p><p class="source-code"><strong class="bold">2021-09-27T15:42:46.996989350+00:00 stdout F [Mon Sep 27 15:42:46.996748 2021] [ssl:warn] [pid 1:tid 139708367605120] AH01882: Init: this version of mod_ssl was compiled against a newer library (OpenSSL 1.1.1b FIPS  26 Feb 2019, version currently loaded is OpenSSL 1.1.1 FIPS  11 Sep 2018) - may result in undefined or erroneous behavior</strong></p><p class="source-code"><strong class="bold">...</strong></p><p class="source-code"><strong class="bold">2021-09-27T15:42:47.101066096+00:00 stdout F [Mon Sep 27 15:42:47.099445 2021] [core:notice] [pid 1:tid 139708367605120] AH00094: Command line: 'httpd -D FOREGROUND'</strong></p></li>
			</ol>
			<p>We just <a id="_idIndexMarker435"/>discovered the secret place where Podman <a id="_idIndexMarker436"/>saves all logs of our containers! </p>
			<p>Please note that the procedure we just introduced will work properly if the <strong class="source-inline">log_driver</strong> field for the <strong class="source-inline">containers.conf</strong> file is set to the <strong class="source-inline">k8s-file</strong> value. For example, in the Fedora Linux distribution starting from version 35, the maintainers decided to switch from <strong class="source-inline">k8s-file</strong> to <strong class="source-inline">journald</strong>. In this case, you could look for the logs directly using the <strong class="source-inline">journalctl</strong> command-line utility. </p>
			<p>If you want to take a look at the default <strong class="source-inline">log_driver</strong> field, you can look in the following path:</p>
			<p class="source-code"># grep log_driver /usr/share/containers/containers.conf</p>
			<p>Does this mean that we need to perform this entire complex procedure every time we need to analyze the logs of our containers? Of course not!</p>
			<p>Podman has a <strong class="source-inline">podman logs</strong> built-in command that can easily discover, grab, and print the latest container logs for us. Considering the previous example, we can easily check the logs of our running container by executing the following command:</p>
			<p class="source-code"><strong class="bold"># podman logs c6afe22eac7c22c35a303d5fed45bc1b6442a4cec4a9060f 392362bc4cecb25d</strong></p>
			<p class="source-code">=&gt; sourcing 10-set-mpm.sh ...</p>
			<p class="source-code">=&gt; sourcing 20-copy-config.sh ...</p>
			<p class="source-code">=&gt; sourcing 40-ssl-certs.sh ...</p>
			<p class="source-code">AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 10.88.0.9. Set the 'ServerName' directive globally to suppress this message</p>
			<p class="source-code">[Mon Sep 27 15:42:46.996748 2021] [ssl:warn] [pid 1:tid 13970 8367605120] AH01882: Init: this version of mod_ssl was compiled  against a newer library (OpenSSL 1.1.1b FIPS  26 Feb 2019, version currently loaded is OpenSSL 1.1.1 FIPS  11 Sep 2018) - may result in undefined or erroneous behavior</p>
			<p class="source-code">...</p>
			<p class="source-code">[Mon Sep 27 15:42:47.099445 2021] [core:notice] [pid 1:tid 139708367605120] AH00094: Command line: 'httpd -D FOREGROUND'</p>
			<p>We can <a id="_idIndexMarker437"/>also get the short ID for our running container <a id="_idIndexMarker438"/>and pass this ID to the <strong class="source-inline">podman logs</strong> command, as follows:</p>
			<p class="source-code"><strong class="bold"># podman ps</strong></p>
			<p class="source-code">CONTAINER ID  IMAGE                                        COMMAND               CREATED         STATUS             PORTS       NAMES</p>
			<p class="source-code">c6afe22eac7c  registry.fedoraproject.org/f29/httpd:latest  /usr/bin/run-http...  40 minutes ago  Up 40 minutes ago              gifted_allen</p>
			<p class="source-code"><strong class="bold"># podman logs --tail 2 c6afe22eac7c</strong></p>
			<p class="source-code">[Mon Sep 27 15:42:47.099403 2021] [mpm_event:notice] [pid 1:tid 139708367605120] AH00489: Apache/2.4.39 (Fedora) OpenSSL/1.1.1 configured -- resuming normal operations</p>
			<p class="source-code">[Mon Sep 27 15:42:47.099445 2021] [core:notice] [pid 1:tid 1397 08367605120] AH00094: Command line: 'httpd -D FOREGROUND'</p>
			<p>In the previous command, we also used a nice option of the <strong class="source-inline">podman logs</strong> command: the <strong class="source-inline">--tail</strong> option, which lets us output only the latest needed rows of the container's log. In our case, we requested the latest two.</p>
			<p>As we saw <a id="_idIndexMarker439"/>earlier in this section, Podman saves the container logs into the host filesystem. These files, by default, are not limited in size, so it could <a id="_idIndexMarker440"/>happen that for long-living containers that might produce a lot of logs, these files could become very large.</p>
			<p>For this reason, as we usually talk about logs and log files, one important configuration parameter that could help reduce the log files' size is available through the Podman global configuration file available at this location: <strong class="source-inline">/etc/containers/containers.conf</strong>.</p>
			<p>If this configuration file is missing, you can easily create a new one, inserting the following rows to apply the configuration:</p>
			<p class="source-code"># vim /etc/containers/containers.conf</p>
			<p class="source-code">[containers]</p>
			<p class="source-code">log_size_max=10000000</p>
			<p>Through the previous configuration, we are limiting every log file for our future running containers to 10 <strong class="bold">megabytes</strong> (<strong class="bold">MB</strong>). If you have some running containers, you have to restart them to apply this new configuration.</p>
			<p>We are now ready to move to the next section, where we will discover another useful command.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor098"/>Executing processes in a running container</h1>
			<p>In the <em class="italic">Podman daemonless architecture</em> section of <a href="B17908_02_epub.xhtml#_idTextAnchor044"><em class="italic">Chapter 2</em></a>, <em class="italic">Comparing Podman and Docker</em>, we talked <a id="_idIndexMarker441"/>about the fact that Podman, as with any other container engine, leverages the Linux namespace functionality to correctly isolate running containers from each other and from the OS host as well.</p>
			<p>So, just because Podman creates a brand-new namespace for every running container, it should not be a surprise that we can attach to the same Linux namespace of a running container, executing other processes just as in a full operating environment.</p>
			<p>Podman gives us the ability to execute a process in a running container through the <strong class="source-inline">podman exec</strong> command.</p>
			<p>Once executed, this command will find internally the right Linux namespace to which the target <a id="_idIndexMarker442"/>running container is attached. Having found the Linux namespace, Podman will execute the respective process, passed as an argument to the <strong class="source-inline">podman exec</strong> command, attaching it to the target Linux namespace. The final process will be in the same environment as the original process companion and it will be able to interact with it.</p>
			<p>To understand how this works in practice, we can consider the following example whereby we will first run a container and then execute a process beside the existing processes:</p>
			<p class="source-code"># podman run -d -i -t registry.fedoraproject.org/f29/httpd</p>
			<p class="source-code">47fae73e4811a56d799f258c85bc50262901bec2f9a9cab19c01af89713 a1248</p>
			<p class="source-code"># podman exec -ti 47fae73e4811a56d799f258c85bc50262901bec2f9a9cab19c01af89713 a1248 /bin/bash</p>
			<p class="source-code">bash-4.4$ ps aux</p>
			<p class="source-code">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START    TIME COMMAND</p>
			<p class="source-code">default        1  0.6  0.6  20292 13664 pts/0    Ss+  13:37    0:00 httpd -D FOREGROUND</p>
			<p class="source-code">...</p>
			<p>As you can see from the previous commands, we grabbed the container ID provided by Podman once the container was started and we passed it to the <strong class="source-inline">podman exec</strong> command as an argument.</p>
			<p>The <strong class="source-inline">podman exec</strong> command could be really useful for troubleshooting, testing, and working with an existing container. In the preceding example, we attached an interactive terminal running the Bash console, and we launched the <strong class="source-inline">ps</strong> command for inspecting the running processes available in the current Linux namespace assigned to the container.</p>
			<p>The <strong class="source-inline">podman exec</strong> command has many options available, similar to the ones provided by the <strong class="source-inline">podman run</strong> command. As you saw from the previous example, we used the option for getting a pseudo-terminal attached to the <strong class="source-inline">STDIN</strong> stream (<strong class="source-inline">-t</strong>), keeping the standard input stream open even if there is no terminal attached yet (<strong class="source-inline">-i</strong>).</p>
			<p>For more details <a id="_idIndexMarker443"/>on the available options, we can check the manual with the respective command, as illustrated here:</p>
			<p class="source-code"># man podman exec</p>
			<p>We are moving forward in our journey to the container management world, and in the next section, we will also take a look at some of the capabilities that Podman offers to enable containerized workloads in the Kubernetes container orchestration world.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor099"/>Running containers in pods</h1>
			<p>As we mentioned in the <em class="italic">Docker versus Podman main differences</em> section of <a href="B17908_02_epub.xhtml#_idTextAnchor044"><em class="italic">Chapter 2</em></a>, <em class="italic">Comparing Podman and Docker </em>, Podman offers capabilities to easily start adopting <a id="_idIndexMarker444"/>some basic concepts of the de facto container orchestrator named Kubernetes (also sometimes referred to as <strong class="source-inline">k8s</strong>).</p>
			<p>The pod concept <a id="_idIndexMarker445"/>was introduced with Kubernetes and represents the smallest execution unit in a Kubernetes cluster. With Podman, users can create empty pods and then run containers inside them easily.</p>
			<p>Grouping two or <a id="_idIndexMarker446"/>more containers inside a single pod can have many benefits, such as the following:</p>
			<ul>
				<li>Sharing the same network namespace, IP address included</li>
				<li>Sharing the same storage volumes for storing persistent data</li>
				<li>Sharing the same configurations</li>
			</ul>
			<p>In addition, placing two or more containers in the same pod will actually enable them to share the same <strong class="bold">inter-process communication</strong> (<strong class="bold">IPC</strong>) Linux namespace. This could be really useful <a id="_idIndexMarker447"/>for applications that need to communicate with each other using shared memory.</p>
			<p>The simplest way to create a pod and start working with it is to use this command:</p>
			<p class="source-code"># podman pod create --name myhttp</p>
			<p class="source-code">3950703adb04c6bca7f83619ea28c650f9db37fd0060c1e263cf7ea34 dbc8dad</p>
			<p class="source-code"># podman pod ps</p>
			<p class="source-code">POD ID        NAME        STATUS      CREATED        INFRA ID       # OF CONTAINERS</p>
			<p class="source-code">3950703adb04  myhttp      Created     6 seconds ago  1bdc82 e77ba2  1</p>
			<p>As shown <a id="_idIndexMarker448"/>in the previous example, we create a new pod named <strong class="source-inline">myhttp</strong> and then check the status of the pod on our host system: there is just one pod in a <strong class="source-inline">created</strong> state.</p>
			<p>We can now start the pod as follows and check what will happen:</p>
			<p class="source-code"># podman pod start myhttp</p>
			<p class="source-code">3950703adb04c6bca7f83619ea28c650f9db37fd0060c1e263cf7ea34 dbc8dad</p>
			<p class="source-code"># podman pod ps</p>
			<p class="source-code">POD ID        NAME        STATUS      CREATED             INFRA ID      # OF CONTAINERS</p>
			<p class="source-code">3950703adb04  myhttp      Running     About a minute ago  1bdc82e77ba2  1</p>
			<p>The pod is now running, but what is Podman actually running? We created an empty pod without containers inside! Let's take a look at the running container by executing the <strong class="source-inline">podman ps</strong> command, as follows:</p>
			<p class="source-code"># podman ps</p>
			<p class="source-code">CONTAINER ID  IMAGE                 COMMAND     CREATED             STATUS            PORTS       NAMES</p>
			<p class="source-code">1bdc82e77ba2  k8s.gcr.io/pause:3.5              About a minute ago  Up 6 seconds ago              3950703adb04-infra</p>
			<p>The <strong class="source-inline">podman ps</strong> command is showing a running container with an image named <strong class="source-inline">pause</strong>. This container is run by Podman by default as an <strong class="source-inline">infra</strong> container. This kind of container does nothing—it just holds the namespace and lets the container engine connect to any other running container inside the pod.</p>
			<p>Having demystified <a id="_idIndexMarker449"/>the role of this special container inside our pods, we can now take a brief look at the steps required to start a multi-container pod.</p>
			<p>First of all, let's start by running a new container inside the existing pod we created in the previous example, as follows:</p>
			<p class="source-code"># podman run --pod myhttp -d -i -t registry.fedoraproject.org/f29/httpd</p>
			<p class="source-code">Cb75e65f10f6dc37c799a3150c1b9675e74d66d8e298a8d19eadfa125d ffdc53</p>
			<p>Then, we can check whether the existing pod has updated the number of containers it contains, as illustrated in the following code snippet:</p>
			<p class="source-code"><strong class="bold"># podman pod ps</strong></p>
			<p class="source-code">POD ID        NAME        STATUS      CREATED         INFRA ID       # OF CONTAINERS</p>
			<p class="source-code">3950703adb04  myhttp      Running     21 minutes ago  1bdc82e77ba2  2</p>
			<p>Finally, we can ask Podman for a list of running containers with the associated pod name, as follows:</p>
			<p class="source-code"><strong class="bold"># podman ps -p</strong></p>
			<p class="source-code">CONTAINER ID  IMAGE                                        COMMAND               CREATED         STATUS             PORTS       NAMES                POD ID        PODNAME</p>
			<p class="source-code">1bdc82e77ba2  k8s.gcr.io/pause:3.5                                               22 minutes ago  Up 20 minutes ago              3950703adb04-infra   3950703adb04  myhttp</p>
			<p class="source-code">cb75e65f10f6  registry.fedoraproject.org/f29/httpd:latest  /usr/bin/run-http...  4 minutes ago   Up 4 minutes ago               determined_driscoll  3950703adb04  myhttp</p>
			<p>As you can see, the two containers running are both associated with the pod named <strong class="source-inline">myhttp</strong>!</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Please consider periodically cleaning up the lab environment after completing all the examples contained in this chapter. This could help you save resources and avoid any errors when moving to the next chapter's examples. For this reason, you can refer to the code provided in the <strong class="source-inline">AdditionalMaterial</strong> folder in the book's GitHub repository: https://github.com/PacktPublishing/Podman-for-DevOps/tree/main/AdditionalMaterial.</p>
			<p>With the same <a id="_idIndexMarker450"/>approach, we can add more and more containers to the same pod, letting them share all the data we described before.</p>
			<p>Please note that placing containers in the same pod can be beneficial in some cases, but this represents an anti-pattern for the container technology. In fact, as mentioned before, Kubernetes considers the <strong class="bold">pod</strong> the smallest computing unit to run on top of the distributed nodes' part of one cluster. This means that once you group two or more containers under the same pod, they will be executed together on the same node and the orchestrator cannot balance or distribute their workload on multiple machines.</p>
			<p>We will explore more about Podman's features that can enable you to enter the container orchestration world through Kubernetes in the next chapters!</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor100"/>Summary</h1>
			<p>In this chapter, we started developing experience in managing containers, starting with container images, and then working with running containers. Once our containers were running, we also explored the various commands available in Podman to inspect and check the logs and troubleshoot our containers. The operations needed to monitor and look after running containers are really important for any container administrator. Finally, we also took a brief look at the Kubernetes concepts available in Podman that let us group two or more containers under the same Linux namespace. All the concepts and the examples we just went through will help us start our experience as a system administrator for container technologies.</p>
			<p>We are now ready to explore another important topic in the next chapter: managing storage for our containers! </p>
		</div>
	</body></html>