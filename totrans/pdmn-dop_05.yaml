- en: '*Chapter 4*: Managing Running Containers'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to set up the environment to run containers
    with Podman, covering binary installation for the major distributions, system
    configuration files, and a first example container run to verify that our setup
    was correct. This chapter will offer a more detailed overview of container execution,
    how to manage and inspect running containers, and how to group containers in pods.
    This chapter is important for gaining the right knowledge and expertise to start
    our experience as a system administrator for container technologies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing container images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations with running containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting container information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing logs from containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing processes in a running container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running containers in pods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before proceeding with this chapter and its exercises, a machine with a working
    Podman instance is required. As stated in [*Chapter 3*](B17908_03_epub.xhtml#_idTextAnchor068),
    *Running the First Container*, all the examples in the book are executed on a
    Fedora 34 system, but can be reproduced on an **operating system** (**OS**) of
    your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a good understanding of the topics covered in the previous chapters
    is useful to easily grasp concepts regarding **Open Container Initiative** (**OCI**)
    images and container execution.
  prefs: []
  type: TYPE_NORMAL
- en: Managing container images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how to find and pull (download) an image in the
    local system, as well as inspect its contents. When a container is created and
    run for the first time, Podman takes care of pulling the related image automatically.
    However, being able to pull and inspect images in advance gives some valuable
    advantages, the first being that a container executes faster when images are already
    available in the machine's local store.
  prefs: []
  type: TYPE_NORMAL
- en: As we stated in the previous chapters, containers are a way to isolate processes
    in a sandboxed environment with separate namespaces and resource allocation.
  prefs: []
  type: TYPE_NORMAL
- en: The filesystem mounted in the container is provided by the OCI image described
    in [*Chapter 2*](B17908_02_epub.xhtml#_idTextAnchor044), *Comparing Podman and
    Docker* .
  prefs: []
  type: TYPE_NORMAL
- en: OCI images are stored and distributed by specialized services called **container
    registries**. A container registry stores images and metadata and exposes simple
    **REpresentational State Transfer** (**REST**) **application programming interface**
    (**API**) services to enable users to push and pull images.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are essentially two types of registries: public and private. A public
    registry is accessible as a public service (with or without authentication). The
    main public registries such as `docker.io`, `gcr.io`, or `quay.io` are also used
    as the image repositories of larger open source projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Private registries are deployed and managed inside an organization and can be
    more focused on security and content filtering. The main container registry projects
    nowadays are graduated under the **Cloud Native Computing Foundation** (**CNCF**)
    ([https://landscape.cncf.io/card-mode?category=container-registry&grouping=category](https://landscape.cncf.io/card-mode?category=container-registry&grouping=category))
    and offer advanced enterprise features to manage multitenancy, authentication,
    and **role-based access control** (**RBAC**), as well as image vulnerability scanning
    and image signing.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B17908_09_epub.xhtml#_idTextAnchor167), *Pushing Images to
    a Container Registry*, we will provide more details and examples of interaction
    with container registries.
  prefs: []
  type: TYPE_NORMAL
- en: The largest part of public and private registries expose Docker Registry HTTP
    API V2 ([https://docs.docker.com/registry/spec/api/](https://docs.docker.com/registry/spec/api/)).
    Being a `curl` command or design their own custom clients.
  prefs: []
  type: TYPE_NORMAL
- en: Podman offers a **command-line interface** (**CLI**) to interact with public
    and private container registries, manage logins when registry authentication is
    required, search for image repositories by passing a string pattern, and handle
    locally cached images.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first command we will learn to use to search images across multiple registries
    is the `podman search` command. The following example shows how to search an nginx
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will produce an output with many entries from all the
    whitelisted registries (see the *Preparing your environment* | *Customizing container
    registries' search lists* section of [*Chapter 3*](B17908_03_epub.xhtml#_idTextAnchor068),
    *Running the First Container*). The output will be a little clumsy, with many
    entries from unknown and unreliable repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, the `podman search` command accepts the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `TERM` is the search argument. The resulting output of a search has the
    following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`INDEX`: The registry indexing the image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NAME`: The full name of the image, including the registry name and associated
    namespaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DESCRIPTION`: A short description of the image role'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STARS`: The number of stars given by users (available only on registries supporting
    this feature, such as `docker.io`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OFFICIAL`: A Boolean for specifying whether the image is official'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AUTOMATED`: A field set to `OK` if the image is automated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Never trust unknown repositories and always prefer official images. When pulling
    images from a niche project, try to understand the content of the image before
    running it. Remember that an attacker could hide malicious code that could be
    executed inside containers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Even trusted repositories can be compromised in some cases. In enterprise scenarios,
    implement image signature verification to avoid image tampering.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It is possible to apply filters to the search and refine the output. For example,
    to refine the search and print only official images, we can add the following
    filtering option that only prints out images with the `is-official` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This command will print one line pointing to `docker.io/library/nginx:latest`.
    This official image is maintained by the nginx community and can be used more
    confidently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users can refine the output format of the command. The following example shows
    how to print only the image registry and the image name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output image name has a standard naming pattern that deserves a detailed
    description. The standard format is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s describe the preceding fields in detail, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`registry`: This contains the registry the image is stored in. The nginx image
    in our example is stored in the `docker.io` public registry. Optionally, it is
    possible to specify a custom port number for the registry. By default, registries
    expose the `5000` **Transmission Control Protocol** (**TCP**) port.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`namespace`: This field provides a hierarchy structure that is useful for distinguishing
    the image context from the provider. The namespace could represent the parent
    organization, the username of the owner of the repository, or the image role.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: This contains the name of the private/public image repository where
    all the tags are stored. It is often referred to as the application name (that
    is, nginx).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tag`: Every image stored in the registry has a unique tag, mapped to a `:latest`
    tag can be omitted in the image name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The generic search hides the image tags by default. To show all available tags
    for a given repository, we can use the `â€“list-tags` option to a given image name,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This option is really useful for finding a specific image tag in the registry,
    often associated with a release version of the application/runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Using the `:latest` tag can lead to image versioning issues since it is not
    a descriptive tag. Also, it is usually expected to point to the latest image version.
    Unfortunately, this is not always true since an untagged image could retain the
    latest tag while the latest pushed image could have a different tag. It is up
    to the repository maintainer to apply tags correctly. If the repository uses semantic
    versioning, the best option is to pull the most recent version tag.
  prefs: []
  type: TYPE_NORMAL
- en: Pulling and viewing images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we have found our desired image, it can be downloaded using the `podman
    pull` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice the root user for running the Podman command. In this case, we are pulling
    the image as root, and its layers and metadata are stored in the `/var/lib/containers/storage`
    path.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the same command as a standard user by executing the command in
    a standard user''s shell, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the image will be downloaded in the user home directory under
    `$HOME/.local/share/containers/storage/` and will be available to run rootless
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users can inspect all locally cached images with the `podman images` command,
    as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The output shows the image repository name, its tag, the image **identifier**
    (**ID**), the creation date, and the image size. It is very useful to keep an
    updated view of the images available in the local store and understand which ones
    are obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `podman images` command also supports many options (a complete list is
    available by executing the `man podman-images` command). One of the more interesting
    options is `â€“sort`, which can be used to sort images by size, date, ID, repository,
    or tag. For example, we could print images sorted by creation date to find out
    the most obsolete ones, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Another couple of very useful options are the `â€“all` (or `â€“a`) and `â€“quiet`
    (or `â€“q`) options. Together, they can be combined to print only the image IDs
    of all the locally stored images, even intermediate image layers. The command
    will print output similar to the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Listing and showing the images already pulled on a system it is not the most
    interesting part of the job! Let's discover how to inspect images with their configuration
    and contents in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting images' configurations and contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To inspect the configuration of a pulled image, the `podman image inspect`
    (or the shorter `podman inspect`) command comes to help us, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The printed output will be a **JavaScript Object Notation** (**JSON**)-formatted
    object containing the image config, architecture, layers, labels, annotation,
    and the image build history.
  prefs: []
  type: TYPE_NORMAL
- en: The image history shows the creation history of every layer and is very useful
    for understanding how the image was built when the Dockerfile or the Containerfile
    is not available.
  prefs: []
  type: TYPE_NORMAL
- en: Since the output is a JSON object, we can extract single fields to collect specific
    data or use them as input parameters for other commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example prints out the command executed when a container is created
    upon this image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the formatted output is managed as a Go template.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the inspection of an image must go further than a simple configuration
    check. On occasions, we need to inspect the filesystem content of an image. To
    achieve this result, Podman offers the useful `podman image mount` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example mounts the image and prints its mount path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run a simple `ls` command in the provided path, we will see the image
    filesystem, composed from its various merged layers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To unmount the image, simply run the `podman image unmount` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Mounting images in rootless mode is a bit different since this execution mode
    only supports manual mounting of the `mount`/`unmount` commands would not work.
    A workaround is to run the `podman unshare` command first. It executes a new shell
    process inside a new namespace where the current `podman mount` command. Let''s
    see an example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the mount point is now in the `<username>` home directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To unmount, simply run the podman `unmount` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `exit` command is necessary to exit the temporary unshared namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To delete a local store image, we can use the `podman rmi` command. The following
    example deletes the nginx image pulled before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The same command works in rootless mode when executed by a standard user against
    their home local store.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove all the cached images, use the following example, which relies on
    shell command expansion to get a full list of image IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice the sharp symbol at the beginning of the line that tells us that the
    command is executed as root.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next command removes all images in a regular user local cache (notice the
    dollar symbol at the beginning of the line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The `podman rmi` command fails to remove images that are currently in use from
    a running container. First, stop the containers using the blocked images and then
    run the command again.
  prefs: []
  type: TYPE_NORMAL
- en: Podman also offers a simpler way to clean up dangling or unused imagesâ€”the `podman
    image prune` command. It does not delete images from containers in use, so if
    you have running or stopped containers, the correspondent container image will
    be not deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example deletes all unused images without asking for confirmation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The same command applies in rootless mode, deleting only images in the user
    home local store, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have learned how to manage container images on our machine. Let's
    now learn how to handle and check running containers.
  prefs: []
  type: TYPE_NORMAL
- en: Operations with running containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B17908_02_epub.xhtml#_idTextAnchor044), *Comparing Podman and
    Docker* , we learned in the *Running your first container* section how to run
    a container with basic examples, involving the execution of a Bash process inside
    a Fedora container and an `httpd` server that was also helpful for learning how
    to expose containers externally.
  prefs: []
  type: TYPE_NORMAL
- en: We will now explore a set of commands used to monitor and check our running
    containers and gain insights into their behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing and handling container status
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by running a simple container and exposing it on port `8080` to
    make it accessible externally, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is run in rootless mode, but the same can be applied as
    a root user by prepending the `sudo` command. In this case, it was simply not
    necessary to have a container executed in that way.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Rootless containers give an extra security advantage. If a malicious process
    breaks the container isolation, maybe leveraging a vulnerability on the host,
    it will at best gain the privileges of the user who started the rootless container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our container is up and running and ready to serve, we can test it
    by running a `curl` command on the localhost, which should produce a **HyperText
    Markup Language** (**HTML**) default output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, an empty nginx server without contents to serve is useless, but we
    will learn how to serve custom contents by using volumes or building custom images
    later in the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first command we can use to check our container is `podman ps`. This simply
    prints out useful information from the running containers, with the option of
    customizing and sorting the output. Let''s run the command in our host and see
    what is printed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output produces some interesting information about running containers,
    as detailed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CONTAINER ID`: Every new container gets a unique hexadecimal ID. The full
    ID has a length of 64 characters, and a shortened portion of 12 characters is
    printed in the `podman ps` output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IMAGE`: The image used by the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COMMAND`: The command executed inside the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CREATED`: The creation date of the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STATUS`: The current container status.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PORTS`: The network ports opened in the container. When a port mapping is
    applied, we can see one or more host `ip:port` pairs mapped to the container ports
    with an arrow sign. For example, the `0.0.0.0:8080->80/tcp` string means that
    the `8080/tcp` host port is exposed on all the listening interfaces and is mapped
    to the `80/tcp` container port.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NAMES`: The container name. This can be assigned by the user or be randomly
    generated by the container engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice the randomly generated name in the last column of the output. Podman
    continues the Docker *tradition* to generate random names using adjectives in
    the left part of the name and notable scientists and hackers in the right part.
    Indeed, Podman still uses the same `github.com/docker/docker/namesgenerator` Docker
    package, included in the vendor directory of the project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To get a full list of both running and stopped containers, we can add an `â€“a`
    option to the command. To demonstrate this, we first introduce the `podman stop`
    command. This changes the container status to stopped and sends a `SIGTERM` signal
    to the processes running inside the container. If the container becomes unresponsive,
    it sends a `SIGKILL` signal after a given timeout of 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to stop the previous container and check its state by executing
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, `podman ps` produced an empty output. This is because the container
    state is stopped. To get a full list of both running and stopped containers, run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Notice the status of the container, which states that the container has exited
    with a `0` exit code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The stopped container can be resumed by running the `podman start` command,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This command simply starts again the container we stopped before.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now check the container status again, we will see it is up and running,
    as indicated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Podman keeps the container configuration, storage, and metadata as long as it
    is in a stopped state. Anyway, when we resume the container, we start a new process
    inside it.
  prefs: []
  type: TYPE_NORMAL
- en: For more options, see the related `man podman-start`).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we simply need to restart a running container, we can use the `podman restart`
    command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This command has the effect of immediately restarting the processes inside the
    container with a new **process ID** (**PID**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `podman start` command can also be used to start containers that have been
    previously created but not run. To create a container without starting it, use
    the `podman create` command. The following example creates a container but does
    not start it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To start it, run `podman start` on the created container ID or name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This command is very useful for preparing an environment without running it
    or for mounting a container filesystem, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now introduce a very frequently used command: `podman rm`. As the name
    indicates, it is used to remove containers from the host. By default, it removes
    stopped containers, but it can be forced to remove running containers with the
    `â€“f` option.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the container from the previous example, if we stop it again and issue
    the `podman rm` command, as illustrated in the following code snippet, all the
    container storage, configs, and metadata will be discarded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now run a `podman ps` command again, even with the `â€“a` option, we will
    get an empty list, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: For more details, please inspect the command man page (`man podman-rm`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, it is usefulâ€”just as with imagesâ€”to print only the container ID
    with the `â€“q` option. This one, combined with the `â€“a` option, can print a list
    of all stopped and running containers in the host. Let''s try another example
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s interesting to notice that we have used a shell loop to start five identical
    containers, this time without any port mappingâ€”just plain nginx containers. We
    can inspect their IDs with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'How can we stop and remove all our running containers quickly? We can use shell
    expansion to combine it with other commands and reach the desired result. Shell
    expansion is a powerful tool that runs the command inside round parentheses and
    lets us pass the output string as arguments to the external command, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The two commands stopped all the running containers, identified by their IDs,
    and removed them from the host.
  prefs: []
  type: TYPE_NORMAL
- en: The `podman ps` command enables users to refine their output by applying specific
    filters. A full list of all applicable filters is available on the `podman-ps`
    man page. A simple but useful application is the status filter, which enables
    users to print only containers in a specific condition. Possible statuses are
    `created`, `exited`, `paused`, `running`, and `unknown`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example only prints containers in an `exited` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we can leverage the power of shell expansion to remove nothing but the
    exited containers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar result can be achieved with the simpler-to-remember `podman container
    prune` command shown here, which removes (prunes) all stopped containers from
    the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Sorting is another useful option for producing ordered output when listing
    containers. The following example shows how to sort by container ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `podman ps` command support formatting using a Go template to produce custom
    output. The next example prints only the container IDs and the commands executed
    inside them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Also, notice the `--no-trunc` option is added to avoid truncating the command
    output. This is not mandatory but is useful when we have long commands executed
    inside the containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we simply wish to extract the host PID of the process running inside the
    running containers, we can run the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, if we need to also find out information about the isolated namespaces,
    `podman ps` can print details about the cloned namespaces of the running containers.
    This is a useful starting point for advanced troubleshooting and inspection. You
    can see the command being run here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This subsection covered many common operations to control and view the status
    of containers. In the next section, we will learn how to pause and resume running
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: Pausing and unpausing containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This short section covers the `podman pause` and `podman unpause` commands.
    Despite being a section related to container status handling, it is interesting
    to understand how Podman and the container runtime leverage **control groups**
    (**cgroups**) to achieve specific purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, the `pause` and `unpause` commands have the purpose of pausing and
    resuming the processes of a running container. Now, the reader could legitimately
    need clearance about the difference between `pause` and `stop` commands in Podman.
  prefs: []
  type: TYPE_NORMAL
- en: While the `podman stop` command simply sends a `SIGTERM`/`SIGKILL` signal to
    the parent process in the container, the `podman pause` command uses cgroups to
    pause the process without terminating it. When the container is unpaused, the
    same process is resumed transparently.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pause`/`unpause` low-level logic is implemented in the container runtimeâ€”for
    the most curious, this was the implementation in `crun` at the time of writing:'
  prefs: []
  type: TYPE_NORMAL
- en: https://github.com/containers/crun/blob/7ef74c9330033cb884507c28fd8c267861486633/src/libcrun/cgroup.c#L1894-L1936
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates the podman `pause` and `unpause` commands.
    First, let''s start a Fedora container that prints a date and time string every
    2 seconds in an endless loop, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We intentionally leave the container running in a window and open a new window/tab
    to manage its status. Before issuing the `pause` command, let''s inspect the PID
    by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s pause the running container with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If we go back to the `timer` container, we see that the output just paused
    but the container has not exited. The `unpause` action seen here will bring it
    back to life:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `unpause` action, the timer container will start printing date outputs
    again. Looking at the PID here, nothing has changed, as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check the cgroups status of the paused/unpaused container. In a third
    tab, open a terminal with a root shell and access the `cgroupfs` controller hierarchy
    after replacing the correct container ID, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now, look at the `cgroup.freeze` file content. This file holds a Boolean value
    and its state changes as we pause/unpause the container from 0 to 1 and vice versa.
    Try to pause and unpause the container again to test the changes.
  prefs: []
  type: TYPE_NORMAL
- en: Cleanup Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the echo loop was issued with a `bash â€“c` command, we need to send a
    `SIGKILL` signal to the process. To do this, we can stop the container and wait
    for the 10-second timeout, or simply run a `podman kill` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ podman kill timer`'
  prefs: []
  type: TYPE_NORMAL
- en: In this subsection, we covered in detail the most common commands for watching
    and modifying a container's status. We can now move on to inspect the processes
    running inside the running containers.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting processes inside containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a container is running, processes inside it are isolated at the namespace
    level, but users still own total control of the processes running and can inspect
    their behavior. There are many levels of complexity in process inspection, but
    Podman offers tools that can speed up this task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `podman top` command: this provides a full view of the
    processes running inside a container. The following example shows the processes
    running inside an nginx container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The result is very similar to the `ps` command output rather than the interactive
    one produced by the Linux `top` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to apply custom formatting to the output. The following example
    only prints PIDs, commands, and arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We may need to inspect container processes in greater detail. As we discussed
    earlier in [*Chapter 1*](B17908_01_epub.xhtml#_idTextAnchor015), *Introduction
    to Container Technology*, once a brand-new container is started, it will start
    assigning PIDs from number 0, while under the hood, the container engine will
    map this container''s PIDs with the real ones on the host. So, we can use the
    output of the `podman ps --namespace` command to extract the process''s original
    PID in the host for a given container. With that information, we can conduct advanced
    analysis. The following example shows how to attach the `strace` command, used
    to inspect processes'' **system calls** (**syscalls**), to the process running
    inside the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Details about the usage of the `strace` command are beyond the scope of this
    book. See `man strace` for more advanced examples and a more in-depth explanation
    of the command options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful command that can be easily applied to processes running inside
    a container is `pidstat`. Once we have obtained the PID, we can inspect the resource
    usage in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The integers applied at the end represent, respectively, the execution interval
    of the command and the number of times it must print the usage stats. See `man
    pidstat` for more usage options.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a process in a container becomes unresponsive, it is possible to handle
    its abrupt termination with the `podman kill` command. By default, it sends a
    `SIGKILL` signal to the process inside the container. The following example creates
    an `httpd` container and then kills it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We can optionally send custom signals (such as `SIGTERM` or `SIGHUP`) with the
    `--signal` option. Notice that a killed container is not removed from the host
    but continues to exist, is stopped, and is in an exited status.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 10*](B17908_10_epub.xhtml#_idTextAnchor193), *Troubleshooting and
    Monitoring Containers*, we will again deal with container troubleshooting and
    learn how to use advanced tools such as `nsenter` to inspect container processes.
    We now move on to basic container statistics commands that can be useful for monitoring
    the overall resource usage by all containers running in a system.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring container stats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When multiple containers are running in the same host, it is crucial to monitor
    the amount of `podman stats` command, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Without any options, the command will open a top-like, self-refreshing window
    with the stats of all the running containers. The default printed values are listed
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ID`: The running container ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NAME`: The running container name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPU %`: The total CPU usage as a percentage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MEM USAGE / LIMIT`: Memory usage against a given limit (dictated by system
    capabilities or by cgroups-driven limits)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MEM %`: The total memory usage as a percentage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NET IO`: Network **input/output** (**I/O**) operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BLOCK IO`: Disk I/O operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PIDS`: The number of PIDs inside the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPU TIME`: Total consumed CPU time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AVG CPU %`: Average CPU usage as a percentage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In case a redirect is needed, it is possible to avoid streaming a self-refreshing
    output with the `--no-stream` option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Anyway, having a static output of this type is not very useful for parsing
    or ingestion. A better approach is to apply a JSON or Go template formatter. The
    following example prints out stats in a JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar way, it is possible to customize the output fields using a Go
    template. The following example only prints out the container ID, CPU percentage
    usage, total memory usage in bytes, and PIDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we have learned how to monitor running containers and their
    isolated processes. The next section shows how to inspect container configurations
    for analysis and troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting container information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A running container exposes a set of configuration data and metadata ready
    to be consumed. Podman implements the `podman inspect` command to print all the
    container configurations and runtime information. In its simplest form, we can
    simply pass the container ID or name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This command prints a JSON output with all the container configurations. For
    the sake of space, we will list some of the most notable fields here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Path`: The container entry point path. We will dig deeper into entry points
    later when we analyze Dockerfiles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Args`: The arguments passed to the entry point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`State`: The container''s current state, including crucial information such
    as the executed PID, the common PID, the OCI version, and the health check status.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Image`: The ID of the image used to run the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Name`: The container name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MountLabel`: Container mount label for **Security-Enhanced Linux** (**SELinux**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProcessLabel`: Container process label for SELinux.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EffectiveCaps`: Effective capabilities applied to the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GraphDriver`: The type of storage driver (default is `overlayfs`) and a list
    of overlay upper, lower, and merged directories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mounts`: The actual bind mounts in the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NetworkSettings`: The overall container network settings, including its internal
    **Internet Protocol** (**IP**) address, exposed ports, and port mappings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Config`: Container runtime configuration, including environment variables,
    hostname, command, working directory, labels, and annotations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HostConfig`: Host configuration, including cgroups'' quotas, network mode,
    and capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a huge amount of information that most of the time is too much for
    our needs. When we need to extract specific fields, we can use the `--format`
    option to print only selected ones. The following example prints only the host-bound
    PID of the process executed inside the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The result is in a Go template format. This allows for flexibility to customize
    the output string as we desire.
  prefs: []
  type: TYPE_NORMAL
- en: The `podman inspect` command is also useful for understanding the behavior of
    the container engine and for gaining useful information during troubleshooting
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when a container is launched, we learn that the `resolv.conf` file
    is mounted inside the container from a path that is defined in the `{{ .ResolvConfPath
    }}` key. The target path is `/run/user/<UID>/containers/overlay-containers/<Container_ID>/userdata/resolv.conf`
    when the container is executed in rootless mode, and `/var/run/containers/storage/overlay-containers/<Container_ID>/userdata/resolv.conf`
    when in rootful mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other interesting information is the list of all the merged layers managed
    by `overlayfs`. Let''s try to run a new container, this time in rootful mode,
    and find out information about the merged layers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This container runs a simple loop that writes a string on a text file every
    5 seconds. Now, let''s run a `podman inspect` command to find out information
    about `MergedDir`, which is the directory where all layers are merged by `overlayfs`.
    The code is illustrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this directory, we can find the `/tmp/test.log` file, as indicated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We can dig deeperâ€”the `LowerDir` directory holds a list of the base image layers,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the base image is made up of only one layer. Are we going
    to find the log file here? Let''s have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We are missing the log file in this layer. This is because the `LowerDir` directory
    is not written and represents the read-only image layers. It is merged with an
    `UpperDir` directory that is the read-write layer of the container. With `podman
    inspect`, we can find out where it resides, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The output directory will contain only a bunch of files and directories, written
    since the container startup, including the `/tmp/test.log` file, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now stop and remove the logger container by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This example was in anticipation of the container storage topic that will be
    covered in [*Chapter 5*](B17908_05_epub.xhtml#_idTextAnchor101), *Implementing
    Storage for the Container's Data*. The `overlayfs` mechanisms, with the lower,
    upper, and merged directory concepts, will be analyzed in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to inspect running containers and collect runtime
    information and configurations. The next section is going to cover best practices
    for capturing logs from containers.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing logs from containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described earlier in this chapter, containers are made of one or more processes
    that can fail, printing errors and describing their current state in a log file.
    But where are these logs stored?
  prefs: []
  type: TYPE_NORMAL
- en: Well, of course, a process in a container could write its log messages inside
    a file somewhere in a temporary filesystem that the container engine has made
    available to it (if any). But what about a read-only filesystem or any permission
    constraints in the running container?
  prefs: []
  type: TYPE_NORMAL
- en: 'A container''s best practice for exposing relevant logs outside the container''s
    shield actually leverages the use of standard streams: `STDOUT`) and `STDERR`).'
  prefs: []
  type: TYPE_NORMAL
- en: Good to Know
  prefs: []
  type: TYPE_NORMAL
- en: Standard streams are communication channels interconnected to a running process
    in an OS. When a program is run through an interactive shell, these streams are
    then directly connected to the user's running terminal to let input, output, and
    error flow between the terminal and the process, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the options we use for running a brand-new container, Podman will
    act appropriately by attaching the `STDIN`, `STDOUT`, and `STDERR` standard streams
    to a local file for storing the logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B17908_03_epub.xhtml#_idTextAnchor068), *Running the First
    Container*, we saw how to run a container in the background, detaching from a
    running container. We used the `-d` option to start a container in *detached*
    mode through the `podman run` command, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: With the previous command, we are instructing Podman to start a container in
    detached mode (`-d`), with a pseudo-terminal attached to the `STDIN` stream (`-t`)
    keeping the standard input stream open even if there is no terminal attached yet
    (`-i`).
  prefs: []
  type: TYPE_NORMAL
- en: The standard Podman behavior is to attach to `STDOUT` and `STDERR` streams and
    store any container's published data in a log file on the host filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are working with Podman as a *root* user, we can take a look at the log
    file available on the host system, executing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to start our container and take note of the ID returned by Podman,
    or ask Podman for a list of containers and take note of their ID. The code to
    accomplish this is shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we can take a look under the `/var/lib/containers/storage/overlay-containers/`
    directory and search for a folder with a name that matches our container''s ID,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can check the logs of our running container by taking a look at
    the file named `ctr.log` in the `userdata` directory, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We just discovered the secret place where Podman saves all logs of our containers!
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the procedure we just introduced will work properly if the
    `log_driver` field for the `containers.conf` file is set to the `k8s-file` value.
    For example, in the Fedora Linux distribution starting from version 35, the maintainers
    decided to switch from `k8s-file` to `journald`. In this case, you could look
    for the logs directly using the `journalctl` command-line utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to take a look at the default `log_driver` field, you can look
    in the following path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Does this mean that we need to perform this entire complex procedure every time
    we need to analyze the logs of our containers? Of course not!
  prefs: []
  type: TYPE_NORMAL
- en: 'Podman has a `podman logs` built-in command that can easily discover, grab,
    and print the latest container logs for us. Considering the previous example,
    we can easily check the logs of our running container by executing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also get the short ID for our running container and pass this ID to
    the `podman logs` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous command, we also used a nice option of the `podman logs` command:
    the `--tail` option, which lets us output only the latest needed rows of the container''s
    log. In our case, we requested the latest two.'
  prefs: []
  type: TYPE_NORMAL
- en: As we saw earlier in this section, Podman saves the container logs into the
    host filesystem. These files, by default, are not limited in size, so it could
    happen that for long-living containers that might produce a lot of logs, these
    files could become very large.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, as we usually talk about logs and log files, one important
    configuration parameter that could help reduce the log files'' size is available
    through the Podman global configuration file available at this location: `/etc/containers/containers.conf`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If this configuration file is missing, you can easily create a new one, inserting
    the following rows to apply the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Through the previous configuration, we are limiting every log file for our future
    running containers to 10 **megabytes** (**MB**). If you have some running containers,
    you have to restart them to apply this new configuration.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to move to the next section, where we will discover another
    useful command.
  prefs: []
  type: TYPE_NORMAL
- en: Executing processes in a running container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Podman daemonless architecture* section of [*Chapter 2*](B17908_02_epub.xhtml#_idTextAnchor044),
    *Comparing Podman and Docker*, we talked about the fact that Podman, as with any
    other container engine, leverages the Linux namespace functionality to correctly
    isolate running containers from each other and from the OS host as well.
  prefs: []
  type: TYPE_NORMAL
- en: So, just because Podman creates a brand-new namespace for every running container,
    it should not be a surprise that we can attach to the same Linux namespace of
    a running container, executing other processes just as in a full operating environment.
  prefs: []
  type: TYPE_NORMAL
- en: Podman gives us the ability to execute a process in a running container through
    the `podman exec` command.
  prefs: []
  type: TYPE_NORMAL
- en: Once executed, this command will find internally the right Linux namespace to
    which the target running container is attached. Having found the Linux namespace,
    Podman will execute the respective process, passed as an argument to the `podman
    exec` command, attaching it to the target Linux namespace. The final process will
    be in the same environment as the original process companion and it will be able
    to interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how this works in practice, we can consider the following example
    whereby we will first run a container and then execute a process beside the existing
    processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the previous commands, we grabbed the container ID provided
    by Podman once the container was started and we passed it to the `podman exec`
    command as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: The `podman exec` command could be really useful for troubleshooting, testing,
    and working with an existing container. In the preceding example, we attached
    an interactive terminal running the Bash console, and we launched the `ps` command
    for inspecting the running processes available in the current Linux namespace
    assigned to the container.
  prefs: []
  type: TYPE_NORMAL
- en: The `podman exec` command has many options available, similar to the ones provided
    by the `podman run` command. As you saw from the previous example, we used the
    option for getting a pseudo-terminal attached to the `STDIN` stream (`-t`), keeping
    the standard input stream open even if there is no terminal attached yet (`-i`).
  prefs: []
  type: TYPE_NORMAL
- en: 'For more details on the available options, we can check the manual with the
    respective command, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: We are moving forward in our journey to the container management world, and
    in the next section, we will also take a look at some of the capabilities that
    Podman offers to enable containerized workloads in the Kubernetes container orchestration
    world.
  prefs: []
  type: TYPE_NORMAL
- en: Running containers in pods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in the *Docker versus Podman main differences* section of [*Chapter
    2*](B17908_02_epub.xhtml#_idTextAnchor044), *Comparing Podman and Docker* , Podman
    offers capabilities to easily start adopting some basic concepts of the de facto
    container orchestrator named Kubernetes (also sometimes referred to as `k8s`).
  prefs: []
  type: TYPE_NORMAL
- en: The pod concept was introduced with Kubernetes and represents the smallest execution
    unit in a Kubernetes cluster. With Podman, users can create empty pods and then
    run containers inside them easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Grouping two or more containers inside a single pod can have many benefits,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Sharing the same network namespace, IP address included
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing the same storage volumes for storing persistent data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing the same configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, placing two or more containers in the same pod will actually enable
    them to share the same **inter-process communication** (**IPC**) Linux namespace.
    This could be really useful for applications that need to communicate with each
    other using shared memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to create a pod and start working with it is to use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the previous example, we create a new pod named `myhttp` and then
    check the status of the pod on our host system: there is just one pod in a `created`
    state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now start the pod as follows and check what will happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The pod is now running, but what is Podman actually running? We created an
    empty pod without containers inside! Let''s take a look at the running container
    by executing the `podman ps` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The `podman ps` command is showing a running container with an image named `pause`.
    This container is run by Podman by default as an `infra` container. This kind
    of container does nothingâ€”it just holds the namespace and lets the container engine
    connect to any other running container inside the pod.
  prefs: []
  type: TYPE_NORMAL
- en: Having demystified the role of this special container inside our pods, we can
    now take a brief look at the steps required to start a multi-container pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s start by running a new container inside the existing pod
    we created in the previous example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can check whether the existing pod has updated the number of containers
    it contains, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can ask Podman for a list of running containers with the associated
    pod name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the two containers running are both associated with the pod
    named `myhttp`!
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Please consider periodically cleaning up the lab environment after completing
    all the examples contained in this chapter. This could help you save resources
    and avoid any errors when moving to the next chapter''s examples. For this reason,
    you can refer to the code provided in the `AdditionalMaterial` folder in the book''s
    GitHub repository: https://github.com/PacktPublishing/Podman-for-DevOps/tree/main/AdditionalMaterial.'
  prefs: []
  type: TYPE_NORMAL
- en: With the same approach, we can add more and more containers to the same pod,
    letting them share all the data we described before.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that placing containers in the same pod can be beneficial in some
    cases, but this represents an anti-pattern for the container technology. In fact,
    as mentioned before, Kubernetes considers the **pod** the smallest computing unit
    to run on top of the distributed nodes' part of one cluster. This means that once
    you group two or more containers under the same pod, they will be executed together
    on the same node and the orchestrator cannot balance or distribute their workload
    on multiple machines.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore more about Podman's features that can enable you to enter the
    container orchestration world through Kubernetes in the next chapters!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started developing experience in managing containers, starting
    with container images, and then working with running containers. Once our containers
    were running, we also explored the various commands available in Podman to inspect
    and check the logs and troubleshoot our containers. The operations needed to monitor
    and look after running containers are really important for any container administrator.
    Finally, we also took a brief look at the Kubernetes concepts available in Podman
    that let us group two or more containers under the same Linux namespace. All the
    concepts and the examples we just went through will help us start our experience
    as a system administrator for container technologies.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to explore another important topic in the next chapter: managing
    storage for our containers!'
  prefs: []
  type: TYPE_NORMAL
