- en: '*Chapter 4*: Managing Running Containers'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第四章*：管理运行中的容器'
- en: In the previous chapter, we learned how to set up the environment to run containers
    with Podman, covering binary installation for the major distributions, system
    configuration files, and a first example container run to verify that our setup
    was correct. This chapter will offer a more detailed overview of container execution,
    how to manage and inspect running containers, and how to group containers in pods.
    This chapter is important for gaining the right knowledge and expertise to start
    our experience as a system administrator for container technologies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们学习了如何设置环境以便使用Podman运行容器，包括主要发行版的二进制安装、系统配置文件以及第一个示例容器的运行，以验证我们的设置是否正确。本章将提供容器执行的更详细概述，介绍如何管理和检查正在运行的容器，以及如何将容器分组到Pod中。本章对于获得正确的知识和技能，以便开始作为容器技术的系统管理员经验非常重要。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Managing container images
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理容器镜像
- en: Operations with running containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与运行中的容器进行操作
- en: Inspecting container information
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查容器信息
- en: Capturing logs from containers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获容器日志
- en: Executing processes in a running container
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行的容器中执行进程
- en: Running containers in pods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Pod中运行容器
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before proceeding with this chapter and its exercises, a machine with a working
    Podman instance is required. As stated in [*Chapter 3*](B17908_03_epub.xhtml#_idTextAnchor068),
    *Running the First Container*, all the examples in the book are executed on a
    Fedora 34 system, but can be reproduced on an **operating system** (**OS**) of
    your choice.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本章及其练习之前，需要一台运行Podman实例的机器。如[*第三章*](B17908_03_epub.xhtml#_idTextAnchor068)所述，*运行第一个容器*，本书中的所有示例都在Fedora
    34系统上执行，但也可以在您选择的**操作系统**（**OS**）上复制。
- en: Finally, a good understanding of the topics covered in the previous chapters
    is useful to easily grasp concepts regarding **Open Container Initiative** (**OCI**)
    images and container execution.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，充分理解前几章中涵盖的主题有助于轻松掌握有关**开放容器倡议**（**OCI**）镜像和容器执行的概念。
- en: Managing container images
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理容器镜像
- en: In this section, we will see how to find and pull (download) an image in the
    local system, as well as inspect its contents. When a container is created and
    run for the first time, Podman takes care of pulling the related image automatically.
    However, being able to pull and inspect images in advance gives some valuable
    advantages, the first being that a container executes faster when images are already
    available in the machine's local store.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何在本地系统中查找并拉取（下载）镜像，以及如何检查其内容。当容器第一次创建并运行时，Podman会自动拉取相关镜像。然而，能够提前拉取和检查镜像具有一些宝贵的优势，第一个优势是，当镜像已经在机器的本地存储中时，容器执行速度更快。
- en: As we stated in the previous chapters, containers are a way to isolate processes
    in a sandboxed environment with separate namespaces and resource allocation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，容器是一种将进程隔离在具有独立命名空间和资源分配的沙箱环境中的方式。
- en: The filesystem mounted in the container is provided by the OCI image described
    in [*Chapter 2*](B17908_02_epub.xhtml#_idTextAnchor044), *Comparing Podman and
    Docker* .
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 容器中挂载的文件系统由在[*第二章*](B17908_02_epub.xhtml#_idTextAnchor044)中描述的OCI镜像提供，*比较Podman和Docker*。
- en: OCI images are stored and distributed by specialized services called **container
    registries**. A container registry stores images and metadata and exposes simple
    **REpresentational State Transfer** (**REST**) **application programming interface**
    (**API**) services to enable users to push and pull images.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: OCI镜像由专门的服务称为**容器镜像仓库**进行存储和分发。容器镜像仓库存储镜像和元数据，并暴露简单的**表述性状态转移**（**REST**）**应用程序编程接口**（**API**）服务，以便用户推送和拉取镜像。
- en: 'There are essentially two types of registries: public and private. A public
    registry is accessible as a public service (with or without authentication). The
    main public registries such as `docker.io`, `gcr.io`, or `quay.io` are also used
    as the image repositories of larger open source projects.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上有两种类型的镜像仓库：公共和私有。公共仓库作为公共服务可以访问（有或没有认证）。主要的公共仓库，如`docker.io`、`gcr.io`或`quay.io`，也被用作大型开源项目的镜像库。
- en: Private registries are deployed and managed inside an organization and can be
    more focused on security and content filtering. The main container registry projects
    nowadays are graduated under the **Cloud Native Computing Foundation** (**CNCF**)
    ([https://landscape.cncf.io/card-mode?category=container-registry&grouping=category](https://landscape.cncf.io/card-mode?category=container-registry&grouping=category))
    and offer advanced enterprise features to manage multitenancy, authentication,
    and **role-based access control** (**RBAC**), as well as image vulnerability scanning
    and image signing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 私有注册表是在组织内部部署和管理的，可以更专注于安全性和内容过滤。目前的主要容器注册表项目已在**云原生计算基金会**（**CNCF**）下毕业（[https://landscape.cncf.io/card-mode?category=container-registry&grouping=category](https://landscape.cncf.io/card-mode?category=container-registry&grouping=category)），并提供管理多租户、身份验证、**基于角色的访问控制**（**RBAC**）等高级企业功能，以及图像漏洞扫描和图像签名。
- en: In [*Chapter 9*](B17908_09_epub.xhtml#_idTextAnchor167), *Pushing Images to
    a Container Registry*, we will provide more details and examples of interaction
    with container registries.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B17908_09_epub.xhtml#_idTextAnchor167)中，*推送图像到容器注册表*，我们将提供更多关于与容器注册表交互的细节和示例。
- en: The largest part of public and private registries expose Docker Registry HTTP
    API V2 ([https://docs.docker.com/registry/spec/api/](https://docs.docker.com/registry/spec/api/)).
    Being a `curl` command or design their own custom clients.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分公共和私有注册表暴露Docker Registry HTTP API V2（[https://docs.docker.com/registry/spec/api/](https://docs.docker.com/registry/spec/api/)）。使用`curl`命令或设计自己的定制客户端。
- en: Podman offers a **command-line interface** (**CLI**) to interact with public
    and private container registries, manage logins when registry authentication is
    required, search for image repositories by passing a string pattern, and handle
    locally cached images.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Podman提供了一个**命令行界面**（**CLI**），用于与公共和私有容器注册表进行交互，管理在需要注册表身份验证时的登录，按字符串模式搜索图像仓库，以及处理本地缓存的图像。
- en: Searching for images
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索图像
- en: 'The first command we will learn to use to search images across multiple registries
    is the `podman search` command. The following example shows how to search an nginx
    image:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习的第一个用于在多个注册表中搜索图像的命令是`podman search`命令。以下示例展示了如何搜索nginx图像：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding command will produce an output with many entries from all the
    whitelisted registries (see the *Preparing your environment* | *Customizing container
    registries' search lists* section of [*Chapter 3*](B17908_03_epub.xhtml#_idTextAnchor068),
    *Running the First Container*). The output will be a little clumsy, with many
    entries from unknown and unreliable repositories.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将生成一个输出，其中包含来自所有白名单注册表的多个条目（参见[*第3章*](B17908_03_epub.xhtml#_idTextAnchor068)，*运行第一个容器*部分，*准备你的环境*
    | *自定义容器注册表的搜索列表*）。输出会有点笨重，包含来自未知和不可靠仓库的多个条目。
- en: 'In general, the `podman search` command accepts the following pattern:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，`podman search`命令接受以下模式：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, `TERM` is the search argument. The resulting output of a search has the
    following fields:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`TERM`是搜索参数。搜索结果的输出包含以下字段：
- en: '`INDEX`: The registry indexing the image'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INDEX`：索引该图像的注册表'
- en: '`NAME`: The full name of the image, including the registry name and associated
    namespaces'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NAME`：图像的完整名称，包括注册表名称和相关的命名空间'
- en: '`DESCRIPTION`: A short description of the image role'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DESCRIPTION`：图像角色的简短描述'
- en: '`STARS`: The number of stars given by users (available only on registries supporting
    this feature, such as `docker.io`)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STARS`：用户评分的星级数（仅在支持此功能的注册表中可用，如`docker.io`）'
- en: '`OFFICIAL`: A Boolean for specifying whether the image is official'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OFFICIAL`：一个布尔值，用于指定图像是否为官方图像'
- en: '`AUTOMATED`: A field set to `OK` if the image is automated'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AUTOMATED`：如果图像是自动化的，该字段设置为`OK`'
- en: Important Note
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要说明
- en: Never trust unknown repositories and always prefer official images. When pulling
    images from a niche project, try to understand the content of the image before
    running it. Remember that an attacker could hide malicious code that could be
    executed inside containers.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 永远不要信任未知的仓库，总是优先选择官方图像。拉取来自小众项目的图像时，尝试在运行之前了解图像的内容。记住，攻击者可能会在容器内部隐藏恶意代码。
- en: Even trusted repositories can be compromised in some cases. In enterprise scenarios,
    implement image signature verification to avoid image tampering.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 即使是受信任的仓库，也有可能在某些情况下被攻破。在企业场景中，实施图像签名验证以避免图像篡改。
- en: 'It is possible to apply filters to the search and refine the output. For example,
    to refine the search and print only official images, we can add the following
    filtering option that only prints out images with the `is-official` flag:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 可以对搜索应用过滤器并细化输出。例如，为了精确搜索并仅打印官方镜像，我们可以添加以下过滤选项，仅打印带有`is-official`标志的镜像：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command will print one line pointing to `docker.io/library/nginx:latest`.
    This official image is maintained by the nginx community and can be used more
    confidently.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将打印一行指向`docker.io/library/nginx:latest`。这个官方镜像由nginx社区维护，可以更放心地使用。
- en: 'Users can refine the output format of the command. The following example shows
    how to print only the image registry and the image name:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以调整命令的输出格式。以下示例演示了如何仅打印镜像注册表和镜像名称：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output image name has a standard naming pattern that deserves a detailed
    description. The standard format is shown here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的镜像名称有一个标准的命名模式，值得详细描述。标准格式如下所示：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s describe the preceding fields in detail, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细描述前面提到的字段，如下所示：
- en: '`registry`: This contains the registry the image is stored in. The nginx image
    in our example is stored in the `docker.io` public registry. Optionally, it is
    possible to specify a custom port number for the registry. By default, registries
    expose the `5000` **Transmission Control Protocol** (**TCP**) port.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registry`：这包含存储镜像的注册表。在我们的示例中，nginx镜像存储在`docker.io`公共注册表中。可选地，也可以为注册表指定自定义端口号。默认情况下，注册表会暴露`5000`
    **传输控制协议** (**TCP**) 端口。'
- en: '`namespace`: This field provides a hierarchy structure that is useful for distinguishing
    the image context from the provider. The namespace could represent the parent
    organization, the username of the owner of the repository, or the image role.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`namespace`：此字段提供了一个层次结构，有助于区分镜像的上下文和提供者。命名空间可以代表父组织、仓库所有者的用户名或镜像角色。'
- en: '`name`: This contains the name of the private/public image repository where
    all the tags are stored. It is often referred to as the application name (that
    is, nginx).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这包含存储所有标签的私有/公共镜像仓库的名称。通常将其称为应用程序名称（即nginx）。'
- en: '`tag`: Every image stored in the registry has a unique tag, mapped to a `:latest`
    tag can be omitted in the image name.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tag`：每个存储在注册表中的镜像都有一个唯一的标签，映射到`:latest`标签时，镜像名称中可以省略该标签。'
- en: 'The generic search hides the image tags by default. To show all available tags
    for a given repository, we can use the `–list-tags` option to a given image name,
    as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通用搜索默认隐藏镜像标签。要显示给定仓库的所有可用标签，我们可以对给定的镜像名称使用`–list-tags`选项，如下所示：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This option is really useful for finding a specific image tag in the registry,
    often associated with a release version of the application/runtime.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项对于在注册表中查找特定镜像标签非常有用，通常与应用程序/运行时的发布版本相关联。
- en: Important Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Using the `:latest` tag can lead to image versioning issues since it is not
    a descriptive tag. Also, it is usually expected to point to the latest image version.
    Unfortunately, this is not always true since an untagged image could retain the
    latest tag while the latest pushed image could have a different tag. It is up
    to the repository maintainer to apply tags correctly. If the repository uses semantic
    versioning, the best option is to pull the most recent version tag.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`:latest`标签可能会导致镜像版本控制问题，因为它不是描述性的标签。而且，通常期望它指向最新的镜像版本。不幸的是，这并不总是正确的，因为一个未标记的镜像可能会保留`latest`标签，而最新推送的镜像可能具有不同的标签。是否正确应用标签由仓库维护者决定。如果仓库使用语义版本控制，最好的选择是拉取最新版本标签。
- en: Pulling and viewing images
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拉取和查看镜像
- en: 'Once we have found our desired image, it can be downloaded using the `podman
    pull` command, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到了所需的镜像，就可以使用`podman pull`命令下载，如下所示：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice the root user for running the Podman command. In this case, we are pulling
    the image as root, and its layers and metadata are stored in the `/var/lib/containers/storage`
    path.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意运行Podman命令的根用户。在这种情况下，我们作为root用户拉取镜像，其层和元数据存储在`/var/lib/containers/storage`路径中。
- en: 'We can run the same command as a standard user by executing the command in
    a standard user''s shell, like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在标准用户的shell中执行相同的命令，以标准用户身份运行该命令，如下所示：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case, the image will be downloaded in the user home directory under
    `$HOME/.local/share/containers/storage/` and will be available to run rootless
    containers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，镜像将被下载到用户的主目录下，路径为`$HOME/.local/share/containers/storage/`，并可用于运行无根容器。
- en: 'Users can inspect all locally cached images with the `podman images` command,
    as illustrated here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以使用`podman images`命令检查所有本地缓存的镜像，如此处所示：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The output shows the image repository name, its tag, the image **identifier**
    (**ID**), the creation date, and the image size. It is very useful to keep an
    updated view of the images available in the local store and understand which ones
    are obsolete.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了镜像的仓库名称、标签、镜像**标识符**（**ID**）、创建日期和镜像大小。这对于保持本地存储中的镜像的最新视图，并了解哪些镜像已过时非常有用。
- en: 'The `podman images` command also supports many options (a complete list is
    available by executing the `man podman-images` command). One of the more interesting
    options is `–sort`, which can be used to sort images by size, date, ID, repository,
    or tag. For example, we could print images sorted by creation date to find out
    the most obsolete ones, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman images`命令还支持许多选项（可以通过执行`man podman-images`命令获取完整列表）。其中一个更有趣的选项是`–sort`，它可以用于按大小、日期、ID、仓库或标签对镜像进行排序。例如，我们可以按创建日期排序，找出最过时的镜像，如下所示：'
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Another couple of very useful options are the `–all` (or `–a`) and `–quiet`
    (or `–q`) options. Together, they can be combined to print only the image IDs
    of all the locally stored images, even intermediate image layers. The command
    will print output similar to the following example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的选项是`–all`（或`–a`）和`–quiet`（或`–q`）选项。它们可以组合使用，打印出所有本地存储的镜像的镜像ID，包括中间层镜像。该命令的输出将类似于以下示例：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Listing and showing the images already pulled on a system it is not the most
    interesting part of the job! Let's discover how to inspect images with their configuration
    and contents in the next section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统中列出并显示已经拉取的镜像并不是最有趣的部分！让我们在下一节中探讨如何检查镜像的配置和内容。
- en: Inspecting images' configurations and contents
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查镜像的配置和内容
- en: 'To inspect the configuration of a pulled image, the `podman image inspect`
    (or the shorter `podman inspect`) command comes to help us, as illustrated here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查拉取镜像的配置，`podman image inspect`（或更短的`podman inspect`）命令可以帮助我们，如此处所示：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The printed output will be a **JavaScript Object Notation** (**JSON**)-formatted
    object containing the image config, architecture, layers, labels, annotation,
    and the image build history.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 打印的输出将是一个**JavaScript对象表示法**（**JSON**）格式的对象，包含镜像配置、架构、层、标签、注释和镜像构建历史。
- en: The image history shows the creation history of every layer and is very useful
    for understanding how the image was built when the Dockerfile or the Containerfile
    is not available.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图像历史显示了每一层的创建历史，对于在没有Dockerfile或Containerfile的情况下，理解图像是如何构建的非常有用。
- en: Since the output is a JSON object, we can extract single fields to collect specific
    data or use them as input parameters for other commands.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于输出是一个JSON对象，我们可以提取单个字段来收集特定数据，或者将它们用作其他命令的输入参数。
- en: 'The following example prints out the command executed when a container is created
    upon this image:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例打印出创建容器时执行的命令：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that the formatted output is managed as a Go template.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，格式化输出是通过Go模板进行管理的。
- en: Sometimes, the inspection of an image must go further than a simple configuration
    check. On occasions, we need to inspect the filesystem content of an image. To
    achieve this result, Podman offers the useful `podman image mount` command.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，镜像的检查必须超越简单的配置检查。在某些情况下，我们需要检查镜像的文件系统内容。为了实现这一点，Podman提供了有用的`podman image
    mount`命令。
- en: 'The following example mounts the image and prints its mount path:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例挂载该镜像并打印其挂载路径：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we run a simple `ls` command in the provided path, we will see the image
    filesystem, composed from its various merged layers, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在提供的路径中运行简单的`ls`命令，我们将看到由其各种合并层组成的镜像文件系统，如下所示：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To unmount the image, simply run the `podman image unmount` command, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要卸载镜像，只需运行`podman image unmount`命令，如下所示：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Mounting images in rootless mode is a bit different since this execution mode
    only supports manual mounting of the `mount`/`unmount` commands would not work.
    A workaround is to run the `podman unshare` command first. It executes a new shell
    process inside a new namespace where the current `podman mount` command. Let''s
    see an example here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以rootless模式挂载镜像有点不同，因为此执行模式仅支持手动挂载，`mount`/`unmount`命令将无法工作。一个解决方法是先运行`podman
    unshare`命令，它将在一个新的命名空间中执行一个新的shell进程，其中当前的`podman mount`命令可以正常工作。让我们在这里看一个示例：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that the mount point is now in the `<username>` home directory.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，挂载点现在位于`<username>`的主目录中。
- en: 'To unmount, simply run the podman `unmount` command, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要卸载，只需运行podman `unmount`命令，如下所示：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `exit` command is necessary to exit the temporary unshared namespace.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`exit`命令用于退出临时的未共享命名空间。'
- en: Deleting images
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除镜像
- en: 'To delete a local store image, we can use the `podman rmi` command. The following
    example deletes the nginx image pulled before:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除本地存储的镜像，我们可以使用`podman rmi`命令。以下示例删除之前拉取的nginx镜像：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The same command works in rootless mode when executed by a standard user against
    their home local store.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的命令在rootless模式下也有效，当标准用户在其主目录本地存储中执行时。
- en: 'To remove all the cached images, use the following example, which relies on
    shell command expansion to get a full list of image IDs:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除所有缓存的镜像，请使用以下示例，该示例依赖于Shell命令扩展来获取完整的镜像ID列表：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice the sharp symbol at the beginning of the line that tells us that the
    command is executed as root.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意行首的井号符号，这告诉我们命令是以root身份执行的。
- en: 'The next command removes all images in a regular user local cache (notice the
    dollar symbol at the beginning of the line):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个命令删除常规用户本地缓存中的所有镜像（注意行首的美元符号）：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Important Note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `podman rmi` command fails to remove images that are currently in use from
    a running container. First, stop the containers using the blocked images and then
    run the command again.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman rmi`命令无法删除当前在运行容器中使用的镜像。首先，停止使用被阻塞镜像的容器，然后再运行该命令。'
- en: Podman also offers a simpler way to clean up dangling or unused images—the `podman
    image prune` command. It does not delete images from containers in use, so if
    you have running or stopped containers, the correspondent container image will
    be not deleted.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Podman还提供了一种更简单的方式来清理悬挂或未使用的镜像——`podman image prune`命令。它不会删除正在使用中的容器的镜像，因此如果你有正在运行或已停止的容器，对应的容器镜像将不会被删除。
- en: 'The following example deletes all unused images without asking for confirmation:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例删除所有未使用的镜像，且无需确认：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The same command applies in rootless mode, deleting only images in the user
    home local store, as illustrated in the following code snippet:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的命令适用于rootless模式，只删除用户主目录本地存储中的镜像，如下代码片段所示：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With this, we have learned how to manage container images on our machine. Let's
    now learn how to handle and check running containers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个，我们已经学习了如何管理我们机器上的容器镜像。接下来，让我们学习如何处理和检查正在运行的容器。
- en: Operations with running containers
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与正在运行的容器的操作
- en: In [*Chapter 2*](B17908_02_epub.xhtml#_idTextAnchor044), *Comparing Podman and
    Docker* , we learned in the *Running your first container* section how to run
    a container with basic examples, involving the execution of a Bash process inside
    a Fedora container and an `httpd` server that was also helpful for learning how
    to expose containers externally.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B17908_02_epub.xhtml#_idTextAnchor044)，*比较Podman和Docker*中，我们在*运行你的第一个容器*部分学习了如何通过基本示例运行容器，涉及在Fedora容器内执行Bash进程和`httpd`服务器，这对于学习如何将容器暴露到外部也很有帮助。
- en: We will now explore a set of commands used to monitor and check our running
    containers and gain insights into their behavior.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索一组用于监控和检查正在运行的容器的命令，并获得有关它们行为的洞察。
- en: Viewing and handling container status
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看和处理容器状态
- en: 'Let''s start by running a simple container and exposing it on port `8080` to
    make it accessible externally, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先运行一个简单的容器，并将其暴露在`8080`端口，使其能够从外部访问，如下所示：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding example is run in rootless mode, but the same can be applied as
    a root user by prepending the `sudo` command. In this case, it was simply not
    necessary to have a container executed in that way.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例在rootless模式下运行，但相同的操作也可以作为root用户应用，只需在命令前添加`sudo`。在这种情况下，实际上不需要以这种方式执行容器。
- en: Important Note
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Rootless containers give an extra security advantage. If a malicious process
    breaks the container isolation, maybe leveraging a vulnerability on the host,
    it will at best gain the privileges of the user who started the rootless container.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Rootless容器提供了额外的安全优势。如果恶意进程突破了容器的隔离，可能利用主机上的漏洞，那么它最多会获得启动rootless容器的用户的权限。
- en: 'Now that our container is up and running and ready to serve, we can test it
    by running a `curl` command on the localhost, which should produce a **HyperText
    Markup Language** (**HTML**) default output like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的容器已经启动并运行，并准备好提供服务，我们可以通过在本地主机上运行`curl`命令来测试它，应该会产生如下的**超文本标记语言** (**HTML**)
    默认输出：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Obviously, an empty nginx server without contents to serve is useless, but we
    will learn how to serve custom contents by using volumes or building custom images
    later in the next chapters.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，一个没有内容可提供的空nginx服务器是没有用的，但我们将在接下来的章节中学习如何通过使用卷或构建自定义镜像来提供自定义内容。
- en: 'The first command we can use to check our container is `podman ps`. This simply
    prints out useful information from the running containers, with the option of
    customizing and sorting the output. Let''s run the command in our host and see
    what is printed, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的第一个命令来检查容器状态的是`podman ps`。这个命令简单地打印出运行中容器的有用信息，并且可以自定义和排序输出。让我们在主机上运行此命令并查看输出，如下所示：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output produces some interesting information about running containers,
    as detailed here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 输出提供了一些关于正在运行容器的有趣信息，具体如下：
- en: '`CONTAINER ID`: Every new container gets a unique hexadecimal ID. The full
    ID has a length of 64 characters, and a shortened portion of 12 characters is
    printed in the `podman ps` output.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONTAINER ID`：每个新容器都会获得一个唯一的十六进制ID。完整ID的长度为64个字符，`podman ps`输出中显示的是其中12个字符的简短版本。'
- en: '`IMAGE`: The image used by the container.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IMAGE`：容器使用的镜像。'
- en: '`COMMAND`: The command executed inside the container.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMMAND`：容器内执行的命令。'
- en: '`CREATED`: The creation date of the container.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREATED`：容器的创建日期。'
- en: '`STATUS`: The current container status.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STATUS`：当前容器的状态。'
- en: '`PORTS`: The network ports opened in the container. When a port mapping is
    applied, we can see one or more host `ip:port` pairs mapped to the container ports
    with an arrow sign. For example, the `0.0.0.0:8080->80/tcp` string means that
    the `8080/tcp` host port is exposed on all the listening interfaces and is mapped
    to the `80/tcp` container port.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PORTS`：容器中打开的网络端口。当应用端口映射时，我们可以看到一个或多个主机`ip:port`对映射到容器端口，并带有箭头符号。例如，`0.0.0.0:8080->80/tcp`表示主机端口`8080/tcp`暴露在所有监听接口上，并映射到容器端口`80/tcp`。'
- en: '`NAMES`: The container name. This can be assigned by the user or be randomly
    generated by the container engine.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NAMES`：容器名称。这个名称可以由用户指定，也可以由容器引擎随机生成。'
- en: Tip
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: Notice the randomly generated name in the last column of the output. Podman
    continues the Docker *tradition* to generate random names using adjectives in
    the left part of the name and notable scientists and hackers in the right part.
    Indeed, Podman still uses the same `github.com/docker/docker/namesgenerator` Docker
    package, included in the vendor directory of the project.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意输出最后一列中的随机生成名称。Podman延续了Docker的*传统*，使用名称左侧的形容词和右侧的著名科学家或黑客来生成随机名称。实际上，Podman仍然使用相同的`github.com/docker/docker/namesgenerator`
    Docker包，该包包含在项目的vendor目录中。
- en: To get a full list of both running and stopped containers, we can add an `–a`
    option to the command. To demonstrate this, we first introduce the `podman stop`
    command. This changes the container status to stopped and sends a `SIGTERM` signal
    to the processes running inside the container. If the container becomes unresponsive,
    it sends a `SIGKILL` signal after a given timeout of 10 seconds.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取正在运行和已停止容器的完整列表，我们可以在命令中添加`–a`选项。为了演示这一点，我们首先介绍`podman stop`命令。该命令将容器状态更改为停止状态，并向容器内运行的进程发送`SIGTERM`信号。如果容器没有响应，则会在10秒的超时后发送`SIGKILL`信号。
- en: 'Let''s try to stop the previous container and check its state by executing
    the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试停止之前的容器，并通过执行以下代码检查其状态：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This time, `podman ps` produced an empty output. This is because the container
    state is stopped. To get a full list of both running and stopped containers, run
    the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`podman ps`输出为空。这是因为容器的状态是停止的。要获取正在运行和已停止容器的完整列表，请运行以下命令：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice the status of the container, which states that the container has exited
    with a `0` exit code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意容器的状态，它显示容器已退出，并且退出代码为`0`。
- en: 'The stopped container can be resumed by running the `podman start` command,
    as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 停止的容器可以通过运行`podman start`命令恢复，如下所示：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This command simply starts again the container we stopped before.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令只是重新启动我们之前停止的容器。
- en: 'If we now check the container status again, we will see it is up and running,
    as indicated here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在再次检查容器状态，我们会看到它已经启动并正在运行，如下所示：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Podman keeps the container configuration, storage, and metadata as long as it
    is in a stopped state. Anyway, when we resume the container, we start a new process
    inside it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Podman在容器处于停止状态时会保留容器配置、存储和元数据。无论如何，当我们恢复容器时，容器内部会启动一个新进程。
- en: For more options, see the related `man podman-start`).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 更多选项，请参见相关的`man podman-start`。
- en: 'If we simply need to restart a running container, we can use the `podman restart`
    command, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只需要重启一个正在运行的容器，可以使用`podman restart`命令，如下所示：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This command has the effect of immediately restarting the processes inside the
    container with a new **process ID** (**PID**).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的作用是立即重启容器内的进程，并赋予其新的**进程 ID**（**PID**）。
- en: 'The `podman start` command can also be used to start containers that have been
    previously created but not run. To create a container without starting it, use
    the `podman create` command. The following example creates a container but does
    not start it:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman start`命令还可以用于启动之前创建但未运行的容器。要创建一个容器而不启动它，可以使用`podman create`命令。以下示例创建一个容器，但不启动它：'
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To start it, run `podman start` on the created container ID or name, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动它，请运行`podman start`命令，后跟已创建容器的 ID 或名称，如下所示：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This command is very useful for preparing an environment without running it
    or for mounting a container filesystem, as in the following example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令在准备一个不运行的环境或挂载容器文件系统时非常有用，如下面的例子所示：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s now introduce a very frequently used command: `podman rm`. As the name
    indicates, it is used to remove containers from the host. By default, it removes
    stopped containers, but it can be forced to remove running containers with the
    `–f` option.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们介绍一个非常常用的命令：`podman rm`。顾名思义，它用于从主机中删除容器。默认情况下，它会删除已停止的容器，但可以通过`–f`选项强制删除正在运行的容器。
- en: 'Using the container from the previous example, if we stop it again and issue
    the `podman rm` command, as illustrated in the following code snippet, all the
    container storage, configs, and metadata will be discarded:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前示例中的容器，如果我们再次停止它并发出`podman rm`命令，如下面的代码片段所示，所有容器的存储、配置和元数据都会被丢弃：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If we now run a `podman ps` command again, even with the `–a` option, we will
    get an empty list, as illustrated here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在再次运行`podman ps`命令，即使使用了`–a`选项，我们将获得一个空列表，如下所示：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: For more details, please inspect the command man page (`man podman-rm`).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多详细信息，请查看命令手册页（`man podman-rm`）。
- en: 'Sometimes, it is useful—just as with images—to print only the container ID
    with the `–q` option. This one, combined with the `–a` option, can print a list
    of all stopped and running containers in the host. Let''s try another example
    here:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这就像处理镜像一样，使用`–q`选项仅打印容器 ID 是很有用的。这个选项与`–a`选项结合使用时，可以打印主机上所有已停止和正在运行的容器列表。让我们在这里尝试另一个例子：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It''s interesting to notice that we have used a shell loop to start five identical
    containers, this time without any port mapping—just plain nginx containers. We
    can inspect their IDs with the following command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们已经使用了一个 shell 循环来启动五个相同的容器，这次没有任何端口映射—仅是纯粹的 nginx 容器。我们可以通过以下命令检查它们的
    ID：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'How can we stop and remove all our running containers quickly? We can use shell
    expansion to combine it with other commands and reach the desired result. Shell
    expansion is a powerful tool that runs the command inside round parentheses and
    lets us pass the output string as arguments to the external command, as illustrated
    in the following code snippet:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如何快速停止并删除所有正在运行的容器？我们可以利用 shell 扩展将其与其他命令结合，达到预期结果。Shell 扩展是一个强大的工具，它在圆括号内运行命令，并将输出字符串作为参数传递给外部命令，如下面的代码片段所示：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The two commands stopped all the running containers, identified by their IDs,
    and removed them from the host.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令停止了所有正在运行的容器，通过它们的 ID 进行标识，并将它们从主机上删除。
- en: The `podman ps` command enables users to refine their output by applying specific
    filters. A full list of all applicable filters is available on the `podman-ps`
    man page. A simple but useful application is the status filter, which enables
    users to print only containers in a specific condition. Possible statuses are
    `created`, `exited`, `paused`, `running`, and `unknown`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman ps`命令允许用户通过应用特定的过滤器来精细化输出。所有适用的过滤器的完整列表可以在`podman-ps`手册页中找到。一个简单而有用的应用是状态过滤器，它使用户能够仅打印处于特定状态的容器。可能的状态有`created`、`exited`、`paused`、`running`和`unknown`。'
- en: 'The following example only prints containers in an `exited` status:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例仅打印处于`exited`状态的容器：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Again, we can leverage the power of shell expansion to remove nothing but the
    exited containers, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以利用 shell 扩展的强大功能，仅删除已退出的容器，如下所示：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'A similar result can be achieved with the simpler-to-remember `podman container
    prune` command shown here, which removes (prunes) all stopped containers from
    the host:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这里展示的更易记住的`podman container prune`命令，也可以获得类似的结果，该命令会移除（清理）主机上所有停止的容器：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Sorting is another useful option for producing ordered output when listing
    containers. The following example shows how to sort by container ID:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 排序是列出容器时生成有序输出的另一个有用选项。以下示例展示了如何按容器ID进行排序：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `podman ps` command support formatting using a Go template to produce custom
    output. The next example prints only the container IDs and the commands executed
    inside them:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman ps`命令支持使用Go模板进行格式化，以生成自定义输出。下一个示例仅打印容器ID和容器内执行的命令：'
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Also, notice the `--no-trunc` option is added to avoid truncating the command
    output. This is not mandatory but is useful when we have long commands executed
    inside the containers.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，`--no-trunc`选项已添加，以避免截断命令输出。虽然这不是强制性的，但在容器内部执行长命令时，它是非常有用的。
- en: 'If we simply wish to extract the host PID of the process running inside the
    running containers, we can run the following example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仅希望提取正在运行的容器内部进程的主机PID，可以运行以下示例：
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Instead, if we need to also find out information about the isolated namespaces,
    `podman ps` can print details about the cloned namespaces of the running containers.
    This is a useful starting point for advanced troubleshooting and inspection. You
    can see the command being run here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要查找关于隔离命名空间的信息，`podman ps`可以打印正在运行容器的克隆命名空间的详细信息。这是进行高级故障排除和检查的一个有用起点。你可以看到这里执行的命令：
- en: '[PRE45]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This subsection covered many common operations to control and view the status
    of containers. In the next section, we will learn how to pause and resume running
    containers.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节介绍了许多常见操作，用于控制和查看容器的状态。在下一节中，我们将学习如何暂停和恢复正在运行的容器。
- en: Pausing and unpausing containers
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暂停和恢复容器
- en: This short section covers the `podman pause` and `podman unpause` commands.
    Despite being a section related to container status handling, it is interesting
    to understand how Podman and the container runtime leverage **control groups**
    (**cgroups**) to achieve specific purposes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节介绍了`podman pause`和`podman unpause`命令。尽管这是一个与容器状态处理相关的部分，但了解Podman和容器运行时如何利用**控制组**（**cgroups**）来实现特定目的，仍然很有趣。
- en: Simply put, the `pause` and `unpause` commands have the purpose of pausing and
    resuming the processes of a running container. Now, the reader could legitimately
    need clearance about the difference between `pause` and `stop` commands in Podman.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，`pause`和`unpause`命令的目的是暂停和恢复正在运行容器中的进程。现在，读者可能需要澄清`pause`和`stop`命令之间的区别。
- en: While the `podman stop` command simply sends a `SIGTERM`/`SIGKILL` signal to
    the parent process in the container, the `podman pause` command uses cgroups to
    pause the process without terminating it. When the container is unpaused, the
    same process is resumed transparently.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当`podman stop`命令仅向容器中的父进程发送`SIGTERM`/`SIGKILL`信号时，`podman pause`命令则使用cgroups暂停进程而不终止它。当容器被恢复时，相同的进程将透明地继续运行。
- en: Tip
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'The `pause`/`unpause` low-level logic is implemented in the container runtime—for
    the most curious, this was the implementation in `crun` at the time of writing:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`pause`/`unpause`的低级逻辑是在容器运行时实现的——对于最为好奇的人，这是写作时在`crun`中的实现：'
- en: https://github.com/containers/crun/blob/7ef74c9330033cb884507c28fd8c267861486633/src/libcrun/cgroup.c#L1894-L1936
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: https://github.com/containers/crun/blob/7ef74c9330033cb884507c28fd8c267861486633/src/libcrun/cgroup.c#L1894-L1936
- en: 'The following example demonstrates the podman `pause` and `unpause` commands.
    First, let''s start a Fedora container that prints a date and time string every
    2 seconds in an endless loop, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了`podman pause`和`podman unpause`命令。首先，让我们启动一个Fedora容器，该容器每2秒在一个无限循环中打印日期和时间字符串，如下所示：
- en: '[PRE46]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We intentionally leave the container running in a window and open a new window/tab
    to manage its status. Before issuing the `pause` command, let''s inspect the PID
    by executing the following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意让容器在一个窗口中保持运行，并打开一个新的窗口/标签页来管理其状态。在发出`pause`命令之前，让我们通过执行以下代码检查PID：
- en: '[PRE47]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, let''s pause the running container with the following command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令暂停正在运行的容器：
- en: '[PRE48]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If we go back to the `timer` container, we see that the output just paused
    but the container has not exited. The `unpause` action seen here will bring it
    back to life:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到`timer`容器，我们会看到输出刚刚被暂停，但容器并没有退出。此处看到的`unpause`操作将使其恢复：
- en: '[PRE49]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After the `unpause` action, the timer container will start printing date outputs
    again. Looking at the PID here, nothing has changed, as expected:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can check the cgroups status of the paused/unpaused container. In a third
    tab, open a terminal with a root shell and access the `cgroupfs` controller hierarchy
    after replacing the correct container ID, as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, look at the `cgroup.freeze` file content. This file holds a Boolean value
    and its state changes as we pause/unpause the container from 0 to 1 and vice versa.
    Try to pause and unpause the container again to test the changes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Cleanup Tip
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the echo loop was issued with a `bash –c` command, we need to send a
    `SIGKILL` signal to the process. To do this, we can stop the container and wait
    for the 10-second timeout, or simply run a `podman kill` command, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '`$ podman kill timer`'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: In this subsection, we covered in detail the most common commands for watching
    and modifying a container's status. We can now move on to inspect the processes
    running inside the running containers.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting processes inside containers
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a container is running, processes inside it are isolated at the namespace
    level, but users still own total control of the processes running and can inspect
    their behavior. There are many levels of complexity in process inspection, but
    Podman offers tools that can speed up this task.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `podman top` command: this provides a full view of the
    processes running inside a container. The following example shows the processes
    running inside an nginx container:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The result is very similar to the `ps` command output rather than the interactive
    one produced by the Linux `top` command.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to apply custom formatting to the output. The following example
    only prints PIDs, commands, and arguments:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We may need to inspect container processes in greater detail. As we discussed
    earlier in [*Chapter 1*](B17908_01_epub.xhtml#_idTextAnchor015), *Introduction
    to Container Technology*, once a brand-new container is started, it will start
    assigning PIDs from number 0, while under the hood, the container engine will
    map this container''s PIDs with the real ones on the host. So, we can use the
    output of the `podman ps --namespace` command to extract the process''s original
    PID in the host for a given container. With that information, we can conduct advanced
    analysis. The following example shows how to attach the `strace` command, used
    to inspect processes'' **system calls** (**syscalls**), to the process running
    inside the container:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Details about the usage of the `strace` command are beyond the scope of this
    book. See `man strace` for more advanced examples and a more in-depth explanation
    of the command options.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful command that can be easily applied to processes running inside
    a container is `pidstat`. Once we have obtained the PID, we can inspect the resource
    usage in this way:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The integers applied at the end represent, respectively, the execution interval
    of the command and the number of times it must print the usage stats. See `man
    pidstat` for more usage options.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'When a process in a container becomes unresponsive, it is possible to handle
    its abrupt termination with the `podman kill` command. By default, it sends a
    `SIGKILL` signal to the process inside the container. The following example creates
    an `httpd` container and then kills it:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We can optionally send custom signals (such as `SIGTERM` or `SIGHUP`) with the
    `--signal` option. Notice that a killed container is not removed from the host
    but continues to exist, is stopped, and is in an exited status.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 10*](B17908_10_epub.xhtml#_idTextAnchor193), *Troubleshooting and
    Monitoring Containers*, we will again deal with container troubleshooting and
    learn how to use advanced tools such as `nsenter` to inspect container processes.
    We now move on to basic container statistics commands that can be useful for monitoring
    the overall resource usage by all containers running in a system.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring container stats
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When multiple containers are running in the same host, it is crucial to monitor
    the amount of `podman stats` command, shown here:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Without any options, the command will open a top-like, self-refreshing window
    with the stats of all the running containers. The default printed values are listed
    here:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '`ID`: The running container ID'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NAME`: The running container name'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPU %`: The total CPU usage as a percentage'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MEM USAGE / LIMIT`: Memory usage against a given limit (dictated by system
    capabilities or by cgroups-driven limits)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MEM %`: The total memory usage as a percentage'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NET IO`: Network **input/output** (**I/O**) operations'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BLOCK IO`: Disk I/O operations'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PIDS`: The number of PIDs inside the container'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPU TIME`: Total consumed CPU time'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AVG CPU %`: Average CPU usage as a percentage'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In case a redirect is needed, it is possible to avoid streaming a self-refreshing
    output with the `--no-stream` option, as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Anyway, having a static output of this type is not very useful for parsing
    or ingestion. A better approach is to apply a JSON or Go template formatter. The
    following example prints out stats in a JSON format:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In a similar way, it is possible to customize the output fields using a Go
    template. The following example only prints out the container ID, CPU percentage
    usage, total memory usage in bytes, and PIDs:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this section, we have learned how to monitor running containers and their
    isolated processes. The next section shows how to inspect container configurations
    for analysis and troubleshooting.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting container information
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A running container exposes a set of configuration data and metadata ready
    to be consumed. Podman implements the `podman inspect` command to print all the
    container configurations and runtime information. In its simplest form, we can
    simply pass the container ID or name, like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This command prints a JSON output with all the container configurations. For
    the sake of space, we will list some of the most notable fields here:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '`Path`: The container entry point path. We will dig deeper into entry points
    later when we analyze Dockerfiles.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Args`: The arguments passed to the entry point.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`State`: The container''s current state, including crucial information such
    as the executed PID, the common PID, the OCI version, and the health check status.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Image`: The ID of the image used to run the container.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Name`: The container name.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MountLabel`: Container mount label for **Security-Enhanced Linux** (**SELinux**).'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProcessLabel`: Container process label for SELinux.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EffectiveCaps`: Effective capabilities applied to the container.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GraphDriver`: The type of storage driver (default is `overlayfs`) and a list
    of overlay upper, lower, and merged directories.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mounts`: The actual bind mounts in the container.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NetworkSettings`: The overall container network settings, including its internal
    **Internet Protocol** (**IP**) address, exposed ports, and port mappings.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Config`: Container runtime configuration, including environment variables,
    hostname, command, working directory, labels, and annotations.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HostConfig`: Host configuration, including cgroups'' quotas, network mode,
    and capabilities.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a huge amount of information that most of the time is too much for
    our needs. When we need to extract specific fields, we can use the `--format`
    option to print only selected ones. The following example prints only the host-bound
    PID of the process executed inside the container:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The result is in a Go template format. This allows for flexibility to customize
    the output string as we desire.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: The `podman inspect` command is also useful for understanding the behavior of
    the container engine and for gaining useful information during troubleshooting
    tasks.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: For example, when a container is launched, we learn that the `resolv.conf` file
    is mounted inside the container from a path that is defined in the `{{ .ResolvConfPath
    }}` key. The target path is `/run/user/<UID>/containers/overlay-containers/<Container_ID>/userdata/resolv.conf`
    when the container is executed in rootless mode, and `/var/run/containers/storage/overlay-containers/<Container_ID>/userdata/resolv.conf`
    when in rootful mode.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Other interesting information is the list of all the merged layers managed
    by `overlayfs`. Let''s try to run a new container, this time in rootful mode,
    and find out information about the merged layers, as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This container runs a simple loop that writes a string on a text file every
    5 seconds. Now, let''s run a `podman inspect` command to find out information
    about `MergedDir`, which is the directory where all layers are merged by `overlayfs`.
    The code is illustrated in the following snippet:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Inside this directory, we can find the `/tmp/test.log` file, as indicated here:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can dig deeper—the `LowerDir` directory holds a list of the base image layers,
    as shown in the following code snippet:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In this example, the base image is made up of only one layer. Are we going
    to find the log file here? Let''s have a look:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We are missing the log file in this layer. This is because the `LowerDir` directory
    is not written and represents the read-only image layers. It is merged with an
    `UpperDir` directory that is the read-write layer of the container. With `podman
    inspect`, we can find out where it resides, as illustrated here:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The output directory will contain only a bunch of files and directories, written
    since the container startup, including the `/tmp/test.log` file, as illustrated
    in the following code snippet:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can now stop and remove the logger container by running the following command:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This example was in anticipation of the container storage topic that will be
    covered in [*Chapter 5*](B17908_05_epub.xhtml#_idTextAnchor101), *Implementing
    Storage for the Container's Data*. The `overlayfs` mechanisms, with the lower,
    upper, and merged directory concepts, will be analyzed in more detail.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to inspect running containers and collect runtime
    information and configurations. The next section is going to cover best practices
    for capturing logs from containers.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Capturing logs from containers
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described earlier in this chapter, containers are made of one or more processes
    that can fail, printing errors and describing their current state in a log file.
    But where are these logs stored?
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Well, of course, a process in a container could write its log messages inside
    a file somewhere in a temporary filesystem that the container engine has made
    available to it (if any). But what about a read-only filesystem or any permission
    constraints in the running container?
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'A container''s best practice for exposing relevant logs outside the container''s
    shield actually leverages the use of standard streams: `STDOUT`) and `STDERR`).'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Good to Know
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Standard streams are communication channels interconnected to a running process
    in an OS. When a program is run through an interactive shell, these streams are
    then directly connected to the user's running terminal to let input, output, and
    error flow between the terminal and the process, and vice versa.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the options we use for running a brand-new container, Podman will
    act appropriately by attaching the `STDIN`, `STDOUT`, and `STDERR` standard streams
    to a local file for storing the logs.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B17908_03_epub.xhtml#_idTextAnchor068), *Running the First
    Container*, we saw how to run a container in the background, detaching from a
    running container. We used the `-d` option to start a container in *detached*
    mode through the `podman run` command, as illustrated here:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: With the previous command, we are instructing Podman to start a container in
    detached mode (`-d`), with a pseudo-terminal attached to the `STDIN` stream (`-t`)
    keeping the standard input stream open even if there is no terminal attached yet
    (`-i`).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: The standard Podman behavior is to attach to `STDOUT` and `STDERR` streams and
    store any container's published data in a log file on the host filesystem.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are working with Podman as a *root* user, we can take a look at the log
    file available on the host system, executing the following steps:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to start our container and take note of the ID returned by Podman,
    or ask Podman for a list of containers and take note of their ID. The code to
    accomplish this is shown in the following snippet:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'After that, we can take a look under the `/var/lib/containers/storage/overlay-containers/`
    directory and search for a folder with a name that matches our container''s ID,
    as follows:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Finally, we can check the logs of our running container by taking a look at
    the file named `ctr.log` in the `userdata` directory, as follows:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We just discovered the secret place where Podman saves all logs of our containers!
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the procedure we just introduced will work properly if the
    `log_driver` field for the `containers.conf` file is set to the `k8s-file` value.
    For example, in the Fedora Linux distribution starting from version 35, the maintainers
    decided to switch from `k8s-file` to `journald`. In this case, you could look
    for the logs directly using the `journalctl` command-line utility.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to take a look at the default `log_driver` field, you can look
    in the following path:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Does this mean that we need to perform this entire complex procedure every time
    we need to analyze the logs of our containers? Of course not!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'Podman has a `podman logs` built-in command that can easily discover, grab,
    and print the latest container logs for us. Considering the previous example,
    we can easily check the logs of our running container by executing the following
    command:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We can also get the short ID for our running container and pass this ID to
    the `podman logs` command, as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In the previous command, we also used a nice option of the `podman logs` command:
    the `--tail` option, which lets us output only the latest needed rows of the container''s
    log. In our case, we requested the latest two.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: As we saw earlier in this section, Podman saves the container logs into the
    host filesystem. These files, by default, are not limited in size, so it could
    happen that for long-living containers that might produce a lot of logs, these
    files could become very large.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, as we usually talk about logs and log files, one important
    configuration parameter that could help reduce the log files'' size is available
    through the Podman global configuration file available at this location: `/etc/containers/containers.conf`.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'If this configuration file is missing, you can easily create a new one, inserting
    the following rows to apply the configuration:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Through the previous configuration, we are limiting every log file for our future
    running containers to 10 **megabytes** (**MB**). If you have some running containers,
    you have to restart them to apply this new configuration.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to move to the next section, where we will discover another
    useful command.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Executing processes in a running container
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Podman daemonless architecture* section of [*Chapter 2*](B17908_02_epub.xhtml#_idTextAnchor044),
    *Comparing Podman and Docker*, we talked about the fact that Podman, as with any
    other container engine, leverages the Linux namespace functionality to correctly
    isolate running containers from each other and from the OS host as well.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: So, just because Podman creates a brand-new namespace for every running container,
    it should not be a surprise that we can attach to the same Linux namespace of
    a running container, executing other processes just as in a full operating environment.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Podman gives us the ability to execute a process in a running container through
    the `podman exec` command.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Once executed, this command will find internally the right Linux namespace to
    which the target running container is attached. Having found the Linux namespace,
    Podman will execute the respective process, passed as an argument to the `podman
    exec` command, attaching it to the target Linux namespace. The final process will
    be in the same environment as the original process companion and it will be able
    to interact with it.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how this works in practice, we can consider the following example
    whereby we will first run a container and then execute a process beside the existing
    processes:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: As you can see from the previous commands, we grabbed the container ID provided
    by Podman once the container was started and we passed it to the `podman exec`
    command as an argument.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: The `podman exec` command could be really useful for troubleshooting, testing,
    and working with an existing container. In the preceding example, we attached
    an interactive terminal running the Bash console, and we launched the `ps` command
    for inspecting the running processes available in the current Linux namespace
    assigned to the container.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: The `podman exec` command has many options available, similar to the ones provided
    by the `podman run` command. As you saw from the previous example, we used the
    option for getting a pseudo-terminal attached to the `STDIN` stream (`-t`), keeping
    the standard input stream open even if there is no terminal attached yet (`-i`).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'For more details on the available options, we can check the manual with the
    respective command, as illustrated here:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: We are moving forward in our journey to the container management world, and
    in the next section, we will also take a look at some of the capabilities that
    Podman offers to enable containerized workloads in the Kubernetes container orchestration
    world.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Running containers in pods
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in the *Docker versus Podman main differences* section of [*Chapter
    2*](B17908_02_epub.xhtml#_idTextAnchor044), *Comparing Podman and Docker* , Podman
    offers capabilities to easily start adopting some basic concepts of the de facto
    container orchestrator named Kubernetes (also sometimes referred to as `k8s`).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: The pod concept was introduced with Kubernetes and represents the smallest execution
    unit in a Kubernetes cluster. With Podman, users can create empty pods and then
    run containers inside them easily.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'Grouping two or more containers inside a single pod can have many benefits,
    such as the following:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Sharing the same network namespace, IP address included
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing the same storage volumes for storing persistent data
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing the same configurations
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, placing two or more containers in the same pod will actually enable
    them to share the same **inter-process communication** (**IPC**) Linux namespace.
    This could be really useful for applications that need to communicate with each
    other using shared memory.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to create a pod and start working with it is to use this command:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'As shown in the previous example, we create a new pod named `myhttp` and then
    check the status of the pod on our host system: there is just one pod in a `created`
    state.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now start the pod as follows and check what will happen:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The pod is now running, but what is Podman actually running? We created an
    empty pod without containers inside! Let''s take a look at the running container
    by executing the `podman ps` command, as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `podman ps` command is showing a running container with an image named `pause`.
    This container is run by Podman by default as an `infra` container. This kind
    of container does nothing—it just holds the namespace and lets the container engine
    connect to any other running container inside the pod.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Having demystified the role of this special container inside our pods, we can
    now take a brief look at the steps required to start a multi-container pod.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s start by running a new container inside the existing pod
    we created in the previous example, as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Then, we can check whether the existing pod has updated the number of containers
    it contains, as illustrated in the following code snippet:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Finally, we can ask Podman for a list of running containers with the associated
    pod name, as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: As you can see, the two containers running are both associated with the pod
    named `myhttp`!
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'Please consider periodically cleaning up the lab environment after completing
    all the examples contained in this chapter. This could help you save resources
    and avoid any errors when moving to the next chapter''s examples. For this reason,
    you can refer to the code provided in the `AdditionalMaterial` folder in the book''s
    GitHub repository: https://github.com/PacktPublishing/Podman-for-DevOps/tree/main/AdditionalMaterial.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: With the same approach, we can add more and more containers to the same pod,
    letting them share all the data we described before.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Please note that placing containers in the same pod can be beneficial in some
    cases, but this represents an anti-pattern for the container technology. In fact,
    as mentioned before, Kubernetes considers the **pod** the smallest computing unit
    to run on top of the distributed nodes' part of one cluster. This means that once
    you group two or more containers under the same pod, they will be executed together
    on the same node and the orchestrator cannot balance or distribute their workload
    on multiple machines.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: We will explore more about Podman's features that can enable you to enter the
    container orchestration world through Kubernetes in the next chapters!
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started developing experience in managing containers, starting
    with container images, and then working with running containers. Once our containers
    were running, we also explored the various commands available in Podman to inspect
    and check the logs and troubleshoot our containers. The operations needed to monitor
    and look after running containers are really important for any container administrator.
    Finally, we also took a brief look at the Kubernetes concepts available in Podman
    that let us group two or more containers under the same Linux namespace. All the
    concepts and the examples we just went through will help us start our experience
    as a system administrator for container technologies.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to explore another important topic in the next chapter: managing
    storage for our containers!'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
