<html><head></head><body>
		<div id="_idContainer028">
			<h1 id="_idParaDest-134"><em class="italic"><a id="_idTextAnchor134"/>Chapter 7</em>: Integrating with Existing Application Build Processes</h1>
			<p>After learning how to create custom container images using Podman and Buildah, we can now focus on special use cases that can make our build workflows more efficient and portable. For instance, small images are a very common requirement in an enterprise environment, for performance and security reasons. We will explore how to achieve this goal by breaking down the build process into different stages. </p>
			<p>This chapter will also try to uncover scenarios where Buildah is not expected to run directly on a developer machine but is driven instead by a container orchestrator or embedded inside custom applications that are expected to call its libraries or <strong class="bold">command line interface</strong> (<strong class="bold">CLI</strong>).</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Multistage container builds</li>
				<li>Running Buildah inside a container</li>
				<li>Integrating Buildah with custom builders</li>
			</ul>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor135"/>Technical requirements</h1>
			<p>Before proceeding with this chapter, a machine with a working Podman installation is required. As stated in <a href="B17908_03_epub.xhtml#_idTextAnchor068"><em class="italic">Chapter 3</em></a>, <em class="italic">Running the First Container</em>, all the examples in the book are executed on a Fedora 34 system or later versions but can be reproduced on the reader's OS of choice. </p>
			<p>A good understanding of the topics covered in <a href="B17908_06_epub.xhtml#_idTextAnchor116"><em class="italic">Chapter 6</em></a>, <em class="italic">Meet Buildah – Building Containers from Scratch</em>, will be useful to easily grasp concepts regarding builds, both with native Buildah commands and from Dockerfiles.</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor136"/>Multistage container builds</h1>
			<p>We have learned so far how to create builds with Podman and Buildah using Dockerfiles or native Buildah <a id="_idIndexMarker647"/>commands that unleash potential advanced building techniques.</p>
			<p>There is still an important point that we haven't already discussed – the size of the images.</p>
			<p>When creating a new image, we should always take care of its final size, which is the result of the total number of layers and the number of changed files inside them. </p>
			<p>Minimal images with a small size have the great advantage of being able to be pulled faster from registries. Nevertheless, a large image will eat a lot of precious disk space in the host's local store. </p>
			<p>We already showed examples of some best practices to keep images compact in size, such as building from scratch, cleaning up package manager caches, and reducing the amount of <strong class="source-inline">RUN</strong>, <strong class="source-inline">COPY</strong>, and <strong class="source-inline">ADD</strong> instructions to the minimum necessary. However, what happens when we need to build an application from its source and create a final image with the final artifacts?</p>
			<p>Let's say we need to build a containerized Go application – we should start from a base image that includes Go runtimes, copy the source code, and compile to produce the final binary with a series of intermediate steps, most notably downloading all the necessary Go packages inside the image cache. At the end of the build, we should clean up all the source code and the downloaded dependencies and put the final binary (which is statically linked in Go) in a working directory. Everything will work, but the final image will still include the Go runtimes included in the base image, which are no longer necessary at the end of the compilation process.</p>
			<p>When Docker was introduced and Dockerfiles gained momentum, this problem was circumnavigated in different ways by DevOps teams who struggled to keep images minimal. For example, <strong class="bold">binary builds</strong> were a way to inject the final artifact compiled externally inside the <a id="_idIndexMarker648"/>built image. This approach solves the image size problem but removes the advantage of a standardized environment for builds provided by runtime/compiler images.</p>
			<p>A better approach is to share volumes between containers and have the final container image grab the compiled artifacts from a first build image.</p>
			<p>To provide a standardized approach, Docker, and then the OCI specifications, introduced the concept of <strong class="bold">multistage builds</strong>. Multistage builds, as the name says, allow users to create builds with <a id="_idIndexMarker649"/>multiple stages using different <strong class="source-inline">FROM</strong> instructions and have subsequent images grab contents from the previous ones.</p>
			<p>In the next subsections, we will explore how to achieve this result with Dockerfiles/Containerfiles and with Buildah's native commands.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor137"/>Multistage builds with Dockerfiles</h2>
			<p>The first approach <a id="_idIndexMarker650"/>to multistage builds is by <a id="_idIndexMarker651"/>creating multiple stages in a single Dockerfile/Containerfile, with each block beginning with a <strong class="source-inline">FROM</strong> instruction.</p>
			<p>Build stages can copy files and folders from previous ones using the <strong class="source-inline">--from</strong> option to specify the source stage.</p>
			<p>The next examples show how to create a minimal multistage build for the Go application, with the first stage acting as a pure build context and the second stage copying the final artifact inside a minimal image:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Chapter07/http_hello_world/Dockerfile</p>
			<p class="source-code"># Builder image</p>
			<p class="source-code">FROM docker.io/library/golang</p>
			<p class="source-code"># Copy files for build</p>
			<p class="source-code">COPY go.mod /go/src/hello-world/</p>
			<p class="source-code">COPY main.go /go/src/hello-world/</p>
			<p class="source-code"># Set the working directory</p>
			<p class="source-code">WORKDIR /go/src/hello-world</p>
			<p class="source-code"># Download dependencies</p>
			<p class="source-code">RUN go get -d -v ./...</p>
			<p class="source-code"># Install the package</p>
			<p class="source-code">RUN go build -v </p>
			<p class="source-code"># Runtime image</p>
			<p class="source-code">FROM registry.access.redhat.com/ubi8/ubi-micro:latest</p>
			<p class="source-code">COPY --from=0 /go/src/hello-world/hello-world /</p>
			<p class="source-code">EXPOSE 8080</p>
			<p class="source-code">CMD ["/hello-world"]</p>
			<p>The first stage copies the source <strong class="source-inline">main.go</strong> file and the <strong class="source-inline">go.mod</strong> file to manage the Go module <a id="_idIndexMarker652"/>dependencies. After downloading the <a id="_idIndexMarker653"/>dependency packages (<strong class="source-inline">go get -d -v ./...</strong>), the final application is built (<strong class="source-inline">go build –v ./...</strong>). </p>
			<p>The second stage grabs the final artifact (<strong class="source-inline">/go/src/hello-world/hello-world</strong>) and copies it under the new image root. To specify that the source file should be copied from the first stage, the <strong class="source-inline">--from=0</strong> syntax is used.</p>
			<p>In the first stage, we used the official <strong class="source-inline">docker.io</strong>/<strong class="source-inline">library</strong>/<strong class="source-inline">golang</strong> image, which includes the latest <a id="_idIndexMarker654"/>version of the Go programming language. In the second stage, we used the <strong class="bold">ubi-micro</strong> image, a minimal image from Red Hat with a reduced footprint, optimized for microservices and statically linked binaries. Universal Base Images will be covered in greater detail in <a href="B17908_08_epub.xhtml#_idTextAnchor149"><em class="italic">Chapter 8</em></a>, <em class="italic">Choosing the Container Base Image</em>. </p>
			<p>The Go application listed as follows is a basic web server that listens on port <strong class="source-inline">8080/tcp</strong> and prints a crafted HTML page with the <em class="italic">"Hello World!"</em> message when it receives a <strong class="source-inline">GET /</strong> request:</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">For the purpose of this book, it is not necessary to be able to write or understand the Go programming language. However, a basic understanding of the language syntax and logic will prove to be very useful, since the greatest part of container-related software (such as Podman, Docker, Buildah, Skopeo, Kubernetes, and OpenShift) is written in Go.</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Chapter07/http_hello_world/main.go</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">       "log"</p>
			<p class="source-code">   "net/http"</p>
			<p class="source-code">)</p>
			<p class="source-code">func handler(w http.ResponseWriter, r *http.Request) {</p>
			<p class="source-code">     log.Printf("%s %s %s\n", r.RemoteAddr, r.Method, r.URL)</p>
			<p class="source-code">     w.Header().Set("Content-Type", "text/html")</p>
			<p class="source-code">     w.Write([]byte("&lt;html&gt;\n&lt;body&gt;\n"))</p>
			<p class="source-code">     w.Write([]byte("&lt;p&gt;Hello World!&lt;/p&gt;\n"))</p>
			<p class="source-code">     w.Write([]byte("&lt;/body&gt;\n&lt;/html&gt;\n"))</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">     http.HandleFunc("/", handler)</p>
			<p class="source-code">     log.Println("Starting http server")</p>
			<p class="source-code">     log.Fatal(http.ListenAndServe(":8080", nil))</p>
			<p class="source-code">}</p>
			<p>The application <a id="_idIndexMarker655"/>can be built using either Podman <a id="_idIndexMarker656"/>or Buildah. In this example, we choose to build the application with Buildah:</p>
			<p class="source-code">$ cd http_hello_world</p>
			<p class="source-code">$ buildah build -t hello-world .</p>
			<p>Finally, we can check the resulting image size:</p>
			<p class="source-code">$ buildah images --format '{{.Name}} {{.Size}}' \     localhost/hello-world</p>
			<p class="source-code">localhost/hello-world   45 MB</p>
			<p>The final image has a size of only 45 MB! </p>
			<p>We can improve our Dockerfile by adding custom names to the base images using the keyword <strong class="source-inline">AS</strong>. The following example is a rework of the previous Dockerfile following this approach, with the key elements highlighted in bold:</p>
			<p class="source-code"># Builder image</p>
			<p class="source-code">FROM docker.io/library/golang <strong class="bold">AS builder</strong></p>
			<p class="source-code"># Copy files for build</p>
			<p class="source-code">COPY go.mod /go/src/hello-world/</p>
			<p class="source-code">COPY main.go /go/src/hello-world/</p>
			<p class="source-code"># Set the working directory</p>
			<p class="source-code">WORKDIR /go/src/hello-world</p>
			<p class="source-code"># Download dependencies</p>
			<p class="source-code">RUN go get -d -v ./...</p>
			<p class="source-code"># Install the package</p>
			<p class="source-code">RUN go build -v ./...</p>
			<p class="source-code"># Runtime image</p>
			<p class="source-code">FROM registry.access.redhat.com/ubi8/ubi-micro:latest <strong class="bold">AS srv</strong></p>
			<p class="source-code">COPY <strong class="bold">--from=builder</strong> /go/src/hello-world/hello-world /</p>
			<p class="source-code">EXPOSE 8080</p>
			<p class="source-code">CMD ["/hello-world"]</p>
			<p>In the preceding example, the name of the builder image is set as <strong class="source-inline">builder</strong>, while the final image is <a id="_idIndexMarker657"/>named <strong class="source-inline">srv</strong>. Interestingly, the <strong class="source-inline">COPY</strong> instruction <a id="_idIndexMarker658"/>can now specify the builder as using the custom name with the <strong class="source-inline">--from=builder</strong> option. </p>
			<p>Dockerfile/Containerfile builds are the most common approach but still lack some flexibility when it comes to implementing a custom build workflow. For those special use cases, Buildah native commands come to our rescue.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor138"/>Multistage builds with Buildah native commands</h2>
			<p>As mentioned before, the multistage build feature is a great approach to produce images with a <a id="_idIndexMarker659"/>small footprint and a reduced <a id="_idIndexMarker660"/>attack surface. To provide greater flexibility during the build process, the Buildah native commands come to our rescue. As we mentioned earlier in <a href="B17908_06_epub.xhtml#_idTextAnchor116"><em class="italic">Chapter 6</em></a>, <em class="italic">Meet Buildah – Building Containers from Scratch</em>, Buildah offers a series of commands that replicate the behavior of the Dockerfile instructions, thus offering greater control over the build process when those commands are included in scripts or automations.</p>
			<p>The same concept applies when working with multistage builds, where we can also apply extra steps between the stages. For instance, we can mount the build container overlay file system and extract the built artifact to release alternate packages, all before building the final runtime image. </p>
			<p>The following example builds the same <strong class="source-inline">hello-world</strong> Go application by translating the previous <a id="_idIndexMarker661"/>Dockerfile instructions into native Buildah <a id="_idIndexMarker662"/>commands, with everything inside a simple shell script:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code"># Define builder and runtime images</p>
			<p class="source-code">BUILDER=docker.io/library/golang</p>
			<p class="source-code">RUNTIME=registry.access.redhat.com/ubi8/ubi-micro:latest</p>
			<p class="source-code"># Create builder container</p>
			<p class="source-code"><strong class="bold">container1=$(buildah from $BUILDER)</strong></p>
			<p class="source-code"># Copy files from host</p>
			<p class="source-code">if [ -f go.mod ]; then </p>
			<p class="source-code">    buildah copy $container1 'go.mod' '/go/src/hello-world/'</p>
			<p class="source-code">else</p>
			<p class="source-code">    exit 1</p>
			<p class="source-code">fi</p>
			<p class="source-code">if [ -f main.go ]; then </p>
			<p class="source-code">    buildah copy $container1 'main.go' '/go/src/hello-world/'</p>
			<p class="source-code">else </p>
			<p class="source-code">    exit 1</p>
			<p class="source-code">fi</p>
			<p class="source-code"># Configure and start build</p>
			<p class="source-code">buildah config --workingdir /go/src/hello-world $container1</p>
			<p class="source-code">buildah run $container1 go get -d -v ./...</p>
			<p class="source-code">buildah run $container1 go build -v ./...</p>
			<p class="source-code"># Create runtime container</p>
			<p class="source-code"><strong class="bold">container2=$(buildah from $RUNTIME)</strong></p>
			<p class="source-code"># Copy files from the builder container</p>
			<p class="source-code">buildah copy --chown=1001:1001 \</p>
			<p class="source-code">    --from=$container1 $container2 \</p>
			<p class="source-code">    '/go/src/hello-world/hello-world' '/'</p>
			<p class="source-code"># Configure exposed ports</p>
			<p class="source-code">buildah config --port 8080 $container2</p>
			<p class="source-code"># Configure default CMD</p>
			<p class="source-code">buildah config --cmd /hello-world $container2</p>
			<p class="source-code"># Configure default user</p>
			<p class="source-code">buildah config --user=1001 $container2</p>
			<p class="source-code"># Commit final image</p>
			<p class="source-code">buildah commit $container2 hello-world</p>
			<p class="source-code"># Remove build containers</p>
			<p class="source-code">buildah rm $container1 $container2</p>
			<p>In the preceding example, we highlighted the two working containers' creation commands and the related <strong class="source-inline">container1</strong> and <strong class="source-inline">container2</strong> variables that store the container ID. </p>
			<p>Also, note the <strong class="source-inline">buildah copy</strong> command, where we have defined the source container with the <strong class="source-inline">--from</strong> option, and used the <strong class="source-inline">--chown</strong> option to define user and group owners <a id="_idIndexMarker663"/>of the copied resource. This approach <a id="_idIndexMarker664"/>proves to be more flexible than the Dockerfile-based workflow, since we can enrich our script with variables, conditionals, and loops. </p>
			<p>For instance, we have tested with the <strong class="source-inline">if</strong> condition in the Bash script to check the existence of the <strong class="source-inline">go.mod</strong> and <strong class="source-inline">main.go</strong> files before copying them inside the working container dedicated to the build.</p>
			<p>Let's now add an extra feature to the script. In the following example, we evolved the previous one by adding a semantic versioning for the build and creating a version archive before starting the build of the final runtime image:</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The concept of semantic versioning is aimed to provide a clear and standardized way to manage software versioning and dependency management. It is a set of standard rules whose purpose is to define how software release versions are applied and follows the<strong class="bold"> X.Y.Z</strong> versioning pattern, where <strong class="bold">X</strong> is the major version, <strong class="bold">Y</strong> is the minor version, and <strong class="bold">Z</strong> is the patch version. For more information, check out the official specifications: <a href="https://semver.org/">https://semver.org/</a>. </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code"># Define builder and runtime images</p>
			<p class="source-code">BUILDER=docker.io/library/golang</p>
			<p class="source-code">RUNTIME=registry.access.redhat.com/ubi8/ubi-micro:latest</p>
			<p class="source-code"><strong class="bold">RELEASE=1.0.0</strong></p>
			<p class="source-code"># Create builder container</p>
			<p class="source-code">container1=$(buildah from $BUILDER)</p>
			<p class="source-code"># Copy files from host</p>
			<p class="source-code">if [ -f go.mod ]; then </p>
			<p class="source-code">    buildah copy $container1 'go.mod' '/go/src/hello-world/'</p>
			<p class="source-code">else</p>
			<p class="source-code">    exit 1</p>
			<p class="source-code">fi</p>
			<p class="source-code">if [ -f main.go ]; then </p>
			<p class="source-code">    buildah copy $container1 'main.go' '/go/src/hello-world/'</p>
			<p class="source-code">else </p>
			<p class="source-code">    exit 1</p>
			<p class="source-code">fi</p>
			<p class="source-code"># Configure and start build</p>
			<p class="source-code">buildah config --workingdir /go/src/hello-world $container1</p>
			<p class="source-code">buildah run $container1 go get -d -v ./...</p>
			<p class="source-code">buildah run $container1 go build -v ./...</p>
			<p class="source-code"># Extract build artifact and create a version archive</p>
			<p class="source-code"><strong class="bold">buildah unshare --mount mnt=$container1 \</strong></p>
			<p class="source-code"><strong class="bold">    sh -c 'cp $mnt/go/src/hello-world/hello-world .'</strong></p>
			<p class="source-code">cat &gt; README &lt;&lt; EOF</p>
			<p class="source-code">Version $RELEASE release notes:</p>
			<p class="source-code">- Implement basic features</p>
			<p class="source-code">EOF</p>
			<p class="source-code"><strong class="bold">tar zcf hello-world-${RELEASE}.tar.gz hello-world README</strong></p>
			<p class="source-code">rm -f hello-world README</p>
			<p class="source-code"># Create runtime container</p>
			<p class="source-code">container2=$(buildah from $RUNTIME)</p>
			<p class="source-code"># Copy files from the builder container</p>
			<p class="source-code">buildah copy --chown=1001:1001 \</p>
			<p class="source-code">    --from=$container1 $container2 \</p>
			<p class="source-code">    '/go/src/hello-world/hello-world' '/'</p>
			<p class="source-code"># Configure exposed ports</p>
			<p class="source-code">buildah config --port 8080 $container2</p>
			<p class="source-code"># Configure default CMD</p>
			<p class="source-code">buildah config --cmd /hello-world $container2</p>
			<p class="source-code"># Configure default user</p>
			<p class="source-code">buildah  config--user=1001 $container2</p>
			<p class="source-code"># Commit final image</p>
			<p class="source-code"><strong class="bold">buildah commit $container2 hello-world:$RELEASE</strong></p>
			<p class="source-code"># Remove build containers</p>
			<p class="source-code">buildah rm $container1 $container2</p>
			<p>The key changes in the script are again highlighted in bold. First, we added a <strong class="source-inline">RELEASE</strong> variable that tracks the release version of the application. Then, we extracted the build artifact using the <strong class="source-inline">buildah unshare</strong> command, followed by the <strong class="source-inline">--mount</strong> option to pass the container mount point. The user namespace unshare was necessary to make the script capable of running rootless.</p>
			<p>After extracting <a id="_idIndexMarker665"/>the artifact, we created a gzipped archive <a id="_idIndexMarker666"/>using the <strong class="source-inline">$RELEASE</strong> variable inside the archive name and removed the temporary files.</p>
			<p>Finally, we started the build of the runtime image and committed using the <strong class="source-inline">$RELEASE</strong> variable again as the image tag.</p>
			<p>In this section, we have learned how to run multistage builds with Buildah using both Dockerfiles/Containerfiles and native commands. In the next section, we will learn how to isolate Buildah builds inside a container.</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor139"/>Running Buildah inside a container</h1>
			<p>Podman and Buildah <a id="_idIndexMarker667"/>follow a fork/exec approach that makes them very easy to run inside a container, including rootless containers scenarios. </p>
			<p>There are many use cases that imply the need for containerized builds. Nowadays, one of the most common adoption scenarios is the application build workflow running on top of a <strong class="bold">Kubernetes</strong> cluster. </p>
			<p>Kubernetes is basically a container orchestrator that manages the scheduling of containers <a id="_idIndexMarker668"/>from a control plane over a set of worker nodes that run a container engine compatible with the <strong class="bold">Container Runtime Interface</strong> (<strong class="bold">CRI</strong>). Its design allows great flexibility <a id="_idIndexMarker669"/>in customizing networking, storage, and runtimes, and leads to the great flourishing of side projects that are now <a id="_idIndexMarker670"/>incubating or matured inside the <strong class="bold">Cloud Native Computing Foundation</strong> (<strong class="bold">CNCF</strong>).</p>
			<p><strong class="bold">Vanilla</strong> Kubernetes (which is the basic community release without any customization or add-ons) doesn't have <a id="_idIndexMarker671"/>any native build feature but offers the proper framework to implement one. Over time, many solutions appeared trying to address this need. </p>
			<p>For example, Red Hat <strong class="bold">OpenShift</strong> introduced, way back when Kubernetes 1.0 was released, its <a id="_idIndexMarker672"/>own build APIs and the <em class="italic">Source-to-Image</em> toolkit to create container images from source code directly on top of the OpenShift cluster. </p>
			<p>Another interesting solution is Google's <strong class="bold">kaniko</strong>, which is a build tool to create container images inside a <a id="_idIndexMarker673"/>Kubernetes cluster that runs every build step inside user space.</p>
			<p>Besides using already implemented solutions, we can design our own running Buildah inside containers that are orchestrated by Kubernetes. We can also leverage the rootless-ready design to implement secure build workflows.</p>
			<p>It is possible to run CI/CD pipelines on top of a Kubernetes cluster and embed containerized builds within a pipeline. One of the most interesting CNCF projects, <strong class="bold">Tekton Pipelines</strong>, offers a cloud-native approach to accomplish this goal. Tekton allows running pipelines <a id="_idIndexMarker674"/>that are driven by Kubernetes' custom resources – special APIs that extend the basic API set. </p>
			<p>Tekton Pipelines are made up of many different tasks, and users can either create their own or grab them from <strong class="bold">Tekton Hub</strong> (<a href="https://hub.tekton.dev/">https://hub.tekton.dev/</a>), a free repository where many pre-baked <a id="_idIndexMarker675"/>tasks are available to be consumed immediately, including <a id="_idIndexMarker676"/>examples from Buildah (<a href="https://hub.tekton.dev/tekton/task/buildah">https://hub.tekton.dev/tekton/task/buildah</a>). </p>
			<p>The preceding examples are useful to understand why containerized builds are important. In this book, we want to focus on the details of running builds within containers, with special attention paid to security-related constraints.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor140"/>Running rootless Buildah containers with volume stores</h2>
			<p>For the examples <a id="_idIndexMarker677"/>in this subsection, the <a id="_idIndexMarker678"/>stable upstream <strong class="source-inline">quay.io/buildah/stable</strong> Buildah image will be used. This image already embeds the latest stable Buildah binary.</p>
			<p>Let's run our first example with a rootless container that builds the contents of the <strong class="source-inline">~/build</strong> directory in the host and stores the output in a local volume named <strong class="source-inline">storevol</strong>:</p>
			<p class="source-code">$ podman run --device /dev/fuse \</p>
			<p class="source-code">    -v ~/build:/build:z \</p>
			<p class="source-code">    -v storevol:/var/lib/containers quay.io/buildah/stable \</p>
			<p class="source-code">    buildah build -t build_test1 /build</p>
			<p>This example <a id="_idIndexMarker679"/>brings some peculiar <a id="_idIndexMarker680"/>options that deserve attention, as follows: </p>
			<ul>
				<li>The <strong class="source-inline">--device /dev/fuse</strong> option, which loads the fuse kernel module in the container, which is necessary to run fuse-overlay commands</li>
				<li>The <strong class="source-inline">-v ~/build:/build:z</strong> option, which bind-mounts the <strong class="source-inline">/root/build</strong> directory inside the container, assigning proper SELinux labeling with the <strong class="source-inline">:z</strong> suffix</li>
				<li>The <strong class="source-inline">-v storevol:/var/lib/containers</strong> option, which creates a fresh volume mounted on the default container store where all the layers are created</li>
			</ul>
			<p>When the build is complete, we can run a new container using the same volume and inspect or manipulate the built image:</p>
			<p class="source-code">$ podman run --rm -v storevol:/var/lib/containers quay.io/buildah/stable buildah images</p>
			<p class="source-code">REPOSITORY                  TAG      IMAGE ID       CREATED          SIZE</p>
			<p class="source-code">localhost/build_test1             latest   cd36bf58daff   12 minutes ago   283 </p>
			<p class="source-code">docker.io/library/fedora    latest   b080de8a4da3   4 days ago       159 MB</p>
			<p>We have successfully built an image whose layers have been stored inside the <strong class="source-inline">storevol</strong> volume. To recursively list the content of the store, we can extract the volume mount point with the <strong class="source-inline">podman volume inspect</strong> command:</p>
			<p class="source-code">$ ls -alR \</p>
			<p class="source-code">$(podman volume inspect storevol --format '{{.Mountpoint}}')</p>
			<p>From now on, it is <a id="_idIndexMarker681"/>possible to launch a <a id="_idIndexMarker682"/>new Buildah container to authenticate to the remote registry, and tag and push the image. In the next example, Buildah tags the resulting image, authenticates to the remote registry, and finally pushes the image:</p>
			<p class="source-code">$ podman run --rm -v storevol:/var/lib/containers \</p>
			<p class="source-code">  quay.io/buildah/stable \</p>
			<p class="source-code">  sh -c 'buildah tag build_test1 \</p>
			<p class="source-code">    registry.example.com/build_test1 \</p>
			<p class="source-code">    &amp;&amp; buildah login -u=&lt;USERNAME&gt; -p=&lt;PASSWORD&gt; \</p>
			<p class="source-code">    registry.example.com &amp;&amp; \</p>
			<p class="source-code">    buildah push registry.example.com/build_test1'</p>
			<p>When the image is successfully pushed, it is finally safe to remove the volume:</p>
			<p class="source-code"># podman volume rm storevol</p>
			<p>Despite working perfectly, this approach has some limits that are worth discussing. </p>
			<p>The first limit we can notice is that the store volume is not isolated, and thus any other container can access its contents. To overcome this issue, we can use SELinux's <strong class="bold">Multi-Category Security</strong> (<strong class="bold">MCS</strong>) with the <strong class="source-inline">:Z</strong> suffix in order to apply categories to the volume and <a id="_idIndexMarker683"/>make it accessible exclusively to the running container.</p>
			<p>However, since a second container would run by default with different category labels, we should grab the volume categories and run the second tag/push container with the <strong class="source-inline">--security-opt label=level:s0:&lt;CAT1&gt;,&lt;CAT2&gt;</strong> option. </p>
			<p>Alternatively, we can just run build, tag, and push commands in one single container, as shown in the following example:</p>
			<p class="source-code">$ podman run --device /dev/fuse \</p>
			<p class="source-code">    -v ~/build:/build \</p>
			<p class="source-code">    <strong class="bold">-v secure_storevol:/var/lib/containers:Z</strong> \</p>
			<p class="source-code">    quay.io/buildah/stable \</p>
			<p class="source-code">    sh -c 'buildah build -t test2 /build &amp;&amp; \</p>
			<p class="source-code">      buildah tag test2 registry.example.com/build_test2 &amp;&amp; \</p>
			<p class="source-code">      buildah login -u=&lt;USERNAME&gt; \</p>
			<p class="source-code">      -p=&lt;PASSWORD&gt; \</p>
			<p class="source-code">      registry.example.com &amp;&amp; \</p>
			<p class="source-code">      buildah push registry.example.com/build_test2'</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">In the preceding examples, we used the Buildah login by directly passing the username and password in the command. Needless to say, this is far from being an acceptable security practice. </p>
			<p>Instead of <a id="_idIndexMarker684"/>passing sensitive <a id="_idIndexMarker685"/>data in the command line, we can mount the authentication file that contains a valid session token as a volume inside the container. </p>
			<p>The next example mounts a valid <strong class="source-inline">auth.json</strong> file, stored under the <strong class="source-inline">/run/user/&lt;UID&gt;</strong> tmpfs, inside the build container, and the <strong class="source-inline">--authfile /auth.json</strong> option is then passed to the <strong class="source-inline">buildah push</strong> command: </p>
			<p class="source-code">$ podman run --device /dev/fuse \</p>
			<p class="source-code">    -v ~/build:/build \ </p>
			<p class="source-code">    <strong class="bold">-v /run/user/&lt;UID&gt;/containers/auth.json:/auth.json:z</strong> \</p>
			<p class="source-code">    -v secure_storevol:/var/lib/containers:Z \</p>
			<p class="source-code">    quay.io/buildah/stable \</p>
			<p class="source-code">    sh -c 'buildah build -t test3 /build &amp;&amp; \</p>
			<p class="source-code">      buildah tag test3 registry.example.com/build_test3 &amp;&amp; \</p>
			<p class="source-code">      buildah push <strong class="bold">--authfile /auth.json</strong> \</p>
			<p class="source-code">      registry.example.com/build_test3'</p>
			<p>Finally, we have a working example that avoids exposing clear credentials in the commands passed to the container.</p>
			<p>To provide <a id="_idIndexMarker686"/>a working authentication <a id="_idIndexMarker687"/>file, we need to authenticate from the host that will run the containerized build or copy a valid authentication file. To authenticate with Podman, we'll use the following command:</p>
			<p class="source-code">$ podman login –u &lt;USERNAME&gt; -p &lt;PASSWORD&gt; &lt;REGISTRY&gt;</p>
			<p>If the authentication process succeeds, the obtained token is stored in the <strong class="source-inline">/run/user/&lt;UID&gt;/containers/auth.json</strong> file, which stores a JSON-encoded object with a structure similar to the following example:</p>
			<p class="source-code">{</p>
			<p class="source-code">      "auths": {</p>
			<p class="source-code">           "registry.example.com": {</p>
			<p class="source-code">                "auth": "&lt;base64_encoded_token&gt;"</p>
			<p class="source-code">               }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="callout-heading">Security Alert!</p>
			<p class="callout">If the authentication file mounted inside the container has multiple authentication records for different registries, they will be exposed inside the build container. This can lead to potential security issues, since the container will be able to authenticate on those registries using the tokens specified in the file.</p>
			<p>The volume-based approach we just described has some small impact on the performance <a id="_idIndexMarker688"/>when compared to <a id="_idIndexMarker689"/>a native host build but provides better isolation of the build process, a reduced attack surface, thanks to the rootless execution and standardization of the build environment across different hosts.</p>
			<p>Let's now inspect how to run containerized builds using bind-mounted stores.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor141"/>Running Buildah containers with bind-mounted stores</h2>
			<p>In the highest isolation scenario, where DevOps teams follow a zero-trust approach, every build <a id="_idIndexMarker690"/>container should have its own isolated store populated at the beginning of the build and destroyed upon completion. Isolation can be easily achieved with SELinux MCS security.</p>
			<p>To test this approach, let's start by creating a temporary directory that will host the build layers. We also want to generate a random suffix for a name in order to host multiple builds without conflicts:</p>
			<p class="source-code"># BUILD_STORE=/var/lib/containers-$(echo $RANDOM | md5sum | head -c 8)</p>
			<p class="source-code"># mkdir $BUILD_STORE</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The preceding example and the next builds are executed as root.</p>
			<p>We can now run the build and bind-mount the new directory to the <strong class="source-inline">/var/lib/containers</strong> folder inside the container and add the <strong class="source-inline">:Z</strong> suffix to ensure multi-category security isolation:</p>
			<p class="source-code"># podman run --device /dev/fuse \</p>
			<p class="source-code">    -v ./build:/build:z \</p>
			<p class="source-code">    -v $BUILD_STORE:/var/lib/containers:Z \</p>
			<p class="source-code">    -v /run/containers/0/auth.json:/auth.json \ </p>
			<p class="source-code">    quay.io/buildah/stable \</p>
			<p class="source-code">    bash -c 'set -euo pipefail; \</p>
			<p class="source-code">      buildah build -t registry.example.com/test4 /build; \</p>
			<p class="source-code">      buildah push --authfile /auth.json \</p>
			<p class="source-code">      registry.example.com/test4'</p>
			<p>The MCS isolation guarantees isolation from other containers. Every build container will have its own custom store, and this implies the need to re-pull the base image layers on every execution, since they are never cached. </p>
			<p>Despite being the most secure in terms of isolation, this approach also offers the slowest performance because of the continuous pulls on the build run.</p>
			<p>On the other hand, the less secure approach does not expect any store isolation, and all the build containers <a id="_idIndexMarker691"/>mount the default host store under <strong class="source-inline">/var/lib/containers</strong>. This approach provides better performance, since it allows the reuse of cached layers from the host store. </p>
			<p>SELinux will not allow a containerized process to access the host store; therefore, we need to relax SELinux security restrictions to run the following example using the <strong class="source-inline">--security-opt label=disable</strong> option.</p>
			<p>The following example runs another build using the default host store:</p>
			<p class="source-code"># podman run --device /dev/fuse \</p>
			<p class="source-code">  -v ./build:/build:z </p>
			<p class="source-code">  -v /var/lib/containers:/var/lib/containers \</p>
			<p class="source-code">  --security-opt label=disable \</p>
			<p class="source-code">  -v /run/containers/0/auth.json:/auth.json \</p>
			<p class="source-code">  quay.io/buildah/stable \</p>
			<p class="source-code">  bash -c 'set -euo pipefail; \</p>
			<p class="source-code">    buildah build -t registry.example.com/test5 /build; \</p>
			<p class="source-code">    buildah push --authfile /auth.json \</p>
			<p class="source-code">    registry.example.com/test5'</p>
			<p>The approach described in this example is the opposite of the previous one – better performances but worse security isolation. </p>
			<p>A good compromise between the two implies the usage of a secondary, read-only image store <a id="_idIndexMarker692"/>to provide access to the cached layers. Buildah supports the usage of multiple image stores, and the <strong class="source-inline">/etc/containers/storage.conf</strong> file <em class="italic">inside the Buildah stable image</em> already configures the <strong class="source-inline">/var/lib/shared</strong> folder for this purpose.</p>
			<p>To prove this, we can inspect the content of the <strong class="source-inline">/etc/containers/storage.conf</strong> file, where the following section is defined:</p>
			<p class="source-code"># AdditionalImageStores is used to pass paths to additional Read/Only image stores</p>
			<p class="source-code"># Must be comma separated list.</p>
			<p class="source-code">additionalimagestores = [</p>
			<p class="source-code">"/var/lib/shared",</p>
			<p class="source-code">]</p>
			<p>This way, we can get good isolation and better performance, since cached images from the host will be already available in the read-only store. The read-only store can be prepopulated with the most used images to speed up builds or can be mounted from a network share.</p>
			<p>The following example shows this approach, by bind-mounting the read-only store to the container and executing the build with the advantage of reusing pre-pulled images:</p>
			<p class="source-code"># podman run --device /dev/fuse \</p>
			<p class="source-code">  -v ./build:/build:z \</p>
			<p class="source-code">  -v $BUILD_STORE:/var/lib/containers:Z \</p>
			<p class="source-code">  -v /var/lib/containers/storage:/var/lib/shared:ro \ </p>
			<p class="source-code">  -v /run/containers/0/auth.json:/auth.json:z \</p>
			<p class="source-code">  quay.io/buildah/stable \</p>
			<p class="source-code">  bash -c 'set -euo pipefail; \</p>
			<p class="source-code">  buildah build -t registry.example.com/test6 /build; \</p>
			<p class="source-code">  buildah push --authfile /auth.json \</p>
			<p class="source-code">  registry.example.com/test6'</p>
			<p>The examples <a id="_idIndexMarker693"/>showed in this subsection are also inspired by a great technical article written by <em class="italic">Dan Walsh</em> (one of the leads of the Buildah and Podman projects) on the <em class="italic">Red Hat Developer</em> blog; refer to the <em class="italic">Further reading</em> section for the original article link. Let's close this section with an example of native Buildah commands.</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor142"/>Running native Buildah commands inside containers</h2>
			<p>We have so <a id="_idIndexMarker694"/>far illustrated examples using Dockerfiles/Containerfiles, but nothing prevents us from running containerized native Buildah commands. The following example creates a custom Python image built from a Fedora base image:</p>
			<p class="source-code"># BUILD_STORE=/var/lib/containers-$(echo $RANDOM | md5sum | head -c 8)# mkdir $BUILD_STORE </p>
			<p class="source-code"># podman run --device /dev/fuse \</p>
			<p class="source-code">  -e REGISTRY=&lt;USER_DEFINED_REGISTRY:PORT&gt; \</p>
			<p class="source-code">  --security-opt label=disable \</p>
			<p class="source-code">  -v $BUILD_STORE:/var/lib/containers:Z \</p>
			<p class="source-code">  -v /var/lib/containers/storage:/var/lib/shared:ro \</p>
			<p class="source-code">  -v /run/containers/0:/run/containers/0 \</p>
			<p class="source-code">  quay.io/buildah/stable \</p>
			<p class="source-code">  bash -c 'set -euo pipefail; \</p>
			<p class="source-code">    container=$(buildah from fedora); \</p>
			<p class="source-code">    buildah run $container dnf install -y python3 python3; \</p>
			<p class="source-code">    buildah commit $container $REGISTRY/python_demo; \</p>
			<p class="source-code">    buildah push –authfile \</p>
			<p class="source-code">    /run/containers/0/auth.json $REGISTRY/python_demo'</p>
			<p>From a performance standpoint as well as the build process, nothing changes from the previous examples. As already stated, this approach provides more flexibility in the build operations. </p>
			<p>If the <a id="_idIndexMarker695"/>commands to be passed are too many, a good workaround can be to create a shell script and inject it into the Buildah image using a dedicated volume:</p>
			<p class="source-code"># BUILD_STORE=/var/lib/containers-$(echo $RANDOM | md5sum | head -c 8)</p>
			<p class="source-code"># PATH_TO_SCRIPT=/path/to/script</p>
			<p class="source-code"># REGISTRY=&lt;USER_DEFINED_REGISTRY:PORT&gt;</p>
			<p class="source-code"># mkdir $BUILD_STORE </p>
			<p class="source-code"># podman run --device /dev/fuse \</p>
			<p class="source-code">  -v $BUILD_STORE:/var/lib/containers:Z \</p>
			<p class="source-code">  -v /var/lib/containers/storage:/var/lib/shared:ro \</p>
			<p class="source-code">  -v /run/containers/0:/run/containers/0 \</p>
			<p class="source-code">  -v $PATH_TO_SCRIPT:/root:z \ </p>
			<p class="source-code">  quay.io/buildah/stable /root/build.sh</p>
			<p><strong class="source-inline">build.sh</strong> is the name of the shell script file containing all the build custom commands.</p>
			<p>In this section, we have learned how to run Buildah in containers covering both volume mounts and bind mounts. We have learned how to run rootless build containers that can be easily integrated into pipelines or Kubernetes clusters to provide an end-to-end application life cycle workflow. This is due to the flexible nature of Buildah, and for the same reason, it is very easy to embed Buildah inside custom builders, as we will see in the next section.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor143"/>Integrating Buildah in custom builders</h1>
			<p>As we saw in the previous section of this chapter, Buildah is a key component of Podman's <a id="_idIndexMarker696"/>container ecosystem. Buildah is a dynamic and <a id="_idIndexMarker697"/>flexible tool that can be adapted to different scenarios to build brand-new containers. It has several options and configurations available, but our exploration is not yet finished.</p>
			<p>Podman and all the projects developed around it have been built with extensibility in mind, making every programmable interface available to be reused from the outside world.</p>
			<p>Podman, for example, inherits Buildah capabilities for building brand-new containers through the <strong class="source-inline">podman build</strong> command; with the same principle, we can embed Buildah interfaces and its engine in our custom builder.</p>
			<p>Let's see how to build a custom builder in the Go language; we will see that the process is pretty straightforward, because Podman, Buildah, and many other projects in this ecosystem are actually written in the Go language.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor144"/>Including Buildah in our Go build tool</h2>
			<p>As a first step, we <a id="_idIndexMarker698"/>need to prepare our development <a id="_idIndexMarker699"/>environment, downloading and installing all the required tools and libraries for creating our custom build tool.</p>
			<p>In <a href="B17908_03_epub.xhtml#_idTextAnchor068"><em class="italic">Chapter 3</em></a>, <em class="italic">Running the First Container</em>, we saw various Podman installation methods. In the following section, we will use a similar procedure while going through the preliminary steps for building a Buildah project from scratch, downloading its source file to include in our custom builder.</p>
			<p>First of all, let's ensure we have all the needed packages installed on our development host system:</p>
			<p class="source-code"># dnf install -y golang git go-md2man btrfs-progs-devel \ gpgme-devel device-mapper-devel</p>
			<p class="source-code">Last metadata expiration check: 0:43:05 ago on mar 9 nov 2021, 17:21:23.</p>
			<p class="source-code">Package git-2.33.1-1.fc35.x86_64 is already installed.</p>
			<p class="source-code">Dependencies resolved.</p>
			<p class="source-code">=============================================================================================================================================================================</p>
			<p class="source-code">Package                                                 Architecture                     Version                                    Repository                         Size</p>
			<p class="source-code">=============================================================================================================================================================================</p>
			<p class="source-code">Installing:</p>
			<p class="source-code">btrfs-progs-devel                                       x86_64                            5.14.2-1.fc35                              updates                            50 k</p>
			<p class="source-code">device-mapper-devel                                     x86_64                           1.02.175-6.fc35                            fedora                             45 k</p>
			<p class="source-code">golang                                                  x86_64                           1.16.8-2.fc35                              fedora                            608 k</p>
			<p class="source-code">golang-github-cpuguy83-md2man                           x86_64                           2.0.1-1.fc35                               fedora                            818 k</p>
			<p class="source-code">gpgme-devel                                             x86_64                           1.15.1-6.fc35                              updates                           163 k</p>
			<p class="source-code">Installing dependencies:</p>
			<p class="source-code">[... omitted output]</p>
			<p>After installing <a id="_idIndexMarker700"/>the Go language core libraries and some other <a id="_idIndexMarker701"/>development tools, we are ready to create the directory structure for our project and initialize it:</p>
			<p class="source-code">$ mkdir ~/custombuilder</p>
			<p class="source-code">$ cd ~/custombuilder</p>
			<p class="source-code">[custombuilder]$ export GOPATH=`pwd`</p>
			<p>As shown in the previous example, we followed these steps:</p>
			<ol>
				<li>Created the project root directory</li>
				<li>Defined the Go language root path that we are going to use</li>
			</ol>
			<p>We are now ready to create our Go module that will create our customized container image with a few easy steps.</p>
			<p>To speed up the <a id="_idIndexMarker702"/>example and avoid any writing errors, we <a id="_idIndexMarker703"/>can download the Go language code that we are going to use for this test from the official GitHub repository of this book:</p>
			<ol>
				<li value="1">Go to <a href="https://github.com/PacktPublishing/Podman-for-DevOps">https://github.com/PacktPublishing/Podman-for-DevOps</a> or run the following command:<p class="source-code">$ git clone https://github.com/PacktPublishing/Podman-for-DevOps </p></li>
				<li>After that, copy the files provided in the <strong class="source-inline">Chapter07/*</strong> directory into the newly created <strong class="source-inline">~/custombuilder/</strong> directory.</li>
			</ol>
			<p>You should have the following files in your directory at this point:</p>
			<p class="source-code">$ cd ~/custombuilder/src/builder</p>
			<p class="source-code">$ ls -latotal 148</p>
			<p class="source-code">drwxrwxr-x. 1 alex alex     74 9 nov 15.22 .</p>
			<p class="source-code">drwxrwxr-x. 1 alex alex     14 9 nov 14.10 ..</p>
			<p class="source-code">-rw-rw-r--. 1 alex alex   1466 9 nov 14.10 custombuilder.go</p>
			<p class="source-code">-rw-rw-r--. 1 alex alex    161 9 nov 15.22 go.mod</p>
			<p class="source-code">-rw-rw-r--. 1 alex alex 135471 9 nov 15.22 go.sum</p>
			<p class="source-code">-rw-rw-r--. 1 alex alex    337 9 nov 14.17 script.js</p>
			<p>At this point, we can run the following command to let the Go tools acquire all the needed dependencies to ready the module for execution:</p>
			<p class="source-code">$ go mod tidy</p>
			<p class="source-code">go: finding module for package github.com/containers/storage/pkg/unshare</p>
			<p class="source-code">go: finding module for package github.com/containers/image/v5/storage</p>
			<p class="source-code">go: finding module for package github.com/containers/storage</p>
			<p class="source-code">go: finding module for package github.com/containers/image/v5/types</p>
			<p class="source-code">go: finding module for package github.com/containers/buildah/define</p>
			<p class="source-code">go: finding module for package github.com/containers/buildah</p>
			<p class="source-code">go: found github.com/containers/buildah in github.com/containers/buildah v1.23.1</p>
			<p class="source-code">go: found github.com/containers/buildah/define in github.com/containers/buildah v1.23.1</p>
			<p class="source-code">go: found github.com/containers/image/v5/storage in github.com/containers/image/v5 v5.16.1</p>
			<p class="source-code">go: found github.com/containers/image/v5/types in github.com/containers/image/v5 v5.16.1</p>
			<p class="source-code">go: found github.com/containers/storage in github.com/containers/storage v1.37.0</p>
			<p class="source-code">go: found github.com/containers/storage/pkg/unshare in github.com/containers/storage v1.37.0</p>
			<p>The tool <a id="_idIndexMarker704"/>analyzed the provided <strong class="source-inline">custombuilder.go</strong> file, and <a id="_idIndexMarker705"/>it found all the required libraries, populating the <strong class="source-inline">go.mod</strong> file.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Please be aware that the previous command will verify whether a module is available, and if it is not, the tool will start downloading it from the internet. So, be patient during this step!</p>
			<p>We can check <a id="_idIndexMarker706"/>that the previous commands downloaded <a id="_idIndexMarker707"/>all the required packages by inspecting the directory structure we created earlier:</p>
			<p class="source-code">$ cd ~/custombuilder</p>
			<p class="source-code">[custombuilder]$ ls</p>
			<p class="source-code">pkg  src</p>
			<p class="source-code">[custombuilder]$ ls -la pkg/</p>
			<p class="source-code">total 0</p>
			<p class="source-code">drwxrwxr-x. 1 alex alex  28  9 nov 18.27 .</p>
			<p class="source-code">drwxrwxr-x. 1 alex alex  12  9 nov 18.18 ..</p>
			<p class="source-code">drwxrwxr-x. 1 alex alex  20  9 nov 18.27 linux_amd64</p>
			<p class="source-code">drwxrwxr-x. 1 alex alex 196  9 nov 18.27 mod</p>
			<p class="source-code">[custombuilder]$ ls -la pkg/mod/</p>
			<p class="source-code">total 0</p>
			<p class="source-code">drwxrwxr-x. 1 alex alex 196  9 nov 18.27 .</p>
			<p class="source-code">drwxrwxr-x. 1 alex alex  28  9 nov 18.27 ..</p>
			<p class="source-code">drwxrwxr-x. 1 alex alex  22  9 nov 18.18 cache</p>
			<p class="source-code">drwxrwxr-x. 1 alex alex 918  9 nov 18.27 github.com</p>
			<p class="source-code">drwxrwxr-x. 1 alex alex  24  9 nov 18.27 go.etcd.io</p>
			<p class="source-code">drwxrwxr-x. 1 alex alex   2  9 nov 18.27 golang.org</p>
			<p class="source-code">[... omitted output]</p>
			<p class="source-code">[custombuilder]$ ls -la pkg/mod/github.com/</p>
			<p class="source-code">[... omitted output]</p>
			<p class="source-code">drwxrwxr-x. 1 alex alex  98  9 nov 18.27  containerd</p>
			<p class="source-code">drwxrwxr-x. 1 alex alex  20  9 nov 18.27  containernetworking</p>
			<p class="source-code">drwxrwxr-x. 1 alex alex 184  9 nov 18.27  containers</p>
			<p class="source-code">drwxrwxr-x. 1 alex alex 110  9 nov 18.27  coreos</p>
			<p class="source-code">[... omitted output]</p>
			<p>We are now ready to run our custom builder module, but before going forward, let's take a look at the key elements contained in the Go source file.</p>
			<p>If we start <a id="_idIndexMarker708"/>looking at the <strong class="source-inline">custombuilder.go</strong> file, just <a id="_idIndexMarker709"/>after defining the package and the libraries to use, we defined the main function of our module.</p>
			<p>In the main function, at the beginning of the definition, we inserted a fundamental code block:</p>
			<p class="source-code">  if buildah.InitReexec() {</p>
			<p class="source-code">    return</p>
			<p class="source-code">  }</p>
			<p class="source-code">  unshare.MaybeReexecUsingUserNamespace(false)</p>
			<p>This piece of code enables the usage of <strong class="bold">rootless</strong> mode by leveraging the Go <strong class="source-inline">unshare</strong> package, available through <strong class="source-inline">github.com/containers/storage/pkg/unshare</strong>.</p>
			<p>To leverage the build features of Buildah, we have to instantiate <strong class="source-inline">buildah.Builder</strong>. This object has all the methods to define the build steps, configure the build, and finally run it.</p>
			<p>To create <strong class="source-inline">Builder</strong>, we need an object called <strong class="source-inline">storage.Store</strong> from the <strong class="source-inline">github.com/containers/storage</strong> package. This element is responsible for storing the intermediate and resultant container images. Let's see the code block we are discussing:</p>
			<p class="source-code">buildStoreOptions, err := storage.DefaultStoreOptions(unshare.IsRootless(), unshare.GetRootlessUID())</p>
			<p class="source-code">buildStore, err := storage.GetStore(buildStoreOptions)</p>
			<p>As you can see from the previous example, we are getting the default options and passing them to the <strong class="source-inline">storage</strong> module to request a <strong class="source-inline">Store</strong> object.</p>
			<p>Another element <a id="_idIndexMarker710"/>we need for creating <strong class="source-inline">Builder</strong> is <a id="_idIndexMarker711"/>the <strong class="source-inline">BuilderOptions</strong> object. This element contains all the default and custom options we might assign to Buildah's <strong class="source-inline">Builder</strong>. Let's see how to define it:</p>
			<p class="source-code">builderOpts := buildah.BuilderOptions{</p>
			<p class="source-code">  FromImage:        "node:12-alpine", // Starting image</p>
			<p class="source-code">  Isolation:        define.IsolationChroot, // Isolation environment</p>
			<p class="source-code">  CommonBuildOpts:  &amp;define.CommonBuildOptions{},</p>
			<p class="source-code">  ConfigureNetwork: define.NetworkDefault,</p>
			<p class="source-code">  SystemContext:    &amp;types.SystemContext {},</p>
			<p class="source-code">}</p>
			<p>In the previous code block, we defined a <strong class="source-inline">BuilderOptions</strong> object that contains the following: </p>
			<ul>
				<li>An initial image that we are going to use to build our target container image:<ul><li>In this case, we chose the Node.js image based on Alpine Linux distribution. This is because, in our example, we are simulating the build process of a Node.js application.</li></ul></li>
				<li>Isolation mode to adopt once the build starts. In this case, we are going to use chroot isolation that fits a lot of build scenarios well – less isolation but fewer requirements.</li>
				<li>Some default options for the build, network, and system contexts:<ul><li><strong class="source-inline">SystemContext</strong> objects define the information contained in configuration files as parameters.</li></ul></li>
			</ul>
			<p>Now that we have all the necessary data for instantiating <strong class="source-inline">Builder</strong>, let's do it:</p>
			<p class="source-code">builder, err := buildah.NewBuilder(context.TODO(), buildStore, builderOpts)</p>
			<p>As you can see, we are calling the <strong class="source-inline">NewBuilder</strong> function, with all the required options that we created <a id="_idIndexMarker712"/>in code earlier in this section, to get <strong class="source-inline">Builder</strong> ready <a id="_idIndexMarker713"/>to create our custom container image.</p>
			<p>Now that we are ready to instruct <strong class="source-inline">Builder</strong> with the required options to create the custom image, let's first add into the container image the <strong class="bold">JavaScript</strong> file containing our application, for which we are creating this container image:</p>
			<p class="source-code">err = builder.Add("/home/node/", false, buildah.AddAndCopyOptions{}, "script.js")</p>
			<p>We are assuming that the JavaScript main file is stored next to the Go module that we are writing and using in this example, and we are copying this file into the <strong class="source-inline">/home/node</strong> directory, which is the default path where the base container image expects to find this kind of data.</p>
			<p>The JavaScript program that we are going to copy into the container image and use for this test is really simple – let's inspect it:</p>
			<p class="source-code">var http = require("http");</p>
			<p class="source-code">http.createServer(function(request, response) {</p>
			<p class="source-code">  response.writeHead(200, {"Content-Type": "text/plain"});</p>
			<p class="source-code">  response.write("Hello Podman and Buildah friends. This page is provided to you through a container running Node.js version: ");</p>
			<p class="source-code">  response.write(process.version);</p>
			<p class="source-code">  response.end();</p>
			<p class="source-code">}).listen(8080);</p>
			<p>Without going deep into the JavaScript language syntax and its concepts, we can note looking at the JavaScript file that we are using the HTTP library for listening on port <strong class="source-inline">8080</strong> for incoming requests, responding to these requests with a default welcome message: <strong class="source-inline">Hello Podman and Buildah friends. This page is provided to you through a container running Node.js</strong>. We also append the Node.js version to the response string.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Please consider that JavaScript, also known as <strong class="bold">JS</strong>, is a high-level programming language that is compiled just in time. As we stated earlier, we are neither going deep into the definition of the JavaScript language nor its most famous runtime environment, Node.js. </p>
			<p>After that, we configure the <a id="_idIndexMarker714"/>default command to run for our <a id="_idIndexMarker715"/>custom container image:</p>
			<p class="source-code">builder.SetCmd([]string{"node", "/home/node/script.js"})</p>
			<p>We just set the command to execute the Node.js execution runtime, referring to the JavaScript program that we just added to the container image.</p>
			<p>For committing the changes we made, we need to get the image reference that we are working on. At the same time, we will also define the container image name that <strong class="source-inline">Builder</strong> will create:</p>
			<p class="source-code">imageRef, err := is.Transport.ParseStoreReference(buildStore, "podmanbook/nodejs-welcome")</p>
			<p>Now, we are ready to commit the changes and call the <strong class="source-inline">commit</strong> function of <strong class="source-inline">Builder</strong>:</p>
			<p class="source-code">imageId, _, _, err := builder.Commit(context.TODO(), imageRef, define.CommitOptions{})</p>
			<p class="source-code">fmt.Printf("Image built! %s\n", imageId)</p>
			<p>As we can see, we just requested <strong class="source-inline">Builder</strong> to commit the changes, passing the image reference we obtained earlier, and then we finally print it as a reference.</p>
			<p>We are now ready to run our program! Let's execute it:</p>
			<p class="source-code">[builder]$ go run custombuilder.go </p>
			<p class="source-code">Image built! e60fa98051522a51f4585e46829ad6a18df704dde774634dbc010baae440 4849</p>
			<p>We can now test the custom container image we just built:</p>
			<p class="source-code">[builder]$ podman run -dt -p 8080:8080/tcp podmanbook/nodejs-welcome:latest</p>
			<p class="source-code">747805c1b59558a70c4a2f1a1d258913cae5ffc08cc026c74ad3ac21aab1 8974</p>
			<p class="source-code">[builder]$ curl localhost:8080</p>
			<p class="source-code">Hello Podman and Buildah friends. This page is provided to you through a container running Node.js version: v12.22.7</p>
			<p>As we can see in the <a id="_idIndexMarker716"/>previous code block, we are running the <a id="_idIndexMarker717"/>container image we just created with the following options:</p>
			<ul>
				<li><strong class="source-inline">-d</strong>: Detached mode, which runs the container in the background</li>
				<li><strong class="source-inline">-t</strong>: Allocates a new pseudo-TTY</li>
				<li><strong class="source-inline">-p</strong>: Publishes the container port to the host system</li>
				<li><strong class="source-inline">podmanbook/nodejs-welcome:latest</strong>: The name of our custom container image</li>
			</ul>
			<p>Finally, we use the <strong class="source-inline">curl</strong> command-line tool for requesting and printing the HTTP response provided by our JavaScript program, which is containerized in the custom container image that we created!</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The example described in this section is just a simple overview of all the great features that the Buildah Go module can enable for our custom image builders. To learn more about the various functions, variables, and code documentation, you can refer to the docs at <a href="https://pkg.go.dev/github.com/containers/buildah">https://pkg.go.dev/github.com/containers/buildah</a>.</p>
			<p>As we saw in this section, Buildah is a really flexible tool, and with its libraries, it can support custom builders in many different scenarios.</p>
			<p>If we try to search on the internet, we can find many examples of Buildah supporting the creation of custom container images. Let's see some of them.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor145"/>Quarkus-native executables in containers</h2>
			<p><strong class="bold">Quarkus</strong> is defined as the Kubernetes-native Java stack leveraging OpenJDK (the open Java development kit) project <a id="_idIndexMarker718"/>and the GraalVM project. GraalVM is a Java virtual machine that has many special features, such as the compilation of Java applications for fast startup and low memory footprint.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">We will not go into the details of Quarkus, GraalVM, and any other companion projects. The example that we will deep-dive into is only for your reference. We encourage you to learn more about these projects by going through their web pages and reading the related documentation.</p>
			<p>If we take a look at the Quarkus documentation web page, we can easily find that, after a long tutorial in which we can learn how to build a Quarkus-native executable, we can then pack and execute this executable in a container image.</p>
			<p>The steps provided in the Quarkus documentation leverage a Maven wrapper with a special option. Maven was born as a Java build automation tool, but then it was also extended to other programming languages. If we take a quick look at this command, we will note the name of Podman inside:</p>
			<p class="source-code">$ ./mvnw package -Pnative -Dquarkus.native.container-build=true -Dquarkus.native.container-runtime=podman</p>
			<p>This means that the Maven wrapper program will invoke a Podman build to create a container image with the preconfigured environment shipped by the Quarkus project and the binary application that we are developing. </p>
			<p>We saw the name of Podman inside the option. This is because, as we saw in <a href="B17908_06_epub.xhtml#_idTextAnchor116"><em class="italic">Chapter 6</em></a>, <em class="italic">Meet Buildah – Building Containers from Scratch</em>, Podman borrows Buildah's build logic by vendoring its libraries.</p>
			<p>To explore <a id="_idIndexMarker719"/>this example further, we can take a look at <a href="https://quarkus.io/guides/building-native-image">https://quarkus.io/guides/building-native-image</a>.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor146"/>A Buildah wrapper for the Rust language</h2>
			<p>Another cool example of build tools made through the Buildah library or CLI is the Buildah wrapper <a id="_idIndexMarker720"/>for the <strong class="bold">Rust</strong> programming language. Rust is a programming language similar to C++, designed for performance and safe <a id="_idIndexMarker721"/>concurrency. The main project page is available at this URL: <a href="https://github.com/Dennis-Krasnov/Buildah-Rust">https://github.com/Dennis-Krasnov/Buildah-Rust</a>.</p>
			<p>This Buildah wrapper leverages the Rust package manager names <strong class="bold">Cargo</strong> for downloading the needed dependencies, compiles it in a package, and makes it distributable.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">We will not go into the details of Rust, Cargo, and any other companion projects. The example that we will deep-dive into is only for your reference. We encourage you to learn more about these projects by going through their web pages and reading the related documentation.</p>
			<p>The example in the project homepage is really simple, as you can see in the following code block:</p>
			<p class="source-code">$ cd examples/</p>
			<p class="source-code">$ cargo run --example nginx</p>
			<p class="source-code">$ podman run --rm -it -p 8080:80 nginx_rust</p>
			<p>The first command, after selecting the directory named <strong class="source-inline">examples</strong>, executes a simple block of code that is needed to create a container, while the second tests the container image that the Buildah wrapper has just made through Buildah itself.</p>
			<p>We can take a look at the Rust code used in the first command of the previous code block. The first command executes the small piece of code in the <strong class="source-inline">nginx.rs</strong> file:</p>
			<p class="source-code">use buildah_rs::container::Container;</p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    let mut container = Container::from("nginx:1.21");</p>
			<p class="source-code">    container.copy("html", "/usr/share/nginx/html").unwrap();</p>
			<p class="source-code">    container.commit("nginx_rust").unwrap();</p>
			<p class="source-code">}</p>
			<p>As stated before, we will not dive deep into the code syntax or into the library itself; anyway, the <a id="_idIndexMarker722"/>code is pretty simple, and it just imports the Buildah wrapper library, creates a container image starting from <strong class="source-inline">nginx:1.21</strong>, and finally, copies the local <strong class="source-inline">html</strong> directory to the container image's destination path.</p>
			<p>To explore this example further, take a look at <a href="https://github.com/Dennis-Krasnov/Buildah-Rust">https://github.com/Dennis-Krasnov/Buildah-Rust</a>. </p>
			<p>This concludes this section. We have learned, through a lot of useful examples, about how to integrate Buildah in different scenarios to support custom builders of the container images of our projects.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor147"/>Summary</h1>
			<p>In this chapter, we have learned how to leverage Podman's companion, Buildah, in some advanced scenarios to support our development projects.</p>
			<p>We saw how to use Buildah for multistage container image creation, which allows us to create builds with multiple stages using different <strong class="source-inline">FROM</strong> instructions and, subsequently, to have images that grab contents from the previous ones.</p>
			<p>Then, we discovered that there are many use cases that imply the need for containerized builds. Nowadays, one of the most common adoption scenarios is the application build workflow running on top of a Kubernetes cluster. For this reason, we went into the details of containerizing Buildah.</p>
			<p>Finally, we learned through a lot of interesting examples how to integrate Buildah to create custom builders for container images. As we saw in this chapter, there are several options and methods to actually build a container image with the Podman ecosystem tools, and most of the time, we usually start from a base image for customizing and extending a previous OS layer to fit our use cases.</p>
			<p>In the next chapter, we will learn more about container base images, how to choose them, and what to look out for when we are making our choice.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor148"/>Further readings</h1>
			<ul>
				<li>A list of CNCF projects: <a href="https://landscape.cncf.io/">https://landscape.cncf.io/</a></li>
				<li><em class="italic">Best practices for running Buildah in a container</em>: <a href="https://developers.redhat.com/blog/2019/08/14/best-practices-for-running-buildah-in-a-container">https://developers.redhat.com/blog/2019/08/14/best-practices-for-running-buildah-in-a-container</a></li>
				<li>The Buildah Go module documentation: <a href="https://pkg.go.dev/github.com/containers/buildah">https://pkg.go.dev/github.com/containers/buildah</a></li>
				<li>Quarkus-native executables: <a href="https://quarkus.io/guides/building-native-image">https://quarkus.io/guides/building-native-image</a></li>
				<li>The Buildah wrapper for the Rust language: <a href="https://github.com/Dennis-Krasnov/Buildah-Rust">https://github.com/Dennis-Krasnov/Buildah-Rust</a></li>
			</ul>
		</div>
	</body></html>