<html><head></head><body>
		<div id="_idContainer043">
			<h1 id="_idParaDest-167"><em class="italic"><a id="_idTextAnchor167"/>Chapter 9</em>: Pushing Images to a Container Registry</h1>
			<p>In the previous chapter, we went through the very important concept of the container base image. As we saw, it is really important to choose the base image wisely for our containers, using official container images from trusted container registries and development communities.</p>
			<p>But once we choose the preferred base image and then build our final container image, we need a way to further distribute our work to the various target hosts that we plan to let it run on. </p>
			<p>The best option to distribute a container image is to push it to a container registry and after that, let all the target hosts pull the container image and run it. </p>
			<p>For this reason, in this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>What is a container registry?</li>
				<li>Cloud-based and on-premise container registries</li>
				<li>Managing container images with Skopeo</li>
				<li>Running a local container registry </li>
			</ul>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor168"/>Technical requirements</h1>
			<p>Before proceeding with the chapter and its examples, a machine with a working Podman installation is required. As stated in <a href="B17908_03_epub.xhtml#_idTextAnchor068"><em class="italic">Chapter 3</em></a>, <em class="italic">Running the First Container</em>, all the examples in the book are executed on a Fedora 34 system or later but can be reproduced on your OS of choice.</p>
			<p>A good understanding of the topics covered in <a href="B17908_04_epub.xhtml#_idTextAnchor083"><em class="italic">Chapter 4</em></a>, <em class="italic">Managing Running Containers</em>, and <a href="B17908_08_epub.xhtml#_idTextAnchor149"><em class="italic">Chapter 8</em></a>, <em class="italic">Choosing the Container Base Image</em>, is useful to easily grasp concepts regarding container registries.</p>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor169"/>What is a container registry?</h1>
			<p>A<a id="_idIndexMarker805"/> container registry is just a collection of container images' repositories, used in conjunction with systems that need to pull and run container images in a dynamic way. </p>
			<p>The <a id="_idIndexMarker806"/>main features available on a container registry are the following:</p>
			<ul>
				<li>Repository management</li>
				<li>Pushing container images</li>
				<li>Tag management</li>
				<li>Pulling container images</li>
				<li>Authentication <a id="_idIndexMarker807"/>management</li>
			</ul>
			<p>Let's look at every feature in detail in the following sections.</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor170"/>Repository management</h2>
			<p>One<a id="_idIndexMarker808"/> of the most important features of container<a id="_idIndexMarker809"/> registries is managing container images through repositories. Depending on the container registry implementation that we choose, we will be sure to find a web interface or a command-line interface that will let us handle the creation of a sort of <em class="italic">folder</em> that will act as a repository for our container images.</p>
			<p>According to<a id="_idIndexMarker810"/> the <strong class="bold">Open Container Initiative</strong> (<strong class="bold">OCI</strong>) Distribution Specification <em class="italic">[1]</em>, the container images are organized in a repository that is identified by name. A repository name is usually composed of a user/organization name and the container image name in this way: <em class="italic">myorganization/mycontainerimage</em>, and it must respect the following regular expression check:</p>
			<p class="source-code">[a-z0-9]+([._-][a-z0-9]+)*(/[a-z0-9]+([._-][a-z0-9]+)*)*</p>
			<p class="callout-heading">Important Definition</p>
			<p class="callout">A <strong class="bold">regular expression</strong> (<strong class="bold">regex</strong>) is a<a id="_idIndexMarker811"/> search pattern defined by a sequence of characters. This pattern definition leverages several notations that let the user define in detail the target keyword, line, or multiple lines to find in a text document.</p>
			<p>Once we've<a id="_idIndexMarker812"/> created a repository on our container registry, we should be able to start pushing, pulling, and handling different versions (identified by a label) of our container images.</p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor171"/>Pushing container images</h2>
			<p>The <a id="_idIndexMarker813"/>act of pushing container images to a<a id="_idIndexMarker814"/> container registry is handled by the container tool that we are using, which respects the OCI Distribution Specification. </p>
			<p>In this process, the blobs, which are the binary form of the content, are uploaded first and, usually at the end, the manifest is then uploaded. This order is not strict and mandatory by the specification, but a registry may refuse a manifest that references blobs that it does not know.</p>
			<p>Using a container management tool to push a container image to a registry, we must specify again the name of the repository in the form shown before and the container image's tag we want to upload.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor172"/>Tag management</h2>
			<p>As <a id="_idIndexMarker815"/>we introduced starting in <a href="B17908_04_epub.xhtml#_idTextAnchor083"><em class="italic">Chapter 4</em></a>, <em class="italic">Managing Running Containers</em>, the container images are identified by a name and a tag. Thanks to the <a id="_idIndexMarker816"/>tag mechanism, we can store several different versions of the container images on a system's local cache or on a container registry.</p>
			<p>The container registry should be able to expose the feature of content discovery, providing the list of the container images' tags to the client requesting it. This feature can give the opportunity to the container registry's users to choose the right container image to pull and run to the target systems.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor173"/>Pulling container images</h2>
			<p>In <a id="_idIndexMarker817"/>the process of pulling container images, the client <a id="_idIndexMarker818"/>should first request the manifest to know which blobs, which are the binary form of the content, to pull to get the final container image. The order is strict because without pulling and parsing the manifest file of the container image, the client would not be able to know which binary data it has to request from the registry.</p>
			<p>Using a <a id="_idIndexMarker819"/>container management tool to pull a container image from a registry, we must specify again the name of the repository in the form shown before and the container image's tag we want to download.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor174"/>Authentication management</h2>
			<p>All the <a id="_idIndexMarker820"/>previous operations may require<a id="_idIndexMarker821"/> authentication. In many cases, public container registries may allow anonymous pulling and content discovery but for pushing container images they require a valid authentication.</p>
			<p>Depending on the container registry chosen, we might find basic or advanced features to authenticate to a container registry, let our client store a token, and then use it for every operation that could require it.</p>
			<p>This ends up our brief deep dive into container registry theory. If you want to know more about the OCI Distribution Specification, you can investigate the URL <em class="italic">[1]</em> available at the end of this chapter in the <em class="italic">Further reading</em> section.</p>
			<p class="callout-heading">Nice to Know</p>
			<p class="callout">The OCI Distribution Specification<a id="_idIndexMarker822"/> also defines a set of conformance tests that anyone could run against a container registry to check if that particular implementation respects all the rules defined in the specification: <a href="https://github.com/opencontainers/distribution-spec/tree/main/conformance">https://github.com/opencontainers/distribution-spec/tree/main/conformance</a>. </p>
			<p>The various implementations of a container registry available on the web, in addition to the basic functions we described before, also add more features that we will discover soon in the next section.</p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor175"/>Cloud-based and on-premise container registries</h1>
			<p>As we introduced in the previous sections, the OCI defined a standard to adhere to for container registries. This initiative allowed the rise of many other container registries apart from the initial Docker Registry and its online service, Docker Hub.</p>
			<p>We can group the available container registries into two main categories:</p>
			<ul>
				<li>Cloud-based <a id="_idIndexMarker823"/>container registries</li>
				<li>On-premise<a id="_idIndexMarker824"/> container registries</li>
			</ul>
			<p>Let's see these two categories in detail in the following subsections.</p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor176"/>On-premise container registries</h2>
			<p>On-premise<a id="_idIndexMarker825"/> container registries are often used for creating a private repository for enterprise purposes. The main use cases include the following:</p>
			<ul>
				<li>Distributing images in a private or isolated network</li>
				<li>Deploying a new container image at a large scale over several machines</li>
				<li>Keeping any sensitive data in our own data center</li>
				<li>Improving the speed of pulling and pushing images using an internal network</li>
			</ul>
			<p>Of course, running an on-premise registry requires several skills to ensure availability, monitoring, logging, and security.  </p>
			<p>This is a non-comprehensive list of the available container registries that we can install on-premises: </p>
			<ul>
				<li><strong class="bold">Docker Registry</strong>: Docker's <a id="_idIndexMarker826"/>project, which is currently at version 2, provides<a id="_idIndexMarker827"/> all the basic features described in the earlier sections and we will learn how to run it in the last section of this chapter, <em class="italic">Running a local container registry</em>.</li>
				<li><strong class="bold">Harbor</strong>: This is a <a id="_idIndexMarker828"/>VMware open source project that provides high<a id="_idIndexMarker829"/> availability, image auditing, and integration with authentication systems.</li>
				<li><strong class="bold">GitLab Container Registry</strong>: This is <a id="_idIndexMarker830"/>strongly integrated with the <a id="_idIndexMarker831"/>GitLab product, so it requires minimal setup, but it depends on the main project.</li>
				<li><strong class="bold">JFrog Artifactory</strong>: This<a id="_idIndexMarker832"/> manages more than just containers; it provides <a id="_idIndexMarker833"/>management for any artifact.</li>
				<li><strong class="bold">Quay</strong>: This is the <a id="_idIndexMarker834"/>open source distribution of the Red Hat product called Quay. This<a id="_idIndexMarker835"/> project offers a fully-featured web UI, a service for image vulnerability scanning, data storage, and protection.</li>
			</ul>
			<p>We will not go into every detail of these container registries. What we can suggest for sure is to pay attention and choose the product or project that fits better with your use cases and support needs. Many of these products have support plans or enterprise editions (license required) that could easily save your skin in the event of a disaster.</p>
			<p>Let's now see what the cloud-based container registries are that could make our life easier, offering a complete managed service, with which our operational skills could be reduced to zero.</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor177"/>Cloud-based container registries</h2>
			<p>As anticipated in the <a id="_idIndexMarker836"/>previous section, cloud-based container registries could be the fastest way to start working with container images through a registry.</p>
			<p>As described in <a href="B17908_08_epub.xhtml#_idTextAnchor149"><em class="italic">Chapter 8</em></a>, <em class="italic">Choosing the Container Base Image</em>, there are several cloud-based container registry services on the web. We will concentrate only on a small subset, taking out of the analysis the ones provided by a public cloud provider and the ones offered by the Linux distribution, which usually are only available to pull images, preloaded by the distribution maintainers.</p>
			<p>We will take a look at these cloud container registries:</p>
			<ul>
				<li><strong class="bold">Docker Hub</strong>: This is a <a id="_idIndexMarker837"/>hosted registry solution by Docker Inc. This <a id="_idIndexMarker838"/>registry also hosts official repositories and security verified images for some popular open source projects.</li>
				<li><strong class="bold">Quay</strong>: This is the <a id="_idIndexMarker839"/>hosted registry solution born under the CoreOS company, now <a id="_idIndexMarker840"/>part of Red Hat. It offers private and public repositories, automated scanning for security purposes, image builds, and integration with popular Git public repositories.</li>
			</ul>
			<h3>Docker Hub cloud registry</h3>
			<p>Docker Hub cloud registry <a id="_idIndexMarker841"/>was born together with the Docker project and it represented one of the greatest features added to this project and containers in general, the right attention they deserved.</p>
			<p>Talking about features, Docker Hub has free and paid plans:</p>
			<ul>
				<li>Anonymous access: Only 100 image pulls in 6 hours.</li>
				<li>A registered user account with the free tier: 200 image pulls in 6 hours and unlimited public repositories. With the free tier we do not get builds or security scans.</li>
				<li>Pro, Team, and Business accounts: Thousands of image pulls per day, automated builds, security scans, RBAC, and so on.</li>
			</ul>
			<p>As we just reported, if we try to log in with a registered user account with the free tier, we can only create public repositories. This could be enough for communities or individual developers, but once you start using it at the enterprise level, you may need the additional features provided by the paid plans.</p>
			<p>To avoid a big limitation in terms of image pulls, we should at least use a registered user account and log in to the web portal and to the container registry with our beloved container engine: Podman. We will see in the following sections how to authenticate to a registry and ensure 200 image pulls every 6 hours using Docker Hub.</p>
			<h3>Red Hat Quay cloud registry</h3>
			<p>Quay cloud registry is the <a id="_idIndexMarker842"/>Red Hat on-premise registry but offered <a id="_idIndexMarker843"/>as <strong class="bold">Software-as-a-Service</strong> (<strong class="bold">SaaS</strong>).</p>
			<p>Quay cloud registry, like Docker Hub, offers paid plans as well to unlock additional features.</p>
			<p>But the nice news is that Quay's free tier has a lot of features included:</p>
			<ul>
				<li>Build from a Dockerfile, manually uploaded or even linked through GitHub/Bitbucket/Gitlab or any Git repository.</li>
				<li>Security scans for images pushed on the registry.</li>
				<li>Usage/auditing logs.</li>
				<li>Robot user account/tokens for integrating any external software.</li>
				<li>There is no limit on image pulls.</li>
			</ul>
			<p>On the other hand, the paid plans will unlock private repositories and team-based permissions.</p>
			<p>Let's look at the Quay cloud registry by creating a public repository and linking it to a GitHub repository in which we pushed a Dockerfile to build our target container image:</p>
			<ol>
				<li>First, we need to register or log in to the Quay<a id="_idIndexMarker844"/> portal at <a href="https://quay.io">https://quay.io</a>.</li>
			</ol>
			<p>After that, we can click on the <strong class="bold">+ Create New Repository</strong> button in the upper-right corner:</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/B17908_09_01.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – Quay Create New Repository button</p>
			<ol>
				<li value="2">Once done, the <a id="_idIndexMarker845"/>web portal will request some basic information about the new repository we want to create:<ul><li>A name</li><li>A description</li><li>Public or private (we are using a free account, so public is fine)</li><li>How to initialize the repository:</li></ul></li>
			</ol>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/B17908_09_02.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – Create New Repository page</p>
			<p>We just defined a name for our repo, <strong class="source-inline">ubi8-httpd</strong>, and we chose to link this repository to a GitHub repository push.</p>
			<ol>
				<li value="3">Once <a id="_idIndexMarker846"/>confirmed, the Quay registry cloud portal will redirect us to GitHub to allow the authorization and then it will ask us to select the right organization and GitHub repository to link with:</li>
			</ol>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B17908_09_03.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3 – Select the GitHub repository to link with our container repo</p>
			<p>We just <a id="_idIndexMarker847"/>selected the default organization and the Git repository we created holding our Dockerfile. The Git repository is named <strong class="source-inline">ubi8-httpd</strong> and it is available here: <a href="https://github.com/alezzandro/ubi8-httpd">https://github.com/alezzandro/ubi8-httpd</a>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The repository used in this example belongs to the author's own project. You can fork the repository on GitHub and make your own copy with read/write permissions in order to be able to make changes and experiment with commits and automated builds.</p>
			<ol>
				<li value="4">Finally, it will ask us to further configure the trigger:</li>
			</ol>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/B17908_09_04.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4 – Build trigger customization</p>
			<p>We just left the default option, which will trigger a new build every time a push is made on the Git repository for any branches and tags.</p>
			<ol>
				<li value="5">Once done, we<a id="_idIndexMarker848"/> will be redirected to the main repository page:</li>
			</ol>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B17908_09_05.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5 – Main repository page</p>
			<p>Once created, the repository is empty with no information or activity, of course.</p>
			<ol>
				<li value="6">On the left bar, we can easily access the build section. It's the fourth icon starting from the top. In the following figure, we just executed two pushes on our Git repository, which triggered two different builds:</li>
			</ol>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B17908_09_06.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.6 – Container image build section</p>
			<ol>
				<li value="7">If we try clicking on<a id="_idIndexMarker849"/> one of the builds, the cloud registry will show the details of the build:</li>
			</ol>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B17908_09_07.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.7 – Container image build details</p>
			<p>As we can see, the build worked as expected, connecting to the GitHub repository, downloading the Dockerfile and executing the build, and finally, pushing the image to the container registry, all in an automated way. The Dockerfile contains just a few commands for installing an httpd server on a UBI8 base image, as we learned in <a href="B17908_08_epub.xhtml#_idTextAnchor149"><em class="italic">Chapter 8</em></a>, <em class="italic">Choosing the Container Base Image</em>.</p>
			<ol>
				<li value="8">Finally, the last section that is worth mentioning is the included security scanning functionality. This feature is accessible by clicking the <em class="italic">Tag</em> icon, the second from the top in the left panel:</li>
			</ol>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B17908_09_08.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.8 – Container image tags page</p>
			<p>As you will notice, there<a id="_idIndexMarker850"/> is a <strong class="source-inline">SECURITY SCAN</strong> column (the third) reporting the status of the scan executed on that particular container image associated with the tag name reported in the first column. By clicking on the value of that column (in the previous screenshot, it is <strong class="source-inline">Passed</strong>), we can obtain further details.</p>
			<p>We just got some experience leveraging a container registry offered as a managed service. This could make our life easier, reducing our operational skills, but they are not always the best option for our projects or companies. </p>
			<p>In the next section, we will explore more in detail how to manage container images with Podman's companion Skopeo, and then we'll learn how to configure and run a container registry on-premises.</p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor178"/>Managing container images with Skopeo</h1>
			<p>So far, we have <a id="_idIndexMarker851"/>learned about many container registry<a id="_idIndexMarker852"/> concepts, including the differences between private and public registries, their compliance with OCI image specifications, and how to consume images with Podman and Buildah to build and run containers. </p>
			<p>However, sometimes we need to implement simple image manipulation tasks such as moving an image from a registry to a mirror, inspecting a remote image without the need to pull it locally, or even signing images. </p>
			<p>The community that gave birth <a id="_idIndexMarker853"/>to Podman and Buildah developed a third amazing tool, <strong class="bold">Skopeo</strong> (<a href="https://github.com/containers/skopeo">https://github.com/containers/skopeo</a>), which exactly implements the features described previously.</p>
			<p>Skopeo was designed as an image and registry manipulation tool for DevOps teams and is not intended to run containers (the main role of Podman) nor build OCI images (the main role of Buildah). Instead, it offers a minimal and straightforward command-line interface with basic image manipulation commands that will prove to be extremely useful in different contexts. </p>
			<p>Let's inspect the most interesting features in the next subsections.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor179"/>Installing Skopeo</h2>
			<p>Skopeo <a id="_idIndexMarker854"/>is a Go binary tool that is already packaged and available for many distributions. It can also be built and installed from source directly.</p>
			<p>This section provides a non-exhaustive list of installation examples on the major distributions. For the sake of clarity, it is important to reiterate that the book lab environments were all <a id="_idIndexMarker855"/>based on Fedora 34:</p>
			<ul>
				<li><strong class="bold">Fedora</strong>: To install Skopeo on Fedora, run the following <strong class="source-inline">dnf</strong> command:<p class="source-code">$ sudo dnf -y install skopeo</p></li>
				<li><strong class="bold">Debian</strong>: To install Skopeo on Debian Bullseye, Testing and Unstable (Sid), run the following <strong class="source-inline">apt-get</strong> commands:<p class="source-code">$ sudo apt-get update</p><p class="source-code">$ sudo apt-get -y install skopeo</p></li>
				<li><strong class="bold">RHEL 8/9, CentOS 8 and CentOS Stream 8/9</strong>: To install Skopeo on RHEL, CentOS, and CentOS Stream, run the following <strong class="source-inline">dnf</strong> command:<p class="source-code">$ sudo dnf -y install skopeo</p></li>
				<li><strong class="bold">RHEL 7 and CentOS 7</strong>: To install Skopeo on earlier releases of RHEL and CentOS, run the following <strong class="source-inline">yum</strong> command:<p class="source-code">$ sudo yum -y install skopeo</p></li>
				<li><strong class="bold">Ubuntu</strong>: To install Skopeo on Ubuntu 20.10 and newer, run the following command:<p class="source-code">$ sudo apt-get -y update</p><p class="source-code">$ sudo apt-get -y install skopeo</p></li>
				<li><strong class="bold">Arch Linux</strong>: To<a id="_idIndexMarker856"/> install Skopeo on Arch Linux, run the following <strong class="source-inline">pacman</strong> command: <p class="source-code">$ sudo pacman –S skopeo</p></li>
				<li><strong class="bold">openSUSE</strong>: To install Skopeo on openSUSE, run the following <strong class="source-inline">zypper</strong> command:<p class="source-code">$ sudo zypper install skopeo</p></li>
				<li><strong class="bold">macOS</strong>: To install Skopeo on macOS, run the following <strong class="source-inline">brew</strong> command:<p class="source-code">$ brew install skopeo</p></li>
				<li><strong class="bold">Building from source</strong>: Skopeo can also be built from source. As for Buildah, for the purposes of this book, we will keep the focus on simple deployment methods but if you're curious, you can find a dedicated install section in the main project repository that illustrates how to build Skopeo from source: <a href="https://github.com/containers/skopeo/blob/main/install.md#building-from-source">https://github.com/containers/skopeo/blob/main/install.md#building-from-source</a>.</li>
			</ul>
			<p>The preceding link shows examples of containerized and non-containerized builds.</p>
			<ul>
				<li><strong class="bold">Running Skopeo in a container</strong>: Skopeo is also released as a container image that can be executed with Podman. To pull and run the latest version of Skopeo as a container, use the following <strong class="source-inline">podman</strong> command:<p class="source-code">$ podman run quay.io/skopeo/stable:latest &lt;command&gt; &lt;options&gt;</p></li>
				<li><strong class="bold">Windows</strong>: At the<a id="_idIndexMarker857"/> time of writing of this book, there is no build available for Microsoft Windows.</li>
			</ul>
			<p>Skopeo uses the same system and local configuration files described for Podman and Buildah, therefore we can immediately focus on the installation verification and the analysis of the most common use cases.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor180"/>Verifying the installation</h2>
			<p>To verify the correct <a id="_idIndexMarker858"/>installation, simply run the <strong class="source-inline">skopeo</strong> command with the <strong class="source-inline">-h</strong> or <strong class="source-inline">--help</strong> option to view all available commands, as in the following example:</p>
			<p class="source-code">$ skopeo -h</p>
			<p>The expected output will show, among the utility options, all the available commands, each one with a description of the command scope. The full list of commands is as follows:</p>
			<ul>
				<li><strong class="source-inline">copy</strong>: Copy an image across locations, using different transports, such as the Docker Registry, local directories, OCI, tarballs, OSTree, and OCI archives.</li>
				<li><strong class="source-inline">delete</strong>: Delete an image from a target location.</li>
				<li><strong class="source-inline">help</strong>: Print help commands.</li>
				<li><strong class="source-inline">inspect</strong>: Inspect the metadata, tags, and configuration of an image in a target location.</li>
				<li><strong class="source-inline">list-tags</strong>: Shows the available tags for a specific image repository.</li>
				<li><strong class="source-inline">login</strong>: Authenticates to a remote registry.</li>
				<li><strong class="source-inline">logout</strong>: Log out from a remote registry.</li>
				<li><strong class="source-inline">manifest-digest</strong>: Produce a manifest digest for a file.</li>
				<li><strong class="source-inline">standalone-sign</strong>: A debugging tool to publish and sign an image using local files.</li>
				<li><strong class="source-inline">standalone-verify</strong>: Verify an image signature using local files.</li>
				<li><strong class="source-inline">sync</strong>: Synchronizes<a id="_idIndexMarker859"/> one or more images across locations.</li>
			</ul>
			<p>Let's now inspect in greater detail some of the most interesting Skopeo commands.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor181"/>Copying images across locations</h2>
			<p>Podman, just like <a id="_idIndexMarker860"/>Docker, can be used not only to run containers but also to pull images locally and push them to other locations. However, one of the main caveats is the need to run two commands, one to pull and one to push, while the local image store remains filled with the pulled images. Therefore, users should periodically clean up the local store.</p>
			<p>Skopeo offers a smarter and simpler way <a id="_idIndexMarker861"/>to achieve this goal with the <strong class="source-inline">skopeo copy</strong> command. The command implements the following syntax:</p>
			<p class="source-code">skopeo copy [command options] SOURCE-IMAGE DESTINATION-IMAGE</p>
			<p>In this generic description, <strong class="source-inline">SOURCE-IMAGE</strong> and <strong class="source-inline">DESTINATION-IMAGE</strong> are images belonging to local or remote locations and reachable using one of the following <strong class="bold">transports</strong>: </p>
			<ul>
				<li><strong class="source-inline">docker://docker-reference</strong>: This transport is related to images stored in registries implementing the <em class="italic">Docker Registry HTTP API V2</em>. </li>
			</ul>
			<p>This setting uses the <strong class="source-inline">/etc/containers/registries.conf</strong> or <strong class="source-inline">$HOME/.config/containers/registries.conf</strong> file to obtain further registry configurations. </p>
			<p>The <strong class="source-inline">docker-reference</strong> field follows the format <strong class="source-inline">name[:tag|@digest]</strong>.</p>
			<ul>
				<li><strong class="source-inline">containers-storage:[[storage-specifier]]{image-id|docker-reference[@image-id]}</strong>: This setting refers to an image in local container storage. </li>
			</ul>
			<p>The <strong class="source-inline">storage-specifier</strong> field is in the format <strong class="source-inline">[[driver@]root[+run-root][:options]]</strong>.</p>
			<ul>
				<li><strong class="source-inline">dir:path</strong>: This setting refers to an existing local directory that holds manifests, layers (in tarball format), and signatures.</li>
				<li><strong class="source-inline">docker-archive:path[:{docker-reference|@source-index}]</strong>: This setting refers to a Docker archive obtained with the <strong class="source-inline">docker save</strong> or <strong class="source-inline">podman save</strong> commands.</li>
				<li><strong class="source-inline">docker-daemon:docker-reference|algo:digest</strong>: This setting refers to image storage in the Docker daemon's internal storage.</li>
				<li><strong class="source-inline">oci:path[:tag]</strong>: This setting refers to an image stored in a local path compliant with the OCI layout specifications.</li>
				<li><strong class="source-inline">oci-archive:path[:tag]</strong>: This setting refers to an OCI layout specification compliant image stored in tarball format.</li>
				<li><strong class="source-inline">ostree:docker-reference[@/absolute/repo/path]</strong>: This setting refers to an image stored in a local <strong class="source-inline">ostree</strong> repository. OSTree is a tool to manage <a id="_idIndexMarker862"/>multiple versioned filesystem trees. It allows you to manage operating systems in an atomic and immutable way. Check out <strong class="source-inline">man ostree</strong> for more details. </li>
			</ul>
			<p>Let's inspect some usage examples of the <strong class="source-inline">skopeo copy</strong> command in real-world scenarios. The first example shows how to copy an image from a remote registry to another remote registry:</p>
			<p class="source-code">$ skopeo copy \</p>
			<p class="source-code">   docker://docker.io/library/nginx:latest \</p>
			<p class="source-code">   docker://private-registry.example.com/lab/nginx:latest</p>
			<p>The <a id="_idIndexMarker863"/>preceding example does not take care of registry authentication, which is usually a requirement to push images to the remote repository. In the next example, we show a variant where both source and target registry are decorated with authentication options:</p>
			<p class="source-code">$ skopeo copy \</p>
			<p class="source-code">   --src-creds USERNAME:PASSWORD \ </p>
			<p class="source-code">   --dest-creds USERNAME:PASSWORD \</p>
			<p class="source-code">   docker://registry1.example.com/mirror/nginx:latest \</p>
			<p class="source-code">   docker://registry2.example.com/lab/nginx:latest</p>
			<p>The previous approach, despite working perfectly, has the limitation of passing username and password strings as clear text strings. To avoid this, we can use the <strong class="source-inline">skopeo login</strong> command to authenticate<a id="_idIndexMarker864"/> to our registries before running <strong class="source-inline">skopeo copy</strong>.</p>
			<p>The third example shows a pre-authentication to the destination registry, assuming that the source registry is publicly accessible for pulls:</p>
			<p class="source-code">$ skopeo login private-registry.example.com</p>
			<p class="source-code">$ skopeo copy \</p>
			<p class="source-code">   docker://docker.io/library/nginx:latest \</p>
			<p class="source-code">   docker://private-registry.example.com/lab/nginx:latest</p>
			<p>When we log in to the source/target registries, the system persists the registry-provided auth tokens in dedicated auth files that we can reuse later for further access. </p>
			<p>By default, Skopeo looks at the <strong class="source-inline">${XDG_RUNTIME_DIR}/containers/auth.json</strong> path, but we can provide a custom location for the auth file. For example, in case we used Docker container runtime before, we could find it in the path <strong class="source-inline">${HOME}/.docker/config.json</strong>. This file contains a simple JSON object that holds, for every used registry, the token obtained upon authentication. The client (Podman, Skopeo, or Buildah) will use this token to directly access the registry.</p>
			<p>The following example shows the usage of the auth file, provided with a custom path:</p>
			<p class="source-code">$ skopeo copy \ </p>
			<p class="source-code">   --authfile ${HOME}/.docker/config.json \</p>
			<p class="source-code">   docker://docker.io/library/nginx:latest \</p>
			<p class="source-code">   docker://private-registry.example.com/lab/nginx:latest</p>
			<p>Another <a id="_idIndexMarker865"/>common issue that can be encountered when working with a private registry is the lack of certificates signed by a known <strong class="bold">certification authority</strong> (<strong class="bold">CA</strong>) or the <a id="_idIndexMarker866"/>lack of HTTPS communication (which means that all traffic is completely unencrypted). If we consider these totally non-secure scenarios safe to trust in a lab environment, we can skip the TLS verification with the <strong class="source-inline">--dest-tls-verify</strong> and <strong class="source-inline">--src-tls-verify</strong> options, which accept a simple Boolean value.</p>
			<p>The following example shows how to skip the TLS verification on the target registry:</p>
			<p class="source-code">$ skopeo copy \ </p>
			<p class="source-code">   --authfile ${HOME}/.docker/config.json \ </p>
			<p class="source-code">   --dest-tls-verify false \</p>
			<p class="source-code">   docker://docker.io/library/nginx:latest \</p>
			<p class="source-code">   docker://private-registry.example.com/lab/nginx:latest</p>
			<p>So far, we've seen how to move images across public and private registries, but we can use Skopeo to move images to and from local stores easily. For example, we can use Skopeo as a highly specialized push/pull tool for images inside our build pipelines.</p>
			<p>The next example shows how to push a locally built image to a public registry:</p>
			<p class="source-code">$ skopeo copy \</p>
			<p class="source-code">   --authfile ${HOME}/.docker/config.json \</p>
			<p class="source-code">   containers-storage:quay.io/&lt;namespace&gt;/python_httpd \</p>
			<p class="source-code">   docker://quay.io/&lt;namespace&gt;/python_httpd:latest</p>
			<p>This is an amazing way to manage an image push with total control over the push/pull process and shows how the three tools – Podman, Buildah, and Skopeo – can fulfill specialized tasks in our DevOps environment, each one accomplishing the purpose it was designed for at its best.</p>
			<p>Let's see another example, this time showing how to pull an image from a remote registry to an OCI-compliant local store:</p>
			<p class="source-code">$ skopeo copy \</p>
			<p class="source-code">   --authfile ${HOME}/.docker/config.json \</p>
			<p class="source-code">   docker://docker.io/library/nginx:latest \</p>
			<p class="source-code">   oci:/tmp/nginx</p>
			<p>The output folder<a id="_idIndexMarker867"/> is compliant with the OCI image specifications and will have the following structure (blob hashes cut for layout reasons):</p>
			<p class="source-code">$ tree /tmp/nginx</p>
			<p class="source-code">/tmp/nginx/</p>
			<p class="source-code">├─ blobs</p>
			<p class="source-code">│ └─sha256</p>
			<p class="source-code">│   ├──21e0df283cd68384e5e8dff7e6be1774c86ea3110c1b1e932[...]</p>
			<p class="source-code">│   ├──44be98c0fab60b6cef9887dbad59e69139cab789304964a19[...]</p>
			<p class="source-code">│   ├──77700c52c9695053293be96f9cbcf42c91c5e097daa382933[...]</p>
			<p class="source-code">│   ├──81d15e9a49818539edb3116c72fbad1df1241088116a7363a[...]</p>
			<p class="source-code">│   ├──881ff011f1c9c14982afc6e95ae70c25e38809843bb7d42ab[...]</p>
			<p class="source-code">│   ├──d86da3a6c06fb46bc76d6dc7b591e87a73cb456c990d814fd[...]</p>
			<p class="source-code">│   ├──e5ae68f740265288a4888db98d2999a638fdcb6d725f42767[...]</p>
			<p class="source-code">│   └──ed835de16acd8f5821cf3f3ef77a66922510ee6349730d89a[...]</p>
			<p class="source-code">├─ index.json</p>
			<p class="source-code">└─ oci-layout</p>
			<p>The files inside the <strong class="source-inline">blobs/sha256</strong> folder include the image manifest (in JSON format) and the image layers, as compressed tarballs.</p>
			<p>It's interesting to <a id="_idIndexMarker868"/>know that Podman can seamlessly run a container based on a local folder compliant with the OCI image specifications. The next example shows how to run an NGINX container from the previously downloaded image:</p>
			<p class="source-code">$ podman run -d oci:/tmp/nginx</p>
			<p class="source-code">Getting image source signatures</p>
			<p class="source-code">Copying blob e5ae68f74026 done  </p>
			<p class="source-code">Copying blob 21e0df283cd6 done  </p>
			<p class="source-code">Copying blob ed835de16acd done  </p>
			<p class="source-code">Copying blob 881ff011f1c9 done  </p>
			<p class="source-code">Copying blob 77700c52c969 done  </p>
			<p class="source-code">Copying blob 44be98c0fab6 done  </p>
			<p class="source-code">Copying config 81d15e9a49 done  </p>
			<p class="source-code">Writing manifest to image destination</p>
			<p class="source-code">Storing signatures</p>
			<p class="source-code">90493fe89f024cfffda3f626acb5ba8735cadd827be6c26fa44971108e09b54f</p>
			<p>Notice the <strong class="source-inline">oci:</strong> prefix before the image path, necessary to specify that the path provided is OCI compliant. </p>
			<p>Besides, it is interesting to show that Podman copies and extracts the blobs inside its local store (under <strong class="source-inline">$HOME/.local/share/containers/storage</strong> for a rootless container like the one in the example).</p>
			<p>After learning how to copy images with Skopeo, let's see how to inspect remote images without the need to pull them locally.</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor182"/>Inspecting remote images</h2>
			<p>Sometimes we need<a id="_idIndexMarker869"/> to verify the configurations, tags, or metadata of an image before pulling and executing it locally. For this purpose, Skopeo offers the <a id="_idIndexMarker870"/>useful <strong class="source-inline">skopeo inspect</strong> command to inspect images over supported transports.</p>
			<p>The first example shows how to inspect the official NGINX image repository:</p>
			<p class="source-code">$ skopeo inspect docker://docker.io/library/nginx</p>
			<p>The <strong class="source-inline">skopeo copy</strong> command<a id="_idIndexMarker871"/> creates a JSON-formatted output with the following fields:</p>
			<ul>
				<li><strong class="source-inline">Name</strong>: The name of the image repository.</li>
				<li><strong class="source-inline">Digest</strong>: The SHA256 calculated digest.</li>
				<li><strong class="source-inline">RepoTags</strong>: The full list of available image tags in the repository. This list will be empty when inspecting local transports such as <strong class="source-inline">containers-storage:</strong> or <strong class="source-inline">oci:</strong> since they will be referred to as a single image.</li>
				<li><strong class="source-inline">Created</strong>: The creation date of the repository or image.</li>
				<li><strong class="source-inline">DockerVersion</strong>: The version of Docker used to create the image. This value is empty for images created with Podman, Buildah, or other tools.</li>
				<li><strong class="source-inline">Labels</strong>: Additional labels applied to the image at build time.</li>
				<li><strong class="source-inline">Architecture</strong>: The target system architecture the image was built for. This value is <strong class="source-inline">amd64</strong> for x86-64 systems.</li>
				<li><strong class="source-inline">Os</strong>: The target operating system the image was built for.</li>
				<li><strong class="source-inline">Layers</strong>: The list of layers that compose the image, along with their SHA256 digest.</li>
				<li><strong class="source-inline">Env</strong>: Additional environment variables defined in the image at build time.</li>
			</ul>
			<p>The same considerations illustrated previously about authentication and TLS verification apply to <a id="_idIndexMarker872"/>the <strong class="source-inline">skopeo inspect</strong> command: it is possible to inspect images on a private registry upon authentication and skip the TLS verification. The next example shows this use case:</p>
			<p class="source-code">$ skopeo inspect \</p>
			<p class="source-code">   --authfile ${HOME}/.docker/config.json \ </p>
			<p class="source-code">   --tls-verify false \ </p>
			<p class="source-code">   registry.example.com/library/test-image</p>
			<p>Inspecting local images is possible by passing the correct transport. The next example shows how to inspect a local OCI image:</p>
			<p class="source-code">$ skopeo inspect oci:/tmp/custom_image </p>
			<p>The output of this command will have an empty <strong class="source-inline">RepoTags</strong> field.</p>
			<p>In addition, it is possible to use the <strong class="source-inline">--no-tags</strong> option to intentionally skip the repository tags, like in the following example:</p>
			<p class="source-code">$ skopeo inspect --no-tags docker://docker.io/library/nginx</p>
			<p>On the other <a id="_idIndexMarker873"/>hand, if we need to print only the available repository tags, we can use the <strong class="source-inline">skopeo list-tags</strong> command. The next example prints all the available tags of the official Nginx repository:</p>
			<p class="source-code">$ skopeo list-tags docker://docker.io/library/nginx</p>
			<p>The third use case we are going to analyze is the synchronization of images across registries and local stores.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor183"/>Synchronizing registries and local directories</h2>
			<p>When working <a id="_idIndexMarker874"/>with disconnected environments, a quite common <a id="_idIndexMarker875"/>scenario is the need to synchronize repositories from a remote registry locally. </p>
			<p>To serve this purpose, Skopeo introduced the <strong class="source-inline">skopeo sync</strong> command, which helps synchronize content between a source and destination, supporting different transport kinds.</p>
			<p>We can use this command to synchronize a whole repository, with all the available tags inside it, between a source and a destination. Alternatively, it is possible to synchronize only a specific image tag.</p>
			<p>The first example shows how to synchronize the official busybox repository from a private registry to the local filesystem. This command pulls all the tags contained in the remote repository to the local destination (the target directory must already exist):   </p>
			<p class="source-code">$ mkdir /tmp/images </p>
			<p class="source-code">$ skopeo sync \</p>
			<p class="source-code">  --src docker --dest dir \</p>
			<p class="source-code">  registry.example.com/lab/busybox /tmp/images</p>
			<p>Notice the use of the <strong class="source-inline">--src</strong> and <strong class="source-inline">--dest</strong> options to define the kind of transport. Supported transport types are as follows: </p>
			<ul>
				<li><em class="italic">Source</em>: <strong class="source-inline">docker</strong>, <strong class="source-inline">dir</strong>, and <strong class="source-inline">yaml</strong> (covered later in this section)</li>
				<li><em class="italic">Destination</em>: <strong class="source-inline">docker</strong> and <strong class="source-inline">dir</strong></li>
			</ul>
			<p>By default, Skopeo syncs the repository content to the destination without the whole image source path. This could represent a limitation when we need to sync repositories with the same name from multiple sources. To solve this limitation, we can add the <strong class="source-inline">--scoped</strong> option and get the full image source path copied in the destination tree.</p>
			<p>The second <a id="_idIndexMarker876"/>example shows a scoped synchronization<a id="_idIndexMarker877"/> of the busybox repository:</p>
			<p class="source-code">$ skopeo sync \</p>
			<p class="source-code">   --src docker --dest dir --scoped \</p>
			<p class="source-code">   registry.example.com/lab/busybox /tmp/images</p>
			<p>The resulting path in the destination directory will contain the registry name and the related namespace, with a new folder named after the image tag. </p>
			<p>The next example shows the directory structure of the destination after a successful synchronization:</p>
			<p class="source-code">ls -A1 /tmp/images/docker.io/library/</p>
			<p class="source-code">busybox:1</p>
			<p class="source-code">busybox:1.21.0-ubuntu</p>
			<p class="source-code">busybox:1.21-ubuntu</p>
			<p class="source-code">busybox:1.23</p>
			<p class="source-code">busybox:1.23.2</p>
			<p class="source-code">busybox:1-glibc</p>
			<p class="source-code">busybox:1-musl</p>
			<p class="source-code">busybox:1-ubuntu</p>
			<p class="source-code">busybox:1-uclibc</p>
			<p class="source-code">[...omitted output...]</p>
			<p>If we need to synchronize only a specific image tag, it is possible to specify the tag name in the source argument, like in this third example:</p>
			<p class="source-code">$ skopeo sync --src docker --dest dir docker.io/library/busybox:latest /tmp/images</p>
			<p>We can directly <a id="_idIndexMarker878"/>synchronize two registries using<a id="_idIndexMarker879"/> Docker both for the source and destination transport. This is especially useful in disconnected environments where systems are allowed to reach a local registry only. The local registry can mirror repositories from other public or private registries and the task can be scheduled periodically to keep the mirror updated. </p>
			<p>The next example shows how to synchronize the UBI8 image and all its tags from the public Red Hat repository to a local mirror registry: </p>
			<p class="source-code">$ skopeo sync \</p>
			<p class="source-code">   --src docker --dest docker \</p>
			<p class="source-code">   --dest-tls-verify=false \</p>
			<p class="source-code">   registry.access.redhat.com/ubi8 \</p>
			<p class="source-code">   mirror-registry.example.com</p>
			<p>The preceding command will mirror all the UBI8 image tags to the target registry. </p>
			<p>Notice the <strong class="source-inline">--dest-tls-verify=false</strong> option to disable TLS certificate checks on the destination.</p>
			<p>The <strong class="source-inline">skopeo sync</strong> command<a id="_idIndexMarker880"/> is great to mirror repositories and single images between locations but when it comes to mirroring full registries or a large set of repositories, we should run the command many times, passing different source arguments.</p>
			<p>To avoid this limitation, the source transport can be defined as a YAML file to include an exhaustive list of registries, repositories, and images. It is also possible to use regular expressions to capture only selected subsets of image tags.</p>
			<p>The following is an<a id="_idIndexMarker881"/> example of a custom YAML file that will <a id="_idIndexMarker882"/>be passed as a source argument to Skopeo:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Chapter09/example_sync.yaml</p>
			<p class="source-code">docker.io:</p>
			<p class="source-code">  tls-verify: true</p>
			<p class="source-code">  images: </p>
			<p class="source-code">    alpine: []</p>
			<p class="source-code">    nginx:</p>
			<p class="source-code">      - "latest"</p>
			<p class="source-code">  images-by-tag-regex:</p>
			<p class="source-code">    httpd: ^2\.4\.[0-9]*-alpine$</p>
			<p class="source-code">quay.io: </p>
			<p class="source-code">  tls-verify: true</p>
			<p class="source-code">  images:</p>
			<p class="source-code">    fedora/fedora:</p>
			<p class="source-code">      - latest</p>
			<p class="source-code">registry.access.redhat.com:</p>
			<p class="source-code">  tls-verify: true</p>
			<p class="source-code">  images:</p>
			<p class="source-code">    ubi8:</p>
			<p class="source-code">      - "8.4"</p>
			<p class="source-code">      - "8.5"</p>
			<p>In the preceding example, different images and repositories are defined and therefore the file content deserves a detailed description.</p>
			<p>The whole <strong class="source-inline">alpine</strong> repository is pulled from <strong class="source-inline">docker.io</strong>, along with the <strong class="source-inline">nginx:latest</strong> image tag. Also, a regular expression is used to define a pattern of tags for the <strong class="source-inline">httpd</strong> image, in order to pull Alpine-based image version 2.4.z only.</p>
			<p>The file also defines a specific tag (<strong class="source-inline">latest</strong>) for the <strong class="source-inline">fedora</strong> image stored under <a href="https://quay.io/">https://quay.io/</a> and the <strong class="source-inline">8.4</strong> and <strong class="source-inline">8.5</strong> tags for the <strong class="source-inline">ubi8</strong> image stored under the <strong class="source-inline">registry.access.redhat.com</strong> registry.</p>
			<p>Once defined, the file is passed as an argument to Skopeo, along with the destination:</p>
			<p class="source-code">$ skopeo sync \</p>
			<p class="source-code">  --src yaml --dest dir \</p>
			<p class="source-code">  --scoped example_sync.yaml /tmp/images</p>
			<p>All the contents<a id="_idIndexMarker883"/> listed in the <strong class="source-inline">example_sync.yaml</strong> file <a id="_idIndexMarker884"/>will be copied to the destination directory, following the previously mentioned filtering rules.</p>
			<p>The next example shows a larger mirroring use case, applied to the OpenShift release images. The following <strong class="source-inline">openshift_sync.yaml</strong> file defines a regular expression to sync all the images for version 4.9.z of OpenShift built for the x86_64 architecture:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Chapter09/openshift_sync.yaml</p>
			<p class="source-code">quay.io:</p>
			<p class="source-code">  tls-verify: true</p>
			<p class="source-code">  images-by-tag-regex:</p>
			<p class="source-code">    openshift-release-dev/ocp-release: ^4\.9\..*-x86_64$</p>
			<p>We can use this file to mirror a whole minor release of OpenShift to an internal registry accessible from disconnected environments and use this mirror to successfully conduct an air-gapped installation of OpenShift Container Platform. The next command example shows this use case:</p>
			<p class="source-code">$ skopeo sync \</p>
			<p class="source-code">  --src yaml --dest docker \</p>
			<p class="source-code">  --dest-tls-verify=false \</p>
			<p class="source-code">  --src-authfile pull_secret.json \</p>
			<p class="source-code">  openshift_sync.yaml mirror-registry.example.com:5000</p>
			<p>It is worth <a id="_idIndexMarker885"/>noticing the usage of a pull secret file, passed <a id="_idIndexMarker886"/>with the <strong class="source-inline">--src-authfile</strong> option, to authenticate on the Quay public registry and pull images from the <strong class="source-inline">ocp-release</strong> repository.</p>
			<p>There is a final Skopeo feature that captures our interest: the remote deletion of images, covered in the next subsection.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor184"/>Deleting images </h2>
			<p>A <a id="_idIndexMarker887"/>registry can be imagined as a specialized object store that implements a set of HTTP APIs to manipulate its content and push/pull objects in the form of image layers and metadata.</p>
			<p>The <strong class="bold">Docker Registry v2</strong> protocol<a id="_idIndexMarker888"/> is a standard API specification that is widely adopted among many registry projects. This set of API specifications covers all the registry functions that are expected to be exposed to an external client through standard HTTP <strong class="source-inline">GET</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">DELETE</strong>, <strong class="source-inline">POST</strong>, and <strong class="source-inline">PATCH</strong> methods.</p>
			<p>This means that we could interact with a registry with any kind of HTTP client capable of managing the requests correctly, for example, the <strong class="source-inline">curl</strong> command.</p>
			<p>Any container engine uses, at a lower level, HTTP client libraries to execute the various methods against the registry (for example, for an image pull).</p>
			<p>The Docker v2 protocol also supports the remote deletion of images, and any registry that implements this protocol supports the following <strong class="source-inline">DELETE</strong> request for images:</p>
			<p class="source-code"><strong class="bold">DELETE /v2/&lt;name&gt;/manifests/&lt;reference&gt;</strong></p>
			<p>The following example represents a theoretical delete command issued with the <strong class="source-inline">curl</strong> command against a local registry:</p>
			<p class="source-code">$ curl -v --silent \</p>
			<p class="source-code">   -H "Accept: application/vnd.docker.distribution.manifest.v2+json" \</p>
			<p class="source-code">   -X DELETE http://127.0.0.1:5000/v2/&lt;name&gt;/manifests/sha256:&lt;image_tag_digest&gt;</p>
			<p>The preceding example intentionally avoids including the management of authorization tokens for readability.</p>
			<p>Podman or Docker, designed to work as registry engines, do not implement a remote delete feature in their command interfaces. </p>
			<p>Fortunately, Skopeo <a id="_idIndexMarker889"/>comes to the rescue with its built-in <strong class="source-inline">skopeo delete</strong> command to manage remote image deletion with a simple and user-friendly syntax.</p>
			<p>The following example deletes an image on a hypothetical internal <strong class="source-inline">mirror-registry.example.com:5000</strong> registry:</p>
			<p class="source-code">$ skopeo delete \</p>
			<p class="source-code">  docker://mirror-registry.example.com:5000/foo:bar</p>
			<p>The command immediately deletes the image tag references in the remote registry.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">When deleting images with Skopeo, it is necessary to enable image deletion in the remote registry, as covered in the next section, <em class="italic">Running a local container registry</em>. </p>
			<p>In this section, we have learned how to use Skopeo to copy, delete, inspect, and sync images or even whole repositories across different transports, including private local registries, gaining control over daily image manipulation operations. </p>
			<p>In the next section, we will learn how to run and configure a local container registry to directly manage image storage in our lab or development environments.</p>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor185"/>Running a local container registry  </h1>
			<p>Most<a id="_idIndexMarker890"/> companies and organizations adopt enterprise-grade registries to rely on secure and resilient solutions for their container image storage. Most enterprise <a id="_idIndexMarker891"/>registries also offer advanced features such as <strong class="bold">role-based access control</strong> (<strong class="bold">RBAC</strong>), an image vulnerability scanner, mirroring, geo-replication, and high availability, becoming the default choice for production and mission-critical environments.</p>
			<p>However, sometimes it is very useful to run a simple local registry, for example, in development environments or training labs. Local registries can also be helpful in disconnected environments to mirror main public or private registries.</p>
			<p>This section aims to illustrate how to run a simple local registry and how to apply basic configuration settings.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor186"/>Running a containerized registry</h2>
			<p>Like <a id="_idIndexMarker892"/>every application, a local registry can be installed on the host by its administrators. Alternatively, a commonly preferred approach is to run the registry itself inside a container. </p>
			<p>The most used containerized registry solution is based on the official <strong class="bold">Docker Registry 2.0</strong> image, which offers all the necessary functionalities for a basic registry and is very easy to use.</p>
			<p>When running a local registry, containerized or not, we must define a destination directory to host all image layers and metadata. The next example shows the first execution of a containerized registry, with the <strong class="source-inline">/var/lib/registry</strong> folder created and bind-mounted to hold image data:</p>
			<p class="source-code"># mkdir /var/lib/registry</p>
			<p class="source-code"># podman run -d \</p>
			<p class="source-code">   --name local_registry \</p>
			<p class="source-code">   -p 5000:5000 \</p>
			<p class="source-code">   -v /var/lib/registry:/var/lib/registry:z \</p>
			<p class="source-code">   --restart=always registry:2</p>
			<p>The registry <a id="_idIndexMarker893"/>will be reachable at the host address on port <strong class="source-inline">5000/tcp</strong>, which is also the default port for this service. If we run the registry on our local workstation, it will be reachable at <strong class="source-inline">localhost:5000</strong>, and exposed to the external connection using the assigned IP address or its <strong class="bold">Fully Qualified Domain Name</strong> (<strong class="bold">FQDN</strong>) if the <a id="_idIndexMarker894"/>workstation/laptop is resolved by a local DNS service.</p>
			<p>For, example, if a host has the IP address <strong class="source-inline">10.10.2.30</strong> and FQDN <strong class="source-inline">registry.example.com</strong> correctly resolved by DNS queries, the registry service will be reachable at <strong class="source-inline">10.10.2.30:5000</strong> or at <strong class="source-inline">registry.example.com:5000</strong>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">If the host runs a local firewall service or is behind a corporate firewall, do not forget to open the correct ports to expose the registry externally.</p>
			<p>We can try to build and push a test image to the new registry. The following Containerfile builds a basic UBI-based httpd server:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Chapter09/local_registry/minimal_httpd/Containerfile</p>
			<p class="source-code">FROM registry.access.redhat.com/ubi8:latest</p>
			<p class="source-code">RUN dnf install -y httpd &amp;&amp; dnf clean all -y  </p>
			<p class="source-code">COPY index.html /var/www/html</p>
			<p class="source-code">RUN dnf install -y git &amp;&amp; dnf clean all -y  </p>
			<p class="source-code">CMD ["/usr/sbin/httpd", "-DFOREGROUND"]</p>
			<p>We can build the new image with Buildah:</p>
			<p class="source-code">$ buildah build -t minimal_httpd .</p>
			<p>To push the image to the local registry, we can use Podman or its companion tools Buildah or Skopeo. Skopeo is very handy for these use cases since we do not even need to scope the image name with the registry name. </p>
			<p>The next command shows how to push the new image on the registry:</p>
			<p class="source-code">$ skopeo copy --dest-tls-verify=false \</p>
			<p class="source-code">   containers-storage:localhost/minimal_httpd \</p>
			<p class="source-code">   docker://localhost:5000/minimal_httpd</p>
			<p>Notice the use of <strong class="source-inline">--dest-tls-verify=false</strong>: it was necessary since the local registry provides an HTTP transport by default.</p>
			<p>Despite being <a id="_idIndexMarker895"/>simple to implement, the default registry configuration has some limitations that must be addressed. To illustrate one of those limitations, let's try to delete the just uploaded image:</p>
			<p class="source-code">$ skopeo delete \</p>
			<p class="source-code">  --tls-verify=false \</p>
			<p class="source-code">  docker://localhost:5000/minimal_httpd</p>
			<p class="source-code">FATA[0000] Failed to delete /v2/minimal_httpd/manifests/sha256:f8c0c374cf124e728e20045f327de30ce1f3c552b307945de9b911cbee103522: {"errors":[{"code":"UNSUPPORTED","message":"The operation is unsupported."}]}</p>
			<p class="source-code">(405 Method Not Allowed)</p>
			<p>As we can see in the previous output, the registry did not allow us to delete the image, returning an <strong class="source-inline">HTTP 405</strong> error message. To alter this behavior, we need to edit the registry configuration.</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor187"/>Customizing the registry configuration</h2>
			<p>The<a id="_idIndexMarker896"/> registry configuration file <strong class="source-inline">/etc/docker/registry/config.yml</strong> can be modified to alter its behavior. The default content of this file is the following:</p>
			<p class="source-code">version: 0.1</p>
			<p class="source-code">log:</p>
			<p class="source-code">  fields:</p>
			<p class="source-code">    service: registry</p>
			<p class="source-code">storage:</p>
			<p class="source-code">  cache:</p>
			<p class="source-code">    blobdescriptor: inmemory</p>
			<p class="source-code">  filesystem:</p>
			<p class="source-code">    rootdirectory: /var/lib/registry</p>
			<p class="source-code">http:</p>
			<p class="source-code">  addr: :5000</p>
			<p class="source-code">  headers:</p>
			<p class="source-code">    X-Content-Type-Options: [nosniff]</p>
			<p class="source-code">health:</p>
			<p class="source-code">  storagedriver:</p>
			<p class="source-code">    enabled: true</p>
			<p class="source-code">    interval: 10s</p>
			<p class="source-code">    threshold: 3</p>
			<p>We soon <a id="_idIndexMarker897"/>realize that this is an extremely basic configuration with no authentication, no deletion of images allowed, and no TLS encryption. Our custom version will try to address those limitations.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The full documentation about the registry configuration has a wide range of options that we're not mentioning here since it is out of the scope of this book. More configuration options can be found at this link: <a href="https://docs.docker.com/registry/configuration/">https://docs.docker.com/registry/configuration/</a>.</p>
			<p>The following file contains a modified version of the registry <strong class="source-inline">config.yml</strong>: </p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Chapter09/local_registry/customizations/config.yml</p>
			<p class="source-code">version: 0.1</p>
			<p class="source-code">log: </p>
			<p class="source-code">  fields:</p>
			<p class="source-code">    service: registry</p>
			<p class="source-code">storage:</p>
			<p class="source-code">  cache:</p>
			<p class="source-code">    blobdescriptor: inmemory</p>
			<p class="source-code">  filesystem:</p>
			<p class="source-code">    rootdirectory: /var/lib/registry</p>
			<p class="source-code">  <strong class="bold">delete:</strong></p>
			<p class="source-code"><strong class="bold">    enabled: true</strong></p>
			<p class="source-code"><strong class="bold">auth:</strong> </p>
			<p class="source-code"><strong class="bold">  htpasswd:</strong></p>
			<p class="source-code"><strong class="bold">    realm: basic-realm</strong></p>
			<p class="source-code"><strong class="bold">    path: /var/lib/htpasswd</strong></p>
			<p class="source-code">http:</p>
			<p class="source-code">  addr: :5000</p>
			<p class="source-code">  headers:</p>
			<p class="source-code">    X-Content-Type-Options: [nosniff]</p>
			<p class="source-code">  <strong class="bold">tls:</strong></p>
			<p class="source-code"><strong class="bold">    certificate: /etc/pki/certs/tls.crt</strong></p>
			<p class="source-code"><strong class="bold">    key: /etc/pki/certs/tls.key</strong></p>
			<p class="source-code">health:</p>
			<p class="source-code">  storagedriver:</p>
			<p class="source-code">    enabled: true</p>
			<p class="source-code">    interval: 10s</p>
			<p class="source-code">    threshold: 3</p>
			<p>The highlighted sections in the previous example emphasize the added features:</p>
			<ul>
				<li><strong class="bold">Image deletion</strong>: By default, this setting is disabled.</li>
				<li><strong class="bold">Basic authentication</strong> using an <strong class="source-inline">htpasswd</strong> file. This approach is acceptable in a development and lab environment while a token-based authentication relying on an external issuer would be best suited for production use cases. </li>
				<li><strong class="bold">HTTPS transport</strong> using self-signed certificates.</li>
			</ul>
			<p>Before running <a id="_idIndexMarker898"/>the registry again with our custom configuration, we need to generate a <strong class="source-inline">htpasswd</strong> file that holds at least one valid login and the self-signed certificates for TLS encryption. Let's start with the <strong class="source-inline">htpasswd</strong> file – we can generate it using the <strong class="source-inline">htpasswd</strong> utility, like in the following example:</p>
			<p class="source-code">htpasswd -cBb ./htpasswd admin p0dman4Dev0ps#</p>
			<p>The <strong class="source-inline">-cBb</strong> option enables batch mode (useful to provide the password non-interactively), creates the file if it does not exist, and enables the <strong class="bold">bcrypt</strong> hashing function <em class="italic">[2]</em>. In this example, we <a id="_idIndexMarker899"/>create the user <strong class="source-inline">admin</strong> with the password <strong class="source-inline">p0dman4Dev0ps#</strong>.</p>
			<p>Finally, we need to create a self-signed server certificate with its related private key, to be used for HTTPS connections. As an example, a certificate associated with the <em class="italic">localhost</em> <strong class="bold">Common Name</strong> (<strong class="bold">CN</strong>) will <a id="_idIndexMarker900"/>be created. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Bounding certificates to the <em class="italic">localhost</em> CN is a frequent practice in development environments. However, if the registry is meant to be exposed externally, the <strong class="source-inline">CN</strong> and <strong class="source-inline">SubjectAltName</strong> fields should map to the host FQDN and alternate names.</p>
			<p>The following example shows how to create a self-signed certificate with the <strong class="source-inline">openssl</strong> utility:</p>
			<p class="source-code">$ mkdir certs </p>
			<p class="source-code">$ openssl req -newkey rsa:4096 -x509 -sha256 -nodes \ </p>
			<p class="source-code">  -days 365 \</p>
			<p class="source-code">  -out certs/tls.crt \</p>
			<p class="source-code">  -keyout certs/tls.key \</p>
			<p class="source-code">  -subj '/CN=localhost' \</p>
			<p class="source-code">  -addext "subjectAltName=DNS:localhost"</p>
			<p>The <a id="_idIndexMarker901"/>command will issue non-interactive certificate generation, without any extra information about the certificate subject. The private key <strong class="source-inline">tls.key</strong> is generated using a 4096-bit RSA algorithm. The certificate, named <strong class="source-inline">tls.crt</strong>, is set to expire after 1 year. Both the key and certificate are written inside the <strong class="source-inline">certs</strong> directory.</p>
			<p>To inspect the content of the generated certificate, we can run the following command:</p>
			<p class="source-code">$ openssl x509 -in certs/tls.crt -text -noout</p>
			<p>The command will produce a human-readable dump of the certificate data and validity.</p>
			<p class="callout-heading">Hint</p>
			<p class="callout">For the purpose of this example, the self-signed certificate is acceptable, but it should be avoided in production scenarios. </p>
			<p class="callout">Solutions such as <strong class="bold">Let's Encrypt</strong> provide a<a id="_idIndexMarker902"/> free CA service for everybody and can be used to reliably secure the registry or any other HTTPS service. For further details, visit <a href="https://letsencrypt.org/">https://letsencrypt.org/</a>.</p>
			<p>We now have all the requirements to run our custom registry. Before creating the new container, make sure the previous instance has been stopped and removed:</p>
			<p class="source-code"># podman stop local_registry &amp;&amp; podman rm local_registry</p>
			<p>The next command shows how to run the new custom registry using bind mounts to pass the certificates folder, the <strong class="source-inline">htpasswd</strong> file, the registry store, and, obviously, the custom config file:</p>
			<p class="source-code"># podman run -d --name local_registry \</p>
			<p class="source-code">   -p 5000:5000 \</p>
			<p class="source-code">   -v $PWD/htpasswd:/var/lib/htpasswd:z \</p>
			<p class="source-code">   -v $PWD/config.yml:/etc/docker/registry/config.yml:z \</p>
			<p class="source-code">   -v /var/lib/registry:/var/lib/registry:z \</p>
			<p class="source-code">   -v $PWD/certs:/etc/pki/certs:z \</p>
			<p class="source-code">   --restart=always \</p>
			<p class="source-code">   registry:2</p>
			<p>We can now test the login to the remote registry using the previously defined credentials:</p>
			<p class="source-code">$ skopeo login -u admin -p p0dman4Dev0ps# --tls-verify=false localhost:5000</p>
			<p class="source-code">Login Succeeded!</p>
			<p>Notice the <strong class="source-inline">--tls-verify=false</strong> option to skip TLS certificate validation. Since it is a self-signed certificate, we need to bypass checks that would produce the error message <em class="italic">x509: certificate signed by unknown authority</em>.</p>
			<p>We can try <a id="_idIndexMarker903"/>again to delete the image pushed before:</p>
			<p class="source-code">$ skopeo delete \</p>
			<p class="source-code">  --tls-verify=false \</p>
			<p class="source-code">  docker://localhost:5000/minimal_httpd</p>
			<p>This time, the command will succeed since the deletion feature was enabled in the config file.</p>
			<p>A local registry can be used to mirror images from an external public registry. In the next subsection, we will see an example of registry mirroring using our local registry and a selected set of repositories and images.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor188"/>Using a local registry to sync repositories </h2>
			<p>Mirroring<a id="_idIndexMarker904"/> images and repositories to a local registry<a id="_idIndexMarker905"/> can be very useful on disconnected environments. This can also be very useful to keep an async copy of selected images and be able to keep pulling them during public service outages.</p>
			<p>The next example shows simple mirroring using the <strong class="source-inline">skopeo sync</strong> command with a list of images provided by a YAML file and our local registry as the destination:</p>
			<p class="source-code">$ skopeo sync \</p>
			<p class="source-code">  --src yaml --dest docker \</p>
			<p class="source-code">  --dest-tls-verify=false \</p>
			<p class="source-code">  kube_sync.yaml localhost:5000</p>
			<p>The YAML file contains a list of the images that compose a Kubernetes control plane for a specific release. Again, we take advantage of regular expressions to customize the images to pull:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Chapter09/kube_sync.yaml</p>
			<p class="source-code">k8s.gcr.io: </p>
			<p class="source-code">  tls-verify: true </p>
			<p class="source-code">  images-by-tag-regex: </p>
			<p class="source-code">    kube-apiserver: ^v1\.22\..*</p>
			<p class="source-code">    kube-controller-manager: ^v1\.22\..*</p>
			<p class="source-code">    kube-proxy: ^v1\.22\..*</p>
			<p class="source-code">    kube-scheduler: ^v1\.22\..*</p>
			<p class="source-code">    coredns/coredns: ^v1\.8\..*</p>
			<p class="source-code">    etcd: 3\.4.[0-9]*-[0-9]*</p>
			<p>When <a id="_idIndexMarker906"/>synchronizing a remote and local registry, a<a id="_idIndexMarker907"/> lot of layers can be mirrored in the process. For this reason, it is important to monitor the storage used by the registry (<strong class="source-inline">/var/lib/registry</strong> in our example) to avoid filling up the filesystem.</p>
			<p>When the filesystem is filled, deleting older and unused images with Skopeo is not enough and an extra garbage collection action is necessary to free space. The next subsection illustrates this process.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor189"/>Managing registry garbage collection</h2>
			<p>When a delete<a id="_idIndexMarker908"/> command is issued on a container registry, it only deletes the image manifests that reference a set of blobs (which could be layers or further manifests), while keeping the blobs in the filesystem.</p>
			<p>If a blob is no longer referenced by any manifest, it can be eligible for garbage collection by the registry. The garbage collection process is managed with a dedicated command, <strong class="source-inline">registry garbage-collect</strong>, issued inside the registry container. This is not an automatic process and should be executed manually or scheduled.</p>
			<p>In the next example, we will run a simple garbage collection. The <strong class="source-inline">--dry-run</strong> flag only prints the eligible blobs that are no longer referenced by a manifest and thus they can be safely deleted:</p>
			<p class="source-code"># podman exec -it local_registry \</p>
			<p class="source-code">  registry garbage-collect --dry-run \</p>
			<p class="source-code">  /etc/docker/registry/config.yml</p>
			<p>To delete the blobs, simply remove the <strong class="source-inline">--dry-run</strong> option:</p>
			<p class="source-code"># podman exec -it local_registry \</p>
			<p class="source-code">  registry garbage-collect /etc/docker/registry/config.yml</p>
			<p>Garbage <a id="_idIndexMarker909"/>collection is helpful to keep the registry cleaned of unused blobs and save space. On the other hand, we must keep in mind that an unreferenced blob could still be reused in the future by another image. If deleted, it could be necessary to upload it again eventually.</p>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor190"/>Summary</h1>
			<p>In this chapter, we explored how to interact with container registries, which are the fundamental storage services for our images. We started with a high-level description of what a container registry is and how it works and interacts with our container engines and tools. We then moved on to a more detailed description of the differences between public, cloud-based registries and private registries, usually executed on-premises. It was especially useful to understand the benefits and limitations of both and to help us to understand the best approach for our needs.</p>
			<p>To manage container images on registries, we introduced the Skopeo tool, which is part of the Podman companion tools family, and illustrated how it can be used to copy, sync, delete, or simply inspect images over registries, giving users a higher degree of control over their images.</p>
			<p>Finally, we learned how to run a local containerized registry using the official community image of the Docker Registry v2. After showing a basic usage, we went deeper into more advanced configuration details by showing how to enable authentication, image deletion, and HTTPS encryption. The local registry proved to be useful to sync local images as well as remote registries. The registry garbage collection process was illustrated to keep things tidy inside the registry store.</p>
			<p>With the knowledge gained in this chapter, you will be able to manage images over registries and even local registry instances with a higher degree of awareness of what happens under the hood. Container registries are a crucial part of a successful container adoption strategy and should be understood very well: with this chapter's concepts in mind, you should also be able to understand and design the best fitting solutions and gain deep control over the tools to manipulate images.</p>
			<p>With this chapter, we have also completed the exploration of all the basic tasks related to container management. We can now move on to more advanced topics, such as container troubleshooting and monitoring, covered in the next chapter. </p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor191"/>Further reading</h1>
			<ul>
				<li>[1] <strong class="bold">Open Container Initiative</strong> (<strong class="bold">OCI</strong>) Distribution Specification: <a href="https://github.com/opencontainers/distribution-spec/blob/main/spec.md">https://github.com/opencontainers/distribution-spec/blob/main/spec.md</a> </li>
				<li>[2] Bcrypt description: <a href="https://en.wikipedia.org/wiki/Bcrypt">https://en.wikipedia.org/wiki/Bcrypt</a></li>
				<li>[3] Docker Registry v2 API specifications: <a href="https://docs.docker.com/registry/spec/api/">https://docs.docker.com/registry/spec/api/</a></li>
			</ul>
		</div>
	</body></html>