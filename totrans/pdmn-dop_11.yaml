- en: '*Chapter 9*: Pushing Images to a Container Registry'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we went through the very important concept of the container
    base image. As we saw, it is really important to choose the base image wisely
    for our containers, using official container images from trusted container registries
    and development communities.
  prefs: []
  type: TYPE_NORMAL
- en: But once we choose the preferred base image and then build our final container
    image, we need a way to further distribute our work to the various target hosts
    that we plan to let it run on.
  prefs: []
  type: TYPE_NORMAL
- en: The best option to distribute a container image is to push it to a container
    registry and after that, let all the target hosts pull the container image and
    run it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, in this chapter, we''re going to cover the following main
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a container registry?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud-based and on-premise container registries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing container images with Skopeo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a local container registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before proceeding with the chapter and its examples, a machine with a working
    Podman installation is required. As stated in [*Chapter 3*](B17908_03_epub.xhtml#_idTextAnchor068),
    *Running the First Container*, all the examples in the book are executed on a
    Fedora 34 system or later but can be reproduced on your OS of choice.
  prefs: []
  type: TYPE_NORMAL
- en: A good understanding of the topics covered in [*Chapter 4*](B17908_04_epub.xhtml#_idTextAnchor083),
    *Managing Running Containers*, and [*Chapter 8*](B17908_08_epub.xhtml#_idTextAnchor149),
    *Choosing the Container Base Image*, is useful to easily grasp concepts regarding
    container registries.
  prefs: []
  type: TYPE_NORMAL
- en: What is a container registry?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A container registry is just a collection of container images' repositories,
    used in conjunction with systems that need to pull and run container images in
    a dynamic way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main features available on a container registry are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Repository management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushing container images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tag management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pulling container images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at every feature in detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Repository management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most important features of container registries is managing container
    images through repositories. Depending on the container registry implementation
    that we choose, we will be sure to find a web interface or a command-line interface
    that will let us handle the creation of a sort of *folder* that will act as a
    repository for our container images.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the **Open Container Initiative** (**OCI**) Distribution Specification
    *[1]*, the container images are organized in a repository that is identified by
    name. A repository name is usually composed of a user/organization name and the
    container image name in this way: *myorganization/mycontainerimage*, and it must
    respect the following regular expression check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Important Definition
  prefs: []
  type: TYPE_NORMAL
- en: A **regular expression** (**regex**) is a search pattern defined by a sequence
    of characters. This pattern definition leverages several notations that let the
    user define in detail the target keyword, line, or multiple lines to find in a
    text document.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've created a repository on our container registry, we should be able
    to start pushing, pulling, and handling different versions (identified by a label)
    of our container images.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing container images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The act of pushing container images to a container registry is handled by the
    container tool that we are using, which respects the OCI Distribution Specification.
  prefs: []
  type: TYPE_NORMAL
- en: In this process, the blobs, which are the binary form of the content, are uploaded
    first and, usually at the end, the manifest is then uploaded. This order is not
    strict and mandatory by the specification, but a registry may refuse a manifest
    that references blobs that it does not know.
  prefs: []
  type: TYPE_NORMAL
- en: Using a container management tool to push a container image to a registry, we
    must specify again the name of the repository in the form shown before and the
    container image's tag we want to upload.
  prefs: []
  type: TYPE_NORMAL
- en: Tag management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we introduced starting in [*Chapter 4*](B17908_04_epub.xhtml#_idTextAnchor083),
    *Managing Running Containers*, the container images are identified by a name and
    a tag. Thanks to the tag mechanism, we can store several different versions of
    the container images on a system's local cache or on a container registry.
  prefs: []
  type: TYPE_NORMAL
- en: The container registry should be able to expose the feature of content discovery,
    providing the list of the container images' tags to the client requesting it.
    This feature can give the opportunity to the container registry's users to choose
    the right container image to pull and run to the target systems.
  prefs: []
  type: TYPE_NORMAL
- en: Pulling container images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the process of pulling container images, the client should first request
    the manifest to know which blobs, which are the binary form of the content, to
    pull to get the final container image. The order is strict because without pulling
    and parsing the manifest file of the container image, the client would not be
    able to know which binary data it has to request from the registry.
  prefs: []
  type: TYPE_NORMAL
- en: Using a container management tool to pull a container image from a registry,
    we must specify again the name of the repository in the form shown before and
    the container image's tag we want to download.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the previous operations may require authentication. In many cases, public
    container registries may allow anonymous pulling and content discovery but for
    pushing container images they require a valid authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the container registry chosen, we might find basic or advanced
    features to authenticate to a container registry, let our client store a token,
    and then use it for every operation that could require it.
  prefs: []
  type: TYPE_NORMAL
- en: This ends up our brief deep dive into container registry theory. If you want
    to know more about the OCI Distribution Specification, you can investigate the
    URL *[1]* available at the end of this chapter in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Nice to Know
  prefs: []
  type: TYPE_NORMAL
- en: 'The OCI Distribution Specification also defines a set of conformance tests
    that anyone could run against a container registry to check if that particular
    implementation respects all the rules defined in the specification: [https://github.com/opencontainers/distribution-spec/tree/main/conformance](https://github.com/opencontainers/distribution-spec/tree/main/conformance).'
  prefs: []
  type: TYPE_NORMAL
- en: The various implementations of a container registry available on the web, in
    addition to the basic functions we described before, also add more features that
    we will discover soon in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-based and on-premise container registries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we introduced in the previous sections, the OCI defined a standard to adhere
    to for container registries. This initiative allowed the rise of many other container
    registries apart from the initial Docker Registry and its online service, Docker
    Hub.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can group the available container registries into two main categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-based container registries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On-premise container registries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see these two categories in detail in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: On-premise container registries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On-premise container registries are often used for creating a private repository
    for enterprise purposes. The main use cases include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Distributing images in a private or isolated network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a new container image at a large scale over several machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping any sensitive data in our own data center
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the speed of pulling and pushing images using an internal network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, running an on-premise registry requires several skills to ensure
    availability, monitoring, logging, and security.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a non-comprehensive list of the available container registries that
    we can install on-premises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Registry**: Docker''s project, which is currently at version 2, provides
    all the basic features described in the earlier sections and we will learn how
    to run it in the last section of this chapter, *Running a local container registry*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Harbor**: This is a VMware open source project that provides high availability,
    image auditing, and integration with authentication systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitLab Container Registry**: This is strongly integrated with the GitLab
    product, so it requires minimal setup, but it depends on the main project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JFrog Artifactory**: This manages more than just containers; it provides
    management for any artifact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quay**: This is the open source distribution of the Red Hat product called
    Quay. This project offers a fully-featured web UI, a service for image vulnerability
    scanning, data storage, and protection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will not go into every detail of these container registries. What we can
    suggest for sure is to pay attention and choose the product or project that fits
    better with your use cases and support needs. Many of these products have support
    plans or enterprise editions (license required) that could easily save your skin
    in the event of a disaster.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now see what the cloud-based container registries are that could make
    our life easier, offering a complete managed service, with which our operational
    skills could be reduced to zero.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-based container registries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As anticipated in the previous section, cloud-based container registries could
    be the fastest way to start working with container images through a registry.
  prefs: []
  type: TYPE_NORMAL
- en: As described in [*Chapter 8*](B17908_08_epub.xhtml#_idTextAnchor149), *Choosing
    the Container Base Image*, there are several cloud-based container registry services
    on the web. We will concentrate only on a small subset, taking out of the analysis
    the ones provided by a public cloud provider and the ones offered by the Linux
    distribution, which usually are only available to pull images, preloaded by the
    distribution maintainers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will take a look at these cloud container registries:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Hub**: This is a hosted registry solution by Docker Inc. This registry
    also hosts official repositories and security verified images for some popular
    open source projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quay**: This is the hosted registry solution born under the CoreOS company,
    now part of Red Hat. It offers private and public repositories, automated scanning
    for security purposes, image builds, and integration with popular Git public repositories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Hub cloud registry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docker Hub cloud registry was born together with the Docker project and it represented
    one of the greatest features added to this project and containers in general,
    the right attention they deserved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Talking about features, Docker Hub has free and paid plans:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Anonymous access: Only 100 image pulls in 6 hours.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A registered user account with the free tier: 200 image pulls in 6 hours and
    unlimited public repositories. With the free tier we do not get builds or security
    scans.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pro, Team, and Business accounts: Thousands of image pulls per day, automated
    builds, security scans, RBAC, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we just reported, if we try to log in with a registered user account with
    the free tier, we can only create public repositories. This could be enough for
    communities or individual developers, but once you start using it at the enterprise
    level, you may need the additional features provided by the paid plans.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid a big limitation in terms of image pulls, we should at least use a
    registered user account and log in to the web portal and to the container registry
    with our beloved container engine: Podman. We will see in the following sections
    how to authenticate to a registry and ensure 200 image pulls every 6 hours using
    Docker Hub.'
  prefs: []
  type: TYPE_NORMAL
- en: Red Hat Quay cloud registry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Quay cloud registry is the Red Hat on-premise registry but offered as **Software-as-a-Service**
    (**SaaS**).
  prefs: []
  type: TYPE_NORMAL
- en: Quay cloud registry, like Docker Hub, offers paid plans as well to unlock additional
    features.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the nice news is that Quay''s free tier has a lot of features included:'
  prefs: []
  type: TYPE_NORMAL
- en: Build from a Dockerfile, manually uploaded or even linked through GitHub/Bitbucket/Gitlab
    or any Git repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security scans for images pushed on the registry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage/auditing logs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Robot user account/tokens for integrating any external software.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no limit on image pulls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, the paid plans will unlock private repositories and team-based
    permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the Quay cloud registry by creating a public repository and
    linking it to a GitHub repository in which we pushed a Dockerfile to build our
    target container image:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to register or log in to the Quay portal at [https://quay.io](https://quay.io).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, we can click on the **+ Create New Repository** button in the upper-right
    corner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17908_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Quay Create New Repository button
  prefs: []
  type: TYPE_NORMAL
- en: 'Once done, the web portal will request some basic information about the new
    repository we want to create:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A name
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A description
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Public or private (we are using a free account, so public is fine)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to initialize the repository:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B17908_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Create New Repository page
  prefs: []
  type: TYPE_NORMAL
- en: We just defined a name for our repo, `ubi8-httpd`, and we chose to link this
    repository to a GitHub repository push.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once confirmed, the Quay registry cloud portal will redirect us to GitHub to
    allow the authorization and then it will ask us to select the right organization
    and GitHub repository to link with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17908_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Select the GitHub repository to link with our container repo
  prefs: []
  type: TYPE_NORMAL
- en: 'We just selected the default organization and the Git repository we created
    holding our Dockerfile. The Git repository is named `ubi8-httpd` and it is available
    here: [https://github.com/alezzandro/ubi8-httpd](https://github.com/alezzandro/ubi8-httpd).'
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The repository used in this example belongs to the author's own project. You
    can fork the repository on GitHub and make your own copy with read/write permissions
    in order to be able to make changes and experiment with commits and automated
    builds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, it will ask us to further configure the trigger:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17908_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Build trigger customization
  prefs: []
  type: TYPE_NORMAL
- en: We just left the default option, which will trigger a new build every time a
    push is made on the Git repository for any branches and tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once done, we will be redirected to the main repository page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17908_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Main repository page
  prefs: []
  type: TYPE_NORMAL
- en: Once created, the repository is empty with no information or activity, of course.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the left bar, we can easily access the build section. It''s the fourth icon
    starting from the top. In the following figure, we just executed two pushes on
    our Git repository, which triggered two different builds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17908_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Container image build section
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try clicking on one of the builds, the cloud registry will show the details
    of the build:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17908_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Container image build details
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the build worked as expected, connecting to the GitHub repository,
    downloading the Dockerfile and executing the build, and finally, pushing the image
    to the container registry, all in an automated way. The Dockerfile contains just
    a few commands for installing an httpd server on a UBI8 base image, as we learned
    in [*Chapter 8*](B17908_08_epub.xhtml#_idTextAnchor149), *Choosing the Container
    Base Image*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the last section that is worth mentioning is the included security
    scanning functionality. This feature is accessible by clicking the *Tag* icon,
    the second from the top in the left panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17908_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Container image tags page
  prefs: []
  type: TYPE_NORMAL
- en: As you will notice, there is a `SECURITY SCAN` column (the third) reporting
    the status of the scan executed on that particular container image associated
    with the tag name reported in the first column. By clicking on the value of that
    column (in the previous screenshot, it is `Passed`), we can obtain further details.
  prefs: []
  type: TYPE_NORMAL
- en: We just got some experience leveraging a container registry offered as a managed
    service. This could make our life easier, reducing our operational skills, but
    they are not always the best option for our projects or companies.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore more in detail how to manage container
    images with Podman's companion Skopeo, and then we'll learn how to configure and
    run a container registry on-premises.
  prefs: []
  type: TYPE_NORMAL
- en: Managing container images with Skopeo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned about many container registry concepts, including the
    differences between private and public registries, their compliance with OCI image
    specifications, and how to consume images with Podman and Buildah to build and
    run containers.
  prefs: []
  type: TYPE_NORMAL
- en: However, sometimes we need to implement simple image manipulation tasks such
    as moving an image from a registry to a mirror, inspecting a remote image without
    the need to pull it locally, or even signing images.
  prefs: []
  type: TYPE_NORMAL
- en: The community that gave birth to Podman and Buildah developed a third amazing
    tool, **Skopeo** ([https://github.com/containers/skopeo](https://github.com/containers/skopeo)),
    which exactly implements the features described previously.
  prefs: []
  type: TYPE_NORMAL
- en: Skopeo was designed as an image and registry manipulation tool for DevOps teams
    and is not intended to run containers (the main role of Podman) nor build OCI
    images (the main role of Buildah). Instead, it offers a minimal and straightforward
    command-line interface with basic image manipulation commands that will prove
    to be extremely useful in different contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Let's inspect the most interesting features in the next subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Skopeo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Skopeo is a Go binary tool that is already packaged and available for many distributions.
    It can also be built and installed from source directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section provides a non-exhaustive list of installation examples on the
    major distributions. For the sake of clarity, it is important to reiterate that
    the book lab environments were all based on Fedora 34:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dnf` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`apt-get` commands:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`dnf` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`yum` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Ubuntu**: To install Skopeo on Ubuntu 20.10 and newer, run the following
    command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`pacman` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`zypper` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`brew` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Building from source**: Skopeo can also be built from source. As for Buildah,
    for the purposes of this book, we will keep the focus on simple deployment methods
    but if you''re curious, you can find a dedicated install section in the main project
    repository that illustrates how to build Skopeo from source: [https://github.com/containers/skopeo/blob/main/install.md#building-from-source](https://github.com/containers/skopeo/blob/main/install.md#building-from-source).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding link shows examples of containerized and non-containerized builds.
  prefs: []
  type: TYPE_NORMAL
- en: '`podman` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Windows**: At the time of writing of this book, there is no build available
    for Microsoft Windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skopeo uses the same system and local configuration files described for Podman
    and Buildah, therefore we can immediately focus on the installation verification
    and the analysis of the most common use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To verify the correct installation, simply run the `skopeo` command with the
    `-h` or `--help` option to view all available commands, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected output will show, among the utility options, all the available
    commands, each one with a description of the command scope. The full list of commands
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`copy`: Copy an image across locations, using different transports, such as
    the Docker Registry, local directories, OCI, tarballs, OSTree, and OCI archives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete`: Delete an image from a target location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`help`: Print help commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inspect`: Inspect the metadata, tags, and configuration of an image in a target
    location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list-tags`: Shows the available tags for a specific image repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`login`: Authenticates to a remote registry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logout`: Log out from a remote registry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`manifest-digest`: Produce a manifest digest for a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`standalone-sign`: A debugging tool to publish and sign an image using local
    files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`standalone-verify`: Verify an image signature using local files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sync`: Synchronizes one or more images across locations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now inspect in greater detail some of the most interesting Skopeo commands.
  prefs: []
  type: TYPE_NORMAL
- en: Copying images across locations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Podman, just like Docker, can be used not only to run containers but also to
    pull images locally and push them to other locations. However, one of the main
    caveats is the need to run two commands, one to pull and one to push, while the
    local image store remains filled with the pulled images. Therefore, users should
    periodically clean up the local store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Skopeo offers a smarter and simpler way to achieve this goal with the `skopeo
    copy` command. The command implements the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this generic description, `SOURCE-IMAGE` and `DESTINATION-IMAGE` are images
    belonging to local or remote locations and reachable using one of the following
    **transports**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker://docker-reference`: This transport is related to images stored in
    registries implementing the *Docker Registry HTTP API V2*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This setting uses the `/etc/containers/registries.conf` or `$HOME/.config/containers/registries.conf`
    file to obtain further registry configurations.
  prefs: []
  type: TYPE_NORMAL
- en: The `docker-reference` field follows the format `name[:tag|@digest]`.
  prefs: []
  type: TYPE_NORMAL
- en: '`containers-storage:[[storage-specifier]]{image-id|docker-reference[@image-id]}`:
    This setting refers to an image in local container storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `storage-specifier` field is in the format `[[driver@]root[+run-root][:options]]`.
  prefs: []
  type: TYPE_NORMAL
- en: '`dir:path`: This setting refers to an existing local directory that holds manifests,
    layers (in tarball format), and signatures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-archive:path[:{docker-reference|@source-index}]`: This setting refers
    to a Docker archive obtained with the `docker save` or `podman save` commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-daemon:docker-reference|algo:digest`: This setting refers to image
    storage in the Docker daemon''s internal storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oci:path[:tag]`: This setting refers to an image stored in a local path compliant
    with the OCI layout specifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oci-archive:path[:tag]`: This setting refers to an OCI layout specification
    compliant image stored in tarball format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ostree:docker-reference[@/absolute/repo/path]`: This setting refers to an
    image stored in a local `ostree` repository. OSTree is a tool to manage multiple
    versioned filesystem trees. It allows you to manage operating systems in an atomic
    and immutable way. Check out `man ostree` for more details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s inspect some usage examples of the `skopeo copy` command in real-world
    scenarios. The first example shows how to copy an image from a remote registry
    to another remote registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example does not take care of registry authentication, which
    is usually a requirement to push images to the remote repository. In the next
    example, we show a variant where both source and target registry are decorated
    with authentication options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The previous approach, despite working perfectly, has the limitation of passing
    username and password strings as clear text strings. To avoid this, we can use
    the `skopeo login` command to authenticate to our registries before running `skopeo
    copy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third example shows a pre-authentication to the destination registry, assuming
    that the source registry is publicly accessible for pulls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When we log in to the source/target registries, the system persists the registry-provided
    auth tokens in dedicated auth files that we can reuse later for further access.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Skopeo looks at the `${XDG_RUNTIME_DIR}/containers/auth.json` path,
    but we can provide a custom location for the auth file. For example, in case we
    used Docker container runtime before, we could find it in the path `${HOME}/.docker/config.json`.
    This file contains a simple JSON object that holds, for every used registry, the
    token obtained upon authentication. The client (Podman, Skopeo, or Buildah) will
    use this token to directly access the registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the usage of the auth file, provided with a custom
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Another common issue that can be encountered when working with a private registry
    is the lack of certificates signed by a known `--dest-tls-verify` and `--src-tls-verify`
    options, which accept a simple Boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to skip the TLS verification on the target
    registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So far, we've seen how to move images across public and private registries,
    but we can use Skopeo to move images to and from local stores easily. For example,
    we can use Skopeo as a highly specialized push/pull tool for images inside our
    build pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example shows how to push a locally built image to a public registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is an amazing way to manage an image push with total control over the push/pull
    process and shows how the three tools – Podman, Buildah, and Skopeo – can fulfill
    specialized tasks in our DevOps environment, each one accomplishing the purpose
    it was designed for at its best.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see another example, this time showing how to pull an image from a remote
    registry to an OCI-compliant local store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output folder is compliant with the OCI image specifications and will have
    the following structure (blob hashes cut for layout reasons):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The files inside the `blobs/sha256` folder include the image manifest (in JSON
    format) and the image layers, as compressed tarballs.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s interesting to know that Podman can seamlessly run a container based
    on a local folder compliant with the OCI image specifications. The next example
    shows how to run an NGINX container from the previously downloaded image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `oci:` prefix before the image path, necessary to specify that the
    path provided is OCI compliant.
  prefs: []
  type: TYPE_NORMAL
- en: Besides, it is interesting to show that Podman copies and extracts the blobs
    inside its local store (under `$HOME/.local/share/containers/storage` for a rootless
    container like the one in the example).
  prefs: []
  type: TYPE_NORMAL
- en: After learning how to copy images with Skopeo, let's see how to inspect remote
    images without the need to pull them locally.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting remote images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes we need to verify the configurations, tags, or metadata of an image
    before pulling and executing it locally. For this purpose, Skopeo offers the useful
    `skopeo inspect` command to inspect images over supported transports.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first example shows how to inspect the official NGINX image repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `skopeo copy` command creates a JSON-formatted output with the following
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Name`: The name of the image repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Digest`: The SHA256 calculated digest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RepoTags`: The full list of available image tags in the repository. This list
    will be empty when inspecting local transports such as `containers-storage:` or
    `oci:` since they will be referred to as a single image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Created`: The creation date of the repository or image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DockerVersion`: The version of Docker used to create the image. This value
    is empty for images created with Podman, Buildah, or other tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Labels`: Additional labels applied to the image at build time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Architecture`: The target system architecture the image was built for. This
    value is `amd64` for x86-64 systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Os`: The target operating system the image was built for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Layers`: The list of layers that compose the image, along with their SHA256
    digest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Env`: Additional environment variables defined in the image at build time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The same considerations illustrated previously about authentication and TLS
    verification apply to the `skopeo inspect` command: it is possible to inspect
    images on a private registry upon authentication and skip the TLS verification.
    The next example shows this use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspecting local images is possible by passing the correct transport. The next
    example shows how to inspect a local OCI image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The output of this command will have an empty `RepoTags` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, it is possible to use the `--no-tags` option to intentionally
    skip the repository tags, like in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if we need to print only the available repository tags,
    we can use the `skopeo list-tags` command. The next example prints all the available
    tags of the official Nginx repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The third use case we are going to analyze is the synchronization of images
    across registries and local stores.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing registries and local directories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with disconnected environments, a quite common scenario is the
    need to synchronize repositories from a remote registry locally.
  prefs: []
  type: TYPE_NORMAL
- en: To serve this purpose, Skopeo introduced the `skopeo sync` command, which helps
    synchronize content between a source and destination, supporting different transport
    kinds.
  prefs: []
  type: TYPE_NORMAL
- en: We can use this command to synchronize a whole repository, with all the available
    tags inside it, between a source and a destination. Alternatively, it is possible
    to synchronize only a specific image tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first example shows how to synchronize the official busybox repository
    from a private registry to the local filesystem. This command pulls all the tags
    contained in the remote repository to the local destination (the target directory
    must already exist):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the use of the `--src` and `--dest` options to define the kind of transport.
    Supported transport types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Source*: `docker`, `dir`, and `yaml` (covered later in this section)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Destination*: `docker` and `dir`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, Skopeo syncs the repository content to the destination without the
    whole image source path. This could represent a limitation when we need to sync
    repositories with the same name from multiple sources. To solve this limitation,
    we can add the `--scoped` option and get the full image source path copied in
    the destination tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second example shows a scoped synchronization of the busybox repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The resulting path in the destination directory will contain the registry name
    and the related namespace, with a new folder named after the image tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example shows the directory structure of the destination after a successful
    synchronization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to synchronize only a specific image tag, it is possible to specify
    the tag name in the source argument, like in this third example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We can directly synchronize two registries using Docker both for the source
    and destination transport. This is especially useful in disconnected environments
    where systems are allowed to reach a local registry only. The local registry can
    mirror repositories from other public or private registries and the task can be
    scheduled periodically to keep the mirror updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example shows how to synchronize the UBI8 image and all its tags from
    the public Red Hat repository to a local mirror registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will mirror all the UBI8 image tags to the target registry.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the `--dest-tls-verify=false` option to disable TLS certificate checks
    on the destination.
  prefs: []
  type: TYPE_NORMAL
- en: The `skopeo sync` command is great to mirror repositories and single images
    between locations but when it comes to mirroring full registries or a large set
    of repositories, we should run the command many times, passing different source
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this limitation, the source transport can be defined as a YAML file
    to include an exhaustive list of registries, repositories, and images. It is also
    possible to use regular expressions to capture only selected subsets of image
    tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a custom YAML file that will be passed as a
    source argument to Skopeo:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter09/example_sync.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, different images and repositories are defined and
    therefore the file content deserves a detailed description.
  prefs: []
  type: TYPE_NORMAL
- en: The whole `alpine` repository is pulled from `docker.io`, along with the `nginx:latest`
    image tag. Also, a regular expression is used to define a pattern of tags for
    the `httpd` image, in order to pull Alpine-based image version 2.4.z only.
  prefs: []
  type: TYPE_NORMAL
- en: The file also defines a specific tag (`latest`) for the `fedora` image stored
    under [https://quay.io/](https://quay.io/) and the `8.4` and `8.5` tags for the
    `ubi8` image stored under the `registry.access.redhat.com` registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once defined, the file is passed as an argument to Skopeo, along with the destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: All the contents listed in the `example_sync.yaml` file will be copied to the
    destination directory, following the previously mentioned filtering rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example shows a larger mirroring use case, applied to the OpenShift
    release images. The following `openshift_sync.yaml` file defines a regular expression
    to sync all the images for version 4.9.z of OpenShift built for the x86_64 architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter09/openshift_sync.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this file to mirror a whole minor release of OpenShift to an internal
    registry accessible from disconnected environments and use this mirror to successfully
    conduct an air-gapped installation of OpenShift Container Platform. The next command
    example shows this use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It is worth noticing the usage of a pull secret file, passed with the `--src-authfile`
    option, to authenticate on the Quay public registry and pull images from the `ocp-release`
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a final Skopeo feature that captures our interest: the remote deletion
    of images, covered in the next subsection.'
  prefs: []
  type: TYPE_NORMAL
- en: Deleting images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A registry can be imagined as a specialized object store that implements a set
    of HTTP APIs to manipulate its content and push/pull objects in the form of image
    layers and metadata.
  prefs: []
  type: TYPE_NORMAL
- en: The `GET`, `PUT`, `DELETE`, `POST`, and `PATCH` methods.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we could interact with a registry with any kind of HTTP client
    capable of managing the requests correctly, for example, the `curl` command.
  prefs: []
  type: TYPE_NORMAL
- en: Any container engine uses, at a lower level, HTTP client libraries to execute
    the various methods against the registry (for example, for an image pull).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker v2 protocol also supports the remote deletion of images, and any
    registry that implements this protocol supports the following `DELETE` request
    for images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example represents a theoretical delete command issued with the
    `curl` command against a local registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example intentionally avoids including the management of authorization
    tokens for readability.
  prefs: []
  type: TYPE_NORMAL
- en: Podman or Docker, designed to work as registry engines, do not implement a remote
    delete feature in their command interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Skopeo comes to the rescue with its built-in `skopeo delete` command
    to manage remote image deletion with a simple and user-friendly syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example deletes an image on a hypothetical internal `mirror-registry.example.com:5000`
    registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The command immediately deletes the image tag references in the remote registry.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: When deleting images with Skopeo, it is necessary to enable image deletion in
    the remote registry, as covered in the next section, *Running a local container
    registry*.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned how to use Skopeo to copy, delete, inspect,
    and sync images or even whole repositories across different transports, including
    private local registries, gaining control over daily image manipulation operations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to run and configure a local container
    registry to directly manage image storage in our lab or development environments.
  prefs: []
  type: TYPE_NORMAL
- en: Running a local container registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most companies and organizations adopt enterprise-grade registries to rely on
    secure and resilient solutions for their container image storage. Most enterprise
    registries also offer advanced features such as **role-based access control**
    (**RBAC**), an image vulnerability scanner, mirroring, geo-replication, and high
    availability, becoming the default choice for production and mission-critical
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: However, sometimes it is very useful to run a simple local registry, for example,
    in development environments or training labs. Local registries can also be helpful
    in disconnected environments to mirror main public or private registries.
  prefs: []
  type: TYPE_NORMAL
- en: This section aims to illustrate how to run a simple local registry and how to
    apply basic configuration settings.
  prefs: []
  type: TYPE_NORMAL
- en: Running a containerized registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like every application, a local registry can be installed on the host by its
    administrators. Alternatively, a commonly preferred approach is to run the registry
    itself inside a container.
  prefs: []
  type: TYPE_NORMAL
- en: The most used containerized registry solution is based on the official **Docker
    Registry 2.0** image, which offers all the necessary functionalities for a basic
    registry and is very easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running a local registry, containerized or not, we must define a destination
    directory to host all image layers and metadata. The next example shows the first
    execution of a containerized registry, with the `/var/lib/registry` folder created
    and bind-mounted to hold image data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The registry will be reachable at the host address on port `5000/tcp`, which
    is also the default port for this service. If we run the registry on our local
    workstation, it will be reachable at `localhost:5000`, and exposed to the external
    connection using the assigned IP address or its **Fully Qualified Domain Name**
    (**FQDN**) if the workstation/laptop is resolved by a local DNS service.
  prefs: []
  type: TYPE_NORMAL
- en: For, example, if a host has the IP address `10.10.2.30` and FQDN `registry.example.com`
    correctly resolved by DNS queries, the registry service will be reachable at `10.10.2.30:5000`
    or at `registry.example.com:5000`.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: If the host runs a local firewall service or is behind a corporate firewall,
    do not forget to open the correct ports to expose the registry externally.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can try to build and push a test image to the new registry. The following
    Containerfile builds a basic UBI-based httpd server:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter09/local_registry/minimal_httpd/Containerfile
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can build the new image with Buildah:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: To push the image to the local registry, we can use Podman or its companion
    tools Buildah or Skopeo. Skopeo is very handy for these use cases since we do
    not even need to scope the image name with the registry name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next command shows how to push the new image on the registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the use of `--dest-tls-verify=false`: it was necessary since the local
    registry provides an HTTP transport by default.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite being simple to implement, the default registry configuration has some
    limitations that must be addressed. To illustrate one of those limitations, let''s
    try to delete the just uploaded image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the previous output, the registry did not allow us to delete
    the image, returning an `HTTP 405` error message. To alter this behavior, we need
    to edit the registry configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the registry configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The registry configuration file `/etc/docker/registry/config.yml` can be modified
    to alter its behavior. The default content of this file is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We soon realize that this is an extremely basic configuration with no authentication,
    no deletion of images allowed, and no TLS encryption. Our custom version will
    try to address those limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The full documentation about the registry configuration has a wide range of
    options that we''re not mentioning here since it is out of the scope of this book.
    More configuration options can be found at this link: [https://docs.docker.com/registry/configuration/](https://docs.docker.com/registry/configuration/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following file contains a modified version of the registry `config.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter09/local_registry/customizations/config.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted sections in the previous example emphasize the added features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Image deletion**: By default, this setting is disabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`htpasswd` file. This approach is acceptable in a development and lab environment
    while a token-based authentication relying on an external issuer would be best
    suited for production use cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTPS transport** using self-signed certificates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before running the registry again with our custom configuration, we need to
    generate a `htpasswd` file that holds at least one valid login and the self-signed
    certificates for TLS encryption. Let''s start with the `htpasswd` file – we can
    generate it using the `htpasswd` utility, like in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `-cBb` option enables batch mode (useful to provide the password non-interactively),
    creates the file if it does not exist, and enables the `admin` with the password
    `p0dman4Dev0ps#`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to create a self-signed server certificate with its related
    private key, to be used for HTTPS connections. As an example, a certificate associated
    with the *localhost* **Common Name** (**CN**) will be created.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Bounding certificates to the *localhost* CN is a frequent practice in development
    environments. However, if the registry is meant to be exposed externally, the
    `CN` and `SubjectAltName` fields should map to the host FQDN and alternate names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to create a self-signed certificate with the
    `openssl` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The command will issue non-interactive certificate generation, without any extra
    information about the certificate subject. The private key `tls.key` is generated
    using a 4096-bit RSA algorithm. The certificate, named `tls.crt`, is set to expire
    after 1 year. Both the key and certificate are written inside the `certs` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To inspect the content of the generated certificate, we can run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The command will produce a human-readable dump of the certificate data and validity.
  prefs: []
  type: TYPE_NORMAL
- en: Hint
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of this example, the self-signed certificate is acceptable,
    but it should be avoided in production scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions such as **Let's Encrypt** provide a free CA service for everybody
    and can be used to reliably secure the registry or any other HTTPS service. For
    further details, visit [https://letsencrypt.org/](https://letsencrypt.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have all the requirements to run our custom registry. Before creating
    the new container, make sure the previous instance has been stopped and removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The next command shows how to run the new custom registry using bind mounts
    to pass the certificates folder, the `htpasswd` file, the registry store, and,
    obviously, the custom config file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now test the login to the remote registry using the previously defined
    credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the `--tls-verify=false` option to skip TLS certificate validation.
    Since it is a self-signed certificate, we need to bypass checks that would produce
    the error message *x509: certificate signed by unknown authority*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can try again to delete the image pushed before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This time, the command will succeed since the deletion feature was enabled in
    the config file.
  prefs: []
  type: TYPE_NORMAL
- en: A local registry can be used to mirror images from an external public registry.
    In the next subsection, we will see an example of registry mirroring using our
    local registry and a selected set of repositories and images.
  prefs: []
  type: TYPE_NORMAL
- en: Using a local registry to sync repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mirroring images and repositories to a local registry can be very useful on
    disconnected environments. This can also be very useful to keep an async copy
    of selected images and be able to keep pulling them during public service outages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example shows simple mirroring using the `skopeo sync` command with
    a list of images provided by a YAML file and our local registry as the destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The YAML file contains a list of the images that compose a Kubernetes control
    plane for a specific release. Again, we take advantage of regular expressions
    to customize the images to pull:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter09/kube_sync.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: When synchronizing a remote and local registry, a lot of layers can be mirrored
    in the process. For this reason, it is important to monitor the storage used by
    the registry (`/var/lib/registry` in our example) to avoid filling up the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: When the filesystem is filled, deleting older and unused images with Skopeo
    is not enough and an extra garbage collection action is necessary to free space.
    The next subsection illustrates this process.
  prefs: []
  type: TYPE_NORMAL
- en: Managing registry garbage collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a delete command is issued on a container registry, it only deletes the
    image manifests that reference a set of blobs (which could be layers or further
    manifests), while keeping the blobs in the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: If a blob is no longer referenced by any manifest, it can be eligible for garbage
    collection by the registry. The garbage collection process is managed with a dedicated
    command, `registry garbage-collect`, issued inside the registry container. This
    is not an automatic process and should be executed manually or scheduled.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, we will run a simple garbage collection. The `--dry-run`
    flag only prints the eligible blobs that are no longer referenced by a manifest
    and thus they can be safely deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete the blobs, simply remove the `--dry-run` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Garbage collection is helpful to keep the registry cleaned of unused blobs and
    save space. On the other hand, we must keep in mind that an unreferenced blob
    could still be reused in the future by another image. If deleted, it could be
    necessary to upload it again eventually.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored how to interact with container registries, which
    are the fundamental storage services for our images. We started with a high-level
    description of what a container registry is and how it works and interacts with
    our container engines and tools. We then moved on to a more detailed description
    of the differences between public, cloud-based registries and private registries,
    usually executed on-premises. It was especially useful to understand the benefits
    and limitations of both and to help us to understand the best approach for our
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: To manage container images on registries, we introduced the Skopeo tool, which
    is part of the Podman companion tools family, and illustrated how it can be used
    to copy, sync, delete, or simply inspect images over registries, giving users
    a higher degree of control over their images.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how to run a local containerized registry using the official
    community image of the Docker Registry v2\. After showing a basic usage, we went
    deeper into more advanced configuration details by showing how to enable authentication,
    image deletion, and HTTPS encryption. The local registry proved to be useful to
    sync local images as well as remote registries. The registry garbage collection
    process was illustrated to keep things tidy inside the registry store.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the knowledge gained in this chapter, you will be able to manage images
    over registries and even local registry instances with a higher degree of awareness
    of what happens under the hood. Container registries are a crucial part of a successful
    container adoption strategy and should be understood very well: with this chapter''s
    concepts in mind, you should also be able to understand and design the best fitting
    solutions and gain deep control over the tools to manipulate images.'
  prefs: []
  type: TYPE_NORMAL
- en: With this chapter, we have also completed the exploration of all the basic tasks
    related to container management. We can now move on to more advanced topics, such
    as container troubleshooting and monitoring, covered in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[1] **Open Container Initiative** (**OCI**) Distribution Specification: [https://github.com/opencontainers/distribution-spec/blob/main/spec.md](https://github.com/opencontainers/distribution-spec/blob/main/spec.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2] Bcrypt description: [https://en.wikipedia.org/wiki/Bcrypt](https://en.wikipedia.org/wiki/Bcrypt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3] Docker Registry v2 API specifications: [https://docs.docker.com/registry/spec/api/](https://docs.docker.com/registry/spec/api/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
