- en: '*Chapter 10*: Troubleshooting and Monitoring Containers'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：《故障排除和监控容器》'
- en: Running a container could be mistaken as the ultimate goal for a DevOps team,
    but instead, this is only the first step of a long journey. System administrators
    should ensure that their systems are working properly to keep the services up
    and running; in the same way, the DevOps team should ensure that their containers
    are working properly.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 运行容器可能会被误认为是 DevOps 团队的最终目标，但实际上，这只是漫长旅程的第一步。系统管理员应该确保他们的系统正常运行，以保持服务的持续运行；同样，DevOps
    团队应确保他们的容器正常工作。
- en: In container management activities, having the right knowledge of troubleshooting
    techniques could really help minimize any impact on the final services, reducing
    downtime. Talking of issues and troubleshooting, a good practice is to keep monitoring
    containers to easily intercept any issues or errors to speed up recovery.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器管理活动中，拥有正确的故障排除技术知识确实能帮助减少对最终服务的影响，减少停机时间。谈到问题和故障排除，一个好的做法是持续监控容器，以便轻松发现任何问题或错误，加快恢复速度。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Troubleshooting running containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除正在运行的容器
- en: Monitoring containers with health checks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过健康检查监控容器
- en: Inspecting our container build results
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查我们的容器构建结果
- en: Advanced troubleshooting with `nsenter`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`nsenter`进行高级故障排除
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before proceeding with the chapter information and examples, a machine with
    a working Podman installation is required. As stated in [*Chapter 3*](B17908_03_epub.xhtml#_idTextAnchor068),
    *Running the First Container*, all the examples in the book are executed on a
    Fedora 34 system or later, but can be reproduced on your OS of choice.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续介绍章节信息和示例之前，需要一台已经安装并正常运行 Podman 的机器。正如在[*第3章*](B17908_03_epub.xhtml#_idTextAnchor068)《运行第一个容器》中所述，本书中的所有示例都在
    Fedora 34 或更高版本的系统上执行，但也可以在你选择的操作系统上复现。
- en: A good understanding of the topics covered in [*Chapter 4*](B17908_04_epub.xhtml#_idTextAnchor083),
    *Managing Running Containers*, and [*Chapter 5*](B17908_05_epub.xhtml#_idTextAnchor101),
    *Implementing Storage for the Container's Data*, will be useful to easily grasp
    concepts relating to container registries.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对[*第4章*](B17908_04_epub.xhtml#_idTextAnchor083)《管理运行中的容器》和[*第5章*](B17908_05_epub.xhtml#_idTextAnchor101)《实现容器数据存储》中的内容有一个良好的理解，将有助于轻松掌握与容器注册中心相关的概念。
- en: Troubleshooting running containers
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除正在运行的容器
- en: Troubleshooting containers is an important practice that we need experience
    with to solve common issues and investigate any bugs we may encounter on the container
    layer or in the application running inside our containers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 故障排除容器是一个重要的实践，我们需要通过经验解决常见问题并调查在容器层或容器内部运行的应用程序中可能遇到的任何 bug。
- en: Starting from [*Chapter 3*](B17908_03_epub.xhtml#_idTextAnchor068), *Running
    the First Container*, we started working with basic Podman commands for running
    and then inspecting containers on our host system. We saw how we can collect logs
    with the `podman logs` command, and we also learned how to use the information
    provided by the `podman inspect` command. Finally, we should also consider taking
    a look at the output of the useful `podman system df` command, which will report
    storage usage for our containers and images, and also the useful `podman system
    info` command, which will show useful information on the host where we are running
    Podman.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从[*第3章*](B17908_03_epub.xhtml#_idTextAnchor068)《运行第一个容器》开始，我们已开始使用基本的 Podman
    命令来运行和检查主机系统上的容器。我们看到了如何使用`podman logs`命令收集日志，我们还学习了如何使用`podman inspect`命令提供的信息。最后，我们还应考虑查看有用的`podman
    system df`命令的输出，该命令会报告容器和镜像的存储使用情况，还会显示有用的`podman system info`命令的输出，显示有关运行 Podman
    的主机的有用信息。
- en: In general, we should always consider that the running container is just a process
    on the host system so we always have available all the tools and commands for
    troubleshooting the underlying OS and its available resources.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们应始终考虑运行中的容器只是主机系统上的一个进程，因此我们始终可以使用所有用于故障排除底层操作系统及其可用资源的工具和命令。
- en: A best practice for troubleshooting containers could be a top-down approach,
    analyzing the application layer first, then moving to the container layer, down
    finally to the base host system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 故障排除容器的最佳实践可以采用自上而下的方法，首先分析应用层，然后转到容器层，最终到达基础主机系统。
- en: At the container level, many of the issues that we may encounter have been summarized
    by the Podman project team in a comprehensive list on the project page. We will
    cover some of the more useful ones in the following sections.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器级别，我们可能遇到的许多问题已被 Podman 项目团队在项目页面上总结成一个综合列表。我们将在接下来的章节中介绍一些更有用的问题。
- en: Permission denied while using storage volumes
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用存储卷时权限被拒绝
- en: A very common issue that we may encounter during our activities on RHEL, Fedora,
    or any Linux distribution that uses the SELinux security subsystem is related
    to storage permission. The error described as follows is triggered when SELinux
    is set to `Enforcing` mode, which is also the suggested approach to fully guarantee
    the mandatory access security features of SELinux.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 RHEL、Fedora 或任何使用 SELinux 安全子系统的 Linux 发行版上，可能遇到的一个非常常见的问题与存储权限有关。以下描述的错误是在
    SELinux 设置为 `Enforcing` 模式时触发的，这也是建议的做法，以完全保障 SELinux 强制访问安全特性。
- en: 'We can try to test this on our Fedora workstation, first creating a directory
    and then trying to use this as a volume in our container:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试在 Fedora 工作站上测试这一点，首先创建一个目录，然后尝试将其用作容器中的卷：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As we can see, the `touch` command reports a `Permission denied` error, because
    actually, it cannot write in the filesystem.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`touch` 命令报告了 `Permission denied` 错误，因为实际上，它无法在文件系统中写入。
- en: As we saw in detail in [*Chapter 5*](B17908_05_epub.xhtml#_idTextAnchor101),
    *Implementing Storage for the Container's Data*, SELinux recursively applies labels
    to files and directories to define their context. Those labels are usually stored
    as extended filesystem attributes. SELinux uses contexts to manage policies and
    define which processes can access a specific resource.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第 5 章*](B17908_05_epub.xhtml#_idTextAnchor101)《实现容器数据存储》中详细看到的，SELinux
    会递归地为文件和目录应用标签，以定义它们的上下文。这些标签通常存储为扩展文件系统属性。SELinux 使用上下文来管理策略并定义哪些进程可以访问特定的资源。
- en: The container we just ran got its own Linux namespace and an SELinux label that
    is completely different from the local user in the Fedora workstation, which is
    why we actually got that error before.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚运行的容器有自己的 Linux 命名空间和一个与 Fedora 工作站上的本地用户完全不同的 SELinux 标签，这也是我们之前实际遇到错误的原因。
- en: Without a proper label, the SELinux system prevents the processes running in
    the container from accessing the content. This is also because Podman does not
    change the labels set by the OS if not explicitly requested through a command
    option.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有正确的标签，SELinux 系统会阻止容器中运行的进程访问内容。这是因为如果没有通过命令选项明确请求，Podman 不会更改操作系统设置的标签。
- en: To let Podman change the label for a container, we can use either of two suffixes,
    `:z` or `:Z`, for the volume mount. These options tell Podman to relabel file
    objects on the volume.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要让 Podman 更改容器的标签，我们可以在卷挂载时使用 `:z` 或 `:Z` 两个后缀中的任意一个。这些选项告诉 Podman 对卷上的文件对象重新标记。
- en: The `:z` option is used to instruct Podman that two containers share a storage
    volume. So, in this case, Podman will label the content with a shared content
    label that will allow two or more containers to read/write content on that volume.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`:z` 选项用于指示 Podman 两个容器共享一个存储卷。因此，在这种情况下，Podman 会为内容打上共享内容标签，允许两个或更多容器在该卷上读取/写入内容。'
- en: The `:Z` option is used to instruct Podman to label the volume's content with
    a private unshared label that can only be used by the current container.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`:Z` 选项用于指示 Podman 将卷的内容标记为私有的、非共享的标签，仅当前容器可以使用。'
- en: 'The command would result in something like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的结果将类似于以下内容：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see, the command didn't report any error; it worked.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，命令没有报告任何错误；它执行成功了。
- en: Issues with the ping command in rootless containers
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在无 root 容器中使用 ping 命令的问题
- en: On some hardened Linux systems, the `ping` command execution could be limited
    to only a restricted group of users. This could cause the failure of the `ping`
    command used in a container.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些强化的 Linux 系统上，`ping` 命令的执行可能仅限于一组受限用户。这可能导致容器中使用 `ping` 命令失败。
- en: As we saw in [*Chapter 3*](B17908_03_epub.xhtml#_idTextAnchor068), *Running
    the First Container*, when starting the container, the base OS will associate
    with it a different user ID from the one used in the container itself. The user
    ID associated to the container could fall outside the allowed range of user's
    IDs enabled to use the `ping` command.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [*第 3 章*](B17908_03_epub.xhtml#_idTextAnchor068) 中看到的，*运行第一个容器*，启动容器时，基础操作系统会将一个与容器内使用的用户
    ID 不同的用户 ID 关联到容器上。与容器关联的用户 ID 可能会超出允许使用 `ping` 命令的用户 ID 范围。
- en: In a Fedora workstation installation, the default configuration will allow any
    container to run the `ping` command without issues. To manage restrictions on
    the usage of the `ping` command, Fedora uses the `ping_group_range` kernel parameter,
    which defines the allowed system groups that can execute the `ping` command.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Fedora 工作站的安装中，默认配置将允许任何容器运行 `ping` 命令而不受限制。为了管理 `ping` 命令的使用限制，Fedora 使用
    `ping_group_range` 内核参数，该参数定义了允许执行 `ping` 命令的系统组。
- en: 'If we take a look at a just-installed Fedora workstation, the default range
    is the following one:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看一个刚安装的 Fedora 工作站，默认范围如下：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So, nothing to worry about for a brand-new Fedora system. But what about if
    the range is smaller than this one?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，对于一个全新的 Fedora 系统，不必担心。但如果范围比这个小呢？
- en: 'Well, we test this behavior by changing the allowed range with a simple command.
    In this example, we are going to restrict the range and see that the `ping` command
    will actually fail then:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们通过一个简单的命令来更改允许的范围来测试这种行为。在这个示例中，我们将限制范围并看到 `ping` 命令实际会失败：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Just in case the range is smaller than the one reported in the previous output,
    we can make it persistent by adding a file to `/etc/sysctl.d` that contains `net.ipv4.ping_group_range=0
    0`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以防范围小于前面输出中报告的范围，我们可以通过将一个包含 `net.ipv4.ping_group_range=0 0` 的文件添加到 `/etc/sysctl.d`
    来使其持久化。
- en: The applied change in the `ping` group range will impact the mapped user privileges
    to run the `ping` command inside the container.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `ping` 组范围所做的更改将影响映射到容器内运行 `ping` 命令的用户权限。
- en: 'Let''s start by building a Fedora-based image with the `iputils` package (not
    included by default) using Buildah:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用 Buildah 构建一个基于 Fedora 的镜像，并包含 `iputils` 包（默认未包含）：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can test it by running the following command inside a container:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在容器内运行以下命令来进行测试：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The command, executed on a system with a restricted range, produces a 100% packet
    loss since the `ping` command is not able to send packets over a raw socket.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个限制范围的系统上执行该命令时，因 `ping` 命令无法通过原始套接字发送数据包，因此会产生 100% 的数据包丢失。
- en: The example demonstrates how a restriction in `ping_group_range` impacts the
    execution of `ping` inside a rootless container. By setting the range to a value
    large enough to include the user private group GID (or one of the user's secondary
    groups), the `ping` command will be able to send ICMP packets correctly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例演示了 `ping_group_range` 限制如何影响无根容器内 `ping` 的执行。通过将范围设置为足够大的值以包含用户私有组 GID（或用户的某个次要组），`ping`
    命令将能够正确发送 ICMP 数据包。
- en: Important Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Do not forget to restore the original `ping_group_range` before proceeding with
    the next examples. On Fedora, the default configuration can be restored with the
    `sudo sysctl -w "net.ipv4.ping_group_range=0 2147483647"` command and by removing
    any persistent configuration applied under `/etc/sysctl.d` during the exercise.
    For a base container image that we are building through a Dockerfile, we may need
    to add a brand-new user with a large UID/GID. This will create a large, sparse
    `/var/log/lastlog` file and this can cause the build to hang forever. This issue
    is related to the Go language, which does not correctly support sparse files,
    leading to the creation of this huge file in the container image.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续进行下一个示例之前，请不要忘记恢复原始的 `ping_group_range`。在 Fedora 中，默认配置可以通过 `sudo sysctl
    -w "net.ipv4.ping_group_range=0 2147483647"` 命令恢复，并通过删除在练习过程中应用于 `/etc/sysctl.d`
    下的任何持久配置来恢复。对于我们通过 Dockerfile 构建的基础容器镜像，可能需要添加一个新的用户，并为其分配较大的 UID/GID。这将导致创建一个较大且稀疏的
    `/var/log/lastlog` 文件，并可能导致构建永远挂起。这个问题与 Go 语言相关，因为 Go 语言不正确地支持稀疏文件，导致在容器镜像中创建了这个巨大的文件。
- en: Good to Know
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 需要知道的事项
- en: The `/var/log/lastlog` file is a binary and sparse file that contains information
    about the last time that the users logged in to the system. The apparent size
    of a sparse file reported by `ls -l` is larger than the actual disk usage. A sparse
    file attempts to use filesystem space in a more efficient way, writing the metadata
    that represents the empty blocks to disk instead of the empty space that should
    be stored in the block. This will use less disk space.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`/var/log/lastlog` 文件是一个二进制稀疏文件，包含有关用户上次登录系统的时间的信息。通过 `ls -l` 查看时，稀疏文件的显示大小大于实际磁盘使用量。稀疏文件通过将表示空块的元数据写入磁盘，而不是将空闲空间存储在块中，从而更加高效地使用文件系统空间。这将节省更多的磁盘空间。'
- en: 'If we need to add a brand-new user to our base container image with a high
    UID number, the best way would be to append the `--no-log-init` option to the
    Dockerfile command, as shown here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要为基础容器镜像添加一个 UID 数字较高的新用户，最好的方法是将 `--no-log-init` 选项附加到 Dockerfile 命令中，如下所示：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This option instructs the `useradd` command to stop creating the lastlog file,
    solving the issue we may encounter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项指示 `useradd` 命令停止创建 lastlog 文件，从而解决我们可能遇到的问题。
- en: 'As mentioned in the early paragraphs of this section, the Podman team has created
    a long but non-comprehensive list of common issues. We strongly suggest taking
    a look at it if any issues are encountered: [https://github.com/containers/podman/blob/main/troubleshooting.md](https://github.com/containers/podman/blob/main/troubleshooting.md).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本节前几段所提到的，Podman 团队创建了一个很长但不全面的常见问题列表。如果遇到任何问题，我们强烈建议查看该列表：[https://github.com/containers/podman/blob/main/troubleshooting.md](https://github.com/containers/podman/blob/main/troubleshooting.md)。
- en: Troubleshooting could be tricky, but the first step is always the identification
    of an issue. For this reason, a monitoring tool could help in alerting as soon
    as possible in the case of issues. Let's see how to monitor containers with health
    checks in the next section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 排查问题可能会有些棘手，但第一步始终是识别问题。因此，监控工具可以在出现问题时尽早发出警报。接下来我们将看看如何使用健康检查监控容器。
- en: Monitoring containers with health checks
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控具有健康检查的容器
- en: Starting with version 1.2, Podman supports the option to add a health check
    to containers. We will go in depth in this section into these health checks and
    how to use them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从 1.2 版本开始，Podman 支持为容器添加健康检查选项。在本节中，我们将深入探讨这些健康检查以及如何使用它们。
- en: A health check is a Podman feature that can help determine the health or readiness
    of the process running in a container. It could be as simple as checking that
    the container's process is running but also more sophisticated, such as verifying
    that both the container and its applications are responsive using, for example,
    network connections.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查是 Podman 的一个功能，它可以帮助判断容器中运行的进程的健康状况或准备状态。它可以像检查容器进程是否在运行一样简单，也可以更复杂，比如使用网络连接等方式验证容器及其应用是否响应。
- en: 'A health check is made up of five core components. The first is the main element
    that will instruct Podman on the particular check to execute; the others are used
    for configuring the schedule of the health check. Let''s see these elements in
    detail:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查由五个核心组件组成。第一个是主要元素，它指示 Podman 执行特定的检查；其他组件用于配置健康检查的调度。让我们详细了解这些元素：
- en: '`0`) or a failure (with other exit codes).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`）或失败（其他退出代码）。'
- en: If our container provides a web server, for example, our health check command
    could be something really simple, such as a `curl` command that will try to connect
    to the web server port to make sure it is responsive.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的容器提供一个 web 服务器，例如，我们的健康检查命令可以是一个非常简单的命令，比如 `curl` 命令，尝试连接到 web 服务器的端口，确保它是响应的。
- en: '**Retries**: This defines the number of consecutive failed commands that Podman
    has to execute before the container will be marked as unhealthy. If a command
    executes successfully, Podman will reset the retry counter.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重试次数**：此选项定义了 Podman 必须执行的连续失败命令数量，容器才会被标记为不健康。如果某个命令成功执行，Podman 会重置重试计数器。'
- en: '**Interval**: This option defines the interval time within which Podman will
    run the health check command.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**间隔时间**：此选项定义了 Podman 执行健康检查命令的时间间隔。'
- en: 'Finding the right interval time could be really difficult and requires some
    trial and error. If we set it to a small value, then our system may spend a lot
    of time running the health checks. But if we set it to a large value, we may struggle
    and catch timeouts. This value can be defined with a widely used time format:
    `30s` or `1h5m`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 找到合适的间隔时间可能非常困难，并且需要一些反复试验。如果我们设置为一个较小的值，那么系统可能会花费大量时间进行健康检查。但如果我们设置为较大的值，可能会出现超时问题。这个值可以使用广泛使用的时间格式来定义：`30s`或`1h5m`。
- en: '**Start period**: This describes the time after which the health checks will
    be started by Podman. In this period, Podman will ignore health check failures.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动周期**：这描述了健康检查将由Podman启动的时间，在此期间，Podman将忽略健康检查失败。'
- en: We can consider this as a grace period that should be used to allow our application
    to successfully be up and start replying correctly to any clients as well as to
    our health checks.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其视为一个宽限期，用于让我们的应用成功启动并开始正确地响应任何客户端请求以及健康检查。
- en: '**Timeout**: This defines the period of time the health check itself must complete
    before being considered unsuccessful.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超时**：这定义了健康检查本身必须完成的时间段，超过该时间段即视为检查失败。'
- en: 'Let''s take a look at a real example, supposing we want to define a health
    check for a container and run that health check manually:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个实际的例子，假设我们要为一个容器定义一个健康检查，并手动运行该健康检查：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we can see from the previous code block, we just started a brand-new container
    named `checktest1`, defining a `healthcheck-command` that will run the `curl`
    command on the `localhost` address inside the target container. Once the container
    started, we manually ran `healthcheck` and verified that the exit code was `0`,
    meaning that the check completed successfully and our container is healthy. In
    the previous example, we also used the `--healthcheck-interval=0` option to actually
    disable the run interval and make the health check manual.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的代码块中可以看到，我们刚刚启动了一个名为`checktest1`的全新容器，定义了一个`healthcheck-command`，该命令将在目标容器内的`localhost`地址上运行`curl`命令。容器启动后，我们手动运行了`healthcheck`并验证退出代码为`0`，意味着检查成功完成，并且我们的容器是健康的。在之前的示例中，我们还使用了`--healthcheck-interval=0`选项，实际上禁用了运行间隔并将健康检查设置为手动。
- en: Podman uses `cron`, to schedule the health checks, but these should be set manually.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Podman使用`cron`来调度健康检查，但这些应该手动设置。
- en: 'Let''s inspect how this automatic integration with systemd works by creating
    an health check with an interval:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个具有间隔时间的健康检查来检查系统与systemd的自动集成是如何工作的：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we can see from the previous code block, we just started a brand-new container
    named `checktest2`, defining the same `healthcheck-command` of the previous example
    but now specifying the `--healthcheck-interval=10s` option to actually schedule
    the check every 10 seconds.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的代码块中可以看到，我们刚刚启动了一个名为`checktest2`的全新容器，定义了与前面示例相同的`healthcheck-command`，但现在指定了`--healthcheck-interval=10s`选项，实际上将检查任务每10秒调度一次。
- en: After the `podman run` command, we also ran the `podman ps` command to actually
    inspect whether the health check is working properly, and as we can see in the
    output, we have the `healthy` status for our brand-new container.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行`podman run`命令之后，我们还运行了`podman ps`命令，实际上检查健康检查是否正常工作，正如我们在输出中看到的那样，我们为新容器显示了`healthy`状态。
- en: 'But how does this integration work? Let''s grab the container ID and search
    for it in the following directory:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个集成是如何工作的呢？让我们获取容器ID，并在以下目录中搜索它：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The directory shown in the previous code block holds all the systemd resources
    in use for our current user. In particular, we looked into the `transient` directory,
    which holds temporary unit files for our current user.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码块中显示的目录包含了当前用户使用的所有systemd资源。特别地，我们查看了`transient`目录，它存放了当前用户的临时单元文件。
- en: When we start a container with a health check and a schedule interval, Podman
    will perform a transient setup of a systemd service and timer unit file. This
    means that these unit files are not permanent and can be lost on reboot.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动一个带有健康检查和调度间隔的容器时，Podman将执行一个临时设置的systemd服务和计时器单元文件。这意味着这些单元文件不是永久性的，并且在重启时可能会丢失。
- en: 'Let''s inspect what is defined inside these files:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下这些文件中定义的内容：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see from the previous code block, the service unit file contains the
    Podman health check command, while the timer unit file defines the scheduling
    interval.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的代码块中可以看到，服务单元文件包含了Podman健康检查命令，而计时器单元文件定义了调度间隔。
- en: 'Finally, just because we may want a quick way to identify healthy or unhealthy
    containers, we can use the following command to quickly output them:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们想快速识别健康或不健康的容器，可以使用以下命令快速输出它们：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, we used the `--filter health=healthy` option to display only
    the healthy containers with the `podman ps` command.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了 `--filter health=healthy` 选项，通过 `podman ps` 命令仅显示健康的容器。
- en: We learned how to troubleshoot and monitor our containers in the previous sections,
    but what about the container build process? Let's discover more about container
    build inspection in the next section.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的章节中学会了如何排查和监控容器，但容器构建过程又该如何处理呢？让我们在接下来的章节中更深入地了解容器构建检查。
- en: Inspecting your container build results
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查容器构建结果
- en: In previous chapters, we discussed in detail the container build process and
    learned how to create custom images using Dockerfiles/Containerfiles or Buildah-native
    commands. We also illustrated how the second approach helps achieve a greater
    degree of control of the build workflow.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们详细讨论了容器构建过程，并学习了如何使用 Dockerfile/Containerfile 或 Buildah 原生命令创建自定义镜像。我们还展示了第二种方法如何帮助更好地控制构建工作流程。
- en: This section helps provide some best practices to inspect the build results
    and understand potentially related issues.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本节帮助提供了一些最佳实践，用于检查构建结果并理解可能相关的问题。
- en: Troubleshooting builds from Dockerfiles
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排查来自 Dockerfile 的构建问题
- en: When using Podman or Buildah to run a build based on a Dockerfile/Containerfile,
    the build process prints all the instructions' outputs and related errors on the
    terminal stdout. For all `RUN` instructions, errors generated from the executed
    commands are propagated and printed for debugging purposes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Podman 或 Buildah 根据 Dockerfile/Containerfile 运行构建时，构建过程会将所有指令的输出和相关错误打印到终端标准输出。对于所有
    `RUN` 指令，执行命令时产生的错误会被传播并打印出来以供调试。
- en: Let's now try to test some potential build issues. This is not an exhaustive
    list of errors; the purpose is to provide a method to analyze the root cause.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试测试一些潜在的构建问题。这不是一个详尽无遗的错误清单；其目的是提供一种分析根本原因的方法。
- en: 'The first example shows a minimal build where a `RUN` instruction fails due
    to an error in the executed command. Errors in `RUN` instructions can cover a
    wide range of cases but the general rule of thumb is the following: the executed
    command returns an exit code and if this is non-zero, the build fails and the
    error, along with the exit status, is printed.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例展示了一个最小构建，其中由于执行的命令出现错误，`RUN` 指令失败。`RUN` 指令中的错误可能涵盖广泛的情况，但一般的经验法则是：执行的命令返回一个退出码，如果该退出码非零，构建失败，错误和退出状态会被打印出来。
- en: 'In the next example, we use the `yum` command to install the `httpd` package,
    but we have intentionally made a typo in the package name to generate an error.
    Here is the Dockerfile transcript:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们使用 `yum` 命令安装 `httpd` 包，但我们故意在包名中打了一个错别字，以产生一个错误。下面是 Dockerfile 的记录：
- en: Chapter10/RUN_command_error/Dockerfile
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter10/RUN_command_error/Dockerfile
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we try to execute the command, we will get an error generated by the `yum`
    command not being able to find the missing `htpd` package:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试执行该命令，将会遇到一个错误，错误由 `yum` 命令无法找到缺失的 `httpd` 包生成：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first two lines print the error message generated by the `yum` command,
    as in a standard command-line environment.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行打印出由 `yum` 命令生成的错误信息，类似于标准命令行环境中的输出。
- en: 'Next, Buildah (and, in the same way, Podman) produces a message to inform us
    about the step that generated the error. This message is managed in the `imagebuildah`
    package by the stage executor, which handles, as the name indicates, the execution
    of the build stages and their statuses. The source code can be inspected in the
    Buildah repository on GitHub: [https://github.com/containers/buildah/blob/main/imagebuildah/stage_executor.go](https://github.com/containers/buildah/blob/main/imagebuildah/stage_executor.go).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Buildah（同样，Podman）会产生一条信息，告知我们产生错误的步骤。此信息由 `imagebuildah` 包中的阶段执行器管理，正如其名称所示，阶段执行器处理构建阶段的执行及其状态。源代码可以在
    Buildah 的 GitHub 仓库中查看：[https://github.com/containers/buildah/blob/main/imagebuildah/stage_executor.go](https://github.com/containers/buildah/blob/main/imagebuildah/stage_executor.go)。
- en: The message includes the Dockerfile instruction and the generated error, along
    with the exit status.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 该信息包含 Dockerfile 指令和生成的错误，以及退出状态。
- en: The last line includes the `ERRO[0004]` error code and the final exit status
    `1`, related to the `buildah` command execution.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行包括`ERRO[0004]`错误代码和与`buildah`命令执行相关的最终退出状态`1`。
- en: '`RUN` instruction that contains the failing command and fix or troubleshoot
    the command error.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`RUN`指令包含出错的命令，并修复或排查该命令错误。
- en: Another very common failure reason in builds is the missing parent image. It
    could be related to a misspelled repository name, a missing tag, or an unreachable
    registry.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程中的另一个常见失败原因是缺少父镜像。这可能与拼写错误的仓库名称、缺失的标签或无法访问的镜像仓库相关。
- en: 'The next example shows another variation of the previous Dockerfile, where
    the image repository name is mistyped and thus does not exist in the remote registry:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例展示了前一个Dockerfile的另一种变体，其中镜像仓库名称拼写错误，因此在远程仓库中找不到该镜像：
- en: Chapter10/FROM_repo_not_found/Dockerfile
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter10/FROM_repo_not_found/Dockerfile
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When running a build from this Dockerfile, we will encounter an error caused
    by the missing image repository, as in the next example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当从这个Dockerfile进行构建时，我们将遇到由于缺少镜像仓库而导致的错误，如下一个示例所示：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The last line produces a different error code, `ERRO[0001]`, and an exit status,
    `125`. This is a very easy error to troubleshoot and only requires passing a valid
    repository to the `FROM` instruction.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行产生了不同的错误代码`ERRO[0001]`和退出状态`125`。这是一个非常容易排查的错误，只需将有效的仓库传递给`FROM`指令即可。
- en: '**Solution**: Fix the repository name and relaunch the build process. Alternatively,
    verify that the target registry holds the wanted repository.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：修正仓库名称并重新启动构建过程。或者，验证目标仓库是否包含所需的仓库。'
- en: 'What happens if we misspell the image tag? The next Dockerfile snippet shows
    an invalid tag for the official Fedora image:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们拼写错误了镜像标签，会发生什么呢？下一个Dockerfile片段显示了官方Fedora镜像的无效标签：
- en: Chapter10/FROM_tag_not_found/Dockerfile
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter10/FROM_tag_not_found/Dockerfile
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This time, when we build the image, we will get a 404 error produced by the
    registry, which is unable to find an associated manifest for the `sometag` tag:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，当我们构建镜像时，仓库会产生404错误，因为它无法找到`sometag`标签的关联清单：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The missing tag will generate an `ERRO[0001]` error, while the exit status will
    be set to `125` again.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少标签会产生`ERRO[0001]`错误，退出状态再次设置为`125`。
- en: '`skopeo list-tags` to find all the available tags in a given repository.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`skopeo list-tags`命令可以查找给定仓库中所有可用的标签。
- en: Sometimes, the error caught from the `FROM` instruction is caused by the attempt
    to access a private registry without authentication. This is a very common mistake
    and simply requires an authenticating step on the target registry before any build
    action takes place.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，`FROM`指令捕获到的错误是由于尝试访问一个私有仓库而没有进行身份验证。这是一个非常常见的错误，只需要在进行构建操作之前，在目标仓库进行身份验证即可。
- en: 'In the next example, we have a Dockerfile that uses an image from a generic
    private registry running using Docker Registry v2 APIs:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们有一个使用来自通用私有仓库的镜像的Dockerfile，该私有仓库通过Docker Registry v2 APIs运行：
- en: Chapter10/FROM_auth_error/Dockerfile
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter10/FROM_auth_error/Dockerfile
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s try to build the image and see what happens:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试构建镜像并查看会发生什么：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this use case, the error is very clear. We are not authorized to pull the
    image from the target registry and thus, we need to authenticate with a valid
    auth token to access it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个用例中，错误非常明显。我们没有权限从目标仓库拉取镜像，因此我们需要使用有效的认证令牌进行身份验证才能访问它。
- en: '`podman login` or `buildah login` to the registry to retrieve the token or
    provide an authentication file with a valid token.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`podman login`或`buildah login`命令登录仓库以获取令牌，或者提供包含有效令牌的身份验证文件。
- en: So far, we have inspected errors generated by builds with Dockerfiles. Let's
    now see the behavior of Buildah in the case of errors when using its command-line
    instructions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经检查了通过Dockerfile构建时产生的错误。接下来，让我们看看在使用Buildah命令行指令时，发生错误的情况。
- en: Troubleshooting builds with Buildah-native commands
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Buildah原生命令排查构建问题
- en: When running Buildah commands, it is a common practice to put them inside a
    shell script or a pipeline.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行Buildah命令时，常见的做法是将它们放入shell脚本或管道中。
- en: 'In this example, we will use Bash as the interpreter. By default, Bash executes
    the script up to the end, regardless of intermediate errors. This behavior can
    generate unexpected errors if a Buildah instruction inside the script fails. For
    this reason, the best practice is to add the following command at the beginning
    of the script:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用Bash作为解释器。默认情况下，Bash会一直执行脚本，直到结束，无论中间是否有错误。如果脚本中的Buildah指令失败，这种行为可能会产生意外的错误。因此，最佳实践是在脚本开头添加以下命令：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The resulting configuration is a sort of safety net that blocks the execution
    of the script as soon as we encounter an error and avoids common mistakes, such
    as unset variables.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 结果配置是一种安全网，一旦遇到错误，它就会阻止脚本的执行，并避免常见的错误，比如未设置的变量。
- en: The `set` command is a Bash internal instruction that configures the shell for
    the script execution. The `-e` option inside this instruction tells the shell
    to exit immediately if a pipeline or a single command fails and the `–o pipefail`
    option tells the shell to exit with the error code of the rightmost command of
    a failing pipeline that produced a non-zero exit code. The `-u` option tells the
    shell to treat unset variables and parameters as an error during parameter expansion.
    This keeps us safe from the missing expansion of unset variables.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`命令是一个Bash内部指令，用于配置脚本执行时的Shell环境。此指令中的`-e`选项告诉Shell在管道或单个命令失败时立即退出，`–o
    pipefail`选项则告诉Shell在失败管道的最右侧命令产生非零退出码时退出，并返回该命令的错误码。`-u`选项告诉Shell在参数扩展过程中将未设置的变量和参数视为错误。这能保护我们免受未设置变量未展开的影响。'
- en: 'The next script embeds the logic of a simple build of an `httpd` server on
    top of the Fedora image:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个脚本嵌入了在Fedora镜像上构建一个简单`httpd`服务器的逻辑：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The image tag was set wrong on purpose. Let''s see the results of the script
    execution:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图像标签故意设置错误。让我们看看脚本执行的结果：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The build produces a `manifest unknown` error with the `ERRO[0001]` error code
    and the `125` exit status, just like the similar attempt with the Dockerfile.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 构建会产生一个`manifest unknown`错误，错误代码为`ERRO[0001]`，退出状态为`125`，就像使用Dockerfile时的类似尝试。
- en: From this output, we can also learn that Buildah (and Podman, which uses Buildah
    libraries for its build implementation) produces the same messages as a standard
    build with a Dockerfile/Containerfile, with the only exception of not mentioning
    the build step, which is obvious since we are running free commands inside a script.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中，我们还可以了解到，Buildah（以及使用Buildah库进行构建实现的Podman）生成的消息与使用Dockerfile/Containerfile进行标准构建时的消息相同，唯一的例外是没有提到构建步骤，这是显而易见的，因为我们在脚本中运行的是自由命令。
- en: '`skopeo list-tags` to find all the available tags in a given repository.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`skopeo list-tags`查找给定仓库中所有可用的标签。
- en: 'In this section, we have learned how to analyze and troubleshoot build errors,
    but what can we do when the errors happen at runtime inside the container and
    we do not have the proper tools for troubleshooting inside the image? For this
    purpose, we have a native Linux tool that can be considered the real Swiss Army
    knife of namespaces: `nsenter`.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们学习了如何分析和排除构建错误，但当错误发生在容器内的运行时，并且我们没有合适的工具来进行容器内故障排除时该怎么办？为此，我们有一个本地Linux工具，可以视为命名空间的真正瑞士军刀：`nsenter`。
- en: Advanced troubleshooting with nsenter
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用nsenter进行高级故障排除
- en: 'Let''s start with a dramatic sentence: troubleshooting issues at runtime can
    sometimes be complex.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一句戏剧性的句子开始：在运行时排除故障有时可能是复杂的。
- en: Also, understanding and troubleshooting runtime issues inside a container implies
    an understanding of how containers work in GNU/Linux. We explained these concepts
    in [*Chapter 1*](B17908_01_epub.xhtml#_idTextAnchor015), *Introduction to Container
    Technology*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，理解和排除容器内的运行时问题需要理解容器在GNU/Linux中的工作原理。我们在[*第1章*](B17908_01_epub.xhtml#_idTextAnchor015)《容器技术简介》中解释了这些概念。
- en: Sometimes, troubleshooting can be very easy and, as stated in the previous sections,
    the usage of basic commands, such as `podman logs`, `podman inspect`, and `podman
    exec`, along with the usage of tailored health checks, can help us to gain access
    to the necessary information to complete our analysis successfully.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，故障排除非常简单，正如前面几部分所述，使用基本命令，如`podman logs`、`podman inspect`和`podman exec`，再加上定制的健康检查，可以帮助我们获得完成分析所需的信息。
- en: Images nowadays tend to be as small as possible. What happens when we need more
    specialized troubleshooting tools, and they are not available inside the image?
    You could think to exec a shell process inside the container and install the missing
    tool but sometimes (and this is a growing security pattern), package managers
    are not available inside container images, sometimes not even the `curl` or `wget`
    commands!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，镜像通常尽可能小。那么当我们需要更多专业的故障排除工具，而它们在镜像中不可用时怎么办？你可以考虑在容器内执行一个Shell进程，并安装缺失的工具，但有时（这也是一个日益增长的安全模式），容器镜像中没有包管理器，有时甚至没有`curl`或`wget`命令！
- en: We may feel a bit lost but we must remember that containers are processes executed
    within dedicated namespaces and cgroups. What if we had a tool that could let
    us exec inside one or more namespaces while keeping our access to the host tools?
    That tool exists and is called `nsenter` (access the manual page with `man nsenter`).
    It is not affiliated with any container engine or runtime and provides a simple
    way to execute commands inside one or multiple namespaces unshared for a process
    (the main container process).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会感到有些迷茫，但我们必须记住，容器是运行在专用命名空间和cgroups中的进程。如果我们有一个工具，可以在保持访问主机工具的同时，在一个或多个命名空间内执行命令，那会怎么样？这个工具就叫做`nsenter`（可以使用`man
    nsenter`访问手册页）。它与任何容器引擎或运行时无关，提供了一种简单的方法来在一个或多个进程的未共享命名空间内执行命令（即容器的主进程）。
- en: 'Before diving into real examples, let''s discuss the main `nsenter` options
    and arguments by running it with the `--help` option:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入真实示例之前，让我们通过使用`--help`选项来运行`nsenter`，讨论一下它的主要选项和参数：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: From the output of this command, it is easy to spot that there are as many options
    as the number of available namespaces.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从此命令的输出中，可以轻松发现选项的数量与可用命名空间的数量相同。
- en: Thanks to `nsenter`, we can capture the PID of the main process of a container
    and then exec commands (including a shell) inside the related namespaces.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢`nsenter`，我们可以捕获容器主进程的PID，然后在相关的命名空间内执行命令（包括启动一个Shell）。
- en: 'To extract the container''s main PID, we use can use the following command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取容器的主PID，可以使用以下命令：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output can be inserted inside a variable for easier access:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果可以插入到变量中以便于访问：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Hint
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: All namespaces associated with a process are represented inside the `/proc/[pid]/ns`
    directory. This directory contains a series of symbolic links mapping to a namespace
    type and its corresponding inode number.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与进程相关的所有命名空间都表示在`/proc/[pid]/ns`目录中。该目录包含一系列符号链接，映射到命名空间类型及其对应的inode编号。
- en: 'The following command shows the namespaces associated with the process executed
    by the container: `ls –al /proc/$CNT_PID/ns`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令显示与容器执行的进程相关的命名空间：`ls –al /proc/$CNT_PID/ns`。
- en: We are going to learn how to use `nsenter` with a practical example. In the
    next subsection, we will try to network troubleshoot a database client application
    that returns an HTTP internal server error without mentioning any useful information
    in the application logs.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个实际的例子学习如何使用`nsenter`。在接下来的子章节中，我们将尝试对一个数据库客户端应用进行网络故障排除，该应用返回HTTP内部服务器错误，但应用日志中没有任何有用信息。
- en: Troubleshooting a database client with nsenter
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用nsenter对数据库客户端进行故障排除
- en: It is not uncommon to work on alpha applications that still do not have logging
    correctly implemented or that have poor handling of log messages.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理alpha应用时，遇到日志未正确实现或日志消息处理较差的情况并不少见。
- en: The following example is a web application that extracts fields from a Postgres
    database and prints out a JSON object with all the occurrences. The verbosity
    of the application logs has been intentionally left to a minimum and no connection
    or query errors are produced.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是一个Web应用，从Postgres数据库中提取字段，并打印出包含所有出现项的JSON对象。应用日志的详细信息被故意设为最少，且没有产生连接或查询错误。
- en: 'For the sake of space, we will not print the application source code in the
    book; however, it is available at the following URL for inspection: [https://github.com/PacktPublishing/Podman-for-DevOps/tree/main/Chapter10/students](https://github.com/PacktPublishing/Podman-for-DevOps/tree/main/Chapter10/students).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，书中不会打印应用的源代码；但是，源代码可以通过以下URL进行查看：[https://github.com/PacktPublishing/Podman-for-DevOps/tree/main/Chapter10/students](https://github.com/PacktPublishing/Podman-for-DevOps/tree/main/Chapter10/students)。
- en: 'The folder also contains a SQL script to populate a sample database. The application
    is built using the following Dockerfile:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹中还包含一个SQL脚本，用于填充示例数据库。该应用是通过以下Dockerfile构建的：
- en: Chapter10/students/Dockerfile
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter10/students/Dockerfile
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As usual, we are going to build the container with Buildah:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，我们将使用Buildah构建容器：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The container accepts a set of custom flags to define the database, host, port,
    and credentials. To see the help information, simply run the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 容器接受一组自定义标志来定义数据库、主机、端口和凭据。要查看帮助信息，只需运行以下命令：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We have been informed that the database is running on host `pghost.example.com`
    on port `5432`, with username `students` and password `Podman_R0cks#`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已获悉数据库正在`pghost.example.com`主机上的`5432`端口运行，用户名为`students`，密码为`Podman_R0cks#`。
- en: 'The next command runs the `students` web application with the custom arguments:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条命令使用自定义参数运行`students`网页应用程序：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The container starts successfully, and the only log message printed is the
    following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 容器成功启动，打印的唯一日志消息如下：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It is now time to test the application and see what happens when we run a query:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候测试应用程序并查看运行查询时会发生什么了：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The application can take some time to answer but after a while, it will print
    an internal server error (`500`) HTTP message. We will find the reason in the
    following paragraphs. Logs are not useful since nothing else other than the first
    boot message is printed. Besides, the container was built with the UBI minimal
    image, which has a small footprint of pre-installed binaries and no utilities
    for troubleshooting. We can use `nsenter` to inspect the container behavior, especially
    from a networking point of view, by attaching our current shell program to the
    container network namespace while keeping access to our host binaries.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可能需要一些时间来响应，但过了一会儿，它会打印出一个内部服务器错误（`500`）HTTP消息。我们将在接下来的段落中找到原因。日志没有什么用处，因为除了第一次启动消息之外没有其他输出。此外，容器是使用UBI最小镜像构建的，预装二进制文件的占用空间很小，且没有故障排除的工具。我们可以使用`nsenter`来检查容器的行为，特别是从网络角度，通过将当前的Shell程序附加到容器网络命名空间，同时保持对主机二进制文件的访问。
- en: 'We can now find out the main process PID and populate a variable with its value:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以找出主进程的PID，并将其值存入一个变量中：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following example runs Bash in the container network namespace, while retaining
    all the other host namespaces (notice the `sudo` command to run it with elevated
    privileges):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例在容器网络命名空间中运行Bash，同时保留其他所有主机命名空间（请注意使用`sudo`命令以提升权限运行）：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Important Note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: 'It is possible to run any host binary directly from `nsenter`. A command such
    as the following is perfectly legitimate: `$ sudo nsenter -t $CNT_PID -n ip addr
    show`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 可以直接从`nsenter`运行任何主机二进制文件。如下命令是完全合法的：`$ sudo nsenter -t $CNT_PID -n ip addr
    show`。
- en: 'To demonstrate that we are really executing a shell attached to the container
    network namespace, we can launch the `ip addr show` command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明我们确实在执行附加到容器网络命名空间的Shell，我们可以启动`ip addr show`命令：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first command, `ip addr show`, prints the IP configuration, with a basic
    `tap0` interface connected to the host and the loopback interface.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条命令，`ip addr show`，打印出IP配置，显示一个连接到主机的基本`tap0`接口和环回接口。
- en: The second command, `ip route`, shows the default routing table inside the container
    network namespace.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条命令，`ip route`，显示容器网络命名空间内的默认路由表。
- en: 'We can take a first look at the active connections using the `ss` tool, already
    available on our Fedora host:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`ss`工具查看活动连接，`ss`工具已经在我们的Fedora主机上可用：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We immediately spot that there are no established connections between the application
    and the database host, which tells us that the issue is probably related to routing,
    firewall rules, or name resolution causes that prevent us from reaching the host
    correctly.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们立刻发现应用程序与数据库主机之间没有建立连接，这告诉我们问题可能与路由、防火墙规则或名称解析相关，这些因素阻止了我们正确访问主机。
- en: 'The next step is to try to manually connect to the database with the `psql`
    client tool, available from the rpm `postgresql` package:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是尝试使用`psql`客户端工具手动连接到数据库，该工具来自`postgresql`rpm包：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This message is quite clear: the host is not resolved by the DNS service and
    causes the application to fail. To finally confirm it, we can run the `dig` command,
    which returns an `NXDOMAIN` error, a typical message from a DNS server to say
    that the domain cannot be resolved and does not exist:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个消息很清楚：主机无法通过DNS服务解析，导致应用程序失败。为了最终确认这一点，我们可以运行`dig`命令，它返回一个`NXDOMAIN`错误，这是DNS服务器典型的消息，表示域无法解析并不存在：
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: After checking with the development team, we discovered that the database name
    had a missing dash that was misspelled, and the correct name was `pg-host.example.com`.
    We can now fix the issue by running the container with the correct name.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在与开发团队确认后，我们发现数据库名称中缺少了一个连字符并拼写错误，正确的名称是 `pg-host.example.com`。现在，我们可以通过使用正确的名称运行容器来修复问题。
- en: 'We expect now to see the correct results when launching the query again:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在期望再次启动查询时看到正确的结果：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this example, we have focused on network namespace troubleshooting, but it
    is possible to attach our current shell program to multiple namespaces by simply
    adding the related flags.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们集中讨论了网络命名空间故障排除，但通过简单地添加相关标志，我们也可以将当前的 shell 程序附加到多个命名空间。
- en: 'We can also simulate `podman exec` by running the command with the `-a` option:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过添加 `-a` 选项来模拟 `podman exec`：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This command attaches the process to all the unshared namespaces, including
    the mount namespace, thus giving the same filesystem tree view that is seen by
    processes inside the container.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将进程附加到所有未共享的命名空间，包括挂载命名空间，从而提供与容器内进程看到的相同的文件系统树视图。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we focused on container troubleshooting, trying to provide
    a set of best practices and tools to find and fix issues inside a container at
    build time or runtime.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们重点讨论了容器故障排除，旨在提供一套最佳实践和工具，用于在构建时或运行时查找并修复容器内的问题。
- en: We started by showing off some common use cases during container execution and
    build stages and their related solutions.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先展示了在容器执行和构建阶段中的一些常见用例及其相关解决方案。
- en: Afterward, we introduced the concept of health checks and illustrated how to
    implement solid probes on containers to monitor their statuses, while showing
    the architectural concepts behind them.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们介绍了健康检查的概念，并说明了如何在容器上实现稳健的探针以监控其状态，同时展示了其背后的架构概念。
- en: In the third section, we learned about a series of common error scenarios related
    to builds and showed how to solve them quickly.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三节中，我们学习了一系列与构建相关的常见错误场景，并展示了如何快速解决它们。
- en: In the final section, we introduced the `nsenter` command and simulated a web
    frontend application that needed network troubleshooting to find out the cause
    of an internal server error. Thanks to this example, we learned how to conduct
    advanced troubleshooting inside the container namespaces.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们介绍了 `nsenter` 命令，并模拟了一个需要网络故障排除的 Web 前端应用，以找出内部服务器错误的原因。通过这个示例，我们学会了如何在容器命名空间内部进行高级故障排除。
- en: In the next chapter, we are going to discuss container security, a crucial concept
    that deserves great attention. We will learn how to secure containers with a series
    of best practices, the difference between rootless and rootful containers, and
    how to sign container images to make them publicly available.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论容器安全性，这是一个至关重要的概念，值得特别关注。我们将学习如何通过一系列最佳实践来保障容器安全，了解无根容器和有根容器之间的区别，并学习如何签名容器镜像以使其公开可用。
- en: Further reading
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'Podman troubleshooting guidelines: [https://github.com/containers/podman/blob/main/troubleshooting.md](https://github.com/containers/podman/blob/main/troubleshooting.md)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman 故障排除指南：[https://github.com/containers/podman/blob/main/troubleshooting.md](https://github.com/containers/podman/blob/main/troubleshooting.md)
