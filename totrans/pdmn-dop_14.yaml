- en: '*Chapter 11*: Securing Containers'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is becoming the hottest topic of current times. Enterprises and companies
    all over the world are making huge investments in security practices and tools
    that should help protect their systems from internal or external attacks.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in [*Chapter 1*](B17908_01_epub.xhtml#_idTextAnchor015), *Introduction
    to Container Technology*, containers and their host systems can be considered
    a medium to execute and keep a target application running. Security should be
    applied to all levels of the service architecture, from the base infrastructure
    to the target application code, all while passing through the virtualization or
    containerization layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the best practices and tools that could help
    improve the overall security of our containerization layer. In particular, we''re
    going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Running rootless containers with Podman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not run containers with UID 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signing our container images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing Linux kernel capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SELinux interaction with containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this chapter's examples, you will need a machine with a working
    Podman installation. As we mentioned in [*Chapter 3*](B17908_03_epub.xhtml#_idTextAnchor068),
    *Running the First Container*, all the examples in this book have been executed
    on a Fedora 34 system or later, but they can be reproduced on your OS of choice.
  prefs: []
  type: TYPE_NORMAL
- en: Having a good understanding of the topics that were covered in [*Chapter 4*](B17908_04_epub.xhtml#_idTextAnchor083),
    *Managing Running Containers*, [*Chapter 5*](B17908_05_epub.xhtml#_idTextAnchor101),
    *Implementing Storage for the Container's Data*, and [*Chapter 9*](B17908_09_epub.xhtml#_idTextAnchor167),
    *Pushing Images to a Container Registry*, will help you understand the container
    security topics we'll be discussing here.
  prefs: []
  type: TYPE_NORMAL
- en: Running rootless containers with Podman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we briefly saw in [*Chapter 4*](B17908_04_epub.xhtml#_idTextAnchor083), *Managing
    Running Containers*, it is possible for Podman to let standard users without administrative
    privileges run containers in a Linux host. These containers are often referred
    to as "rootless containers."
  prefs: []
  type: TYPE_NORMAL
- en: 'Rootless containers have many advantages, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: They create an additional security layer that could block attackers trying to
    get root privileges on the host, even if the container engine, runtime, or orchestrator
    has been compromised.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can allow many unprivileged users to run containers on the same host, making
    the most of high-performance computing environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's think about the approach that's used by any Linux system to handle traditional
    process services. Usually, the package maintainers tend to create a dedicated
    user for scheduling and running the target process. If we try to install an Apache
    web server on our favorite Linux distribution through the default package manager,
    then we can find out that the installed service will run through a dedicated user
    named "apache."
  prefs: []
  type: TYPE_NORMAL
- en: This approach has been the best practice for years because, from a security
    perspective, allowing fewer privileges improves security.
  prefs: []
  type: TYPE_NORMAL
- en: Using the same approach but with a rootless container allows us to run the container
    process without the need for additional privileges escalation. Additionally, Podman
    is daemonless, so it will just create a child process.
  prefs: []
  type: TYPE_NORMAL
- en: Running rootless containers in Podman is pretty straightforward and, as we saw
    in the previous chapters, many of the examples in this book can be run as standard
    unprivileged users. Now, let's learn what's behind the execution of a rootless
    container.
  prefs: []
  type: TYPE_NORMAL
- en: The Podman Swiss Army knife – subuid and subgid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Modern Linux distributions use a version of the `shadow-utils` package that
    leverages two files: `/etc/subuid` and `/etc/subgid`. These files are used to
    determine which UIDs and GIDs can be used to map a user namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: The default allocation for every user is 65536 UIDs and 65536 GIDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the following simple command to check how the subuid and subgid
    allocation works in rootless containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, both files indicate that they start mapping UID and GID 0 with
    the current user's UID/GID that we just run the container with; that is, `1000`.
    After that, it maps UID and GID 1, starting from `100000` and arriving at `165536`.
    This is calculated by summing the starting point, `100000`, and the default range,
    `65536`.
  prefs: []
  type: TYPE_NORMAL
- en: Using rootless containers is not the only best practice we can implement for
    our container environments. In the next section, we'll learn why we shouldn't
    run a container with UID 0.
  prefs: []
  type: TYPE_NORMAL
- en: Do not run containers with UID 0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Container runtimes can be instructed to perform running processes inside a container
    with a user ID that's different from the one that initially created the container,
    similar to what we saw for rootless containers. Running the container's processes
    as a non-root user can be helpful for security purposes. For example, using an
    unprivileged user in a container could limit the attack surface inside and outside
    that container.
  prefs: []
  type: TYPE_NORMAL
- en: By default, a Dockerfile and Containerfile may set the default user as root
    (that is, UID=0). To avoid this, we can leverage the USER instruction in those
    build files – for example, `USER 1001` – to instruct Buildah or other container
    build tools to build and run the container image using that particular user (with
    UID 1001).
  prefs: []
  type: TYPE_NORMAL
- en: If we want to force a specific UID, we need to adjust the permissions of any
    file, folder, or mount we plan to use with our running containers.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's learn how to adapt an existing image so that it can be run with a
    standard user.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can leverage some prebuilt images on DockerHub or pick one of the official
    Nginx container images. First, we need to create a basic `nginx` configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `nginx` configuration file is really simple: we define the listening port
    (80) and the content message to return once a request arrives on the server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can create a simple Dockerfile to leverage one of the official Nginx
    container images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The Dockerfile contains three instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM`: For selecting the official Nginx image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN`: For cleaning the configuration directory from any default config example'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADD`: For copying the configuration file we just created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s build the container image with Buildah:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve built the image, name it `nginx-root`. Now, we are ready to run
    our container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we used the`–p` option to publish the port and make it reachable from
    the host. Let''s find out what local port has been chosen, randomly, in the host
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s call our containerized web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The container is finally running, but what user is using our container? Let''s
    find out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the container is running as root!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s make a few edits to change the user. First, we need to change the
    listening port in the Nginx server configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we replaced the listening port (`80`) with `8080`; we cannot use a port
    that's below `1024` with unprivileged users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to edit our Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we fixed the permissions for the main file and folder on the
    Nginx server, exposed the new `8080` port, and set the default user to an Nginx
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are ready to build a brand-new container image. Let''s call it `nginx-user`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the associated random host port and check whether the web server is working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s see whether we changed the user that''s running the target
    process in our container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our container is running as an unprivileged user, which is what
    we wanted.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to look at a ready-to-use example of this, please go to this book''s
    GitHub repository: [https://github.com/PacktPublishing/Podman-for-DevOps](https://github.com/PacktPublishing/Podman-for-DevOps).'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, security is not all about permissions and users – we also need
    to take care of the base image and its source and check container image signatures.
    We'll learn about this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Signing our container images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we're dealing with images that have been pulled from external registries,
    we will have some security concerns related to the potential attack tactics that
    have been conducted on the containers (see [*1*] in the *Further reading* section),
    especially masquerading techniques, which help the attacker manipulate image components
    to make them appear legitimate. This could also happen due to a **man-in-the-middle**
    (**MITM**) attack being conducted by an attacker over the wire.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent certain kinds of attacks while you're managing containers, the best
    solution is to use a detached image signature to trust the image provider and
    guarantee its reliability.
  prefs: []
  type: TYPE_NORMAL
- en: '**GNU Privacy Guard** (**GPG**) is a free implementation of the OpenPGP standard
    and can be used, together with Podman, to sign images and check their valid signatures
    once they''ve been pulled.'
  prefs: []
  type: TYPE_NORMAL
- en: When an image is pulled, Podman can verify the validity of the signatures and
    reject images without valid signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's learn how to implement a basic image signature workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Signing images with GPG and Podman
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will create a basic GPG key pair and configure Podman to
    push and sign the image while storing the signature in a staging store. For the
    sake of clarity, we will run a registry using the basic Docker Registry V2 container
    image without any customization.
  prefs: []
  type: TYPE_NORMAL
- en: Before testing the image pull and signature validation workflow, we will expose
    a basic web server to publish the detached signature.
  prefs: []
  type: TYPE_NORMAL
- en: To create image signatures with GPG, we need to create a valid GPG key pair
    or use an existing one. For this reason, we will provide a short recap on GPG
    key pairs to help you understand how image signatures work.
  prefs: []
  type: TYPE_NORMAL
- en: A key pair is composed of a private key and a public key. The public key can
    be shared universally, while the private key is kept private and never shared
    with anybody. The public key that belongs to the receiver can be used by the sender
    of a file or message to sign it. In this way, only the owner of the private key
    (that is, the receiver) will be able to decrypt the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily translate this concept into container images: the image owner
    that pushes it to the remote registry can sign it using a key pair and store the
    detached signature on a store (from now on, *sigstore*) that is publicly accessible
    by users. Here, the signature is separated by the image itself – the registry
    will store the image blobs while the sigstore will hold and expose the image signatures.'
  prefs: []
  type: TYPE_NORMAL
- en: Users who are pulling the image will be able to validate the image signature
    using the previously shared public key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s go back to creating the GPG key pair. We are going to create a
    simple one with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will ask you a series of questions and provide a passphrase
    to help you generate the key pair. By default, this will be stored in the `$HOME/.gnupg`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key pair''s output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to export generated key pairs. The following command will
    export the public key to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This command will be useful later when we define the image signature's verification.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command can be used to export the private key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In both examples, the `--armor` option has been used to export the keys in **Privacy
    Enhanced Mail** (**PEM**) format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the key pair has been generated, we can create a basic registry that will
    host our container images. To do so, we will reuse the basic example from [*Chapter
    9*](B17908_09_epub.xhtml#_idTextAnchor167), *Pushing Images to a Container Registry*,
    and run the following command as root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We now have a local registry without authentication that can be used to push
    the test images. As we mentioned previously, the registry is unaware of the image's
    detached signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Podman must be able to write signatures on a staging sigstore. There is already
    a default configuration in the `/etc/containers/registries.d/default.yaml` file,
    which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `sigstore-staging` path is where Podman writes image signatures; it must
    write them to a writable folder. It is possible to customize this path or keep
    the default configuration as-is.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to create multiple user-related sigstores, we can create the `$HOME/.config/containers/registries.d/default.yaml`
    files and define a custom `sigstore-staging` path in the user's home directory,
    following the same syntax that was shown in the previous example. This will allow
    users to run Podman in rootless mode and successfully write to their sigstore.
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs: []
  type: TYPE_NORMAL
- en: It is not a good idea to share the default `sigstore` across all users by allowing
    general write permissions. This is because every user in the host would have write
    access to the existing signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Since we want to use the default sigstore while still using the default GPG
    key pair under the user's home directory, we will run Podman by elevating privileges
    with `sudo`, an exception to the approach that this book follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the Dockerfile of a custom `httpd` image that''s
    been built using UBI 8:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter11/image_signature/Dockerfile
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To build the image, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can tag the image with the local registry name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it''s time to push the image on the temporary registry and sign it
    using the generated key pair. The `--sign-by` option allows users to pass a valid
    key pair that''s been identified by the user''s email:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code successfully pushed the image blobs to the registry and stored
    the image signature. Notice the `GNUPGHOME` variable, which was passed at the
    beginning of the command to define the GPG keystore path that's accessed by Podman.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The `--sign-by` option is not supported on the remote Podman client.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that the image has been signed correctly and that its signature is
    being saved in the sigstore, we can check the content of `/var/lib/containers/sigstore`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you will see, the new directory contains the image signature file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have successfully pushed and signed the image, making it more
    secure for future use. Now, let's learn how to configure Podman to retrieve signed
    images.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Podman to pull signed images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To successfully pull a signed image, Podman must be able to retrieve the signature
    from a sigstore and have access to a public key to verify the signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we are dealing with detached signatures, and we have already learned
    that the registry doesn''t hold any information about image signatures. For this
    reason, we need to make them available to users with a publicly accessible sigstore:
    a web server (Nginx, Apache httpd, and so on) will be a good fit.'
  prefs: []
  type: TYPE_NORMAL
- en: Since the signing host will be the same as the one used to test image pulls,
    we will run an Apache httpd server that exposes the sigstore staging folder as
    the server document root. In a real-life scenario, we would move the signatures
    to a dedicated web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we will use the standard `docker.io/library/httpd` image
    and run the container with root privileges to grant access to the sigstore folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The web server is now available at `http://localhost:8080` and can be used by
    Podman to retrieve image signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's configure Podman for image pulling. First, we must configure the
    default image sigstore. We have already defined the staging sigstore that's used
    by Podman to write a signature, so now, we need to define the sigstore that's
    used to read image signatures.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we must edit the `/etc/containers/registries.d/default.yaml` file
    one more time and add a reference to the default sigstore web server that''s running
    on `http://localhost:8080`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code configures the sigstore that''s used by Podman for all images.
    However, it is possible to add more sigstores for specific registries by populating
    the *docker* field of the file. The following code configures the sigstore for
    the public Red Hat registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Before we test the image pulls, we must implement the public key that's used
    by Podman to verify the signatures. This public key must be stored in the host
    that pulls the image and belongs to the key pair that's used to sign the image.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration file that's used to define the public key's path is `/etc/containers/policy.json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the `/etc/containers/policy.json` file with a custom
    configuration for the registry''s `localhost:5000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To verify the signatures of images that have been pulled from `localhost:5000`,
    we can use a public key that's stored in the path defined by the `keyPath` field.
    The public key must exist in the defined path and be readable by Podman.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to extract the public key from the example key pair that was generated
    at the beginning of this section, we can use the following GPG command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to test the image pull and verify its signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The image was successfully pulled into the local store after signature verification
    using the public key provided.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how Podman behaves when it is unable to correctly verify the
    signature.
  prefs: []
  type: TYPE_NORMAL
- en: Testing signature verification failures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What if we make the sigstore unavailable? Will Podman still succeed in pulling
    the image if it''s unable to verify the signature? Let''s try to stop the local
    httpd server that exposes the sigstore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Before pulling it again, let''s remove the previously cached image to avoid
    false positives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can try to pull the image again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The preceding error demonstrates that Podman is trying to connect to the web
    server that exposes the sigstore and failed. This error blocked the whole image
    pull process.
  prefs: []
  type: TYPE_NORMAL
- en: 'A different error occurs when the public key we use to verify the signature
    is not valid or not part of the key pair that was used to sign the image. To test
    this, let''s replace the public key with another one from a different key pair
    – in this example, the public Fedora 34 RPM-GPG key, which has been taken from
    the `/etc/pki/rpm-gpg` directory (any other public key can be used):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The previously stopped httpd server must be restarted; we want to make the
    signatures available and focus on the wrong public key error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can pull the image again and inspect the generated errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, Podman generates an error that's caused by an invalid GPG signature, which
    is correct since the public key that's being used does not belong to the correct
    key pair.
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget to restore the valid public key before proceeding with the following
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Podman can manage multiple registries and sigstores, and also offers dedicated
    commands to help you customize security policies, as we'll see in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Managing keys with Podman image trust commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible to edit the `/etc/containers/policy.json` file and modify its
    JSON objects to add or remove configurations for dedicated registries. However,
    manual editing can be prone to errors and hard to automate.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can use the `podman image trust` command to dump or modify
    the current configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to print the current configuration with the `podman
    image trust show` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: It is also possible to configure new trusts. For example, we can add the Red
    Hat public GPG key to check the signature of UBI images.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to download the Red Hat public key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Red Hat's product signing keys, including the one that was used in this example,
    can be found at [https://access.redhat.com/security/team/key](https://access.redhat.com/security/team/key).
  prefs: []
  type: TYPE_NORMAL
- en: 'After downloading the key, we must configure the image trust for UBI 8 images
    that have been pulled from *registry.access.redhat.com* using the `podman image
    trust set` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the preceding command, the `/etc/containers/policy.json` file
    will change, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note that the entry that's related to *registry.access.redhat.com/ubi8* and
    the public key that was used to verify the image signatures have been added to
    the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the configuration, we need to add the Red Hat sigstore configuration
    to the `/etc/containers/registries.d/default.yaml` configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to create custom registry configuration files for different providers
    in the `/etc/containers/registries.d` folder. For example, the preceding example
    could be defined in a dedicated `/etc/containers/registries.d/redhat.yaml` file.
    This allows you to easily maintain and version registry sigstore configurations.
  prefs: []
  type: TYPE_NORMAL
- en: From now on, every time a UBI8 image is pulled from *registry.access.redhat.com*,
    its signature will be pulled from the Red Hat sigstore and validated using the
    provided public key.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have looked at examples of managing keys concerning Podman, but it
    is also possible to manage signature verification with Skopeo. In the next subsection,
    we are going to look at some basic examples.
  prefs: []
  type: TYPE_NORMAL
- en: Managing signatures with Skopeo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can verify an image signature using Skopeo when we're pulling an image from
    a valid transport.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses the `skopeo copy` command to pull the image from
    our registry to the local store. This command has the same effects as using a
    `podman pull` command but allows more control over the source and destination
    transports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Skopeo does not need any further configuration since the previously modified
    configuration files already define the sigstore and public key path.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use Skopeo to sign an image before copying it to a transport:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the configuration files that are used by Podman are still valid
    for Skopeo, which uses the same sigstore to write the signatures and the same
    GPG store to retrieve the key that's used to generate the signature.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to verify image signatures and avoid potential
    MITM attacks. In the next section, we'll shift focus and learn how to execute
    the container runtime by customizing Linux kernel capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing Linux kernel capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Capabilities are features that were introduced in Linux kernel 2.2 with the
    purpose of splitting elevated privileges into single units that can be arbitrarily
    assigned to a process or thread.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of running a process as a fully privileged instance with effective UID
    0, we can assign a limited subset of specific capabilities to an unprivileged
    process. By providing more granular control over the security context of the process's
    execution, this approach helps mitigate potential attack tactics.
  prefs: []
  type: TYPE_NORMAL
- en: Before we discuss the capabilities of containers, let's recap on how they work
    in a Linux system so that we understand their inner logic.
  prefs: []
  type: TYPE_NORMAL
- en: Capabilities quickstart guide
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Capabilities are associated with the file executables using extended attributes
    (see `man xattr`) and are automatically inherited by the process that's executed
    with an `execve()` system call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of available capabilities is quite large and still growing; it includes
    very specific actions that can be performed by a thread. Some basic examples are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CAP_CHOWN**: This capability allows a thread to modify a file''s UID and
    GID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CAP_KILL**: This capability allows you to bypass the permission checks to
    send a signal to a process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mknod()` syscall.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CAP_NET_ADMIN**: This capability allows you to operate various privileged
    actions on the system''s network configuration, including changing the interface
    configuration, enabling/disabling promiscuous mode for an interface, editing routing
    tables, and enabling/disabling multicasting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CAP_NET_RAW**: This capability allows a thread to use RAW and PACKET sockets.
    This capability can be used by programs such as ping to send ICMP packets without
    the need for elevated privileges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chroot()` syscall and change mount namespaces with the `setns()` syscall.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CAP_DAC_OVERRIDE**: This capability allows you to bypass **discretionary
    access control** (**DAC**) checks for file read, write, and execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more details and an extensive list of available capabilities, see the relevant
    man page (`man capabilities`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To assign a capability to an executable, we can use the `setcap` command, as
    shown in the following example, where `CAP_NET_ADMIN` and `CAP_NET_RAW` are being
    permitted in the `/usr/bin/ping` executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The '*+p*' flag in the preceding command indicates that the capabilities have
    been set to *Permitted*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To inspect the capabilities of a file, we can use the `getcap` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: See `man getcap` and `man setcap` for more details about these utilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can inspect the active capabilities of a running process by looking at the
    `/proc/<PID>/status` file. In the following code, we are launching a `ping` command
    after setting the `CAP_NET_ADMIN` and `CAP_NET_RAW` capabilities. We want to launch
    the process in the background and check its current capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are interested in evaluating the bitmap in the `CapPrm` field, which
    represents the permitted capabilities. To get a user-friendly value, we can use
    the `capsh` command to decode the bitmap hex value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The result is similar to the output of the `getcap` command in the `/usr/bin/ping`
    file, demonstrating that executing the command propagated the file's permitted
    capabilities to its process instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a full list of the constants that were used to set the bitmaps, as well
    as their capabilities, see the following kernel header file: [https://github.com/torvalds/linux/blob/master/include/uapi/linux/capability.h](https://github.com/torvalds/linux/blob/master/include/uapi/linux/capability.h).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Distributions such as RHEL and CentOS use the preceding configuration to allow
    the ping to send ICMP packets with access from all users without them being executed
    as privileged processes with *setuid 0*. This is an insecure approach where an
    attacker could leverage a vulnerability or bug in the executable to escalate privileges
    and gain control of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Fedora introduced a new and more secure approach in version 31 that's based
    on using the `net.ipv4.ping_group_range` Linux kernel parameter. By setting an
    extensive range that covers all system groups, this parameter allows users to
    send ICMP packets without the need to enable the `CAP_NET_ADMIN` and `CAP_NET_RAW`
    capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more details, see the following wiki page from the Fedora Project: [https://fedoraproject.org/wiki/Changes/EnableSysctlPingGroupRange](https://fedoraproject.org/wiki/Changes/EnableSysctlPingGroupRange).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've provided a high-level description of the Linux kernel's capabilities,
    let's learn how they are applied to containers.
  prefs: []
  type: TYPE_NORMAL
- en: Capabilities in containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Capabilities can be applied inside containers to allow targeted actions to
    take place. By default, Podman runs containers using a set of Linux kernel capabilities
    that are defined in the `/usr/share/containers/containers.conf` file. At the time
    of writing, the following capabilities are enabled inside this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run a simple test to verify that those capabilities have been effectively
    applied to a process running inside a container. For this test, we will use the
    official Nginx image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have extracted the current capabilities from the parent Nginx process
    (running with PID 1 inside the container). Now, we can check the bitmap with the
    `capsh` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The preceding list of capabilities is the same as the list that was defined
    in the default Podman configuration. Note that the capabilities are applied in
    both rootless and rootful mode.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you're curious, the capabilities for the containerized process(es) are set
    up by the container runtime, which is either `runc` or `crun`, based on the distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how capabilities are configured and applied inside containers,
    let's learn how to customize a container's capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing a container's capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can add or drop capabilities either at runtime or statically.
  prefs: []
  type: TYPE_NORMAL
- en: To statically change the default capabilities, we can simply edit the *default_capabilities*
    field in the `/usr/share/containers/containers.conf` file and add or remove them
    according to our desired results.
  prefs: []
  type: TYPE_NORMAL
- en: To modify capabilities at runtime, we can use the `–cap-add` and `–cap-drop`
    options, both of which are provided by the `podman run` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code removes the `CAP_DAC_OVERRIDE` capability from a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the capability bitmaps again, we will see that they were updated
    accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to pass the `--cap-add` and `--cap-drop` options multiple times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'When we''re dealing with capabilities, we must be careful while dropping a
    default capability. The following code shows an error in the Nginx container when
    dropping the `CAP_CHOWN` capability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Here, the container fails. From the output, we can see that the Nginx process
    was unable to show the `/var/cache/nginx/client_temp` directory. This is a direct
    consequence of the `CAP_CHOWN` capability being removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not all capabilities can be applied to rootless containers. For example, if
    we try to apply the `CAP_MKNOD` capability to a rootless container, any attempt
    to create a special file inside a rootless container won''t be allowed by the
    kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, if we run the container with elevated root privileges, the capability
    can be assigned successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Generally, adding capabilities to containers implies enlarging the potential
    attack surface that a malicious attacker could use. If it's not necessary, it
    is a good practice to keep the default capabilities and drop the unwanted ones
    once the potential side effects have been analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to manage capabilities inside containers. However,
    capabilities are not the only security aspect to consider when you're securing
    containers. SELinux, as we will learn in the next section, has a crucial role
    in guaranteeing container isolation.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux interaction with containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss SELinux policies and introduce **Udica**, a
    tool that's used to generate SELinux profiles for containers.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux works directly in kernel space and manages object isolation while following
    a least-privilege model that contains a series of **policies** that can handle
    enforcing or exceptions. To define these objects, SELinux uses labels that define
    **types**. By default, SELinux works in **Enforcing** mode, denying access to
    resources with a series of exceptions defined by policies. To disable Enforcing
    mode, SELinux can be put in **Permissive** mode, where violations are only audited,
    without them being blocked.
  prefs: []
  type: TYPE_NORMAL
- en: Security Alert
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, switching SELinux to Permissive mode or completely
    disabling it is *not a good practice* as it opens you up to potential security
    threats. Instead of doing that, users should create custom policies to manage
    the necessary exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: By default, SELinux uses a **targeted** policy type, which tries to target and
    confine specific object types (processes, files, devices, and so on) using a set
    of predefined policies.
  prefs: []
  type: TYPE_NORMAL
- en: 'SELinux allows different kinds of access control. They can be summarized as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Type Enforcement** (**TE**): This controls access to resources according
    to process and file types. This is the main use case of SELinux access control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Role-Based Access Control** (**RBAC**): This controls access to resources
    using SELinux users (which can be mapped to real system users) and their associated
    SELinux roles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-Level Security** (**MLS**): This grants all processes with the same
    sensitivity level read/write access to the resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-Category Security** (**MCS**): This controls access using **categories**,
    which are plain text labels that are applied to resources. Categories are used
    to create compartments of objects, along with the other SELinux labels. Only processes
    that belong to the same category can access a given resource. In [*Chapter 5*](B17908_05_epub.xhtml#_idTextAnchor101),
    *Implementing Storage for the Container''s Data*, we discussed MCS and how we
    can map categories to resources that have been accessed by containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With Type Enforcement, the system files receive labels called **types**, while
    processes receive labels called **domains**. A process that belongs to a domain
    can be allowed to access a file that belongs to a given type, and this access
    can be audited by SELinux.
  prefs: []
  type: TYPE_NORMAL
- en: For example, according to SELinux, the Apache `httpd` process, which is labeled
    with the `httpd_t` domain, can access files or directories with `httpd_sys_content_t`
    labels.
  prefs: []
  type: TYPE_NORMAL
- en: 'An SELinux-type policy is based on the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Here, `POLICY` is the kind of policy (`allow`, `allowxperm`, `auditallow`, `neverallow`,
    `dontaudit`, and so on), `DOMAIN` is the process domain, `TYPE` is the resource
    type context, `CLASS` is the object category (for example, `file`, `dir`, `lnk_file`,
    `chr_file`, `blk_file`, `sock_file`, or `fifo_file`), and `OPERATION` is a list
    of actions that are handled by the policy (for example, `open`, `read`, `use`,
    `lock`, `getattr`, or `revc`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a basic `allow` rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the process that's running in the `myapp_t` domain is allowed
    to access files of the `myapp_log_t` type and perform the `read_file_perms` and
    `append_file_perms` actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'SELinux manages policies in a modular fashion, allowing you to dynamically
    load and unload policy modules without the need to recompile the whole policy
    set every time. Policies can be loaded and unloaded using the `semodule` utility,
    as shown in the following example, which shows an example of loading a custom
    policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `semodule` utility can also be used to view all the loaded policies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: On Fedora, CentOS, RHEL, and derivate distributions, the current binary policy
    is installed under the `/etc/selinux/targeted/policy` directory in a file named
    `polixy.XX`, with `XX` representing the policy version.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the same distributions, container policies are defined inside the `container-selinux`
    package, which contains the already compiled SELinux module. The source code of
    the package is available on GitHub if you wish to look at it in more detail: [https://github.com/containers/container-selinux](https://github.com/containers/container-selinux).'
  prefs: []
  type: TYPE_NORMAL
- en: 'By looking at the repository''s content, we will find the three most important
    policy source files for developing any module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`container.fc`: This file defines the files and directories that are bound
    to the types defined in the module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container.te`: This file defines the policy rules, attributes, and aliases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container.if`: This file defines the module interface. It contains a set of
    public macro functions that are exposed by the module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A process that's running inside a container is labeled with the `container_t`
    domain. It has read/write access to resources labeled with the `container_file_t`
    type context and read/execute access to resources labeled with the `container_share_t`
    type context.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a container is executed, the `podman` process, as well as the container
    runtime and the `conmon` process, run with the `container_runtime_t` domain type
    and are allowed to execute processes that transition only to specific types. Those
    types are grouped in the `container_domain` attribute and can be inspected with
    the `seinfo` utility (installed with the `setools-console` package on Fedora),
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The `container_domain` attribute is declared in the `container.te` source file
    in the `container-policy` repository using the **attribute** keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding attributes are mapped to the `container_t` type using a `typeattribute`
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Using this approach, SELinux guarantees process isolations across containers
    and between a container and its host. In this way, a process escaping the container
    (maybe exploiting a vulnerability) cannot access resources on the host or inside
    other containers.
  prefs: []
  type: TYPE_NORMAL
- en: When a container is created, the image's read-only layers, which form the OverlayFS
    set of LowerDirs, are labeled with the `container_ro_file_t` type, which prevents
    the container from writing inside those directories. At the same time, MergedDir,
    which is the sum of LowerDirs and UpperDir, is writable and labeled as `container_file_t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prove this, let''s run a `c1` and `c2` MCS categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can find all the files labeled as `container_file_t:s0:c1,c2` under
    the host filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the `container_file_t` label, which is associated with the `c1`
    and `c2` categories, is applied to all the files under the MergedDir container.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the same time, we can demonstrate that the container''s LowerDirs are labeled
    as `container_ro_file_t`. First, we need to extract the container''s LowerDirs
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The rightmost directory represents the container''s lowest layer and is usually
    the base filesystem tree of the image. Let''s inspect the type context of this
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output also shows another interesting aspect: since the LowerDir
    layers are shared across multiple containers that use the same image, we won''t
    find any MCS categories that have been applied here.'
  prefs: []
  type: TYPE_NORMAL
- en: Containers do not have read/write access to files or directories that are not
    labeled as `container_file_t`. Previously, we saw that it is possible to relabel
    those files by applying the `:z` suffix to mounted volumes or by manually relabeling
    them in advance before running the containers.
  prefs: []
  type: TYPE_NORMAL
- en: However, relabeling crucial directories such as `/home` or `/var/logs` is a
    very bad idea since many other non-containerized processes won't be able to access
    them anymore.
  prefs: []
  type: TYPE_NORMAL
- en: The only solution is to manually create custom policies that override the default
    behavior. However, this is too complex to manage in everyday use and production
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, we can solve this limitation with a tool that generates custom SELinux
    security profiles for our containers: **Udica**.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Udica
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Udica is an open source project ([https://github.com/containers/udica](https://github.com/containers/udica))
    that was created by Lukas Vrabec, SELinux evangelist and team leader of the SELinux
    and Security Special Projects engineering teams at Red Hat.
  prefs: []
  type: TYPE_NORMAL
- en: Udica aims to overcome the rigid policy limitations that were described previously
    by generating SELinux profiles for containers and allowing them to access resources
    that would normally be prevented with the common `container_t` domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Udica on Fedora, simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'On other distributions, Udica can be installed from its source by running the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: To demonstrate how Udica works, we are going to create a container that writes
    to the `/var/log` directory of the host, which is bind-mounted when the container
    is created. By default, the process with the `container_t` domain would not be
    able to write a directory labeled with the `var_log_t` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script, which has been executed inside the container, is an endless
    loop that writes a log line composed of the current date and a counter:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter11/custom_logger/logger.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The preceding script uses the `set -euo pipefail` option, to exit immediately
    in case an error occurs, and the `tee` utility, to write both to standard output
    and the `/var/log/custom.log` file in append mode. The `count` variable increments
    on each loop cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Dockerfile for this container is kept minimal – it just copies the logger
    script and executes it at container startup:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter11/custom_logger/Dockerfile
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Important
  prefs: []
  type: TYPE_NORMAL
- en: The `logger.sh` script must be executed before the build so that it can be launched
    correctly at container startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'The container image is built with the name `custom_logger`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to test the container and see how it behaves. The `/var/log`
    directory is bind-mounted with `rw` permissions to the container''s `/var/log`,
    without this altering its type context. We should keep the execution in the foreground
    to see the immediate output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the script failed to write to the target file. We could fix this
    by changing the directory type context to `container_file_t` but, as we learned
    previously, this is a poor idea since it would prevent other processes from writing
    their logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we can use Udica to generate a custom SELinux security profile for
    the container. In the following code, the container specs are exported to a `container.json`
    file and then parsed by Udica to generate a custom profile called *custom_logger*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Once the profile has been generated, Udica outputs the instructions to configure
    the container. First, we need to load the new custom policy using the `semodule`
    utility. The generated file is in `/usr/share/udica/templates/base_container.cil`
    and `/usr/share/udica/templates/log_container.cil`, whose rules are inherited
    in the custom container policy file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s load the modules using the suggested command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'After loading the modules in SELinux, we are ready to run the container with
    the custom `custom_logger.process` label, passing it as an argument to the Podman
    `--security-opt` option. The other container option was kept identical, except
    for its name, which has been updated to `custom_logger2` to differentiate it from
    the previous instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This time, the script successfully wrote to the `/var/log/custom.log` file thanks
    to the custom profile that was generated with Udica.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the container processes are not running with the `container_t` domain,
    but with the new `custom_logger.process` superset, which includes additional rules
    on top of the default.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can confirm this by running the following command on the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Udica creates the custom policy by parsing the JSON spec file and looking for
    the container mount points, ports, and capabilities. Let''s look at the content
    of the generated `custom_logger.cil` file from our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The CIL language syntax is beyond the scope of this book, but we still can
    notice some interesting things:'
  prefs: []
  type: TYPE_NORMAL
- en: The *custom_logger* profile is defined by a `block` statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `allow` rule enables the default capabilities for the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The policy inherits the `container` and `log_rw_container` blocks with the `blockinherit`
    statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The generated CIL file inherits the blocks that have been defined in the available
    Udica templates, each one focused on specific actions. On Fedora, the templates
    are installed via the `container-selinux` package and are available in the `/usr/share/udica/templates/`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The available templates are implemented for common scenarios, such as accessing
    log directories or user homes, or even for opening network ports. Among them,
    the `base_container.cil` template is always included by all the Udica-generated
    policies as the base building block that's used to generate the custom policies.
  prefs: []
  type: TYPE_NORMAL
- en: According to the behavior of the container that's derived from the spec file,
    other templates are included. For example, the policy inherited the `log_rw_container`
    block from the `log_container.cil` template to let the custom logger container
    access the `/var/log` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Udica is a great tool for addressing container isolation issues and helps administrators
    address SELinux confinement use cases by overcoming the complexity of writing
    rules manually.
  prefs: []
  type: TYPE_NORMAL
- en: Generated security profiles can also be versioned inside a GitHub repository
    and reused for similar containers on different hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to develop and apply techniques to improve the
    overall security of our container-based service architecture. We learned how leveraging
    rootless containers and avoiding UID 0 can reduce the attack surface of our services.
    Then, we learned how to sign and trust container images to avoid MITM attacks.
    Finally, we went under the hood of a containers' tools and looked at the Linux
    kernel's capabilities and the SELinux subsystem, which can help us fine-tune various
    security aspects for our running containers.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've done a deep dive into security, we are ready to move on to the
    next chapter, where we will take an advanced look at networking for containers.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information about the topics that were covered in this chapter, take
    a look at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'MITRE ATT&CK Container Matrix: [https://attack.mitre.org/matrices/enterprise/containers/](https://attack.mitre.org/matrices/enterprise/containers/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GNU Privacy Guard: [https://gnupg.org/](https://gnupg.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RFC4880 – OpenPGP standard: [https://www.rfc-editor.org/info/rfc4880](https://www.rfc-editor.org/info/rfc4880)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Podman image signing tutorial: [https://github.com/containers/podman/blob/main/docs/tutorials/image_signing.md](https://github.com/containers/podman/blob/main/docs/tutorials/image_signing.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lukas Vrabec''s blog: [https://lukas-vrabec.com/](https://lukas-vrabec.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CIL introduction and design principles: [https://github.com/SELinuxProject/cl/wiki](https://github.com/SELinuxProject/cl/wiki)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Udica introduction on Red Hat''s blog: [https://www.redhat.com/en/blog/generate-selinux-policies-containers-with-udica](https://www.redhat.com/en/blog/generate-selinux-policies-containers-with-udica)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
