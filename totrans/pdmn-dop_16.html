<html><head></head><body>
		<div id="_idContainer052">
			<h1 id="_idParaDest-243"><em class="italic"><a id="_idTextAnchor243"/>Chapter 13</em>: Docker Migration Tips and Tricks</h1>
			<p>Every technology has a pioneer company, project, and product that, once created and announced, becomes a real game-changer that allowed its base concepts to spread. For containers, this was Docker. </p>
			<p>As we learned in <a href="B17908_01_epub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to Container Technology</em>, Docker provided a new approach and great ideas to leveraging existing technologies and creating brand new ones. After a few years, it became the most used technology for containers.</p>
			<p>But as usually happens for open source projects, the community and the enterprise started looking for improvements, new architectures, and different implementations. That's where Podman found a place to grow and leverage the standardization that's offered by the <strong class="bold">Open Container Initiative</strong> (<strong class="bold">OCI</strong>).</p>
			<p>Docker was (and still is) the most used container technology. For this reason, in this chapter, we are going to provide some tips and tricks regarding handling the migration process. We will be covering the following topics:</p>
			<ul>
				<li>Migrating existing images and playing with a command's alias</li>
				<li>Podman commands versus Docker commands</li>
				<li>Using Docker Compose with Podman</li>
			</ul>
			<h1 id="_idParaDest-244"><a id="_idTextAnchor244"/>Technical requirements</h1>
			<p>Before you proceed with this chapter's lecture and examples, you will need a machine with a working Podman installation. As we mentioned in <a href="B17908_03_epub.xhtml#_idTextAnchor068"><em class="italic">Chapter 3</em></a>, <em class="italic">Running the First Container</em>, all the examples in this book have been executed on a Fedora 34 system or later but can be reproduced on your choice of <strong class="bold">operating system</strong> (<strong class="bold">OS</strong>). </p>
			<p>Having a good understanding of the topics that were covered in <a href="B17908_04_epub.xhtml#_idTextAnchor083"><em class="italic">Chapter 4</em></a>, <em class="italic">Managing Running Containers</em>, <a href="B17908_05_epub.xhtml#_idTextAnchor101"><em class="italic">Chapter 5</em></a>, <em class="italic">Implementing Storage for the Container's Data</em>, and <a href="B17908_09_epub.xhtml#_idTextAnchor167"><em class="italic">Chapter 9</em></a>, <em class="italic">Pushing Images to a Container Registry</em>, will help you grasp the concepts that will be covered in this chapter regarding containers.</p>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor245"/>Migrating existing images and playing with a command's alias</h1>
			<p>Podman has <a id="_idIndexMarker1184"/>one great feature that lets any previous <a id="_idIndexMarker1185"/>Docker user easily adapt <a id="_idIndexMarker1186"/>and switch to it – complete <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) compatibility with Docker.</p>
			<p>Let's <a id="_idIndexMarker1187"/>demonstrate this CLI compatibility <a id="_idIndexMarker1188"/>with Docker by creating a shell command alias for the <strong class="source-inline">docker</strong> command:</p>
			<p class="source-code"># alias docker=podman</p>
			<p class="source-code"># docker</p>
			<p class="source-code">Error: missing command 'podman COMMAND'</p>
			<p class="source-code">Try 'podman --help' for more information.</p>
			<p>As you can see, we have created a command alias that binds the <strong class="source-inline">podman</strong> command to the <strong class="source-inline">docker</strong> one. If we try to execute the <strong class="source-inline">docker</strong> command after setting the alias, the output is returned from the <strong class="source-inline">podman</strong> command instead.</p>
			<p>Let's try this out on the newly created alias by running a container:</p>
			<p class="source-code"># docker run --rm -it docker.io/wernight/funbox nyancat</p>
			<p>We should see something very funny – a running cat, similar to the one shown in the following screenshot:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/B17908_13_01.jpg" alt="Figure 13.1 – Funny output from running a test container&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.1 – Funny output from running a test container</p>
			<p>Let's <a id="_idIndexMarker1189"/>test something more interesting. Docker, for <a id="_idIndexMarker1190"/>example, offers <a id="_idIndexMarker1191"/>a tutorial based on a container <a id="_idIndexMarker1192"/>image exposing a web server:</p>
			<p class="source-code"># docker run -dp 80:80 docker.io/docker/getting-started</p>
			<p class="source-code">Trying to pull docker.io/docker/getting-started:latest...</p>
			<p class="source-code">Getting image source signatures</p>
			<p class="source-code">Copying blob 97518928ae5f done  </p>
			<p class="source-code">Copying blob e0bae2ade5ec done  </p>
			<p class="source-code">Copying blob a2402c2da473 done  </p>
			<p class="source-code">Copying blob e362c27513c3 done  </p>
			<p class="source-code">Copying blob a4e156412037 done  </p>
			<p class="source-code">Copying blob 3f3577460f48 done  </p>
			<p class="source-code">Copying blob 69465e074227 done  </p>
			<p class="source-code">Copying blob eb65930377cd done  </p>
			<p class="source-code">Copying config 26d80cd96d done  </p>
			<p class="source-code">Writing manifest to image destination</p>
			<p class="source-code">Storing signatures</p>
			<p class="source-code">d44a2df41d76b3322e56971d45e92e75f4679e8b620198228fbd9 cc00fe9578f</p>
			<p>Here, we <a id="_idIndexMarker1193"/>continued to use the <strong class="source-inline">docker</strong> alias <a id="_idIndexMarker1194"/>command with <a id="_idIndexMarker1195"/>the option for running it by using a <a id="_idIndexMarker1196"/>daemon, <strong class="source-inline">–d</strong>, and the option for binding the HTTP port, <strong class="source-inline">–p</strong>.</p>
			<p>If everything worked correctly, then we can point our favorite web browser to <strong class="source-inline">http://localhost</strong>:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/B17908_13_02.jpg" alt="Figure 13.2 – Docker tutorial home page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.2 – Docker tutorial home page</p>
			<p>The first page of Dockerlabs, <strong class="bold">Getting Started</strong>, specifies the command that was just run. From the left column of the page, we can continue with the tutorial.</p>
			<p>Let's continue with the tutorial and double-check that the alias will work properly at every stage.</p>
			<p>The tutorial steps are very simple, and they can help you summarize the knowledge that was shared in the previous chapters, from building a container to using multiple container applications to create a dedicated network. Please stop before the <strong class="bold">Using Docker Compose</strong> section as we will look at this in more detail shortly.</p>
			<p>Don't forget that we are using an alias and that, under the hood, Podman is working actively to let our containers work as expected, ensuring Docker CLI compatibility.</p>
			<p>But <a id="_idIndexMarker1197"/>what about container migration <a id="_idIndexMarker1198"/>in the case of swapping Docker in favor of Podman?</p>
			<p>Well, a <a id="_idIndexMarker1199"/>direct way to move existing <a id="_idIndexMarker1200"/>containers from Docker to Podman does not exist. It is recommended that you recreate the containers with the respective container images and reattach any volumes using Podman.</p>
			<p>The container images can be exported using the <strong class="source-inline">docker export</strong> command, which will create a TAR archive file that can be imported into Podman via the <strong class="source-inline">podman import</strong> command. If you're using a container image registry, you can skip this.</p>
			<p>To understand any limitations we may encounter when we're using commands, examples, and resources written for Docker with our Podman installation, let's compare various Podman and Docker commands.</p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor246"/>Podman commands versus Docker commands</h1>
			<p>As we saw in the previous section, as well as in <a href="B17908_02_epub.xhtml#_idTextAnchor044"><em class="italic">Chapter 2</em></a>, <em class="italic">Comparing Podman and Docker</em>, the Podman CLI is based on the Docker CLI. However, because Podman <a id="_idIndexMarker1201"/>does not require a runtime daemon <a id="_idIndexMarker1202"/>to work, some of the Docker commands may not be directly available or they could require some workarounds.</p>
			<p>The command list is exceptionally long, so the following table only specifies a few:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/Table_01.jpg" alt=""/>
				</div>
			</div>
			<p>As you can see, the command's name is the same as comparing the <strong class="source-inline">docker</strong> command with the <strong class="source-inline">podman</strong> command. However, even though the name is the same, due to architectural differences between Podman and Docker, some features or behaviors could be different.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor247"/>Behavioral differences between Podman and Docker</h2>
			<p>The following <a id="_idIndexMarker1203"/>commands were intentionally <a id="_idIndexMarker1204"/>implemented in another way by the Podman development team:</p>
			<ul>
				<li><strong class="source-inline">podman volume create</strong>: This command will fail if the volume already exists. In Docker, this command is idempotent, which means that if a volume already exists with the same name, then Docker will just skip this instruction. The actual behavior of Docker does not match the implementations for the other commands.</li>
				<li><strong class="source-inline">podman run -v /tmp/noexist:/tmp</strong>: This command will fail if the source volume path does not exist. Instead, Docker will create the folder if it does not exist. Again, the Podman development team considered this a bug and changed it.</li>
				<li><strong class="source-inline">podman run --restart</strong>: The restart option in Podman will not persist after a system reboot. If required, we can run Podman from a <strong class="source-inline">systemd.unit</strong> file through <strong class="source-inline">podman generate systemd</strong>.</li>
			</ul>
			<p>In the <a id="_idIndexMarker1205"/>next section, we'll see which commands <a id="_idIndexMarker1206"/>are missing from Podman that exist in Docker.</p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor248"/>Missing commands in Podman</h2>
			<p>The following <a id="_idIndexMarker1207"/>table shows a non-comprehensive list of Docker commands that, at the time of writing, don't have equivalents in Podman:</p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/Table_02.jpg" alt=""/>
				</div>
			</div>
			<p>Now, let's see which commands are missing from Docker. </p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor249"/>Missing commands in Docker</h2>
			<p>Similar to <a id="_idIndexMarker1208"/>how Podman is missing some Docker commands, Docker is missing some Podman commands. </p>
			<p>The following families of commands in Podman don't have respective ones in Docker:</p>
			<ul>
				<li><strong class="source-inline">podman container</strong>: This command can be used to manage containers.</li>
				<li><strong class="source-inline">podman generate</strong>: This command can be used to create a structured output (such as a YAML file) for a container, pod, or volume.</li>
				<li><strong class="source-inline">podman healthcheck</strong>: This command provides you with a set of subcommands that you can use to manage container health checks.</li>
				<li><strong class="source-inline">podman image</strong>: This command can be used to manage container images.</li>
				<li><strong class="source-inline">podman init</strong>: This command can be used to initialize a container with all the required steps but without running it.</li>
				<li><strong class="source-inline">podman machine</strong>: This command lists a set of subcommands for managing Podman's virtual machine on macOS.</li>
				<li><strong class="source-inline">podman mount</strong>: This command mounts the container's root filesystem in a location that can be accessed by the host.</li>
				<li><strong class="source-inline">podman network exists/prune/reload</strong>: This command checks and manages the status of a container's network. </li>
				<li><strong class="source-inline">podman play</strong>: This command creates containers, pods, or volumes based on the input from a structured (such as YAML) file input.</li>
				<li><strong class="source-inline">podman pod</strong>: This provides a set of subcommands for managing pods or groups of containers.</li>
				<li><strong class="source-inline">podman system</strong>: This provides a set of subcommands for managing the Podman systems and retrieving information.</li>
				<li><strong class="source-inline">podman unmount</strong>: This command unmounts a working container's root filesystem.</li>
				<li><strong class="source-inline">podman unshare</strong>: This command launches a process in a new user namespace (rootless containers).</li>
				<li><strong class="source-inline">podman untag</strong>: This command removes one or more stored images.</li>
				<li><strong class="source-inline">podman volume exists</strong>: This command checks if a volume exists.</li>
			</ul>
			<p>Of course, if a <a id="_idIndexMarker1209"/>command is missing, this does not mean that the feature is missing in Docker.</p>
			<p>Another useful feature that's available in Docker is Compose. We'll learn how to use it in Podman in the next section.</p>
			<h1 id="_idParaDest-250"><a id="_idTextAnchor250"/>Using Docker Compose with Podman</h1>
			<p>When it was first released, Docker quickly gained consensus thanks to its intuitive approach <a id="_idIndexMarker1210"/>to container management. Along with the main container engine solution, another great feature was introduced to help users orchestrate multiple <a id="_idIndexMarker1211"/>containers on a single host: <strong class="bold">Docker Compose</strong>.</p>
			<p>The idea <a id="_idIndexMarker1212"/>behind Compose is quite simple – it's a tool that can be used to orchestrate multi-container applications that are supposed to interact together on a single host and configured with a declarative file in YAML format. All the applications that are executed in a Compose stack are defined as services that can communicate with the other containers in the stack with a transparent name resolution.</p>
			<p>The configuration file is named <strong class="source-inline">docker-compose.yaml</strong> and has a simple syntax where one or more <strong class="bold">services</strong> and related <strong class="bold">volumes</strong> are created and started. </p>
			<p>Development teams can benefit from the stack's automation to quickly test applications on a single host. However, if we need to run our application on a production-like, multi-node environment, the best approach is to adopt a clustered orchestration solution such as Kubernetes.</p>
			<p>When Podman was first released, its main purpose was to reach OCI full compatibility and feature parity with Docker CLI commands to become a valid daemonless alternative to the well-known container engine that inspired it. Unfortunately, this Compose compatibility was not supported in the first two major releases. Afterwards, the <strong class="source-inline">podman-compose</strong> project was introduced to fill the gap. The project was a separate development stream that needed to compensate for the lack of native Compose support in Podman.</p>
			<p>With Podman v3.0, native support for Docker Compose was finally introduced upstream, leaving users with the choice of using the original <strong class="source-inline">docker-compose</strong> utility or the new <strong class="source-inline">podman-compose</strong> utility.</p>
			<p>In this <a id="_idIndexMarker1213"/>section, we learned how to configure <a id="_idIndexMarker1214"/>Podman to orchestrate multiple containers with <strong class="source-inline">docker-compose</strong> to provide full compatibility to users migrating from Docker to Podman. In the next subsection, we'll look at an example of using <strong class="source-inline">podman-compose</strong> to leverage rootless container orchestration. </p>
			<p>Before we dig into setting up Podman, let's look at a few basic examples of Compose files to understand how they work.</p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor251"/>Docker Compose quick start</h2>
			<p>Compose files can be used to declare one or multiple containers being executed inside a common <a id="_idIndexMarker1215"/>stack and also to define build instructions for custom applications. The advantage of this approach is that you can fully automate the entire application stack, including frontends, backends, and persistence services such as databases or in-memory caches.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The purpose of this section is to provide a quick overview of Compose files to help you understand how Podman can handle them. </p>
			<p class="callout">For a detailed <a id="_idIndexMarker1216"/>list of the latest Compose specification, please refer to the following URL: <a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a>.</p>
			<p class="callout">A more extensive list of Compose examples can be found in the Docker Awesome Compose project at <a href="https://github.com/docker/awesome-compose">https://github.com/docker/awesome-compose</a>.</p>
			<p>The following is a minimal configuration file that defines a single container running the Docker registry:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Chapter13/registry/docker-compose.yaml</p>
			<p class="source-code">services:</p>
			<p class="source-code">  registry:</p>
			<p class="source-code">    ports:</p>
			<p class="source-code">      - "5000:5000"</p>
			<p class="source-code">    volumes:</p>
			<p class="source-code">      - registry_volume:/var/lib/registry</p>
			<p class="source-code">    image: docker.io/library/registry</p>
			<p class="source-code">volumes:</p>
			<p class="source-code">  registry_volume: {}</p>
			<p>The preceding example can be seen as a more structured and declarative way to define the execution <a id="_idIndexMarker1217"/>parameters for a container. However, the real value of Docker Compose is its orchestration stacks, which are made up of multiple containers in a single instance.</p>
			<p>The following example is even more interesting and shows a configuration file for a WordPress application that uses a MySQL database as its backend:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Chapter13/wordpress/docker-compose.yaml</p>
			<p class="source-code">services:</p>
			<p class="source-code">  <strong class="bold">db</strong>:</p>
			<p class="source-code">    image: docker.io/library/mysql:latest</p>
			<p class="source-code">    command: '--default-authentication-plugin=mysql_native_password'</p>
			<p class="source-code">    volumes:</p>
			<p class="source-code">      - db_data:/var/lib/mysql</p>
			<p class="source-code">    restart: always</p>
			<p class="source-code">    environment:</p>
			<p class="source-code">      - MYSQL_ROOT_PASSWORD=wordpressroot</p>
			<p class="source-code">      - MYSQL_DATABASE=wordpress</p>
			<p class="source-code">      - MYSQL_USER=wordpress</p>
			<p class="source-code">      - MYSQL_PASSWORD=wordpress</p>
			<p class="source-code">    expose:</p>
			<p class="source-code">      - 3306</p>
			<p class="source-code">      - 33060</p>
			<p class="source-code">  <strong class="bold">wordpress</strong>:</p>
			<p class="source-code">    image: docker.io/library/wordpress:latest</p>
			<p class="source-code">    ports:</p>
			<p class="source-code">      - 8080:80</p>
			<p class="source-code">    restart: always</p>
			<p class="source-code">    environment:</p>
			<p class="source-code">      - WORDPRESS_DB_HOST=db</p>
			<p class="source-code">      - WORDPRESS_DB_USER=wordpress</p>
			<p class="source-code">      - WORDPRESS_DB_PASSWORD=wordpress</p>
			<p class="source-code">      - WORDPRESS_DB_NAME=wordpress</p>
			<p class="source-code">volumes:</p>
			<p class="source-code">  db_data:</p>
			<p>Here, we can <a id="_idIndexMarker1218"/>see the two main YAML objects – <strong class="source-inline">services</strong> and <strong class="source-inline">volumes</strong>. Under the <strong class="source-inline">services</strong> part of the code, we have two applications – <strong class="source-inline">db</strong> and <strong class="source-inline">wordpress</strong>. These have been highlighted for clarity.</p>
			<p>In the <strong class="source-inline">services</strong> list, there's a set of configuration values that define the container's behavior. These are as follows:</p>
			<ul>
				<li><strong class="source-inline">image</strong>: The image that's used by the container.</li>
				<li><strong class="source-inline">command</strong>: Additional commands to be passed to the container's entry point.</li>
				<li><strong class="source-inline">Volumes</strong>: The list of volumes to be mounted in the container, along with their associated mount points. Along with new dedicated volumes, existing directories in the host can be bind-mounted on container mount points.</li>
				<li><strong class="source-inline">restart</strong>: Container restart options in case an error occurs.</li>
				<li><strong class="source-inline">expose</strong>: The list of ports to be exposed by the container.</li>
				<li><strong class="source-inline">ports</strong>: The list of port mappings between the container and the host.</li>
				<li><strong class="source-inline">environment</strong>: The list of environment variables to be created in the container. In this example, <strong class="source-inline">WORDPRESS_DB_HOST</strong>, <strong class="source-inline">WORDPRESS_DB_USER</strong>, <strong class="source-inline">WORDPRESS_DB_PASSWORD</strong>, <strong class="source-inline">WORDPRESS_DB_NAME</strong>, are injected into the WordPress container to provide connection parameters to the database.</li>
			</ul>
			<p>Together with the <a id="_idIndexMarker1219"/>service's declaration, we have a list of volumes that are managed by Compose. The engine can create these volumes in the Compose process or use existing volumes that have been labeled as <strong class="source-inline">external</strong>.</p>
			<p>The third and final example is a Compose file that builds a minimal REST API application that's been written in Go that writes and retrieves data to a Redis in-memory store:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Chapter13/golang-redis/docker-compose.yaml</p>
			<p class="source-code">services:</p>
			<p class="source-code">  web:</p>
			<p class="source-code">    build: </p>
			<p class="source-code">      context: ./app</p>
			<p class="source-code">      labels: </p>
			<p class="source-code">        - "com.example.description=Golang Redis App"</p>
			<p class="source-code">    ports: </p>
			<p class="source-code">      - "8080:8080"</p>
			<p class="source-code">    environment:</p>
			<p class="source-code">      - REDIS_HOST=redis</p>
			<p class="source-code">    depends_on:</p>
			<p class="source-code">      - redis</p>
			<p class="source-code">  redis:</p>
			<p class="source-code">    image: docker.io/library/redis</p>
			<p class="source-code">    deploy:</p>
			<p class="source-code">      replicas: 1</p>
			<p>In this example, we have <a id="_idIndexMarker1220"/>new elements that deserve attention:</p>
			<ul>
				<li>A <strong class="source-inline">build</strong> object, which defines the image to be built and also applies custom labels to the build.</li>
				<li>The <strong class="source-inline">context</strong> key holds the path for the build. In this example, the <strong class="source-inline">./app</strong> folder contains all the source code files and the Dockerfile for building the image.</li>
				<li>A <strong class="source-inline">labels</strong> list, which holds a set of labels that are passed as strings in the build process.</li>
				<li>A <strong class="source-inline">depends_on</strong> list that specifies, for the web service, the other services that are considered dependencies; in this case, the <strong class="source-inline">redis</strong> service.</li>
				<li>An <strong class="source-inline">environment</strong> list that defines the name of the <strong class="source-inline">redis</strong> service that's used by the web app. </li>
				<li>A <strong class="source-inline">deploy</strong> object in the <strong class="source-inline">redis</strong> service that lets us define custom configuration parameters, such as the number of container <strong class="source-inline">replicas</strong>.</li>
			</ul>
			<p>To bring up Compose applications with Docker, we can run the following command from the <strong class="source-inline">compose</strong> file's folder:</p>
			<p class="source-code">$ docker-compose up</p>
			<p>This command creates all the stack and related volumes while printing the output to <strong class="source-inline">stdout</strong>.</p>
			<p>To run in detached mode, simply add the <strong class="source-inline">-d</strong> option to the command:</p>
			<p class="source-code">$ docker-compose up -d</p>
			<p>The following command builds the necessary images and starts the stack:</p>
			<p class="source-code">$ docker-compose up --build</p>
			<p>Alternatively, the <strong class="source-inline">docker-compose build</strong> command can be used to build the applications without starting them.</p>
			<p>To shut down <a id="_idIndexMarker1221"/>a stack running in the foreground, simply hit the <em class="italic">Ctrl</em> + <em class="italic">C</em> keyboard combination. Instead, to shut down a detached application, run the following command:</p>
			<p class="source-code">$ docker-compose down</p>
			<p>To kill an unresponsive container, we can use the <strong class="source-inline">docker-compose kill</strong> command:</p>
			<p class="source-code">$ docker-compose kill [SERVICE]</p>
			<p>This command supports multiple signals with the <strong class="source-inline">-s SIGNAL</strong> option.</p>
			<p>Now that we've covered the basic concepts surrounding Docker Compose, let's learn how to configure Podman to run Compose files.</p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor252"/>Configuring Podman to interact with docker-compose</h2>
			<p>To support <a id="_idIndexMarker1222"/>Compose, Podman <a id="_idIndexMarker1223"/>needs to expose its REST API service through a local UNIX socket. This service supports both Docker-compatible APIs and the native Libpod APIs.</p>
			<p>On a Fedora distribution, the <strong class="source-inline">docker-compose</strong> (which provides Docker Compose binaries) and <strong class="source-inline">podman-docker</strong> (which provides aliasing to the <strong class="source-inline">docker</strong> command) packages must be installed using the following command: </p>
			<p class="source-code">$ sudo dnf install docker-compose podman-docker</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The <strong class="source-inline">docker-compose</strong> package, when installed on a Fedora 34 system, installs version v1.28 at the time of writing, written in Python. The latest version, v2, was completely rewritten in Go and provides a significant performance improvement. It can be downloaded from the GitHub release page at <a href="https://github.com/docker/compose/releases">https://github.com/docker/compose/releases</a>.</p>
			<p>After installing the packages, we can enable and start the <strong class="source-inline">systemd</strong> unit that manages the UNIX socket service:</p>
			<p class="source-code">$ sudo systemctl enable --now podman.socket</p>
			<p>This <a id="_idIndexMarker1224"/>command starts a socket that's listening on <strong class="source-inline">/run/podman/podman.sock</strong>.</p>
			<p>Note <a id="_idIndexMarker1225"/>that the native <strong class="source-inline">docker-compose</strong> command looks for a socket file in the <strong class="source-inline">/run/docker.sock</strong> path by default. For this reason, the <strong class="source-inline">podman-docker</strong> packages creates a symbolic link on the same path that points to <strong class="source-inline">/run/podman/podman.sock</strong>, as shown in the following example:</p>
			<p class="source-code"># ls -al /run/docker.sock</p>
			<p class="source-code">lrwxrwxrwx. 1 root root 23 Feb  3 21:54 /var/run/docker.sock -&gt; /run/podman/podman.sock</p>
			<p>The UNIX socket that's exposed by Podman can be accessed by a process with root privileges only. It is possible to stretch the security restrictions by opening access to the file to all the users in the system or by allowing custom ACLs for a custom group. Later in this chapter, we will see that rootless container stacks can be executed with <strong class="source-inline">podman-compose</strong>. </p>
			<p>For the sake of simplicity, in the next subsection, you'll learn how to run <strong class="source-inline">docker-compose</strong> commands with Podman in rootfull mode.</p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor253"/>Running Compose workloads with Podman and docker-compose</h2>
			<p>To help <a id="_idIndexMarker1226"/>you learn <a id="_idIndexMarker1227"/>how to <a id="_idIndexMarker1228"/>operate <strong class="source-inline">docker-compose</strong> and <a id="_idIndexMarker1229"/>create orchestrated multi-container deployments on our host, we will reuse the previous example of the Go REST API with a Redis in-memory store.</p>
			<p>We <a id="_idIndexMarker1230"/>have already inspected <a id="_idIndexMarker1231"/>the <strong class="source-inline">docker-compose.yaml</strong> file, which <a id="_idIndexMarker1232"/>builds the <a id="_idIndexMarker1233"/>web application and deploys one instance of the Redis container. </p>
			<p>Let's inspect the Dockerfile that's used to build the application:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Chapter13/golang-redis/Dockerfile</p>
			<p class="source-code">FROM docker.io/library/golang AS builder</p>
			<p class="source-code"># Copy files for build</p>
			<p class="source-code">RUN mkdir -p /go/src/golang-redis</p>
			<p class="source-code">COPY go.mod main.go /go/src/golang-redis</p>
			<p class="source-code"># Set the working directory</p>
			<p class="source-code">WORKDIR /go/src/golang-redis</p>
			<p class="source-code"># Download dependencies</p>
			<p class="source-code">RUN go get -d -v ./...</p>
			<p class="source-code"># Install the package</p>
			<p class="source-code">RUN go build -v </p>
			<p class="source-code"># Runtime image</p>
			<p class="source-code">FROM registry.access.redhat.com/ubi8/ubi-minimal:latest as bin</p>
			<p class="source-code">COPY --from=builder /go/src/golang-redis/golang-redis /usr/local/bin</p>
			<p class="source-code">COPY entrypoint.sh /</p>
			<p class="source-code">EXPOSE 8080</p>
			<p class="source-code">ENTRYPOINT ["/entrypoint.sh"]</p>
			<p>Here, we <a id="_idIndexMarker1234"/>can see that the Go application <a id="_idIndexMarker1235"/>is compiled in a multi-stage build and that the Go binary is copied inside a UBI-Minimal image.</p>
			<p>The web <a id="_idIndexMarker1236"/>frontend is minimal – it listens <a id="_idIndexMarker1237"/>to port <strong class="source-inline">8080</strong>/<strong class="source-inline">tcp</strong> and only implements two endpoints – an <strong class="source-inline">HTTP POST</strong> method and an <strong class="source-inline">HTTP GET</strong> method to allow clients to upload and retrieve a JSON object that contains the name, email, and ID of a user. The JSON object is stored inside the Redis database.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">If you're curious, the source code for the Go server is available in the <strong class="source-inline">Chapter13/golang-redis/app/main.go</strong> file. It isn't presented in this book for the sake of space and readability.</p>
			<p>To build and run the application, we must change to the project directory and run the <strong class="source-inline">docker-compose up</strong> command:</p>
			<p class="source-code"># cd Chapter13/golang-redis </p>
			<p class="source-code"># docker-compose up --build -d</p>
			<p class="source-code">[...omitted output...]</p>
			<p class="source-code">Successfully tagged localhost/golang-redis_web:latest</p>
			<p class="source-code">6b330224010ed611baba11fc2d66b9e4cfc991312f5166b47b5fcd073 57c6325</p>
			<p class="source-code">Successfully built 6b330224010ed611baba11fc2d66b9e4cfc991312f5166b47b5fcd073 57c6325</p>
			<p class="source-code">Creating golang-redis_redis_1 ... done</p>
			<p class="source-code">Creating golang-redis_web_1   ... done</p>
			<p>Here, we <a id="_idIndexMarker1238"/>can see that <strong class="source-inline">docker-compose</strong> created <a id="_idIndexMarker1239"/>two containers, whose names always follow the <strong class="source-inline">&lt;project_name&gt;_&lt;service_name&gt;_&lt;instance_count&gt;</strong> pattern.</p>
			<p>The instance <a id="_idIndexMarker1240"/>count varies when <a id="_idIndexMarker1241"/>there is more than one replica in the service deployment.</p>
			<p>We can inspect the running containers with the usual <strong class="source-inline">podman ps</strong> command:</p>
			<p class="source-code"># podman ps </p>
			<p class="source-code">CONTAINER ID  IMAGE                              COMMAND       CREATED         STATUS             PORTS                   NAMES</p>
			<p class="source-code">4a5421c9e7cd  docker.io/library/redis:latest     redis-server  20 seconds ago  Up 20 seconds ago                          golang-redis_redis_1</p>
			<p class="source-code">8a465d4724ab  localhost/golang-redis_web:latest                20 seconds ago  Up 20 seconds ago  0.0.0.0:8080-&gt;8080/tcp  golang-redis_web_1</p>
			<p>One of the more interesting aspects is that the service names are automatically resolved. </p>
			<p>When a Compose stack is created, Podman creates a new network, named with the <strong class="source-inline">&lt;project_name&gt;_default</strong> pattern. </p>
			<p>The new network uses the <strong class="source-inline">dnsname</strong> plugin to instantiate a <strong class="source-inline">dnsmasq</strong> process and resolve the containers' IPs to names that have been created after the service names.</p>
			<p>We can inspect the network with the following command:</p>
			<p class="source-code"># podman network ls | grep golang-redis</p>
			<p class="source-code">49d5a3c3679c  golang-redis_default    0.4.0       bridge,portmap,firewall,tuning,dnsname</p>
			<p>The <strong class="source-inline">dnsmasq</strong> service can be found using the <strong class="source-inline">ps</strong> command and filtered with <strong class="source-inline">grep</strong>:</p>
			<p class="source-code"># ps aux | grep dnsmasq | grep golang</p>
			<p class="source-code">root     2749495  0.0  0.0  26388  2416 ?        S    01:33   0:00 /usr/sbin/dnsmasq -u root --conf-file=/run/containers/cni/dnsname/golang-redis_default/dnsmasq.conf</p>
			<p>The <strong class="source-inline">/run/containers/cni/dnsname/golang-redis_default</strong> directory holds <a id="_idIndexMarker1242"/>the instance's configuration. Inside the <strong class="source-inline">addnhosts</strong> file, we can find the mappings between the service <a id="_idIndexMarker1243"/>names and the allocated container IPs:</p>
			<p class="source-code"># cat /run/containers/cni/dnsname/golang-redis_default/addnhosts</p>
			<p class="source-code">10.89.3.240     golang-redis_redis_1   4a5421c9e7cd   redis</p>
			<p class="source-code">10.89.3.241         golang-redis_web_1    4298ae9f29c5      web</p>
			<p>This means <a id="_idIndexMarker1244"/>that a process inside a container <a id="_idIndexMarker1245"/>can resolve a service name with a standard DNS query.</p>
			<p>When we have multiple container replicas in a service, the resulting resolution that's delivered by <strong class="source-inline">dnsmasq</strong> is similar <a id="_idIndexMarker1246"/>to a <strong class="bold">round-robin DNS</strong>, a simple and minimalistic kind of load balancing that iterates multiple DNS records that are resolved by the same name. When a process calls a service (the <strong class="source-inline">db</strong> service, for example), it will be resolved to as many different IPs as there are service replicas. </p>
			<p>Let's go back to the <strong class="source-inline">docker-compose.yaml</strong> file. In the environment section of the <strong class="source-inline">web</strong> service configuration, we have the following variable:</p>
			<p class="source-code">    environment:</p>
			<p class="source-code">      - REDIS_HOST=redis</p>
			<p>This variable is injected into the running container and represents the name of the <strong class="source-inline">redis</strong> service. It is used by the Go application to create the connection string to Redis and initialize the connection. When we're using a DNS-resolved service name, the container <a id="_idIndexMarker1247"/>name and IP address of the <strong class="source-inline">redis</strong> service <a id="_idIndexMarker1248"/>are completely irrelevant to our Go application.</p>
			<p>We can <a id="_idIndexMarker1249"/>use the <strong class="source-inline">docker-compose exec</strong> command to verify that the variable was correctly injected inside the containers <a id="_idIndexMarker1250"/>running as the <strong class="source-inline">web</strong> service in the stack:</p>
			<p class="source-code"># docker-compose exec web env</p>
			<p class="source-code">Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.</p>
			<p class="source-code">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</p>
			<p class="source-code">TERM=xterm</p>
			<p class="source-code">container=oci</p>
			<p class="source-code">REDIS_HOST=redis</p>
			<p class="source-code">HOME=/root</p>
			<p>The <strong class="source-inline">env</strong> command outputs the full list of environment variables in the container. This allows us to verify that the <strong class="source-inline">REDIS_HOST</strong> variable was created correctly.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Storing configurations such as connection strings in a database as constants in the application code is an anti-pattern in general, especially for modern cloud-native applications. The correct approach is to guarantee a strict separation between the application logic and the configuration parameters.</p>
			<p class="callout">Configurations can be stored as environment variables or inside config/secret files that are injected at runtime in the container that runs the application.</p>
			<p class="callout">These practices <a id="_idIndexMarker1251"/>are well-defined in the <strong class="bold">Twelve-Factor App</strong> pattern specification, whose URL can be found in the <em class="italic">Further reading</em> section.</p>
			<p>It is finally time to test the application by posting a couple of JSON objects and retrieving one of them with the <strong class="source-inline">curl</strong> command:</p>
			<p class="source-code">$ curl -X POST -d \</p>
			<p class="source-code">'{"name":"jim", "email":"jim@example.com", "id":"0001"}' \</p>
			<p class="source-code">localhost:8080</p>
			<p class="source-code">$ curl -X POST -d \</p>
			<p class="source-code">'{"name":"anna", "email":"anna@example.com", "id":"0002"}' \</p>
			<p class="source-code">localhost:8080</p>
			<p>The web <a id="_idIndexMarker1252"/>container was successfully <a id="_idIndexMarker1253"/>written to the Redis backend, which <a id="_idIndexMarker1254"/>we can see by <a id="_idIndexMarker1255"/>running the <strong class="source-inline">docker-compose logs</strong> command:</p>
			<p class="source-code"># docker-compose logs web</p>
			<p class="source-code">[...omitted output...]</p>
			<p class="source-code">2022/02/06 00:58:06 Storing data:  {"name":"jim","email":"jim@example.com","id":"0001"}</p>
			<p class="source-code">2022/02/06 00:58:10 Storing data:  {"name":"anna","email":"anna@example.com","id":"0002"}</p>
			<p>The preceding command captures the logs of all the containers behind the <strong class="source-inline">web</strong> service.</p>
			<p>Finally, we can retrieve the result. The web application reads back the object from the Redis database by looking at its <strong class="source-inline">id</strong>:</p>
			<p class="source-code">$ curl -X GET -d '{"id": "0001"}' localhost:8080  </p>
			<p class="source-code">{"name":"jim","email":"jim@example.com","id":"0001"}</p>
			<p>To shut down our application, we can simply use the <strong class="source-inline">docker-compose down</strong> command:</p>
			<p class="source-code"># docker-compose down</p>
			<p>This <a id="_idIndexMarker1256"/>command destroys the containers <a id="_idIndexMarker1257"/>and their associated <a id="_idIndexMarker1258"/>resources, including <a id="_idIndexMarker1259"/>the custom network, but not volumes. To remove volumes, you must add the <strong class="source-inline">-v</strong> option to the end of the command.</p>
			<p>The <strong class="source-inline">docker-compose</strong> utility is a great companion for building and deploying on a single host with Podman. However, in the next chapter, we will learn about some other useful solutions that will let us generate and execute Kubernetes Pod and Service resources, as well as containers that are executed by Systemd units. Before moving on, let's inspect the alternative <strong class="source-inline">podman-compose</strong> tool, which provides support for rootless containers.</p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor254"/>Using podman-compose</h2>
			<p>The <strong class="source-inline">podman-compose</strong> project started way before version 3.0 of Podman to provide a compatibility <a id="_idIndexMarker1260"/>layer for users that needed to orchestrate containers with Compose files. In this subsection, we will look at an example of using <strong class="source-inline">podman-compose</strong> on Fedora.</p>
			<p>The <strong class="source-inline">podman-compose</strong> tool's CLI is written in Python. The package can be installed with <strong class="source-inline">dnf</strong> or by getting the latest release from the respective GitHub repository (you can find the direct link in <em class="italic">Further reading</em> section):</p>
			<p class="source-code">$ sudo dnf install -y podman-compose</p>
			<p>Alternatively, it can be installed with Python's package manager, <strong class="source-inline">pip3</strong>, which supports a broader set of operating systems and distributions:</p>
			<p class="source-code">$ pip3 install podman-compose</p>
			<p>Now, we can run the same Compose stacks from the previous examples with the advantage of the rootless approach that's provided by <strong class="source-inline">podman-compose</strong>.</p>
			<p>The following are all the available commands that are compatible with <strong class="source-inline">docker-compose</strong>, along with their descriptions and some minor changes that are made by the output of the <strong class="source-inline">podman-compose help</strong> command:</p>
			<ul>
				<li><strong class="source-inline">help</strong>: Shows the tool's help</li>
				<li><strong class="source-inline">version</strong>: Shows the command's version</li>
				<li><strong class="source-inline">pull</strong>: Pulls the stack images</li>
				<li><strong class="source-inline">push</strong>: Pushes the stack images</li>
				<li><strong class="source-inline">build</strong>: Builds the stack images</li>
				<li><strong class="source-inline">up</strong>: Creates and starts the entire stack or some of its services</li>
				<li><strong class="source-inline">down</strong>: Tears down the entire stack</li>
				<li><strong class="source-inline">ps</strong>: Show the status of running containers</li>
				<li><strong class="source-inline">run</strong>: Creates a container similar to a service to run a one-off command</li>
				<li><strong class="source-inline">exec</strong>: Executes a certain command in a running container</li>
				<li><strong class="source-inline">start</strong>: Starts specific services</li>
				<li><strong class="source-inline">stop</strong>: Stops specific services</li>
				<li><strong class="source-inline">restart</strong>: Restarts specific services</li>
				<li><strong class="source-inline">logs</strong>: Shows logs from services</li>
			</ul>
			<p>The following <a id="_idIndexMarker1261"/>command creates a stack from a directory containing the necessary configurations and the <strong class="source-inline">docker-compose.yaml</strong> file:</p>
			<p class="source-code">$ podman-compose up</p>
			<p>The command's output is also very similar to the output provided by <strong class="source-inline">docker-compose</strong>.</p>
			<p>To shut down the stack, simply run the following command:</p>
			<p class="source-code">$ podman-compose down</p>
			<p>The <strong class="source-inline">podman-compose</strong> project still hasn't reached total feature parity with <strong class="source-inline">docker-compose</strong>. However, it is a <a id="_idIndexMarker1262"/>very interesting project to follow and contribute to to help implement a Podman-native utility that can evolve independently in the future.</p>
			<h1 id="_idParaDest-255"><a id="_idTextAnchor255"/>Summary</h1>
			<p>In this chapter, we learned how to manage a full migration from Docker to Podman.</p>
			<p>We covered how to migrate images and create command aliases and we inspected the command compatibility matrix. Here, we provided a detailed overview of the different behaviors of specific commands and the different commands that are implemented in the two container engines – that is, Docker and Podman.</p>
			<p>Then, we learned how to migrate Docker Compose by illustrating native Podman 3.0 support for the <strong class="source-inline">docker-compose</strong> command and the <strong class="source-inline">podman-compose</strong> alternative utility.</p>
			<p>In the next and final chapter of this book, we will learn how to interact with Systemd by generating custom service units and turning containers into services that are started automatically inside the host. Then, we'll look at Kubernetes-oriented orchestration, where we will learn how to generate Kubernetes resources from running containers and pods and run them in Podman or Kubernetes natively. </p>
			<h1 id="_idParaDest-256"><a id="_idTextAnchor256"/>Further reading</h1>
			<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
			<ul>
				<li>Docker Awesome Compose: <a href="https://github.com/docker/awesome-compose">https://github.com/docker/awesome-compose</a> </li>
				<li>Podman-compose project on GitHub: <a href="https://github.com/containers/podman-compose">https://github.com/containers/podman-compose</a></li>
				<li>Red Hat blog introduction to Docker Compose support in Podman: <a href="https://www.redhat.com/sysadmin/podman-docker-compose">https://www.redhat.com/sysadmin/podman-docker-compose</a></li>
				<li>Twelve-Factor App: <a href="https://12factor.net/">https://12factor.net/</a> </li>
				<li>Podman man page: <a href="https://github.com/containers/podman/blob/main/docs/source/markdown/podman.1.md">https://github.com/containers/podman/blob/main/docs/source/markdown/podman.1.md</a></li>
			</ul>
		</div>
	</body></html>