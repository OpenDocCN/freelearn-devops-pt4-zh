- en: '*Chapter 13*: Docker Migration Tips and Tricks'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every technology has a pioneer company, project, and product that, once created
    and announced, becomes a real game-changer that allowed its base concepts to spread.
    For containers, this was Docker.
  prefs: []
  type: TYPE_NORMAL
- en: As we learned in [*Chapter 1*](B17908_01_epub.xhtml#_idTextAnchor015), *Introduction
    to Container Technology*, Docker provided a new approach and great ideas to leveraging
    existing technologies and creating brand new ones. After a few years, it became
    the most used technology for containers.
  prefs: []
  type: TYPE_NORMAL
- en: But as usually happens for open source projects, the community and the enterprise
    started looking for improvements, new architectures, and different implementations.
    That's where Podman found a place to grow and leverage the standardization that's
    offered by the **Open Container Initiative** (**OCI**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker was (and still is) the most used container technology. For this reason,
    in this chapter, we are going to provide some tips and tricks regarding handling
    the migration process. We will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Migrating existing images and playing with a command's alias
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Podman commands versus Docker commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Docker Compose with Podman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you proceed with this chapter's lecture and examples, you will need a
    machine with a working Podman installation. As we mentioned in [*Chapter 3*](B17908_03_epub.xhtml#_idTextAnchor068),
    *Running the First Container*, all the examples in this book have been executed
    on a Fedora 34 system or later but can be reproduced on your choice of **operating
    system** (**OS**).
  prefs: []
  type: TYPE_NORMAL
- en: Having a good understanding of the topics that were covered in [*Chapter 4*](B17908_04_epub.xhtml#_idTextAnchor083),
    *Managing Running Containers*, [*Chapter 5*](B17908_05_epub.xhtml#_idTextAnchor101),
    *Implementing Storage for the Container's Data*, and [*Chapter 9*](B17908_09_epub.xhtml#_idTextAnchor167),
    *Pushing Images to a Container Registry*, will help you grasp the concepts that
    will be covered in this chapter regarding containers.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating existing images and playing with a command's alias
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Podman has one great feature that lets any previous Docker user easily adapt
    and switch to it – complete **command-line interface** (**CLI**) compatibility
    with Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s demonstrate this CLI compatibility with Docker by creating a shell command
    alias for the `docker` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have created a command alias that binds the `podman` command
    to the `docker` one. If we try to execute the `docker` command after setting the
    alias, the output is returned from the `podman` command instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this out on the newly created alias by running a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see something very funny – a running cat, similar to the one shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Funny output from running a test container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17908_13_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.1 – Funny output from running a test container
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test something more interesting. Docker, for example, offers a tutorial
    based on a container image exposing a web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we continued to use the `docker` alias command with the option for running
    it by using a daemon, `–d`, and the option for binding the HTTP port, `–p`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything worked correctly, then we can point our favorite web browser
    to `http://localhost`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Docker tutorial home page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17908_13_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.2 – Docker tutorial home page
  prefs: []
  type: TYPE_NORMAL
- en: The first page of Dockerlabs, **Getting Started**, specifies the command that
    was just run. From the left column of the page, we can continue with the tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue with the tutorial and double-check that the alias will work properly
    at every stage.
  prefs: []
  type: TYPE_NORMAL
- en: The tutorial steps are very simple, and they can help you summarize the knowledge
    that was shared in the previous chapters, from building a container to using multiple
    container applications to create a dedicated network. Please stop before the **Using
    Docker Compose** section as we will look at this in more detail shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget that we are using an alias and that, under the hood, Podman is
    working actively to let our containers work as expected, ensuring Docker CLI compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: But what about container migration in the case of swapping Docker in favor of
    Podman?
  prefs: []
  type: TYPE_NORMAL
- en: Well, a direct way to move existing containers from Docker to Podman does not
    exist. It is recommended that you recreate the containers with the respective
    container images and reattach any volumes using Podman.
  prefs: []
  type: TYPE_NORMAL
- en: The container images can be exported using the `docker export` command, which
    will create a TAR archive file that can be imported into Podman via the `podman
    import` command. If you're using a container image registry, you can skip this.
  prefs: []
  type: TYPE_NORMAL
- en: To understand any limitations we may encounter when we're using commands, examples,
    and resources written for Docker with our Podman installation, let's compare various
    Podman and Docker commands.
  prefs: []
  type: TYPE_NORMAL
- en: Podman commands versus Docker commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the previous section, as well as in [*Chapter 2*](B17908_02_epub.xhtml#_idTextAnchor044),
    *Comparing Podman and Docker*, the Podman CLI is based on the Docker CLI. However,
    because Podman does not require a runtime daemon to work, some of the Docker commands
    may not be directly available or they could require some workarounds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command list is exceptionally long, so the following table only specifies
    a few:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the command's name is the same as comparing the `docker` command
    with the `podman` command. However, even though the name is the same, due to architectural
    differences between Podman and Docker, some features or behaviors could be different.
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral differences between Podman and Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following commands were intentionally implemented in another way by the
    Podman development team:'
  prefs: []
  type: TYPE_NORMAL
- en: '`podman volume create`: This command will fail if the volume already exists.
    In Docker, this command is idempotent, which means that if a volume already exists
    with the same name, then Docker will just skip this instruction. The actual behavior
    of Docker does not match the implementations for the other commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`podman run -v /tmp/noexist:/tmp`: This command will fail if the source volume
    path does not exist. Instead, Docker will create the folder if it does not exist.
    Again, the Podman development team considered this a bug and changed it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`podman run --restart`: The restart option in Podman will not persist after
    a system reboot. If required, we can run Podman from a `systemd.unit` file through
    `podman generate systemd`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we'll see which commands are missing from Podman that exist
    in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Missing commands in Podman
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following table shows a non-comprehensive list of Docker commands that,
    at the time of writing, don''t have equivalents in Podman:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's see which commands are missing from Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Missing commands in Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to how Podman is missing some Docker commands, Docker is missing some
    Podman commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following families of commands in Podman don''t have respective ones in
    Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '`podman container`: This command can be used to manage containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`podman generate`: This command can be used to create a structured output (such
    as a YAML file) for a container, pod, or volume.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`podman healthcheck`: This command provides you with a set of subcommands that
    you can use to manage container health checks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`podman image`: This command can be used to manage container images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`podman init`: This command can be used to initialize a container with all
    the required steps but without running it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`podman machine`: This command lists a set of subcommands for managing Podman''s
    virtual machine on macOS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`podman mount`: This command mounts the container''s root filesystem in a location
    that can be accessed by the host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`podman network exists/prune/reload`: This command checks and manages the status
    of a container''s network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`podman play`: This command creates containers, pods, or volumes based on the
    input from a structured (such as YAML) file input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`podman pod`: This provides a set of subcommands for managing pods or groups
    of containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`podman system`: This provides a set of subcommands for managing the Podman
    systems and retrieving information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`podman unmount`: This command unmounts a working container''s root filesystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`podman unshare`: This command launches a process in a new user namespace (rootless
    containers).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`podman untag`: This command removes one or more stored images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`podman volume exists`: This command checks if a volume exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, if a command is missing, this does not mean that the feature is missing
    in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful feature that's available in Docker is Compose. We'll learn how
    to use it in Podman in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker Compose with Podman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it was first released, Docker quickly gained consensus thanks to its intuitive
    approach to container management. Along with the main container engine solution,
    another great feature was introduced to help users orchestrate multiple containers
    on a single host: **Docker Compose**.'
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind Compose is quite simple – it's a tool that can be used to orchestrate
    multi-container applications that are supposed to interact together on a single
    host and configured with a declarative file in YAML format. All the applications
    that are executed in a Compose stack are defined as services that can communicate
    with the other containers in the stack with a transparent name resolution.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration file is named `docker-compose.yaml` and has a simple syntax
    where one or more **services** and related **volumes** are created and started.
  prefs: []
  type: TYPE_NORMAL
- en: Development teams can benefit from the stack's automation to quickly test applications
    on a single host. However, if we need to run our application on a production-like,
    multi-node environment, the best approach is to adopt a clustered orchestration
    solution such as Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: When Podman was first released, its main purpose was to reach OCI full compatibility
    and feature parity with Docker CLI commands to become a valid daemonless alternative
    to the well-known container engine that inspired it. Unfortunately, this Compose
    compatibility was not supported in the first two major releases. Afterwards, the
    `podman-compose` project was introduced to fill the gap. The project was a separate
    development stream that needed to compensate for the lack of native Compose support
    in Podman.
  prefs: []
  type: TYPE_NORMAL
- en: With Podman v3.0, native support for Docker Compose was finally introduced upstream,
    leaving users with the choice of using the original `docker-compose` utility or
    the new `podman-compose` utility.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to configure Podman to orchestrate multiple
    containers with `docker-compose` to provide full compatibility to users migrating
    from Docker to Podman. In the next subsection, we'll look at an example of using
    `podman-compose` to leverage rootless container orchestration.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dig into setting up Podman, let's look at a few basic examples of
    Compose files to understand how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose quick start
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compose files can be used to declare one or multiple containers being executed
    inside a common stack and also to define build instructions for custom applications.
    The advantage of this approach is that you can fully automate the entire application
    stack, including frontends, backends, and persistence services such as databases
    or in-memory caches.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this section is to provide a quick overview of Compose files
    to help you understand how Podman can handle them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a detailed list of the latest Compose specification, please refer to the
    following URL: [https://docs.docker.com/compose/compose-file/compose-file-v3/](https://docs.docker.com/compose/compose-file/compose-file-v3/).'
  prefs: []
  type: TYPE_NORMAL
- en: A more extensive list of Compose examples can be found in the Docker Awesome
    Compose project at [https://github.com/docker/awesome-compose](https://github.com/docker/awesome-compose).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a minimal configuration file that defines a single container
    running the Docker registry:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter13/registry/docker-compose.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example can be seen as a more structured and declarative way to
    define the execution parameters for a container. However, the real value of Docker
    Compose is its orchestration stacks, which are made up of multiple containers
    in a single instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is even more interesting and shows a configuration file
    for a WordPress application that uses a MySQL database as its backend:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter13/wordpress/docker-compose.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see the two main YAML objects – `services` and `volumes`. Under
    the `services` part of the code, we have two applications – `db` and `wordpress`.
    These have been highlighted for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `services` list, there''s a set of configuration values that define
    the container''s behavior. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`image`: The image that''s used by the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`command`: Additional commands to be passed to the container''s entry point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Volumes`: The list of volumes to be mounted in the container, along with their
    associated mount points. Along with new dedicated volumes, existing directories
    in the host can be bind-mounted on container mount points.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restart`: Container restart options in case an error occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expose`: The list of ports to be exposed by the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ports`: The list of port mappings between the container and the host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`environment`: The list of environment variables to be created in the container.
    In this example, `WORDPRESS_DB_HOST`, `WORDPRESS_DB_USER`, `WORDPRESS_DB_PASSWORD`,
    `WORDPRESS_DB_NAME`, are injected into the WordPress container to provide connection
    parameters to the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Together with the service's declaration, we have a list of volumes that are
    managed by Compose. The engine can create these volumes in the Compose process
    or use existing volumes that have been labeled as `external`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third and final example is a Compose file that builds a minimal REST API
    application that''s been written in Go that writes and retrieves data to a Redis
    in-memory store:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter13/golang-redis/docker-compose.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have new elements that deserve attention:'
  prefs: []
  type: TYPE_NORMAL
- en: A `build` object, which defines the image to be built and also applies custom
    labels to the build.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `context` key holds the path for the build. In this example, the `./app`
    folder contains all the source code files and the Dockerfile for building the
    image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `labels` list, which holds a set of labels that are passed as strings in the
    build process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `depends_on` list that specifies, for the web service, the other services
    that are considered dependencies; in this case, the `redis` service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `environment` list that defines the name of the `redis` service that's used
    by the web app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `deploy` object in the `redis` service that lets us define custom configuration
    parameters, such as the number of container `replicas`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To bring up Compose applications with Docker, we can run the following command
    from the `compose` file''s folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This command creates all the stack and related volumes while printing the output
    to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run in detached mode, simply add the `-d` option to the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command builds the necessary images and starts the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, the `docker-compose build` command can be used to build the applications
    without starting them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To shut down a stack running in the foreground, simply hit the *Ctrl* + *C*
    keyboard combination. Instead, to shut down a detached application, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To kill an unresponsive container, we can use the `docker-compose kill` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This command supports multiple signals with the `-s SIGNAL` option.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've covered the basic concepts surrounding Docker Compose, let's
    learn how to configure Podman to run Compose files.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Podman to interact with docker-compose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To support Compose, Podman needs to expose its REST API service through a local
    UNIX socket. This service supports both Docker-compatible APIs and the native
    Libpod APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a Fedora distribution, the `docker-compose` (which provides Docker Compose
    binaries) and `podman-docker` (which provides aliasing to the `docker` command)
    packages must be installed using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The `docker-compose` package, when installed on a Fedora 34 system, installs
    version v1.28 at the time of writing, written in Python. The latest version, v2,
    was completely rewritten in Go and provides a significant performance improvement.
    It can be downloaded from the GitHub release page at [https://github.com/docker/compose/releases](https://github.com/docker/compose/releases).
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing the packages, we can enable and start the `systemd` unit that
    manages the UNIX socket service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This command starts a socket that's listening on `/run/podman/podman.sock`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the native `docker-compose` command looks for a socket file in the
    `/run/docker.sock` path by default. For this reason, the `podman-docker` packages
    creates a symbolic link on the same path that points to `/run/podman/podman.sock`,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The UNIX socket that's exposed by Podman can be accessed by a process with root
    privileges only. It is possible to stretch the security restrictions by opening
    access to the file to all the users in the system or by allowing custom ACLs for
    a custom group. Later in this chapter, we will see that rootless container stacks
    can be executed with `podman-compose`.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity, in the next subsection, you'll learn how to run
    `docker-compose` commands with Podman in rootfull mode.
  prefs: []
  type: TYPE_NORMAL
- en: Running Compose workloads with Podman and docker-compose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To help you learn how to operate `docker-compose` and create orchestrated multi-container
    deployments on our host, we will reuse the previous example of the Go REST API
    with a Redis in-memory store.
  prefs: []
  type: TYPE_NORMAL
- en: We have already inspected the `docker-compose.yaml` file, which builds the web
    application and deploys one instance of the Redis container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s inspect the Dockerfile that''s used to build the application:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter13/golang-redis/Dockerfile
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the Go application is compiled in a multi-stage build
    and that the Go binary is copied inside a UBI-Minimal image.
  prefs: []
  type: TYPE_NORMAL
- en: The web frontend is minimal – it listens to port `8080`/`tcp` and only implements
    two endpoints – an `HTTP POST` method and an `HTTP GET` method to allow clients
    to upload and retrieve a JSON object that contains the name, email, and ID of
    a user. The JSON object is stored inside the Redis database.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: If you're curious, the source code for the Go server is available in the `Chapter13/golang-redis/app/main.go`
    file. It isn't presented in this book for the sake of space and readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build and run the application, we must change to the project directory and
    run the `docker-compose up` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that `docker-compose` created two containers, whose names always
    follow the `<project_name>_<service_name>_<instance_count>` pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The instance count varies when there is more than one replica in the service
    deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can inspect the running containers with the usual `podman ps` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: One of the more interesting aspects is that the service names are automatically
    resolved.
  prefs: []
  type: TYPE_NORMAL
- en: When a Compose stack is created, Podman creates a new network, named with the
    `<project_name>_default` pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The new network uses the `dnsname` plugin to instantiate a `dnsmasq` process
    and resolve the containers' IPs to names that have been created after the service
    names.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can inspect the network with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dnsmasq` service can be found using the `ps` command and filtered with
    `grep`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `/run/containers/cni/dnsname/golang-redis_default` directory holds the
    instance''s configuration. Inside the `addnhosts` file, we can find the mappings
    between the service names and the allocated container IPs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This means that a process inside a container can resolve a service name with
    a standard DNS query.
  prefs: []
  type: TYPE_NORMAL
- en: When we have multiple container replicas in a service, the resulting resolution
    that's delivered by `dnsmasq` is similar to a `db` service, for example), it will
    be resolved to as many different IPs as there are service replicas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the `docker-compose.yaml` file. In the environment section
    of the `web` service configuration, we have the following variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This variable is injected into the running container and represents the name
    of the `redis` service. It is used by the Go application to create the connection
    string to Redis and initialize the connection. When we're using a DNS-resolved
    service name, the container name and IP address of the `redis` service are completely
    irrelevant to our Go application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `docker-compose exec` command to verify that the variable was
    correctly injected inside the containers running as the `web` service in the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `env` command outputs the full list of environment variables in the container.
    This allows us to verify that the `REDIS_HOST` variable was created correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Storing configurations such as connection strings in a database as constants
    in the application code is an anti-pattern in general, especially for modern cloud-native
    applications. The correct approach is to guarantee a strict separation between
    the application logic and the configuration parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Configurations can be stored as environment variables or inside config/secret
    files that are injected at runtime in the container that runs the application.
  prefs: []
  type: TYPE_NORMAL
- en: These practices are well-defined in the **Twelve-Factor App** pattern specification,
    whose URL can be found in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is finally time to test the application by posting a couple of JSON objects
    and retrieving one of them with the `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The web container was successfully written to the Redis backend, which we can
    see by running the `docker-compose logs` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command captures the logs of all the containers behind the `web`
    service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can retrieve the result. The web application reads back the object
    from the Redis database by looking at its `id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To shut down our application, we can simply use the `docker-compose down` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This command destroys the containers and their associated resources, including
    the custom network, but not volumes. To remove volumes, you must add the `-v`
    option to the end of the command.
  prefs: []
  type: TYPE_NORMAL
- en: The `docker-compose` utility is a great companion for building and deploying
    on a single host with Podman. However, in the next chapter, we will learn about
    some other useful solutions that will let us generate and execute Kubernetes Pod
    and Service resources, as well as containers that are executed by Systemd units.
    Before moving on, let's inspect the alternative `podman-compose` tool, which provides
    support for rootless containers.
  prefs: []
  type: TYPE_NORMAL
- en: Using podman-compose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `podman-compose` project started way before version 3.0 of Podman to provide
    a compatibility layer for users that needed to orchestrate containers with Compose
    files. In this subsection, we will look at an example of using `podman-compose`
    on Fedora.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `podman-compose` tool''s CLI is written in Python. The package can be installed
    with `dnf` or by getting the latest release from the respective GitHub repository
    (you can find the direct link in *Further reading* section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it can be installed with Python''s package manager, `pip3`,
    which supports a broader set of operating systems and distributions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can run the same Compose stacks from the previous examples with the
    advantage of the rootless approach that's provided by `podman-compose`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are all the available commands that are compatible with `docker-compose`,
    along with their descriptions and some minor changes that are made by the output
    of the `podman-compose help` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`help`: Shows the tool''s help'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version`: Shows the command''s version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pull`: Pulls the stack images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`push`: Pushes the stack images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`build`: Builds the stack images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`up`: Creates and starts the entire stack or some of its services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`down`: Tears down the entire stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ps`: Show the status of running containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run`: Creates a container similar to a service to run a one-off command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exec`: Executes a certain command in a running container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start`: Starts specific services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stop`: Stops specific services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restart`: Restarts specific services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logs`: Shows logs from services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following command creates a stack from a directory containing the necessary
    configurations and the `docker-compose.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The command's output is also very similar to the output provided by `docker-compose`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To shut down the stack, simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `podman-compose` project still hasn't reached total feature parity with
    `docker-compose`. However, it is a very interesting project to follow and contribute
    to to help implement a Podman-native utility that can evolve independently in
    the future.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to manage a full migration from Docker to Podman.
  prefs: []
  type: TYPE_NORMAL
- en: We covered how to migrate images and create command aliases and we inspected
    the command compatibility matrix. Here, we provided a detailed overview of the
    different behaviors of specific commands and the different commands that are implemented
    in the two container engines – that is, Docker and Podman.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we learned how to migrate Docker Compose by illustrating native Podman
    3.0 support for the `docker-compose` command and the `podman-compose` alternative
    utility.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter of this book, we will learn how to interact with
    Systemd by generating custom service units and turning containers into services
    that are started automatically inside the host. Then, we'll look at Kubernetes-oriented
    orchestration, where we will learn how to generate Kubernetes resources from running
    containers and pods and run them in Podman or Kubernetes natively.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Awesome Compose: [https://github.com/docker/awesome-compose](https://github.com/docker/awesome-compose)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Podman-compose project on GitHub: [https://github.com/containers/podman-compose](https://github.com/containers/podman-compose)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Red Hat blog introduction to Docker Compose support in Podman: [https://www.redhat.com/sysadmin/podman-docker-compose](https://www.redhat.com/sysadmin/podman-docker-compose)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Twelve-Factor App: [https://12factor.net/](https://12factor.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Podman man page: [https://github.com/containers/podman/blob/main/docs/source/markdown/podman.1.md](https://github.com/containers/podman/blob/main/docs/source/markdown/podman.1.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
