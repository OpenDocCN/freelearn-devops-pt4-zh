- en: '*Chapter 14*: Interacting with systemd and Kubernetes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 14 章*：与 systemd 和 Kubernetes 交互'
- en: In the previous chapters, we learned how to initialize and manage containers,
    starting with simple concepts and arriving at advanced ones. Containers represent
    a key technology for application development in the latest Linux operating system
    releases. For this reason, containers are only the starting point for advanced
    developers and system administrators. Once this technology becomes widely adopted
    in an enterprise company or a technical project, the next step will be to integrate
    it with the base operating system and with -system orchestration platforms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们学习了如何初始化和管理容器，从简单的概念开始，逐步深入到更高级的内容。容器代表了最新 Linux 操作系统版本中应用开发的关键技术。因此，容器只是高级开发人员和系统管理员的起点。一旦这项技术在企业公司或技术项目中得到广泛应用，下一步将是将其与基础操作系统和系统编排平台进行集成。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Setting up the prerequisites for the host operating system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置主机操作系统的先决条件
- en: Creating the systemd unit files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 systemd 单元文件
- en: Managing container-based systemd services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理基于容器的 systemd 服务
- en: Generating Kubernetes YAML resources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成 Kubernetes YAML 资源
- en: Running Kubernetes resource files in Podman
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Podman 中运行 Kubernetes 资源文件
- en: Testing the results in Kubernetes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中测试结果
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete this chapter, you will need a machine with a working Podman installation.
    As we mentioned in [*Chapter 3*](B17908_03_epub.xhtml#_idTextAnchor068), *Running
    the First Container*, all the examples in this book were executed on a Fedora
    34 system or later but can be reproduced on your choice of **operating system**
    (**OS**).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，您需要一台已安装并正常运行 Podman 的机器。正如我们在[*第 3 章*](B17908_03_epub.xhtml#_idTextAnchor068)《运行第一个容器》中提到的，本书中的所有示例都是在
    Fedora 34 或更高版本的系统上执行的，但可以在您选择的**操作系统**（**OS**）上复现。
- en: Having a good understanding of the topics that were covered in [*Chapter 4*](B17908_04_epub.xhtml#_idTextAnchor083),
    *Managing Running Containers*, [*Chapter 5*](B17908_05_epub.xhtml#_idTextAnchor101),
    *Implementing Storage for the Container's Data*, and [*Chapter 9*](B17908_09_epub.xhtml#_idTextAnchor167),
    *Pushing Images to a Container Registry*, will help you grasp the topics we'll
    cover regarding advanced containers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对[*第 4 章*](B17908_04_epub.xhtml#_idTextAnchor083)《管理正在运行的容器》、[*第 5 章*](B17908_05_epub.xhtml#_idTextAnchor101)《为容器数据实现存储》以及[*第
    9 章*](B17908_09_epub.xhtml#_idTextAnchor167)《推送镜像到容器注册表》中的内容有充分的理解，将有助于您掌握我们将在高级容器部分中讨论的内容。
- en: You should also have a good understanding of system administration and Kubernetes
    container orchestration.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该对系统管理和 Kubernetes 容器编排有较好的理解。
- en: For the examples related to the Kubernetes section, you will require Podman
    version 4.0.0 because of a bug in version 3.4.z that prevents container environment
    variables from being created ([https://github.com/containers/podman/issues/12781](https://github.com/containers/podman/issues/12781)).
    This bug was fixed in v4.0.0 but it hasn't been backported to Podman v3 at the
    time of writing.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于与 Kubernetes 部分相关的示例，您需要 Podman 版本 4.0.0，因为版本 3.4.z 存在一个错误，该错误会阻止容器环境变量的创建（[https://github.com/containers/podman/issues/12781](https://github.com/containers/podman/issues/12781)）。这个错误在
    v4.0.0 中已被修复，但在撰写本文时并未回溯到 Podman v3。
- en: Setting up the prerequisites for the host operating system
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置主机操作系统的先决条件
- en: As we saw in [*Chapter 1*](B17908_01_epub.xhtml#_idTextAnchor015), *Introduction
    to Container Technology*, containers were born to help simplify and create system
    services that can be distributed on standalone hosts.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第 1 章*](B17908_01_epub.xhtml#_idTextAnchor015)《容器技术简介》中看到的，容器诞生的初衷是帮助简化并创建可以在独立主机上分发的系统服务。
- en: In the following sections, we will learn how to run MariaDB and a GIT service
    in containers while managing those containers like any other service – that is,
    through Systemd and the `systemctl` command.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习如何在容器中运行 MariaDB 和 GIT 服务，并像管理其他服务一样管理这些容器——也就是通过 Systemd 和 `systemctl`
    命令。
- en: First, let's introduce systemd, a system and service manager for Linux that
    runs as the first process on boot (as PID 1) and acts as an init system that brings
    up and maintains userspace services. Once a new user logs in to the host system,
    separate instances are executed to start their services.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们介绍一下 systemd，它是 Linux 的系统和服务管理器，在启动时作为第一个进程运行（作为 PID 1），并充当 init 系统，启动和维护用户空间服务。一旦新的用户登录到主机系统，便会执行单独的实例以启动他们的服务。
- en: The systemd daemon starts services and ensures priority with a dependency system
    between various entities called *units*. There are 11 different types of units.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: systemd守护进程启动服务，并通过一个名为*单元*的依赖系统来确保各个实体之间的优先级。共有11种不同类型的单元。
- en: 'Fedora 34 and later has systemd enabled and running by default. We can check
    if it is running properly by using the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Fedora 34及更高版本默认启用了并运行systemd。我们可以使用以下命令检查它是否正常运行：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the following sections, we are going to work with system unit files of the
    `service` type. We can check the current ones by running the following command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将处理`service`类型的系统单元文件。我们可以通过运行以下命令检查当前的单元文件：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Please Note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意
- en: The systemd service and its internals are more complex, so they cannot be summarized
    in a few lines. For additional information, please refer to the related Linux
    manual.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: systemd服务及其内部结构更为复杂，因此无法用几行总结。有关更多信息，请参阅相关的Linux手册。
- en: In the next section, we are going to learn how to create the systemd unit files
    for any running container service on our operating system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何为操作系统上任何运行中的容器服务创建systemd单元文件。
- en: Creating the systemd unit files
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建systemd单元文件
- en: The unit files on our system define how systemd starts and runs services.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们系统上的单元文件定义了systemd如何启动和运行服务。
- en: Each unit file represents a single component as a simple text file that describes
    its behavior, what needs to run before or afterward, and more.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单元文件表示一个单独的组件，它是一个简单的文本文件，描述了其行为、需要先后运行的内容等。
- en: 'Unit files are stored in a few different places on a system and systemd looks
    for them in this order:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 单元文件存储在系统中的几个不同位置，systemd按照以下顺序查找它们：
- en: '`/etc/systemd/system`'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/etc/systemd/system`'
- en: '`/run/systemd/system`'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/run/systemd/system`'
- en: '`/usr/lib/systemd/system`'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/usr/lib/systemd/system`'
- en: Unit files that are in the earlier directories override the later ones. This
    lets us change what we need in the `/etc` directory, where configuration is expected,
    leaving the default configuration files in `/usr`, for example.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 位于较早目录中的单元文件会覆盖后面的单元文件。这使得我们可以在`/etc`目录中修改所需的配置文件，而将默认的配置文件保留在`/usr`目录中，例如。
- en: But what does a unit file look like? Let's find out.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但单元文件是什么样的呢？让我们来看看。
- en: 'First, we can get the location of a default unit file by asking systemd about
    it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以通过询问systemd来获取默认单元文件的位置：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we executed the `status` command while passing the `sshd` service name
    as a filter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们执行了`status`命令，并传入`sshd`服务名称作为过滤条件。
- en: 'In the systemd output, the default unit file path can be inspected with the
    following example command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在systemd的输出中，默认的单元文件路径可以通过以下示例命令来检查：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'But what about Podman? Well, Podman makes systemd integration easier with its
    dedicated sub-command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 那Podman呢？实际上，Podman通过其专用子命令使systemd集成更加简单：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `podman generate systemd` command will output a text file representing the
    unit file that was created. As we can see from the help output, we can set up
    several options to adjust our settings.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman generate systemd`命令会输出一个文本文件，表示创建的单元文件。从帮助输出中我们可以看到，我们可以设置多个选项来调整设置。'
- en: We should always save the generated file and place it on the right path, as
    described in the previous output. We'll explore this command by providing a full
    example in the next section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该始终保存生成的文件，并将其放在正确的路径上，如前面的输出中所描述的那样。我们将在下一节通过提供完整示例来进一步探索这个命令。
- en: Managing container-based systemd services
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理基于容器的systemd服务
- en: In this section, you will learn how to use the `podman generate systemd` command
    through a practical example. We will create two system services based on containers
    to create a GIT repository.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将通过一个实际的例子学习如何使用`podman generate systemd`命令。我们将创建基于容器的两个系统服务来创建一个GIT仓库。
- en: 'For this example, we will leverage two well-known open source projects:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将利用两个知名的开源项目：
- en: '**Gitea**: The GIT repository, which also offers a nice web interface for code
    management'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gitea**：一个GIT仓库，还提供了一个漂亮的网页界面用于代码管理'
- en: '**MariaDB**: The SQL database for holding the data that''s produced by the
    Gitea service'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MariaDB**：SQL数据库，用于存储Gitea服务生成的数据'
- en: 'Let''s start with the example. First, we need to generate a password for our
    database''s user:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从例子开始。首先，我们需要为数据库用户生成一个密码：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we exported the environment variable with the secret password we are
    going to use and then leveraged a useful secrets management command that we did
    not introduce previously: `podman secret create`. Unfortunately, this command
    holds the secret in plain text, though this is good enough for our purpose. Since
    we are running these containers as root, these secrets are stored on the filesystem
    with root-only permissions.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导出了包含秘密密码的环境变量，然后使用了一个我们之前没有介绍的有用的秘密管理命令：`podman secret create`。不幸的是，该命令以纯文本存储秘密，但对于我们的目的来说已经足够好。由于我们以root身份运行这些容器，这些秘密将以root-only权限存储在文件系统中。
- en: 'We can inspect the secret with the following commands:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令检查秘密：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we have asked Podman to list and inspect the secret we created previously
    and looked at the underlying filesystem for the file holding the secrets.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们要求Podman列出并检查我们之前创建的秘密，并查看包含秘密的底层文件系统。
- en: The file holding the secrets is a file in JSON format and, as we mentioned previously,
    is in plain text. The first string of the couple is the secret ID, while the second
    string is the value Base64 encoded. If we try to decode it with the `BASE64` algorithm,
    we would see that it represents the password we just added – that is, `my-secret-pw`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 存储秘密的文件是JSON格式的文件，正如我们之前提到的，它是纯文本文件。该对字符串的第一个是秘密ID，第二个字符串是Base64编码的值。如果我们尝试用`BASE64`算法解码，我们会看到它代表了我们刚刚添加的密码——即`my-secret-pw`。
- en: Even though the password is stored in plain text, it is good enough for our
    example because we are using the root user and this filestore has root-only permission,
    as we can verify with the last command of the previous output.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管密码是以纯文本存储的，但对于我们的示例来说足够好，因为我们正在使用root用户，而该文件存储只有root权限，正如我们从之前输出的最后一个命令中可以验证的那样。
- en: Now, we can continue setting up the database container. We will start with the
    database setup because it is a dependency on our GIT server.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续设置数据库容器。我们将从数据库设置开始，因为它是我们GIT服务器的依赖项。
- en: 'We must create a local folder in the host system where we can store container
    data:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在主机系统上创建一个本地文件夹，用于存储容器数据：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can also look at the public documentation of the container image to find
    out the right volume path and the various environment variables to use to start
    our container:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以查看容器镜像的公共文档，找出正确的卷路径和启动容器时使用的各种环境变量：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are going to run and test the container as standalone first to check if there
    are any errors; then, we will transform it into a system service.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将容器作为独立实例运行并进行测试，以检查是否存在任何错误；然后，我们将其转变为系统服务。
- en: 'In the preceding Podman command, we did the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的Podman命令中，我们执行了以下操作：
- en: We ran the container in detached mode.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们以分离模式运行了容器。
- en: We assigned it a name – that is, `mariadb-service`.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为其指定了一个名称——即`mariadb-service`。
- en: We exposed the host network for simplicity; of course, we could limit and filter
    this connectivity.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了简化操作，我们暴露了主机网络；当然，我们也可以限制和过滤此连接。
- en: We mapped the storage volume with the newly created local directory while also
    specifying the `:Z` option to correctly assign the SELinux labels.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将存储卷映射到新创建的本地目录，同时指定了`:Z`选项，以正确分配SELinux标签。
- en: We defined the environment variables to use at runtime by the container's processes,
    also providing the password's secret with the `--secret` option.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了容器进程在运行时使用的环境变量，并通过`--secret`选项提供了密码的秘密。
- en: We used the container image name we want to use – that is, `docker.io/mariadb:latest`.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了我们想要使用的容器镜像名称——即`docker.io/mariadb:latest`。
- en: 'We can also check if the container is up and running by using the following
    command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过以下命令检查容器是否正在运行：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we are ready to check the output of the `podman generate systemd` command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备检查`podman generate systemd`命令的输出：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the output has been published directly in the console. Here,
    we used the `--name` option to instruct Podman that we want to manage the container
    with that name through systemd.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，输出已直接显示在控制台中。这里，我们使用了`--name`选项，指示Podman通过systemd管理容器并使用该名称。
- en: Podman generated a unit file with all the required command instructions to integrate
    our container into the operating system.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Podman生成了一个包含所有所需命令指令的单元文件，用于将容器集成到操作系统中。
- en: In the `[Unit]` section, we can see that it declared a dependency of this service
    from the network through the `network-online.target` unit. It also states the
    need for the storage mount point for `/run/containers/storage` containers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在`[Unit]`部分，我们可以看到它声明了该服务依赖于通过`network-online.target`单元连接的网络。它还声明了需要用于`/run/containers/storage`容器的存储挂载点。
- en: In the `[Service]` section, Podman defined all the instructions for describing
    how to start and stop the containerized service.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`[Service]`部分，Podman定义了描述如何启动和停止容器化服务的所有指令。
- en: 'Now, let''s look at the GIT service. First, we will create the storage directory:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看GIT服务。首先，我们将创建存储目录：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After that, we can look at the project documentation for any configuration
    that''s needed for the Gitea container image to be built correctly and complete
    the `podman run` command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以查看项目文档，了解构建Gitea容器镜像所需的任何配置，并完成`podman run`命令：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the previous Podman command, we did the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的Podman命令中，我们做了以下操作：
- en: We ran the container in detached mode.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们以分离模式运行了容器。
- en: We assigned it a name – that is, `gitea-service`.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为其指定了一个名称——即`gitea-service`。
- en: We exposed the host network for simplicity; of course, we can limit and filter
    this connectivity.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了简化操作，我们暴露了主机网络；当然，我们也可以限制并过滤这种连接。
- en: We mapped the storage volume with the newly created local directory while specifying
    the `:Z` option to correctly assign the SELinux labels.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将存储卷映射到新创建的本地目录，并指定了`:Z`选项以正确分配SELinux标签。
- en: 'Finally, we can check if the service is running properly by inspecting its
    logs:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过查看日志检查服务是否正常运行：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we can see, the Gitea service is listening on port `3000`. Let''s point
    our web browser to `http://localhost:3000` to install it with the required configuration:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Gitea服务正在`3000`端口上监听。让我们将网页浏览器指向`http://localhost:3000`，以使用所需的配置进行安装：
- en: '![Figure 14.1 – Gitea service installation page'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.1 – Gitea服务安装页面'
- en: '](img/B17908_14_01.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17908_14_01.jpg)'
- en: Figure 14.1 – Gitea service installation page
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – Gitea服务安装页面
- en: 'In the preceding screenshot, we defined the database''s type, address, username,
    and password to complete the installation. Once done, we should be redirected
    to the login page, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们定义了数据库的类型、地址、用户名和密码，以完成安装。完成后，我们应该会被重定向到登录页面，如下所示：
- en: '![Figure 14.2 – Gitea service login page'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.2 – Gitea服务登录页面'
- en: '](img/B17908_14_02.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17908_14_02.jpg)'
- en: Figure 14.2 – Gitea service login page
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 – Gitea服务登录页面
- en: 'Once the configuration is complete, we can generate and add the systemd unit
    files to the right configuration path:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 配置完成后，我们可以生成并将systemd单元文件添加到正确的配置路径中：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we can manually edit the Gitea service unit file by adding a depending
    order to the MariaDB service through the special `Requires` instruction:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以手动编辑Gitea服务单元文件，通过特殊的`Requires`指令将MariaDB服务的依赖顺序添加进去：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Thanks to the `Requires` instruction, systemd will start the MariaDB service
    first, then the Gitea service.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Requires`指令，systemd会首先启动MariaDB服务，然后启动Gitea服务。
- en: 'Now, we can stop the containers by starting them through the systemd units:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过启动systemd单元来停止容器：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Don't worry about the data – previously, we mapped both containers to a dedicated
    storage volume that holds the data.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心数据——之前，我们已将两个容器映射到一个专用存储卷中，存放着数据。
- en: 'We need to let the systemd daemon know about the new unit files we just added.
    So, first, we need to run the following command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要让systemd守护进程知道我们刚刚添加的新单元文件。因此，首先，我们需要运行以下命令：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After that, we can start the services through systemd and check their statuses:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以通过systemd启动服务并检查其状态：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we can enable the service to start them when the OS boots:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以启用该服务，使其在操作系统启动时自动启动：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With that, we have set up and enabled two containerized system services on our
    host OS. This process is simple and could be useful for leveraging the containers'
    features and capabilities, extending them to system services.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已在主机操作系统上设置并启用了两个容器化的系统服务。这个过程简单，并且有助于利用容器的功能和特性，将其扩展到系统服务中。
- en: Now, we are ready to move on to the next advanced topic, where we will learn
    how to generate Kubernetes resources.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备进入下一个高级主题，在那里我们将学习如何生成Kubernetes资源。
- en: Generating Kubernetes YAML resources
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成Kubernetes YAML资源
- en: Kubernetes has become the de facto standard for multi-node container orchestration.
    Kubernetes clusters allow multiple pods to be executed across nodes according
    to scheduling policies that reflect the node's load, labels, capabilities, or
    hardware resources (for example, GPUs).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 已成为多节点容器协调的事实标准。Kubernetes 集群允许多个 pod 根据调度策略在节点间执行，这些策略反映了节点的负载、标签、能力或硬件资源（例如
    GPU）。
- en: We have already described the concept of a pod – a single execution group of
    one or more containers that share common namespaces (network, IPC, and, optionally,
    PID namespaces). In other words, we can think of pods as sandboxes for containers.
    Containers inside a Pod are executed and thus started, stopped, or paused simultaneously.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经描述了 pod 的概念 —— 它是一个或多个容器的执行组，这些容器共享公共命名空间（网络、IPC，以及可选的 PID 命名空间）。换句话说，我们可以把
    pods 看作容器的沙箱。Pod 内的容器一起执行，因此它们的启动、停止或暂停是同时进行的。
- en: One of the most promising features that was introduced by Podman is the capability
    to generate Kubernetes resources in YAML format. Podman can intercept the configuration
    of running containers or pods and generate a `Pod` resource that is compliant
    with Kubernetes API specifications.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 引入的最有前景的功能之一是生成 YAML 格式的 Kubernetes 资源的能力。Podman 可以拦截正在运行的容器或 pod 的配置，并生成符合
    Kubernetes API 规范的 `Pod` 资源。
- en: Along with pods, we can generate `Service` and `PersistentVolumeClaim` resources
    as well, which reflect the configurations of the port mappings and volumes that
    are mounted inside containers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 pods，我们还可以生成 `Service` 和 `PersistentVolumeClaim` 资源，它们反映了容器内挂载端口映射和卷的配置。
- en: We can use the generated Kubernetes resources inside Podman itself as an alternative
    to the Docker Compose stacks or apply them inside a Kubernetes cluster to orchestrate
    the execution of simple pods.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Podman 本身内部使用生成的 Kubernetes 资源，作为 Docker Compose 堆栈的替代品，或者将它们应用到 Kubernetes
    集群中，来协调简单 Pods 的执行。
- en: 'Kubernetes has many ways to orchestrate how workloads are executed: `Deployments`,
    `StatefulSets`, `DaemonSets`, `Jobs`, and `CronJobs`. In every case, Pods are
    their workload-minimal execution units and the orchestration logic changes based
    on that specific behavior. This means that we can take a Pod resource that''s
    been generated by Podman and easily adapt it to be orchestrated in a more complex
    object, such as `Deployments`, which manages replicas and version rollouts of
    our applications, or `DaemonSets`, which guarantees that a singleton pod instance
    is created for every cluster node.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 有多种方式来协调工作负载的执行：`Deployments`、`StatefulSets`、`DaemonSets`、`Jobs`
    和 `CronJobs`。在每种情况下，Pod 是它们最小的工作负载执行单元，协调逻辑根据特定的行为进行变化。这意味着我们可以轻松地将 Podman 生成的
    Pod 资源，适配到一个更复杂的对象中进行协调，例如 `Deployments`，它管理应用程序的副本和版本更新，或 `DaemonSets`，它确保为每个集群节点创建一个单例的
    pod 实例。
- en: Now, let's learn how to generate Kubernetes YAML resources with Podman.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用 Podman 生成 Kubernetes YAML 资源。
- en: Generating basic Pod resources from running containers
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从正在运行的容器生成基本的 Pod 资源
- en: 'The basic command to generate Kubernetes resource from Podman is `podman generate
    kube`, followed by various options and arguments, as shown in the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Podman 生成 Kubernetes 资源的基本命令是 `podman generate kube`，后面跟随各种选项和参数，如以下代码所示：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can apply this command to a running container, pod, or existing volume. The
    command also allows you to use the `-s, --service` option to generate `Service`
    resources and `-f, --filename` to export contents to a file (the default is to
    standard output).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此命令应用于正在运行的容器、Pod 或现有的卷。该命令还允许您使用 `-s, --service` 选项生成 `Service` 资源，使用
    `-f, --filename` 将内容导出到文件（默认是标准输出）。
- en: 'Let''s start with a basic example of a `Pod` resource that''s been generated
    from a running container. First, we will start a rootless Nginx container:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个基本的例子开始，演示如何从一个正在运行的容器生成 `Pod` 资源。首先，我们将启动一个无 root 权限的 Nginx 容器：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When the container is created, we can generate our Kubernetes `Pod` resource:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器创建时，我们可以生成我们的 Kubernetes `Pod` 资源：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s describe the generated output. Every new Kubernetes resource is always
    composed of at least four fields:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一下生成的输出。每个新的 Kubernetes 资源总是由至少四个字段组成：
- en: '`apiVersion`: This field describes the API version schema of the resource.
    The `Pod` object belongs to the `v1` version of the `core` APIs of Kubernetes.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiVersion`：此字段描述资源的 API 版本架构。`Pod` 对象属于 Kubernetes 的 `core` API 中的 `v1` 版本。'
- en: '`kind`: This field defines the resource kind, which is `Pod` in our example.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind`：此字段定义了资源类型，在我们的示例中是 `Pod`。'
- en: '`metadata`: This field is an object that holds a set of resource metadata that
    usually includes `name`, `namespace`, `labels`, and `annotations`, along with
    additional dynamic metadata that''s created at runtime, such as `creationTimestamp`,
    `resourceVersion`, or the resource''s `uid`.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata`：此字段是一个对象，包含一组资源元数据，通常包括 `name`、`namespace`、`labels` 和 `annotations`，以及在运行时创建的附加动态元数据，例如
    `creationTimestamp`、`resourceVersion` 或资源的 `uid`。'
- en: '`spec`: This field holds resource specifications and varies among different
    resources. For example, a `Pod` resource will contain a list of `containers`,
    along with their startup arguments, volumes, ports, or security contexts.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec`：此字段包含资源规范，并在不同的资源之间有所不同。例如，`Pod` 资源将包含一个 `containers` 列表，其中包括启动参数、卷、端口或安全上下文等内容。'
- en: All the information that's embedded inside a Pod resource is enough to start
    the pod inside a Kubernetes cluster. Along with the fields described previously,
    a fifth `status` field is dynamically created when the pod is running to describe
    its execution status.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入在 Pod 资源中的所有信息足以在 Kubernetes 集群中启动该 pod。除了前面描述的字段外，Pod 运行时会动态创建第五个 `status`
    字段，用于描述其执行状态。
- en: From the generated output, we can notice an `args` list for every container,
    along with their startup commands, arguments, and options.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从生成的输出中，我们可以注意到每个容器都有一个 `args` 列表，其中包含它们的启动命令、参数和选项。
- en: 'When you''re generating a Pod from a container with mapped ports, the following
    `ports` list is created inside the Pod resource:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从一个带有映射端口的容器生成一个 Pod 时，以下 `ports` 列表会被创建到 Pod 资源中：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This means that port `80` must be exposed to the container and port `8080` must
    be exposed on the host running it. This information will be used by Podman when
    we create containers and pods with the `podman play kube` command, as we will
    see in the next section.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着端口 `80` 必须暴露给容器，端口 `8080` 必须在运行该容器的主机上暴露。Podman 会在我们使用 `podman play kube`
    命令创建容器和 Pods 时使用这些信息，正如我们将在下一节中看到的那样。
- en: The `securityContext` object defines capabilities that must be dropped for this
    container. This means that the `CAP_MKNOD`, `CAP_NET_RAW`, and `CAP_AUDIT_WRITE`
    capabilities won't be enabled on a pod that's created from this configuration.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`securityContext` 对象定义了必须为此容器丢弃的权限。这意味着在此配置中创建的 pod 将不会启用 `CAP_MKNOD`、`CAP_NET_RAW`
    和 `CAP_AUDIT_WRITE` 权限。'
- en: 'We can apply the output of the `podman generate kube` command directly to a
    Kubernetes cluster or save it to a file. To save it to a file, we can use the
    `-f` option:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `podman generate kube` 命令的输出直接应用到 Kubernetes 集群中，或将其保存到文件中。要保存到文件，我们可以使用
    `-f` 选项：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To apply the generated output to a running Kubernetes cluster, we can use the
    Kubernetes CLI tool, `kubectl`. The `kubectl create` command applies a resource
    object inside the cluster:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要将生成的输出应用于运行中的 Kubernetes 集群，我们可以使用 Kubernetes CLI 工具 `kubectl`。`kubectl create`
    命令会将资源对象应用到集群中：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The basic Pod generation command can be enriched by creating the related Kubernetes
    services, as described in the next subsection.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的 Pod 生成命令可以通过创建相关的 Kubernetes 服务来丰富，如下一个小节所述。
- en: Generating Pods and services from running containers
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从运行中的容器生成 Pods 和服务
- en: Pods running inside a Kubernetes cluster obtain unique IP addresses on a software-defined
    network that's managed by the default CNI plugin.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 运行在 Kubernetes 集群中的 Pods 会在由默认 CNI 插件管理的软件定义网络上获得唯一的 IP 地址。
- en: These IPs are not routed externally – we can only reach the Pod's IP address
    from within the cluster. However, we need a layer to balance multiple replicas
    of the same pods and provide a DNS resolution for a single abstraction frontend.
    In other words, our application must be able to query for a given service name
    and receive a unique IP address that abstracts from the pods' IPs, regardless
    of the number of replicas.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 IP 地址不会被外部路由 – 我们只能从集群内部访问 Pod 的 IP 地址。然而，我们需要一层来平衡同一 pod 的多个副本，并为单一的抽象前端提供
    DNS 解析。换句话说，我们的应用程序必须能够查询给定的服务名称，并接收到一个独特的 IP 地址，这个地址抽象了 pods 的 IP 地址，无论副本的数量如何。
- en: Important Note
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Native, cluster-scoped DNS name resolution in Kubernetes is implemented with
    the **CoreDNS** service, which is started when the cluster's control plane is
    bootstrapped. CoreDNS is delegated to resolve internal requests and to forward
    ones for external names to authoritative DNS servers outside the cluster.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，本地的集群范围DNS名称解析是通过**CoreDNS**服务实现的，该服务在集群控制平面引导时启动。CoreDNS负责解析内部请求，并将外部名称的请求转发到集群外部的权威DNS服务器。
- en: The resource that describes the abstraction in one or more pods in Kubernetes
    is called `Service`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中描述一个或多个Pod抽象的资源被称为`Service`。
- en: For example, we can have three replicas of the Nginx pod running inside our
    cluster and expose them with a unique IP. It belongs to a `ClusterIP` type, and
    its allocation is dynamic when the service is created. `ClusterIP` services are
    the default in Kubernetes and their assigned IPs are only local to the cluster.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在集群内运行三个Nginx Pod副本，并通过一个唯一的IP将它们暴露出来。它属于`ClusterIP`类型，在服务创建时分配其IP是动态的。`ClusterIP`服务是Kubernetes中的默认服务，其分配的IP仅在集群内部有效。
- en: We can also create `NodePort` type services that use **Network Address Translation**
    (**NAT**) so that the service can be reached from the external world. We can do
    this by mapping the service VIP and port to a local port on the cluster worker
    nodes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建使用**网络地址转换**（**NAT**）的`NodePort`类型服务，以便从外部世界访问该服务。我们可以通过将服务VIP和端口映射到集群工作节点的本地端口来实现这一点。
- en: If we have a cluster running on an infrastructure that allows dynamic load balancing
    (such as a public cloud provider), we can create `LoadBalancer` type services
    and have the provider manage ingress traffic load balancing for us.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的集群运行在允许动态负载均衡的基础设施上（例如公共云提供商），我们可以创建`LoadBalancer`类型服务，并让提供商为我们管理入口流量的负载均衡。
- en: 'Podman allows you to create services along with pods by adding the `-s` option
    to the `podman generate kube` command. This allows them to be potentially reused
    inside a Kubernetes cluster. The following example is a variation of the previous
    one and generates the Service resource along with the previously described Pod:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Podman允许通过在`podman generate kube`命令中添加`-s`选项来创建带有Pod的服务。这使得它们能够在Kubernetes集群中潜在地被重用。以下示例是前一个示例的变体，它生成了与先前描述的Pod一起的Service资源：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The generated output contains, along with the Pod resource, a Service resource
    that exposes the Nginx pod using a selector field. The selector matches all the
    pods with the `app: nginxpod` label.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '生成的输出包含Pod资源，同时还包含一个Service资源，通过选择器字段暴露Nginx Pod。该选择器匹配所有具有`app: nginxpod`标签的Pod。'
- en: When the service is created inside a Kubernetes cluster, an internal, non-routed
    VIP is allocated for the service. Since this is a `NodePort` type service, a `30582`
    and forward it to the service IP.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务在Kubernetes集群内创建时，会为该服务分配一个内部的、非路由的VIP。由于这是一个`NodePort`类型的服务，它会被映射到`30582`并转发到服务IP。
- en: By default, Podman generates `NodePort` type services. Whenever a container
    or pod is decorated with a port mapping, Podman populates the `ports` object with
    a list of ports and their related `nodePort` mappings inside the manifest.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Podman会生成`NodePort`类型的服务。每当容器或Pod使用端口映射时，Podman会在清单文件中填充`ports`对象，列出端口及其相关的`nodePort`映射。
- en: In our use case, we created the Nginx container by mapping its port, `80`, to
    port `8080` on the host. Here, Podman generated a Service that maps the container's
    port, `80`, to port `30582` on the cluster nodes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的使用案例中，我们通过将Nginx容器的端口`80`映射到主机的端口`8080`来创建了Nginx容器。在这里，Podman生成了一个Service，将容器的端口`80`映射到集群节点的端口`30582`。
- en: Important Note
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `nodePort` mapping is applied to Kubernetes cluster nodes only, not to standalone
    hosts running Podman.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`nodePort`映射仅适用于Kubernetes集群节点，而不适用于运行Podman的独立主机。'
- en: The value of creating Kubernetes services and pods from Podman is the ability
    to port to a Kubernetes platform.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从Podman创建Kubernetes服务和Pod的价值在于能够将其移植到Kubernetes平台。
- en: In many cases, we work with composite, multi-tier applications that need to
    be exported and recreated together. Podman allows us to export multiple containers
    into a single Kubernetes Pod object or to create and export multiple pods to gain
    more control over our application. In the next two subsections, we will see both
    cases applied to a WordPress application and try to find out what the best approach
    is.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们处理的是需要一起导出和重新创建的复合多层应用。Podman允许我们将多个容器导出为一个单一的Kubernetes Pod对象，或者创建并导出多个Pods，以便更好地控制我们的应用程序。在接下来的两个小节中，我们将看到这两种情况应用于WordPress应用，并尝试找出最佳方法。
- en: Generating a composite application in a single Pod
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在单个Pod中生成一个复合应用
- en: In this first scenario, we will implement a multi-tier application in a single
    pod. The advantage of this approach is that we can leverage the pod as a single
    unit that will execute multiple containers and that resource sharing across them
    is simplified.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个场景中，我们将实现一个在单个Pod中的多层应用。这种方法的优势在于，我们可以将Pod作为一个单一单位来执行多个容器，并且容器之间的资源共享得到了简化。
- en: We will launch two containers – one for MySQL and one for WordPress – and export
    them as a single Pod resource. We will learn how to work around some minor adjustments
    to make it work seamlessly later during run tests.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将启动两个容器——一个用于MySQL，一个用于WordPress——并将它们导出为一个单一的Pod资源。稍后在运行测试时，我们将学习如何解决一些小的调整问题，使其顺利运行。
- en: Important Note
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: The following examples have been created in a rootless context but can be seamlessly
    applied to rootfull containers too.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是在无根环境中创建的，但也可以无缝应用于有根容器。
- en: A set of scripts that will be useful for launching the stacks and the generated
    Kubernetes YAML files are available in this book's GitHub repository at [https://github.com/PacktPublishing/Podman-for-DevOps/tree/main/Chapter14/kube](https://github.com/PacktPublishing/Podman-for-DevOps/tree/main/Chapter14/kube).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一些用于启动堆栈和生成的Kubernetes YAML文件的脚本，可以在本书的GitHub仓库中找到，网址为[https://github.com/PacktPublishing/Podman-for-DevOps/tree/main/Chapter14/kube](https://github.com/PacktPublishing/Podman-for-DevOps/tree/main/Chapter14/kube)。
- en: 'First, we must create two volumes that will be used later by the WordPress
    and MySQL containers:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须创建两个卷，这些卷稍后将由WordPress和MySQL容器使用：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we must create an empty pod named `wordpress-pod` with the necessary
    pre-defined port mappings:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们必须创建一个名为`wordpress-pod`的空Pod，并进行必要的预定义端口映射：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we can populate our pod by creating the WordPress and MySQL containers.
    Let''s begin with the MySQL container:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过创建WordPress和MySQL容器来填充我们的Pod。让我们从MySQL容器开始：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we can create the WordPress container:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建WordPress容器：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we can see that the `WORDPRESS_DB_HOST` variable has been set to `127.0.0.1`
    (the address of the loopback device) since the two containers are going to run
    in the same pod and share the same network namespace. For this reason, we let
    the WordPress container know that the MySQL service is listening on the same loopback
    device.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`WORDPRESS_DB_HOST`变量已被设置为`127.0.0.1`（回环设备的地址），因为这两个容器将在同一个Pod中运行，并共享相同的网络命名空间。因此，我们让WordPress容器知道MySQL服务正在同一个回环设备上监听。
- en: 'Finally, we can start the pod with the `podman pod start` command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`podman pod start`命令启动Pod：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can inspect the running containers with `podman ps`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`podman ps`来检查正在运行的容器：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we can point our browser to `http://localhost:8080` and confirm the appearance
    of the WordPress setup dialog screen:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将浏览器指向`http://localhost:8080`，并确认WordPress设置对话框的界面：
- en: '![Figure 14.3 – WordPress setup dialog screen'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.3 – WordPress设置对话框界面'
- en: '](img/B17908_14_03.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17908_14_03.jpg)'
- en: Figure 14.3 – WordPress setup dialog screen
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 – WordPress设置对话框界面
- en: Important Note
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: The pod also started a third `podman-pause` image that initializes the pod's
    network and the IPC namespaces of our example. The image is built directly in
    the background on the host the first time a pod is created and executes a `catatonit`
    process, an `init` micro container written in C that's designed to handle system
    signals and zombie process reaping.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 该Pod还启动了一个第三个`podman-pause`镜像，用于初始化Pod的网络和我们示例的IPC命名空间。该镜像在第一次创建Pod时直接在主机后台构建，并执行一个`catatonit`进程，这是一个用C语言编写的`init`微型容器，旨在处理系统信号和收割僵尸进程。
- en: This behavior of the pod's infra image is directly inherited from Kubernetes's
    design.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 该Pod的基础镜像行为直接继承自Kubernetes的设计。
- en: 'Now, we are ready to generate our Pod YAML manifest with the `podman generate
    kube` command and save it to a file for reuse:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备使用`podman generate kube`命令生成 Pod YAML 清单，并将其保存到文件中以供重用：
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding command generates a file with the following content:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令生成了一个包含以下内容的文件：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Our YAML file holds a single Pod resource with two containers inside. Note that
    the previously defined environment variables have been created correctly inside
    our containers (when using Podman v4.0.0 or later).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 YAML 文件包含一个单一的 Pod 资源，其中有两个容器。请注意，之前定义的环境变量已正确创建在我们的容器内（当使用 Podman v4.0.0
    或更高版本时）。
- en: Also, notice that the two container volumes have been mapped to `PersistentVolumeClaim`
    objects, often referred to as `PVC` objects.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，两个容器卷已映射到`PersistentVolumeClaim`对象，通常称为`PVC`对象。
- en: PVCs are Kubernetes resources that are used to request (in other words, claim)
    a storage volume resource that satisfies a specific capacity and consumption modes.
    The attached storage volume resource is called a `PersistentVolume` (`PV`) and
    can be created manually or automatically by a `StorageClass` resource that leverages
    a storage driver that's compliant with the **Container Storage Interface** (**CSI**).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: PVC 是 Kubernetes 资源，用于请求（即声明）一个满足特定容量和消费模式的存储卷资源。附加的存储卷资源被称为`PersistentVolume`（`PV`），可以通过手动创建或由符合
    **容器存储接口**（**CSI**）的存储驱动程序自动创建的`StorageClass`资源来创建。
- en: When we create a PVC, `StorageClass` provisions a `PersistentVolume` that satisfied
    our storage requests, and the two resources are bound together. This approach
    decouples the storage request from storage provisioning and makes storage consumption
    in Kubernetes more portable.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 PVC 时，`StorageClass` 会配置一个满足我们存储请求的`PersistentVolume`，并将这两个资源绑定在一起。这种方法将存储请求与存储配置解耦，使
    Kubernetes 中的存储消费更具可移植性。
- en: When Podman generates Kubernetes YAML files, PVC resources are not exported
    by default. However, we can also export the PVC resources to recreate them in
    Kubernetes with the `podman generate kube <VOLUME_NAME>` command.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Podman 生成 Kubernetes YAML 文件时，默认情况下 PVC 资源不会被导出。然而，我们也可以通过`podman generate
    kube <VOLUME_NAME>`命令导出 PVC 资源，以便在 Kubernetes 中重新创建它们。
- en: 'The following command exports the WordPress application, along with its volume
    definitions, as a PVC:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令导出了 WordPress 应用程序及其卷定义，作为一个 PVC：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following is an example of the `dbvol` volume translated into a `PersistentVolumeClaim`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将`dbvol`卷转换为`PersistentVolumeClaim`的示例：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This approach has the advantage of providing the necessary PVC definitions
    to recreate the whole application in a Kubernetes cluster, but it is not necessary
    to recreate the volume resources in Podman: if they''re not available, an empty
    volume with the same name will be created automatically.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点在于提供了必要的 PVC 定义，用于在 Kubernetes 集群中重建整个应用程序，但在 Podman 中并不需要重建卷资源：如果它们不存在，将自动创建一个具有相同名称的空卷。
- en: To recreate all the resource dependencies in a Kubernetes cluster, we can also
    export the application's `Service` resource.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重建 Kubernetes 集群中的所有资源依赖关系，我们还可以导出应用程序的`Service`资源。
- en: 'The following command exports everything in our WordPress example, including
    pods, services, and volumes:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令导出了我们 WordPress 示例中的所有内容，包括 Pod、服务和卷：
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Before we move on, let's briefly dig into the single pod approach logic that
    was described in this subsection and look at its advantages and possible limitations.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们简要地探讨一下本小节中描述的单个 Pod 方法的逻辑，并看看它的优点和可能的局限性。
- en: One great advantage of executing all the containers in a single pod is the simpler
    networking configuration – one network namespace is shared by all the running
    containers. This also means we don't have to create a dedicated Podman network
    to let the containers communicate with each other.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 执行所有容器在一个单一 Pod 中的一个巨大优势是简化了网络配置——所有运行的容器共享一个网络命名空间。这也意味着我们不必为容器之间的通信创建一个专门的
    Podman 网络。
- en: On the other hand, this approach does not reflect the common Kubernetes pattern
    of executing pods. In Kubernetes, we would prefer to split the WordPress pod and
    the MySQL pod to manage them independently and have different services associated
    with them. More separation implies more control and the chance to update independently.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这种方法并没有反映出 Kubernetes 执行 Pod 的常见模式。在 Kubernetes 中，我们更倾向于将 WordPress Pod
    和 MySQL Pod 分开，以便独立管理它们，并为它们关联不同的服务。更多的分离意味着更多的控制权，以及独立更新的机会。
- en: In the next subsection, you'll learn how to replicate this approach and generate
    multiple pods for every application tier.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，你将学习如何复制这种方法，并为每个应用层生成多个 Pod。
- en: Generating composite applications with multiple Pods
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成多个 Pod 的复合应用
- en: One of the features of Docker Compose is that you can create different independent
    containers that communicate with each other using a service abstraction concept
    that is decoupled from the container's execution.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 的一大特点是，你可以创建不同的独立容器，它们通过服务抽象概念互相通信，这个概念与容器的执行是解耦的。
- en: The Podman community (and many of its users) believe that a standardization
    toward Kubernetes YAML manifests to describe complex workloads is useful to get
    closer to the mainstream orchestration solution.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 社区（及其许多用户）认为，向 Kubernetes YAML 清单的标准化是描述复杂工作负载的一种有效方法，有助于我们更接近主流的编排解决方案。
- en: For this reason, the approach we'll describe in this section can become a full
    replacement for Docker Compose while providing Kubernetes portability at the same
    time. First, we will learn how to prepare an environment that can be used to generate
    the YAML manifests. After that, we can get rid of the workloads and only use the
    Kubernetes YAML to run our workloads.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将在本节中描述的方法可以完全替代 Docker Compose，同时提供 Kubernetes 的可移植性。首先，我们将学习如何准备一个可以用于生成
    YAML 清单的环境。之后，我们可以摆脱工作负载，只使用 Kubernetes YAML 来运行我们的工作负载。
- en: The following example can be executed with rootless containers and networks.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以在无根容器和网络环境中执行。
- en: Important Note
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Before continuing, make sure that the previous example pod and containers have
    been completely removed, along with their volumes, to prevent any issues with
    port assignment or WordPress content initialization. Please refer to the commands
    in this book''s GitHub repository as a reference: [https://github.com/PacktPublishing/Podman-for-DevOps/tree/main/AdditionalMaterial](https://github.com/PacktPublishing/Podman-for-DevOps/tree/main/AdditionalMaterial).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保之前的示例 Pod 和容器已经完全移除，连同它们的卷一起删除，以避免端口分配或 WordPress 内容初始化出现问题。请参考本书 GitHub
    仓库中的命令：[https://github.com/PacktPublishing/Podman-for-DevOps/tree/main/AdditionalMaterial](https://github.com/PacktPublishing/Podman-for-DevOps/tree/main/AdditionalMaterial)。
- en: 'First, we need to create a network. We have chosen the name `kubenet` to identify
    it easily and leave it with the default configuration for the sake of our example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个网络。我们选择了 `kubenet` 作为名称，方便识别，并且为了示范，保留默认配置：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once the network has been created, the two `dbvol` and `wpvol` volumes must
    be created:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦网络创建完毕，必须创建两个 `dbvol` 和 `wpvol` 卷：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We want to generate two distinct pods – one for each container. First, we must
    create the MySQL pod and its related container:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望生成两个独立的 Pod —— 每个容器一个。首先，我们必须创建 MySQL Pod 及其相关容器：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Notice the port mapping, which we can use to access the MySQL service from a
    client and create the correct port mapping later in the Kubernetes service.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意端口映射，我们可以用它从客户端访问 MySQL 服务，并稍后在 Kubernetes 服务中创建正确的端口映射。
- en: 'Now, let''s create the WordPress pod and container:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建 WordPress Pod 和容器：
- en: '[PRE41]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'There is a very important variable in the preceding command that can be considered
    the key to this approach: `WORDPRESS_DB_HOST` is populated with the `mysql-pod`
    string, which is the name that''s been given to the MySQL pod.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，有一个非常重要的变量，可以认为是该方法的关键：`WORDPRESS_DB_HOST` 被填充为 `mysql-pod` 字符串，这是分配给
    MySQL pod 的名称。
- en: In Podman, the pod's name will act as the service name of the application and
    the DNS daemon associated with the network (`dnsmasq` in Podman 3 or `aardvark-dns`
    in Podman 4) will directly resolve the pod name to the associated IP address.
    This is a key feature that makes multi-pod applications a perfect replacement
    for Compose stacks.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Podman 中，Pod 的名称将充当应用的服务名称，与网络相关的 DNS 守护进程（在 Podman 3 中是 `dnsmasq`，在 Podman
    4 中是 `aardvark-dns`）会直接将 Pod 名称解析为关联的 IP 地址。这是一个关键特性，使得多 Pod 应用成为 Compose 堆栈的完美替代品。
- en: 'Now, we can start the two pods and have all the containers up and running:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动这两个 Pod，并让所有容器都运行起来：
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Once again, pointing our browsers to `http://localhost:8080` should lead us
    to the WordPress first setup page (if everything was set up correctly).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说一次，我们只需将浏览器指向 `http://localhost:8080`，应该会引导我们进入 WordPress 的首次设置页面（如果一切设置正确）。
- en: Now, we are ready to export our Kubernetes YAML manifest. We can choose to simply
    export the two Pod resources or create a full export that also includes services
    and volumes. This is useful if you need to import to a Kubernetes cluster.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好导出 Kubernetes YAML 清单了。我们可以选择仅导出两个 Pod 资源，或创建一个完整的导出，其中还包括服务和卷。如果你需要将其导入到
    Kubernetes 集群中，这将非常有用。
- en: 'Let''s start with the basic version:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从基本版本开始：
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output of the preceding code will contain nothing but the two Pod resources:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出将仅包含两个 Pod 资源：
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The resulting file is also available in this book''s GitHub repository:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的文件也可以在本书的 GitHub 仓库中找到：
- en: '[https://github.com/PacktPublishing/Podman-for-DevOps/blob/main/Chapter14/kube/wordpress-multi-pod-basic.yaml](https://github.com/PacktPublishing/Podman-for-DevOps/blob/main/Chapter14/kube/wordpress-multi-pod-basic.yaml)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Podman-for-DevOps/blob/main/Chapter14/kube/wordpress-multi-pod-basic.yaml](https://github.com/PacktPublishing/Podman-for-DevOps/blob/main/Chapter14/kube/wordpress-multi-pod-basic.yaml)'
- en: As we will see in the next section, this YAML file is enough to recreate a fully
    working WordPress application on Podman from scratch. We can persist and version
    it on a source control repository such as Git for future reuse.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在下一节中看到的，这个 YAML 文件足以从头开始在 Podman 上重建一个完全可运行的 WordPress 应用程序。我们可以将其保存在源代码控制仓库（如
    Git）中，并进行版本管理，以便将来重用。
- en: 'The following code exports the two `Pod` resources, along with the `PersistentVolumeClaim`
    and `Service` resources:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码导出了两个 `Pod` 资源，以及 `PersistentVolumeClaim` 和 `Service` 资源：
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output of this command is also available in this book''s GitHub repository:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出也可以在本书的 GitHub 仓库中找到：
- en: '[https://github.com/PacktPublishing/Podman-for-DevOps/blob/main/Chapter14/kube/wordpress-multi-pod-full.yaml](https://github.com/PacktPublishing/Podman-for-DevOps/blob/main/Chapter14/kube/wordpress-multi-pod-full.yaml)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Podman-for-DevOps/blob/main/Chapter14/kube/wordpress-multi-pod-full.yaml](https://github.com/PacktPublishing/Podman-for-DevOps/blob/main/Chapter14/kube/wordpress-multi-pod-full.yaml)'
- en: This full manifest is useful for importing and testing our application on a
    Kubernetes cluster, where the `Service` and `PersistentVolumeClaim` resources
    are necessary.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个完整的清单对于在 Kubernetes 集群中导入和测试我们的应用程序非常有用，其中 `Service` 和 `PersistentVolumeClaim`
    资源是必需的。
- en: Now, we are ready to test our generated resources in Podman and learn how to
    reproduce full stack deployments with simple operations.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好在 Podman 中测试生成的资源，并学习如何通过简单操作重现完整堆栈部署。
- en: Running Kubernetes resource files in Podman
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Podman 中运行 Kubernetes 资源文件
- en: Now that we've learned how to generate Kubernetes YAML files containing the
    necessary resources to deploy our applications, we want to test them in a real
    scenario.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何生成包含必要资源的 Kubernetes YAML 文件，以部署我们的应用程序，我们希望在真实场景中进行测试。
- en: For this book, we will use the WordPress application again, both in its simple
    form with a single container and in its multi-pod variation.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们将再次使用 WordPress 应用程序，既使用其单个容器的简单形式，也使用其多 Pod 变体。
- en: The following examples are also available in this book's GitHub repository –
    you can choose to use the resources that have been generated from your labs or
    use the prepared manifests in this book's repository.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的以下示例也可在 GitHub 仓库中找到——你可以选择使用从实验中生成的资源，或使用本书仓库中准备好的清单。
- en: Important Note
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Don't forget to clean up all the previous workloads before testing the creation
    of Kubernetes resources with Podman.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 Podman 创建 Kubernetes 资源之前，请别忘了清理所有之前的工作负载。
- en: For all our examples, we will use the `podman play kube` command. It offers
    us an easy and intuitive interface for managing the execution of complex stacks
    with a good degree of customization.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有示例，我们将使用 `podman play kube` 命令。它为我们提供了一个简单直观的接口，用于管理复杂堆栈的执行，并具有良好的自定义能力。
- en: 'The first example will be based on the single-pod manifest:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例将基于单个 Pod 清单：
- en: '[PRE46]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The preceding command creates a pod called `wordpress-pod` that''s composed
    of the two containers, along with the necessary volumes. Let''s inspect the results
    and see what happened:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令创建了一个名为 `wordpress-pod` 的 Pod，该 Pod 包含两个容器以及所需的卷。让我们检查一下结果，看看发生了什么：
- en: '[PRE47]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can also check the running containers. Here, we expect to see the two WordPress
    and MySQL containers and the third infra-related `podman-pause`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查正在运行的容器。在这里，我们预计会看到两个 WordPress 和 MySQL 容器以及第三个与基础设施相关的 `podman-pause`：
- en: '[PRE48]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, we can verify if the `dbvol` and `wpvol` volumes have been created:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以验证是否已创建 `dbvol` 和 `wpvol` 卷：
- en: '[PRE49]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Before we look at the more articulated (and interesting) example with the multi-pod
    manifest, we must clean up the environment. We can do this manually or by using
    the `--down` option of the `podman play kube` command, which immediately stops
    and removes the running pods:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看更详细（且有趣的）多Pod示例之前，我们必须清理环境。我们可以手动执行此操作，也可以使用`--down`选项，通过`podman play kube`命令立即停止并删除正在运行的Pod：
- en: '[PRE50]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Important Note
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Volumes are not removed by default since it can be useful to keep them if containers
    have already written data on them. To remove unused volumes, use the `podman volume
    prune` command.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，卷不会被删除，因为如果容器已在其上写入数据，保留它们可能会很有用。要删除未使用的卷，可以使用`podman volume prune`命令。
- en: 'Now, let''s run the multi-pod example using the basic exported manifest:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用基本导出的清单运行多Pod示例：
- en: '[PRE51]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Notice the additional `--network` argument, which is used to specify the network
    that the pods will be attached to. This is necessary information since the Kubernetes
    YAML file contains no information about Podman networks. Our pods will be executed
    in rootless mode and attached to the rootless `kubenet` network.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意额外的`--network`参数，该参数用于指定Pod将连接到的网络。这是必要的信息，因为Kubernetes YAML文件中没有关于Podman网络的信息。我们的Pod将以无根模式执行，并连接到无根`kubenet`网络。
- en: 'We can check that the two pods have been created correctly by using the following
    command:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令检查这两个Pod是否已正确创建：
- en: '[PRE52]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, we can inspect the running containers. The strings that are highlighted
    in the following code represent the main workload to differentiate from the infra
    containers:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以检查正在运行的容器。以下代码中突出显示的字符串代表主要工作负载，以便与基础设施容器区分开来：
- en: '[PRE53]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `podman volume ls` command confirms the existence of the two volumes:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman volume ls`命令确认了两个卷的存在：'
- en: '[PRE54]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The rootless network configuration can be inspected with the `podman unshare`
    command:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`podman unshare`命令检查无根网络配置：
- en: '[PRE55]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Important Note
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `--rootless-netns` option is only available on Podman 4, which is the recommended
    version for this chapter.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`--rootless-netns`选项仅在Podman 4中可用，这是本章节推荐使用的版本。'
- en: Finally, let's inspect the DNS behavior. On Podman 4, the name resolution for
    custom networks is managed by the `aardvark-dns` daemon, while on Podman 3, it
    is managed by `dnsmasq`. Since we assume you're using Podman 4 for these examples,
    let's look at its DNS configuration. For rootless networks, we can find the managed
    records in the `/run/user/<UID>/containers/networks/aardvark-dns/<NETWORK_NAME>`
    file.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们检查DNS的行为。在Podman 4中，定制网络的名称解析由`aardvark-dns`守护进程管理，而在Podman 3中，则由`dnsmasq`管理。由于我们假设你在这些示例中使用的是Podman
    4，让我们来看一下它的DNS配置。对于无根网络，我们可以在`/run/user/<UID>/containers/networks/aardvark-dns/<NETWORK_NAME>`文件中找到管理的记录。
- en: 'In our example, the configuration for the `kubenet` network is as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`kubenet`网络的配置如下：
- en: '[PRE56]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The most amazing thing from this output is the confirmation that the name resolution
    now works at the pod level, not at the container level. This is fair if we think
    that the pod initialized the namespaces, including the network namespace. For
    this reason, we can treat the pod name in Podman as a service name.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中最令人惊讶的事情是确认名称解析现在在Pod级别工作，而不是在容器级别。如果我们考虑到Pod初始化了命名空间，包括网络命名空间，这也是合理的。因此，我们可以将Podman中的Pod名称视为服务名称。
- en: Here, we demonstrated how the Kubernetes manifests that are generated with Podman
    can become a great replacement for the Docker Compose approach while being more
    portable. Now, let's learn how to import our generated resources into a test Kubernetes
    cluster.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们演示了如何使用Podman生成的Kubernetes清单成为一个出色的替代方案，取代Docker Compose方法，同时更加便携。现在，让我们学习如何将生成的资源导入到一个测试Kubernetes集群中。
- en: Testing the results in Kubernetes
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes中测试结果
- en: In this section, we want to import the multi-pod YAML file, which is enriched
    with the Services and PVC configurations, on Kubernetes.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们要将多Pod YAML文件导入到Kubernetes中，该文件已经添加了Services和PVC配置。
- en: To provide a repeatable environment, we will use **minikube** (with a lowercase
    m), a portable solution, to create an all-in-one Kubernetes cluster as the local
    infrastructure.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个可重复的环境，我们将使用**minikube**（小写的m），这是一种便携式解决方案，用于创建一个一体化的Kubernetes集群作为本地基础设施。
- en: The minikube project aims to provide a local Kubernetes cluster on Linux, Windows,
    and macOS. It uses host virtualization to spin up a VM that runs the all-in-one
    cluster or containerization to create a control plane that runs inside a container.
    It also provides a large set of add-ons to extend cluster functionalities, such
    as ingress controllers, service meshes, registries, logging, and more.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: minikube 项目旨在为 Linux、Windows 和 macOS 提供本地 Kubernetes 集群。它使用主机虚拟化启动一个虚拟机，运行所有集群功能，或使用容器化创建一个控制平面，该平面运行在容器内部。它还提供了一整套附加组件，扩展集群功能，例如入口控制器、服务网格、注册表、日志记录等。
- en: Another widely adopted alternative to spinning up a local Kubernetes cluster
    is the **Kubernetes in Docker** (**KinD**) project, which is not described in
    this book. KinD runs a Kubernetes control plane inside a container that's driven
    by Docker or Podman.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种广泛采用的启动本地 Kubernetes 集群的替代方法是 **Kubernetes in Docker**（**KinD**）项目，本书未描述此方法。KinD
    将 Kubernetes 控制平面运行在由 Docker 或 Podman 驱动的容器内。
- en: To set up minikube, users need virtualization support (KVM, VirtualBox, Hyper-V,
    Parallels, or VMware) or a container runtime such as Docker or Podman.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置 minikube，用户需要虚拟化支持（KVM、VirtualBox、Hyper-V、Parallels 或 VMware）或容器运行时，例如 Docker
    或 Podman。
- en: For brevity, we will not cover the technical steps necessary to configure the
    virtualization support for the different OSs; instead, we will use a GNU/Linux
    distribution.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们将不涉及为不同操作系统配置虚拟化支持所需的技术步骤；相反，我们将使用一个GNU/Linux发行版。
- en: Important Note
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you already own a running Kubernetes cluster or want to set up one in an
    alternative way, you can skip the next minikube configuration quick start and
    go to the *Running generated resource files in Kubernetes* subsection.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经拥有一个正在运行的 Kubernetes 集群，或者希望以其他方式设置一个集群，您可以跳过下一步的 minikube 配置快速启动，直接进入
    *在 Kubernetes 中运行生成的资源文件* 子部分。
- en: Setting up minikube
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 minikube
- en: 'Run the following commands to download and install the latest `minikube` binary:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令下载并安装最新的`minikube`二进制文件：
- en: '[PRE57]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You can choose to run minikube with a virtualization or containerization driver.
    To run minikube as a virtual machine on the KVM driver, you must install the **Qemu/KVM**
    and **libvirt** packages.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择使用虚拟化或容器化驱动程序运行 minikube。若要在 KVM 驱动程序上将 minikube 作为虚拟机运行，您必须安装 **Qemu/KVM**
    和 **libvirt** 软件包。
- en: 'On Fedora, run the following command to install all the mandatory and default
    packages using the `@virtualization` package group:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Fedora 上，运行以下命令使用 `@virtualization` 软件包组安装所有强制性和默认的软件包：
- en: '[PRE58]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, start and enable the `libvirtd` service:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动并启用 `libvirtd` 服务：
- en: '[PRE59]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To grant the user running minikube the proper permissions, append it to the
    `libvirt` supplementary group (this operation requires a new login to load the
    new group):'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为了授予运行 minikube 的用户适当的权限，将其添加到 `libvirt` 补充组中（此操作需要重新登录以加载新组）：
- en: '[PRE60]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The following command statically configures the `kvm2` driver as the default:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将静态配置 `kvm2` 驱动程序为默认驱动程序：
- en: '[PRE61]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: When the preceding command is executed for the first time, minikube will automatically
    download the proper `kvm2` driver binary before starting the VM.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行上述命令时，minikube 会在启动虚拟机之前自动下载合适的 `kvm2` 驱动程序二进制文件。
- en: 'Alternatively, you can choose to run minikube as a containerized service with
    Docker or Podman. Assuming Podman is already installed, we only need to ensure
    that the user running minikube can run passwordless sudo. This is necessary since
    the Kubernetes cluster must run in a rootfull container, so privilege escalation
    is necessary. To allow passwordless privilege escalation for Podman, edit the
    `/etc/sudoers` file with the following command:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以选择将 minikube 作为 Docker 或 Podman 的容器化服务运行。假设 Podman 已经安装，我们只需要确保运行 minikube
    的用户可以运行无密码的 sudo。这是必需的，因为 Kubernetes 集群必须在 rootfull 容器中运行，因此需要提升权限。要允许 Podman
    无密码提升权限，请使用以下命令编辑 `/etc/sudoers` 文件：
- en: '[PRE62]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Once opened, add the following line to the end of the file to grant passwordless
    escalation for the Podman binary and save it. Remember to replace `<username>`
    with your user''s name:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件后，在文件末尾添加以下行，以便为 Podman 二进制文件授予无密码提升权限，并保存文件。记得将 `<username>` 替换为您的用户名：
- en: '[PRE63]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The following command statically configures the `podman` driver as the default:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将静态配置 `podman` 驱动程序为默认驱动程序：
- en: '[PRE64]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Important Note
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If your host is a virtual machine running on a hypervisor such as KVM and Podman
    is installed on the host, minikube will detect the environment and set up the
    default driver as `podman` automatically.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的主机是运行在虚拟化平台（如 KVM）上的虚拟机，并且在主机上安装了 Podman，minikube 将会自动检测环境并将默认驱动程序设置为 `podman`。
- en: 'To use minikube, users also need to install the Kubernetes CLI tool, kubectl.
    The following commands download and install the latest Linux release:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 minikube 时，用户还需要安装 Kubernetes CLI 工具 kubectl。以下命令用于下载并安装最新的 Linux 版本：
- en: '[PRE65]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now, we are ready to run our Kubernetes cluster with minikube.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好使用 minikube 运行我们的 Kubernetes 集群。
- en: Starting minikube
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动 minikube
- en: 'To start minikube as a VM, use the CRI-O container runtime inside the Kubernetes
    cluster:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 minikube 启动为虚拟机，请在 Kubernetes 集群内使用 CRI-O 容器运行时：
- en: '[PRE66]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `--driver` option is not necessary if `kvm2` has already been configured
    as the default driver with the `minikube config set driver` command.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `kvm2` 已通过 `minikube config set driver` 命令配置为默认驱动程序，则不需要使用 `--driver` 选项。
- en: 'To start minikube with Podman, use the CRI-O container runtime inside the cluster:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Podman 启动 minikube，可以在集群内使用 CRI-O 容器运行时：
- en: '[PRE67]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Again, the `--driver` option is not necessary if `podman` has been already configured
    as the default driver with the `minikube config set driver` command.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已通过 `minikube config set driver` 命令将 `podman` 配置为默认驱动程序，则 `--driver` 选项不是必需的。
- en: 'To ensure that the cluster has been created correctly, run the following command
    with the `kubectl` CLI. All the pods should have the `Running` status:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保集群正确创建，使用 `kubectl` CLI 运行以下命令。所有 Pod 应该处于 `Running` 状态：
- en: '[PRE68]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Important Note
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If one or more containers still have the `ContainerCreating` status, wait a
    little longer for the images to be pulled.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个或多个容器仍处于 `ContainerCreating` 状态，请稍等片刻，等待镜像拉取完成。
- en: Also, notice that the output may differ slightly if you're running minikube
    with a Podman driver. In that case, an additional pod named `kindnet` will be
    created to help manage CNI networking inside the cluster.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，如果您使用 Podman 驱动程序运行 minikube，输出可能会稍有不同。在这种情况下，会额外创建一个名为 `kindnet` 的 Pod，以帮助管理集群内的
    CNI 网络。
- en: With that, we have set everything up for a local Kubernetes environment and
    are ready to test our generated manifests.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就为本地 Kubernetes 环境做好了所有设置，准备测试我们生成的清单。
- en: Running generated resource files in Kubernetes
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中运行生成的资源文件
- en: In the *Generating a composite application with multiple Pods* section, we learned
    how to export a manifest file from Podman that included the `Pod` resources, along
    with the `Service` and `PersistentVolumeClaim` resources. The need to export this
    set of resources is related to the way Kubernetes handles workloads, storage,
    and exposed services.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *生成包含多个 Pod 的复合应用程序* 部分中，我们学习了如何从 Podman 导出包含 `Pod` 资源、`Service` 资源和 `PersistentVolumeClaim`
    资源的清单文件。导出这些资源集的需求与 Kubernetes 处理工作负载、存储和暴露服务的方式有关。
- en: Kubernetes services are needed to provide a resolution mechanism, as well as
    internal load balancing. In our example, the `mysql-pod` pod will be mapped to
    a homonymous `mysql-pod` service.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 服务用于提供解析机制以及内部负载均衡。在我们的示例中，`mysql-pod` Pod 将映射到同名的 `mysql-pod` 服务。
- en: PVCs are required to define a storage claim that starts provisioning persistent
    volumes for our pods. In minikube, automated provisioning is implemented by a
    local `StorageClass` named `minikube-hostpath`; it creates local directories in
    the VM/container filesystem that are later bind-mounted inside the pods' containers.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: PVCs（持久卷声明）用于定义一个存储声明，开始为我们的 Pod 配置持久卷。在 minikube 中，自动化配置由一个名为 `minikube-hostpath`
    的本地 `StorageClass` 实现；它会在虚拟机/容器的文件系统中创建本地目录，随后将这些目录挂载到 Pod 的容器内。
- en: 'We can roll out our WordPress stack by using the `kubectl create` command:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `kubectl create` 命令来部署我们的 WordPress 堆栈：
- en: '[PRE69]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: If not specified, all the resources will be created in the `default` Kubernetes
    namespace. Let's wait for the pods to reach the `Running` status and inspect the
    results.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定，所有资源将会在 `default` Kubernetes 命名空间中创建。我们等待 Pod 进入 `Running` 状态，并检查结果。
- en: 'First, we can inspect the pods and services that have been created:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以检查已经创建的 Pods 和服务：
- en: '[PRE70]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Notice that the two `mysql-pod` and `wordpress-pod` services have been created
    with the `NodePort` type and mapped to a port on a `30000` or upper range. We
    will use the `30408` port to test the WordPress frontend.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，两个 `mysql-pod` 和 `wordpress-pod` 服务已经创建，并且类型为 `NodePort`，映射到了 `30000` 或更高范围的端口。我们将使用
    `30408` 端口来测试 WordPress 前端。
- en: 'The pods are mapped by the services using label matching logic. If the labels
    that have been defined in the service''s `selector` field exist in the pod, it
    becomes an `endpoint` to the service itself. Let''s view the current endpoints
    in our project:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Pods 由服务使用标签匹配逻辑进行映射。如果服务的 `selector` 字段中定义的标签在 pod 中存在，则该 pod 成为服务本身的 `endpoint`。让我们查看当前项目中的端点：
- en: '[PRE71]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Important Note
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `kubernetes` service and its related endpoint provide API access to internal
    workloads. However, it is not part of this book's examples, so it can be ignored
    in this context.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubernetes` 服务及其相关端点提供了对内部工作负载的 API 访问。然而，这不是本书示例的一部分，因此可以在此上下文中忽略。'
- en: 'Let''s also inspect the claims and their related volumes:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还检查一下声明和它们相关的卷：
- en: '[PRE72]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The two PVC resources have been created and bound to two dynamically provisioned
    persistent volumes. So long as the PVC objects exist, the related PV will stay
    untouched, even if the pods are destroyed and recreated.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个 PVC 资源已经创建并绑定到两个动态配置的持久卷。只要 PVC 对象存在，相关的 PV 就会保持不变，即使 Pods 被销毁并重新创建。
- en: Now, the WordPress application can be tested. By default, minikube does not
    deploy an ingress controller (even though this can be enabled with the `minikube
    addons enable ingress` command), so we will use the simple NodePort service to
    test the functionalities of our application.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以测试 WordPress 应用程序。默认情况下，minikube 不部署 ingress 控制器（尽管可以通过 `minikube addons
    enable ingress` 命令启用它），因此我们将使用简单的 NodePort 服务来测试我们应用程序的功能。
- en: 'The current minikube VM/container IP must be obtained to reach the exposed
    NodePort service. Port `30408`, which is associated with the `wordpress-pod` service,
    listens to the IP address that''s produced by the following command:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 必须获取当前 minikube 虚拟机/容器的 IP 地址，才能访问暴露的 NodePort 服务。端口 `30408` 与 `wordpress-pod`
    服务关联，监听由以下命令生成的 IP 地址：
- en: '[PRE73]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now, we can point our browser to `http://10.88.0.6:30408` and see the WordPress
    first setup screen.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在浏览器中访问 `http://10.88.0.6:30408` 并查看 WordPress 的首次设置页面。
- en: 'To remove the WordPress application and all its related content, use the `kubectl
    delete` command in the YAML manifest file:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除 WordPress 应用程序及其所有相关内容，可以在 YAML 清单文件中使用 `kubectl delete` 命令：
- en: '[PRE74]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This command removes all the resources that have been defined in the file, including
    the generated PVs.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令会删除文件中已定义的所有资源，包括生成的 PVs。
- en: Summary
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With that, we have reached the end of this book about Podman and its companion
    tools.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已完成关于 Podman 及其相关工具的本书内容。
- en: First, we learned how to generate Systemd unit files and control containerized
    workloads as Systemd services, which allows us to, for example, automate container
    execution at system startup.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们学习了如何生成 Systemd 单元文件并将容器化的工作负载作为 Systemd 服务进行控制，这使得我们可以例如在系统启动时自动执行容器。
- en: After that, we learned how to generate Kubernetes YAML resources. Starting with
    basic concepts and examples, we learned how to generate complex application stacks
    using both single-pod and multiple pods approaches and illustrated how the latter
    can provide a great alternative (and Kubernetes compliant) to the Docker Compose
    methodology.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们学习了如何生成 Kubernetes YAML 资源。从基本概念和示例开始，我们学习了如何使用单个 Pod 和多个 Pod 的方法生成复杂的应用栈，并展示了后者如何提供一个很好的替代方案（并符合
    Kubernetes 标准）来代替 Docker Compose 方法。
- en: Finally, we tested our results on Podman and a local Kubernetes cluster that
    had been created with `minikube` to show the great portability of this approach.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 Podman 和通过 `minikube` 创建的本地 Kubernetes 集群上测试了我们的结果，展示了这种方法的出色可移植性。
- en: This book's journey finishes here, but Podman's amazing evolution continues
    thanks to its growing adoption in many contexts and its vibrant and helpful community.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的旅程在这里结束，但由于 Podman 在许多场景中的广泛应用和其充满活力且乐于助人的社区，Podman 的惊人演变仍在继续。
- en: Before you move on, don't forget to join the community on IRC, Matrix, or Discord
    and subscribe to the relevant mailing lists. Feel free to ask for and give feedback
    and contribute to help with the growth of the project.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，别忘了加入 IRC、Matrix 或 Discord 社区，并订阅相关的邮件列表。随时提出反馈和建议，并贡献力量帮助项目的成长。
- en: Thank you for your interest and dedication.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您的关注与投入。
- en: Further reading
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多本章所涉及的主题，可以查看以下资源：
- en: 'The Catatonit repository on GitHub: [https://github.com/openSUSE/catatonit](https://github.com/openSUSE/catatonit)'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Catatonit 仓库在 GitHub 上: [https://github.com/openSUSE/catatonit](https://github.com/openSUSE/catatonit)'
- en: 'Kubernetes persistent volumes definition: [https://kubernetes.io/docs/concepts/storage/persistent-volumes/](https://kubernetes.io/docs/concepts/storage/persistent-volumes/)'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Kubernetes 持久化存储卷定义: [https://kubernetes.io/docs/concepts/storage/persistent-volumes/](https://kubernetes.io/docs/concepts/storage/persistent-volumes/)'
- en: 'The minikube project''s home page: [https://minikube.sigs.k8s.io/](https://minikube.sigs.k8s.io/)'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'minikube 项目的主页: [https://minikube.sigs.k8s.io/](https://minikube.sigs.k8s.io/)'
- en: 'The KinD project''s home page: [https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/)'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'KinD 项目的主页: [https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/)'
- en: 'Podman community links: [https://podman.io/community/](https://podman.io/community/)'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Podman 社区链接: [https://podman.io/community/](https://podman.io/community/)'
