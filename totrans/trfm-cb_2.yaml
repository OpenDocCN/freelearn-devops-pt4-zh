- en: Writing Terraform Configuration
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 Terraform 配置
- en: When you start writing Terraform configuration, you will notice very quickly
    that the language provided by Terraform is very rich and allows for a lot of manipulation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始编写 Terraform 配置时，你会很快注意到 Terraform 提供的语言非常丰富，可以进行大量操作。
- en: In the recipes in this chapter, you will learn how to use the Terraform language
    effectively in order to apply it to real-life business scenarios. We will discuss
    how to specify the versions of the provider to be used, as well as how to make
    the code more dynamic with variables and outputs. Then, we will use these concepts
    to provision several environments with Terraform. After that, we will consider
    the use of functions and conditions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的配方中，你将学习如何有效地使用 Terraform 语言，并将其应用于现实生活中的商业场景。我们将讨论如何指定要使用的提供者版本，以及如何通过变量和输出使代码更加动态。然后，我们将使用这些概念用
    Terraform 配置多个环境。之后，我们将考虑如何使用函数和条件。
- en: We will also learn how to retrieve data from external systems with data blocks,
    other Terraform state files, and external resources. Finally, we will cover the
    use of Terraform for local operations, such as running a local executable and
    manipulating local files.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将学习如何使用数据块、其他 Terraform 状态文件和外部资源从外部系统中检索数据。最后，我们将介绍如何使用 Terraform 进行本地操作，例如运行本地可执行文件和操作本地文件。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Configuring Terraform and the provider version to use
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Terraform 和要使用的提供者版本
- en: Manipulating variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作变量
- en: Using local variables for custom functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为自定义函数使用本地变量
- en: Using outputs to expose Terraform provisioned data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用输出暴露 Terraform 配置的数据
- en: Provisioning infrastructure in multiple environments
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个环境中配置基础设施
- en: Obtaining external data with data sources
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据源获取外部数据
- en: Using external resources from other state files
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用其他状态文件中的外部资源
- en: Querying external data with Terraform
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Terraform 查询外部数据
- en: Calling Terraform built-in functions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 Terraform 内置函数
- en: Writing conditional expressions
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写条件表达式
- en: Manipulating local files with Terraform
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Terraform 操作本地文件
- en: Executing local programs with Terraform
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Terraform 执行本地程序
- en: Generating passwords with Terraform
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Terraform 生成密码
- en: Let's get started!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need to have the Terraform binary installed on your
    computer. The source code for this chapter is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要你在计算机上安装 Terraform 二进制文件。本章的源代码可以在[https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02)找到。
- en: Check out the following video to see the code in action: [https://bit.ly/3hcZNVR](https://bit.ly/3hcZNVR)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，查看代码的实际运行：[https://bit.ly/3hcZNVR](https://bit.ly/3hcZNVR)
- en: Configuring Terraform and the provider version to use
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Terraform 和要使用的提供者版本
- en: The default behavior of Terraform is that, when executing the `terraform init`
    command, the version of the Terraform binary (which we will call the **Command-Line
    Interface** (**CLI**), as explained here: [https://www.terraform.io/docs/glossary.html#cli](https://www.terraform.io/docs/glossary.html#cli)) used
    is the one installed on the local workstation. In addition, this command downloads
    the latest version of the providers used in the code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 的默认行为是，当执行`terraform init`命令时，使用的 Terraform 二进制版本（我们称之为**命令行界面**（**CLI**），如这里解释的：[https://www.terraform.io/docs/glossary.html#cli](https://www.terraform.io/docs/glossary.html#cli)）是安装在本地工作站上的版本。此外，该命令还会下载代码中使用的最新版本的提供者。
- en: 'However, for compatibility reasons, it is always advisable to avoid surprises so
    that you can specify which version of the Terraform binary is going to be used
    in the Terraform configuration. The following are some examples:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，出于兼容性考虑，始终建议避免意外情况，因此你可以在 Terraform 配置文件中指定将要使用的 Terraform 二进制版本。以下是一些示例：
- en: A Terraform configuration written with HCL 2 must indicate that it has to be
    executed with a Terraform version greater than or equal to 0.12.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HCL 2 编写的 Terraform 配置文件必须表明它必须使用 Terraform 版本大于或等于 0.12 进行执行。
- en: A Terraform configuration that contains new features such as `count` and `for_each`
    in modules must indicate that it has to be executed with a Terraform version greater
    than or equal to 0.13.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含新功能（如模块中的`count`和`for_each`）的 Terraform 配置必须表明它必须使用 Terraform 版本大于或等于 0.13
    进行执行。
- en: For more details about the HCL syntax, read the documentation at [https://www.terraform.io/docs/configuration/syntax.html](https://www.terraform.io/docs/configuration/syntax.html).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 HCL 语法的更多详细信息，请阅读文档：[https://www.terraform.io/docs/configuration/syntax.html](https://www.terraform.io/docs/configuration/syntax.html)。
- en: In the same vein and for the same reasons of compatibility, we may want to specify
    the provider version to be used.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 同理，为了兼容性，我们可能希望指定要使用的提供程序版本。
- en: In this recipe, we will learn how to specify the Terraform version, as well
    as the provider version.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何指定 Terraform 版本以及提供程序版本。
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To start this recipe, we will write a basic Terraform configuration file that
    contains the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个教程，我们将编写一个包含以下代码的基础 Terraform 配置文件：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This example code provides resources in Azure (a Resource Group and a public
    IP address). For more details, read the following documentation about the Terraform
    AzureRM provider: [https://www.terraform.io/docs/providers/azurerm/index.html](https://www.terraform.io/docs/providers/azurerm/index.html)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码提供了 Azure 中的资源（一个资源组和一个公共 IP 地址）。有关更多详细信息，请阅读以下关于 Terraform AzureRM 提供程序的文档：[https://www.terraform.io/docs/providers/azurerm/index.html](https://www.terraform.io/docs/providers/azurerm/index.html)
- en: In addition, this code contains the improvements that were made to the HCL 2.0
    language since Terraform 0.12\. For more details about these HCL enhancements,
    go to [https://www.slideshare.net/mitchp/terraform-012-deep-dive-hcl-20-for-infrastructure-as-code-remote-plan-apply-125837028](https://www.slideshare.net/mitchp/terraform-012-deep-dive-hcl-20-for-infrastructure-as-code-remote-plan-apply-125837028).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这段代码包含了自 Terraform 0.12 以来对 HCL 2.0 语言所做的改进。有关这些 HCL 增强的更多详细信息，请访问 [https://www.slideshare.net/mitchp/terraform-012-deep-dive-hcl-20-for-infrastructure-as-code-remote-plan-apply-125837028](https://www.slideshare.net/mitchp/terraform-012-deep-dive-hcl-20-for-infrastructure-as-code-remote-plan-apply-125837028)。
- en: 'Finally, when executing the `terraform plan` command inside this code, we get
    the following warning message:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当在此代码中执行`terraform plan`命令时，我们会收到以下警告信息：
- en: '![](img/754aad40-3123-4b99-ba8d-190489a662e3.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/754aad40-3123-4b99-ba8d-190489a662e3.png)'
- en: This means that, currently, this Terraform configuration is still compatible
    with the latest version of the provider but that in a future version of the provider,
    this property will be changed and therefore this code will no longer work.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，目前这个 Terraform 配置仍然与提供程序的最新版本兼容，但在未来的版本中，该属性将发生更改，因此这段代码将不再有效。
- en: 'Now, let''s discuss the steps we need to follow to make the following compliances:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论一下我们需要遵循的步骤，以便做出以下合规性：
- en: This configuration can only be executed if Terraform 0.13 (at least) is installed
    on the local computer.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在本地计算机上安装了至少 Terraform 0.13 版本时，才能执行此配置。
- en: Our current configuration can be executed even if the `azurerm` provider evolves
    with breaking changes.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使`azurerm`提供程序发生破坏性更改，我们当前的配置也可以执行。
- en: Regarding the new features provided by Terraform 0.13, read the change log here – [https://github.com/hashicorp/terraform/blob/master/CHANGELOG.md](https://github.com/hashicorp/terraform/blob/master/CHANGELOG.md),
    and the upgrade guide here – [https://github.com/hashicorp/terraform/blob/master/website/upgrade-guides/0-13.html.markdown](https://github.com/hashicorp/terraform/blob/master/website/upgrade-guides/0-13.html.markdown).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Terraform 0.13 提供的新功能，请在此查看变更日志 – [https://github.com/hashicorp/terraform/blob/master/CHANGELOG.md](https://github.com/hashicorp/terraform/blob/master/CHANGELOG.md)，并在此查看升级指南
    – [https://github.com/hashicorp/terraform/blob/master/website/upgrade-guides/0-13.html.markdown](https://github.com/hashicorp/terraform/blob/master/website/upgrade-guides/0-13.html.markdown)。
- en: We'll take a look at this next.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将查看这个内容。
- en: How to do it…
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'To specify the Terraform version to be installed on the local workstation,
    do the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定在本地工作站上安装的 Terraform 版本，请执行以下操作：
- en: 'In the Terraform configuration, add the following block:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Terraform 配置中，添加以下块：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To specify the provider source and version to use, we need to add the `required_provider`
    block inside the same `terraform` configuration block:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要指定要使用的提供程序源和版本，我们需要在同一个`terraform`配置块中添加`required_provider`块：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works…
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: When executing the `terraform init` command, Terraform will check that the version
    of the installed Terraform binary that executes the Terraform configuration file
    corresponds to the version specified in the `required_version` property of the
    `terraform` block.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`terraform init`命令时，Terraform 会检查执行 Terraform 配置文件的已安装 Terraform 二进制文件版本是否与`terraform`块中`required_version`属性指定的版本相对应。
- en: 'If it matches, it won''t throw an error as it is greater than version 0.13\.
    Otherwise, it will throw an error:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果匹配，它不会抛出错误，因为它大于版本 0.13\。否则，它将抛出错误：
- en: '![](img/4dd89fda-144c-4ded-95b4-051e0029f4a4.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4dd89fda-144c-4ded-95b4-051e0029f4a4.png)'
- en: With regard to the specification of the provider version, when executing the
    `terraform init` command, if no version is specified, Terraform downloads the
    latest version of the provider, otherwise it downloads the specified version,
    as shown in the following two screenshots.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 关于提供程序版本的指定，执行 `terraform init` 命令时，如果没有指定版本，Terraform 将下载提供程序的最新版本，否则将下载指定版本，如下图所示。
- en: 'The following screenshot shows the provider plugin being downloaded from the
    specified `source` without us specifying the required version (at the time of
    writing, the latest version of the provider is 2.20.0):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了提供程序插件从指定的 `source` 被下载，而我们并未指定所需的版本（截至撰写时，提供程序的最新版本为 2.20.0）：
- en: '![](img/280032a1-412f-4a80-86f0-55e0681092c5.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/280032a1-412f-4a80-86f0-55e0681092c5.png)'
- en: As we can see, the latest version of the `azurerm` provider (2.20.0) has been
    downloaded.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，已下载最新版本的 `azurerm` 提供程序（2.20.0）。
- en: 'In addition, the following screenshot shows the `azurerm` provider plugin being
    downloaded when we specify the required version (2.10.0):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下截图显示了在我们指定所需版本（2.10.0）时，`azurerm` 提供程序插件正在被下载：
- en: '![](img/aec54df2-67e1-4d5d-abc4-c5c4a3cce7e7.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aec54df2-67e1-4d5d-abc4-c5c4a3cce7e7.png)'
- en: As we can see, the specified version of the `azurerm` provider (2.10.0) has
    been downloaded.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，已下载指定版本的 `azurerm` 提供程序（2.10.0）。
- en: For more details about the `required_version` block and provider versions, go
    to [https://www.terraform.io/docs/configuration/terraform.html#specifying-required-provider-versions](https://www.terraform.io/docs/configuration/terraform.html#specifying-required-provider-versions).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `required_version` 块和提供程序版本的更多细节，请访问 [https://www.terraform.io/docs/configuration/terraform.html#specifying-required-provider-versions](https://www.terraform.io/docs/configuration/terraform.html#specifying-required-provider-versions)。
- en: In this `required_version` block, we also add the `source` property, which was
    introduced in version 0.13 of Terraform and is documented here: [https://github.com/hashicorp/terraform/blob/master/website/upgrade-guides/0-13.html.markdown#explicit-provider-source-locations](https://github.com/hashicorp/terraform/blob/master/website/upgrade-guides/0-13.html.markdown#explicit-provider-source-locations)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `required_version` 块中，我们还添加了 `source` 属性，它是在 Terraform 0.13 版本中引入的，相关文档可以在这里找到：[https://github.com/hashicorp/terraform/blob/master/website/upgrade-guides/0-13.html.markdown#explicit-provider-source-locations](https://github.com/hashicorp/terraform/blob/master/website/upgrade-guides/0-13.html.markdown#explicit-provider-source-locations)
- en: There's more…
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In this recipe, we learned how to download the `azurerm` provider in various
    ways. What we did here applies to all providers you may wish to download.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们学习了如何以多种方式下载 `azurerm` 提供程序。我们在这里做的适用于你可能想要下载的所有提供程序。
- en: It is also important to mention that the version of the Terraform binary that's
    used is specified in the Terraform state file. This is to ensure that nobody applies
    this Terraform configuration with a lower version of the Terraform binary, thus
    ensuring that the format of the Terraform state file conforms with the correct
    version of the Terraform binary.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要提到的是，使用的 Terraform 二进制版本在 Terraform 状态文件中指定。这是为了确保没有人使用较低版本的 Terraform 二进制文件应用此
    Terraform 配置，从而确保 Terraform 状态文件的格式与正确版本的 Terraform 二进制文件一致。
- en: See also
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: For more information about the properties of the Terraform block, go to [https://www.terraform.io/docs/configuration/terraform.html](https://www.terraform.io/docs/configuration/terraform.html).
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Terraform 块属性的更多信息，请访问 [https://www.terraform.io/docs/configuration/terraform.html](https://www.terraform.io/docs/configuration/terraform.html)。
- en: For more information about the properties of the providers, go to [https://www.terraform.io/docs/configuration/providers.html](https://www.terraform.io/docs/configuration/providers.html).
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于提供程序属性的更多信息，请访问 [https://www.terraform.io/docs/configuration/providers.html](https://www.terraform.io/docs/configuration/providers.html)。
- en: More information about Terraform binary versioning is documented at [https://www.terraform.io/docs/extend/best-practices/versioning.html](https://www.terraform.io/docs/extend/best-practices/versioning.html).
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Terraform 二进制版本管理的更多信息，请参考 [https://www.terraform.io/docs/extend/best-practices/versioning.html](https://www.terraform.io/docs/extend/best-practices/versioning.html)。
- en: The upgrade guide for the `azurerm` provider (to version 2.0) is available at [https://www.terraform.io/docs/providers/azurerm/guides/2.0-upgrade-guide.html](https://www.terraform.io/docs/providers/azurerm/guides/2.0-upgrade-guide.html).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`azurerm`提供程序的升级指南（至版本 2.0）可以通过以下链接访问：[https://www.terraform.io/docs/providers/azurerm/guides/2.0-upgrade-guide.html](https://www.terraform.io/docs/providers/azurerm/guides/2.0-upgrade-guide.html)。'
- en: Manipulating variables
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作变量
- en: When you write a Terraform configuration file where all the properties are hardcoded
    in the code, you often find yourself faced with the problem of having to duplicate
    it in order to reuse it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写一个所有属性都硬编码在代码中的 Terraform 配置文件时，你常常会遇到需要重复编写代码以便重用的问题。
- en: In this recipe, we'll learn how to make the Terraform configuration more dynamic
    by using variables.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何通过使用变量使 Terraform 配置更加动态。
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To begin, we are going to work on the `main.tf` file, which contains a basic
    Terraform configuration:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将处理`main.tf`文件，该文件包含一个基本的 Terraform 配置：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see, the `name` and `location` properties have values written in the
    code in a static way.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`name`和`location`属性的值在代码中是以静态方式写入的。
- en: Let's learn how to make them dynamic using variables.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何使用变量使它们动态化。
- en: How to do it…
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Perform the following steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'In the same `main.tf` file, add the following variable declarations:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个`main.tf`文件中，添加以下变量声明：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, modify the Terraform configuration we had at the beginning of this recipe
    so that it refers to our new variables, as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，修改本教程开始时的 Terraform 配置，使其引用我们的新变量，如下所示：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, in the same folder that contains the `main.tf` file, create a new
    file called `terraform.tfvars` and add the following content:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在包含`main.tf`文件的相同文件夹中，创建一个名为`terraform.tfvars`的新文件，并添加以下内容：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works…
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理……
- en: 'In *step 1*, we wrote the declaration of the two variables, which consists
    of the following elements:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第 1 步*中，我们编写了两个变量的声明，其中包含以下元素：
- en: 'A variable name: This must be unique to this Terraform configuration and must
    be explicit enough to be understood by all the contributors of the code.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名称：此名称必须在该 Terraform 配置中唯一，并且必须足够明确，以便所有代码贡献者都能理解。
- en: 'A description of what this variable represents: This description is optional,
    but is recommended because it can be displayed by the CLI and can also be integrated
    into the documentation, which is automatically generated.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该变量表示的内容描述：此描述是可选的，但建议提供，因为它可以通过 CLI 显示，并且可以集成到自动生成的文档中。
- en: 'A default value: This is optional. Not setting a default value makes it mandatory
    to enter a default value.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认值：这是可选的。不设置默认值会使其变为必填项。
- en: Then, in *step 2*, we modified the Terraform configuration to use these two
    variables. We did this using the `var.<name of the variable>`syntax.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在*第 2 步*中，我们修改了 Terraform 配置，使用这两个变量。我们通过`var.<变量名>`语法完成了这一操作。
- en: Finally, in *step 3*, we gave values to these variables in the `terraform.tfvars`
    file, which is used natively by Terraform.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*第 3 步*中，我们在`terraform.tfvars`文件中为这些变量赋值，该文件由 Terraform 原生使用。
- en: 'The result of executing this Terraform configuration is shown in the following
    screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此 Terraform 配置后的结果显示在以下截图中：
- en: '![](img/96421f7a-ab2b-42e4-b74f-abf39af53249.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96421f7a-ab2b-42e4-b74f-abf39af53249.png)'
- en: There's more…
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: Setting a value in the variable is optional in the `terraform.tfvars` file since
    we have set a default value for the variable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在`terraform.tfvars`文件中设置变量的值是可选的，因为我们已经为该变量设置了默认值。
- en: 'Apart from this `terraform.tfvars` file, it is possible to give a variable
    a value using the `-var` option of the `terraform plan` and `terraform apply`
    commands, as shown in the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个`terraform.tfvars`文件，还可以通过`terraform plan`和`terraform apply`命令的`-var`选项为变量设置值，如下命令所示：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So, with this command, the `location` variable declared in our code will have
    a value of `westus` instead of `westeurope`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用此命令时，我们代码中声明的`location`变量将具有`westus`的值，而不是`westeurope`。
- en: In addition, with the 0.13 version of Terraform released in August 2020, we
    can now create custom validation rules for variables which makes it possible for
    us to verify a value during the `terraform plan` execution.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，随着 Terraform 2020 年 8 月发布的 0.13 版本，我们现在可以为变量创建自定义验证规则，这使我们能够在执行`terraform
    plan`时验证值。
- en: 'In our recipe, we can complete the `location` variable with a validation rule
    in the `validation` block as shown in the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们可以在 `validation` 块中使用如下代码完成 `location` 变量的验证规则：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding configuration, the rule checks that if the value of the `location`
    variable is `westeurope` or `westus`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述配置中，规则检查了 `location` 变量的值是否为 `westeurope` 或 `westus`。
- en: 'The following screenshot shows the `terraform plan` command in execution if
    we put another value in the `location` variable, such as `westus2`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `location` 变量设置为 `westus2` 等其他值，则下面的截图显示了 `terraform plan` 命令的执行：
- en: '![](img/3f568703-848d-47d5-96af-41d501ff5cef.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f568703-848d-47d5-96af-41d501ff5cef.png)'
- en: For more information about variable custom rules validation read the documentation
    at [https://www.terraform.io/docs/configuration/variables.html#custom-validation-rules](https://www.terraform.io/docs/configuration/variables.html#custom-validation-rules).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有关变量自定义规则验证的更多信息，请阅读文档：[https://www.terraform.io/docs/configuration/variables.html#custom-validation-rules](https://www.terraform.io/docs/configuration/variables.html#custom-validation-rules)。
- en: Finally, there is another alternative to setting a value to a variable, which
    consists of setting an environment variable called `TF_VAR_<variable name>`. As
    in our case, we can create an environment variable called `TF_VAR_location` with
    a value of `westus` and then execute the `terraform plan` command in a classical
    way.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有另一种为变量设置值的方法，即设置名为 `TF_VAR_<变量名>` 的环境变量。在我们的案例中，我们可以创建一个名为 `TF_VAR_location`
    的环境变量，并设置其值为 `westus`，然后以经典方式执行 `terraform plan` 命令。
- en: Note that using the `-var` option or the `TF_VAR_<name of the variable>` environment
    variable doesn't hardcode these variable's values inside the Terraform configuration.
    They make it possible for us to give values of variables to the flight. But be
    careful – these options can have consequences if the same code is executed with
    other values initially provided in parameters and the plan's output isn't reviewed
    carefully.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用 `-var` 选项或 `TF_VAR_<变量名>` 环境变量并不会将这些变量的值硬编码到 Terraform 配置中。它们使我们能够将变量的值传递给工具。但是要注意，如果在参数中提供的初始值与执行代码时提供的其他值不符，则可能会产生后果，应仔细检查计划的输出。
- en: See also
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In this recipe, we looked at the basic use of variables. We will look at more
    advanced uses of these when we learn how to manage environments in the *Managing
    infrastructure in multiple environments* recipe, later in this chapter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们查看了变量的基本使用。当我们学习如何管理环境时，在本章后面的*在多个环境中管理基础设施*一节中，我们将探讨其更高级的用法。
- en: For more information on variables, refer to the documentation here: [https://www.terraform.io/docs/configuration/variables.html](https://www.terraform.io/docs/configuration/variables.html)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有关变量的更多信息，请参阅此处的文档：[https://www.terraform.io/docs/configuration/variables.html](https://www.terraform.io/docs/configuration/variables.html)
- en: Using local variables for custom functions
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用本地变量进行自定义函数
- en: In the previous recipe, we learned how to use variables to dynamize our Terraform
    configuration. Sometimes, this use can be a bit more tedious when it comes to
    using combinations of variables.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，我们学习了如何使用变量来动态配置我们的 Terraform。有时，当涉及到变量的组合使用时，这种使用可能会有点繁琐。
- en: In this recipe, we will learn how to implement local variables and use them
    as custom functions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何实现本地变量并将它们用作自定义函数。
- en: Getting ready
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To start with, we will use the following Terraform configuration:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用以下 Terraform 配置：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The goal of this recipe is to consistently render the names of the Azure resources.
    We must provide them with the following nomenclature rule:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的目标是始终渲染 Azure 资源的名称。我们必须为它们提供以下命名规则：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How to do it…
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Perform the following steps:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'In the `main.tf` file, which contains our Terraform configuration, we will
    add a local variable called `resource_name`, along with the following code:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包含我们的 Terraform 配置的 `main.tf` 文件中，我们将添加一个名为 `resource_name` 的本地变量，以及以下代码：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We then use this local variable in the resources with the following code:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在资源中使用这个本地变量，代码如下：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works…
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何运作…
- en: In *step 1*, we created a variable called `resource_name` that is local to our
    Terraform configuration. This allows us to create a combination of several Terraform
    variables (which we will see the result of in the *Using outputs to expose Terraform
    provisioned data* recipe of this chapter).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第 1 步*中，我们创建了一个名为 `resource_name` 的变量，它是局部于我们 Terraform 配置的。这使我们能够创建多个 Terraform
    变量的组合（我们将在本章的*使用输出暴露 Terraform 配置数据*这一部分看到结果）。
- en: Then, in *step 2*, we used this local variable with the `local.<name of the
    local variable>` expression. Moreover, in the `name` property, we used it as a
    concatenation of a variable and static text, which is why we used the `"${}"`
    syntax.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在*第 2 步*中，我们使用了带有 `local.<局部变量名称>` 表达式的局部变量。此外，在 `name` 属性中，我们将其用作变量和静态文本的拼接，这就是为什么我们使用了
    `"${}"` 语法。
- en: 'The result of executing this Terraform configuration is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此 Terraform 配置的结果如下：
- en: '![](img/75e03e97-6029-48a3-9892-88380f2295a7.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75e03e97-6029-48a3-9892-88380f2295a7.png)'
- en: In the previous screenshot, we can see the output of executing the `terraform
    plan` command with the `name` of the Resource Group that we calculated with the `locals`
    variable.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的截图中，我们可以看到执行 `terraform plan` 命令后的输出，其中包含我们通过 `locals` 变量计算得出的资源组的 `name`。
- en: See also
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: For more information on local variables, take a look at the following documentation: [https://www.terraform.io/docs/configuration/locals.html](https://www.terraform.io/docs/configuration/locals.html)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有关局部变量的更多信息，请查看以下文档：[https://www.terraform.io/docs/configuration/locals.html](https://www.terraform.io/docs/configuration/locals.html)
- en: Using outputs to expose Terraform provisioned data
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用输出暴露 Terraform 配置数据
- en: When using Infrastructure as Code tools such as Terraform, it is often necessary
    to retrieve output values from the provisioned resources after code execution.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用诸如 Terraform 之类的基础设施即代码工具时，通常需要在代码执行后从已配置的资源中检索输出值。
- en: One of the uses of these output values is that they can be used after execution
    by other programs. This is often the case when the execution of the Terraform
    configuration is integrated into a CI/CD pipeline.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些输出值的一个用途是，它们可以在执行后由其他程序使用。这通常发生在 Terraform 配置的执行集成到 CI/CD 流水线时。
- en: For example, we can use these output values in a CI/CD pipeline that creates
    an Azure App Service with Terraform and also deploys the application to this Azure
    App Service. In this example, we can have the name of the App Service (web app
    type) as the output of the Terraform configuration. These output values are also
    very useful for transmitting information through modules, which we will see in
    detail in [Chapter 5](ddb13a41-5cdd-4931-b38f-d185d3a10c1e.xhtml), *Sharing Terraform
    Configuration with Modules*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在 CI/CD 流水线中使用这些输出值，该流水线使用 Terraform 创建 Azure App Service，并将应用程序部署到该
    Azure App Service 中。在这个例子中，我们可以将 App Service（Web 应用类型）的名称作为 Terraform 配置的输出。对于通过模块传递信息，这些输出值也非常有用，我们将在[第
    5 章](ddb13a41-5cdd-4931-b38f-d185d3a10c1e.xhtml)《*使用模块共享 Terraform 配置*》中详细了解。
- en: In this recipe, we will learn how to implement output values in Terraform's configuration.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何在 Terraform 配置中实现输出值。
- en: Getting ready
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To proceed, we are going to add some Terraform configuration that we already
    have in the existing `main.tf` file.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一些我们已经在现有的 `main.tf` 文件中的 Terraform 配置。
- en: 'The following is an extract of this existing code, which provides an App Service
    in Azure:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是现有代码的摘录，该代码在 Azure 中提供一个 App Service：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How to do it…
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To ensure we have an output value, we will just add the following code to this
    `main.tf` file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保我们有一个输出值，我们只需将以下代码添加到此 `main.tf` 文件中：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `output` block of Terraform is defined by a name, `webapp_name`, and a value,
    `azurerm_app_service.app.name`. These refer to the name of the Azure App Service
    that is provided in the same Terraform configuration. Optionally, we can add a `description`
    that describes what the output returns, which can also be very useful for autogenerated
    documentation or in the use of modules.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 的 `output` 块通过一个名称 `webapp_name` 和一个值 `azurerm_app_service.app.name`
    来定义。这些引用了在同一个 Terraform 配置中提供的 Azure App Service 的名称。可选地，我们可以添加一个 `description`
    来描述输出返回的内容，这对于自动生成文档或在使用模块时非常有用。
- en: It is, of course, possible to define more than one output in the same Terraform
    configuration.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可以在同一个 Terraform 配置中定义多个输出。
- en: 'The outputs are stored in the Terraform state file and are displayed when the
    `terraform apply` command is executed, as shown in the following screenshot:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 输出存储在 Terraform 状态文件中，并在执行 `terraform apply` 命令时显示，如下图所示：
- en: '![](img/fa2ba3e2-fbcc-44c4-830f-5ad926575e67.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa2ba3e2-fbcc-44c4-830f-5ad926575e67.png)'
- en: Here, we see two output values that are displayed at the end of the execution.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到执行结束时显示的两个输出值。
- en: There's more…
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'There are two ways to retrieve the values of the output in order to exploit
    them, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以检索输出的值以便利用它们，如下所示：
- en: By using the `terraform output` command in the Terraform CLI, which we will
    see in the *Exporting the output in JSON* recipe in [Chapter 4](fc591e87-b893-40fa-9021-7827bffcc094.xhtml),
    *Using the Terraform CLI*
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 Terraform CLI 中的 `terraform output` 命令，我们将在[第4章](fc591e87-b893-40fa-9021-7827bffcc094.xhtml)的
    *以 JSON 导出输出* 章节中看到，*使用 Terraform CLI*
- en: By using the `terraform_remote_state` data source object, which we will discuss
    in the *Using external resources from other state files* recipe, later in this
    chapter
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 `terraform_remote_state` 数据源对象，我们将在本章稍后的 *使用其他状态文件中的外部资源* 章节中讨论。
- en: See also
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: Documentation on Terraform outputs is available at [https://www.terraform.io/docs/configuration/outputs.html](https://www.terraform.io/docs/configuration/outputs.html).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 输出的文档可在 [https://www.terraform.io/docs/configuration/outputs.html](https://www.terraform.io/docs/configuration/outputs.html)
    上查看。
- en: Provisioning infrastructure in multiple environments
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多个环境中配置基础设施
- en: In the same way that we deploy an application to several environments (dev,
    test, QA, and production), we also need to provision infrastructure on these different
    environments.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们将应用程序部署到多个环境（开发、测试、QA 和生产环境）一样，我们也需要在这些不同的环境中配置基础设施。
- en: The question that often arises is how to write a maintainable and scalable Terraform
    configuration that would allow us to provision infrastructure for multiple environments.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的问题是如何编写一个可维护、可扩展的 Terraform 配置，使我们能够为多个环境配置基础设施。
- en: To answer this question, it is important to know that there are several solutions
    for organizing Terraform configuration topologies that will allow for this provisioning.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答这个问题，重要的是要知道，有多种方法可以组织 Terraform 配置拓扑，这些方法能够支持此类资源的配置。
- en: In this recipe, we will look at two Terraform configuration structure topologies
    that will allow us to deploy an Azure infrastructure to multiple environments.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将查看两种 Terraform 配置结构拓扑，它们可以帮助我们将 Azure 基础设施部署到多个环境中。
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To fully understand this recipe, you will need to have a good understanding
    of the notion of variables, as discussed in the *Manipulating variables* recipe
    of this chapter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全理解这个教程，你需要对变量的概念有深入的了解，正如本章中*操作变量*的教程所讨论的那样。
- en: 'The goal of the Terraform configuration that we are going to write is to deploy
    an Azure App Service for a single environment. Its code is distributed in the
    following files:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的 Terraform 配置的目标是为单一环境部署 Azure 应用服务。其代码分布在以下文件中：
- en: '![](img/a9d8f674-bdcf-4d37-860c-bf99d2c7d570.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9d8f674-bdcf-4d37-860c-bf99d2c7d570.png)'
- en: 'In the preceding diagram, we can see the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到以下内容：
- en: The `main.tf` file contains the Terraform configuration of the resources to
    be provisioned.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.tf` 文件包含要配置的资源的 Terraform 配置。'
- en: The `variables.tf` file contains the declaration of the variables.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`variables.tf` 文件包含变量的声明。'
- en: The `terraform.tfvars` file contains the values of the variables.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`terraform.tfvars` 文件包含变量的值。'
- en: The Terraform source code for this basic example is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/myApp/simple-env](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/myApp/simple-env).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基础示例的 Terraform 源代码可以在 [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/myApp/simple-env](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/myApp/simple-env)
    上查看。
- en: What is important in this recipe is not the content of the code, but the folder
    structure and the Terraform commands to be executed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程中重要的不是代码的内容，而是文件夹结构和需要执行的 Terraform 命令。
- en: How to do it…
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Follow these steps to implement the first Terraform configuration folder topology:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤来实现第一个 Terraform 配置文件夹拓扑：
- en: 'In an empty folder, create a separate directory per environment: one for dev,
    one for test, one for QA, and one for production.'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个空文件夹中，为每个环境创建一个独立的目录：一个用于开发环境，一个用于测试环境，一个用于 QA，另一个用于生产环境。
- en: Copy the Terraform base configuration into each of these directories identically.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Terraform 基础配置文件相同地复制到这些目录中。
- en: 'Then, in each of these directories, modify the values of the `terraform.tfvars`
    file with the information that is specific to the environment. Here is an extract
    of each of these `terraform.tfvars` files:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在这些目录中的每个目录中，修改 `terraform.tfvars` 文件的值，填写特定于环境的信息。以下是每个 `terraform.tfvars`
    文件的摘录：
- en: '[PRE15]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, to provision each of these environments, inside each of these directories,
    execute the classical Terraform execution workflow by running the `terraform init`,
    `terraform plan`, and `terraform apply` commands.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了配置每个环境，在这些目录中的每个目录下，执行经典的 Terraform 执行工作流，通过运行 `terraform init`、`terraform
    plan` 和 `terraform apply` 命令。
- en: 'Follow these steps to implement the second topology of the Terraform configuration folder:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实施 Terraform 配置文件的第二种拓扑结构：
- en: 'In the folder that contains our basic Terraform configuration, create three
    subdirectories: `dev`, `test`, and `production`.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包含我们基本 Terraform 配置的文件夹中，创建三个子目录：`dev`、`test` 和 `production`。
- en: 'Then, in each of these subdirectories, copy only the `terraform.tfvars` base file, in
    which we modify the variables with the correct values of the target environments.
    The following is an extract from each `terraform.tfvars` file:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在这些子目录中，只需复制 `terraform.tfvars` 基础文件，在其中修改目标环境的正确变量值。以下是每个 `terraform.tfvars`
    文件的摘录：
- en: '[PRE16]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, to provision each of these environments, go to the root folder of
    the Terraform configuration and execute the following commands:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了配置这些环境，进入 Terraform 配置的根文件夹并执行以下命令：
- en: '[PRE17]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In the first topology, we duplicate the same Terraform configuration for each
    environment and just change the values of the variables in the `terraform.tfvars`
    file of each folder.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种拓扑中，我们为每个环境重复相同的 Terraform 配置，只需更改每个文件夹中 `terraform.tfvars` 文件的变量值。
- en: 'By doing this, we get the following folder structure:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们得到了以下文件夹结构：
- en: '![](img/7837e09f-2dbc-498a-bf8f-8b914453e13f.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7837e09f-2dbc-498a-bf8f-8b914453e13f.png)'
- en: Terraform is then executed with the basic Terraform commands. This structure
    can be used if the infrastructure does not contain the same resources for each
    environment. This is because duplicating all the Terraform configuration in each
    environment folder offers us the advantage of being able to easily add or remove
    resources for one environment without affecting the other environments.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行基本的 Terraform 命令。此结构可用于基础设施在各个环境中没有相同资源的情况。因为将所有 Terraform 配置复制到每个环境文件夹中，可以轻松地为一个环境添加或删除资源，而不会影响其他环境。
- en: However, this is duplicate code, which implies that this code must be maintained
    several times (we must modify the infrastructure for all environments, make changes
    to the Terraform configuration, and so on).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是重复的代码，这意味着这些代码必须多次维护（我们必须修改所有环境的基础设施，改变 Terraform 配置等）。
- en: 'In the second topology, we kept the Terraform configuration in the common base
    for all environments and have just one `terraform.tfvars` file per environment. By
    doing this, we get the following folder structure:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种拓扑中，我们将 Terraform 配置保留在所有环境的公共基础中，每个环境只有一个 `terraform.tfvars` 文件。通过这种方式，我们得到了以下文件夹结构：
- en: '![](img/6a6f86a3-75ba-4b95-b9e8-6c4ec3f060eb.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a6f86a3-75ba-4b95-b9e8-6c4ec3f060eb.png)'
- en: As for the execution of the Terraform configuration, we have added the `-var-file`
    option to the `plan` and `apply` commands. This structure can be used if the infrastructure
    is the same for all environments but only the configuration changes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Terraform 配置的执行，我们在 `plan` 和 `apply` 命令中添加了 `-var-file` 选项。如果所有环境的基础设施相同，仅配置不同，可以使用此结构。
- en: The advantage of this topology is that we have only one common piece of Terraform
    resource code (in the `main.tf` and `variables.tf` files), and just one `terraform.tfvars`
    file to fill in, so we will have to make a few changes in case of code evolution
    or a new environment.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这种拓扑的优点是，我们只有一份公共的 Terraform 资源代码（在 `main.tf` 和 `variables.tf` 文件中），并且只有一个 `terraform.tfvars`
    文件需要填写，因此在代码演变或新增环境时，我们只需做少量更改。
- en: On the other hand, the changes that were made to the Terraform `main.tf` code
    will apply to all the environments, which in this case requires more testing and
    verification.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对 Terraform `main.tf` 代码所做的更改将应用于所有环境，在这种情况下，需要更多的测试和验证。
- en: See also
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: There are other solutions to Terraform configuration folder structure topologies,
    as we will discuss in [Chapter 5](ddb13a41-5cdd-4931-b38f-d185d3a10c1e.xhtml),
    *Sharing Terraform Configuration with Modules*.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有其他解决方案来处理 Terraform 配置文件夹结构拓扑，正如我们在[第 5 章](ddb13a41-5cdd-4931-b38f-d185d3a10c1e.xhtml)中讨论的，*使用模块共享
    Terraform 配置*。
- en: Documentation regarding the `-var-file` option of the `plan` and `apply` commands
    is available at [https://www.terraform.io/docs/commands/plan.html](https://www.terraform.io/docs/commands/plan.html).
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`plan`和`apply`命令的`-var-file`选项的文档可以在[https://www.terraform.io/docs/commands/plan.html](https://www.terraform.io/docs/commands/plan.html)找到。
- en: An article explaining the best practices surrounding Terraform configuration can
    be found at [https://www.terraform-best-practices.com/code-structure](https://www.terraform-best-practices.com/code-structure).
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一篇解释 Terraform 配置最佳实践的文章可以在[https://www.terraform-best-practices.com/code-structure](https://www.terraform-best-practices.com/code-structure)找到。
- en: 'The following blog post explains the folder structure for production Terraform
    configuration: [https://www.hashicorp.com/blog/structuring-hashicorp-terraform-configuration-for-production](https://www.hashicorp.com/blog/structuring-hashicorp-terraform-configuration-for-production)'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下博客文章解释了生产环境中 Terraform 配置的文件夹结构：[https://www.hashicorp.com/blog/structuring-hashicorp-terraform-configuration-for-production](https://www.hashicorp.com/blog/structuring-hashicorp-terraform-configuration-for-production)
- en: Obtaining external data with data sources
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据源获取外部数据
- en: When infrastructure is provisioned with Terraform, it is sometimes necessary
    to retrieve information about the already existing resources. Indeed, when deploying
    resources to a certain infrastructure, there is often a need to place ourselves
    in an existing infrastructure or link it to other resources that have already
    been provisioned.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Terraform 配置基础设施时，有时需要获取已有资源的信息。实际上，在将资源部署到某个基础设施时，我们常常需要将自己置于现有基础设施中，或者将其与已经配置的其他资源链接起来。
- en: In this recipe, we will learn how, in our Terraform configuration, to retrieve
    information about resources already present in an infrastructure.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何在我们的 Terraform 配置中获取基础设施中已经存在的资源信息。
- en: Getting ready
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will use an existing Terraform configuration that provides
    an Azure App Service in the Azure cloud. This source code is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/data](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/data).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将使用一个现有的 Terraform 配置，它在 Azure 云中提供一个 Azure 应用服务。这个源代码可以在[https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/data](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/data)找到。
- en: This code is incomplete because, for this project, we need to store the App
    Service in an existing Service Plan. This Service Plan is the one we will use
    for the entire App Service.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是不完整的，因为在这个项目中，我们需要将应用服务存储在一个现有的服务计划中。这个服务计划是我们将为整个应用服务使用的。
- en: How to do it…
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Perform the following steps:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'In our file that contains our Terraform configuration, add the following data
    block:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包含 Terraform 配置的文件中，添加以下数据块：
- en: '[PRE18]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the properties sections, specify the name and the Resource Group of the Service
    Plan to be used.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性部分中，指定要使用的服务计划的名称和资源组。
- en: 'Then, complete the existing App Service configuration, as follows:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，完成现有应用服务配置，如下所示：
- en: '[PRE19]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works…
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In *step 1*, a data block is added to query existing resources. In this data
    block, we specify the Resource Group and the name of the existing Service Plan.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 1*中，添加一个数据块来查询现有资源。在此数据块中，我们指定了现有服务计划的资源组和名称。
- en: In *step 2*, we use the ID of the Service Plan that was retrieved by the data
    block we added in *step 1*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 2*中，我们使用了通过在*步骤 1*中添加的数据块获取的服务计划 ID。
- en: 'The result of executing this Terraform configuration can be seen in the following
    screenshot:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此 Terraform 配置的结果可以在以下截图中看到：
- en: '![](img/886e9632-addb-4b12-9d32-fcdefe01e433.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/886e9632-addb-4b12-9d32-fcdefe01e433.png)'
- en: As we can see, we have the ID of the Service Plan that was retrieved by the
    `data` block.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们得到了通过`data`块获取的服务计划 ID。
- en: There's more…
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: What's interesting about the use of data blocks is that when executing the `terraform
    destroy` command on our Terraform configuration, Terraform does not perform a
    destroy action on the resource called by the data block.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据块的有趣之处在于，当我们在 Terraform 配置上执行`terraform destroy`命令时，Terraform 不会对数据块调用的资源执行销毁操作。
- en: Moreover, the use of data blocks is to be preferred to the use of IDs written
    in clear text in the code, which can change because the data block recovers the
    information dynamically.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，推荐使用数据块，而不是在代码中写明的ID，因为ID可能会变化，而数据块能够动态地恢复信息。
- en: Finally, the data block is also called when executing the `terraform plan` command,
    so your external resource must be present before you execute the `terraform plan`
    and `terraform apply` commands.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，数据块在执行`terraform plan`命令时也会被调用，因此在执行`terraform plan`和`terraform apply`命令之前，您的外部资源必须已经存在。
- en: 'If this external resource is not already present, we get the following error
    in the `terraform plan` command:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此外部资源尚未存在，我们会在`terraform plan`命令中遇到以下错误：
- en: '![](img/4d15acf6-1388-49a0-a0e9-d2de230d869f.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d15acf6-1388-49a0-a0e9-d2de230d869f.png)'
- en: You need to know which providers to use in your Terraform configuration since
    not all providers implement data blocks.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要知道在你的Terraform配置中使用哪些提供程序，因为并不是所有的提供程序都实现了数据块。
- en: See also
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: For more information about data blocks, take a look at the following documentation: [https://www.terraform.io/docs/configuration/data-sources.html](https://www.terraform.io/docs/configuration/data-sources.html)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关数据块的更多信息，请查看以下文档：[https://www.terraform.io/docs/configuration/data-sources.html](https://www.terraform.io/docs/configuration/data-sources.html)
- en: Using external resources from other state files
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从其他状态文件中使用外部资源
- en: In the previous recipe, we saw that it's possible to retrieve information about
    resources already present in the infrastructure using data blocks.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个食谱中，我们看到可以使用数据块检索基础设施中已存在资源的信息。
- en: In this recipe, we will learn that it is also possible to retrieve external
    information that is present in other Terraform state files.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习也可以从其他Terraform状态文件中检索外部信息。
- en: Getting ready
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will, similar to the previous recipe, use a Terraform configuration that
    provisions an Azure App Service that must be part of an already provisioned Service
    Plan.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本食谱，我们将像前一个食谱一样，使用一个Terraform配置来配置一个Azure App Service，该服务必须是已经配置好的Service
    Plan的一部分。
- en: Unlike the previous recipe, we will not use individual data sources; instead,
    we will read outputs from an existing Terraform state file that was used to provision
    the Service Plan.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个食谱不同，我们将不使用单独的数据源；相反，我们将从用于配置Service Plan的现有Terraform状态文件中读取输出。
- en: 'As a prerequisite, in the Terraform configuration that was used to provision
    the Service Plan, we must have an output value (see the *Using outputs to expose
    Terraform provisioned data* recipe in this chapter) that returns the identifier
    of the Service Plan, as shown in the following code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 作为前提条件，在用于配置Service Plan的Terraform配置中，我们必须有一个输出值（请参见本章中的*使用输出暴露Terraform配置的数据*一节），该输出返回Service
    Plan的标识符，如下代码所示：
- en: '[PRE20]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In addition, we used a remote backend version of Azure Storage (see the *Protecting
    state files in an Azure remote backend* recipe in [Chapter 6](d054157b-d534-47c9-8079-3af13107c4ef.xhtml),
    *Provisioning Azure Infrastructure with Terraform*, for more information) to store
    the Terraform state file of the Service Plan.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用了Azure Storage的远程后端版本（有关更多信息，请参见[第6章](d054157b-d534-47c9-8079-3af13107c4ef.xhtml)中的*保护Azure远程后端中的状态文件*一节，以及*使用Terraform配置Azure基础设施*的食谱）来存储Service
    Plan的Terraform状态文件。
- en: How to do it…
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何执行...
- en: 'Perform the following steps:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'In the Terraform configuration that provides the Azure App Service, add and
    configure the `terraform_remote_state` block, as follows:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供Azure App Service的Terraform配置中，添加并配置`terraform_remote_state`块，如下所示：
- en: '[PRE21]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, in the Terraform configuration of the Azure App Service, use the created
    output of the Service Plan, as follows:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在Azure App Service的Terraform配置中，使用Service Plan的创建输出，如下所示：
- en: '[PRE22]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works…
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 1*, we added the `terraform_remote_state` block, which allows us to
    retrieve outputs present in another Terraform state file. In its block, we specified
    the remote backend information, which is where the given Terraform state is stored
    (in this recipe, we used Azure Storage).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，我们添加了`terraform_remote_state`块，它允许我们检索另一个Terraform状态文件中存在的输出。在其块中，我们指定了远程后端信息，这是给定Terraform状态存储的位置（在本食谱中，我们使用了Azure
    Storage）。
- en: In *step 2*, we used the ID returned by the output present in the Terraform
    state file.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们使用了Terraform状态文件中输出返回的ID。
- en: The result of executing this code is exactly the same as what we saw in the *Using
    external resources with data blocks* recipe.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码的结果与我们在 *使用数据块调用外部资源* 方案中看到的完全相同。
- en: There's more…
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: This technique is very practical when separating the Terraform configuration that
    deploys a complex infrastructure.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当将部署复杂基础设施的 Terraform 配置进行分离时，这个技巧非常实用。
- en: Separating the Terraform configuration is a good practice because it allows
    better control and maintainability of the Terraform configuration. It also allows
    us to provision each part separately, without it impacting the rest of the infrastructure.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Terraform 配置分离是一个良好的实践，因为它可以更好地控制和维护 Terraform 配置。它还允许我们单独配置每个部分，而不会影响其他基础设施。
- en: 'To know when to use a data block or a `terraform_remote_state` block, the following
    recommendations must be kept in mind:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道何时使用数据块或 `terraform_remote_state` 块，必须记住以下建议：
- en: 'The `data` block is used in the following cases:'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data` 块用于以下情况：'
- en: When external resources have not been provisioned with Terraform configuration (it
    has been built manually or with a script)
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当外部资源未通过 Terraform 配置进行配置（它是手动构建的或通过脚本构建的）
- en: When the user providing the resources of our Terraform configuration does not
    have access to another remote backend
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当提供我们 Terraform 配置资源的用户无法访问另一个远程后端时
- en: 'The `terraform_remote_state` block is used in the following cases:'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`terraform_remote_state` 块用于以下情况：'
- en: External resources have not been provisioned with Terraform configuration
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部资源未通过 Terraform 配置进行配置
- en: When the user providing the resources of our Terraform configuration has read
    access to the other remote backend
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当提供我们 Terraform 配置资源的用户拥有对另一个远程后端的读取权限时
- en: When the external Terraform state file contains the output of the property we
    need in our Terraform configuration
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当外部 Terraform 状态文件包含我们在 Terraform 配置中所需的属性输出时
- en: See also
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: The documentation for the `terraform_remote_state` block is available at [https://www.terraform.io/docs/providers/terraform/d/remote_state.html](https://www.terraform.io/docs/providers/terraform/d/remote_state.html).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`terraform_remote_state` 块的文档可以在 [https://www.terraform.io/docs/providers/terraform/d/remote_state.html](https://www.terraform.io/docs/providers/terraform/d/remote_state.html)
    找到。'
- en: Querying external data with Terraform
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Terraform 查询外部数据
- en: In the previous two recipes, we learned that it is possible to use either the
    `data` block or the `terraform_remote_state` block to retrieve external data.
    However, there are scenarios where the `data` block does not exist in the provider
    or `terraform_remote_state` cannot be used, such as when we need to process with
    an external API or need to use a local tool and process its output.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面两种方案中，我们学习了可以使用 `data` 块或 `terraform_remote_state` 块来获取外部数据。然而，也有一些场景，`data`
    块在提供程序中不存在，或者 `terraform_remote_state` 无法使用，例如当我们需要与外部 API 进行处理，或者需要使用本地工具并处理其输出时。
- en: To meet this need, there is an `external` resource in Terraform that allows
    you to call an external program and retrieve its output data so that it can be
    used in the Terraform configuration.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这一需求，Terraform 中有一个 `external` 资源，它允许你调用外部程序并获取其输出数据，以便在 Terraform 配置中使用。
- en: Use of the `external` provider imposes prerequisites that may not be obvious
    (for example, in this case, we expect a particular version of PowerShell) or may
    be difficult to communicate other than through `README` files or documentation.
    Also, Terraform is generally designed to work the same cross-platform (operating
    system/architecture), but this essentially restricts the configuration to particular
    platforms that can (and do) run PowerShell – presumably just Windows. These requirements
    apply to both CI and local environments.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `external` 提供程序会有一些前提条件，这些前提条件可能不明显（例如，在此案例中，我们期望特定版本的 PowerShell），或者可能只能通过
    `README` 文件或文档进行传达。此外，Terraform 通常设计为跨平台（操作系统/架构）工作，但这实际上将配置限制为可以（并且确实可以）运行 PowerShell
    的特定平台——大概仅限于 Windows。这些要求适用于 CI 和本地环境。
- en: In this recipe, we will learn how to call an external program and retrieve its
    output so that we can reuse it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方案中，我们将学习如何调用外部程序并获取其输出，以便我们可以重用它。
- en: Getting ready
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will use an existing Terraform configuration that allows
    us to provision a Resource Group in Azure.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个方案，我们将使用一个现有的 Terraform 配置，它允许我们在 Azure 中配置一个资源组。
- en: Here, we want a Resource Group to be in a different Azure region (location),
    depending on the environment (dev or production).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们希望资源组位于不同的Azure区域（位置），具体取决于环境（开发环境或生产环境）。
- en: The source code for this recipe is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/external](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/external).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的源代码可在[https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/external](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/external)获取。
- en: How to do it…
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Perform the following steps:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'In the directory that contains our `main.tf` file, create a PowerShell `GetLocation.ps1`
    script that contains the following content:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包含`main.tf`文件的目录中，创建一个PowerShell脚本`GetLocation.ps1`，内容如下：
- en: '[PRE23]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the `main.tf` file, add the `external` block, as follows:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.tf`文件中，添加`external`块，内容如下：
- en: '[PRE24]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, modify the code of the Resource Group to make its location more dynamic,
    as follows:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，修改资源组的代码，使其位置更加动态，如下所示：
- en: '[PRE25]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Optionally, you can add an `output` value that has the following configuration:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，你可以添加一个`output`值，其配置如下：
- en: '[PRE26]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works…
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1*, we wrote the PowerShell `GetLocation.ps1` script, which will be
    called by Terraform locally. This script takes in `environment` as an input parameter
    in JSON format. Then, this PowerShell script makes a condition on this input environment
    and returns the right Azure region as output so that we can use it in our Terraform
    configuration.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1步*中，我们编写了PowerShell脚本`GetLocation.ps1`，该脚本将在本地由Terraform调用。此脚本接受`environment`作为输入参数，格式为JSON。然后，PowerShell脚本根据此输入环境做出条件判断，并返回正确的Azure区域作为输出，以便我们在Terraform配置中使用它。
- en: Then, in *step 2*, we used the Terraform `external` resource, which calls this
    PowerShell script and provides it with the contents of the `environment_name`
    variable as a parameter.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在*第2步*中，我们使用了Terraform的`external`资源，它调用这个PowerShell脚本并将`environment_name`变量的内容作为参数提供给它。
- en: Finally, in *step 3*, we used the return value of this `external` block in the
    `location` property of the Resource Group.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*第3步*中，我们将`external`块的返回值用于资源组的`location`属性。
- en: 'The following screenshot shows the output of executing `terraform plan` with
    the `environment_name` variable, which is set to `Dev`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了执行`terraform plan`命令时，`environment_name`变量设置为`Dev`的输出：
- en: '![](img/f4d30c6d-2474-48b7-a7e5-383de2bf5be6.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4d30c6d-2474-48b7-a7e5-383de2bf5be6.png)'
- en: As you can see, the regional location of the Resource Group is `westus`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，资源组的区域位置是`westus`。
- en: 'The following screenshot shows the output executing `terraform plan` with the
    `environment_name` variable, which is set to `Production`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了执行`terraform plan`命令时，`environment_name`变量设置为`Production`的输出：
- en: '![](img/ceb825a5-e06d-42ff-a631-cd4cc59f85ab.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ceb825a5-e06d-42ff-a631-cd4cc59f85ab.png)'
- en: As you can see, the location of the Resource Group is `westeurope`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，资源组的区域位置是`westeurope`。
- en: As we saw in the *Manipulating variables* recipe, in this example, we used the
    `-var` option of the `terraform plan` command, which allows us to assign a value
    to a variable upon executing the command.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*操作变量*一节中看到的那样，在这个示例中，我们使用了`terraform plan`命令的`-var`选项，这允许我们在执行命令时为变量分配一个值。
- en: Optionally, we can also add a Terraform `output` that exposes this value. This
    can be displayed upon executing Terraform. This can also be exploited at other
    places in the Terraform configuration.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，我们还可以添加一个Terraform `output`，以暴露此值。在执行Terraform时，这个值可以显示出来。它还可以在Terraform配置中的其他地方使用。
- en: 'The following screenshot shows the output after running the `terraform apply`
    command:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了运行`terraform apply`命令后的输出：
- en: '![](img/e13ba774-e0de-4825-8727-c70e511fcecd.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e13ba774-e0de-4825-8727-c70e511fcecd.png)'
- en: As we can see, the `terraform output` command displays the right `locationname`
    value.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`terraform output`命令显示了正确的`locationname`值。
- en: There's more…
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In this recipe, we used a PowerShell script, but this script also works with
    all the other scripting languages and tools that are installed on your local machine.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用了PowerShell脚本，但该脚本同样适用于本地机器上安装的所有其他脚本语言和工具。
- en: This `external` resource contains specifics about the protocol, the format of
    the parameters, and its output. I advise that you read its documentation to learn
    more: [https://www.terraform.io/docs/providers/external/data_source.html](https://www.terraform.io/docs/providers/external/data_source.html)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`external`资源包含了关于协议、参数格式及其输出的详细信息。我建议你阅读它的文档以了解更多：[https://www.terraform.io/docs/providers/external/data_source.html](https://www.terraform.io/docs/providers/external/data_source.html)
- en: See also
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'The following are some example articles regarding how to use the `external`
    Terraform resource:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于如何使用`external` Terraform资源的示例文章：
- en: '[https://dzone.com/articles/lets-play-with-terraform-external-provider](https://dzone.com/articles/lets-play-with-terraform-external-provider)'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://dzone.com/articles/lets-play-with-terraform-external-provider](https://dzone.com/articles/lets-play-with-terraform-external-provider)'
- en: '[https://thegrayzone.co.uk/blog/2017/03/external-terraform-provider-powershell/](https://thegrayzone.co.uk/blog/2017/03/external-terraform-provider-powershell/)'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://thegrayzone.co.uk/blog/2017/03/external-terraform-provider-powershell/](https://thegrayzone.co.uk/blog/2017/03/external-terraform-provider-powershell/)'
- en: Calling Terraform built-in functions
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用Terraform内置函数
- en: When provisioning infrastructure or handling resources with Terraform, it is
    sometimes necessary to use transformations or combinations of elements provided
    in the Terraform configuration.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Terraform进行基础设施配置或处理资源时，有时需要使用变换或组合Terraform配置中提供的元素。
- en: For this purpose, the language supplied with Terraform (HCL2) includes functions
    that are built-in and can be used in any Terraform configuration.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，Terraform自带的语言（HCL2）包含了一些内置函数，可以在任何Terraform配置中使用。
- en: In this recipe, we will discuss how to use built-in functions to apply transformations
    to code.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将讨论如何使用内置函数对代码应用变换。
- en: Getting ready
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To complete this recipe, we will start from scratch regarding the Terraform
    configuration, which will be used to provision a Resource Group in Azure. This
    Resource Group will be named according to the following naming convention:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个食谱，我们将从零开始配置Terraform，用于在Azure中配置一个资源组。这个资源组将按照以下命名约定进行命名：
- en: '[PRE27]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This name should be entirely in uppercase.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名称应该完全是大写的。
- en: The source code for this recipe is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/fct](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/fct).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的源代码可以在[https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/fct](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/fct)找到。
- en: How to do it…
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到……
- en: 'Perform the following steps:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: In a new local folder, create a file called `main.tf`.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的本地文件夹中，创建一个名为`main.tf`的文件。
- en: 'In this `main.tf` file, write the following code:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个`main.tf`文件中，写入以下代码：
- en: '[PRE28]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, in this `main.tf` file, write the following Terraform configuration:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在这个`main.tf`文件中，写入以下Terraform配置：
- en: '[PRE29]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works…
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In *step 3*, we defined the property name of the resource with a Terraform `format`
    function, which allows us to format text. In this function, we used the `%s` verb
    to indicate that it is a character string that will be replaced, in order, by
    the name of the application and the name of the environment.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第3步*中，我们使用Terraform的`format`函数定义了资源的属性名称，该函数允许我们格式化文本。在这个函数中，我们使用了`%s`动词来表示它是一个字符字符串，稍后将被应用程序名称和环境名称按顺序替换。
- en: Furthermore, to capitalize everything inside, we encapsulate the `format` function
    in the `upper` function, which capitalizes all its contents.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了使其中的所有内容大写，我们将`format`函数封装在`upper`函数中，该函数将把所有内容转换为大写。
- en: 'The result of executing these Terraform commands on this code can be seen in
    the following screenshot:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这些Terraform命令后的结果可以在以下截图中看到：
- en: '![](img/b5e9edb9-77c1-499c-a08f-18cdb39c54a8.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5e9edb9-77c1-499c-a08f-18cdb39c54a8.png)'
- en: Thus, thanks to these functions, it is possible to control the properties that
    will be used in the Terraform configuration. This also allows us to apply transformations
    automatically, without having to impose constraints on the user using the Terraform
    configuration.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，得益于这些函数，我们可以控制Terraform配置中将使用的属性。这也使得我们能够自动应用变换，而不需要对使用Terraform配置的用户施加约束。
- en: See also
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: There are a multitude of predefined functions in Terraform. The full list can
    be found at [https://www.terraform.io/docs/configuration/functions.html](https://www.terraform.io/docs/configuration/functions.html)
    (see the left menu).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 中有许多预定义的函数。完整列表可在 [https://www.terraform.io/docs/configuration/functions.html](https://www.terraform.io/docs/configuration/functions.html)
    查找（请参见左侧菜单）。
- en: Writing conditional expressions
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写条件表达式
- en: When writing the Terraform configuration, we may need to make the code more
    dynamic by integrating various conditions. In this recipe, we will discuss an
    example of an equal condition operation.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写 Terraform 配置时，我们可能需要通过集成各种条件来使代码更加动态。在本食谱中，我们将讨论一个相等条件操作的示例。
- en: Getting ready
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will use the Terraform configuration we wrote in the previous
    recipe, whose code is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/fct](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/fct).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本食谱，我们将使用之前食谱中编写的 Terraform 配置，其代码可在 [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/fct](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/fct)
    获取。
- en: 'We will complete this code by adding a condition to the name of the Resource
    Group. This condition is as follows: if the name of the environment is equal to
    `Production`, then the name of the Resource Group will be in the form `RG-<APP
    NAME>`; otherwise, the name of the Resource Group will be in the form `RG-<APP
    NAME>-<ENVIRONMENT NAME>`.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过向资源组的名称添加条件来完成此代码。此条件如下：如果环境的名称等于 `Production`，则资源组的名称将为 `RG-<APP NAME>`；否则，资源组的名称将为
    `RG-<APP NAME>-<ENVIRONMENT NAME>`。
- en: How to do it…
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何执行…
- en: 'In the Terraform configuration of the `main.tf` file, modify the code of the
    Resource Group, as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.tf` 文件的 Terraform 配置中，修改资源组的代码，如下所示：
- en: '[PRE30]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works…
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Here, we added the following condition:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了以下条件：
- en: '[PRE31]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The result of executing Terraform commands on this code if the `environment`
    variable is equal to production can be seen in the following screenshot:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `environment` 变量等于 production，执行 Terraform 命令时该代码的结果可在以下屏幕截图中看到：
- en: '![](img/2f28a9fc-dc9b-4f05-b45b-6c4c01f15584.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f28a9fc-dc9b-4f05-b45b-6c4c01f15584.png)'
- en: 'If the `environment` variable is not equal to `production`, we''ll get the
    following output:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `environment` 变量不等于 `production`，我们将得到以下输出：
- en: '![](img/5f8fff9d-56d4-4ca9-b71c-ae503b854b6c.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f8fff9d-56d4-4ca9-b71c-ae503b854b6c.png)'
- en: See also
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Documentation on the various conditions of Terraform can be found at [https://www.terraform.io/docs/configuration/expressions.html#conditional-expressions](https://www.terraform.io/docs/configuration/expressions.html#conditional-expressions).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Terraform 各种条件的文档可以在 [https://www.terraform.io/docs/configuration/expressions.html#conditional-expressions](https://www.terraform.io/docs/configuration/expressions.html#conditional-expressions)
    查找。
- en: Manipulating local files with Terraform
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Terraform 操作本地文件
- en: Terraform is very popular due to its Infrastructure as Code functionality for
    cloud providers. But it also has many providers that allow us to manipulate the
    local system.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其云服务提供商的基础设施即代码功能，Terraform 非常受欢迎。但它也有许多提供者，可以让我们操作本地系统。
- en: In the *Querying external data with Terraform* recipe, we discussed local script
    executions that are performed by Terraform to get data for external data sources.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *使用 Terraform 查询外部数据* 食谱中，我们讨论了由 Terraform 执行的本地脚本，以获取外部数据源的数据。
- en: In this recipe, we will study another type of local operation that involves
    creating and archiving local files with Terraform.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将研究另一种涉及使用 Terraform 创建和归档本地文件的本地操作。
- en: Getting ready
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we don't need any prerequisites or base code – we will write
    the code from scratch.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本食谱，我们不需要任何前提条件或基础代码——我们将从头开始编写代码。
- en: The source code for this recipe is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/files](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/files).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的源代码可在 [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/files](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/files)
    获取。
- en: How to do it…
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何执行…
- en: 'Perform the following steps:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'In a new folder called `files`, create a `main.tf` file. Write the following
    code inside it:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `files` 的新文件夹中，创建一个 `main.tf` 文件。将以下代码写入其中：
- en: '[PRE32]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In a command-line terminal, navigate to the `files` directory and execute Terraform''s
    workflow commands, which are as follows:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行终端中，导航到 `files` 目录并执行 Terraform 的工作流命令，命令如下：
- en: '[PRE33]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In a new `archive` folder, create a `main.tf` file and write the following
    Terraform configuration inside it:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, using the command-line terminal, navigate to the `archive` directory
    and execute the following Terraform commands:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works…
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, we wrote a piece of Terraform configuration that uses the `local` provider and
    the `local_file` resource. This resource creates a file called `mytextfile.txt` and
    adds `This is my text` to it.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Then, in *step 2*, we executed Terraform on this code. By doing this, we obtained
    the `mytextfile.txt` file on our local disk.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of executing the `terraform plan` command on this code can be seen
    in the following screenshot:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f6d91dc-b509-46fe-920c-c66e80ccfa4c.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
- en: After we executed `terraform apply`, the `mytextfile.txt` file became available
    on our local filesystem.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of this recipe, in *step 3*, we wrote a piece of Terraform
    configuration that uses the `archive` provider and the `archive_file` resource
    to create a ZIP file that contains the file we created in *steps 1* and *2*.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: After we executed `terraform apply`, the ZIP archive `backup.zip` file became
    available on our local filesystem, in the `archives` folder.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we can see, the `archive_file` resource we used in the second part of this
    recipe is of the `data` block type (which we learned about in the *Obtaining external
    data with data sources *recipe of this chapter) and is therefore based on an element
    that already exists before we execute the `terraform plan` command.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the file to be included in the archive must already be present
    on the local disk.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation on the `local_file` resource is available at [https://www.terraform.io/docs/providers/local/r/file.html](https://www.terraform.io/docs/providers/local/r/file.html).
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `archive_file` resource is available at [https://www.terraform.io/docs/providers/archive/d/archive_file.html](https://www.terraform.io/docs/providers/archive/d/archive_file.html).
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing local programs with Terraform
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the previous recipe regarding file manipulation, apart from infrastructure
    provisioning, Terraform also allows you to run programs or scripts that are located
    on the local workstation where Terraform has been installed.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to execute a local program inside the Terraform
    configuration.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will complete the Terraform configuration that we used in
    the previous recipe to write a file on the local machine. Our goal will be to
    execute a PowerShell command with Terraform that will read and display the contents
    of the file that we have written using Terraform.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we will have to run this Terraform script on a Windows operating
    system.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this recipe is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/files_local_exec](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/files_local_exec).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main.tf` file, which is in the `files` directory of the source code
    from the previous recipe, complete the Terraform configuration with the following
    code:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, in a command-line terminal, execute the Terraform workflow commands,
    as follows:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works…
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we used `null_resource`, which is a `null` provider resource.
    This resource doesn't allow us to create resources, but rather run programs locally.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: In this resource, we have the `provisioner` block, which is of the `local-exec`
    type, which operates on our local machine. Then, in this block, we indicate the
    command to execute, which is the `-Content` command of PowerShell. With this,
    we are telling Terraform to use the `PowerShell` interpreter to execute this command.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'When executing the respective Terraform commands, we get the following result:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/055c4a2d-3632-4aa2-9225-5a858acca537.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
- en: As you can see, the text `This is my text`, which we had written in the file
    (in the `local_file` resource), is displayed in the Terraform runtime output.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we looked at a simple `local-exec` command being executed with
    Terraform. It is also possible to execute several commands that are stored in a
    script file (Bash, PowerShell, and so on) with a sample Terraform configuration,
    as shown here:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `local-exec` provisioner sets expectations on the local system, which may
    not be obvious. This is usually otherwise mitigated by cross-platform builds from
    providers and Terraform itself, where the implementation should generally work
    the same on any supported platform (macOS/Linux/Windows).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: In addition, it is important to know that the `local-exec` provisioner, once
    executed, ensures that the Terraform state file cannot be executed a second time
    by the `terraform apply` command.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: To be able to execute the `local-exec` command based on a trigger element, such
    as a resource that has been modified, it is necessary to add a `trigger` object
    inside `null_resource` that will act as the trigger element of the `local-exec` resource.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example code uses a trigger, based on `timestamp`, to execute
    the `local-exec` code at each execution step of Terraform:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this example, the trigger is a timestamp that will have a different value
    each time Terraform is run.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: We will look at another concrete use case of `local-exec` in the *Executing
    Azure CLI commands in Terraform* recipe in [Chapter 6](d054157b-d534-47c9-8079-3af13107c4ef.xhtml),
    *Provisioning Azure Infrastructure with Terraform*.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `local-exec` provisioner documentation is available at [https://www.terraform.io/docs/provisioners/local-exec.html](https://www.terraform.io/docs/provisioners/local-exec.html).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Generating passwords with Terraform
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Terraform生成密码
- en: When provisioning infrastructure with Terraform, there are some resources that
    require passwords in their properties, such as VMs and databases.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Terraform配置基础设施时，有些资源在其属性中需要密码，例如虚拟机和数据库。
- en: To ensure better security by not writing passwords in clear text, you can use
    a Terraform provider, which allows you to generate passwords.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保更好的安全性，避免明文写入密码，您可以使用Terraform提供程序，它允许您生成密码。
- en: In this recipe, we will discuss how to generate a password with Terraform and
    assign it to a resource.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将讨论如何使用Terraform生成密码并将其分配给资源。
- en: Getting ready
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we need to provision a VM in Azure that will be provisioned
    with an administrator password generated dynamically by Terraform.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们需要在Azure中配置一个虚拟机，该虚拟机将通过Terraform动态生成的管理员密码进行配置。
- en: To do this, we will base ourselves on an already existing Terraform configuration that
    provisions a VM in Azure.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将基于一个已经存在的Terraform配置，该配置用于在Azure中配置虚拟机。
- en: The source code for this recipe is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/password](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/password).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的源代码可在[https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/password](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/password)找到。
- en: How to do it…
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Perform the following steps:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'In the Terraform configuration file for the VM, add the following code:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VM的Terraform配置文件中，添加以下代码：
- en: '[PRE40]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, in the code of the resource itself, modify the password property with
    the following code:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在资源本身的代码中，修改密码属性，使用以下代码：
- en: '[PRE41]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works…
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理…
- en: In *step 1*, we added the Terraform `random_password` resource from the `random` provider,
    which allows us to generate strings according to the properties provided. These
    will be sensitive, meaning that they're protected by Terraform.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第一步*中，我们从`random`提供程序中添加了Terraform的`random_password`资源，它允许我们根据提供的属性生成字符串。这些字符串将是敏感的，意味着它们会被Terraform保护。
- en: Then, in *step 2*, we used its result (with the `result` property) in the password
    property of the VM.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在*第二步*中，我们使用了其结果（通过`result`属性）在虚拟机的密码属性中。
- en: 'The result of executing the `terraform plan` command on this code can be seen
    in the following screenshot:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`terraform plan`命令时，代码的执行结果可以在以下截图中看到：
- en: '![](img/e6a3aa5e-05d5-4346-95c4-8d25d3458422.png)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6a3aa5e-05d5-4346-95c4-8d25d3458422.png)'
- en: As we can see, the result is `sensitive value`.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，结果是`sensitive value`。
- en: Please note that the fact a property is sensitive in Terraform means that it
    cannot be displayed when using the Terraform `plan` and `apply` commands in the
    console output display.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Terraform中的敏感属性意味着在使用Terraform的`plan`和`apply`命令时，无法在控制台输出中显示该属性。
- en: On the other hand, it will be present in clear text in the Terraform state file.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，它将以明文形式出现在Terraform状态文件中。
- en: See also
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: To find out more about the `random_password` resource, read the following documentation: [https://www.terraform.io/docs/providers/random/r/password.html](https://www.terraform.io/docs/providers/random/r/password.html).
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于`random_password`资源的信息，请阅读以下文档：[https://www.terraform.io/docs/providers/random/r/password.html](https://www.terraform.io/docs/providers/random/r/password.html)。
- en: Documentation regarding sensitive data in Terraform state files is available
    at [https://www.terraform.io/docs/state/sensitive-data.html](https://www.terraform.io/docs/state/sensitive-data.html).
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Terraform状态文件中敏感数据的文档，请参见[https://www.terraform.io/docs/state/sensitive-data.html](https://www.terraform.io/docs/state/sensitive-data.html)。
