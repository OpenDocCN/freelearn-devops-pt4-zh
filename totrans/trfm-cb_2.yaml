- en: Writing Terraform Configuration
  prefs: []
  type: TYPE_NORMAL
- en: When you start writing Terraform configuration, you will notice very quickly
    that the language provided by Terraform is very rich and allows for a lot of manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: In the recipes in this chapter, you will learn how to use the Terraform language
    effectively in order to apply it to real-life business scenarios. We will discuss
    how to specify the versions of the provider to be used, as well as how to make
    the code more dynamic with variables and outputs. Then, we will use these concepts
    to provision several environments with Terraform. After that, we will consider
    the use of functions and conditions.
  prefs: []
  type: TYPE_NORMAL
- en: We will also learn how to retrieve data from external systems with data blocks,
    other Terraform state files, and external resources. Finally, we will cover the
    use of Terraform for local operations, such as running a local executable and
    manipulating local files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Terraform and the provider version to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using local variables for custom functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using outputs to expose Terraform provisioned data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provisioning infrastructure in multiple environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtaining external data with data sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using external resources from other state files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying external data with Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling Terraform built-in functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing conditional expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating local files with Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing local programs with Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating passwords with Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you will need to have the Terraform binary installed on your
    computer. The source code for this chapter is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action: [https://bit.ly/3hcZNVR](https://bit.ly/3hcZNVR)
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Terraform and the provider version to use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default behavior of Terraform is that, when executing the `terraform init`
    command, the version of the Terraform binary (which we will call the **Command-Line
    Interface** (**CLI**), as explained here: [https://www.terraform.io/docs/glossary.html#cli](https://www.terraform.io/docs/glossary.html#cli)) used
    is the one installed on the local workstation. In addition, this command downloads
    the latest version of the providers used in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, for compatibility reasons, it is always advisable to avoid surprises so
    that you can specify which version of the Terraform binary is going to be used
    in the Terraform configuration. The following are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: A Terraform configuration written with HCL 2 must indicate that it has to be
    executed with a Terraform version greater than or equal to 0.12.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Terraform configuration that contains new features such as `count` and `for_each`
    in modules must indicate that it has to be executed with a Terraform version greater
    than or equal to 0.13.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more details about the HCL syntax, read the documentation at [https://www.terraform.io/docs/configuration/syntax.html](https://www.terraform.io/docs/configuration/syntax.html).
  prefs: []
  type: TYPE_NORMAL
- en: In the same vein and for the same reasons of compatibility, we may want to specify
    the provider version to be used.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to specify the Terraform version, as well
    as the provider version.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start this recipe, we will write a basic Terraform configuration file that
    contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This example code provides resources in Azure (a Resource Group and a public
    IP address). For more details, read the following documentation about the Terraform
    AzureRM provider: [https://www.terraform.io/docs/providers/azurerm/index.html](https://www.terraform.io/docs/providers/azurerm/index.html)
  prefs: []
  type: TYPE_NORMAL
- en: In addition, this code contains the improvements that were made to the HCL 2.0
    language since Terraform 0.12\. For more details about these HCL enhancements,
    go to [https://www.slideshare.net/mitchp/terraform-012-deep-dive-hcl-20-for-infrastructure-as-code-remote-plan-apply-125837028](https://www.slideshare.net/mitchp/terraform-012-deep-dive-hcl-20-for-infrastructure-as-code-remote-plan-apply-125837028).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, when executing the `terraform plan` command inside this code, we get
    the following warning message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/754aad40-3123-4b99-ba8d-190489a662e3.png)'
  prefs: []
  type: TYPE_IMG
- en: This means that, currently, this Terraform configuration is still compatible
    with the latest version of the provider but that in a future version of the provider,
    this property will be changed and therefore this code will no longer work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s discuss the steps we need to follow to make the following compliances:'
  prefs: []
  type: TYPE_NORMAL
- en: This configuration can only be executed if Terraform 0.13 (at least) is installed
    on the local computer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our current configuration can be executed even if the `azurerm` provider evolves
    with breaking changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regarding the new features provided by Terraform 0.13, read the change log here – [https://github.com/hashicorp/terraform/blob/master/CHANGELOG.md](https://github.com/hashicorp/terraform/blob/master/CHANGELOG.md),
    and the upgrade guide here – [https://github.com/hashicorp/terraform/blob/master/website/upgrade-guides/0-13.html.markdown](https://github.com/hashicorp/terraform/blob/master/website/upgrade-guides/0-13.html.markdown).
  prefs: []
  type: TYPE_NORMAL
- en: We'll take a look at this next.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To specify the Terraform version to be installed on the local workstation,
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Terraform configuration, add the following block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To specify the provider source and version to use, we need to add the `required_provider`
    block inside the same `terraform` configuration block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When executing the `terraform init` command, Terraform will check that the version
    of the installed Terraform binary that executes the Terraform configuration file
    corresponds to the version specified in the `required_version` property of the
    `terraform` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it matches, it won''t throw an error as it is greater than version 0.13\.
    Otherwise, it will throw an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4dd89fda-144c-4ded-95b4-051e0029f4a4.png)'
  prefs: []
  type: TYPE_IMG
- en: With regard to the specification of the provider version, when executing the
    `terraform init` command, if no version is specified, Terraform downloads the
    latest version of the provider, otherwise it downloads the specified version,
    as shown in the following two screenshots.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the provider plugin being downloaded from the
    specified `source` without us specifying the required version (at the time of
    writing, the latest version of the provider is 2.20.0):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/280032a1-412f-4a80-86f0-55e0681092c5.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the latest version of the `azurerm` provider (2.20.0) has been
    downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, the following screenshot shows the `azurerm` provider plugin being
    downloaded when we specify the required version (2.10.0):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aec54df2-67e1-4d5d-abc4-c5c4a3cce7e7.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the specified version of the `azurerm` provider (2.10.0) has
    been downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: For more details about the `required_version` block and provider versions, go
    to [https://www.terraform.io/docs/configuration/terraform.html#specifying-required-provider-versions](https://www.terraform.io/docs/configuration/terraform.html#specifying-required-provider-versions).
  prefs: []
  type: TYPE_NORMAL
- en: In this `required_version` block, we also add the `source` property, which was
    introduced in version 0.13 of Terraform and is documented here: [https://github.com/hashicorp/terraform/blob/master/website/upgrade-guides/0-13.html.markdown#explicit-provider-source-locations](https://github.com/hashicorp/terraform/blob/master/website/upgrade-guides/0-13.html.markdown#explicit-provider-source-locations)
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we learned how to download the `azurerm` provider in various
    ways. What we did here applies to all providers you may wish to download.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to mention that the version of the Terraform binary that's
    used is specified in the Terraform state file. This is to ensure that nobody applies
    this Terraform configuration with a lower version of the Terraform binary, thus
    ensuring that the format of the Terraform state file conforms with the correct
    version of the Terraform binary.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information about the properties of the Terraform block, go to [https://www.terraform.io/docs/configuration/terraform.html](https://www.terraform.io/docs/configuration/terraform.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information about the properties of the providers, go to [https://www.terraform.io/docs/configuration/providers.html](https://www.terraform.io/docs/configuration/providers.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about Terraform binary versioning is documented at [https://www.terraform.io/docs/extend/best-practices/versioning.html](https://www.terraform.io/docs/extend/best-practices/versioning.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The upgrade guide for the `azurerm` provider (to version 2.0) is available at [https://www.terraform.io/docs/providers/azurerm/guides/2.0-upgrade-guide.html](https://www.terraform.io/docs/providers/azurerm/guides/2.0-upgrade-guide.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you write a Terraform configuration file where all the properties are hardcoded
    in the code, you often find yourself faced with the problem of having to duplicate
    it in order to reuse it.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll learn how to make the Terraform configuration more dynamic
    by using variables.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, we are going to work on the `main.tf` file, which contains a basic
    Terraform configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `name` and `location` properties have values written in the
    code in a static way.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn how to make them dynamic using variables.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same `main.tf` file, add the following variable declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, modify the Terraform configuration we had at the beginning of this recipe
    so that it refers to our new variables, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the same folder that contains the `main.tf` file, create a new
    file called `terraform.tfvars` and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *step 1*, we wrote the declaration of the two variables, which consists
    of the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A variable name: This must be unique to this Terraform configuration and must
    be explicit enough to be understood by all the contributors of the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A description of what this variable represents: This description is optional,
    but is recommended because it can be displayed by the CLI and can also be integrated
    into the documentation, which is automatically generated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A default value: This is optional. Not setting a default value makes it mandatory
    to enter a default value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, in *step 2*, we modified the Terraform configuration to use these two
    variables. We did this using the `var.<name of the variable>`syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in *step 3*, we gave values to these variables in the `terraform.tfvars`
    file, which is used natively by Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of executing this Terraform configuration is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96421f7a-ab2b-42e4-b74f-abf39af53249.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting a value in the variable is optional in the `terraform.tfvars` file since
    we have set a default value for the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from this `terraform.tfvars` file, it is possible to give a variable
    a value using the `-var` option of the `terraform plan` and `terraform apply`
    commands, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: So, with this command, the `location` variable declared in our code will have
    a value of `westus` instead of `westeurope`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, with the 0.13 version of Terraform released in August 2020, we
    can now create custom validation rules for variables which makes it possible for
    us to verify a value during the `terraform plan` execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our recipe, we can complete the `location` variable with a validation rule
    in the `validation` block as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding configuration, the rule checks that if the value of the `location`
    variable is `westeurope` or `westus`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `terraform plan` command in execution if
    we put another value in the `location` variable, such as `westus2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f568703-848d-47d5-96af-41d501ff5cef.png)'
  prefs: []
  type: TYPE_IMG
- en: For more information about variable custom rules validation read the documentation
    at [https://www.terraform.io/docs/configuration/variables.html#custom-validation-rules](https://www.terraform.io/docs/configuration/variables.html#custom-validation-rules).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there is another alternative to setting a value to a variable, which
    consists of setting an environment variable called `TF_VAR_<variable name>`. As
    in our case, we can create an environment variable called `TF_VAR_location` with
    a value of `westus` and then execute the `terraform plan` command in a classical
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Note that using the `-var` option or the `TF_VAR_<name of the variable>` environment
    variable doesn't hardcode these variable's values inside the Terraform configuration.
    They make it possible for us to give values of variables to the flight. But be
    careful – these options can have consequences if the same code is executed with
    other values initially provided in parameters and the plan's output isn't reviewed
    carefully.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we looked at the basic use of variables. We will look at more
    advanced uses of these when we learn how to manage environments in the *Managing
    infrastructure in multiple environments* recipe, later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on variables, refer to the documentation here: [https://www.terraform.io/docs/configuration/variables.html](https://www.terraform.io/docs/configuration/variables.html)
  prefs: []
  type: TYPE_NORMAL
- en: Using local variables for custom functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learned how to use variables to dynamize our Terraform
    configuration. Sometimes, this use can be a bit more tedious when it comes to
    using combinations of variables.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to implement local variables and use them
    as custom functions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start with, we will use the following Terraform configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The goal of this recipe is to consistently render the names of the Azure resources.
    We must provide them with the following nomenclature rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main.tf` file, which contains our Terraform configuration, we will
    add a local variable called `resource_name`, along with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use this local variable in the resources with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, we created a variable called `resource_name` that is local to our
    Terraform configuration. This allows us to create a combination of several Terraform
    variables (which we will see the result of in the *Using outputs to expose Terraform
    provisioned data* recipe of this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Then, in *step 2*, we used this local variable with the `local.<name of the
    local variable>` expression. Moreover, in the `name` property, we used it as a
    concatenation of a variable and static text, which is why we used the `"${}"`
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of executing this Terraform configuration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75e03e97-6029-48a3-9892-88380f2295a7.png)'
  prefs: []
  type: TYPE_IMG
- en: In the previous screenshot, we can see the output of executing the `terraform
    plan` command with the `name` of the Resource Group that we calculated with the `locals`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on local variables, take a look at the following documentation: [https://www.terraform.io/docs/configuration/locals.html](https://www.terraform.io/docs/configuration/locals.html)
  prefs: []
  type: TYPE_NORMAL
- en: Using outputs to expose Terraform provisioned data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using Infrastructure as Code tools such as Terraform, it is often necessary
    to retrieve output values from the provisioned resources after code execution.
  prefs: []
  type: TYPE_NORMAL
- en: One of the uses of these output values is that they can be used after execution
    by other programs. This is often the case when the execution of the Terraform
    configuration is integrated into a CI/CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can use these output values in a CI/CD pipeline that creates
    an Azure App Service with Terraform and also deploys the application to this Azure
    App Service. In this example, we can have the name of the App Service (web app
    type) as the output of the Terraform configuration. These output values are also
    very useful for transmitting information through modules, which we will see in
    detail in [Chapter 5](ddb13a41-5cdd-4931-b38f-d185d3a10c1e.xhtml), *Sharing Terraform
    Configuration with Modules*.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to implement output values in Terraform's configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To proceed, we are going to add some Terraform configuration that we already
    have in the existing `main.tf` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an extract of this existing code, which provides an App Service
    in Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To ensure we have an output value, we will just add the following code to this
    `main.tf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `output` block of Terraform is defined by a name, `webapp_name`, and a value,
    `azurerm_app_service.app.name`. These refer to the name of the Azure App Service
    that is provided in the same Terraform configuration. Optionally, we can add a `description`
    that describes what the output returns, which can also be very useful for autogenerated
    documentation or in the use of modules.
  prefs: []
  type: TYPE_NORMAL
- en: It is, of course, possible to define more than one output in the same Terraform
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The outputs are stored in the Terraform state file and are displayed when the
    `terraform apply` command is executed, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa2ba3e2-fbcc-44c4-830f-5ad926575e67.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we see two output values that are displayed at the end of the execution.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to retrieve the values of the output in order to exploit
    them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: By using the `terraform output` command in the Terraform CLI, which we will
    see in the *Exporting the output in JSON* recipe in [Chapter 4](fc591e87-b893-40fa-9021-7827bffcc094.xhtml),
    *Using the Terraform CLI*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using the `terraform_remote_state` data source object, which we will discuss
    in the *Using external resources from other state files* recipe, later in this
    chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation on Terraform outputs is available at [https://www.terraform.io/docs/configuration/outputs.html](https://www.terraform.io/docs/configuration/outputs.html).
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning infrastructure in multiple environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the same way that we deploy an application to several environments (dev,
    test, QA, and production), we also need to provision infrastructure on these different
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: The question that often arises is how to write a maintainable and scalable Terraform
    configuration that would allow us to provision infrastructure for multiple environments.
  prefs: []
  type: TYPE_NORMAL
- en: To answer this question, it is important to know that there are several solutions
    for organizing Terraform configuration topologies that will allow for this provisioning.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look at two Terraform configuration structure topologies
    that will allow us to deploy an Azure infrastructure to multiple environments.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To fully understand this recipe, you will need to have a good understanding
    of the notion of variables, as discussed in the *Manipulating variables* recipe
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of the Terraform configuration that we are going to write is to deploy
    an Azure App Service for a single environment. Its code is distributed in the
    following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9d8f674-bdcf-4d37-860c-bf99d2c7d570.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding diagram, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `main.tf` file contains the Terraform configuration of the resources to
    be provisioned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `variables.tf` file contains the declaration of the variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `terraform.tfvars` file contains the values of the variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Terraform source code for this basic example is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/myApp/simple-env](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/myApp/simple-env).
  prefs: []
  type: TYPE_NORMAL
- en: What is important in this recipe is not the content of the code, but the folder
    structure and the Terraform commands to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the first Terraform configuration folder topology:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In an empty folder, create a separate directory per environment: one for dev,
    one for test, one for QA, and one for production.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the Terraform base configuration into each of these directories identically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, in each of these directories, modify the values of the `terraform.tfvars`
    file with the information that is specific to the environment. Here is an extract
    of each of these `terraform.tfvars` files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finally, to provision each of these environments, inside each of these directories,
    execute the classical Terraform execution workflow by running the `terraform init`,
    `terraform plan`, and `terraform apply` commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the second topology of the Terraform configuration folder:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the folder that contains our basic Terraform configuration, create three
    subdirectories: `dev`, `test`, and `production`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, in each of these subdirectories, copy only the `terraform.tfvars` base file, in
    which we modify the variables with the correct values of the target environments.
    The following is an extract from each `terraform.tfvars` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to provision each of these environments, go to the root folder of
    the Terraform configuration and execute the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first topology, we duplicate the same Terraform configuration for each
    environment and just change the values of the variables in the `terraform.tfvars`
    file of each folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'By doing this, we get the following folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7837e09f-2dbc-498a-bf8f-8b914453e13f.png)'
  prefs: []
  type: TYPE_IMG
- en: Terraform is then executed with the basic Terraform commands. This structure
    can be used if the infrastructure does not contain the same resources for each
    environment. This is because duplicating all the Terraform configuration in each
    environment folder offers us the advantage of being able to easily add or remove
    resources for one environment without affecting the other environments.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is duplicate code, which implies that this code must be maintained
    several times (we must modify the infrastructure for all environments, make changes
    to the Terraform configuration, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second topology, we kept the Terraform configuration in the common base
    for all environments and have just one `terraform.tfvars` file per environment. By
    doing this, we get the following folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a6f86a3-75ba-4b95-b9e8-6c4ec3f060eb.png)'
  prefs: []
  type: TYPE_IMG
- en: As for the execution of the Terraform configuration, we have added the `-var-file`
    option to the `plan` and `apply` commands. This structure can be used if the infrastructure
    is the same for all environments but only the configuration changes.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this topology is that we have only one common piece of Terraform
    resource code (in the `main.tf` and `variables.tf` files), and just one `terraform.tfvars`
    file to fill in, so we will have to make a few changes in case of code evolution
    or a new environment.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the changes that were made to the Terraform `main.tf` code
    will apply to all the environments, which in this case requires more testing and
    verification.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are other solutions to Terraform configuration folder structure topologies,
    as we will discuss in [Chapter 5](ddb13a41-5cdd-4931-b38f-d185d3a10c1e.xhtml),
    *Sharing Terraform Configuration with Modules*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation regarding the `-var-file` option of the `plan` and `apply` commands
    is available at [https://www.terraform.io/docs/commands/plan.html](https://www.terraform.io/docs/commands/plan.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An article explaining the best practices surrounding Terraform configuration can
    be found at [https://www.terraform-best-practices.com/code-structure](https://www.terraform-best-practices.com/code-structure).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following blog post explains the folder structure for production Terraform
    configuration: [https://www.hashicorp.com/blog/structuring-hashicorp-terraform-configuration-for-production](https://www.hashicorp.com/blog/structuring-hashicorp-terraform-configuration-for-production)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtaining external data with data sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When infrastructure is provisioned with Terraform, it is sometimes necessary
    to retrieve information about the already existing resources. Indeed, when deploying
    resources to a certain infrastructure, there is often a need to place ourselves
    in an existing infrastructure or link it to other resources that have already
    been provisioned.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how, in our Terraform configuration, to retrieve
    information about resources already present in an infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use an existing Terraform configuration that provides
    an Azure App Service in the Azure cloud. This source code is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/data](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/data).
  prefs: []
  type: TYPE_NORMAL
- en: This code is incomplete because, for this project, we need to store the App
    Service in an existing Service Plan. This Service Plan is the one we will use
    for the entire App Service.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our file that contains our Terraform configuration, add the following data
    block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the properties sections, specify the name and the Resource Group of the Service
    Plan to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, complete the existing App Service configuration, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, a data block is added to query existing resources. In this data
    block, we specify the Resource Group and the name of the existing Service Plan.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2*, we use the ID of the Service Plan that was retrieved by the data
    block we added in *step 1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of executing this Terraform configuration can be seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/886e9632-addb-4b12-9d32-fcdefe01e433.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, we have the ID of the Service Plan that was retrieved by the
    `data` block.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What's interesting about the use of data blocks is that when executing the `terraform
    destroy` command on our Terraform configuration, Terraform does not perform a
    destroy action on the resource called by the data block.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the use of data blocks is to be preferred to the use of IDs written
    in clear text in the code, which can change because the data block recovers the
    information dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the data block is also called when executing the `terraform plan` command,
    so your external resource must be present before you execute the `terraform plan`
    and `terraform apply` commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this external resource is not already present, we get the following error
    in the `terraform plan` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d15acf6-1388-49a0-a0e9-d2de230d869f.png)'
  prefs: []
  type: TYPE_IMG
- en: You need to know which providers to use in your Terraform configuration since
    not all providers implement data blocks.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information about data blocks, take a look at the following documentation: [https://www.terraform.io/docs/configuration/data-sources.html](https://www.terraform.io/docs/configuration/data-sources.html)
  prefs: []
  type: TYPE_NORMAL
- en: Using external resources from other state files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw that it's possible to retrieve information about
    resources already present in the infrastructure using data blocks.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn that it is also possible to retrieve external
    information that is present in other Terraform state files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will, similar to the previous recipe, use a Terraform configuration that
    provisions an Azure App Service that must be part of an already provisioned Service
    Plan.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the previous recipe, we will not use individual data sources; instead,
    we will read outputs from an existing Terraform state file that was used to provision
    the Service Plan.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a prerequisite, in the Terraform configuration that was used to provision
    the Service Plan, we must have an output value (see the *Using outputs to expose
    Terraform provisioned data* recipe in this chapter) that returns the identifier
    of the Service Plan, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In addition, we used a remote backend version of Azure Storage (see the *Protecting
    state files in an Azure remote backend* recipe in [Chapter 6](d054157b-d534-47c9-8079-3af13107c4ef.xhtml),
    *Provisioning Azure Infrastructure with Terraform*, for more information) to store
    the Terraform state file of the Service Plan.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Terraform configuration that provides the Azure App Service, add and
    configure the `terraform_remote_state` block, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the Terraform configuration of the Azure App Service, use the created
    output of the Service Plan, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, we added the `terraform_remote_state` block, which allows us to
    retrieve outputs present in another Terraform state file. In its block, we specified
    the remote backend information, which is where the given Terraform state is stored
    (in this recipe, we used Azure Storage).
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2*, we used the ID returned by the output present in the Terraform
    state file.
  prefs: []
  type: TYPE_NORMAL
- en: The result of executing this code is exactly the same as what we saw in the *Using
    external resources with data blocks* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This technique is very practical when separating the Terraform configuration that
    deploys a complex infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Separating the Terraform configuration is a good practice because it allows
    better control and maintainability of the Terraform configuration. It also allows
    us to provision each part separately, without it impacting the rest of the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'To know when to use a data block or a `terraform_remote_state` block, the following
    recommendations must be kept in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `data` block is used in the following cases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When external resources have not been provisioned with Terraform configuration (it
    has been built manually or with a script)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user providing the resources of our Terraform configuration does not
    have access to another remote backend
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `terraform_remote_state` block is used in the following cases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External resources have not been provisioned with Terraform configuration
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user providing the resources of our Terraform configuration has read
    access to the other remote backend
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When the external Terraform state file contains the output of the property we
    need in our Terraform configuration
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The documentation for the `terraform_remote_state` block is available at [https://www.terraform.io/docs/providers/terraform/d/remote_state.html](https://www.terraform.io/docs/providers/terraform/d/remote_state.html).
  prefs: []
  type: TYPE_NORMAL
- en: Querying external data with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two recipes, we learned that it is possible to use either the
    `data` block or the `terraform_remote_state` block to retrieve external data.
    However, there are scenarios where the `data` block does not exist in the provider
    or `terraform_remote_state` cannot be used, such as when we need to process with
    an external API or need to use a local tool and process its output.
  prefs: []
  type: TYPE_NORMAL
- en: To meet this need, there is an `external` resource in Terraform that allows
    you to call an external program and retrieve its output data so that it can be
    used in the Terraform configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Use of the `external` provider imposes prerequisites that may not be obvious
    (for example, in this case, we expect a particular version of PowerShell) or may
    be difficult to communicate other than through `README` files or documentation.
    Also, Terraform is generally designed to work the same cross-platform (operating
    system/architecture), but this essentially restricts the configuration to particular
    platforms that can (and do) run PowerShell – presumably just Windows. These requirements
    apply to both CI and local environments.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to call an external program and retrieve its
    output so that we can reuse it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use an existing Terraform configuration that allows
    us to provision a Resource Group in Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we want a Resource Group to be in a different Azure region (location),
    depending on the environment (dev or production).
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this recipe is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/external](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/external).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the directory that contains our `main.tf` file, create a PowerShell `GetLocation.ps1`
    script that contains the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main.tf` file, add the `external` block, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, modify the code of the Resource Group to make its location more dynamic,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally, you can add an `output` value that has the following configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, we wrote the PowerShell `GetLocation.ps1` script, which will be
    called by Terraform locally. This script takes in `environment` as an input parameter
    in JSON format. Then, this PowerShell script makes a condition on this input environment
    and returns the right Azure region as output so that we can use it in our Terraform
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in *step 2*, we used the Terraform `external` resource, which calls this
    PowerShell script and provides it with the contents of the `environment_name`
    variable as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in *step 3*, we used the return value of this `external` block in the
    `location` property of the Resource Group.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of executing `terraform plan` with
    the `environment_name` variable, which is set to `Dev`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4d30c6d-2474-48b7-a7e5-383de2bf5be6.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the regional location of the Resource Group is `westus`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output executing `terraform plan` with the
    `environment_name` variable, which is set to `Production`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ceb825a5-e06d-42ff-a631-cd4cc59f85ab.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the location of the Resource Group is `westeurope`.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the *Manipulating variables* recipe, in this example, we used the
    `-var` option of the `terraform plan` command, which allows us to assign a value
    to a variable upon executing the command.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, we can also add a Terraform `output` that exposes this value. This
    can be displayed upon executing Terraform. This can also be exploited at other
    places in the Terraform configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output after running the `terraform apply`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e13ba774-e0de-4825-8727-c70e511fcecd.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the `terraform output` command displays the right `locationname`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we used a PowerShell script, but this script also works with
    all the other scripting languages and tools that are installed on your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: This `external` resource contains specifics about the protocol, the format of
    the parameters, and its output. I advise that you read its documentation to learn
    more: [https://www.terraform.io/docs/providers/external/data_source.html](https://www.terraform.io/docs/providers/external/data_source.html)
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some example articles regarding how to use the `external`
    Terraform resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://dzone.com/articles/lets-play-with-terraform-external-provider](https://dzone.com/articles/lets-play-with-terraform-external-provider)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://thegrayzone.co.uk/blog/2017/03/external-terraform-provider-powershell/](https://thegrayzone.co.uk/blog/2017/03/external-terraform-provider-powershell/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling Terraform built-in functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When provisioning infrastructure or handling resources with Terraform, it is
    sometimes necessary to use transformations or combinations of elements provided
    in the Terraform configuration.
  prefs: []
  type: TYPE_NORMAL
- en: For this purpose, the language supplied with Terraform (HCL2) includes functions
    that are built-in and can be used in any Terraform configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will discuss how to use built-in functions to apply transformations
    to code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To complete this recipe, we will start from scratch regarding the Terraform
    configuration, which will be used to provision a Resource Group in Azure. This
    Resource Group will be named according to the following naming convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This name should be entirely in uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this recipe is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/fct](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/fct).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In a new local folder, create a file called `main.tf`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this `main.tf` file, write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in this `main.tf` file, write the following Terraform configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 3*, we defined the property name of the resource with a Terraform `format`
    function, which allows us to format text. In this function, we used the `%s` verb
    to indicate that it is a character string that will be replaced, in order, by
    the name of the application and the name of the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, to capitalize everything inside, we encapsulate the `format` function
    in the `upper` function, which capitalizes all its contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of executing these Terraform commands on this code can be seen in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5e9edb9-77c1-499c-a08f-18cdb39c54a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Thus, thanks to these functions, it is possible to control the properties that
    will be used in the Terraform configuration. This also allows us to apply transformations
    automatically, without having to impose constraints on the user using the Terraform
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a multitude of predefined functions in Terraform. The full list can
    be found at [https://www.terraform.io/docs/configuration/functions.html](https://www.terraform.io/docs/configuration/functions.html)
    (see the left menu).
  prefs: []
  type: TYPE_NORMAL
- en: Writing conditional expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing the Terraform configuration, we may need to make the code more
    dynamic by integrating various conditions. In this recipe, we will discuss an
    example of an equal condition operation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use the Terraform configuration we wrote in the previous
    recipe, whose code is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/fct](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/fct).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will complete this code by adding a condition to the name of the Resource
    Group. This condition is as follows: if the name of the environment is equal to
    `Production`, then the name of the Resource Group will be in the form `RG-<APP
    NAME>`; otherwise, the name of the Resource Group will be in the form `RG-<APP
    NAME>-<ENVIRONMENT NAME>`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the Terraform configuration of the `main.tf` file, modify the code of the
    Resource Group, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we added the following condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of executing Terraform commands on this code if the `environment`
    variable is equal to production can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f28a9fc-dc9b-4f05-b45b-6c4c01f15584.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the `environment` variable is not equal to `production`, we''ll get the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f8fff9d-56d4-4ca9-b71c-ae503b854b6c.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation on the various conditions of Terraform can be found at [https://www.terraform.io/docs/configuration/expressions.html#conditional-expressions](https://www.terraform.io/docs/configuration/expressions.html#conditional-expressions).
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating local files with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Terraform is very popular due to its Infrastructure as Code functionality for
    cloud providers. But it also has many providers that allow us to manipulate the
    local system.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Querying external data with Terraform* recipe, we discussed local script
    executions that are performed by Terraform to get data for external data sources.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will study another type of local operation that involves
    creating and archiving local files with Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we don't need any prerequisites or base code – we will write
    the code from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this recipe is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/files](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/files).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a new folder called `files`, create a `main.tf` file. Write the following
    code inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In a command-line terminal, navigate to the `files` directory and execute Terraform''s
    workflow commands, which are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In a new `archive` folder, create a `main.tf` file and write the following
    Terraform configuration inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, using the command-line terminal, navigate to the `archive` directory
    and execute the following Terraform commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, we wrote a piece of Terraform configuration that uses the `local` provider and
    the `local_file` resource. This resource creates a file called `mytextfile.txt` and
    adds `This is my text` to it.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in *step 2*, we executed Terraform on this code. By doing this, we obtained
    the `mytextfile.txt` file on our local disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of executing the `terraform plan` command on this code can be seen
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f6d91dc-b509-46fe-920c-c66e80ccfa4c.png)'
  prefs: []
  type: TYPE_IMG
- en: After we executed `terraform apply`, the `mytextfile.txt` file became available
    on our local filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of this recipe, in *step 3*, we wrote a piece of Terraform
    configuration that uses the `archive` provider and the `archive_file` resource
    to create a ZIP file that contains the file we created in *steps 1* and *2*.
  prefs: []
  type: TYPE_NORMAL
- en: After we executed `terraform apply`, the ZIP archive `backup.zip` file became
    available on our local filesystem, in the `archives` folder.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we can see, the `archive_file` resource we used in the second part of this
    recipe is of the `data` block type (which we learned about in the *Obtaining external
    data with data sources *recipe of this chapter) and is therefore based on an element
    that already exists before we execute the `terraform plan` command.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the file to be included in the archive must already be present
    on the local disk.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation on the `local_file` resource is available at [https://www.terraform.io/docs/providers/local/r/file.html](https://www.terraform.io/docs/providers/local/r/file.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `archive_file` resource is available at [https://www.terraform.io/docs/providers/archive/d/archive_file.html](https://www.terraform.io/docs/providers/archive/d/archive_file.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing local programs with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the previous recipe regarding file manipulation, apart from infrastructure
    provisioning, Terraform also allows you to run programs or scripts that are located
    on the local workstation where Terraform has been installed.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to execute a local program inside the Terraform
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will complete the Terraform configuration that we used in
    the previous recipe to write a file on the local machine. Our goal will be to
    execute a PowerShell command with Terraform that will read and display the contents
    of the file that we have written using Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we will have to run this Terraform script on a Windows operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this recipe is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/files_local_exec](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/files_local_exec).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main.tf` file, which is in the `files` directory of the source code
    from the previous recipe, complete the Terraform configuration with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in a command-line terminal, execute the Terraform workflow commands,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we used `null_resource`, which is a `null` provider resource.
    This resource doesn't allow us to create resources, but rather run programs locally.
  prefs: []
  type: TYPE_NORMAL
- en: In this resource, we have the `provisioner` block, which is of the `local-exec`
    type, which operates on our local machine. Then, in this block, we indicate the
    command to execute, which is the `-Content` command of PowerShell. With this,
    we are telling Terraform to use the `PowerShell` interpreter to execute this command.
  prefs: []
  type: TYPE_NORMAL
- en: 'When executing the respective Terraform commands, we get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/055c4a2d-3632-4aa2-9225-5a858acca537.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the text `This is my text`, which we had written in the file
    (in the `local_file` resource), is displayed in the Terraform runtime output.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we looked at a simple `local-exec` command being executed with
    Terraform. It is also possible to execute several commands that are stored in a
    script file (Bash, PowerShell, and so on) with a sample Terraform configuration,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `local-exec` provisioner sets expectations on the local system, which may
    not be obvious. This is usually otherwise mitigated by cross-platform builds from
    providers and Terraform itself, where the implementation should generally work
    the same on any supported platform (macOS/Linux/Windows).
  prefs: []
  type: TYPE_NORMAL
- en: In addition, it is important to know that the `local-exec` provisioner, once
    executed, ensures that the Terraform state file cannot be executed a second time
    by the `terraform apply` command.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to execute the `local-exec` command based on a trigger element, such
    as a resource that has been modified, it is necessary to add a `trigger` object
    inside `null_resource` that will act as the trigger element of the `local-exec` resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example code uses a trigger, based on `timestamp`, to execute
    the `local-exec` code at each execution step of Terraform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the trigger is a timestamp that will have a different value
    each time Terraform is run.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at another concrete use case of `local-exec` in the *Executing
    Azure CLI commands in Terraform* recipe in [Chapter 6](d054157b-d534-47c9-8079-3af13107c4ef.xhtml),
    *Provisioning Azure Infrastructure with Terraform*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `local-exec` provisioner documentation is available at [https://www.terraform.io/docs/provisioners/local-exec.html](https://www.terraform.io/docs/provisioners/local-exec.html).
  prefs: []
  type: TYPE_NORMAL
- en: Generating passwords with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When provisioning infrastructure with Terraform, there are some resources that
    require passwords in their properties, such as VMs and databases.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure better security by not writing passwords in clear text, you can use
    a Terraform provider, which allows you to generate passwords.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will discuss how to generate a password with Terraform and
    assign it to a resource.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we need to provision a VM in Azure that will be provisioned
    with an administrator password generated dynamically by Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we will base ourselves on an already existing Terraform configuration that
    provisions a VM in Azure.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this recipe is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/password](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP02/password).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Terraform configuration file for the VM, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the code of the resource itself, modify the password property with
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, we added the Terraform `random_password` resource from the `random` provider,
    which allows us to generate strings according to the properties provided. These
    will be sensitive, meaning that they're protected by Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in *step 2*, we used its result (with the `result` property) in the password
    property of the VM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of executing the `terraform plan` command on this code can be seen
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6a3aa5e-05d5-4346-95c4-8d25d3458422.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the result is `sensitive value`.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the fact a property is sensitive in Terraform means that it
    cannot be displayed when using the Terraform `plan` and `apply` commands in the
    console output display.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, it will be present in clear text in the Terraform state file.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To find out more about the `random_password` resource, read the following documentation: [https://www.terraform.io/docs/providers/random/r/password.html](https://www.terraform.io/docs/providers/random/r/password.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation regarding sensitive data in Terraform state files is available
    at [https://www.terraform.io/docs/state/sensitive-data.html](https://www.terraform.io/docs/state/sensitive-data.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
