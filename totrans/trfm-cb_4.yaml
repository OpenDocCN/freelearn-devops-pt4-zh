- en: Using the Terraform CLI
  prefs: []
  type: TYPE_NORMAL
- en: 'Terraform is an **Infrastructure as Code** (**IaC**) tool that consists of
    two linked elements: the Terraform configuration, written in **HashiCorp Configuration
    Language** (**HCL**), which describes the infrastructure we want to provision,
    and the Terraform client tool, which will analyze and execute our Terraform configuration.
    In the previous two chapters, we have studied a variety of recipes on writing
    Terraform configuration using variables, functions, and expressions of HCL.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on the use of Terraform with its command lines
    and options. We will discuss how to have the code well presented, the destruction
    of resources, and the use of workspaces. Then we will learn how to import already
    existing resources, the taint functionality, and finally, we will see how to generate
    a dependency graph and debug the execution of Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping your Terraform configuration clean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating the code syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destroying infrastructure resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using workspaces for managing environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing existing resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting the output in JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tainting resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating the graph dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging the Terraform execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contrary to the previous two chapters, the code examples provided in this chapter
    are not fundamental, since we will focus on the execution of Terraform command
    lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, to provide Terraform configuration samples, we will manage
    resources in Azure cloud; it is obvious that this also applies to all other Terraform
    providers. If you want to apply these recipes and don''t have an Azure account,
    you can create an Azure account for free at this site: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code examples in this chapter are available here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP04](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP04)'
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the Code in Action: [https://bit.ly/3m3oho7](https://bit.ly/3m3oho7)
  prefs: []
  type: TYPE_NORMAL
- en: Keeping your Terraform configuration clean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any application with code, it is very important that the code is clean and
    clearly readable by all contributors (current and future) who will be involved
    in the maintenance and evolution of this code.
  prefs: []
  type: TYPE_NORMAL
- en: In IaC and with Terraform, it is even more important to have clear code because written
    code serving as documentation is an advantage of IaC.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look at how to use Terraform's command line to properly
    format its code and we will also see some tips for automating it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started, we will start with a `main.tf` file that contains the following
    Terraform configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2220917f-7221-4c62-99d6-38491466c531.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, this code is not very readable; it needs to be better formatted.
  prefs: []
  type: TYPE_NORMAL
- en: To execute Terraform commands with the CLI, we use a command-line terminal (CMD,
    PowerShell, Bash, and so on) and the execution folder will be the folder containing
    the Terraform configuration of the recipe. This will apply to all recipes in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To fix the code indentation, execute the `terraform fmt` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `terraform fmt` command makes it easier to arrange the code with the correct
    indentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of its execution, this command displays the list of files that have
    been modified, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7c7e0ad-f353-4a4b-8b36-d4a80accb9c1.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that executing the `terraform fmt` command modified our `main.tf`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we open the `main.tf` file and read it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e14b773a-0f43-4f91-a0f0-e1b870a25614.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see in the preceding screenshot that the code has been well indented
    and so is more easily readable.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have learned that the `terraform fmt` command executed in
    its most basic way, that is, without any additional options.
  prefs: []
  type: TYPE_NORMAL
- en: This default command indents the Terraform file code, which is at the root of
    the current folder. We can also execute this command recursively, that is, it
    can also indent the code in subfolders of the current folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we execute the `terraform fmt` command with the `-recursive` option
    and its output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bfddf070-0e1d-4b04-887e-e361220ea6db.png)'
  prefs: []
  type: TYPE_IMG
- en: We see that the command has also formatted the `main.tf` file in the `sub` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Among the other options of this command, there is also the `-check` option,
    which can be added and allows you to preview the files that will be indented,
    without applying the changes in the file(s).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it's also possible to automate the execution of this command, because
    apart from running it manually in a command terminal, as seen in this recipe,
    we can automate it to ensure that every time we save or commit a file in Git,
    the code provided and shared with the rest of the contributors will always be
    properly indented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the IDEs that support Terraform have integrated the execution of this
    command natively with the writing of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the Terraform extension of Visual Studio Code, we can have every Terraform
    file saved and formatted with the `terraform fmt` command. For more information,
    read the pertinent documentation: [https://marketplace.visualstudio.com/items?itemName=HashiCorp.terraform](https://marketplace.visualstudio.com/items?itemName=HashiCorp.terraform).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In IntelliJ, the Save action plugin enables the code to be formatted every
    time it is saved and the **Terraform** plugin has a large integration of the `terraform
    fmt` command within the IDE. Furthermore, with this Terraform plugin, it is possible
    to execute the `terraform fmt` command and arrange the code at every code commit,
    as shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/0df18552-6da3-4b9b-94a0-5e7e82113586.png)'
  prefs: []
  type: TYPE_IMG
- en: For more information on the Save action plugin, refer to [https://plugins.jetbrains.com/plugin/7642-save-actions](https://plugins.jetbrains.com/plugin/7642-save-actions)
    and for the Terraform plugin, refer to [https://plugins.jetbrains.com/plugin/7808-hashicorp-terraform--hcl-language-support](https://plugins.jetbrains.com/plugin/7808-hashicorp-terraform--hcl-language-support).
  prefs: []
  type: TYPE_NORMAL
- en: 'For Git commits, it''s possible to automate the execution of the `terraform
    fmt` command before each commit by using pre-commits that are hooks to Git: [https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use pre-commits with Terraform, refer to this list of hooks provided by
    *Gruntwork*: [https://github.com/gruntwork-io/pre-commit](https://github.com/gruntwork-io/pre-commit.).'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The complete `terraform fmt` command documentation is available here: [https://www.terraform.io/docs/commands/fmt.html](https://www.terraform.io/docs/commands/fmt.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Validating the code syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing a Terraform configuration, it is important to be able to validate
    the syntax of the code we are writing before executing it, or even before archiving
    it in a Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: We will see in this recipe how, by using the Terraform client tool, we can check
    the syntax of a Terraform configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will start with the following Terraform configuration,
    which is written in a `main.tf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/783a84c0-e179-4f74-a564-ddebe7b28292.png)'
  prefs: []
  type: TYPE_IMG
- en: What we notice in the preceding code is that the declaration of the `environment`
    variable is missing.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To validate our Terraform configuration syntax, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, initialize the Terraform context by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, validate the code by executing the `validate` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, we initialize the Terraform context by executing the `terraform
    init` command.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we perform a check of the code validity by executing the `terraform validate`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the execution of this command, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/578a737b-e1c6-4be0-a94c-41d563a15810.png)'
  prefs: []
  type: TYPE_IMG
- en: We see that there is one syntax error in the Terraform configuration, which
    indicates that we call the variable `var.environment`, which has not been declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we correct the code and run the `terraform validate` command again until
    we have no more errors, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3b32978-0324-438a-889c-343cfa51fc81.png)'
  prefs: []
  type: TYPE_IMG
- en: The output shows us that the Terraform configuration is valid.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This validation command is useful in local development mode, but also in code
    integration in a **continuous integration** (**CI**) pipeline, so as to not execute
    the `terraform plan` command if the `terraform validate` command returns syntax
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following PowerShell code shows an example of return code following the
    execution of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The PowerShell variable, `$LASTEXITCODE`, which is native to PowerShell, will
    return `0` if there is no error, otherwise `1` if there is an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to get the output of this command in JSON format by adding
    the `-json` option to this command, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9daeb7f4-ade6-45cb-8a19-4874d2557443.png)'
  prefs: []
  type: TYPE_IMG
- en: The JSON result can then be parsed with third-party tools such as **jq** and
    used in your workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful, however. This command only allows validation of the syntax of the
    configuration with, for example, the correct use of functions, variables, and
    object types, and not validation of the execution of the result of the Terraform
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: If the Terraform configuration contains a `backend` block, then, for this validation
    of the configuration, we don't need to connect to this state file. We can add
    the `-backend=false` option to the `terraform init` command.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if the execution of this Terraform configuration requires variables
    passed with the `-var` argument, or with the `-var-file` option, you cannot use
    this command. Instead, use the `terraform plan` command, which performs validation
    during its execution.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `terraform validate` command documentation is available here: [https://www.terraform.io/docs/commands/validate.html](https://www.terraform.io/docs/commands/validate.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Destroying infrastructure resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have said many times in this book, IaC allows the rapid provisioning of
    infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of IaC is that it allows a quick build and the cleaning up
    of resources that have been provisioned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, we may need to clean up an infrastructure for different reasons. Here
    are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: We destroy an infrastructure with a view to rebuild it better in accordance
    with new specifications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We provide an infrastructure that is called on demand, which means it is temporary
    for a specific need (such as to test a new feature or a new branch of the application).
    And this infrastructure must be capable of being built and destroyed quickly and
    automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to remove an unused infrastructure and, at the same time, no longer
    pay for it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will discuss how to destroy an infrastructure that has been
    provisioned with Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, we are going to provide an infrastructure in Azure that is composed
    of an Azure App Service.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this we use the Terraform configuration, which can be found here: [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP04/sample-app](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP04/sample-app)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to provision it, we execute the basic Terraform workflow with the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At the end of its execution, we have a Resource Group, a Service Plan, an App
    Service, and an Application Insights resource in Azure.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this recipe is to completely destroy this infrastructure using Terraform
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For clean resources with Terraform, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, initialize the Terraform context by running the `init` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to clean the resources, we execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning of its execution, this command displays all resources that
    will be destroyed and asks for confirmation to delete the resources. Validation
    is then confirmed by typing the word `yes`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 2*, we are destroying all the provisioned resources by executing the
    `terraform destroy` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the extracted output of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a994fb5-d844-4078-a913-a71f6bdb2de5.png)'
  prefs: []
  type: TYPE_IMG
- en: At the end of the command execution, Terraform reports that the resources have
    been successfully destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have studied how to destroy all the resources that have been
    described and provisioned with a Terraform configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `terraform destroy` command deletes all the resources tracked in the Terraform
    state file, it is important to break the Terraform configuration by separating
    it into multiple state files to reduce the room for error when changing the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to destroy a single resource and not all the resources tracked
    in the state file, you can add the `-target` option to the `terraform destroy`
    command, which allows you to target the resource to be deleted. The following
    is an example of this command with the `target` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, only the Application Insights resource is destroyed. For more
    details, read the pertinent documentation here: [https://www.terraform.io/docs/commands/plan.html#resource-targeting](https://www.terraform.io/docs/commands/plan.html#resource-targeting)'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the targeting mechanism should only be used as a last resort. In an
    ideal scenario, the configuration stays in sync with the state file (as applied
    without any extra `target` flags). The risk of executing a targeted apply or destroy
    operation is that other contributors may miss the context and, more importantly,
    it becomes much more difficult to apply further changes after changing the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, if the `terraform plan` command in this Terraform configuration
    requires the `-var-file` option to specify or override values to the variables,
    then the same options must also be added to the `terraform destroy` command.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, all options that apply to the `terraform plan` command also apply
    to the `terraform destroy` command.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The documentation pertaining to the `terraform destroy` command is available
    here: [https://www.terraform.io/docs/commands/destroy.html](https://www.terraform.io/docs/commands/destroy.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The documentation pertaining to addressing the resource target is available
    here: [https://www.terraform.io/docs/internals/resource-addressing.html](https://www.terraform.io/docs/internals/resource-addressing.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using workspaces for managing environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Terraform, there is the concept of **workspaces**, which enables the same
    Terraform configuration to be used in order to build multiple environments.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these configurations will be written to a different Terraform state file
    and will thus be isolated from the other configurations. Workspaces can be used
    to create several environments of our infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will study the use of Terraform workspaces in the Terraform
    configuration, with the execution of Terraform commands.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of this recipe is for an application to create a Resource Group
    for each of its environments (`dev` and `prod`).
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the Terraform configuration, no prerequisites are necessary. We will
    see it in the steps of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Terraform configuration for this recipe is available here: [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP04/workspaces](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP04/workspaces)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To manage a Terraform workspace, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a new `main.tf` file, we write the following Terraform configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In a command terminal, we navigate into the folder that contains this Terraform
    configuration and execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To provision the `dev` environment, we run the basic commands of the Terraform
    workflow, which are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we execute the `workspace new` command with the name of the production
    workspace to be created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish and provision the `prod` environment, we execute the basic commands
    of the Terraform workflow production, which are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, in the Terraform configuration we wrote, we provide a Resource
    Group in Azure that will have a name composed of an `RG-APP` prefix and a dynamic
    suffix, `terraform.workspace`, which will be the name of the workspace we are
    going to create.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2*, we create the workspace that corresponds to the `dev` environment,
    and for this we use the `terraform workspace new` command followed by the workspace
    name (in this case, `dev`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once created, Terraform is automatically placed in this workspace, as you can
    see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccda3ae2-3ba8-47ca-ba3b-2a30fd1cd789.png)'
  prefs: []
  type: TYPE_IMG
- en: After we've created the workspace, we just execute the basic commands of the
    Terraform workflow, which we do in *step 3*.
  prefs: []
  type: TYPE_NORMAL
- en: Note that here we have added the `-out` option to the `terraform plan` command
    to save the result of the plan in the `outdev.tfplan` file. Then, to apply the
    changes, we specifically add this file as an argument to the `terraform apply`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Then, to provision the `prod` environment, we repeat exactly the same *steps
    2* and *3*, but this time creating a workspace called `prod`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the execution of all these steps, we can see in the Azure portal
    that we have our two Resource Groups that contain in the suffix the name of their
    workspace, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3fd1d118-f30b-4462-a496-0c947eea9842.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition, we also notice two Terraform state files, one for each workspace,
    which were created automatically, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff0cf20e-0607-400f-92a5-a87dd02d6544.png)'
  prefs: []
  type: TYPE_IMG
- en: In this screenshot, we can see two `terraform.tfstate` files, one in the `dev`
    directory and another in the `prod` directory.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In any Terraform configuration execution, there is a default workspace that
    only names `default`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to see the list of workspaces in our code by executing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the execution of this command in the case of
    our recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e749ef2-3ea1-4198-aae7-65c914672b05.png)'
  prefs: []
  type: TYPE_IMG
- en: We can clearly see our `dev` and `prod` workspace, and that the current workspace
    is `prod` (marked with an `*` in front of its name).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to switch to another workspace, execute the `terraform workspace
    select` command, followed by the name of the workspace to be selected; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can also delete a workspace by executing the `terraform workspace
    delete` command, followed by the name of the workspace to be deleted; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Be careful when deleting a workspace that it does not delete the associated
    resources. That's why, in order to delete a workspace, you must first delete the
    resources provided by that workspace using the `terraform destroy` command. Otherwise,
    if this operation is not carried out, it will no longer be possible to manage
    these resources with Terraform because the Terraform state file of this workspace
    will have been deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, by default, it is not possible to delete a workspace whose state
    file is not empty. However, we can force the destruction of this workspace by
    adding the `-force` option to the `terraform workspace delete -force` command, as
    documented here: [https://www.terraform.io/docs/commands/workspace/delete.html](https://www.terraform.io/docs/commands/workspace/delete.html).'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The general documentation for workspaces is available here: [https://www.terraform.io/docs/state/workspaces.html](https://www.terraform.io/docs/state/workspaces.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The CLI documentation for the `terraform workspace` command is available here:
    [https://www.terraform.io/docs/commands/workspace/index.html](https://www.terraform.io/docs/commands/workspace/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Read this blog post for a more complete use of workspaces: [https://www.colinsalmcorner.com/terraform-all-the-things-with-vsts/](https://www.colinsalmcorner.com/terraform-all-the-things-with-vsts/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing existing resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we have seen the normal use of Terraform, which is to write
    a Terraform configuration that is going to be executed and applied by Terraform.
    This execution will provision or apply changes to an infrastructure that will
    be reflected in the Terraform state file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In certain scenarios, however, it may be necessary to import resources that
    have already been provisioned into the Terraform state file. Examples of such
    scenarios include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Resources have been provisioned manually (or by scripts) and now it is desired
    that their configuration is in the Terraform configuration and in the state file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Terraform state file that contains the configuration of an infrastructure
    has been corrupted or deleted and regeneration is desirable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will discuss how, with the assistance of Terraform commands,
    we can import the configuration of resources that have already been provisioned
    into the Terraform state file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will use the following Terraform configuration, which we
    have already written, in order to provision a Resource Group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is also available here: [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP04/import](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP04/import)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, in the Azure portal, we have created this Resource Group called `RG-APP-IMPORT`
    manually, as explained in the pertinent documentation: [https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/manage-resource-groups-portal](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/manage-resource-groups-portal)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows this Resource Group in Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a6e02a7-b2d7-4d33-b4e0-ba3725a77790.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, if we run Terraform on this code, the `terraform apply` command
    will try to create this Resource Group. It will fail and return the error that
    the Resource Group already exists and cannot be created, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e5454a5-f419-4ab8-a1c4-3b7c5f886dda.png)'
  prefs: []
  type: TYPE_IMG
- en: It is therefore necessary to use a resource import directly in the Terraform
    state file.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will perform an import operation with one Resource Group
    in Azure. But it is important to note that each Terraform provider has different
    target parameters for the `import` command.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this recipe is to import the configuration of this Resource Group
    in the Terraform state file corresponding to our Terraform configuration.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We initialize the Terraform context by executing the `init` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we execute the `terraform import` command as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, the Terraform context is initialized with the `terraform init` command.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in *step 2*, we execute the `terraform import` command, which takes the
    reference of the Terraform resource as the first parameter and the Azure identifier
    of the Resource Group as the second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of the execution of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29adb1ae-4057-41bb-9a35-5b81f359fd5f.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the resource was indeed imported into the Terraform state file.
  prefs: []
  type: TYPE_NORMAL
- en: We now have the Terraform configuration, the Terraform state file, and the resources
    in Azure up to date.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To check the execution of the resource import, we execute the `terraform plan`
    command and we have to have a situation where no changes are required, as can
    be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0478c8c-f7ce-42ba-9fbd-dcc9a4c924a8.png)'
  prefs: []
  type: TYPE_IMG
- en: If you are provisioning resources in Azure, there are rather interesting tools
    that generate the Terraform configuration and the corresponding Terraform state file
    from Azure resources that have already been created. This open source **Az2Tf**
    tool is available at [https://github.com/andyt530/py-az2tf](https://github.com/andyt530/py-az2tf).
    Alternatively, there is **TerraCognita**, which is available at [https://github.com/cycloidio/terracognita/blob/master/README.md](https://github.com/cycloidio/terracognita/blob/master/README.md).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The documentation pertaining to the `import` command is available here: [https://www.terraform.io/docs/commands/import.html](https://www.terraform.io/docs/commands/import.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Exporting the output in JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed in the *Looping over object collections* recipe of [Chapter 3](d019fed0-6c22-4da8-9796-58d45feafa2c.xhtml),
    *Building Dynamic Environments with Terraform*, the use of Terraform's outputs
    that allow you to have output values for the execution of the Terraform configuration.
    Indeed, we have seen how to declare an output in the Terraform configuration,
    and we learned that these outputs and their values were displayed at the end of
    the execution of the `terraform apply` command.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of these outputs is that they can be retrieved by a program and
    thus be used for another operation; for example, in a CI/CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how the values of the outputs can be retrieved in
    JSON format so that they can be used in an external program.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will use only the Terraform configuration that we studied
    in [Chapter 3](d019fed0-6c22-4da8-9796-58d45feafa2c.xhtml), *Building Dynamic
    Environments with Terraform*, and whose sources can be found here: [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP03/list_map](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP03/list_map)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code, we add another output that returns the list of App Service URLs
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To exploit the values of the output, we need to use a tool that allows us to
    work on JSON. For this, you can use any framework and library according to your
    scripting languages. In this recipe, we will use **jq**, which is a free tool
    that allows you to easily manipulate JSON on the command line. The documentation
    on jq is available here [https://stedolan.github.io/jq/](https://stedolan.github.io/jq/).
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this recipe is to provision two Azure App Services using Terraform
    configuration and then, with a script, perform a response check of the URL of
    the first App Service.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to use the output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the Terraform workflow with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the `terraform output` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to retrieve the URL of the created App Service, we execute the following
    command in the command terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, we execute the basic commands of the Terraform workflow. After
    executing the `terraform apply` command, the command displays the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in *step 2*, we visualize the output of this Terraform configuration
    more clearly by executing the `terraform output` command, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2306f84-2a90-4993-8b18-68bd678108cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, we can see that this command returns the two outputs
    declared in the code, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app_service_names`: This returns a list of App Service names provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app_service_urls`: This returns a list of the URLs of provisioned App Services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, in *step 3*, we run a script that checks the URL of the `webappdemobook1` App
    Service. In the first line of this script, we execute the `terraform output -json`
    command, which enables the result of the output to be returned in JSON format,
    as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b346db5e-0c06-4f63-b832-84082452c66d.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, with this result in JSON, we use the **jq** tool on it by retrieving the
    URL of the `webappdemobook1` App Service. The returned URL is put in a variable
    called `urlwebapp1`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the second line of this script, we use the `curl` command on this URL
    by passing options to return only the HTTP header of this URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the execution of this script is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2aee7893-7dcd-45e0-9d0a-ef97c73b36ff.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that the result of the check is `OK`, with a status code of `200`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we learned how to retrieve all the outputs of a Terraform configuration.
    It is also possible to retrieve the value of a particular output by executing
    the `terraform output <output name>` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we could have executed the `app_service_urls` command to display
    the value of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the execution of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69cecede-2901-4166-8eba-3f7d2edf43e9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we would run the following command to check the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We see in this script that the command used is `terraform output app_service_urls
    -json`, which is more simplistic than `$(terraform output -json | jq -r .app_service_urls.value.webappdemobook1)`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `terraform output` command documentation is available here: [https://www.terraform.io/docs/commands/output.html](https://www.terraform.io/docs/commands/output.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'jq''s website can be found here: [https://stedolan.github.io/jq/](https://stedolan.github.io/jq/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tainting resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, in the *Destroying infrastructure resources* recipe, we learned how
    to destroy resources that have been provisioned with Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: However, in certain situations, you may need to destroy a particular resource
    in order to rebuild it immediately. Examples of such situations may include modifications
    that have been made manually on that resource.
  prefs: []
  type: TYPE_NORMAL
- en: To destroy and rebuild a resource, you could perform the `terraform destroy
    -target <resource>` command, followed by the `apply` command. However, the problem
    is that between the `destroy` and `apply` commands, there may be other changes
    in the Terraform configuration that will be applied that are not desired.
  prefs: []
  type: TYPE_NORMAL
- en: So, in this recipe, we will see how to perform this operation using the Terraform
    notion of tainting.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to apply this recipe, we have first provisioned the infrastructure
    composed of a Resource Group, a Service Plan, an App Service, and an Application
    Insights resource. The Terraform configuration used for this provisioning can
    be found here: [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP04/sample-app](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP04/sample-app).
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this recipe is to destroy and then rebuild the App Service in a
    single operation using the `taint` command of Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To apply the `taint` operation, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `terraform init` command to initialize the context.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, execute the `terraform taint` command to flag the resource as *tainted*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to rebuild the App Service, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, we execute the `terraform init` command to initialize the context.
    Then, in *step 2*, we execute the `terraform taint` command to flag the `azurerm_app_service.app`
    resource as tainted; that is, to be destroyed and rebuilt.
  prefs: []
  type: TYPE_NORMAL
- en: This command does not affect the resource itself, but only marks it as tainted
    in the Terraform state file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the result of the `taint` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ce81d8d-4958-4a7b-a8ba-6961c6f963f5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, in *step 3*, we execute the `terraform apply` command and, when it
    is executed, we can see that Terraform will delete and then recreate the Azure
    App Service, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f305383a-c0ba-4eb6-9fd5-460451b2046b.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see in the preceding screenshot that Terraform destroys the App Service
    resource and then recreates it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To go further, we can display in the terminal the status of this resource flagged
    in the Terraform state file by executing the `terraform state show` command, which
    displays the contents of the state file in the command terminal (documented here: [https://www.terraform.io/docs/commands/state/show.html](https://www.terraform.io/docs/commands/state/show.html))
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the result of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e21ebdd-972c-4e33-8d09-8271bc5aa1c8.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the resource App Service has the flag `tainted`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have used the `terraform state` command to display the contents of the state,
    since it is strongly discouraged to read and modify the state file manually, as
    documented here: [https://www.terraform.io/docs/state/index.html#inspection-and-modification](https://www.terraform.io/docs/state/index.html#inspection-and-modification)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, in order to cancel the taint flag applied with the `terraform taint`
    command, we can execute the inverse command, which is `terraform untaint`. This
    command can be executed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, if we execute the `terraform plan` command, we can see that there is
    no change, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8ec7081-f7ac-4c32-a25f-652d9e5ebb4d.png)'
  prefs: []
  type: TYPE_IMG
- en: We see in this screenshot that the `untaint` command has cancelled the effect
    of the `taint` command and, during the execution of the `plan` command, no changes
    will be applied to the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `terraform taint` command documentation is available here: [https://www.terraform.io/docs/commands/taint.html](https://www.terraform.io/docs/commands/taint.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `terraform untaint` command documentation is available here: [https://www.terraform.io/docs/commands/untaint.html](https://www.terraform.io/docs/commands/untaint.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `terraform state` command documentation is available here: [https://www.terraform.io/docs/commands/state/index.html](https://www.terraform.io/docs/commands/state/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An article that explains the `taint` and `untaint` commands really well can
    be found here: [https://www.devopsschool.com/blog/terraform-taint-and-untaint-explained-with-example-programs-and-tutorials/](https://www.devopsschool.com/blog/terraform-taint-and-untaint-explained-with-example-programs-and-tutorials/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating the graph dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the interesting features of Terraform is the ability to generate a dependency
    graph of the resource dependencies mentioned in the Terraform configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to generate and visualize this dependency graph.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we need to use a third-party drawing generation tool called
    **Graphviz**, which is available for download at [https://graphviz.gitlab.io/download/](https://graphviz.gitlab.io/download/).
    You will need to download and install the package corresponding to your operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, as an example, we will take the Terraform configuration available
    at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP04/sample-app.](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP04/sample-app)
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To generate the graph dependencies, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the `terraform graph` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Open the file explorer and navigate inside the folder that contains the Terraform
    configuration and open the file called `graph.svg`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, we will execute the `terraform graph` command. Then, we send the
    result of this graph command to the `dot` utility that was previously installed
    with Graphviz. This `dot` utility will generate a `graph.svg` file, which contains
    the graphical representation of the Terraform configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 2*, we open the `graph.svg` file and we see the dependency graph as
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9a04354-3503-42be-8da6-33b7955c9243.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we can see the dependencies between variables, resources,
    and the provider.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `terraform graph` command documentation is available here: [https://www.terraform.io/docs/commands/graph.html](https://www.terraform.io/docs/commands/graph.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Documentation relating to Graphviz is available here: [https://graphviz.gitlab.io/](https://graphviz.gitlab.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An excellent video about the generation of graph dependencies can be found
    here: [https://techsnips.io/snips/how-to-use-graphviz-with-terraform-to-visualize-your-infrastructure/](https://techsnips.io/snips/how-to-use-graphviz-with-terraform-to-visualize-your-infrastructure/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging the Terraform execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we execute Terraform commands, the display output of the console is quite
    simple and clear.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will study how to activate the debug mode in Terraform, which
    will allow us to display more information about its execution.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use the Terraform configuration available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP04/sample-app.](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP04/sample-app.)
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, for the purposes of this demonstration, we will run it on a Windows
    operating system, but the operation is exactly the same on other operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To activate the debug on Terraform, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the PowerShell command-line terminal, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can execute the Terraform workflow commands with display logs activated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, we create a Terraform environment variable, `TF_LOG`, which enables
    Terraform's verbose mode to be activated, indicating that we want to see all traces
    of Terraform's execution displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Here, in this recipe, we used the `$env` command to set this environment variable
    because we are working on Windows. You can, of course, do the same on other operating
    systems with the correct syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in *step 2*, we execute the commands of the Terraform workflow and we
    can see in the output all traces of this execution, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f868b821-4860-4277-a9aa-f805e2031a1d.png)'
  prefs: []
  type: TYPE_IMG
- en: In this screenshot, which is an extract of the execution of Terraform, you can
    see all the steps involved in the execution of Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of having all these traces displayed in the console output, it is also
    possible to save them in a file.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, just create a second environment variable, `TF_LOG_PATH`, which
    will contain as a value the path to the log file. Indeed, the logs are often very
    verbose and difficult to read on the console output. That's why we prefer that
    the output of the logs is written in a file that can be read more easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, to disable these traces, the `TF_LOG` environment variable must be
    emptied by assigning it an empty value as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The documentation on the Terraform debug is available here: [https://www.terraform.io/docs/internals/debugging.html](https://www.terraform.io/docs/internals/debugging.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Documentation on Terraform''s environment variables is available here: [https://www.terraform.io/docs/commands/environment-variables.html](https://www.terraform.io/docs/commands/environment-variables.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
