- en: Provisioning Azure Infrastructure with Terraform
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Terraform 配置 Azure 基础设施
- en: Terraform contains a multitude of providers that enable the provisioning of
    various types of infrastructure, whether in the cloud or on-premise.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 包含多种提供者，可以实现各种类型基础设施的配置，无论是在云端还是本地。
- en: In the previous chapters of this book, we have studied the basic concepts of
    the Terraform language, as well as the main Terraform commands line and we have
    seen the sharing of Terraform configuration using modules. In addition, all the
    recipes we have seen in the previous chapters are generic and can be used by all
    Terraform providers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前几章中，我们已经学习了 Terraform 语言的基本概念，以及主要的 Terraform 命令行，并且我们也看到了如何通过模块共享 Terraform
    配置。此外，我们在前面章节中看到的所有示例都是通用的，适用于所有 Terraform 提供者。
- en: In this chapter, we will focus on using Terraform to provision a cloud infrastructure
    in Azure. We will start with its integration into Azure Cloud Shell, its secure
    authentication, and the protection of the Terraform state file in an Azure storage.
    You will learn how to run ARM templates and Azure CLI scripts with Terraform and
    how to retrieve the Azure resource list with Terraform. Then we'll look at how
    to protect sensitive data in Azure Key Vault using Terraform. We will write two
    case studies in Azure, with the first showing the provisioning and configuration
    of an IaaS infrastructure consisting of VMs, and the second showing the provisioning
    of a PaaS infrastructure in Azure. Finally, we will go further with the generation
    of Terraform configuration from an already existing infrastructure.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍如何使用 Terraform 在 Azure 中配置云基础设施。我们将从其在 Azure Cloud Shell 中的集成、其安全认证、以及在
    Azure 存储中保护 Terraform 状态文件开始。你将学习如何在 Terraform 中运行 ARM 模板和 Azure CLI 脚本，并且如何通过
    Terraform 获取 Azure 资源列表。接着，我们将探讨如何通过 Terraform 在 Azure Key Vault 中保护敏感数据。我们将以两个案例研究为例，第一个展示了包含虚拟机的
    IaaS 基础设施的配置，第二个展示了 Azure 中 PaaS 基础设施的配置。最后，我们将进一步探讨如何从现有基础设施生成 Terraform 配置。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将覆盖以下教程：
- en: Using Terraform in Azure Cloud Shell
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Azure Cloud Shell 中使用 Terraform
- en: Protecting the Azure credential provider
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护 Azure 凭据提供者
- en: Protecting the state file in the Azure remote backend
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Azure 远程后端保护状态文件
- en: Executing ARM templates in Terraform
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Terraform 中执行 ARM 模板
- en: Executing Azure CLI commands in Terraform
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Terraform 中执行 Azure CLI 命令
- en: Using Azure Key Vault with Terraform to protect secrets
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Azure Key Vault 和 Terraform 来保护机密
- en: Getting a list of Azure resources in Terraform
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 Azure 资源列表的 Terraform 配置
- en: Provisioning and configuring an Azure VM with Terraform
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Terraform 配置和管理 Azure 虚拟机
- en: Building Azure serverless infrastructure with Terraform
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Terraform 构建 Azure 无服务器基础设施
- en: Generating a Terraform configuration for existing Azure infrastructure
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为现有的 Azure 基础设施生成 Terraform 配置
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To apply the recipes in this chapter, you must have an Azure subscription. If
    you don't have one, you can create an Azure account for free at this site: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用本章中的教程，你必须拥有 Azure 订阅。如果没有，你可以在此网站免费创建一个 Azure 帐户：[https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)
- en: The complete source code for this chapter is available here: [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可以在此处获取：[https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06)
- en: Check out the following video to see the Code in Action: [https://bit.ly/2ZmEcnJ](https://bit.ly/2ZmEcnJ)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://bit.ly/2ZmEcnJ](https://bit.ly/2ZmEcnJ)
- en: Using Terraform in Azure Cloud Shell
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Azure Cloud Shell 中使用 Terraform
- en: In [Chapter 1](027d2973-b820-4fba-b43e-ee2747a97e6a.xhtml), *Setting Up the
    Terraform Environment*, of this book, we studied the steps involved in installing
    Terraform on a local machine.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的[第1章](027d2973-b820-4fba-b43e-ee2747a97e6a.xhtml)，*设置 Terraform 环境*，我们学习了在本地机器上安装
    Terraform 的步骤。
- en: In the Azure Shell console, known as **Azure Cloud Shell**, Microsoft has integrated
    Terraform in the list of tools that are installed by default.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure Shell 控制台中，微软已将 Terraform 集成到默认安装的工具列表中，该控制台被称为**Azure Cloud Shell**。
- en: In this recipe, we will see how to write a Terraform configuration and use Terraform
    in Azure Cloud Shell.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何编写 Terraform 配置并在 Azure Cloud Shell 中使用 Terraform。
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The prerequisite for this recipe is to have an Azure subscription and to be
    connected to this subscription via the Azure portal, which is accessible here: [https://portal.azure.com/](https://portal.azure.com/)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的前提是拥有 Azure 订阅，并通过 Azure 门户连接到该订阅，访问地址为：[https://portal.azure.com/](https://portal.azure.com/)
- en: Note that this prerequisite applies to all recipes in this chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个前提条件适用于本章的所有教程。
- en: In addition, you need to associate your Cloud Shell with an existing Azure Storage
    Account or create a new one, as explained in the following documentation: [https://docs.microsoft.com/en-us/azure/cloud-shell/persisting-shell-storage](https://docs.microsoft.com/en-us/azure/cloud-shell/persisting-shell-storage).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您需要将 Cloud Shell 与现有的 Azure 存储帐户关联，或根据以下文档创建一个新的存储帐户：[https://docs.microsoft.com/en-us/azure/cloud-shell/persisting-shell-storage](https://docs.microsoft.com/en-us/azure/cloud-shell/persisting-shell-storage)。
- en: How to do it…
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何执行…
- en: 'In order to use Terraform in Azure Cloud Shell, perform the following steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Azure Cloud Shell 中使用 Terraform，请执行以下步骤：
- en: 'In the Azure portal, open Azure Cloud Shell by clicking the Cloud Shell button
    in the top menu, as shown in the following screenshot:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Azure 门户中，通过点击顶部菜单中的 Cloud Shell 按钮打开 Azure Cloud Shell，如下图所示：
- en: '![](img/0655579d-36a8-4450-b465-49cbe7de0ad9.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0655579d-36a8-4450-b465-49cbe7de0ad9.png)'
- en: 'Inside the Cloud Shell panel, in the top menu, in the dropdown, choose Bash
    mode:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Cloud Shell 面板中，在顶部菜单的下拉框中选择 Bash 模式：
- en: '![](img/901451f8-5167-4550-8189-fdb7dded47de.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/901451f8-5167-4550-8189-fdb7dded47de.png)'
- en: 'In the Cloud Shell terminal, create a new folder, `demotf`, inside the default `clouddrive` folder
    by executing the following command:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Cloud Shell 终端中，通过执行以下命令，在默认的`clouddrive`文件夹内创建一个新的`demotf`文件夹：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Inside this new folder, enter the `cd clouddrive/demotf` command.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新文件夹中，输入`cd clouddrive/demotf`命令。
- en: To write a Terraform configuration inside an integrated Visual Studio Code instance,
    execute the `code` command.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在集成的 Visual Studio Code 实例中编写 Terraform 配置，执行`code`命令。
- en: 'In the editor, in the opened blank page, write the Terraform configuration
    with the following sample code:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，在打开的空白页面中，编写以下示例代码的 Terraform 配置：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Save this file by using the *Ctrl* + *S* shortcut and name this file `main.tf`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Ctrl* + *S*快捷键保存此文件，并将其命名为`main.tf`。
- en: 'Finally, to apply this Terraform configuration to the Cloud Shell terminal,
    execute the classical Terraform workflow as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，要将此 Terraform 配置应用到 Cloud Shell 终端，按照以下经典的 Terraform 工作流执行：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works…
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we used the integrated environment of Azure Cloud Shell, which
    consists of a command-line terminal that we chose to use in Bash mode. In addition,
    in *steps 5* and *6*, we used the built-in Visual Studio Code editor, using the
    `code` command, to write a Terraform configuration, which also has syntax highlighting
    for Terraform files. And finally, in *step 7*, we used the Terraform client, which
    is already installed in this Cloud Shell environment to provision our infrastructure
    with the execution of the Terraform workflow commands.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们使用了 Azure Cloud Shell 的集成环境，其中包括一个命令行终端，我们选择使用 Bash 模式。此外，在*步骤 5*和*步骤
    6*中，我们使用了内置的 Visual Studio Code 编辑器，使用`code`命令编写了 Terraform 配置，它还为 Terraform 文件提供了语法高亮显示。最后，在*步骤
    7*中，我们使用了已安装在 Cloud Shell 环境中的 Terraform 客户端，通过执行 Terraform 工作流命令来部署我们的基础设施。
- en: 'The following screenshot shows Azure Cloud Shell with Terraform execution:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了带有 Terraform 执行的 Azure Cloud Shell：
- en: '![](img/780438d1-4ed3-4ea2-9053-e52b8de19f69.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/780438d1-4ed3-4ea2-9053-e52b8de19f69.png)'
- en: We can see in the preceding screenshot the top panel with the integrated Visual
    Studio Code editor, and, in the bottom panel, the command line with the execution
    of the Terraform command.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在上面的截图中看到，上面面板是集成的 Visual Studio Code 编辑器，下面面板是执行 Terraform 命令的命令行。
- en: There's more…
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'For this recipe, we chose the option to edit the Terraform files directly in
    Visual Studio Code, which is in Cloud Shell, but the following alternative options
    are available:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，我们选择了直接在 Cloud Shell 中的 Visual Studio Code 编辑 Terraform 文件，但也有以下可选方案：
- en: The Terraform files could be created and edited using the **Vim** tool (Linux
    editor: [https://www.linux.com/training-tutorials/vim-101-beginners-guide-vim/](https://www.linux.com/training-tutorials/vim-101-beginners-guide-vim/)),
    which is built into Cloud Shell.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform 文件可以使用**Vim**工具（Linux 编辑器：[https://www.linux.com/training-tutorials/vim-101-beginners-guide-vim/](https://www.linux.com/training-tutorials/vim-101-beginners-guide-vim/)）创建和编辑，该工具已内置于
    Cloud Shell。
- en: We could also have edited the Terraform files locally on our machine and then
    copied them to the Azure Storage service that is connected to Azure Cloud Shell.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也可以在本地计算机上编辑 Terraform 文件，然后将它们复制到与 Azure Cloud Shell 连接的 Azure 存储服务中。
- en: If the files are stored in a Git repository, we could also have cloned the repository
    directly into the Cloud Shell storage by running a `git clone` command in the
    Cloud Shell command-line terminal.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件存储在 Git 仓库中，我们也可以通过在 Cloud Shell 命令行终端运行 `git clone` 命令，将仓库直接克隆到 Cloud Shell
    存储中。
- en: Also, regarding Terraform's authentication to perform actions in Azure, we did
    not take any action because Azure Cloud Shell allows direct authentication to
    our Azure subscriptions and Terraform, which is in Cloud Shell, automatically
    inherits that authentication.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，关于 Terraform 在 Azure 中执行操作的身份验证，我们没有采取任何措施，因为 Azure Cloud Shell 允许直接对我们的
    Azure 订阅和 Terraform 进行身份验证，而在 Cloud Shell 中的 Terraform 会自动继承该身份验证。
- en: 'On the other hand, if you have several subscriptions, prior to executing the
    Terraform workflow, you have to choose the subscription target by executing the
    following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你有多个订阅，在执行 Terraform 工作流之前，你必须通过执行以下命令来选择订阅目标：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This chosen subscription then becomes the subscription by default during execution.
    Refer to the documentation at [https://docs.microsoft.com/en-us/cli/azure/account?view=azure-cli-latest#az-account-set](https://docs.microsoft.com/en-us/cli/azure/account?view=azure-cli-latest#az-account-set).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选定的订阅将在执行过程中成为默认订阅。请参考文档：[https://docs.microsoft.com/en-us/cli/azure/account?view=azure-cli-latest#az-account-set](https://docs.microsoft.com/en-us/cli/azure/account?view=azure-cli-latest#az-account-set)。
- en: Regarding the version of Terraform that is installed on the Cloud Shell, in
    general, it is the latest public version, which you can check by running the `terraform
    --version` command. You need to check that your Terraform configuration is compatible
    with this version before executing.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Cloud Shell 上安装的 Terraform 版本，通常是最新的公开版本，你可以通过运行 `terraform --version` 命令来检查。你需要在执行之前检查你的
    Terraform 配置是否与此版本兼容。
- en: Finally, as regards the recommended use of Azure Cloud Shell for Terraform,
    it can only be used for development and testing. It cannot be integrated into
    a CI/CD pipeline and uses your personal permissions on Azure to provision resources.
    For this reason, in the next recipe, we will look at how to securely authenticate
    Terraform to Azure.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关于推荐使用 Azure Cloud Shell 进行 Terraform 操作，它仅限于开发和测试使用。它不能集成到 CI/CD 管道中，并且使用你在
    Azure 上的个人权限来配置资源。因此，在下一个食谱中，我们将研究如何安全地将 Terraform 认证到 Azure。
- en: See also
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: Refer to this blog post, which also shows the use of Terraform in Azure Cloud
    Shell: [https://cloudskills.io/blog/terraform-azure-01](https://cloudskills.io/blog/terraform-azure-01)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考这篇博客文章，其中也展示了在 Azure Cloud Shell 中使用 Terraform：[https://cloudskills.io/blog/terraform-azure-01](https://cloudskills.io/blog/terraform-azure-01)
- en: Documentation that explains the use of Azure Cloud Shell: [https://docs.microsoft.com/en-us/azure/cloud-shell/using-cloud-shell-editor](https://docs.microsoft.com/en-us/azure/cloud-shell/using-cloud-shell-editor)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释如何使用 Azure Cloud Shell 的文档：[https://docs.microsoft.com/en-us/azure/cloud-shell/using-cloud-shell-editor](https://docs.microsoft.com/en-us/azure/cloud-shell/using-cloud-shell-editor)
- en: A tutorial that shows how to use and configure locally installed Visual Studio
    Code to execute a Terraform configuration in Azure Cloud Shell: [https://docs.microsoft.com/en-us/azure/developer/terraform/configure-vs-code-extension-for-terraform](https://docs.microsoft.com/en-us/azure/developer/terraform/configure-vs-code-extension-for-terraform)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个教程，展示了如何使用和配置本地安装的 Visual Studio Code，以便在 Azure Cloud Shell 中执行 Terraform
    配置：[https://docs.microsoft.com/en-us/azure/developer/terraform/configure-vs-code-extension-for-terraform](https://docs.microsoft.com/en-us/azure/developer/terraform/configure-vs-code-extension-for-terraform)
- en: Protecting the Azure credential provider
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护 Azure 凭证提供者
- en: In order for the Terraform Azure provider to provision and manipulate resources
    in Azure, the provider must authenticate in Azure using an Azure account and that
    account must have the correct authorizations.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Terraform Azure 提供者能够在 Azure 中配置和操作资源，提供者必须使用 Azure 账户进行身份验证，并且该账户必须具有正确的授权。
- en: In the previous recipe, we studied how to automatically authenticate the Terraform
    context in Azure Cloud Shell with our personal account and permissions. However,
    in corporate projects, as well as in production, it is very bad practice to use
    your personal account as this could expire, be deleted, or, even worse, be misused.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的步骤中，我们学习了如何使用个人账户和权限在Azure Cloud Shell中自动认证Terraform上下文。然而，在企业项目和生产环境中，使用个人账户是非常不推荐的做法，因为个人账户可能会过期、被删除，甚至更糟糕的是被滥用。
- en: This is why one of the options we have when running Terraform in Azure is to
    use an **App Registration** account (also known as **Service Principal**) that
    is not linked to a physical person.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在Azure中运行Terraform时的选项之一，使用**应用注册**账户（也称为**服务主体**），该账户不与任何物理人挂钩。
- en: In this recipe, we will first study the creation of this Service Principal and
    then we will see how to use it securely in order to run a Terraform configuration.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们首先学习如何创建服务主体，然后我们将看到如何安全地使用它来运行Terraform配置。
- en: Getting ready
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To apply the first part of this recipe, you must have user account creation
    permissions in Azure Active Directory. Moreover, to create this Service Principal,
    we will do it using the command line with the **az cli** tool, documentation relating
    to which is available at [https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用此配方的第一部分，你必须拥有在Azure Active Directory中创建用户账户的权限。此外，要创建此服务主体，我们将使用命令行工具**az
    cli**来操作，相关文档可参考[https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest)。
- en: 'In addition, we need to retrieve our ID of the subscription in which resources
    will be provisioned. For this, we can get it in Azure Cloud Shell by running the
    `az account list` command to display our subscription details:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要检索我们将要配置资源的订阅ID。为此，我们可以通过运行`az account list`命令在Azure Cloud Shell中显示订阅详细信息：
- en: '![](img/b642bbcf-10b9-4f1e-8c64-b0e301684ec4.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b642bbcf-10b9-4f1e-8c64-b0e301684ec4.png)'
- en: Also, get the `id` property of the subscription concerned.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，获取相关订阅的`id`属性。
- en: How to do it…
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'This recipe comprises two parts, which are as follows: the creation of the
    Service Principal, and the configuration of Terraform authentication using this
    Service Principal.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方包括两部分，分别是：创建服务主体和使用该服务主体配置Terraform认证。
- en: 'To create this Service Principal, perform the following steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建此服务主体，请执行以下步骤：
- en: 'Open Azure Cloud Shell and execute the following command:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Azure Cloud Shell并执行以下命令：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Retrieve all the identification information provided in the output of the previous
    command by making a note (because we won''t be able to retrieve the password after
    closing this console) of `appId`, `password`, and `tenant`, as shown in the following
    screenshot:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从前一个命令的输出中检索所有标识信息，记下`appId`、`password`和`tenant`（因为关闭此控制台后，我们将无法检索密码），如以下截图所示：
- en: '![](img/21a5185e-24d7-4e3f-a2ab-aa4e1bc04029.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21a5185e-24d7-4e3f-a2ab-aa4e1bc04029.png)'
- en: 'Now that the Service Principal is created, we can use it to provision Azure
    infrastructure with Terraform by performing the following steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务主体已经创建，我们可以使用它来通过Terraform配置Azure基础设施，执行以下步骤：
- en: 'In the command-line terminal, set four new variable environments as follows:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行终端中，设置以下四个新的环境变量：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we can apply the Terraform configuration by executing the following Terraform
    workflow:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以通过执行以下Terraform工作流来应用Terraform配置：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In the first part of this recipe, we created a Service Principal and gave it
    its permissions on a subscription, using the command line `az ad sp`. To this
    command, we added the following arguments:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方的第一部分，我们创建了一个服务主体，并使用命令行`az ad sp`为其赋予了订阅权限。我们为此命令添加了以下参数：
- en: '`name`, which is the name of the Service Principal we''re going to create.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`，即我们将要创建的服务主体的名称。'
- en: '`role`, which is the role that the Service Principal will have on the subscription;
    here, we specify `Contributor`.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`role`，即服务主体在订阅中所拥有的角色；在此，我们指定为`Contributor`。'
- en: '`scopes`, where we specify the Azure ID of the resource on which the Service
    Principal will have contributor permissions. In our case, this is the subscription
    ID in which the resources will be provisioned by Terraform.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scopes`，我们在此指定服务主体将拥有贡献者权限的Azure资源ID。在我们的案例中，这是Terraform将配置资源的订阅ID。'
- en: This command will therefore create the Service Principal with a generated password
    and will give it the `Contributor` role on the specified subscription.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，此命令将创建一个服务主体，并为其生成密码，并在指定的订阅上授予 `Contributor` 角色。
- en: 'At the end of its execution, this command displays the information of the Service
    Principal, including `AppId`, `password`, and `tenant`. As explained in *step
    2*, we need to retrieve this information and store it in a safe place because
    this password cannot be retrieved later. Then, we check that the Service Principal has
    the permissions on subscription, as you can see in the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完毕后，此命令会显示服务主体的信息，包括 `AppId`、`password` 和 `tenant`。如 *步骤 2* 中所解释的，我们需要获取这些信息并妥善保存，因为此密码无法以后重新获取。然后，我们检查服务主体是否具有订阅权限，您可以在以下截图中看到：
- en: '![](img/ea215dd2-f679-4882-93d0-75a9f0f85818.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea215dd2-f679-4882-93d0-75a9f0f85818.png)'
- en: 'In the second part of this recipe, we used this Service Principal to authenticate
    the Terraform Azure provider. For this, there are several solutions, the most
    secure one being to use specific Azure provider environment variables because
    these environment variables will not be visible in code and will only be persistent
    during the execution session. So, we have set four environment variables, which
    are as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方的第二部分，我们使用此服务主体来认证 Terraform Azure 提供程序。为此，有几种解决方案，其中最安全的方式是使用特定的 Azure
    提供程序环境变量，因为这些环境变量在代码中不可见，且仅在执行会话期间保持有效。因此，我们设置了四个环境变量，具体如下：
- en: '`ARM_SUBSCRIPTION_ID`: This contains the Azure subscription ID.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ARM_SUBSCRIPTION_ID`：此字段包含 Azure 订阅 ID。'
- en: '`ARM_CLIENT_ID`: This contains the Service Principal ID, called `AppId`.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ARM_CLIENT_ID`：此字段包含服务主体 ID，称为 `AppId`。'
- en: '`ARM_CLIENT_SECRET`: This contains the password of the Service Principal.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ARM_CLIENT_SECRET`：此字段包含服务主体的密码。'
- en: '`ARM_TENANT_ID`: This contains the ID of the Azure Active Directory tenant.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ARM_TENANT_ID`：此字段包含 Azure Active Directory 租户的 ID。'
- en: In the recipe, we used the export command of the Linux system. On Windows PowerShell,
    we can use the `$env` command. In addition, in all the recipes in this chapter,
    we will use these environment variables before executing Terraform.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，我们使用了 Linux 系统的 export 命令。在 Windows PowerShell 中，我们可以使用 `$env` 命令。此外，在本章的所有配方中，我们将在执行
    Terraform 之前使用这些环境变量。
- en: Then, once these environment variables are set, we can execute the basic Terraform
    workflow.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一旦设置了这些环境变量，我们就可以执行基本的 Terraform 工作流。
- en: There's more...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: Regarding the creation of the Service Principal, we made the choice to use the
    Azure CLI tool, but we could also have done it directly via the Azure portal,
    as detailed in the following documentation available at [https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-create-service-principal-portal](https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-create-service-principal-portal),
    or we could have used the Azure PowerShell commands ([https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-authenticate-service-principal-powershell](https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-authenticate-service-principal-powershell)).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 关于创建服务主体，我们选择使用 Azure CLI 工具，但也可以直接通过 Azure 门户进行创建，详细信息请参见以下文档：[https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-create-service-principal-portal](https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-create-service-principal-portal)，或者我们也可以使用
    Azure PowerShell 命令（[https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-authenticate-service-principal-powershell](https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-authenticate-service-principal-powershell)）。
- en: 'In addition, as regards the configuration of the Terraform Azure provider,
    we have used environment variables, but we can also put this information directly
    into the Terraform configuration, as shown in the following code snippet:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，关于 Terraform Azure 提供程序的配置，我们使用了环境变量，但也可以直接将这些信息写入 Terraform 配置文件，如下所示的代码片段所示：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This solution does not require an extra step (the set of environment variables)
    to be implemented prior to executing the Terraform configuration, but it leaves
    identification information in clear text in the code, and hardcoding credentials
    in code is generally considered a bad practice from the security perspective,
    since the leakage of code also leaks credentials and makes it impossible to share
    the code with anyone without exposing the credentials. And in the case where the
    Terraform configuration provides resources for several environments that are in
    different subscriptions, Terraform variables will have to be added, which can
    add complexity to the code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 该解决方案不要求在执行 Terraform 配置之前实现额外的步骤（如设置环境变量），但它将身份信息以明文形式保留在代码中，而在安全角度来看，将凭证硬编码在代码中通常被认为是不好的做法，因为代码泄漏也会导致凭证泄漏，并且无法在不暴露凭证的情况下与他人共享代码。如果
    Terraform 配置为不同订阅中的多个环境提供资源，则需要添加 Terraform 变量，这可能会增加代码的复杂性。
- en: Finally, the use of environment variables offers the advantage of being easily
    integrated into a CI/CD pipeline while preserving the security of the authentication
    data.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用环境变量的优点是它能够轻松集成到 CI/CD 管道中，同时保持身份验证数据的安全性。
- en: See also
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The Azure documentation and Terraform configuration is available here: [https://docs.microsoft.com/en-us/azure/developer/terraform/install-configure](https://docs.microsoft.com/en-us/azure/developer/terraform/install-configure)
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 文档和 Terraform 配置可在此处查看：[https://docs.microsoft.com/en-us/azure/developer/terraform/install-configure](https://docs.microsoft.com/en-us/azure/developer/terraform/install-configure)
- en: Documentation on the configuration of the Azure provider, along with the other
    authentication options, is available here: [https://www.terraform.io/docs/providers/azurerm/index.html](https://www.terraform.io/docs/providers/azurerm/index.html)
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Azure 提供者的配置文档以及其他身份验证选项，请参阅：[https://www.terraform.io/docs/providers/azurerm/index.html](https://www.terraform.io/docs/providers/azurerm/index.html)
- en: Protecting the state file in the Azure remote backend
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护 Azure 远程后端中的状态文件
- en: When executing the Terraform workflow commands, which are mainly `terraform
    plan`, `terraform apply`, and `terraform destroy`, Terraform has a mechanism that
    allows it to identify which resources need to be updated, added, or deleted. To
    perform this mechanism, Terraform maintains a file called a Terraform state file
    that contains all the details of the resources provisioned by Terraform. This
    Terraform state file is created the first time the `terraform plan` command is
    run and is updated with each action (`apply` or `destroy`).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行 Terraform 工作流命令时，主要是 `terraform plan`、`terraform apply` 和 `terraform destroy`，Terraform
    有一个机制，它可以识别哪些资源需要更新、添加或删除。为了执行这个机制，Terraform 维护一个名为 Terraform 状态文件的文件，其中包含所有由
    Terraform 提供的资源的详细信息。这个 Terraform 状态文件在首次运行 `terraform plan` 命令时创建，并在每次操作（`apply`
    或 `destroy`）后更新。
- en: 'In a enterprise, this file contains certain interesting aspects, which are
    as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业中，这个文件包含某些有趣的方面，如下所示：
- en: Sensitive information on the provisioned resources is mentioned in clear text.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供资源的敏感信息以明文形式显示。
- en: If several people are working together, this file must be shared by everyone
    or, by default, this file is created on the local workstation or on the workstation
    that contains the Terraform binary.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果几个人在一起工作，这个文件必须由每个人共享，否则默认情况下，这个文件会在本地工作站或包含 Terraform 二进制文件的工作站上创建。
- en: Even if it is archived in a Git source code manager, once it is retrieved on
    the local workstation, it does not allow several people to work on the same file.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使该文件被归档在 Git 源代码管理工具中，一旦在本地工作站上检索，它也不允许多人在同一个文件上进行工作。
- en: With this locally stored file, managing multi-environments can quickly become
    complicated and risky.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本地存储的文件来管理多环境可能会迅速变得复杂且具有风险。
- en: Any deletion of this local file or poor manual editing can affect the execution
    of Terraform configuration.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何对该本地文件的删除或不当手动编辑都可能影响 Terraform 配置的执行。
- en: A solution to all these problems is the use of a remote backend, which consists
    of storing this file in a remote, shared, and secure store.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 解决所有这些问题的一种方法是使用远程后端，即将该文件存储在远程、共享和安全的存储中。
- en: In the use of Terraform, there are several types of remote backends, such as
    S3, `azurerm`, Artifactory, and many others, which are listed in the menu on the
    following page: [https://www.terraform.io/docs/backends/types/index.html](https://www.terraform.io/docs/backends/types/index.html)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Terraform 的使用中，有多种远程后端类型，例如 S3、`azurerm`、Artifactory 等，这些类型在以下页面的菜单中列出：[https://www.terraform.io/docs/backends/types/index.html](https://www.terraform.io/docs/backends/types/index.html)
- en: In this recipe, we will study the use of a remote backend, `azurerm`, in Azure
    by storing this Terraform state file in an Azure Storage Account.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将研究在 Azure 中使用远程后端 `azurerm`，通过将 Terraform 状态文件存储在 Azure 存储帐户中。
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: For this recipe, we will use Azure Cloud Shell and Azure CLI commands to create
    the Storage Account.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将使用 Azure Cloud Shell 和 Azure CLI 命令来创建存储帐户。
- en: The source code for this recipe and the script used are available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/remotebackend](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/remotebackend).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的源代码和所使用的脚本可以在 [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/remotebackend](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/remotebackend)
    获取。
- en: How to do it…
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'This recipe consists of two parts. In the first part, we will create the Storage
    Account, and in the second part, we will configure Terraform to use the `azurerm`
    remote backend:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱由两部分组成。在第一部分，我们将创建存储帐户，在第二部分，我们将配置 Terraform 使用 `azurerm` 远程后端：
- en: 'In Azure Cloud Shell, execute the following Azure CLI script (available at [https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/remotebackend/create-backend.sh](https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/remotebackend/create-backend.sh))
    to create the Storage Account with a blob container in the Resource Group:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Azure Cloud Shell 中，执行以下 Azure CLI 脚本（可通过 [https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/remotebackend/create-backend.sh](https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/remotebackend/create-backend.sh)
    获取）来在资源组中创建存储帐户及其 blob 容器：
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we configure the Terraform state backend by adding the following code
    to the `main.tf` file:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过将以下代码添加到 `main.tf` 文件中来配置 Terraform 状态后端：
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, to execute the Terraform configuration, we set a new environment variable, `ARM_ACCESS_KEY`,
    with the following command:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了执行 Terraform 配置，我们设置一个新的环境变量 `ARM_ACCESS_KEY`，通过以下命令：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Then, we execute the basic commands of the Terraform workflow.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们执行 Terraform 工作流的基本命令。
- en: How it works…
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理……
- en: 'In the first step, we used a script that performs the following actions in
    sequence:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们使用了一个脚本，按顺序执行以下操作：
- en: It creates a Resource Group called `RG-TFBACKEND`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它创建一个名为 `RG-TFBACKEND` 的资源组。
- en: In this Resource Group, we use the `az storage account create` command to create
    a Storage Account named `storagetfbackend`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个资源组中，我们使用 `az storage account create` 命令创建一个名为 `storagetfbackend` 的存储帐户。
- en: Then, this script creates a blob container in this Storage Account with the
    `az storage container create` command.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，脚本通过 `az storage container create` 命令在这个存储帐户中创建一个 blob 容器。
- en: Finally, we retrieve the account key of the Storage Account created and display
    its value.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们获取已创建的存储帐户的帐户密钥并显示其值。
- en: 'Then, in *step 2*, we configure Terraform to use this Storage Account as a
    remote backend to store the Terraform state file. In this configuration, which
    is located in a `backend "azurerm"` block, we indicate, on the one hand, the Storage
    Account information, and, on the other, the blob with the properties:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在*步骤 2*中，我们配置 Terraform 使用这个存储帐户作为远程后端来存储 Terraform 状态文件。在这个配置中，它位于 `backend
    "azurerm"` 块中，我们一方面指明存储帐户信息，另一方面指明 blob 及其属性：
- en: '`resource_group_name`: This is the name of the Resource Group that contains
    the Storage Account.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource_group_name`：这是包含存储帐户的资源组的名称。'
- en: '`storage_account_name`: This is the name of the Storage Account.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storage_account_name`：这是存储帐户的名称。'
- en: '`container_name`: This is the name of the blob container.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container_name`：这是 blob 容器的名称。'
- en: '`key`: This is the name of the Terraform state file.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key`：这是 Terraform 状态文件的名称。'
- en: Finally, we define a new environment variable, `ARM_ACCESS_KEY`, that contains
    the account key for the Storage Account we retrieved from the script we ran in
    *step 1*. This variable is used to authenticate the Storage Account. Then, we
    execute the `init`, `plan`, and `apply` commands of Terraform.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了一个新的环境变量`ARM_ACCESS_KEY`，它包含我们从*步骤1*中运行的脚本中获取的存储帐户密钥。此变量用于身份验证存储帐户。然后，我们执行
    Terraform 的`init`、`plan`和`apply`命令。
- en: 'Based on what we studied in the previous recipe, *Protecting the Azure credential
    provider*, here is the complete script for executing this Terraform script in
    Azure:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在前一个教程中学到的内容，*保护 Azure 凭证提供者*，这是在 Azure 中执行此 Terraform 脚本的完整脚本：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, we used the four authentication environment variables, as well as the `ARM_ACCESS_KEY`
    environment variable, for authentication to the Storage Account and we executed
    the Terraform commands.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们使用了四个身份验证环境变量，以及`ARM_ACCESS_KEY`环境变量，用于对存储帐户进行身份验证，并执行了 Terraform 命令。
- en: There's more…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'In this recipe, we used an environment variable to specify the value of the
    access key to protect this sensitive data. We could have specified it in the remote
    backend configuration, using the `access_key` property, as in the following example
    (but as mentioned in the *Protecting the Azure credential provider* recipe of
    this chapter, it isn''t good practice to leave sensitive keys as plain text):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们使用了一个环境变量来指定访问密钥的值，以保护这些敏感数据。我们本可以在远程后端配置中使用`access_key`属性来指定它，如下例所示（但正如本章中*保护
    Azure 凭证提供者*部分所提到的，将敏感密钥以明文形式保留并不是一个好做法）：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Moreover, if our Terraform configuration is designed to be deployed on multiple
    environments, we can create *N* configurations of the `azurerm` backend with the
    following steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们的 Terraform 配置旨在部署到多个环境，我们可以通过以下步骤创建*N*个`azurerm`后端配置：
- en: 'The `main.tf` file contains the following code with the `backend "azurerm"`
    block empty:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main.tf`文件包含以下代码，其中`backend "azurerm"`块为空：'
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We create one `backend.tfvars` file per environment (in a specific folder for
    this environment) with the following code:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为每个环境创建一个`backend.tfvars`文件（位于该环境的特定文件夹中），并包含以下代码：
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, in the execution of the `init` command, we specify the `backend.tfvars`
    file to be used with the following command, as specified in the `init` command
    documentation, which is available at [https://www.terraform.io/docs/backends/config.html#partial-configuration](https://www.terraform.io/docs/backends/config.html#partial-configuration):'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在执行`init`命令时，我们使用以下命令指定要使用的`backend.tfvars`文件，如`init`命令文档中所指定，相关文档可在此查看：[https://www.terraform.io/docs/backends/config.html#partial-configuration](https://www.terraform.io/docs/backends/config.html#partial-configuration)：
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, if the Service Principal that was used to authenticate with Terraform
    has permissions on this Storage Account, then this environment variable is not
    mandatory.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果用于与 Terraform 进行身份验证的服务主体（Service Principal）对该存储帐户具有权限，则此环境变量不是必需的。
- en: See also
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: Documentation relating to the `azurerm` remote backend is available here: [https://www.terraform.io/docs/backends/types/azurerm.html](https://www.terraform.io/docs/backends/types/azurerm.html)
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`azurerm`远程后端的文档，请参见此处：[https://www.terraform.io/docs/backends/types/azurerm.html](https://www.terraform.io/docs/backends/types/azurerm.html)
- en: Terraform's learning module with the `azurerm` remote backend is available here: [https://learn.hashicorp.com/terraform/azure/remote_az#azurerm](https://learn.hashicorp.com/terraform/azure/remote_az#azurerm)
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`azurerm`远程后端的 Terraform 学习模块请参见此处：[https://learn.hashicorp.com/terraform/azure/remote_az#azurerm](https://learn.hashicorp.com/terraform/azure/remote_az#azurerm)
- en: Azure documentation relating to the Terraform remote backend is available here: [https://docs.microsoft.com/en-us/azure/developer/terraform/store-state-in-azure-storage](https://docs.microsoft.com/en-us/azure/developer/terraform/store-state-in-azure-storage)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 Terraform 远程后端的 Azure 文档，请参见此处：[https://docs.microsoft.com/en-us/azure/developer/terraform/store-state-in-azure-storage](https://docs.microsoft.com/en-us/azure/developer/terraform/store-state-in-azure-storage)
- en: Executing ARM templates in Terraform
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Terraform 中执行 ARM 模板
- en: Among all the **Infrastructure as Code** (**IaC**) tools and languages, there
    is one provided by Azure called **Azure Resource Manager** (**ARM**), based on
    JSON format files, that contains the description of the resources to be provisioned.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有**基础设施即代码**（**IaC**）工具和语言中，Azure 提供了一个名为**Azure 资源管理器**（**ARM**）的工具，它基于 JSON
    格式文件，包含要配置的资源的描述。
- en: To learn more about ARM templates, read the following documentation: [https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/overview](https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/overview)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多有关ARM模板的信息，请阅读以下文档：[https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/overview](https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/overview)
- en: 'When using Terraform to provision resources in Azure, you may need to use resources
    that are not yet available in the Terraform `azurerm` provider. Indeed, the `azurerm`
    provider is open source and community-based on GitHub, and has a large community
    of contributors, but this is not enough to keep up with all the changes in Azure''s
    functionalities in real time. This is due to several reasons:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Terraform部署Azure资源时，可能需要使用尚未在Terraform `azurerm`提供者中支持的资源。事实上，`azurerm`提供者是开源的，且基于GitHub的社区驱动，拥有庞大的贡献者社区，但这还不足以实时跟进Azure功能的所有变化。造成这种情况的原因有几个：
- en: New releases of Azure resources are very frequent.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure资源的新版本发布非常频繁。
- en: The Terraform `azurerm` provider is highly dependent on the Azure Go SDK ([https://github.com/Azure/azure-sdk-for-go](https://github.com/Azure/azure-sdk-for-go)),
    which does not contain real-time Azure updates on new features or even on features
    that are still in preview.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform `azurerm`提供者高度依赖Azure Go SDK（[https://github.com/Azure/azure-sdk-for-go](https://github.com/Azure/azure-sdk-for-go)），而该SDK不包含有关新功能或仍处于预览阶段的功能的实时更新。
- en: To partially solve this problem, and for organizations that wish to remain in
    full Terraform, there is a Terraform `azurerm_template_deployment` resource that
    allows you to execute ARM code using Terraform.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了部分解决这个问题，并且对于希望完全使用Terraform的组织，可以使用Terraform `azurerm_template_deployment`资源，该资源允许通过Terraform执行ARM代码。
- en: In this recipe, we will discuss the execution of ARM code with Terraform.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将讨论如何使用Terraform执行ARM代码。
- en: Getting ready
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The Terraform configuration of this recipe will provision an Azure App Service
    that includes an extension. Since the extension App Service resource is not available
    in the `azurerm` provider at the time of writing this book, the Azure App Service
    code will be written in **HashiCorp Configuration Language** (**HCL**), and its
    extension will be provisioned using an ARM template that will be executed with
    Terraform.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的Terraform配置将部署一个包括扩展的Azure App Service。由于在编写本书时，`azurerm`提供者中尚不支持扩展App
    Service资源，因此Azure App Service代码将使用**HashiCorp配置语言**（**HCL**）编写，扩展将通过ARM模板来部署，并使用Terraform执行。
- en: The purpose of the recipe is not to detail the code of the ARM template of the
    extension but to study its execution with Terraform.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的目的是不是详细描述扩展的ARM模板代码，而是研究如何用Terraform执行它。
- en: In this recipe, we will present only the key code extracts. The complete source
    code for this chapter is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/arm-template.](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/arm-template)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们只展示关键代码片段。本章的完整源代码可以在这里找到：[https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/arm-template.](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/arm-template)
- en: How to do it…
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'To execute the ARM template with Terraform, perform the following steps:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Terraform执行ARM模板，请按照以下步骤操作：
- en: 'Inside the folder that will contain the Terraform configuration, create a new
    file called `ARM_siteExtension.json`, which contains the following extract ARM
    JSON template:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将包含Terraform配置的文件夹内，创建一个名为`ARM_siteExtension.json`的新文件，其中包含以下ARM JSON模板片段：
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The complete source code of this file is available here: [https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/arm-template/ARM_siteExtension.json](https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/arm-template/ARM_siteExtension.json)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件的完整源代码可以在这里找到：[https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/arm-template/ARM_siteExtension.json](https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/arm-template/ARM_siteExtension.json)
- en: 'In the `main.tf` file, add the following Terraform extract code:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.tf`文件中，添加以下Terraform代码片段：
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The complete source code of this file is available here: [https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/arm-template/main.tf](https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/arm-template/main.tf)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件的完整源代码可以在这里找到：[https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/arm-template/main.tf](https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/arm-template/main.tf)
- en: 'Then, we can execute the basic Terraform workflow with the following:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下命令执行基本的 Terraform 工作流：
- en: Authentication with four Azure variable environments, as discussed in the *Protecting
    the Azure credential provider* recipe of this chapter
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中讨论的*保护 Azure 凭证提供程序*食谱中，使用四个 Azure 变量环境进行身份验证
- en: The execution of the `init`, `plan` and `apply` commands, as mentioned previously
    and in earlier chapters
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述以及在早期章节中提到的，执行 `init`、`plan` 和 `apply` 命令
- en: How it works…
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'In *step 1*, in the directory that contains the Terraform configuration, we
    created a JSON file that contains the ARM code for creating an extension for a
    App Service. In this ARM file, we have the following three input parameters:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在*步骤 1*中，在包含 Terraform 配置的目录中，我们创建了一个 JSON 文件，包含用于创建应用服务扩展的 ARM 代码。在此 ARM 文件中，我们有以下三个输入参数：
- en: '`appserviceName`: This corresponds to the name of the App Service.'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appserviceName`：这对应于应用服务的名称。'
- en: '`extensionName`: This corresponds to the name of the extension to be added
    (from the extension catalog).'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extensionName`：这对应于要添加的扩展的名称（来自扩展目录）。'
- en: '`extensionVersion`: This corresponds to the version of the extension to be
    added.'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extensionVersion`：这对应于要添加的扩展版本。'
- en: Then, the rest of this file describes the site extension resource to be added
    in Azure using the three parameters.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，本文件的其余部分描述了在 Azure 中使用这三个参数添加的站点扩展资源。
- en: 'Then, in *step 2*, in the Terraform configuration, we used the Terraform resource
    `azurerm_template_deployment`, which allows execution of an ARM template with
    the following properties:'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，在*步骤 2*中，在 Terraform 配置中，我们使用了 Terraform 资源 `azurerm_template_deployment`，该资源允许执行一个
    ARM 模板，具有以下属性：
- en: '`template_body`: This is the ARM code in JSON format. Here, in our example,
    we used the file function to indicate that it is a file.'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template_body`：这是 JSON 格式的 ARM 代码。在我们的示例中，我们使用文件函数来指示它是一个文件。'
- en: '`parameters`: In this block, we fill in the input properties of the ARM template,
    which are `appserviceName`, `extensionName`, and `extensionVersion`. In our recipe,
    we install the `AspNetCoreRuntime.2.2.x64` extension of version `2.2.0-preview3-35497`.'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parameters`：在此块中，我们填写了 ARM 模板的输入属性，包括 `appserviceName`、`extensionName` 和 `extensionVersion`。在我们的食谱中，我们安装了版本为
    `2.2.0-preview3-35497` 的 `AspNetCoreRuntime.2.2.x64` 扩展。'
- en: Finally, to provision this Azure App Service and its extension, the Terraform
    workflow commands are executed.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，为了预配这个 Azure 应用服务及其扩展，执行 Terraform 工作流命令。
- en: 'The following screenshot shows the result in the Azure portal:'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了 Azure 门户中的结果：
- en: '![](img/c70f15ab-b3f2-483c-b3cf-e2d03f368600.png)'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/c70f15ab-b3f2-483c-b3cf-e2d03f368600.png)'
- en: We can see the extension provisioned inside the App Service.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以在应用服务中看到已配置的扩展。
- en: There's more…
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: In this recipe, we have studied the possibility of running an ARM template with
    Terraform. This method allows you to provision elements in Azure that are not
    available in the `azurerm` provider, but it is important to know that Terraform
    knows the resources described in this ARM template when it is executed.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本食谱中，我们研究了使用 Terraform 运行 ARM 模板的可能性。这种方法允许你在 Azure 中预配 `azurerm` 提供程序中不可用的元素，但重要的是要知道，Terraform
    会识别在执行此 ARM 模板时描述的资源。
- en: That is to say that these resources (here, in our resource, it is the extension)
    do not follow the life cycle of the Terraform workflow and are not registered
    in the Terraform state file. The only thing that is written in the Terraform state file
    is the configuration of the resource, `azurerm_template_deployment`, and, as a
    consequence, for example, if you run the `terraform destroy` command on the Terraform
    configuration, these resources provided by the ARM template will not be destroyed.
    Instead, only the `azurerm_template_deployment` resource will be removed from
    Terraform state file. For this reason, it is advisable that you use this type
    of deployment only to complete resources that have been provisioned with Terraform
    HCL code.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也就是说，这些资源（在这里，我们的资源是扩展）不遵循 Terraform 工作流的生命周期，也没有在 Terraform 状态文件中注册。唯一写入 Terraform
    状态文件的内容是资源的配置，`azurerm_template_deployment`，因此，例如，如果你在 Terraform 配置上运行 `terraform
    destroy` 命令，这些由 ARM 模板提供的资源将不会被销毁。相反，只有 `azurerm_template_deployment` 资源会从 Terraform
    状态文件中移除。因此，建议你仅在用 Terraform HCL 代码预配的资源上使用这种类型的部署。
- en: This indeed was our case, since the extension is an integrated complement to
    the App Service, and if we run `terraform destroy`, the App Service will be destroyed
    as well as all its extensions that are integrated in it.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这确实是我们的情况，因为该扩展是 App Service 的一个集成补充，如果我们运行 `terraform destroy`，不仅会销毁 App Service，还会销毁所有集成在其中的扩展。
- en: We have seen the impact on the `destroy` command, but it is the same problem
    on other commands, such as the `plan`, `import`, or `refresh` commands. The resources
    provided by the ARM template are not known by Terraform.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经看到 `destroy` 命令的影响，但在其他命令上也存在相同的问题，例如 `plan`、`import` 或 `refresh` 命令。ARM
    模板提供的资源 Terraform 并不认识。
- en: In addition, the use of an ARM template in Terraform is only effective for a
    complete ARM resource, as is the case here with an extension, which can be executed
    as is with the ARM scripts provided by Azure.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，在 Terraform 中使用 ARM 模板仅对完整的 ARM 资源有效，正如这里的扩展所示，Azure 提供的 ARM 脚本可以直接执行。
- en: In the next recipe, we will stay on the same topic, but instead of using an
    ARM template, we will see how to use Azure CLI commands with Terraform.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下一个食谱中，我们将继续这个话题，但我们将不再使用 ARM 模板，而是看看如何在 Terraform 中使用 Azure CLI 命令。
- en: See also
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: Documentation pertaining to the `azurerm_template_deployment` resource of the
    `azurerm` provider is available here: [https://www.terraform.io/docs/providers/azurerm/r/template_deployment.html](https://www.terraform.io/docs/providers/azurerm/r/template_deployment.html)
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 `azurerm` 提供程序的 `azurerm_template_deployment` 资源的文档可以在此查看：[https://www.terraform.io/docs/providers/azurerm/r/template_deployment.html](https://www.terraform.io/docs/providers/azurerm/r/template_deployment.html)
- en: A blog article that also explains how to get the JSON code of the ARM template
    is available at [https://www.phillipsj.net/posts/applying-azure-app-service-extensions-with-arm/](https://www.phillipsj.net/posts/applying-azure-app-service-extensions-with-arm/).
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一篇博客文章也解释了如何获取 ARM 模板的 JSON 代码，文章链接为：[https://www.phillipsj.net/posts/applying-azure-app-service-extensions-with-arm/](https://www.phillipsj.net/posts/applying-azure-app-service-extensions-with-arm/)
- en: Executing Azure CLI commands in Terraform
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Terraform 中执行 Azure CLI 命令
- en: In the previous recipe, we studied how to run ARM templates with Terraform in
    a situation where the provisioned resource is not yet available in the `azurerm`
    provider.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的食谱中，我们研究了如何在 `azurerm` 提供程序中，所提供的资源尚未可用的情况下，使用 Terraform 运行 ARM 模板。
- en: 'However, there are cases where the use of an ARM template is not possible,
    such as the following:'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，存在无法使用 ARM 模板的情况，例如以下几种情况：
- en: We want to fill in one or more properties of a resource, which are not autonomous
    in an ARM template.
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望填写资源的一个或多个属性，这些属性在 ARM 模板中并不是自治的。
- en: The ARM template is not available for the resource to be provisioned.
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源的 ARM 模板不可用。
- en: For these situations, there is another solution that entails executing Azure
    CLI commands with Terraform.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这些情况，另一种解决方案是通过 Terraform 执行 Azure CLI 命令。
- en: This recipe is a practical application of the *Executing local programs with
    Terraform* recipe from [Chapter 2](3099c9ac-8c38-4e7d-8146-411fac26a2b7.xhtml),
    *Writing Terraform Configuration*. We will study the Terraform configuration and
    its execution to integrate Azure CLI commands with Terraform.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本食谱是 *使用 Terraform 执行本地程序* 食谱的实际应用，来自[第2章](3099c9ac-8c38-4e7d-8146-411fac26a2b7.xhtml)，*编写
    Terraform 配置*。我们将研究 Terraform 配置及其执行，以便将 Azure CLI 命令与 Terraform 集成。
- en: Getting ready
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, it is necessary to have read beforehand the *Executing local
    programs with Terraform* recipe from [Chapter 2](3099c9ac-8c38-4e7d-8146-411fac26a2b7.xhtml),
    *Writing Terraform Configuration*, which provides the basis of the Terraform configuration
    we are going to write.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这个食谱，必须预先阅读 *使用 Terraform 执行本地程序* 食谱，来自[第2章](3099c9ac-8c38-4e7d-8146-411fac26a2b7.xhtml)，*编写
    Terraform 配置*，它为我们将要编写的 Terraform 配置提供了基础。
- en: Moreover, it will also be necessary to have already installed the Azure CLI
    tool, documentation pertaining to which is available here: [https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest)
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，还需要提前安装 Azure CLI 工具，相关文档可以在此查看：[https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest)
- en: To demonstrate the use of the Azure CLI command in Terraform, in this recipe, we
    will set up an Azure Storage Account by configuring the properties of a static
    website feature on it.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了展示如何在 Terraform 中使用 Azure CLI 命令，在本食谱中，我们将通过配置静态网站功能的属性来设置 Azure 存储帐户。
- en: As with the previous recipe, the purpose of this recipe is to show how to use
    Azure CLI commands with Terraform, but we will not focus on the Azure CLI command
    used because, since version 2.0.0 of the `azurerm` provider, the properties of
    a static website have been added to the Terraform resource ([https://github.com/terraform-providers/terraform-provider-azurerm/blob/master/CHANGELOG-v2.md#200-february-24-2020](https://github.com/terraform-providers/terraform-provider-azurerm/blob/master/CHANGELOG-v2.md#200-february-24-2020)).
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The source code for this recipe is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/az%20cli](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/az%20cli).
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to execute Azure CLI commands with Terraform:'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `main.tf` file that contains the Terraform code, write the following
    configuration for provision to the Storage Account:'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the same Terraform configuration, add the code to configure the static website
    using the Azure CLI command:'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, in our command-line terminal, we log in to Azure by executing the following
    command:'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we can execute the basic Terraform workflow with the following:'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Authentication with four Azure variable environments, as discussed in the *Protecting
    the Azure credential provider* recipe of this chapter
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The execution of the `init`, `plan`, and `apply` commands, as mentioned previously
    and in earlier chapters
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, there is nothing special. We just wrote the Terraform configuration
    to provision a `StorageV2` Storage Account, which is required to activate the
    static website feature.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In *step 2*, we completed this code by adding `null_resource` that contains
    a `local-exec` provisioner. In the command property of `local-exec`, we put the
    command Azure CLI that must be executed to activate and configure the static website
    functionality on the Storage Account we wrote in *step 1*.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We added the trigger block with the name of the storage as an argument, so that
    if the name of the storage changes, then provisioning will be re-executed.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, in *step 3*, we executed the `az login` command to authenticate the context
    of the Azure CLI. On this command, we added the authentication parameters with
    a Service Principal (see the *Protecting the Azure credential provider *recipe
    in this chapter), as documented here: [https://docs.microsoft.com/en-us/cli/azure/create-an-azure-service-principal-azure-cli?view=azure-cli-latest#sign-in-using-a-service-principal](https://docs.microsoft.com/en-us/cli/azure/create-an-azure-service-principal-azure-cli?view=azure-cli-latest#sign-in-using-a-service-principal).
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the implementation of this recipe, there are two important points:'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first point is that we used `null_resource` with the `local-exec` provisioner
    that we had already studied in detail in the *Executing local programs with Terraform* recipe
    from[ Chapter 2](3099c9ac-8c38-4e7d-8146-411fac26a2b7.xhtml), *Writing Terraform
    Configuration*. The only novelty brought here is the fact that the executed command
    is an Azure CLI command. It could also be a file that contains a script with several
    Azure CLI commands.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一点是我们使用了 `null_resource` 和已经在 *使用 Terraform 执行本地程序* 配方中详细研究过的 `local-exec`
    提供程序，[第二章](3099c9ac-8c38-4e7d-8146-411fac26a2b7.xhtml)《编写 Terraform 配置》中也有讲解。这里唯一的新意是执行的命令是
    Azure CLI 命令，也可以是包含多个 Azure CLI 命令的脚本文件。
- en: The second point is that Terraform's authentication for Azure with the four
    environment variables does not allow authentication of the Azure CLI context that
    will be executed by Terraform. This is why, in *step 3*, we also had to authenticate
    the Azure CLI context with the `az login` command by passing the credentials of
    the Service Principal as parameters.
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二点是，Terraform 使用四个环境变量进行 Azure 身份验证时，无法验证将由 Terraform 执行的 Azure CLI 上下文。这就是为什么在
    *第 3 步* 中，我们还需要通过 `az login` 命令使用服务主体的凭证作为参数来验证 Azure CLI 上下文。
- en: The advantage of executing Azure CLI commands in this way is that we can integrate
    the variables and expressions of the Terraform language into them, just as we
    did when we passed the name of the Storage Account as a parameter.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这种方式执行 Azure CLI 命令的优点在于，我们可以将 Terraform 语言的变量和表达式集成到其中，就像我们在将存储帐户名称作为参数传递时所做的那样。
- en: Note that, as with any local provisioner, this restricts where the configuration
    can be applied as it assumes existence of the Azure CLI (the Azure CLI becomes
    a hidden dependency).
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，与任何本地提供程序一样，这会限制配置应用的地方，因为它假定 Azure CLI 已存在（Azure CLI 成为一个隐藏的依赖项）。
- en: As with the ARM templates, we learned in the previous recipe, *Executing ARM
    templates in Terraform*, that Terraform does not know the resources manipulated
    in the Azure CLI command or script. These resources do not follow the Terraform
    life cycle and are not registered in the Terraform state file. On the other hand,
    in the `local-exec` provisioner of `null_resource`, we can specify a command to
    be executed in the case of execution of the `terraform destroy` command.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与之前的 ARM 模板示例 *在 Terraform 中执行 ARM 模板* 一样，我们了解到 Terraform 无法识别在 Azure CLI 命令或脚本中操作的资源。这些资源不遵循
    Terraform 生命周期，也未注册在 Terraform 状态文件中。另一方面，在 `null_resource` 的 `local-exec` 提供程序中，我们可以指定一个命令，在执行
    `terraform destroy` 命令时执行。
- en: 'The following is an example of the configuration that I used to create a CosmosDB
    database (before the `azurerm` provider supported it) that demonstrates the following:'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是我用来创建 CosmosDB 数据库的配置示例（在 `azurerm` 提供程序支持之前），展示了以下内容：
- en: '[PRE21]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, in the provisioner, we used the `When=destroy` property to
    specify that the Azure CLI command, `az cosmosdb database delete`, will be executed
    to delete the CosmosDB database in the case of `terraform destroy`.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个示例中，在提供程序中，我们使用了 `When=destroy` 属性，指定在执行 `terraform destroy` 时，Azure CLI
    命令 `az cosmosdb database delete` 会被执行以删除 CosmosDB 数据库。
- en: See also
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: Documentation pertaining to the `az login` command and its parameters is available
    here: [https://docs.microsoft.com/en-us/cli/azure/authenticate-azure-cli?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/authenticate-azure-cli?view=azure-cli-latest)
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`az login` 命令及其参数的文档可以在此处找到：[https://docs.microsoft.com/en-us/cli/azure/authenticate-azure-cli?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/authenticate-azure-cli?view=azure-cli-latest)'
- en: Documentation pertaining to the Terraform `provisioner` is available here: [https://www.terraform.io/docs/provisioners/index.html](https://www.terraform.io/docs/provisioners/index.html)
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform `provisioner` 相关文档可以在此处找到：[https://www.terraform.io/docs/provisioners/index.html](https://www.terraform.io/docs/provisioners/index.html)
- en: Documentation pertaining to the `when` property of `provisioner` is available
    here: [https://www.terraform.io/docs/provisioners/index.html#destroy-time-provisioners](https://www.terraform.io/docs/provisioners/index.html#destroy-time-provisioners)
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`provisioner` 的 `when` 属性的文档可以在此处找到：[https://www.terraform.io/docs/provisioners/index.html#destroy-time-provisioners](https://www.terraform.io/docs/provisioners/index.html#destroy-time-provisioners)'
- en: Using Azure Key Vault with Terraform to protect secrets
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Azure Key Vault 和 Terraform 保护机密
- en: One of the challenges of IaC is the protection of sensitive information that
    is part of the infrastructure.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: IaC 的挑战之一是保护基础设施中的敏感信息。
- en: Indeed, one of the advantages of IaC is the possibility to version the code
    in a Git repository and so this code benefits from the Git workflow of versioning
    and validation of the code. However, with this approach, we tend to write *everything*
    in this code, sometimes forgetting that some data that is sensitive, such as passwords
    or login strings, can be misused if they end up in the wrong hands.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上，基础设施即代码（IaC）的一个优势是能够将代码版本化到 Git 仓库中，因此，这些代码可以受益于 Git 工作流中的版本控制和代码验证。然而，采用这种方法时，我们往往会在代码中写下*所有*内容，有时会忘记一些敏感数据，比如密码或登录字符串，如果这些数据落入错误的手中，可能会被滥用。
- en: In this recipe, we will study how to protect this sensitive data by storing
    it in Azure's secret manager, which is Azure Key Vault, and then using it in the
    Terraform configuration.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本配方中，我们将学习如何通过将敏感数据存储在 Azure 的密钥管理器中（即 Azure Key Vault），然后在 Terraform 配置中使用它，从而保护这些敏感数据。
- en: Getting ready
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we assume the use of Azure Key Vault. For more information,
    you can refer to the following documentation available at [https://docs.microsoft.com/en-us/azure/key-vault/](https://docs.microsoft.com/en-us/azure/key-vault/).
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于本配方，我们假设使用 Azure Key Vault。有关更多信息，您可以参考以下文档：[https://docs.microsoft.com/en-us/azure/key-vault/](https://docs.microsoft.com/en-us/azure/key-vault/)。
- en: In an Azure Key Vault that we have created in Azure, as regards the application
    of this recipe, we store a secret that protects the connection string of the SQL
    Server database of our application hosted in an Azure web application.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们在 Azure 中创建的 Azure Key Vault 中，就本配方的应用而言，我们存储了一个保护 SQL Server 数据库连接字符串的密钥，该数据库托管在
    Azure Web 应用程序中。
- en: 'This connection string is as follows:'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个连接字符串如下所示：
- en: '[PRE22]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here is the output of the Azure CLI command, `az keyvault secret show`, which
    shows its storage and properties in Azure Key Vault:'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是 Azure CLI 命令 `az keyvault secret show` 的输出，它显示了该密钥在 Azure Key Vault 中的存储位置和属性：
- en: '![](img/258b1b3b-f223-4e5f-a3c8-df790a793bb5.png)'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/258b1b3b-f223-4e5f-a3c8-df790a793bb5.png)'
- en: In the preceding screenshot, we can see the connection string of the database
    stored in the `value` property of the `secret` object.
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到存储在 `secret` 对象的 `value` 属性中的数据库连接字符串。
- en: The goal of this recipe is to write the Terraform configuration that requests
    the value of this secret to use it in the properties of an Azure App Service.
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本配方的目标是编写 Terraform 配置，请求此密钥的值，并在 Azure App Service 的属性中使用它。
- en: The source code for this recipe is available here: [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/keyvault](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/keyvault)
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本配方的源代码可以在这里找到：[https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/keyvault](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/keyvault)
- en: How to do it…
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'To get and use an Azure Key Vault secret in Terraform, perform the following
    steps:'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要在 Terraform 中获取和使用 Azure Key Vault 密钥，请执行以下步骤：
- en: 'In Azure Key Vault, we add access policy properties by granting the Service
    Principal that will be used by Terraform for Azure to have permission to get and
    list secrets:'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Azure Key Vault 中，我们通过授予将由 Terraform 用于 Azure 的 Service Principal 访问权限，来添加访问策略属性，以便它能够获取和列出密钥：
- en: '![](img/e317dc9a-9653-4b99-a7a2-aa0dddc28884.png)'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/e317dc9a-9653-4b99-a7a2-aa0dddc28884.png)'
- en: 'In the `main.tf` file, we add the following code to get the Key Vault secret:'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.tf` 文件中，我们添加以下代码以获取 Key Vault 密钥：
- en: '[PRE23]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, in the Terraform configuration of the App Service resource, in the `main.tf`
    file, we add the following code:'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 App Service 资源的 Terraform 配置中，在 `main.tf` 文件中，我们添加以下代码：
- en: '[PRE24]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finally, we run the basic Terraform workflow for Azure with set variable environments
    and execute `init`, `plan`, and `apply`, as mentioned previously and in earlier
    chapters.
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们按之前的描述以及前面章节中提到的，运行基本的 Azure Terraform 工作流，设置变量环境并执行 `init`、`plan` 和 `apply`。
- en: How it works…
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In *step 1*, we gave permission to the Service Principal used by Terraform to
    read and list the secrets of Azure Key Vault.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在*第 1 步*中，我们授予了 Terraform 使用的 Service Principal 读取和列出 Azure Key Vault 密钥的权限。
- en: We can do this either via the Azure portal or on the command line with the Azure
    CLI, as explained in the following documentation: [https://docs.microsoft.com/en-us/cli/azure/keyvault?view=azure-cli-latest#az-keyvault-set-policy](https://docs.microsoft.com/en-us/cli/azure/keyvault?view=azure-cli-latest#az-keyvault-set-policy)
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过 Azure 门户或使用 Azure CLI 在命令行上执行此操作，具体方法请参见以下文档：[https://docs.microsoft.com/en-us/cli/azure/keyvault?view=azure-cli-latest#az-keyvault-set-policy](https://docs.microsoft.com/en-us/cli/azure/keyvault?view=azure-cli-latest#az-keyvault-set-policy)
- en: 'If we had not carried out this step, we would have obtained the following error
    when executing the `terraform plan` command:'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们没有执行此步骤，在执行 `terraform plan` 命令时将会出现以下错误：
- en: '![](img/caeee7cf-93b8-4b4d-856c-c52fcae7cd0e.png)'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/caeee7cf-93b8-4b4d-856c-c52fcae7cd0e.png)'
- en: 'Then, in *step 2*, we wrote the Terraform configuration, which contains two
    data sources:'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，在*步骤 2*中，我们编写了包含两个数据源的 Terraform 配置：
- en: The first data source, `azurerm_key_vault`, enables retrieval of the Azure ID
    of the Azure Key Vault resource.
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个数据源`azurerm_key_vault`允许检索 Azure Key Vault 资源的 Azure ID。
- en: The second data source, `azurerm_key_vault_secret`, is used to retrieve the
    secret that contains the database connection string as a value.
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个数据源`azurerm_key_vault_secret`用于获取包含数据库连接字符串的密钥作为值。
- en: For more information about Terraform block data, read the *Using external resources
    with a data block* recipe from [Chapter 2](3099c9ac-8c38-4e7d-8146-411fac26a2b7.xhtml),
    *Writing Terraform Configuration*.
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关 Terraform 数据块的更多信息，请阅读[第 2 章](3099c9ac-8c38-4e7d-8146-411fac26a2b7.xhtml)中的*使用数据块与外部资源*配方，*编写
    Terraform 配置*。
- en: In *step 3*, we continue with the writing of the Terraform configuration, putting
    in the property value of the `connection_string` block of the App Service with
    the expression `data.azurerm_key_vault_secret.app-connectionstring.value`, which
    is the value obtained from the block data, `azurerm_key_vault_secret`, written
    in *step 2*.
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在*步骤 3*中，我们继续编写 Terraform 配置，将`connection_string`块的属性值填入应用服务中，使用表达式`data.azurerm_key_vault_secret.app-connectionstring.value`，这是从在*步骤
    2*中编写的`azurerm_key_vault_secret`数据块中获取的值。
- en: Finally, in the last step, we execute this Terraform configuration. During this
    operation, Terraform will first retrieve the values requested in the block data
    (Key Vault, and then the Key Vault secret) and will then inject the value obtained
    from the secret into the configuration of the App Service.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，在最后一步中，我们执行此 Terraform 配置。在此操作中，Terraform 会首先获取在数据块中请求的值（Key Vault，然后是 Key
    Vault 秘密），然后将从密钥中获取的值注入到应用服务的配置中。
- en: 'This result is obtained in Azure and shown in the following screenshot:'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该结果在 Azure 中获得，并显示在以下截图中：
- en: '![](img/7bc29f65-1ee9-42a8-8e90-40c052927723.png)'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/7bc29f65-1ee9-42a8-8e90-40c052927723.png)'
- en: We can see that the connection string is well filled in the App Service configuration.
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到，连接字符串已在应用服务配置中正确填充。
- en: There's more…
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: We have learned in this recipe that the connection string, which is sensitive
    data, has been stored in Azure Key Vault and will be used automatically when Terraform
    is run. So, thanks to Azure Key Vault, we didn't need to put the sensitive data
    in clear text in the Terraform configuration.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在本配方中了解到，作为敏感数据的连接字符串已存储在 Azure Key Vault 中，并且在 Terraform 执行时会自动使用它。因此，感谢
    Azure Key Vault，我们无需将敏感数据以明文形式放入 Terraform 配置中。
- en: 'However, care should still be taken. Although this data is not written in plain
    text in the Terraform configuration, it will be written in plain text in the Terraform
    state file, as can be seen in this extract of the Terraform state file content
    from this recipe:'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，仍然需要小心。虽然这些数据在 Terraform 配置中不是以明文形式写入，但它们会以明文形式写入 Terraform 状态文件，如以下从本配方提取的
    Terraform 状态文件内容所示：
- en: '![](img/da59826f-3dd9-46fa-819a-195eeed80248.png)'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/da59826f-3dd9-46fa-819a-195eeed80248.png)'
- en: 'That is why, if we need to inspect the contents of this file, it is recommended
    to use the `terraform state show` or `terraform show` commands, which protect
    the displaying of sensitive data, as can be seen in the following screenshot:'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是为什么，如果我们需要检查该文件的内容，建议使用 `terraform state show` 或 `terraform show` 命令，它们可以保护敏感数据的显示，正如以下截图所示：
- en: '![](img/4526cc47-cc0b-41b0-a4a6-c809d60a189a.png)'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/4526cc47-cc0b-41b0-a4a6-c809d60a189a.png)'
- en: This is one of the reasons why it is necessary to protect this `tfstate` file
    by storing it in a secure remote backend, as we have seen in the *Protecting the
    state file in the Azure remote backend* recipe of this chapter, and which is explained
    in the following documentation: [https://www.terraform.io/docs/state/sensitive-data.html](https://www.terraform.io/docs/state/sensitive-data.html)
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是需要通过将 `tfstate` 文件存储在安全的远程后端来保护该文件的原因之一，正如我们在本章的*保护 Azure 远程后端中的状态文件*配方中所见，并且在以下文档中做了详细说明：[https://www.terraform.io/docs/state/sensitive-data.html](https://www.terraform.io/docs/state/sensitive-data.html)
- en: Also in this recipe, although we stored the sensitive data in Azure Key Vault,
    we can also store it in a HashiCorp Vault instance that integrates very well with
    Terraform. For this, it is advisable that you read the vault provider documentation here: [https://www.terraform.io/docs/providers/vault/index.html](https://www.terraform.io/docs/providers/vault/index.html)
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个教程中，尽管我们将敏感数据存储在 Azure Key Vault 中，我们也可以将其存储在与 Terraform 集成良好的 HashiCorp
    Vault 实例中。为此，建议你阅读 vault 提供程序文档，链接在这里：[https://www.terraform.io/docs/providers/vault/index.html](https://www.terraform.io/docs/providers/vault/index.html)
- en: Finally, as a prerequisite for this recipe, we manually created the secret of
    the connection string in Azure Key Vault. This could have been done either with
    Terraform, as documented here ([https://www.terraform.io/docs/providers/azurerm/r/key_vault_secret.html](https://www.terraform.io/docs/providers/azurerm/r/key_vault_secret.html)),
    or with the Azure CLI commands, as documented here ([https://docs.microsoft.com/en-us/cli/azure/keyvault/secret?view=azure-cli-latest#az-keyvault-secret-set](https://docs.microsoft.com/en-us/cli/azure/keyvault/secret?view=azure-cli-latest#az-keyvault-secret-set)).
    On the other hand, in this case, since the data will be written in clear text
    in the code, it will be necessary to secure it well by giving read and write permissions
    only to authorized persons.
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，作为本教程的前提，我们在 Azure Key Vault 中手动创建了连接字符串的密钥。此操作可以通过 Terraform 完成，文档可参考这里：[https://www.terraform.io/docs/providers/azurerm/r/key_vault_secret.html](https://www.terraform.io/docs/providers/azurerm/r/key_vault_secret.html)，也可以通过
    Azure CLI 命令完成，文档参考这里：[https://docs.microsoft.com/en-us/cli/azure/keyvault/secret?view=azure-cli-latest#az-keyvault-secret-set](https://docs.microsoft.com/en-us/cli/azure/keyvault/secret?view=azure-cli-latest#az-keyvault-secret-set)。另一方面，由于数据将在代码中以明文形式写入，因此必须通过仅授权人员授予读写权限来确保安全。
- en: See also
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: Documentation on the block data, `azurerm_key_vault_secret`, is available here: [https://www.terraform.io/docs/providers/azurerm/d/key_vault_secret.html](https://www.terraform.io/docs/providers/azurerm/d/key_vault_secret.html)
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 `azurerm_key_vault_secret` 块数据的文档，请参见这里：[https://www.terraform.io/docs/providers/azurerm/d/key_vault_secret.html](https://www.terraform.io/docs/providers/azurerm/d/key_vault_secret.html)
- en: Getting a list of Azure resources in Terraform
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Terraform 中获取 Azure 资源列表
- en: In the previous recipe, we learned the practical case of using a `data` block
    to obtain the properties of an Azure resource.
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的教程中，我们学习了使用 `data` 块来获取 Azure 资源属性的实际案例。
- en: We will look in this recipe at a data source in the `azurerm` provider that
    is generic and allows you to get information about any provisioned resource in
    Azure.
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本教程中，我们将查看 `azurerm` 提供程序中的一个通用数据源，它允许你获取 Azure 中任何已配置资源的信息。
- en: Getting ready
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will write a Terraform configuration that adds security rules
    to several Azure **Network Security Groups** (**NSGs**) already provisioned (manually
    or by Terraform). Its purpose is to add these rules to all NSGs that have the
    tag `DEFAULTRULES=TRUE`.
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将编写一个 Terraform 配置，向多个已经预配置的 Azure **网络安全组**（**NSGs**）添加安全规则（这些 NSGs
    可能是手动创建的，或者通过 Terraform 创建的）。其目的是向所有具有标签 `DEFAULTRULES=TRUE` 的 NSGs 添加这些规则。
- en: In addition, we have already created three NSGs in the Resource Group called
    `RG-DEMO`. Among these NSGs, only NSG1 and NSG2 have the tag `DEFAULTRULES=TRUE`.
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，我们已经在名为 `RG-DEMO` 的资源组中创建了三个 NSGs。在这些 NSGs 中，只有 NSG1 和 NSG2 具有标签 `DEFAULTRULES=TRUE`。
- en: The source code for this recipe is available here: [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/listresources](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/listresources)
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本教程的源代码可以在这里找到：[https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/listresources](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/listresources)
- en: How to do it…
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Perform the following steps in order to get Azure resources:'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行以下步骤以获取 Azure 资源：
- en: 'In the `main.tf` file that contains the Terraform configuration, add the following
    code to get provisioned NSGs:'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包含 Terraform 配置的 `main.tf` 文件中，添加以下代码以获取已配置的 NSGs：
- en: '[PRE25]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, in the same file, add the following code to create rules:'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在同一个文件中，添加以下代码来创建规则：
- en: '[PRE26]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Finally, we run the basic Terraform workflow for Azure with set variable environments
    and execute `init`, `plan`, and `apply`, as mentioned previously and in earlier
    chapters.
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们按照之前和前几章所提到的步骤，运行了适用于 Azure 的基本 Terraform 工作流，设置了变量环境，并执行了 `init`、`plan`
    和 `apply`。
- en: How it works…
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In *step 1*, we used the `azurerm_resources` data object, which allows you
    to obtain the basic properties of any already provisioned Azure resource. To this
    object, we configured the following properties:'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在*步骤 1* 中，我们使用了 `azurerm_resources` 数据对象，允许您获取任何已经配置的 Azure 资源的基本属性。对于此对象，我们配置了以下属性：
- en: '`type`: This is the type of resource to request. The list of types is documented
    here: [https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-services-resource-providers](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-services-resource-providers).
    Here, we filled in the value `Microsoft.Network/networkSecurityGroups`.'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：这是请求资源类型。类型列表在此处有文档记录：[https://docs.microsoft.com/zh-cn/azure/azure-resource-manager/management/azure-services-resource-providers](https://docs.microsoft.com/zh-cn/azure/azure-resource-manager/management/azure-services-resource-providers)。在这里，我们填入了值
    `Microsoft.Network/networkSecurityGroups`。'
- en: '`resource_group_name`: This is the name of the Resource Group in which the
    NSGs have been provisioned.'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource_group_name`：这是已经配置了 NSG 的资源组的名称。'
- en: '`required_tag`: This is the list of tags on which we want to filter NSGs.'
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`required_tag`：这是我们要过滤 NSG 的标签列表。'
- en: Then, in *step 2*, we completed this Terraform configuration by adding the `azurerm_network_security_rule`
    resource, which enables the provision of rules in already existing NSGs. In this
    resource, we first added the expression `for_each`, which facilitates a loop on
    all NSGs that are returned from the previously instantiated data block. In the
    construction of this loop, we used the expression `data.azurerm_resources.nsg.resources`,
    which contains a list of NSGs retrieved from the `data` block. Moreover, in the
    `name` property, we add a prefix, which is the name of the NSG, using the expression
    `each.key`. Finally, in the `network_security_group_name` property, we also use
    `each.key` as the name of each NSG iterated in the loop.
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，在*步骤 2* 中，我们通过添加 `azurerm_network_security_rule` 资源完成了此 Terraform 配置，该资源允许在已存在的
    NSG 中配置规则。在此资源中，我们首先添加了 `for_each` 表达式，它便于对从先前实例化的数据块返回的所有 NSG 进行循环。在构建此循环时，我们使用了表达式
    `data.azurerm_resources.nsg.resources`，其中包含从 `data` 块检索的 NSG 列表。此外，在 `name` 属性中，我们添加了一个前缀，即
    NSG 的名称，使用表达式 `each.key`。最后，在 `network_security_group_name` 属性中，我们同样使用 `each.key`
    作为循环中每个 NSG 的名称。
- en: For more information on the `for_each` expression and loops in Terraform, refer
    to the recipes in [Chapter 3](d019fed0-6c22-4da8-9796-58d45feafa2c.xhtml), *Building
    Dynamic Environments with Terraform*.
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于 `for_each` 表达式和 Terraform 中的循环更多信息，请参考第 [3 章](d019fed0-6c22-4da8-9796-58d45feafa2c.xhtml)
    的配方，*使用 Terraform 构建动态环境*。
- en: Finally, in *step 3*, we execute the Terraform workflow commands to apply this
    Terraform configuration.
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，在*步骤 3* 中，我们执行 Terraform 工作流命令来应用这个 Terraform 配置。
- en: There's more…
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: We have learned in this recipe that by using `azurerm_resources`, in Terraform, we
    can use any Azure resource that is already provisioned.
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在本配方中学到，通过使用 `azurerm_resources` 在 Terraform 中，我们可以使用任何已经配置的 Azure 资源。
- en: 'In the Terraform configuration, we can also add the following `output` variable,
    which allows a visualization of the resources returned by the `azurerm_resource` data
    block:'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Terraform 配置中，我们还可以添加以下 `output` 变量，该变量允许可视化通过 `azurerm_resource` 数据块返回的资源：
- en: '[PRE27]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following screenshot shows the result of this output:'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了此输出的结果：
- en: '![](img/c68faccb-d32d-4c8b-87fc-76a42d1695e8.png)'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/c68faccb-d32d-4c8b-87fc-76a42d1695e8.png)'
- en: We can see in this output result that the `data` block has recovered the two
    NSGs that are provisioned and has the tag `DEFAULTRULEs=TRUE`. Moreover, you can
    also see the properties of each resource that it is possible to exploit in the
    rest of the Terraform configuration.
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以在此输出结果中看到，`data` 块已经恢复了两个已经配置的 NSG，并具有标签 `DEFAULTRULEs=TRUE`。此外，您还可以看到每个资源的属性，可以在
    Terraform 配置的其余部分中利用。
- en: However, it must be ensured that these resources are provisioned in the same
    subscription as defined in the environment variable, `ARM_SUBSCRIPTION_ID`, which
    is set before executing the Terraform commands, as we have seen in the *Protecting
    the Azure credential provider* recipe of this chapter.
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是，必须确保这些资源是在与环境变量 `ARM_SUBSCRIPTION_ID` 中定义的相同订阅中进行配置的，这些变量在执行 Terraform 命令之前设置，正如我们在本章节的
    *保护 Azure 凭据提供者* 配方中看到的。
- en: See also
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Documentation pertaining to the `azurerm_resources` object data of Terraform
    is available here: [https://www.terraform.io/docs/providers/azurerm/d/resources.html](https://www.terraform.io/docs/providers/azurerm/d/resources.html)
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Provisioning and configuring an Azure VM with Terraform
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will study a typical use case of Terraform in Azure in which
    we will provision and configure a VM in Azure using Terraform.
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we don''t need any special prerequisites. We will start the
    Terraform configuration from scratch. This recipe will only involve writing the
    Terraform configuration. In its stages of realization, we will study the writing
    of this code. As for the architecture in Azure, we have already built a network
    beforehand, which will contain this VM and which is made up of the following resources:'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A **virtual network** (**VNet**) called `VNET-DEMO`.
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside this VNet, a Subnet named `Subnet1` is registered.
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, the VM that will be provisioned will have a public IP address so
    that it can be accessed publicly.
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, in keeping the VM's password secret in the code, we protect it in an
    Azure Key Vault, as studied in the *Using Azure Key Vault with Terraform to protect
    secrets* recipe of this chapter.
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The source code for this chapter is available here: [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/vm](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/vm)
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Write the following Terraform configuration to provision a VM with Terraform:'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The first resource to build is the Resource Group, with the help of the following
    code:'
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we write the following code to provision the public IP:'
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We continue by writing the code for the Network Interface:'
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We get the VM password by using the `keyvault` data block:'
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we write the code for the VM resource, as follows:'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The complete source code for these VM resources is available at [https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/vm/main.tf](https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/vm/main.tf).
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, we wrote the Terraform configuration that will create the Resource
    Group containing the VM. This step is optional because you can provision the VM
    in an existing Resource Group, and in this case you can use the `azurerm_resource_group`
    block data, whose documentation is available here: [https://www.terraform.io/docs/providers/azurerm/d/resource_group.html](https://www.terraform.io/docs/providers/azurerm/d/resource_group.html)
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, in *steps 2* and *3*, we wrote the Terraform configuration that provides
    the following:'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A public IP of the dynamic type, so that we don't have to set the IP address
    (this IP address will be the first free address of the subnet).
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Network Interface of the VM that uses this IP address, and which will register
    in the Subnet that has already been created. To retrieve the subnet ID, we used
    an `azurerm_subnet` data source.
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In *step 4*, we use the `azurerm_key_vault_secret` data source to get the password
    of the VM (refer to the *Using Azure Key Vault with Terraform* *to protect secrets*
    recipe for more details).
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, in *step 5*, we write the code that will provision the VM. In this
    code, we have defined the following properties of the VM:'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Its name and size (which includes its RAM and CPU)
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic image used, which is an Ubuntu image
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication information for the VM with a login and a password (an SSH key
    can also be used)
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In this resource, we also added a `remote-exec` provisioner, which allows you
    to remotely execute commands or scripts directly on the VM that will be provisioned.
    The use of this provisioner will allow you to configure the VM for administration,
    security, or even middleware installation tasks.
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: The interesting and new aspect of this recipe is the addition of the `remote-exec`
    provisioner, which enables configuration of the VM using commands or scripts.
    This method can be useful in performing the first steps of VM administration,
    such as opening firewall ports, creating users, and other basic tasks. Here in
    our recipe, we used it to update the packages with the execution of the `apt update`
    command. However, this method requires that this VM is accessible from the computer
    running Terraform because it connects to the VM (SSH or WinRM) and executes the
    commands.
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you want to keep a real IaC, it is preferable to use an as-code configuration
    tool, such as Ansible, Puppet, Chef, or PowerShell DSC. And so, in the case of
    using Ansible to configure a Windows VM, the `remote-exec` provisioner can perfectly
    serve to authorize the WinRM SSL protocol on my VM because this port is the port
    used by Ansible to configure Windows machines.
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Moreover, in Azure, you can also use a custom script VM extension, which is
    another alternative to configuring VMs using a script. In this case, you can provision
    this VM extension with Terraform using the `azurerm_virtual_machine_extension` resource,
    as explained in the following documentation: [https://www.terraform.io/docs/providers/azurerm/r/virtual_machine_extension.html](https://www.terraform.io/docs/providers/azurerm/r/virtual_machine_extension.html)
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Warning: There can only be one custom script extension per VM. Therefore, you
    have to put all the configuration operations in a single script.'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Apart from providing `remote-exec` and the VM extension, another solution is
    to use the `custom_data` property of the Terraform resource, `azurerm_virtual_machine`.
    Documentation pertaining to the `custom_data` property is available at [https://www.terraform.io/docs/providers/azurerm/r/linux_virtual_machine.html#custom_data](https://www.terraform.io/docs/providers/azurerm/r/linux_virtual_machine.html#custom_data),
    and a complete code sample is available at [https://github.com/terraform-providers/terraform-provider-azurerm/blob/master/examples/virtual-machines/linux/custom-data/main.tf](https://github.com/terraform-providers/terraform-provider-azurerm/blob/master/examples/virtual-machines/linux/custom-data/main.tf).
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, by way of another alternative for VM configuration, we can also preconfigure
    the VM image with all the necessary software using **Packer**, which is another
    open source tool from HashiCorp and allows you to create your own VM image using
    JSON or HCL2 (as documented at [https://www.packer.io/guides/hcl](https://www.packer.io/guides/hcl)).
    Once this image is created, in the Terraform VM configuration, we will set the
    name of the image created by Packer instead of the image provided by the Marketplace
    (Azure or other cloud providers). For more information about Packer, read the
    following documentation: [https://www.packer.io/](https://www.packer.io/)
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: Various tutorials and guides are available in the Azure documentation available
    here: [https://docs.microsoft.com/en-us/azure/developer/terraform/create-linux-virtual-machine-with-infrastructure](https://docs.microsoft.com/en-us/azure/developer/terraform/create-linux-virtual-machine-with-infrastructure)
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Building Azure serverless infrastructure with Terraform
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we studied the implementation of the Terraform configuration
    that allows the provisioning of an IaaS (that is, a VM) infrastructure in Azure.
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this recipe, we will stay in the same realm as the previous recipe, but this
    time we will focus on writing the Terraform configuration that is used to provision
    a PaaS serverless infrastructure with the provisioning of an Azure App Service.
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of this recipe is to provision and configure an Azure App Service
    of the Web App type. In addition to provisioning, we will deploy an application
    in this Web App at the same time as it is being provisioned using Terraform.
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Most of the Terraform configuration needed for this recipe has already been
    studied in several recipes in this book. We will just study the Terraform configuration
    needed to deploy the application in this Web App.
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Regarding the application, it must be packaged in a ZIP file that is in the
    format `<appname>_<version>.zip`, such as, for example, `myapp_v0.1.1.zip`, and
    then we will upload this ZIP file in an Azure blob storage. This ZIP file can
    be uploaded either via the command line Azure CLI, as indicated in this documentation, [https://docs.microsoft.com/en-us/cli/azure/storage/blob?view=azure-cli-latest#az-storage-blob-upload](https://docs.microsoft.com/en-us/cli/azure/storage/blob?view=azure-cli-latest#az-storage-blob-upload),
    or via Terraform using the `azurerm_storage_blob` resource, whose documentation
    is available here: [https://www.terraform.io/docs/providers/azurerm/r/storage_blob.html](https://www.terraform.io/docs/providers/azurerm/r/storage_blob.html)
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Terraform configuration we will write in this recipe will use this ZIP file
    in a secure way. The source code for this recipe is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/webapp.](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/webapp)
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to provision a Web App with Terraform:'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copy and paste, in a new Terraform file, the Web App Terraform from [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/sample-app](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/sample-app).
  id: totrans-382
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside this Terraform file, we add a new `azurerm_storage_account` data block with
    the following code:'
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we add another `azurerm_storage_account_sas` data block to get a security
    token with the following extract code:'
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The complete code of this block is available at [https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/webapp/main.tf](https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/webapp/main.tf).
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we update the code of the Azure Web App in `azurerm_app_resource`
    by adding the following code:'
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works…
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, we retrieved the Terraform configuration that allows a Web App
    to be provisioned. In the following steps of the recipe, we will complete it in
    order to be able to deploy a web application directly in this Web App, with Terraform,
    at the same time as its provisioning.
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, in *step 2*, we add the `azurerm_storage_account` data block, which will
    allow us to retrieve properties from the Storage Account that contains the ZIP
    file of the application. In *step 3*, we add the `azurerm_storage_account_sas` data
    block, which will return a security token to the blob.
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this token, we indicate that the access will be read-only, and that we only
    give access to the blob service.
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, in *step 4*, we complete the resource `azurerm_app_service` by adding
    in the application settings of the `WEBSITE_RUN_FROM_PACKAGE` key, which contains,
    by way of a value, the complete URL of the ZIP file and in which we concatenated
    the token key returned in the block.
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have studied the possibility of provisioning an Azure Web
    App and deploying it with Terraform. There are, however, several other ways to
    deploy this application in the Web App, as explained in the documentation available
    at [https://docs.microsoft.com/en-us/azure/app-service/deploy-zip](https://docs.microsoft.com/en-us/azure/app-service/deploy-zip).
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will learn in the *Building CI/CD pipelines for Terraform configuration in
    Azure pipelines* recipe in [Chapter 7](905f7886-2827-44fe-af8c-4f9f3e3a9cef.xhtml), *Terraform
    Deep Dive,* how to automate this deployment in a CI/CD pipeline in Azure Pipelines.
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation pertaining to the `WEBSITE_RUN_FROM_PACKAGE` app setting of a
    Web App is available here: [https://docs.microsoft.com/en-us/azure/app-service/deploy-run-package](https://docs.microsoft.com/en-us/azure/app-service/deploy-run-package)
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation pertaining to the `azurerm_storage_account_sas` block data is
    available here: [https://www.terraform.io/docs/providers/azurerm/d/storage_account_sas.html](https://www.terraform.io/docs/providers/azurerm/d/storage_account_sas.html)
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation pertaining to the Terraform resource, `azurerm_app_service`, is
    available here: [https://www.terraform.io/docs/providers/azurerm/r/app_service.html](https://www.terraform.io/docs/providers/azurerm/r/app_service.html)
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a Terraform configuration for existing Azure infrastructure
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: When enterprises want to automate their processes and adopt IaC practices (for
    example, with Terraform), they face the challenge of how to generate code for
    an infrastructure that is already provisioned.
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Indeed, for new infrastructures, it is sufficient to write the corresponding
    Terraform configuration and then execute it in order to provision it. On the other
    hand, for resources that are already provisioned, depending on their number and
    configuration, it can be long and tedious to write all the Terraform configuration
    and then execute it to also have the corresponding Terraform state file. In addition,
    this execution of the Terraform configuration can have side effects on these resources,
    which may already be being faced in production.
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As a partial answer to this problem, we have seen in the *Importing existing
    resources* recipe from [Chapter 4](fc591e87-b893-40fa-9021-7827bffcc094.xhtml),
    *Using the Terraform CLI*, that we can use the `terraform import` command to import
    the configuration of already provisioned resources into the Terraform state file.
    However, this command requires that, on the one hand, the corresponding Terraform
    configuration is already written, because this command only updates the Terraform
    state file, and on the other, this command must be executed in order for each
    resource to be imported.
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With this in mind, and having already had this request from many clients, I
    asked myself the question: Are there tools or scripts that can be used to generate
    Terraform configuration and its Terraform state file for resources already provisioned
    in Azure?'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this recipe, I'm going to share the results of my investigation with you
    using one of the Terraform configuration generation tools, called **Terraformer**,
    which is hosted in the GitHub repo of Google Cloud Platform, at [https://github.com/GoogleCloudPlatform/terraformer](https://github.com/GoogleCloudPlatform/terraformer).
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use **Terraformer**, you must first download the version corresponding to
    the Terraform provider whose code you wish to generate. In our case, we want to
    generate the Terraform configuration for an Azure infrastructure, so we run the
    following Linux script:'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This script downloads the **Terraformer** ZIP package. Unzip it and then copy
    it inside the `/usr/local/bin` local folder.
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For this recipe, we will work on a Linux Terminal, but Terraformer works the
    same way for Windows, as described in the following documentation: [https://github.com/GoogleCloudPlatform/terraformer#installation](https://github.com/GoogleCloudPlatform/terraformer#installation)
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once installed, its installation can be checked by executing the `terrafor``mer
    --help` command, and the list of Terraformer commands is displayed:'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/fa822e2d-fc51-4ff0-b7a9-5695eb231507.png)'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The purpose of this recipe is to generate the Terraform configuration and the
    Terraform state file of an Azure infrastructure, which is composed of several
    Resource Groups, as shown in the following screenshot:'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/42b86fd9-38f5-47aa-a800-208b8d579817.png)'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: For the purpose of this recipe, we will limit the generation of the Terraform
    configuration just to these Resource Groups and not to their contents.
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-418
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To generate a Terraform configuration using **Terraformer**, perform the following
    steps:'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the folder that will contain the generated code, we create a `provider.tf`
    file with the code of the Terraform provider declared as following:'
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the command-line terminal, in this folder, we need to download the `azurerm`
    provider by running the `terraform init` command.
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then set the four Azure environment variables for Terraform authentication:'
  id: totrans-423
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we generate the Terraform configuration by executing the following **Terraformer**
    command:'
  id: totrans-425
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once the Terraform configuration and Terraform state file are generated, we
    will navigate the generated code in the `generate/azurerm` folder and add the
    `features {}` expression to the `provider.tf` file as follows:'
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, in this folder, we will test the configuration generated by running
    the basic Terraform workflow with the `terraform init` and `terraform plan` commands:'
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/223a55d4-3543-49fd-a920-4ee53017076c.png)'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: If the output is generated successfully, we should see that the configuration&
    generated doesn't apply any changes. It corresponds to our infrastructure exactly.
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-432
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, we created a file that contains the provider declaration to download.
    Then, we downloaded it with the `terraform init` command we execute in the second
    step.
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Step 3* corresponds to the set of environment variables for Azure authentication
    that we detailed in the *Protecting the Azure credential provider* recipe of this
    chapter. Then, in *step 4*, we used Terraformer to generate the Terraform configuration
    and Terraform state files for the provisioned Azure group resources and, in the
    command line used, we specified the following options:'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`resources`: This is the list of Azure resources for which Terraform configuration
    must be generated.'
  id: totrans-435
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compact`: This enables specification of the fact that all the Terraform configurations
    will be generated in a single file.'
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path-pattern`: This specifies the pattern of the folder that will contain
    the generated code.'
  id: totrans-437
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the execution of Terraformer:'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/9ab5f06d-5afa-489d-b72d-85cabb7863ef.png)'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The `generated/azurerm` folder is created with the Terraform files, as shown
    in the following screenshot:'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/675ba3c8-a9c2-4fd7-94c1-c93a6fa1ef60.png)'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'In this folder, we see the following generated files:'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Terraform configuration `.tf` files – `resources.tf`, `provider.tf`, `outputs.tf`,
    and `variables.tf`
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `tfstate` file – `terraform.tfstate`
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In *step 5*, we added the `features {}` expression to the provider declaration
    that was generated in the `generated/azurerm` folder.
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, in *step 6*, we verified that the generated code is the infrastructure
    code by executing a preview of the changes with the execution of the `terraform
    plan` command. During its execution, no changes will be applied. The Terraform
    configuration is well in line with our infrastructure.
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: Terraformer also contains an option that allows a dry run to preview the code
    that will be generated.
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To do this, we will execute the following command that generates a `plan.json`
    file, along with a description of the resources that will be generated:'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We visualize the content of this created JSON file to check its conformity
    and then, in order to carry out the generation, we execute the following command:'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Moreover, before using Terraformer, it is necessary to check that the resources
    to be generated are well supported. For example, in the case of Azure, the list
    of resources is available here: [https://github.com/GoogleCloudPlatform/terraformer#use-with-azure](https://github.com/GoogleCloudPlatform/terraformer#use-with-azure).
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, among the other Terraform configuration generation tools, there is
    a very good tool called **az2tf** ([https://github.com/andyt530/py-az2tf](https://github.com/andyt530/py-az2tf))
    that used to work on the same Terraformer principle, but unfortunately, this tool
    is no longer maintained. There is also **TerraCognita** ([https://github.com/cycloidio/terracognita/](https://github.com/cycloidio/terracognita/)),
    which still integrates a number of resources for Azure, and **Terraforming** ([https://github.com/dtan4/terraforming](https://github.com/dtan4/terraforming)),
    which is only operational for AWS. The problem with all these tools is that they
    have to follow the evolution of the Terraform language and also the evolution
    of different providers, which requires a lot of development and maintenance time.
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  id: totrans-455
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: The source code and the documentation for Terraformer is available here: [https://github.com/GoogleCloudPlatform/terraformer](https://github.com/GoogleCloudPlatform/terraformer).
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
