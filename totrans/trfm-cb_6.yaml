- en: Provisioning Azure Infrastructure with Terraform
  prefs: []
  type: TYPE_NORMAL
- en: Terraform contains a multitude of providers that enable the provisioning of
    various types of infrastructure, whether in the cloud or on-premise.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters of this book, we have studied the basic concepts of
    the Terraform language, as well as the main Terraform commands line and we have
    seen the sharing of Terraform configuration using modules. In addition, all the
    recipes we have seen in the previous chapters are generic and can be used by all
    Terraform providers.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on using Terraform to provision a cloud infrastructure
    in Azure. We will start with its integration into Azure Cloud Shell, its secure
    authentication, and the protection of the Terraform state file in an Azure storage.
    You will learn how to run ARM templates and Azure CLI scripts with Terraform and
    how to retrieve the Azure resource list with Terraform. Then we'll look at how
    to protect sensitive data in Azure Key Vault using Terraform. We will write two
    case studies in Azure, with the first showing the provisioning and configuration
    of an IaaS infrastructure consisting of VMs, and the second showing the provisioning
    of a PaaS infrastructure in Azure. Finally, we will go further with the generation
    of Terraform configuration from an already existing infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Terraform in Azure Cloud Shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting the Azure credential provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting the state file in the Azure remote backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing ARM templates in Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing Azure CLI commands in Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Azure Key Vault with Terraform to protect secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a list of Azure resources in Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provisioning and configuring an Azure VM with Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Azure serverless infrastructure with Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a Terraform configuration for existing Azure infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To apply the recipes in this chapter, you must have an Azure subscription. If
    you don't have one, you can create an Azure account for free at this site: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)
  prefs: []
  type: TYPE_NORMAL
- en: The complete source code for this chapter is available here: [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06)
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the Code in Action: [https://bit.ly/2ZmEcnJ](https://bit.ly/2ZmEcnJ)
  prefs: []
  type: TYPE_NORMAL
- en: Using Terraform in Azure Cloud Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](027d2973-b820-4fba-b43e-ee2747a97e6a.xhtml), *Setting Up the
    Terraform Environment*, of this book, we studied the steps involved in installing
    Terraform on a local machine.
  prefs: []
  type: TYPE_NORMAL
- en: In the Azure Shell console, known as **Azure Cloud Shell**, Microsoft has integrated
    Terraform in the list of tools that are installed by default.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to write a Terraform configuration and use Terraform
    in Azure Cloud Shell.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The prerequisite for this recipe is to have an Azure subscription and to be
    connected to this subscription via the Azure portal, which is accessible here: [https://portal.azure.com/](https://portal.azure.com/)
  prefs: []
  type: TYPE_NORMAL
- en: Note that this prerequisite applies to all recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you need to associate your Cloud Shell with an existing Azure Storage
    Account or create a new one, as explained in the following documentation: [https://docs.microsoft.com/en-us/azure/cloud-shell/persisting-shell-storage](https://docs.microsoft.com/en-us/azure/cloud-shell/persisting-shell-storage).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to use Terraform in Azure Cloud Shell, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Azure portal, open Azure Cloud Shell by clicking the Cloud Shell button
    in the top menu, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0655579d-36a8-4450-b465-49cbe7de0ad9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside the Cloud Shell panel, in the top menu, in the dropdown, choose Bash
    mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/901451f8-5167-4550-8189-fdb7dded47de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Cloud Shell terminal, create a new folder, `demotf`, inside the default `clouddrive` folder
    by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Inside this new folder, enter the `cd clouddrive/demotf` command.
  prefs: []
  type: TYPE_NORMAL
- en: To write a Terraform configuration inside an integrated Visual Studio Code instance,
    execute the `code` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the editor, in the opened blank page, write the Terraform configuration
    with the following sample code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Save this file by using the *Ctrl* + *S* shortcut and name this file `main.tf`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, to apply this Terraform configuration to the Cloud Shell terminal,
    execute the classical Terraform workflow as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we used the integrated environment of Azure Cloud Shell, which
    consists of a command-line terminal that we chose to use in Bash mode. In addition,
    in *steps 5* and *6*, we used the built-in Visual Studio Code editor, using the
    `code` command, to write a Terraform configuration, which also has syntax highlighting
    for Terraform files. And finally, in *step 7*, we used the Terraform client, which
    is already installed in this Cloud Shell environment to provision our infrastructure
    with the execution of the Terraform workflow commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows Azure Cloud Shell with Terraform execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/780438d1-4ed3-4ea2-9053-e52b8de19f69.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see in the preceding screenshot the top panel with the integrated Visual
    Studio Code editor, and, in the bottom panel, the command line with the execution
    of the Terraform command.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we chose the option to edit the Terraform files directly in
    Visual Studio Code, which is in Cloud Shell, but the following alternative options
    are available:'
  prefs: []
  type: TYPE_NORMAL
- en: The Terraform files could be created and edited using the **Vim** tool (Linux
    editor: [https://www.linux.com/training-tutorials/vim-101-beginners-guide-vim/](https://www.linux.com/training-tutorials/vim-101-beginners-guide-vim/)),
    which is built into Cloud Shell.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could also have edited the Terraform files locally on our machine and then
    copied them to the Azure Storage service that is connected to Azure Cloud Shell.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the files are stored in a Git repository, we could also have cloned the repository
    directly into the Cloud Shell storage by running a `git clone` command in the
    Cloud Shell command-line terminal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, regarding Terraform's authentication to perform actions in Azure, we did
    not take any action because Azure Cloud Shell allows direct authentication to
    our Azure subscriptions and Terraform, which is in Cloud Shell, automatically
    inherits that authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if you have several subscriptions, prior to executing the
    Terraform workflow, you have to choose the subscription target by executing the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This chosen subscription then becomes the subscription by default during execution.
    Refer to the documentation at [https://docs.microsoft.com/en-us/cli/azure/account?view=azure-cli-latest#az-account-set](https://docs.microsoft.com/en-us/cli/azure/account?view=azure-cli-latest#az-account-set).
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the version of Terraform that is installed on the Cloud Shell, in
    general, it is the latest public version, which you can check by running the `terraform
    --version` command. You need to check that your Terraform configuration is compatible
    with this version before executing.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as regards the recommended use of Azure Cloud Shell for Terraform,
    it can only be used for development and testing. It cannot be integrated into
    a CI/CD pipeline and uses your personal permissions on Azure to provision resources.
    For this reason, in the next recipe, we will look at how to securely authenticate
    Terraform to Azure.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to this blog post, which also shows the use of Terraform in Azure Cloud
    Shell: [https://cloudskills.io/blog/terraform-azure-01](https://cloudskills.io/blog/terraform-azure-01)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation that explains the use of Azure Cloud Shell: [https://docs.microsoft.com/en-us/azure/cloud-shell/using-cloud-shell-editor](https://docs.microsoft.com/en-us/azure/cloud-shell/using-cloud-shell-editor)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tutorial that shows how to use and configure locally installed Visual Studio
    Code to execute a Terraform configuration in Azure Cloud Shell: [https://docs.microsoft.com/en-us/azure/developer/terraform/configure-vs-code-extension-for-terraform](https://docs.microsoft.com/en-us/azure/developer/terraform/configure-vs-code-extension-for-terraform)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting the Azure credential provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order for the Terraform Azure provider to provision and manipulate resources
    in Azure, the provider must authenticate in Azure using an Azure account and that
    account must have the correct authorizations.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous recipe, we studied how to automatically authenticate the Terraform
    context in Azure Cloud Shell with our personal account and permissions. However,
    in corporate projects, as well as in production, it is very bad practice to use
    your personal account as this could expire, be deleted, or, even worse, be misused.
  prefs: []
  type: TYPE_NORMAL
- en: This is why one of the options we have when running Terraform in Azure is to
    use an **App Registration** account (also known as **Service Principal**) that
    is not linked to a physical person.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will first study the creation of this Service Principal and
    then we will see how to use it securely in order to run a Terraform configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To apply the first part of this recipe, you must have user account creation
    permissions in Azure Active Directory. Moreover, to create this Service Principal,
    we will do it using the command line with the **az cli** tool, documentation relating
    to which is available at [https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest).
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we need to retrieve our ID of the subscription in which resources
    will be provisioned. For this, we can get it in Azure Cloud Shell by running the
    `az account list` command to display our subscription details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b642bbcf-10b9-4f1e-8c64-b0e301684ec4.png)'
  prefs: []
  type: TYPE_IMG
- en: Also, get the `id` property of the subscription concerned.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe comprises two parts, which are as follows: the creation of the
    Service Principal, and the configuration of Terraform authentication using this
    Service Principal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create this Service Principal, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Azure Cloud Shell and execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve all the identification information provided in the output of the previous
    command by making a note (because we won''t be able to retrieve the password after
    closing this console) of `appId`, `password`, and `tenant`, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/21a5185e-24d7-4e3f-a2ab-aa4e1bc04029.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that the Service Principal is created, we can use it to provision Azure
    infrastructure with Terraform by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the command-line terminal, set four new variable environments as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can apply the Terraform configuration by executing the following Terraform
    workflow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the first part of this recipe, we created a Service Principal and gave it
    its permissions on a subscription, using the command line `az ad sp`. To this
    command, we added the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`, which is the name of the Service Principal we''re going to create.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`role`, which is the role that the Service Principal will have on the subscription;
    here, we specify `Contributor`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scopes`, where we specify the Azure ID of the resource on which the Service
    Principal will have contributor permissions. In our case, this is the subscription
    ID in which the resources will be provisioned by Terraform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This command will therefore create the Service Principal with a generated password
    and will give it the `Contributor` role on the specified subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of its execution, this command displays the information of the Service
    Principal, including `AppId`, `password`, and `tenant`. As explained in *step
    2*, we need to retrieve this information and store it in a safe place because
    this password cannot be retrieved later. Then, we check that the Service Principal has
    the permissions on subscription, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea215dd2-f679-4882-93d0-75a9f0f85818.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the second part of this recipe, we used this Service Principal to authenticate
    the Terraform Azure provider. For this, there are several solutions, the most
    secure one being to use specific Azure provider environment variables because
    these environment variables will not be visible in code and will only be persistent
    during the execution session. So, we have set four environment variables, which
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ARM_SUBSCRIPTION_ID`: This contains the Azure subscription ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ARM_CLIENT_ID`: This contains the Service Principal ID, called `AppId`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ARM_CLIENT_SECRET`: This contains the password of the Service Principal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ARM_TENANT_ID`: This contains the ID of the Azure Active Directory tenant.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the recipe, we used the export command of the Linux system. On Windows PowerShell,
    we can use the `$env` command. In addition, in all the recipes in this chapter,
    we will use these environment variables before executing Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Then, once these environment variables are set, we can execute the basic Terraform
    workflow.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regarding the creation of the Service Principal, we made the choice to use the
    Azure CLI tool, but we could also have done it directly via the Azure portal,
    as detailed in the following documentation available at [https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-create-service-principal-portal](https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-create-service-principal-portal),
    or we could have used the Azure PowerShell commands ([https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-authenticate-service-principal-powershell](https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-authenticate-service-principal-powershell)).
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, as regards the configuration of the Terraform Azure provider,
    we have used environment variables, but we can also put this information directly
    into the Terraform configuration, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This solution does not require an extra step (the set of environment variables)
    to be implemented prior to executing the Terraform configuration, but it leaves
    identification information in clear text in the code, and hardcoding credentials
    in code is generally considered a bad practice from the security perspective,
    since the leakage of code also leaks credentials and makes it impossible to share
    the code with anyone without exposing the credentials. And in the case where the
    Terraform configuration provides resources for several environments that are in
    different subscriptions, Terraform variables will have to be added, which can
    add complexity to the code.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the use of environment variables offers the advantage of being easily
    integrated into a CI/CD pipeline while preserving the security of the authentication
    data.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Azure documentation and Terraform configuration is available here: [https://docs.microsoft.com/en-us/azure/developer/terraform/install-configure](https://docs.microsoft.com/en-us/azure/developer/terraform/install-configure)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the configuration of the Azure provider, along with the other
    authentication options, is available here: [https://www.terraform.io/docs/providers/azurerm/index.html](https://www.terraform.io/docs/providers/azurerm/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting the state file in the Azure remote backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When executing the Terraform workflow commands, which are mainly `terraform
    plan`, `terraform apply`, and `terraform destroy`, Terraform has a mechanism that
    allows it to identify which resources need to be updated, added, or deleted. To
    perform this mechanism, Terraform maintains a file called a Terraform state file
    that contains all the details of the resources provisioned by Terraform. This
    Terraform state file is created the first time the `terraform plan` command is
    run and is updated with each action (`apply` or `destroy`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In a enterprise, this file contains certain interesting aspects, which are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Sensitive information on the provisioned resources is mentioned in clear text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If several people are working together, this file must be shared by everyone
    or, by default, this file is created on the local workstation or on the workstation
    that contains the Terraform binary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if it is archived in a Git source code manager, once it is retrieved on
    the local workstation, it does not allow several people to work on the same file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this locally stored file, managing multi-environments can quickly become
    complicated and risky.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any deletion of this local file or poor manual editing can affect the execution
    of Terraform configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A solution to all these problems is the use of a remote backend, which consists
    of storing this file in a remote, shared, and secure store.
  prefs: []
  type: TYPE_NORMAL
- en: In the use of Terraform, there are several types of remote backends, such as
    S3, `azurerm`, Artifactory, and many others, which are listed in the menu on the
    following page: [https://www.terraform.io/docs/backends/types/index.html](https://www.terraform.io/docs/backends/types/index.html)
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will study the use of a remote backend, `azurerm`, in Azure
    by storing this Terraform state file in an Azure Storage Account.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use Azure Cloud Shell and Azure CLI commands to create
    the Storage Account.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this recipe and the script used are available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/remotebackend](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/remotebackend).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe consists of two parts. In the first part, we will create the Storage
    Account, and in the second part, we will configure Terraform to use the `azurerm`
    remote backend:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Azure Cloud Shell, execute the following Azure CLI script (available at [https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/remotebackend/create-backend.sh](https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/remotebackend/create-backend.sh))
    to create the Storage Account with a blob container in the Resource Group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we configure the Terraform state backend by adding the following code
    to the `main.tf` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to execute the Terraform configuration, we set a new environment variable, `ARM_ACCESS_KEY`,
    with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Then, we execute the basic commands of the Terraform workflow.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the first step, we used a script that performs the following actions in
    sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: It creates a Resource Group called `RG-TFBACKEND`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this Resource Group, we use the `az storage account create` command to create
    a Storage Account named `storagetfbackend`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, this script creates a blob container in this Storage Account with the
    `az storage container create` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we retrieve the account key of the Storage Account created and display
    its value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, in *step 2*, we configure Terraform to use this Storage Account as a
    remote backend to store the Terraform state file. In this configuration, which
    is located in a `backend "azurerm"` block, we indicate, on the one hand, the Storage
    Account information, and, on the other, the blob with the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`resource_group_name`: This is the name of the Resource Group that contains
    the Storage Account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`storage_account_name`: This is the name of the Storage Account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container_name`: This is the name of the blob container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`key`: This is the name of the Terraform state file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we define a new environment variable, `ARM_ACCESS_KEY`, that contains
    the account key for the Storage Account we retrieved from the script we ran in
    *step 1*. This variable is used to authenticate the Storage Account. Then, we
    execute the `init`, `plan`, and `apply` commands of Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on what we studied in the previous recipe, *Protecting the Azure credential
    provider*, here is the complete script for executing this Terraform script in
    Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: So, we used the four authentication environment variables, as well as the `ARM_ACCESS_KEY`
    environment variable, for authentication to the Storage Account and we executed
    the Terraform commands.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we used an environment variable to specify the value of the
    access key to protect this sensitive data. We could have specified it in the remote
    backend configuration, using the `access_key` property, as in the following example
    (but as mentioned in the *Protecting the Azure credential provider* recipe of
    this chapter, it isn''t good practice to leave sensitive keys as plain text):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, if our Terraform configuration is designed to be deployed on multiple
    environments, we can create *N* configurations of the `azurerm` backend with the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main.tf` file contains the following code with the `backend "azurerm"`
    block empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We create one `backend.tfvars` file per environment (in a specific folder for
    this environment) with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the execution of the `init` command, we specify the `backend.tfvars`
    file to be used with the following command, as specified in the `init` command
    documentation, which is available at [https://www.terraform.io/docs/backends/config.html#partial-configuration](https://www.terraform.io/docs/backends/config.html#partial-configuration):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finally, if the Service Principal that was used to authenticate with Terraform
    has permissions on this Storage Account, then this environment variable is not
    mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation relating to the `azurerm` remote backend is available here: [https://www.terraform.io/docs/backends/types/azurerm.html](https://www.terraform.io/docs/backends/types/azurerm.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform's learning module with the `azurerm` remote backend is available here: [https://learn.hashicorp.com/terraform/azure/remote_az#azurerm](https://learn.hashicorp.com/terraform/azure/remote_az#azurerm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure documentation relating to the Terraform remote backend is available here: [https://docs.microsoft.com/en-us/azure/developer/terraform/store-state-in-azure-storage](https://docs.microsoft.com/en-us/azure/developer/terraform/store-state-in-azure-storage)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing ARM templates in Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Among all the **Infrastructure as Code** (**IaC**) tools and languages, there
    is one provided by Azure called **Azure Resource Manager** (**ARM**), based on
    JSON format files, that contains the description of the resources to be provisioned.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about ARM templates, read the following documentation: [https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/overview](https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/overview)
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Terraform to provision resources in Azure, you may need to use resources
    that are not yet available in the Terraform `azurerm` provider. Indeed, the `azurerm`
    provider is open source and community-based on GitHub, and has a large community
    of contributors, but this is not enough to keep up with all the changes in Azure''s
    functionalities in real time. This is due to several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: New releases of Azure resources are very frequent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Terraform `azurerm` provider is highly dependent on the Azure Go SDK ([https://github.com/Azure/azure-sdk-for-go](https://github.com/Azure/azure-sdk-for-go)),
    which does not contain real-time Azure updates on new features or even on features
    that are still in preview.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To partially solve this problem, and for organizations that wish to remain in
    full Terraform, there is a Terraform `azurerm_template_deployment` resource that
    allows you to execute ARM code using Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will discuss the execution of ARM code with Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Terraform configuration of this recipe will provision an Azure App Service
    that includes an extension. Since the extension App Service resource is not available
    in the `azurerm` provider at the time of writing this book, the Azure App Service
    code will be written in **HashiCorp Configuration Language** (**HCL**), and its
    extension will be provisioned using an ARM template that will be executed with
    Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the recipe is not to detail the code of the ARM template of the
    extension but to study its execution with Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will present only the key code extracts. The complete source
    code for this chapter is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/arm-template.](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/arm-template)
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To execute the ARM template with Terraform, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the folder that will contain the Terraform configuration, create a new
    file called `ARM_siteExtension.json`, which contains the following extract ARM
    JSON template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The complete source code of this file is available here: [https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/arm-template/ARM_siteExtension.json](https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/arm-template/ARM_siteExtension.json)
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main.tf` file, add the following Terraform extract code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The complete source code of this file is available here: [https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/arm-template/main.tf](https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/arm-template/main.tf)
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can execute the basic Terraform workflow with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Authentication with four Azure variable environments, as discussed in the *Protecting
    the Azure credential provider* recipe of this chapter
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The execution of the `init`, `plan` and `apply` commands, as mentioned previously
    and in earlier chapters
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *step 1*, in the directory that contains the Terraform configuration, we
    created a JSON file that contains the ARM code for creating an extension for a
    App Service. In this ARM file, we have the following three input parameters:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`appserviceName`: This corresponds to the name of the App Service.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extensionName`: This corresponds to the name of the extension to be added
    (from the extension catalog).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extensionVersion`: This corresponds to the version of the extension to be
    added.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, the rest of this file describes the site extension resource to be added
    in Azure using the three parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, in *step 2*, in the Terraform configuration, we used the Terraform resource
    `azurerm_template_deployment`, which allows execution of an ARM template with
    the following properties:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`template_body`: This is the ARM code in JSON format. Here, in our example,
    we used the file function to indicate that it is a file.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parameters`: In this block, we fill in the input properties of the ARM template,
    which are `appserviceName`, `extensionName`, and `extensionVersion`. In our recipe,
    we install the `AspNetCoreRuntime.2.2.x64` extension of version `2.2.0-preview3-35497`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, to provision this Azure App Service and its extension, the Terraform
    workflow commands are executed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following screenshot shows the result in the Azure portal:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/c70f15ab-b3f2-483c-b3cf-e2d03f368600.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We can see the extension provisioned inside the App Service.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have studied the possibility of running an ARM template with
    Terraform. This method allows you to provision elements in Azure that are not
    available in the `azurerm` provider, but it is important to know that Terraform
    knows the resources described in this ARM template when it is executed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That is to say that these resources (here, in our resource, it is the extension)
    do not follow the life cycle of the Terraform workflow and are not registered
    in the Terraform state file. The only thing that is written in the Terraform state file
    is the configuration of the resource, `azurerm_template_deployment`, and, as a
    consequence, for example, if you run the `terraform destroy` command on the Terraform
    configuration, these resources provided by the ARM template will not be destroyed.
    Instead, only the `azurerm_template_deployment` resource will be removed from
    Terraform state file. For this reason, it is advisable that you use this type
    of deployment only to complete resources that have been provisioned with Terraform
    HCL code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This indeed was our case, since the extension is an integrated complement to
    the App Service, and if we run `terraform destroy`, the App Service will be destroyed
    as well as all its extensions that are integrated in it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have seen the impact on the `destroy` command, but it is the same problem
    on other commands, such as the `plan`, `import`, or `refresh` commands. The resources
    provided by the ARM template are not known by Terraform.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In addition, the use of an ARM template in Terraform is only effective for a
    complete ARM resource, as is the case here with an extension, which can be executed
    as is with the ARM scripts provided by Azure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the next recipe, we will stay on the same topic, but instead of using an
    ARM template, we will see how to use Azure CLI commands with Terraform.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation pertaining to the `azurerm_template_deployment` resource of the
    `azurerm` provider is available here: [https://www.terraform.io/docs/providers/azurerm/r/template_deployment.html](https://www.terraform.io/docs/providers/azurerm/r/template_deployment.html)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A blog article that also explains how to get the JSON code of the ARM template
    is available at [https://www.phillipsj.net/posts/applying-azure-app-service-extensions-with-arm/](https://www.phillipsj.net/posts/applying-azure-app-service-extensions-with-arm/).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing Azure CLI commands in Terraform
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we studied how to run ARM templates with Terraform in
    a situation where the provisioned resource is not yet available in the `azurerm`
    provider.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'However, there are cases where the use of an ARM template is not possible,
    such as the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We want to fill in one or more properties of a resource, which are not autonomous
    in an ARM template.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The ARM template is not available for the resource to be provisioned.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For these situations, there is another solution that entails executing Azure
    CLI commands with Terraform.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This recipe is a practical application of the *Executing local programs with
    Terraform* recipe from [Chapter 2](3099c9ac-8c38-4e7d-8146-411fac26a2b7.xhtml),
    *Writing Terraform Configuration*. We will study the Terraform configuration and
    its execution to integrate Azure CLI commands with Terraform.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, it is necessary to have read beforehand the *Executing local
    programs with Terraform* recipe from [Chapter 2](3099c9ac-8c38-4e7d-8146-411fac26a2b7.xhtml),
    *Writing Terraform Configuration*, which provides the basis of the Terraform configuration
    we are going to write.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Moreover, it will also be necessary to have already installed the Azure CLI
    tool, documentation pertaining to which is available here: [https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To demonstrate the use of the Azure CLI command in Terraform, in this recipe, we
    will set up an Azure Storage Account by configuring the properties of a static
    website feature on it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As with the previous recipe, the purpose of this recipe is to show how to use
    Azure CLI commands with Terraform, but we will not focus on the Azure CLI command
    used because, since version 2.0.0 of the `azurerm` provider, the properties of
    a static website have been added to the Terraform resource ([https://github.com/terraform-providers/terraform-provider-azurerm/blob/master/CHANGELOG-v2.md#200-february-24-2020](https://github.com/terraform-providers/terraform-provider-azurerm/blob/master/CHANGELOG-v2.md#200-february-24-2020)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The source code for this recipe is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/az%20cli](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/az%20cli).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to execute Azure CLI commands with Terraform:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `main.tf` file that contains the Terraform code, write the following
    configuration for provision to the Storage Account:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same Terraform configuration, add the code to configure the static website
    using the Azure CLI command:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, in our command-line terminal, we log in to Azure by executing the following
    command:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can execute the basic Terraform workflow with the following:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Authentication with four Azure variable environments, as discussed in the *Protecting
    the Azure credential provider* recipe of this chapter
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The execution of the `init`, `plan`, and `apply` commands, as mentioned previously
    and in earlier chapters
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, there is nothing special. We just wrote the Terraform configuration
    to provision a `StorageV2` Storage Account, which is required to activate the
    static website feature.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In *step 2*, we completed this code by adding `null_resource` that contains
    a `local-exec` provisioner. In the command property of `local-exec`, we put the
    command Azure CLI that must be executed to activate and configure the static website
    functionality on the Storage Account we wrote in *step 1*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We added the trigger block with the name of the storage as an argument, so that
    if the name of the storage changes, then provisioning will be re-executed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, in *step 3*, we executed the `az login` command to authenticate the context
    of the Azure CLI. On this command, we added the authentication parameters with
    a Service Principal (see the *Protecting the Azure credential provider *recipe
    in this chapter), as documented here: [https://docs.microsoft.com/en-us/cli/azure/create-an-azure-service-principal-azure-cli?view=azure-cli-latest#sign-in-using-a-service-principal](https://docs.microsoft.com/en-us/cli/azure/create-an-azure-service-principal-azure-cli?view=azure-cli-latest#sign-in-using-a-service-principal).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the implementation of this recipe, there are two important points:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first point is that we used `null_resource` with the `local-exec` provisioner
    that we had already studied in detail in the *Executing local programs with Terraform* recipe
    from[ Chapter 2](3099c9ac-8c38-4e7d-8146-411fac26a2b7.xhtml), *Writing Terraform
    Configuration*. The only novelty brought here is the fact that the executed command
    is an Azure CLI command. It could also be a file that contains a script with several
    Azure CLI commands.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second point is that Terraform's authentication for Azure with the four
    environment variables does not allow authentication of the Azure CLI context that
    will be executed by Terraform. This is why, in *step 3*, we also had to authenticate
    the Azure CLI context with the `az login` command by passing the credentials of
    the Service Principal as parameters.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantage of executing Azure CLI commands in this way is that we can integrate
    the variables and expressions of the Terraform language into them, just as we
    did when we passed the name of the Storage Account as a parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that, as with any local provisioner, this restricts where the configuration
    can be applied as it assumes existence of the Azure CLI (the Azure CLI becomes
    a hidden dependency).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As with the ARM templates, we learned in the previous recipe, *Executing ARM
    templates in Terraform*, that Terraform does not know the resources manipulated
    in the Azure CLI command or script. These resources do not follow the Terraform
    life cycle and are not registered in the Terraform state file. On the other hand,
    in the `local-exec` provisioner of `null_resource`, we can specify a command to
    be executed in the case of execution of the `terraform destroy` command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following is an example of the configuration that I used to create a CosmosDB
    database (before the `azurerm` provider supported it) that demonstrates the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, in the provisioner, we used the `When=destroy` property to
    specify that the Azure CLI command, `az cosmosdb database delete`, will be executed
    to delete the CosmosDB database in the case of `terraform destroy`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation pertaining to the `az login` command and its parameters is available
    here: [https://docs.microsoft.com/en-us/cli/azure/authenticate-azure-cli?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/authenticate-azure-cli?view=azure-cli-latest)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation pertaining to the Terraform `provisioner` is available here: [https://www.terraform.io/docs/provisioners/index.html](https://www.terraform.io/docs/provisioners/index.html)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation pertaining to the `when` property of `provisioner` is available
    here: [https://www.terraform.io/docs/provisioners/index.html#destroy-time-provisioners](https://www.terraform.io/docs/provisioners/index.html#destroy-time-provisioners)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Azure Key Vault with Terraform to protect secrets
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the challenges of IaC is the protection of sensitive information that
    is part of the infrastructure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Indeed, one of the advantages of IaC is the possibility to version the code
    in a Git repository and so this code benefits from the Git workflow of versioning
    and validation of the code. However, with this approach, we tend to write *everything*
    in this code, sometimes forgetting that some data that is sensitive, such as passwords
    or login strings, can be misused if they end up in the wrong hands.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this recipe, we will study how to protect this sensitive data by storing
    it in Azure's secret manager, which is Azure Key Vault, and then using it in the
    Terraform configuration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we assume the use of Azure Key Vault. For more information,
    you can refer to the following documentation available at [https://docs.microsoft.com/en-us/azure/key-vault/](https://docs.microsoft.com/en-us/azure/key-vault/).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In an Azure Key Vault that we have created in Azure, as regards the application
    of this recipe, we store a secret that protects the connection string of the SQL
    Server database of our application hosted in an Azure web application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This connection string is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the output of the Azure CLI command, `az keyvault secret show`, which
    shows its storage and properties in Azure Key Vault:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/258b1b3b-f223-4e5f-a3c8-df790a793bb5.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: In the preceding screenshot, we can see the connection string of the database
    stored in the `value` property of the `secret` object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The goal of this recipe is to write the Terraform configuration that requests
    the value of this secret to use it in the properties of an Azure App Service.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The source code for this recipe is available here: [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/keyvault](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/keyvault)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get and use an Azure Key Vault secret in Terraform, perform the following
    steps:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In Azure Key Vault, we add access policy properties by granting the Service
    Principal that will be used by Terraform for Azure to have permission to get and
    list secrets:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e317dc9a-9653-4b99-a7a2-aa0dddc28884.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'In the `main.tf` file, we add the following code to get the Key Vault secret:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, in the Terraform configuration of the App Service resource, in the `main.tf`
    file, we add the following code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we run the basic Terraform workflow for Azure with set variable environments
    and execute `init`, `plan`, and `apply`, as mentioned previously and in earlier
    chapters.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, we gave permission to the Service Principal used by Terraform to
    read and list the secrets of Azure Key Vault.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can do this either via the Azure portal or on the command line with the Azure
    CLI, as explained in the following documentation: [https://docs.microsoft.com/en-us/cli/azure/keyvault?view=azure-cli-latest#az-keyvault-set-policy](https://docs.microsoft.com/en-us/cli/azure/keyvault?view=azure-cli-latest#az-keyvault-set-policy)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we had not carried out this step, we would have obtained the following error
    when executing the `terraform plan` command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/caeee7cf-93b8-4b4d-856c-c52fcae7cd0e.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Then, in *step 2*, we wrote the Terraform configuration, which contains two
    data sources:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first data source, `azurerm_key_vault`, enables retrieval of the Azure ID
    of the Azure Key Vault resource.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second data source, `azurerm_key_vault_secret`, is used to retrieve the
    secret that contains the database connection string as a value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information about Terraform block data, read the *Using external resources
    with a data block* recipe from [Chapter 2](3099c9ac-8c38-4e7d-8146-411fac26a2b7.xhtml),
    *Writing Terraform Configuration*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In *step 3*, we continue with the writing of the Terraform configuration, putting
    in the property value of the `connection_string` block of the App Service with
    the expression `data.azurerm_key_vault_secret.app-connectionstring.value`, which
    is the value obtained from the block data, `azurerm_key_vault_secret`, written
    in *step 2*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, in the last step, we execute this Terraform configuration. During this
    operation, Terraform will first retrieve the values requested in the block data
    (Key Vault, and then the Key Vault secret) and will then inject the value obtained
    from the secret into the configuration of the App Service.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This result is obtained in Azure and shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/7bc29f65-1ee9-42a8-8e90-40c052927723.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We can see that the connection string is well filled in the App Service configuration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: We have learned in this recipe that the connection string, which is sensitive
    data, has been stored in Azure Key Vault and will be used automatically when Terraform
    is run. So, thanks to Azure Key Vault, we didn't need to put the sensitive data
    in clear text in the Terraform configuration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'However, care should still be taken. Although this data is not written in plain
    text in the Terraform configuration, it will be written in plain text in the Terraform
    state file, as can be seen in this extract of the Terraform state file content
    from this recipe:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/da59826f-3dd9-46fa-819a-195eeed80248.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'That is why, if we need to inspect the contents of this file, it is recommended
    to use the `terraform state show` or `terraform show` commands, which protect
    the displaying of sensitive data, as can be seen in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/4526cc47-cc0b-41b0-a4a6-c809d60a189a.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: This is one of the reasons why it is necessary to protect this `tfstate` file
    by storing it in a secure remote backend, as we have seen in the *Protecting the
    state file in the Azure remote backend* recipe of this chapter, and which is explained
    in the following documentation: [https://www.terraform.io/docs/state/sensitive-data.html](https://www.terraform.io/docs/state/sensitive-data.html)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Also in this recipe, although we stored the sensitive data in Azure Key Vault,
    we can also store it in a HashiCorp Vault instance that integrates very well with
    Terraform. For this, it is advisable that you read the vault provider documentation here: [https://www.terraform.io/docs/providers/vault/index.html](https://www.terraform.io/docs/providers/vault/index.html)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, as a prerequisite for this recipe, we manually created the secret of
    the connection string in Azure Key Vault. This could have been done either with
    Terraform, as documented here ([https://www.terraform.io/docs/providers/azurerm/r/key_vault_secret.html](https://www.terraform.io/docs/providers/azurerm/r/key_vault_secret.html)),
    or with the Azure CLI commands, as documented here ([https://docs.microsoft.com/en-us/cli/azure/keyvault/secret?view=azure-cli-latest#az-keyvault-secret-set](https://docs.microsoft.com/en-us/cli/azure/keyvault/secret?view=azure-cli-latest#az-keyvault-secret-set)).
    On the other hand, in this case, since the data will be written in clear text
    in the code, it will be necessary to secure it well by giving read and write permissions
    only to authorized persons.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation on the block data, `azurerm_key_vault_secret`, is available here: [https://www.terraform.io/docs/providers/azurerm/d/key_vault_secret.html](https://www.terraform.io/docs/providers/azurerm/d/key_vault_secret.html)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a list of Azure resources in Terraform
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learned the practical case of using a `data` block
    to obtain the properties of an Azure resource.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will look in this recipe at a data source in the `azurerm` provider that
    is generic and allows you to get information about any provisioned resource in
    Azure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will write a Terraform configuration that adds security rules
    to several Azure **Network Security Groups** (**NSGs**) already provisioned (manually
    or by Terraform). Its purpose is to add these rules to all NSGs that have the
    tag `DEFAULTRULES=TRUE`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In addition, we have already created three NSGs in the Resource Group called
    `RG-DEMO`. Among these NSGs, only NSG1 and NSG2 have the tag `DEFAULTRULES=TRUE`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The source code for this recipe is available here: [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/listresources](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/listresources)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps in order to get Azure resources:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `main.tf` file that contains the Terraform configuration, add the following
    code to get provisioned NSGs:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, in the same file, add the following code to create rules:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we run the basic Terraform workflow for Azure with set variable environments
    and execute `init`, `plan`, and `apply`, as mentioned previously and in earlier
    chapters.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *step 1*, we used the `azurerm_resources` data object, which allows you
    to obtain the basic properties of any already provisioned Azure resource. To this
    object, we configured the following properties:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`type`: This is the type of resource to request. The list of types is documented
    here: [https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-services-resource-providers](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-services-resource-providers).
    Here, we filled in the value `Microsoft.Network/networkSecurityGroups`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource_group_name`: This is the name of the Resource Group in which the
    NSGs have been provisioned.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required_tag`: This is the list of tags on which we want to filter NSGs.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, in *step 2*, we completed this Terraform configuration by adding the `azurerm_network_security_rule`
    resource, which enables the provision of rules in already existing NSGs. In this
    resource, we first added the expression `for_each`, which facilitates a loop on
    all NSGs that are returned from the previously instantiated data block. In the
    construction of this loop, we used the expression `data.azurerm_resources.nsg.resources`,
    which contains a list of NSGs retrieved from the `data` block. Moreover, in the
    `name` property, we add a prefix, which is the name of the NSG, using the expression
    `each.key`. Finally, in the `network_security_group_name` property, we also use
    `each.key` as the name of each NSG iterated in the loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For more information on the `for_each` expression and loops in Terraform, refer
    to the recipes in [Chapter 3](d019fed0-6c22-4da8-9796-58d45feafa2c.xhtml), *Building
    Dynamic Environments with Terraform*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, in *step 3*, we execute the Terraform workflow commands to apply this
    Terraform configuration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: We have learned in this recipe that by using `azurerm_resources`, in Terraform, we
    can use any Azure resource that is already provisioned.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the Terraform configuration, we can also add the following `output` variable,
    which allows a visualization of the resources returned by the `azurerm_resource` data
    block:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot shows the result of this output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/c68faccb-d32d-4c8b-87fc-76a42d1695e8.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We can see in this output result that the `data` block has recovered the two
    NSGs that are provisioned and has the tag `DEFAULTRULEs=TRUE`. Moreover, you can
    also see the properties of each resource that it is possible to exploit in the
    rest of the Terraform configuration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: However, it must be ensured that these resources are provisioned in the same
    subscription as defined in the environment variable, `ARM_SUBSCRIPTION_ID`, which
    is set before executing the Terraform commands, as we have seen in the *Protecting
    the Azure credential provider* recipe of this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation pertaining to the `azurerm_resources` object data of Terraform
    is available here: [https://www.terraform.io/docs/providers/azurerm/d/resources.html](https://www.terraform.io/docs/providers/azurerm/d/resources.html)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Provisioning and configuring an Azure VM with Terraform
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will study a typical use case of Terraform in Azure in which
    we will provision and configure a VM in Azure using Terraform.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we don''t need any special prerequisites. We will start the
    Terraform configuration from scratch. This recipe will only involve writing the
    Terraform configuration. In its stages of realization, we will study the writing
    of this code. As for the architecture in Azure, we have already built a network
    beforehand, which will contain this VM and which is made up of the following resources:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A **virtual network** (**VNet**) called `VNET-DEMO`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside this VNet, a Subnet named `Subnet1` is registered.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, the VM that will be provisioned will have a public IP address so
    that it can be accessed publicly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, in keeping the VM's password secret in the code, we protect it in an
    Azure Key Vault, as studied in the *Using Azure Key Vault with Terraform to protect
    secrets* recipe of this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The source code for this chapter is available here: [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/vm](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/vm)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Write the following Terraform configuration to provision a VM with Terraform:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The first resource to build is the Resource Group, with the help of the following
    code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we write the following code to provision the public IP:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We continue by writing the code for the Network Interface:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We get the VM password by using the `keyvault` data block:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we write the code for the VM resource, as follows:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete source code for these VM resources is available at [https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/vm/main.tf](https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/vm/main.tf).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, we wrote the Terraform configuration that will create the Resource
    Group containing the VM. This step is optional because you can provision the VM
    in an existing Resource Group, and in this case you can use the `azurerm_resource_group`
    block data, whose documentation is available here: [https://www.terraform.io/docs/providers/azurerm/d/resource_group.html](https://www.terraform.io/docs/providers/azurerm/d/resource_group.html)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, in *steps 2* and *3*, we wrote the Terraform configuration that provides
    the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A public IP of the dynamic type, so that we don't have to set the IP address
    (this IP address will be the first free address of the subnet).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Network Interface of the VM that uses this IP address, and which will register
    in the Subnet that has already been created. To retrieve the subnet ID, we used
    an `azurerm_subnet` data source.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In *step 4*, we use the `azurerm_key_vault_secret` data source to get the password
    of the VM (refer to the *Using Azure Key Vault with Terraform* *to protect secrets*
    recipe for more details).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, in *step 5*, we write the code that will provision the VM. In this
    code, we have defined the following properties of the VM:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Its name and size (which includes its RAM and CPU)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic image used, which is an Ubuntu image
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication information for the VM with a login and a password (an SSH key
    can also be used)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In this resource, we also added a `remote-exec` provisioner, which allows you
    to remotely execute commands or scripts directly on the VM that will be provisioned.
    The use of this provisioner will allow you to configure the VM for administration,
    security, or even middleware installation tasks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: The interesting and new aspect of this recipe is the addition of the `remote-exec`
    provisioner, which enables configuration of the VM using commands or scripts.
    This method can be useful in performing the first steps of VM administration,
    such as opening firewall ports, creating users, and other basic tasks. Here in
    our recipe, we used it to update the packages with the execution of the `apt update`
    command. However, this method requires that this VM is accessible from the computer
    running Terraform because it connects to the VM (SSH or WinRM) and executes the
    commands.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you want to keep a real IaC, it is preferable to use an as-code configuration
    tool, such as Ansible, Puppet, Chef, or PowerShell DSC. And so, in the case of
    using Ansible to configure a Windows VM, the `remote-exec` provisioner can perfectly
    serve to authorize the WinRM SSL protocol on my VM because this port is the port
    used by Ansible to configure Windows machines.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Moreover, in Azure, you can also use a custom script VM extension, which is
    another alternative to configuring VMs using a script. In this case, you can provision
    this VM extension with Terraform using the `azurerm_virtual_machine_extension` resource,
    as explained in the following documentation: [https://www.terraform.io/docs/providers/azurerm/r/virtual_machine_extension.html](https://www.terraform.io/docs/providers/azurerm/r/virtual_machine_extension.html)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Warning: There can only be one custom script extension per VM. Therefore, you
    have to put all the configuration operations in a single script.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Apart from providing `remote-exec` and the VM extension, another solution is
    to use the `custom_data` property of the Terraform resource, `azurerm_virtual_machine`.
    Documentation pertaining to the `custom_data` property is available at [https://www.terraform.io/docs/providers/azurerm/r/linux_virtual_machine.html#custom_data](https://www.terraform.io/docs/providers/azurerm/r/linux_virtual_machine.html#custom_data),
    and a complete code sample is available at [https://github.com/terraform-providers/terraform-provider-azurerm/blob/master/examples/virtual-machines/linux/custom-data/main.tf](https://github.com/terraform-providers/terraform-provider-azurerm/blob/master/examples/virtual-machines/linux/custom-data/main.tf).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, by way of another alternative for VM configuration, we can also preconfigure
    the VM image with all the necessary software using **Packer**, which is another
    open source tool from HashiCorp and allows you to create your own VM image using
    JSON or HCL2 (as documented at [https://www.packer.io/guides/hcl](https://www.packer.io/guides/hcl)).
    Once this image is created, in the Terraform VM configuration, we will set the
    name of the image created by Packer instead of the image provided by the Marketplace
    (Azure or other cloud providers). For more information about Packer, read the
    following documentation: [https://www.packer.io/](https://www.packer.io/)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: Various tutorials and guides are available in the Azure documentation available
    here: [https://docs.microsoft.com/en-us/azure/developer/terraform/create-linux-virtual-machine-with-infrastructure](https://docs.microsoft.com/en-us/azure/developer/terraform/create-linux-virtual-machine-with-infrastructure)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Building Azure serverless infrastructure with Terraform
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we studied the implementation of the Terraform configuration
    that allows the provisioning of an IaaS (that is, a VM) infrastructure in Azure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this recipe, we will stay in the same realm as the previous recipe, but this
    time we will focus on writing the Terraform configuration that is used to provision
    a PaaS serverless infrastructure with the provisioning of an Azure App Service.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of this recipe is to provision and configure an Azure App Service
    of the Web App type. In addition to provisioning, we will deploy an application
    in this Web App at the same time as it is being provisioned using Terraform.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Most of the Terraform configuration needed for this recipe has already been
    studied in several recipes in this book. We will just study the Terraform configuration
    needed to deploy the application in this Web App.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Regarding the application, it must be packaged in a ZIP file that is in the
    format `<appname>_<version>.zip`, such as, for example, `myapp_v0.1.1.zip`, and
    then we will upload this ZIP file in an Azure blob storage. This ZIP file can
    be uploaded either via the command line Azure CLI, as indicated in this documentation, [https://docs.microsoft.com/en-us/cli/azure/storage/blob?view=azure-cli-latest#az-storage-blob-upload](https://docs.microsoft.com/en-us/cli/azure/storage/blob?view=azure-cli-latest#az-storage-blob-upload),
    or via Terraform using the `azurerm_storage_blob` resource, whose documentation
    is available here: [https://www.terraform.io/docs/providers/azurerm/r/storage_blob.html](https://www.terraform.io/docs/providers/azurerm/r/storage_blob.html)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Terraform configuration we will write in this recipe will use this ZIP file
    in a secure way. The source code for this recipe is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/webapp.](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/webapp)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to provision a Web App with Terraform:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copy and paste, in a new Terraform file, the Web App Terraform from [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/sample-app](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/sample-app).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside this Terraform file, we add a new `azurerm_storage_account` data block with
    the following code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we add another `azurerm_storage_account_sas` data block to get a security
    token with the following extract code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code of this block is available at [https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/webapp/main.tf](https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/webapp/main.tf).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we update the code of the Azure Web App in `azurerm_app_resource`
    by adding the following code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, we retrieved the Terraform configuration that allows a Web App
    to be provisioned. In the following steps of the recipe, we will complete it in
    order to be able to deploy a web application directly in this Web App, with Terraform,
    at the same time as its provisioning.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, in *step 2*, we add the `azurerm_storage_account` data block, which will
    allow us to retrieve properties from the Storage Account that contains the ZIP
    file of the application. In *step 3*, we add the `azurerm_storage_account_sas` data
    block, which will return a security token to the blob.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this token, we indicate that the access will be read-only, and that we only
    give access to the blob service.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, in *step 4*, we complete the resource `azurerm_app_service` by adding
    in the application settings of the `WEBSITE_RUN_FROM_PACKAGE` key, which contains,
    by way of a value, the complete URL of the ZIP file and in which we concatenated
    the token key returned in the block.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have studied the possibility of provisioning an Azure Web
    App and deploying it with Terraform. There are, however, several other ways to
    deploy this application in the Web App, as explained in the documentation available
    at [https://docs.microsoft.com/en-us/azure/app-service/deploy-zip](https://docs.microsoft.com/en-us/azure/app-service/deploy-zip).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will learn in the *Building CI/CD pipelines for Terraform configuration in
    Azure pipelines* recipe in [Chapter 7](905f7886-2827-44fe-af8c-4f9f3e3a9cef.xhtml), *Terraform
    Deep Dive,* how to automate this deployment in a CI/CD pipeline in Azure Pipelines.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation pertaining to the `WEBSITE_RUN_FROM_PACKAGE` app setting of a
    Web App is available here: [https://docs.microsoft.com/en-us/azure/app-service/deploy-run-package](https://docs.microsoft.com/en-us/azure/app-service/deploy-run-package)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation pertaining to the `azurerm_storage_account_sas` block data is
    available here: [https://www.terraform.io/docs/providers/azurerm/d/storage_account_sas.html](https://www.terraform.io/docs/providers/azurerm/d/storage_account_sas.html)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation pertaining to the Terraform resource, `azurerm_app_service`, is
    available here: [https://www.terraform.io/docs/providers/azurerm/r/app_service.html](https://www.terraform.io/docs/providers/azurerm/r/app_service.html)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a Terraform configuration for existing Azure infrastructure
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: When enterprises want to automate their processes and adopt IaC practices (for
    example, with Terraform), they face the challenge of how to generate code for
    an infrastructure that is already provisioned.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Indeed, for new infrastructures, it is sufficient to write the corresponding
    Terraform configuration and then execute it in order to provision it. On the other
    hand, for resources that are already provisioned, depending on their number and
    configuration, it can be long and tedious to write all the Terraform configuration
    and then execute it to also have the corresponding Terraform state file. In addition,
    this execution of the Terraform configuration can have side effects on these resources,
    which may already be being faced in production.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As a partial answer to this problem, we have seen in the *Importing existing
    resources* recipe from [Chapter 4](fc591e87-b893-40fa-9021-7827bffcc094.xhtml),
    *Using the Terraform CLI*, that we can use the `terraform import` command to import
    the configuration of already provisioned resources into the Terraform state file.
    However, this command requires that, on the one hand, the corresponding Terraform
    configuration is already written, because this command only updates the Terraform
    state file, and on the other, this command must be executed in order for each
    resource to be imported.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With this in mind, and having already had this request from many clients, I
    asked myself the question: Are there tools or scripts that can be used to generate
    Terraform configuration and its Terraform state file for resources already provisioned
    in Azure?'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this recipe, I'm going to share the results of my investigation with you
    using one of the Terraform configuration generation tools, called **Terraformer**,
    which is hosted in the GitHub repo of Google Cloud Platform, at [https://github.com/GoogleCloudPlatform/terraformer](https://github.com/GoogleCloudPlatform/terraformer).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use **Terraformer**, you must first download the version corresponding to
    the Terraform provider whose code you wish to generate. In our case, we want to
    generate the Terraform configuration for an Azure infrastructure, so we run the
    following Linux script:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This script downloads the **Terraformer** ZIP package. Unzip it and then copy
    it inside the `/usr/local/bin` local folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For this recipe, we will work on a Linux Terminal, but Terraformer works the
    same way for Windows, as described in the following documentation: [https://github.com/GoogleCloudPlatform/terraformer#installation](https://github.com/GoogleCloudPlatform/terraformer#installation)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once installed, its installation can be checked by executing the `terrafor``mer
    --help` command, and the list of Terraformer commands is displayed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/fa822e2d-fc51-4ff0-b7a9-5695eb231507.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The purpose of this recipe is to generate the Terraform configuration and the
    Terraform state file of an Azure infrastructure, which is composed of several
    Resource Groups, as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/42b86fd9-38f5-47aa-a800-208b8d579817.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: For the purpose of this recipe, we will limit the generation of the Terraform
    configuration just to these Resource Groups and not to their contents.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To generate a Terraform configuration using **Terraformer**, perform the following
    steps:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the folder that will contain the generated code, we create a `provider.tf`
    file with the code of the Terraform provider declared as following:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the command-line terminal, in this folder, we need to download the `azurerm`
    provider by running the `terraform init` command.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then set the four Azure environment variables for Terraform authentication:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we generate the Terraform configuration by executing the following **Terraformer**
    command:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the Terraform configuration and Terraform state file are generated, we
    will navigate the generated code in the `generate/azurerm` folder and add the
    `features {}` expression to the `provider.tf` file as follows:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, in this folder, we will test the configuration generated by running
    the basic Terraform workflow with the `terraform init` and `terraform plan` commands:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/223a55d4-3543-49fd-a920-4ee53017076c.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: If the output is generated successfully, we should see that the configuration&
    generated doesn't apply any changes. It corresponds to our infrastructure exactly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, we created a file that contains the provider declaration to download.
    Then, we downloaded it with the `terraform init` command we execute in the second
    step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Step 3* corresponds to the set of environment variables for Azure authentication
    that we detailed in the *Protecting the Azure credential provider* recipe of this
    chapter. Then, in *step 4*, we used Terraformer to generate the Terraform configuration
    and Terraform state files for the provisioned Azure group resources and, in the
    command line used, we specified the following options:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`resources`: This is the list of Azure resources for which Terraform configuration
    must be generated.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compact`: This enables specification of the fact that all the Terraform configurations
    will be generated in a single file.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path-pattern`: This specifies the pattern of the folder that will contain
    the generated code.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the execution of Terraformer:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/9ab5f06d-5afa-489d-b72d-85cabb7863ef.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The `generated/azurerm` folder is created with the Terraform files, as shown
    in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/675ba3c8-a9c2-4fd7-94c1-c93a6fa1ef60.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'In this folder, we see the following generated files:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Terraform configuration `.tf` files – `resources.tf`, `provider.tf`, `outputs.tf`,
    and `variables.tf`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `tfstate` file – `terraform.tfstate`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In *step 5*, we added the `features {}` expression to the provider declaration
    that was generated in the `generated/azurerm` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, in *step 6*, we verified that the generated code is the infrastructure
    code by executing a preview of the changes with the execution of the `terraform
    plan` command. During its execution, no changes will be applied. The Terraform
    configuration is well in line with our infrastructure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: Terraformer also contains an option that allows a dry run to preview the code
    that will be generated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To do this, we will execute the following command that generates a `plan.json`
    file, along with a description of the resources that will be generated:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We visualize the content of this created JSON file to check its conformity
    and then, in order to carry out the generation, we execute the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Moreover, before using Terraformer, it is necessary to check that the resources
    to be generated are well supported. For example, in the case of Azure, the list
    of resources is available here: [https://github.com/GoogleCloudPlatform/terraformer#use-with-azure](https://github.com/GoogleCloudPlatform/terraformer#use-with-azure).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, among the other Terraform configuration generation tools, there is
    a very good tool called **az2tf** ([https://github.com/andyt530/py-az2tf](https://github.com/andyt530/py-az2tf))
    that used to work on the same Terraformer principle, but unfortunately, this tool
    is no longer maintained. There is also **TerraCognita** ([https://github.com/cycloidio/terracognita/](https://github.com/cycloidio/terracognita/)),
    which still integrates a number of resources for Azure, and **Terraforming** ([https://github.com/dtan4/terraforming](https://github.com/dtan4/terraforming)),
    which is only operational for AWS. The problem with all these tools is that they
    have to follow the evolution of the Terraform language and also the evolution
    of different providers, which requires a lot of development and maintenance time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: The source code and the documentation for Terraformer is available here: [https://github.com/GoogleCloudPlatform/terraformer](https://github.com/GoogleCloudPlatform/terraformer).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
