- en: Deep Diving into Terraform
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we started with recipes for Terraform that concern its installation,
    the writing of the Terraform configuration, as well as the use of the Terraform
    CLI commands. Then we studied the sharing of the Terraform configuration by using
    modules. Finally, we focused on the use of Terraform to build an Azure infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in this chapter, we will discuss recipes that allow us to go further in
    our usage of Terraform. We will learn how to use the templates in Terraform via
    the generation of an inventory for Ansible using Terraform, and will test the
    Terraform configuration using the `kitchen-terraform` plugin. We will discuss
    how to prevent the destruction of resources, how to implement a zero-downtime
    deployment technique with Terraform, and how to detect the deletion of resources
    when Terraform applies changes.
  prefs: []
  type: TYPE_NORMAL
- en: Then we will discuss the use of **Terragrunt** to manage the Terraform configuration
    dependency and its use as a wrapper for the Terraform CLI. Finally, we will study
    the integration of the Terraform runtime as well as the management of workspaces
    in a CI/CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Ansible inventory with Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the Terraform configuration with kitchen-terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing resources from getting destroyed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero-downtime deployment with Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting resources deleted by the plan command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Terraform configuration dependencies using Terragrunt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Terragrunt as a wrapper for Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building CI/CD pipelines for Terraform configurations in Azure Pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with workspaces in CI/CD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the recipes in this chapter, we will need the following prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kitchen-terraform`, which is available at [https://github.com/newcontext-oss/kitchen-terraform](https://github.com/newcontext-oss/kitchen-terraform),
    and also Ruby, available to download from [https://www.ruby-lang.org/en/](https://www.ruby-lang.org/en/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terragrunt, whose documentation is available at [https://terragrunt.gruntwork.io/](https://terragrunt.gruntwork.io/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, we will also use the **jq** utility for parsing JSON. You can download
    it from [https://stedolan.github.io/jq/](https://stedolan.github.io/jq/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, when working with CI/CD, we will use Azure Pipelines as our CI/CD platform.
    Azure Pipelines is a service of Azure DevOps. You can create a free account via [https://azure.microsoft.com/en-us/services/devops/](https://azure.microsoft.com/en-us/services/devops/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for this chapter is available on the book's GitHub repository,
    at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '"YouTube Bitly link"'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Ansible inventory with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Terraform is a very good **Infrastructure-as-Code** (**IaC**) tool that allows
    us to build complex infrastructure with code.
  prefs: []
  type: TYPE_NORMAL
- en: As we studied in [Chapter 6](d054157b-d534-47c9-8079-3af13107c4ef.xhtml), *Provisioning
    Azure Infrastructure with Terraform*, concerning the construction of virtual machines,
    on all cloud providers, the common objective of Terraform is to build a VM without
    configuring it, which includes the installation of its middleware and its administration.
  prefs: []
  type: TYPE_NORMAL
- en: Among the **Configuration-as-Code** (**CaC**) tools that allow us to use Terraform
    to configure a VM after its creation, there is **Ansible** ([https://www.ansible.com/](https://www.ansible.com/)),
    which is very popular in the open source world (much like Chef and Puppet).
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of Ansible is that it's agentless, which means you don't
    need to install an agent on the VMs you want to configure. Thus, to know which
    VMs to configure, Ansible uses a file called `inventory`, which contains the list
    of VMs that need configuring.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to generate this `inventory` file using Terraform's
    templating features.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of this recipe is not to discuss the installation and use of Ansible
    but just the automatic creation of its `inventory` file.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about Ansible, I invite you to read *Chapter 3, Using Ansible
    for Configuring IaaS Infrastructure*, from my book entitled *Learning DevOps*,
    also available from Packt at [https://www.packtpub.com/eu/cloud-networking/learning-devops](https://www.packtpub.com/eu/cloud-networking/learning-devops).
  prefs: []
  type: TYPE_NORMAL
- en: 'The starting point of our recipe is to use Terraform to create VMs in Azure
    whose private IP addresses are not known before they are created. In this Terraform
    configuration of VMs, we use the configuration we have already studied in the
    *Provisioning and configuring an Azure VM with Terraform* recipe of [Chapter 6](d054157b-d534-47c9-8079-3af13107c4ef.xhtml), *Provisioning
    Azure Infrastructure with Terraform*. So, to keep it simple, we use the Terraform
    modules published in the public registry with the following Terraform configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instantiate a `vmhosts` variable that specifies the hostname of the VM we want
    to create:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use the `network` module and compute from the public registry to create
    the VM inside the network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding Terraform configuration, we create a Virtual Network and a
    Subnet and two Linux VMs that will have private IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of this recipe is to generate an `inventory` text file, in the same
    Terraform configuration, which will contain the list of hosts (along with their
    IP addresses) that have been created by Terraform. This inventory file will be
    in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The complete source code for this recipe is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/ansible-inventory](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/ansible-inventory).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To generate the Ansible inventory with Terraform, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the folder containing the Terraform configuration, we create a new file
    called `template-inventory.tpl` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `main.tf` file of the Terraform configuration that creates a VM,
    we add the following code to generate the `inventory` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Finally, to create the VMs and generate the `inventory` file, we run the basic
    Terraform `init`, `plan`, and `apply` workflow commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We first create a `template-inventory.tpl` file, which uses Terraform''s template
    format. In this file, we use a `for` loop with the syntax `%{ for host, ip in
    vm_dnshost ~}`, which allows us to loop the elements of the `vm_dnshost` variable.
    For each VM in this loop, we use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We end the loop with the `%{ endfor ~}` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: For more details on this templating format, read the documentation at [https://www.terraform.io/docs/configuration/expressions.html#string-templates](https://www.terraform.io/docs/configuration/expressions.html#string-templates).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then in *step 2*, to the Terraform configuration we add a `local_file` resource
    (which we have already studied in the *Manipulating local files with Terraform*
    recipe of [Chapter 2](3099c9ac-8c38-4e7d-8146-411fac26a2b7.xhtml), *Writing Terraform
    Configuration*) in which we fill in the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filename`: This contains `inventory` as its value, which is the name of the
    file that will be generated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, the file will be generated inside the directory that currently contains
    this Terraform configuration. You are free to enter another folder for generation
    and storage.
  prefs: []
  type: TYPE_NORMAL
- en: '`content`: This contains the elements that will fill this file. Here, we use
    the `templatefile` function, passing the following as parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the template file, `template-inventory.tpl`, that we created in
    *step 1*
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `vm_dnshost` variable that will fill the content of the template file. We
    use the built-in Terraform `zipmap` function that allows us to build a map from
    two lists, one being the keys list and the other the values list.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `zipmap` function is available at [https://www.terraform.io/docs/configuration/functions/zipmap.html](https://www.terraform.io/docs/configuration/functions/zipmap.html).
  prefs: []
  type: TYPE_NORMAL
- en: '`depend_on`: This parameter is part of the Terraform language and indicates
    a dependency between two or more resources (the documentation on Terraform dependencies
    can be found at [https://learn.hashicorp.com/terraform/getting-started/dependencies](https://learn.hashicorp.com/terraform/getting-started/dependencies)).
    Here, in our case, we indicate a dependency between this `local_file` resource
    and the VM module so that Terraform only creates the `inventory` file after creating
    the VM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, in the last step, we execute the commands of the Terraform workflow,
    and at the end of its execution we can see that the `inventory` file has indeed
    been generated with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, all new VMs added to this Terraform configuration will be added dynamically
    to this Ansible inventory.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The primary objective of this recipe is to show the use of templates with Terraform
    that we applied on an Ansible inventory. There can be several other use cases
    for these templates, such as using the `cloud-init` file to configure a VM, which
    is explained in the article at [https://grantorchard.com/dynamic-cloudinit-content-with-terraform-file-templates/](https://grantorchard.com/dynamic-cloudinit-content-with-terraform-file-templates/).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The documentation on the Terraform `templatefile` function is available at [https://www.terraform.io/docs/configuration/functions/templatefile.html](https://www.terraform.io/docs/configuration/functions/templatefile.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The documentation on the `local_file` resource of the `local` provider is available
    at [https://registry.terraform.io/providers/hashicorp/local/latest/docs/resources/file](https://registry.terraform.io/providers/hashicorp/local/latest/docs/resources/file).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of books on Ansible from Packt is available at [https://subscription.packtpub.com/search?query=ansible](https://subscription.packtpub.com/search?query=ansible).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a list of web articles that deal with the same subject of Ansible inventories
    generated by Terraform by proposing different solutions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://hooks.technology/2020/02/using-terraform-and-ansible-together/](https://hooks.technology/2020/02/using-terraform-and-ansible-together/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.linkbynet.com/produce-an-ansible-inventory-with-terraform](https://www.linkbynet.com/produce-an-ansible-inventory-with-terraform)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://gist.github.com/hectorcanto/71f732dc02541e265888e924047d47ed](https://gist.github.com/hectorcanto/71f732dc02541e265888e924047d47ed)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://stackoverflow.com/questions/45489534/best-way-currently-to-create-an-ansible-inventory-from-terraform](https://stackoverflow.com/questions/45489534/best-way-currently-to-create-an-ansible-inventory-from-terraform)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the Terraform configuration using kitchen-terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already studied, in the *Testing Terraform module code with Terratest*
    recipe of [Chapter 5](ddb13a41-5cdd-4931-b38f-d185d3a10c1e.xhtml), *Sharing Terraform
    Configuration with Modules*, how to test Terraform modules using the Terratest
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will test a Terraform configuration using another tool: **KitchenCI**
    and its `kitchen-terraform` plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`kitchen-terraform` is written in Ruby and is a plugin for **KitchenCI** (more
    simply called **Kitchen**), which is an IaC testing tool. In order to apply this
    recipe properly, you must first understand the principles and workflow of Kitchen,
    documented at [https://kitchen.ci/index.html](https://kitchen.ci/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: As Kitchen is written in **Ruby**, you will need to install Ruby (available
    at [https://www.ruby-lang.org/en/](https://www.ruby-lang.org/en/) – make sure
    to use version 2.4 at a minimum) on your computer by following the installation
    documentation available at [https://www.ruby-lang.org/en/documentation/installation/](https://www.ruby-lang.org/en/documentation/installation/).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to Ruby, we need to install **Bundle**, available from [https://bundler.io/](https://bundler.io/).
    This is the package dependency for Ruby packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install `kitchen-terraform` firstly by using RubyGems (which is the
    Ruby manager package) by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, secondly, we can use the method recommended by Kitchen using gems and bundles
    by following this procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the folder that contains the Terraform configuration to be tested, we create
    a Gemfile that contains the list of packages (here, we specify the `kitchen-terraform`
    package) to install, containing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In a terminal, execute the following command to install the packages referenced
    in the Gemfile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The execution of the preceding command installs all the packages necessary to
    run `kitchen-terraform`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, concerning the writing of the tests, we will use **Inspec**, which
    is a test framework based on Rspec. Inspec allows you to test local systems or
    even infrastructures in the cloud. For more information about Inspec, I suggest
    you read its documentation at [https://www.inspec.io/](https://www.inspec.io/).
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the use of `kitchen-terraform` in a simple way, we will test the
    proper functioning of the Terraform configuration in this recipe that generates
    an Ansible inventory file, which we studied in the previous recipe. The purpose
    of the tests we will write is to test that the `inventory` file has indeed been
    generated and that it is not empty.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, the goal is not to test the creation of the network and the
    VMs, but only the `inventory` file.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as with all integration testing, it is preferable to have an isolated
    system or environment to run the tests.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this recipe is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/kitchen](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/kitchen).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test the Terraform configuration execution with `kitchen-terraform`, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the folder containing the Terraform configuration, create the Inspec
    `test` folder with the following tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this `kt_suite` folder, add the Inspec profile file named `inspec.yml` with
    the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `kt_suite` folder, create a new folder called `controls` that will contain
    the Inspec tests. Then, inside the `controls` folder, add a new `inventory.rb`
    file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'At the root of the Terraform configuration folder, we create a Kitchen configuration
    file called `kitchen.yml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In a terminal (running in the root of the Terraform configuration folder),
    run the following `kitchen` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The execution of this recipe takes place over three phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing the inspection tests
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing the Kitchen configuration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kitchen execution
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From *steps 1 to 3*, we wrote the inspection tests with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we created the folder tree that will contain the profile and the Inspec
    tests. In the `kt_suite` folder, we created the `inspec.yml` file, which is the
    Inspec profile. In our case, this just contains the `name` property with the `default`
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To learn more about Inspec profiles, refer to the documentation at [https://www.inspec.io/docs/reference/profiles/](https://www.inspec.io/docs/reference/profiles/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `controls > inventory.rb` file, we wrote the Inspec tests (in
    Rspec format) by creating a `control "check_inventory_file" do` control that will
    contain the tests. In these tests, we use the resource `file` Inspec (see the
    documentation at [https://www.inspec.io/docs/reference/resources/file/](https://www.inspec.io/docs/reference/resources/file/)),
    which allows us to run tests on files. Here, the property of this resource is
    `inventory`, which is the name of the inventory file generated by Terraform. In
    this control, we have written two tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`it { should exist }`: This inventory file must exist on disk.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`its(''size'') { should be > 0 }`: The size of this file must be `> 0`, so
    it must contain some content.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the writing of the tests is finished, in *step 4*, we create the `kitchen.yml`
    file, which contains the Kitchen configuration consisting of three parts, the
    first one being the driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The driver is the platform that is used for testing. Kitchen supports a multitude
    of virtual and cloud platforms. In our case, we use the `terraform` driver provided
    by the `kitchen-terraform` plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the drivers supported by Kitchen is available at [https://kitchen.ci/docs/drivers/](https://kitchen.ci/docs/drivers/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of the `kitchen.yml` file is the `provisioner`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `provisioner` is the tool that will configure the VMs. It can use scripts,
    Chef, Ansible, or **Desired State Configuration** (**DSC**). In our case, since
    in our test we don't provision VMs, we use the `terraform` provisioner provided
    by `kitchen-terraform`.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on Kitchen-supported provisioners is available at [https://kitchen.ci/docs/provisioners/](https://kitchen.ci/docs/provisioners/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part is the `verifier`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `verifier` is the system that will test the components applied by the provisioner. We
    can use Inspec, Chef, shell, or pester as our testing framework. In our case,
    we configure the verifier on the control and the Inspec test suite we wrote in
    *step 2*. In addition, the `control` property is optional – it allows us to filter
    the Inspec controls to be executed during the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on Kitchen-supported verifiers is available at [https://kitchen.ci/docs/verifiers/](https://kitchen.ci/docs/verifiers/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in the last step, we perform the tests by executing the `kitchen test` command, which,
    based on the YAML kitchen configuration, will perform the following actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the `init` and `apply` commands of the Terraform workflow.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the Inspec tests.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the `destroy` Terraform command to delete all resources provisioned
    for the test.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The result of this execution is shown in the following three screenshots.
  prefs: []
  type: TYPE_NORMAL
- en: In reality, this execution takes place in the same console and the same workflow.
    I've split this into three screenshots for better visibility because you can't
    see everything with just one screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the execution of the `init` and `apply` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cdcd7e5b-c70d-46ee-80bf-a4694c608da3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the execution of Inspec:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cbf94f6-4c64-42de-b363-05a6060bbf78.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This last screenshot shows the `destroy` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20ced5e1-e92d-4d2f-8a8d-689c7b42bcd1.png)'
  prefs: []
  type: TYPE_IMG
- en: These three screens show the execution of Terraform, then the successful execution
    of the Inspec tests, which indicates that my `inventory` file was indeed generated
    by Terraform, and finally the destruction of the resources that had been allocated
    for the tests.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To go deeper into the writing of the tests, we could have added the Inspec `its('content')`
    expression, which allows us to test the content of the file, as explained in the
    Inspec documentation at [https://www.inspec.io/docs/reference/resources/file/](https://www.inspec.io/docs/reference/resources/file/).
  prefs: []
  type: TYPE_NORMAL
- en: Concerning the execution of the tests in this recipe, we have to execute the `kitchen
    test` command. In the case of integration tests in which, after executing the
    tests, we don't want to destroy the resources that have been built with Terraform,
    we can execute the `kitchen verify` command.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as mentioned in the introduction, in this recipe we used `kitchen-terraform`
    to test a Terraform configuration, but we can also use it to test Terraform modules.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: KitchenCI documentation is available at [https://kitchen.ci/](https://kitchen.ci/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code of the `kitchen-terraform` plugin on GitHub is available at [https://github.com/newcontext-oss/kitchen-terraform](https://github.com/newcontext-oss/kitchen-terraform).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find tutorials on `kitchen-terraform` at [https://newcontext-oss.github.io/kitchen-terraform/tutorials/](https://newcontext-oss.github.io/kitchen-terraform/tutorials/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information about the `kitchen test` command, see the documentation
    at [https://kitchen.ci/docs/getting-started/running-test/](https://kitchen.ci/docs/getting-started/running-test/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing resources from getting destroyed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of IaC requires attention in some cases. Indeed, when the IaC is integrated
    into a CI/CD pipeline, resources containing important data can be automatically
    deleted. This can be done either by changing a property of a Terraform resource,
    which requires the deletion and recreation of this resource, or by executing the
    `terraform destroy` command. Fortunately, Terraform includes a configuration in
    its language that prevents the destruction of sensitive resources.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to prevent the destruction of resources that
    are managed in a Terraform configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will use a Terraform configuration, the code for which
    is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/sample-app](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/sample-app).
    The purpose of this configuration is to manage the following resources in Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: A Resource Group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Service Plan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Azure App Service (web app) instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Azure Application Insights instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problem that we often encounter in company projects concerns the resources
    that contain data. In our example, this is the Application Insights instance containing
    the logs and metrics of our application, which is in the web app and should not
    be deleted automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take as a scenario a company that has decided to change the nomenclature
    of their resources, and we need to update the Terraform configuration with the
    new nomenclature. When running Terraform, we would get the following result from
    the `terraform plan` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44ffd996-a55c-4459-9d13-804cb8d8dc2c.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the name change requires the deletion of the Application Insights
    instance that contains important log metrics.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this recipe is to change the Terraform configuration so that
    the Application Insights resource is never deleted.
  prefs: []
  type: TYPE_NORMAL
- en: The source code of this recipe is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/preventdestroy](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/preventdestroy).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To prevent the deletion of a resource by Terraform, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the Terraform configuration of the Application Insights resource, add
    the following `lifecycle` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In `variables.tf`, change the default value of the `app_name` variable with
    another name for the Application Insights such as `MyApp2-DEV1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the Terraform CLI workflow and the result is shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/69601017-f88c-4cd7-a70c-bff317398c77.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have added the Terraform `lifecycle` block, which contains
    the properties that allow interaction with resource management. Here, in our case,
    we used the `prevent_destroy` property, which, as its name indicates, prevents
    the destruction of the specified resource.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have discussed, the `prevent_destroy` property allows you to prohibit
    the deletion of resources.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in our example with Azure, this property does not prohibit the deletion
    of resources via the Azure portal or the Azure CLI.
  prefs: []
  type: TYPE_NORMAL
- en: However, it should be noted that if a resource in the Terraform configuration
    contains this property, and this property must be deleted when executing the `terraform
    apply` command, then this `prevent_destroy` property prevents the application
    from making changes to all the resources described in the Terraform configuration.
    This blocks us from applying changes to resources. This is one of the reasons
    why I personally break up the Terraform configuration, putting the configuration
    of the sensitive resources that mustn't be destroyed in one folder (and thus a
    separate Terraform state file), and the other resources in another folder. This
    way, we can apply changes to the resources without being blocked by our resource
    destruction prevention settings.
  prefs: []
  type: TYPE_NORMAL
- en: Here, I'm writing about separating the Terraform configuration and the state
    files, but it's also necessary to separate the workflows in the CI/CD pipeline,
    with one pipeline that applies the changes and another that destroys the resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, mostly to prevent human mistakes, it isn''t possible to add variables
    to the values of the properties of the `lifecycle` block by wanting to make the
    value of this property dynamic. You might try using a `bool` type variable, such
    as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'However, when executing the `terraform apply` command, the following error
    occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2f4f17f-c3bf-4865-a566-de5f5165c24d.png)'
  prefs: []
  type: TYPE_IMG
- en: These errors indicate that a variable is not allowed in the `lifecycle` block, so
    you have to keep true/false values in the code.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation on the `prevent_destroy` property is available at [https://www.terraform.io/docs/configuration/resources.html#prevent_destroy](https://www.terraform.io/docs/configuration/resources.html#prevent_destroy).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interesting article on the HashiCorp blog about drift management can be found
    at [https://www.hashicorp.com/blog/detecting-and-managing-drift-with-terraform/](https://www.hashicorp.com/blog/detecting-and-managing-drift-with-terraform/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read this article from HashiCorp about feature toggles, blue-green deployments,
    and canary testing using Terraform, available at [https://www.hashicorp.com/blog/terraform-feature-toggles-blue-green-deployments-canary-test/](https://www.hashicorp.com/blog/terraform-feature-toggles-blue-green-deployments-canary-test/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero-downtime deployment with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in the previous recipe, changing certain properties on resources
    described in the Terraform configuration can lead to their destruction and subsequent
    recreation. Resources are destroyed and recreated in the order in which they are
    run in Terraform. In other words, the first resource to be run will first be destroyed
    and then it will be recreated, and in a production context, during this time period,
    it will lead to downtime, that is, a service interruption. This downtime can be
    greater or smaller depending on the type of resources that will have to be destroyed
    and then recreated.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in Azure, a VM takes much longer to destroy and rebuild than a
    web app or a **Network Security Group** (**NSG**) rule.
  prefs: []
  type: TYPE_NORMAL
- en: In Terraform, there is a mechanism that allows for zero downtime and therefore
    avoids this service interruption when deleting a resource.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will study how to implement zero downtime on a resource described
    in a Terraform configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will use the Terraform configuration available from [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/sample-app](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/sample-app).
    The purpose of this configuration is to manage the following resources in Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: A Resource Group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Service Plan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An App Service (web app) instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Application Insights instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, this Terraform configuration has already been applied to the Azure
    cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our use case, let''s assume that a company has decided to change the resource
    name and that we need to update the Terraform configuration with the new name.
    When running Terraform, the following result would be obtained with the `terraform
    plan` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ca19d92-8c6f-447f-8a22-2e0f0b57b010.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the name change requires a deletion of the web app that hosts
    our web application. This deletion will result in the application not being accessible
    for a small amount of time while it is recreated. The purpose of this recipe is
    to modify the Terraform configuration so that even when the App Service resource
    is deleted, the web application will still be available.
  prefs: []
  type: TYPE_NORMAL
- en: The source code of this recipe is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/zerodowntime](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/zerodowntime).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To provide zero downtime in a Terraform configuration, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Terraform configuration, inside the `azurerm_app_service` resource,
    add the `lifecycle` block as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Change the `name` property of the App Service to apply the new nomenclature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the Terraform CLI workflow and the `terraform apply` result will be
    shown as in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4d0c99fb-63ad-4621-b9c1-fb6521693be3.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 2*, we added the `lifecycle` block to the `azurerm_app_service` resource.
    In this block, we added the `create_before_destroy` property with its value set
    to `true`. This property makes the regeneration of a resource possible in the
    event of destruction by indicating to Terraform to first recreate the resource,
    and only then to delete the original resource.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we've seen, by using this property, there is no more interruption of service.
    As long as the new resource is not created, the old one is not deleted and the
    application continues to be online.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, before using `create_before_destroy`, there are some things to consider,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `create_before_destroy` property only works when a configuration change
    requires the deletion and then regeneration of resources. It only works when executing
    the `terraform apply` command; it does not work when executing the `terraform
    destroy` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must be careful that the names of the resources that will be created have
    different names than the ones that will be destroyed afterward. Otherwise, if
    the names are identical, the resource may not be created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Moreover, this zero-downtime technique is only really effective if the resource
    that will be impacted is fully operational at the end of its creation. For example,
    let''s take the case of a VM: although Terraform can quickly create it, it still
    remains after all its configuration has been carried out (the installation of
    the middleware and deployment of the application). All this configuration can
    generate downtime, and in order to be efficient in this case, I advise you to
    use Packer from HashiCorp ([https://www.packer.io/](https://www.packer.io/)),
    which allows you to create images of VMs that are already fully configured.'
  prefs: []
  type: TYPE_NORMAL
- en: To implement zero downtime in Azure with Packer and Terraform, read the tutorial
    at [https://docs.microsoft.com/en-us/azure/developer/terraform/create-vm-scaleset-network-disks-using-packer-hcl](https://docs.microsoft.com/en-us/azure/developer/terraform/create-vm-scaleset-network-disks-using-packer-hcl).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have seen in this recipe how to implement zero-downtime deployments
    with Terraform, but according to your provider, there are most likely other practices
    that are native to them. For example, we can also use load balancers, and for
    an App Service instance on Azure, we can use slots, as explained in the documentation
    at [https://docs.microsoft.com/en-us/azure/app-service/deploy-staging-slots](https://docs.microsoft.com/en-us/azure/app-service/deploy-staging-slots).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Read the HashiCorp blog post about the `create_before_destroy` property at [https://www.hashicorp.com/blog/zero-downtime-updates-with-terraform/](https://www.hashicorp.com/blog/zero-downtime-updates-with-terraform/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good article on zero downtime can be found at [https://dzone.com/articles/zero-downtime-deployment](https://dzone.com/articles/zero-downtime-deployment).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting resources deleted by the plan command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key features of Terraform is the possibility to visualize a preview
    of changes in advance of their application to a given piece of infrastructure
    with the `terraform plan` command.
  prefs: []
  type: TYPE_NORMAL
- en: We have often discussed in this book displaying a visualization of changes in
    the terminal, but what we see less often is how to automatically evaluate and
    analyze the results of the `terraform plan` command.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to analyze the results of the `terraform plan`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the application of this recipe, we need to have the **jq** tool installed,
    available for download for all platforms from [https://stedolan.github.io/jq/](https://stedolan.github.io/jq/).
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use jq on Windows with PowerShell, but all steps will
    be identical on other OSes.
  prefs: []
  type: TYPE_NORMAL
- en: The Terraform configuration used is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/detectdestroy](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/detectdestroy), and
    we must run it on our infrastructure beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this recipe is to detect via a script whether the execution of
    `terraform plan` will lead to the destruction of a resource.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to analyze the results of the `plan` command:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the Terraform configuration, we change the value of the `name` property
    (by adding the word `test`) in the App Service instance, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we execute the `terraform init` command, followed by the `terraform plan`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we execute the following PowerShell script, which analyzes the number
    of deleted resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This script is also available at [https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP07/detectdestroy/detectdestroy.ps1](https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP07/detectdestroy/detectdestroy.ps1).
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, we modify the Terraform configuration by changing the name of the
    App Service instance, which will lead to the destruction of this resource during
    the `apply` command.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in *step 2*, we execute the `terraform plan` command with the option `-out="tfout.tfplan"`,
    which allows us to get the output of `plan` in a file (in binary format).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in *step 3*, we write the PowerShell script that analyzes the generated
    plan for the number of resources that will be destroyed during the application.
    This script is made up of four lines. Here are the details:'
  prefs: []
  type: TYPE_NORMAL
- en: In line 1, we use the `terraform show` command on the `tfout.tfplan` file that
    was generated in *step 2.* To this command we added the `-json` option in order
    to get an output in JSON format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In line 2, we use **jq** on the JSON result obtained from the previous line
    and filter the list of actions (which will be applied by Terraform) to obtain
    an array of actions (`add`, `delete`, and `no-op`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In line 3, we filter on this array all `delete` actions and get the number of
    this filtered array using the  `Count` PowerShell object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the last line, we display the count value, which corresponds to the number
    of deleted resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the result of this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a286507-440d-4e30-a8cd-10b66c84cd88.png)'
  prefs: []
  type: TYPE_IMG
- en: '`$nbdelete.Count` returns `1`, which is equal to the number of resources that
    will be deleted.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regarding the language used for the scripting of this recipe, we wrote it in
    PowerShell, but it can of course be written in any scripting language, such as
    Bash or Python. We can also put this script into a function that was called just
    after the `terraform plan` command and did not `apply` the Terraform configuration if
    that function returned a positive delete number.
  prefs: []
  type: TYPE_NORMAL
- en: There are also other tools for parsing and processing the plan generated by
    the `terraform plan` command. Among these tools, there are `npm` packages such
    as `terraform-plan-parser`, available at [https://github.com/lifeomic/terraform-plan-parser](https://github.com/lifeomic/terraform-plan-parser),
    or **Open Policy Agent for Terraform** at [https://www.openpolicyagent.org/docs/latest/terraform/](https://www.openpolicyagent.org/docs/latest/terraform/).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More detailed documentation on the JSON format of the `terraform plan` command
    is available at [https://www.terraform.io/docs/internals/json-format.html](https://www.terraform.io/docs/internals/json-format.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `terraform show` command documentation is available at [https://www.terraform.io/docs/commands/show.html](https://www.terraform.io/docs/commands/show.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Terraform configuration dependencies using Terragrunt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In several recipes in this book, we have discussed the organization of the files
    that contain the Terraform configuration. We examined this more specifically in
    the *Provisioning infrastructure in multiple environments* recipe in [Chapter
    2](3099c9ac-8c38-4e7d-8146-411fac26a2b7.xhtml), *Writing Terraform Configuration*,
    which outlines several architecture solutions.
  prefs: []
  type: TYPE_NORMAL
- en: One of the best practices regarding the structure of the configuration is to
    separate the Terraform configuration into infrastructure and application components,
    as explained in the article at [https://www.cloudreach.com/en/resources/blog/how-to-simplify-your-terraform-code-structure/](https://www.cloudreach.com/en/resources/blog/how-to-simplify-your-terraform-code-structure/).
    The challenge with a structure split into several configurations is the maintenance
    of dependencies and run schedules between these components.
  prefs: []
  type: TYPE_NORMAL
- en: Among all the third-party tools that revolve around Terraform, there is **Terragrunt**
    ([https://terragrunt.gruntwork.io/](https://terragrunt.gruntwork.io/)), developed
    by Gruntwork. Terragrunt is open source and offers a lot of additional functionality
    for the organization and execution of Terraform configurations.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how you can use Terragrunt to manage the dependencies
    of different Terraform configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we must have previously installed the Terragrunt binary on
    our workstations by following the instructions at [https://terragrunt.gruntwork.io/docs/getting-started/install/#install-terragrunt](https://terragrunt.gruntwork.io/docs/getting-started/install/#install-terragrunt).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will build an infrastructure consisting of the following
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: A Resource Group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A network with a Virtual Network and a Subnet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A VM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The architecture of the folders containing this Terraform configuration is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f3576d6-6718-43f0-9d97-fb53780172f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The problem with this architecture is the dependency between configurations,
    and the fact that they must be executed in a specific order. Indeed, to apply
    the network, the Resource Group must be applied first, and it''s the same for
    the VM: the network must be created beforehand. With Terraform, in the case of
    several changes, the Terraform workflow must be executed several times and in
    the correct order for each of those configurations.'
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this recipe is not to explain all the functionalities of Terragrunt
    in detail, but to demonstrate one of its features, which is to simplify the execution
    of Terraform when the Terraform configuration is separated into several folders
    that are linked by dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The source code of this recipe is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/demogrunt/dev](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/demogrunt/dev).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to use Terragrunt with Terraform dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the dependency between the `network` and `rg` configurations, inside
    the `network` folder add a new file called `terragrunt.hcl` with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `vm-dev` folder, add a new file called `terragrunt.hcl` with the
    following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In a terminal, inside the `network` folder, run the following `terragrunt`
    commands to create the Resource Group and the network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `terragrunt.hcl` file we added contains the configuration for Terragrunt.
  prefs: []
  type: TYPE_NORMAL
- en: Here, in the configuration we wrote in *step 2*, we indicated a dependency between
    the network configuration and the Resource Group configuration. This is because
    the Resource Group must be created before executing the network configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3*, we then executed the Terragrunt commands (`terragrunt init`, `terragrunt
    plan-all`, and `terragrunt apply-all`) and when executing them, thanks to the
    configuration we wrote, Terragrunt will first apply Terraform to the Resource
    Group and then to the network automatically. This without having to apply the
    Terraform workflow several times on several Terraform configurations and in the
    right order.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we studied how to improve the dependency between the Terraform
    configuration using Terragrunt and its configuration. We can go even further with
    this improvement, by externalizing the configuration (which is redundant between
    each environment) by reading the documentation available at [https://terragrunt.gruntwork.io/docs/features/execute-terraform-commands-on-multiple-modules-at-once/](https://terragrunt.gruntwork.io/docs/features/execute-terraform-commands-on-multiple-modules-at-once/).
  prefs: []
  type: TYPE_NORMAL
- en: However, since Terragrunt runs the Terraform binary that is installed on your
    local computer, you should make sure to install a version of Terragrunt that is
    compatible with the version of the Terraform binary installed.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we will complete the configuration of Terragrunt to be able
    to use it as a wrapper for Terraform by simplifying the Terraform command lines.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The detailed documentation of Terragrunt is available at [https://terragrunt.gruntwork.io/docs/#features](https://terragrunt.gruntwork.io/docs/#features).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for Terragrunt is available on GitHub at [https://github.com/gruntwork-io/terragrunt](https://github.com/gruntwork-io/terragrunt).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A useful blog article on the architecture of the Terraform configuration can
    be found at [https://www.hashicorp.com/blog/structuring-hashicorp-terraform-configuration-for-production/](https://www.hashicorp.com/blog/structuring-hashicorp-terraform-configuration-for-production/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Terragrunt as a wrapper for Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the many years that I have been working and supporting customers on Terraform,
    there is a recurring problem that prevents users from making full use of Terraform's
    functionality. What I have noticed is that these users do not encounter any problems
    with the language and the writing of the provider's resource configuration, but
    they do have difficulty with the automation of the Terraform client through the
    use of command lines for their workflow.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the automation of the Terraform workflow, whether for use on a local
    workstation or in a CI/CD pipeline, we can use Terragrunt as Terraform wrapper
    that integrates the Terraform workflow.
  prefs: []
  type: TYPE_NORMAL
- en: What we will learn in this recipe is how to use Terragrunt (which we have already
    studied in the previous recipe) as a Terraform wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we must have previously installed the Terragrunt binary on
    our workstations by following the instructions at [https://terragrunt.gruntwork.io/docs/getting-started/install/#install-terragrunt](https://terragrunt.gruntwork.io/docs/getting-started/install/#install-terragrunt).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Terraform configuration used in this recipe is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/demogrunt-wrapper](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/demogrunt-wrapper).
    It allows us to build resources in Azure. It uses an `env-dev.tfvars` variable
    file and a remote backend configuration file (`azurerm`) in the `backend.tfvars` file. To
    create this infrastructure, the following Terraform commands must be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The Terraform configuration of this resource creates resources in Azure, but
    what we will study in this recipe applies to any Terraform configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this recipe is to use the Terragrunt configuration to help execute
    these Terraform commands in an automation context.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to use Terragrunt as a Terraform CLI wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the folder that contains the Terraform configuration, create a new file
    called `terragrunt.hcl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this file, add the following configuration section to configure the `init`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to configure the `plan` and `apply` commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the command-line terminal, from the folder that contains the Terraform configuration,
    run the following Terragrunt command to initialize the Terraform context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, run the following Terragrunt commands to apply the changes we''ve
    made:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, we created the `terragrunt.hcl` file, which will contain the Terragrunt
    configuration of the Terraform wrapper. In *step 2*, we described in this file
    the Terraform execution configuration for the `init` command. In the list of commands,
    we indicate that this configuration applies for the `init` command and in the
    list of arguments we put an entry for the `--backend-config` option, which takes
    as a value the `backend.tfvars` file.
  prefs: []
  type: TYPE_NORMAL
- en: Then in *step 3*, we did the same operation for the `plan` and `apply` commands.
    In this configuration, we specify the list of commands: `plan`, `apply`, `destroy`,
    and `refresh`. For the arguments, we indicate the `-var-file="env-vars.tfvars"` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this configuration file is finished being written, we use it to run Terragrunt.
    In *step 4*, we execute the `terragrunt init` command, which will use the configuration
    we wrote and so will execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see this in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5dd8b74-c2f7-46fb-ac66-1736845a1a3d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, to preview the changes, we execute the `terragrunt plan` command,
    which will use the configuration we wrote and will therefore execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see this in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f109b541-10f0-4308-b031-ada3242cda89.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If these changes correspond to your expectations, you can use the following
    Terragrunt command to apply these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Detailed CLI configuration documentation is available at [https://terragrunt.gruntwork.io/docs/features/keep-your-cli-flags-dry/](https://terragrunt.gruntwork.io/docs/features/keep-your-cli-flags-dry/).
  prefs: []
  type: TYPE_NORMAL
- en: Building CI/CD pipelines for Terraform configurations in Azure Pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all of the previous recipes in this book, we've discussed Terraform configuration,
    CLI execution, and its benefits for IaC.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in this recipe, we will discuss how we will integrate this Terraform workflow
    into a CI/CD pipeline in Azure Pipelines using the Terraform extension for Azure
    DevOps and Pipelines YAML.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before automating Terraform in any CI/CD pipeline, it is recommended to read
    HashiCorp''s automation guides with recommendations for Terraform. These guides
    are available here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.hashicorp.com/terraform/development/running-terraform-in-automation](https://learn.hashicorp.com/terraform/development/running-terraform-in-automation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.terraform.io/docs/cloud/guides/recommended-practices/part3.html](https://www.terraform.io/docs/cloud/guides/recommended-practices/part3.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose of this recipe is not to explain in detail how Azure Pipelines works,
    but just to focus on the execution of Terraform in Azure Pipelines. To learn more
    about Azure Pipelines, I suggest you look at the official documentation at [https://docs.microsoft.com/en-us/azure/devops/pipelines/index?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/pipelines/index?view=azure-devops).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Terraform in Azure Pipelines, there are a couple of solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: Using custom scripts (PowerShell and Bash) executing the Terraform CLI commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Terraform extensions for Azure DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here in this recipe, we will learn how to use the Terraform extension for Azure
    DevOps published by Charles Zipp (in the knowledge there are, of course, other
    extensions available by other publishers).
  prefs: []
  type: TYPE_NORMAL
- en: 'To install this extension, implement the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://marketplace.visualstudio.com/items?itemName=charleszipp.azure-pipelines-tasks-terraform](https://marketplace.visualstudio.com/items?itemName=charleszipp.azure-pipelines-tasks-terraform)
    in your browser and click on Terraform Build & Release Tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of the page, click on Get it free.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the installation page, in the Organization dropdown, choose the organization
    to which the extension will be installed (1), then click on the Install button
    (2):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/22b2d1d6-ac59-4167-9388-1f4682edd62c.png)'
  prefs: []
  type: TYPE_IMG
- en: The extension will be installed on your Azure DevOps organization.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, for the Terraform state file, we will use a remote backend. In
    order to be able to use it in Azure (Azure Storage, to be precise) with Terraform,
    we learned in the *Protecting the state file in Azure remote backend* recipe of
    [Chapter 6](d054157b-d534-47c9-8079-3af13107c4ef.xhtml), *Provisioning Azure Infrastructure
    with Terraform*, that an Azure service principal must be created.
  prefs: []
  type: TYPE_NORMAL
- en: To create this connection with Azure, in Azure Pipelines, we go to set up a
    service connection with the information from the created Azure service principal.
    To operate this, in the project settings, we navigate to the Service connections
    menu. Then we create a new Azure RM service connection and configure it with the
    service properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the service connection to my Azure Terraform
    Demo configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12d4dda9-ac4b-4212-8a85-653e70ed3930.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, the code that contains the Terraform configuration must be stored in
    a Git repository, such as GitHub or Azure Repos (in this recipe, we will use GitHub).
  prefs: []
  type: TYPE_NORMAL
- en: Note that in this recipe, we will not study the deployed Terraform configuration
    code, which is very basic (it generates a random string) – its purpose is to demonstrate
    the implementation of the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: The Terraform configuration source code that will be used in this recipe is
    available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/pipeline](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/pipeline).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create the pipeline, we performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Azure Pipelines menu, click Pipelines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/63f31f5c-6930-4ac5-abf6-098c5512bbaa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Create Pipeline button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8e9d534b-4e4a-4fa6-8276-4d19cf374cb8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the code source, select the Git repository that contains the Terraform
    configuration. For this recipe, we choose our GitHub repository and select the Starter
    pipeline option to start with a new pipeline from scratch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0d40134d-ef1b-4ec1-aee5-c0ff3d1b9328.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The pipeline editor opens and you can start writing the CI/CD steps directly
    online. Let''s look at the code for this pipeline, which is in YAML format. First,
    we''re going to configure the pipeline options with the following code to use
    an Ubuntu agent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we tell the pipeline to download the desired version of the Terraform binary
    by adding this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We continue with the first command of the Terraform workflow and execute the `terraform init` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `init` step, the pipeline executes the `terraform plan` command for
    preview and displays the changes that the pipeline will apply:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, the pipeline runs the `terraform apply` command to apply the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The complete source code of this pipeline in YAML is available at [https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP07/pipeline/azure-pipelines.yml](https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP07/pipeline/azure-pipelines.yml).
  prefs: []
  type: TYPE_NORMAL
- en: 'After editing the YAML code of the pipeline, we can test it and trigger the
    execution of the pipeline by clicking on Save and run at the top right of the
    page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fc7be25f-c673-4008-a1f7-f1312c953c2c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the execution of the pipeline is finished, we will be able to see the log
    results of the execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/14c19538-458b-4e02-b20f-054f707033a8.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *steps 1* to *3* of this recipe, we used Azure Pipelines via the web interface to
    create a new pipeline that we configured on our GitHub repository. Moreover, we
    made the choice to configure it by starting with a new YAML file.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 4* was dedicated to writing the YAML code for our pipeline in which we
    defined the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We downloaded the Terraform binary and specified the version that is compatible
    with our Terraform configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Even if you are using an agent hosted by Microsoft that already has Terraform
    installed, I advise you to download Terraform because the version installed by
    default may not be compatible with your configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Then, using the extension installed in the prerequisites, we execute the Terraform
    workflow with a step for the `terraform init` command and the use of the Azure
    remote backend. We then execute the `terraform plan` command with the `out` argument,
    which generates a `plan` output file. Finally, we apply the changes by executing
    the `terraform apply` command using the generated plan file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `terraform apply` command used by this last task has the `-auto-appprove`
    option to allow changes to be applied automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the last step of the recipe, the pipeline is triggered and it is
    clear from the output logs that the changes described in the Terraform configuration
    have been applied.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen in this recipe how to create a pipeline for Terraform from an empty
    YAML file, but you can also create a pipeline using a prewritten YAML file archived
    in your Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use Terraform in an Azure DevOps pipeline using the classic mode
    (that is, in graphical mode without YAML), you can refer to the hands-on labs
    at [https://www.azuredevopslabs.com/labs/vstsextend/terraform/](https://www.azuredevopslabs.com/labs/vstsextend/terraform/).
  prefs: []
  type: TYPE_NORMAL
- en: 'If your Terraform configuration deploys an infrastructure in Azure, and you
    want to use a custom script inside the pipeline instead of the Terraform task,
    then you will have to add, in the Variables tab, the four environment variables
    of the main service used for authentication in Azure (we studied these in the
    *Protecting the Azure Credential Provider* recipe of [Chapter 6](d054157b-d534-47c9-8079-3af13107c4ef.xhtml), *Provisioning
    Azure Infrastructure with Terraform*), as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8bef1b55-c150-4b7a-b12f-a3152e7a8a06.png)'
  prefs: []
  type: TYPE_IMG
- en: These four variables will be automatically loaded as environment variables in
    the pipeline execution session.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, in this recipe, we used a CI/CD Azure Pipelines platform as an
    example, but the automation principle remains the same for all DevOps tools, including
    Jenkins, GitHub Actions, GitLab, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a list of links to articles and videos related to this topic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Terraform on Microsoft Azure – *Continuous Deployment using Azure Pipelines*:
    [https://blog.jcorioland.io/archives/2019/10/02/terraform-microsoft-azure-pipeline-continuous-deployment.html](https://blog.jcorioland.io/archives/2019/10/02/terraform-microsoft-azure-pipeline-continuous-deployment.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A CI/CD journey with Azure DevOps and Terraform: [https://medium.com/faun/a-ci-cd-journey-with-azure-devops-and-terraform-part-3-8122624efa97](https://medium.com/faun/a-ci-cd-journey-with-azure-devops-and-terraform-part-3-8122624efa97)
    (see part 1 and part 2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Deploying Terraform Infrastructure using Azure DevOps Pipelines step by step:
    [https://medium.com/@gmusumeci/deploying-terraform-infrastructure-using-azure-devops-pipelines-step-by-step-d58b68fc666d](https://medium.com/@gmusumeci/deploying-terraform-infrastructure-using-azure-devops-pipelines-step-by-step-d58b68fc666d)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Terraform deployment with Azure DevOps: [https://www.starwindsoftware.com/blog/azure-devops-terraform-deployment-with-azure-devops-part-1](https://www.starwindsoftware.com/blog/azure-devops-terraform-deployment-with-azure-devops-part-1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Infrastructure as Code (IaC) with Terraform and Azure DevOps: [https://itnext.io/infrastructure-as-code-iac-with-terraform-azure-devops-f8cd022a3341](https://itnext.io/infrastructure-as-code-iac-with-terraform-azure-devops-f8cd022a3341)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Terraform all the Things with VSTS: [https://www.colinsalmcorner.com/terraform-all-the-things-with-vsts/](https://www.colinsalmcorner.com/terraform-all-the-things-with-vsts/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Terraform CI/CD with Azure DevOps: [https://www.youtube.com/watch?v=_oMacTRQfyI](https://www.youtube.com/watch?v=_oMacTRQfyI)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Deploying your Azure Infrastructure with Terraform: [https://www.youtube.com/watch?v=JaesylupZa8](https://www.youtube.com/watch?v=JaesylupZa8)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enterprise Deployment to Azure and AWS in Azure DevOps: [https://www.hashicorp.com/resources/enterprise-deployment-to-azure-and-aws-in-azure-devops/](https://www.hashicorp.com/resources/enterprise-deployment-to-azure-and-aws-in-azure-devops/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with workspaces in CI/CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Using workspaces for managing environments* recipe in [Chapter 4](fc591e87-b893-40fa-9021-7827bffcc094.xhtml),
    *Using the Terraform CLI*, we studied the use of some Terraform commands to manage
    and create workspaces. In Terraform's vision, workspaces make it possible to manage
    several environments by creating several Terraform state files for the same Terraform
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will go further with the use of workspaces by automating
    their creation in a CI/CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The prerequisite for this recipe is to know the Terraform command-line options
    for the workspaces, the documentation for which is available at [https://www.terraform.io/docs/commands/workspace/index.html](https://www.terraform.io/docs/commands/workspace/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Concerning the CI/CD pipeline, we will implement it in Azure Pipelines, which
    we have already seen in this chapter, in the *Building CI/CD pipelines for Terraform
    configuration in Azure Pipelines *recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this recipe is to illustrate a scenario I recently implemented,
    which is the creation of on-demand environments with Terraform. These environments
    will be used to test the functionalities during the development of an application.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, we want to deploy the code of a branch of a Git repository in
    a specific environment that will be used to test this development.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use the Terraform configuration at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/workspace-pipeline](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/workspace-pipeline)
    and the YAML pipeline from [https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP07/pipeline/azure-pipelines.yml](https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP07/pipeline/azure-pipelines.yml).
    We will just complete it with our workspace management practice. We assume that
    the name of the workspace we will create will be the name of the Git branch that
    will be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: The complete source code of this recipe is available at [https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/workspace-pipeline](https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/workspace-pipeline).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To manage workspaces in the YAML pipeline, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the folder that contains the Terraform configuration, add the `ManageWorkspaces.ps1`
    file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `azure-pipelines.yaml` file, add the following code just after the
    Terraform `init` step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Commit and push the PowerShell script that we just created and the YAML pipeline
    file changes inside your Git repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Azure Pipelines, run the pipeline, and during the configuration step, choose
    the right branch to deploy to from the Branch/tag drop-down menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2aced576-143b-410c-b6d5-7f92efc7756e.png)'
  prefs: []
  type: TYPE_IMG
- en: Lastly, run the pipeline by clicking on the Run button.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, we create a PowerShell script that takes as an input parameter
    the name of the environment to create (which corresponds to the name of the branch
    to deploy). Then, in line 2, this script executes the `terraform workspace list`
    command, which displays the list of workspaces and searches for a workspace with
    the name of the environment passed as a parameter. If this search does not find
    a workspace, it executes the `terraform workspace new` command to create it. Otherwise,
    if the workspace exists, this script executes the `terraform workspace select`
    command to select it.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `terraform workspace create` command creates a workspace and selects
    it as well.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2*, we complete the YAML pipeline that we created in the previous recipe
    by inserting between `init` and `plan` the execution of this PowerShell script
    by passing as an argument the name of the branch that we sectioned.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we commit these code changes (the PowerShell script and the pipeline YAML
    file) to the Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in *step 4*, we execute the pipeline in Azure Pipelines by selecting
    the branch to be deployed, the name of which will be used as the workspace name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the execution result in the pipeline logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6ac8cfb-5e31-419a-bbba-eb4c351acabb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And in the end, we can see the Terraform state files that were created automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c89ad528-1f42-4116-a9a6-51c354b7d398.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the Terraform state files created by the workspaces contain
    the workspace name at the end.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have managed the workspaces using a PowerShell script, but
    you are of course free to write it in another scripting language of your choice,
    such as Bash or Python.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before using multiple workspaces, make sure to check their compatibility with
    the backends by following the instructions at [https://www.terraform.io/docs/state/workspaces.html](https://www.terraform.io/docs/state/workspaces.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The documentation on CLI commands for workspaces in Terraform is available at [https://www.terraform.io/docs/commands/workspace/index.html](https://www.terraform.io/docs/commands/workspace/index.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
