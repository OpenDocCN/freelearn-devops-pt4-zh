<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Extension Development Fundamentals</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we had an overview of the new Modern Development Environment and we learned how to start a new Dynamics 365 Business Central extension project by using the AL Language extension and the Modern Development Environment.</p>
<p>In this chapter, we'll examine the details of the objects of the new extension's development model and how to create new objects with AL, extend standard objects, and handle an AL extension project. More specifically, we'll cover the following topics:</p>
<ul>
<li>The basics of extension development</li>
<li>An overview of the main AL objects</li>
<li>How to create basic objects in an extension project</li>
<li>Best practices for handling your AL project</li>
<li>Guidelines for AL objects</li>
</ul>
<p>By the end of this chapter, you will have learned about the different AL object types, as well as how to create and use them, and (more generally speaking) you will be ready to start a Dynamics 365 Business Central extension project with the AL Language extension and the Modern Development Environment (Visual Studio Code).</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To follow this chapter and in order to experiment with basic object creation in the <span>AL Language</span><span>, you will need the following:</span></p>
<ul>
<li>A Microsoft Dynamics 365 Business Central sandbox environment (locally installed on a Docker container or an online one)</li>
<li>Visual Studio Code</li>
<li>The AL Language extension, which can be installed from the Visual Studio Code marketplace</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basic concepts regarding extensions</h1>
                </header>
            
            <article>
                
<p>As you already know, with Microsoft Dynamics 365 Business Central SaaS, you don't have access to the database or to the standard base code (this is different in the on-premise version, where you can still have access to the base code, and modifying that core is your responsibility). In the SaaS world, you cannot alter the database schema and cannot alter the standard business logic.</p>
<p>In the previous versions of the Microsoft Dynamics ERP, we have always talked about <em>code modification</em>. In the SaaS world, we have to start thinking about a new concept: <em>code extension</em>. To customize Dynamics 365 Business Central, you have to create <strong>extensions</strong>.</p>
<p>An extension (according to Microsoft's guidelines) is defined as <em>an installable feature built in a way that it does not directly alter source resources and that is distributed as a preconfigured package</em>.</p>
<p class="CDPAlignLeft CDPAlign">An extension interacts with the standard base code by using <em>events</em>. The following diagram shows how events interact between the different layers in a Dynamics 365 Business Central extension:</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0b0b9898-b8e8-4931-8fcb-3286f7eeed49.png" style="width:19.25em;height:18.42em;"/></p>
<p>An event is essentially a function that is triggered by code when something happens in the business process. This function is normally defined as the <em>event publisher</em> function. It comprises only a signature and does not execute any code. The object that contains the event publisher function is defined as the <em>publisher</em>.</p>
<p>In Dynamics 365 Business Central, events are classified according to the following types:</p>
<ul>
<li><strong>Database events</strong>: These are events that are automatically raised by the system during database operations on a table object (such as insert, modify, delete, and rename).</li>
<li><strong>Page events</strong>: These are events that are automatically raised by the system during operations in a page object.</li>
<li><strong>Business events</strong>: These are custom events that are raised by C/AL code. A business event defines a formal contract with an implicit promise not to change in future application releases.</li>
<li><strong>Integration events</strong>: These are custom events that are raised by C/AL code. They are similar to business events but they can change their signature in future releases of the application.</li>
<li><strong>Global events</strong>: These are system events that are raised by the application.</li>
</ul>
<p>When an event is published and raised by code, it is available in the application for subscriptions. A <em>subscriber</em> is a code function that listens for and handles a published event. It subscribes to a specific event publisher function and handles the event by adding custom business logic to it. When the application raises an event, the subscriber function is automatically called and its code is executed.</p>
<div class="packt_tip">Remember that you can have multiple subscribers to a single event publisher function. In this case, the order of the subscriber's execution cannot be determined (it's random), so be careful regarding the event chain when you architect your code.</div>
<p>Events guarantee that you can interact or modify the behavior of standard business processes without changing the base code.</p>
<div class="packt_tip packt_infobox">Dynamics 365 Business Central exposes a lot of events in its standard code and new events are added monthly. You can request new events by going to the following link: <a href="https://github.com/Microsoft/ALAppExtensions/issues">https://github.com/Microsoft/ALAppExtensions/issues</a>. To get a complete overview of published events in Dynamics 365 Business Central, I suggest that you take a look at the following GitHub repository:<a href="https://github.com/Microsoft/ALAppExtensions/issues"> </a><a href="https://github.com/waldo1001/blog.CALAnalysis/tree/master/Published%20Events">https://github.com/waldo1001/blog.CALAnalysis/tree/master/Published%20Events</a><a href="https://github.com/Microsoft/ALAppExtensions/issues">.</a></div>
<p>In this section, we learned how events are the fundamental building blocks of every AL extension. In the next section, we'll have an overview of the available AL objects and learn how to create them with the AL Language extension.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the basics of the AL Language</h1>
                </header>
            
            <article>
                
<p>An extension of Dynamics 365 Business Central is written using the <strong>AL Language</strong>. With AL, you can create new objects, extend standard objects, and create custom business logic for your application.</p>
<p>You create an extension for Dynamics 365 Business Central by using Visual Studio Code as your development environment and by using the AL Language extension (as we described in <a href="215c2304-db18-4145-bb3f-8c10cdca949d.xhtml">Chapter 2</a>, <em>Mastering a Modern Development Environment</em>). When installed, you have full support for developing AL projects.</p>
<p>All Dynamics 365 Business Central functionalities are coded as objects (new objects or extensions of standard objects), and these objects are defined in <kbd>.al</kbd> files. A single <kbd>.al</kbd> file can define multiple objects (although we don't recommend that).</p>
<p>Extensions are then compiled as <kbd>.app</kbd> package files, and this file is the final extension that you will publish in your final environment.</p>
<p>At the time of writing, the following objects are available with the <span class="packt_screen">AL Language</span> extension for Visual Studio Code:</p>
<ul>
<li>Table object</li>
<li>Table extension object</li>
<li>Page object</li>
<li>Page extension object</li>
<li>Codeunit object</li>
<li>Report object</li>
<li>Enum object</li>
<li>XMLport object</li>
<li>Query object</li>
<li>Control add-in (JavaScript)</li>
<li>Profile and page customizations</li>
</ul>
<p>We'll look at the main objects in detail in the following sections. Some of these objects (such as reports, page customizations, and add-ins) will be covered in later chapters.</p>
<p>The AL Language extension contains a lot of snippets for defining objects and for handling the language's tasks. The main standard snippets are as follows:</p>
<ul>
<li><strong>Objects</strong>:
<ul>
<li><kbd>tpagecust</kbd>: New customization of a standard page</li>
<li><kbd>tpageext</kbd>: New extension of a standard page</li>
<li><kbd>ttableext</kbd>: New extension of a standard table</li>
<li class="mce-root"><kbd>tquery</kbd>: New query</li>
<li class="mce-root"><kbd>treport</kbd>: New report</li>
<li class="mce-root"><kbd>txmlport</kbd>: New xmlport</li>
<li class="mce-root"><kbd>tpage</kbd>: Here, we can choose whether we want to get a new List or a new Card</li>
<li class="mce-root"><kbd>tcodeunit</kbd>: New codeunit</li>
</ul>
</li>
<li><strong>Code</strong>:
<ul>
<li><kbd>tcaseelse</kbd>: Case statement with else</li>
<li><kbd>tcaseof</kbd>: Case statement without else</li>
<li><kbd>tfor</kbd>: For statement</li>
<li><kbd>tforeach</kbd>: Foreach statement</li>
<li><kbd>tif</kbd>: If statement with begin and end</li>
<li><kbd>tifelse</kbd>: If statement with begin and end else</li>
<li><kbd>tisempty</kbd>: Isempty statement with begin end</li>
<li><kbd>tisemptyelse</kbd>: Isempty statement with begin end else</li>
<li><kbd>trepeat</kbd>: Repeat loop with begin and end clause</li>
<li><kbd>twhile</kbd>: While statement</li>
<li><kbd>twith</kbd>: With statement</li>
</ul>
</li>
<li><strong>Profile</strong>:
<ul>
<li><kbd>tprofile</kbd>: Allows us to create a new profile with page customizations</li>
</ul>
</li>
<li><strong>Events</strong>:
<ul>
<li><kbd>teventbus</kbd>: Allows us to create a business event</li>
<li><kbd>teventint</kbd>: Allows us to create an integration event</li>
<li><kbd>teventsub</kbd>: Allows us to create a subscriber event</li>
</ul>
</li>
<li><strong>Fields and Keys</strong>:
<ul>
<li><kbd>tfield</kbd>: New field without a type (we need to put one in manually).</li>
<li><kbd>tfieldbiginteger</kbd>: Big Integer type.</li>
<li><kbd>tfieldboolean</kbd>: Boolean field.</li>
<li><kbd>tfieldblob</kbd>: Blob field.</li>
<li><kbd>tfieldcode</kbd>: Code field. You will need just to put the length of the field.</li>
<li><kbd>tfielddate</kbd>: Date field.</li>
<li><kbd>tfielddateformula</kbd>: Dateformula field.</li>
<li><kbd>tfielddatetime</kbd>: Datetime field.</li>
<li><kbd>tfielddecimal</kbd>: Decimal field.</li>
<li><kbd>tfieldduration</kbd>: Duration field.</li>
<li><kbd>tfieldguid</kbd>: GUID field.</li>
<li><kbd>tfieldoption</kbd>: Option field. In this case, the <kbd>OptionMember</kbd> property is automatically added.</li>
<li><kbd>tfieldrecorid</kbd>: RecordID field.</li>
<li><kbd>tfieldtext</kbd>: Text field. You will need just to put the length of the field.</li>
<li><kbd>tfieldtime</kbd>: Time field.</li>
<li><kbd>tkey</kbd>: Adds a new key to a table.</li>
</ul>
</li>
<li><strong>Fields and Action on Pages</strong>:
<ul>
<li><kbd>tfieldpage</kbd>: Adds a field to a page</li>
<li><kbd>taction</kbd>: Adds an action to a page</li>
</ul>
</li>
<li><strong>T</strong><strong>riggers</strong>:
<ul>
<li><kbd>ttrigger</kbd>: Creates a trigger definition</li>
<li><kbd>tprocedure</kbd>: Creates a procedure definition</li>
</ul>
</li>
</ul>
<p>After installing the AL Language extension in Visual Studio Code, you can start a new AL project by going to <span class="packt_screen">View | Command Palette</span> and selecting <span class="packt_screen">AL:Go!</span>.</p>
<p>Visual Studio Code asks you for a folder that it can create the project in and then asks you to select the target platform (Dynamics 365 Business Central version). Select <span class="packt_screen">4.0 Business Central 2019 <span>release w</span>ave 2</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/76a129b4-ea58-4eee-9b66-f6a1088115fe.png" style="width:25.67em;height:12.33em;"/></p>
<p>Now, Visual Studio Code will configure the project for you. It creates the <kbd>launch.json</kbd> file so that you can connect to your development environment and the <kbd>app.json</kbd> file with the extension's manifest file (as described in <a href="215c2304-db18-4145-bb3f-8c10cdca949d.xhtml">Chapter 2</a>, <em>Mastering a Modern Development Environment</em>).</p>
<p>Now, you can start defining the objects that comprise your solution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Table definition</h1>
                </header>
            
            <article>
                
<p>With the AL extension, you don't have a graphical tool for designing tables (like we did previously in CSIDE); instead, you need to create a table using code.</p>
<p class="mce-root"/>
<p>A table definition can be created by using the <kbd>ttable</kbd> snippet:</p>
<pre>table id MyTable<br/>{    <br/>    DataClassification = ToBeClassified;<br/><br/>    fields<br/>    {<br/>        field(1;MyField; Integer)<br/>        {<br/>            DataClassification = ToBeClassified;          <br/>        }<br/>    }   <br/><br/>    keys<br/>    {<br/>        key(PK; MyField)<br/>        {<br/>            Clustered = true;<br/>        }<br/>    }<br/>   <br/>    var<br/>        myInt: Integer;<br/>   <br/>    trigger OnInsert()<br/>    begin<br/>       <br/>    end;<br/><br/>    trigger OnModify()<br/>    begin<br/>       <br/>    end;<br/>   <br/>    trigger OnDelete()<br/>    begin<br/>       <br/>    end;<br/>   <br/>    trigger OnRename()<br/>    begin<br/>       <br/>    end;<br/>   <br/>}</pre>
<p>To define a table, you need to specify an <em>ID</em> (which must be unique in your application) and a <em>name</em> (which must <span>also </span>be unique). Then, you can set the table's properties (use <em>Ctrl</em> + spacebar to discover all the available properties):</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bffce792-71fd-4ffb-ba92-663c196b944a.png" style="width:28.58em;height:22.08em;"/></p>
<p>A table object has the following main properties:</p>
<ul>
<li><kbd>Caption</kbd>: The string that identifies the table in the user interface.</li>
<li><kbd>DataCaptionFields</kbd>: Sets the fields that appear to the left of the caption on pages that display the content of this table.</li>
<li><kbd>DataPerCompany</kbd>: Sets a value that indicates whether the table data applies to all the companies in the database or only the current company (when default = <kbd>true</kbd>, data is only available for the current company).</li>
<li><kbd>DrillDownPageID</kbd>: Sets the ID of the page to use as a drill-down.</li>
<li><kbd>LookupPageID</kbd>: Sets the ID of the page to use as a lookup.</li>
<li><kbd>LinkedObject</kbd>: Available for on-premise only; it specifies a link to a SQL Server object.</li>
<li><kbd>Permissions</kbd>: Sets whether an object has additional permissions that are required to perform some operations on one or more tables.</li>
<li><kbd>TableType</kbd>: Specifies the table type (Normal, CRM, ExternalSQL, Exchange, or MicrosoftGraph).</li>
<li><kbd>ExternalName</kbd>: This property appears when you specify CRM or ExternalSQL in the <kbd>TableType</kbd> property and specifies the name of the original table in the external database.</li>
<li><kbd>ExternalSchema</kbd>: This property appears when you specify CRM or ExternalSQL in the <kbd>TableType</kbd> property and specifies the name of the database schema in the external database.</li>
<li><kbd>ReplicateData</kbd>: Specifies whether the table must be replicated to the cloud service (the default value is true).</li>
<li><kbd>Extensible</kbd>: <span>Sets whether the object can be extended or not.</span></li>
</ul>
<p>A table object contains a set of fields. A table's field can be created by using the <kbd>tfield</kbd> snippet:</p>
<pre>field(id; MyField; Blob)<br/>{<br/>    DataClassification = ToBeClassified;<br/>    FieldPropertyName = FieldPropertyValue;<br/>}</pre>
<p>A field is defined by an <em>ID</em> (which must be unique within the declaring table and all its extensions), a <em>name</em> (which must <span>also </span>be unique within the declaring table and all its extensions), and a <em>type</em> (the data type of the field).</p>
<p>It's recommended to always set the <kbd>Caption</kbd> property (for tables and fields) and to set the <kbd>DataClassification</kbd> property (used for defining the data sensitivity for GDPR regulations) to a value other than <kbd>ToBeClassified</kbd>. A field can have its own specific properties that you can set as needed (optional properties, as shown in the following screenshot):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b8264379-9c65-4a61-8fab-e37b94c9e958.png" style="width:33.25em;height:18.25em;"/></p>
<p class="mce-root"/>
<p>A table also contains a set of <em>keys</em>. You can define keys using the <kbd>tkey</kbd> snippet:</p>
<pre>key(MyKey; MyField)<br/>{<br/>           <br/>}</pre>
<p>A table's key is defined by a <em>name</em> and the <em>fields</em> that comprise the key (a comma-separated list of table fields). A key can have the <kbd>Clustered</kbd> property set to <kbd>true</kbd> if it's the primary key of the table. A clustered index is a special type of index that reorders the way the records in the table are physically stored, and so a table can have only one clustered index.</p>
<p>A table can also have triggers (<kbd>OnInsert</kbd>, <kbd>OnModify</kbd>, <kbd>OnDelete</kbd>, and <kbd>OnRename</kbd>), and inside a table, you can define your own methods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Page object definition</h1>
                </header>
            
            <article>
                
<p>A page object is the user interface for your users in Dynamics 365 Business Central. You can define a page object in AL using the <kbd>tpage</kbd> snippet:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5a02afc5-14a3-43c0-9220-6a04d9880558.png" style="width:37.25em;height:20.67em;"/></p>
<p>The first three options allow you to create the following page types:</p>
<ul>
<li><kbd>Card</kbd> page</li>
<li><kbd>API</kbd> page</li>
<li><kbd>List</kbd> page</li>
</ul>
<p class="mce-root"/>
<p>A <kbd>Card</kbd> page (the first option) is defined as follows:</p>
<pre>page Id MyPage<br/>{<br/>    PageType = Card;<br/>    ApplicationArea = All;<br/>    UsageCategory = Administration;<br/>    SourceTable = TableName;<br/>   <br/>    layout<br/>    {<br/>        area(Content)<br/>        {<br/>            group(GroupName)<br/>            {<br/>                field(Name; NameSource)<br/>                {<br/>                    ApplicationArea = All;                   <br/>                }<br/>            }<br/>        }<br/>    }<br/>   <br/>    actions<br/>    {<br/>        area(Processing)<br/>        {<br/>            action(ActionName)<br/>            {<br/>                ApplicationArea = All;           <br/>                trigger OnAction()<br/>                begin<br/>                   <br/>                end;<br/>            }<br/>        }<br/>    }<br/>   <br/>    var<br/>        myInt: Integer;<br/>}</pre>
<p>A <kbd>Card</kbd> page is identified by its <em>ID</em> and its <em>name</em> (both of which must be unique inside the application). A page also has its own properties. The main things to define are as follows:</p>
<ul>
<li><kbd>PageType</kbd>: Identifies the type of the page.</li>
<li><kbd>SourceTable</kbd>: Sets the underlying table for this page.</li>
<li><kbd>SourceTableView</kbd>: Sets the key, sort order, and filter you want to use to determine the view of the source table presented to the user.</li>
<li><kbd>ApplicationArea</kbd>: Sets the visibility of the page inside the Business Central application. The standard values are All, Basic, Suite, and Advanced.</li>
<li><kbd>UsageCategory</kbd>: Sets the Departments column for the searched page in the web client.</li>
<li><kbd>Extensible</kbd>: <span>Sets whether the object can be extended or not.</span></li>
</ul>
<p>A page has a <kbd>layout</kbd> (which defines the page appearance in the UI) and an <kbd>actions</kbd> section (which defines the available menu items for adding code actions inside a page). Inside the layout, you have a content area, which contains a set of groups, and every group can contain one or more page fields. You can add a field inside a page group by using the <kbd>tpagefield</kbd> snippet:</p>
<pre>field(MyField; FieldSource)<br/>{<br/>    ApplicationArea = All<br/>    FieldPropertyName = FieldPropertyValue;<br/>}</pre>
<p>A field on a page is defined by a <em>name</em> (the field keyword inside the page) and a <em>field source</em> (the source expression of the page field, which corresponds to the physical fields defined in the underlying table).</p>
<p>A field can have its own properties and it must have an <kbd>ApplicationArea</kbd> set.</p>
<p>A <kbd>List</kbd> page (the third option) is defined as follows:</p>
<pre>page Id PageName<br/>{<br/>    PageType = List;<br/>    ApplicationArea = All;<br/>    SourceTable = TableName;<br/>   <br/>    layout<br/>    {<br/>        area(Content)<br/>        {<br/>            repeater(Group)<br/>            {<br/>                field(Name; NameSource)<br/>                {<br/>                    ApplicationArea = All;<br/>                   <br/>                }<br/>            }<br/>        }<br/><br/>        area(Factboxes)<br/>        {<br/>           <br/>        }<br/>    }<br/>   <br/>    actions<br/>    {<br/>        area(Processing)<br/>        {<br/>            action(ActionName)<br/>            {<br/>                ApplicationArea = All;<br/>               <br/>                trigger OnAction();<br/>                begin<br/>                   <br/>                end;<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>A <kbd>List</kbd> page has the <kbd>PageType</kbd> property set to <kbd>List</kbd> and the <kbd>layout</kbd> section has a <kbd>Content</kbd> area and a <kbd>FactBox</kbd> area. The <kbd>Content</kbd> area has a <kbd>repeater</kbd> group, which contains all the fields you want to display on that list. After that, you have the <kbd>actions</kbd> section.</p>
<p>If your page contains a <kbd>repeater</kbd> control (for example, a <kbd>List</kbd> page), you can define actions that apply to the entire page or to the repeater control itself (a single record). For this, the action has a property called <strong>Scope</strong>, which can be defined as a <em>page</em> (the action is at the page level) or a <kbd>repeater</kbd> (the action is at the record level).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Table extension definition</h1>
                </header>
            
            <article>
                
<p>As we mentioned previously, with Dynamics 365 Business Central, you cannot modify an existing table; instead, you need to create a table extension.</p>
<p>A table extension can be defined by using the <kbd>ttableext</kbd> snippet:</p>
<pre>tableextension Id MyExtension extends MyTargetTable<br/>{<br/>    fields<br/>    {<br/>        // Add changes to table fields here<br/>    }<br/>   <br/>    var<br/>        myInt: Integer;<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>A <kbd>tableextension</kbd> object is defined by an <em>ID</em> and a <em>name</em> (which must be unique) and by the table that must be extended (or altered). Then, inside the fields group, you can add new fields or change existing field properties.</p>
<p>The following code is an example of an extension to the standard <kbd>Customer</kbd> table that adds some new fields and changes an existing field property:</p>
<pre>tableextension 50100 CustomerExtSD extends Customer<br/>{<br/>    fields<br/>    {<br/>        field(50100; PacktEnabledSD; Boolean)<br/>        {<br/>            DataClassification = CustomerContent;<br/>            Caption = 'Packt Subscription Enabled';<br/>        }<br/>        field(50101; PacktCodeSD; Code[20])<br/>        {<br/>            DataClassification = CustomerContent;<br/>            Caption = 'Packt Subscription Code';<br/>        }<br/><br/>        modify("Net Change")<br/>        {<br/>            BlankZero = true;<br/>        }<br/>    }   <br/>}</pre>
<p>In a <kbd>tableextension</kbd> object, you can also add new keys to the extended table by adding a <em>keys</em> group, like you can in a table definition. For example, in our previous <kbd>tableextension</kbd> object, we've added two new fields, and we want also to create a secondary key on those fields in the <kbd>Customer</kbd> table. We can create a <kbd>key</kbd> group with the key name and the key fields:</p>
<pre>tableextension 50100 CustomerExtSD extends Customer<br/>{<br/>    fields<br/>    {<br/>        field(50100; PacktEnabledSD; Boolean)<br/>        {<br/>            DataClassification = CustomerContent;<br/>            Caption = 'Packt Subscription Enabled';<br/>        }<br/>        field(50101; PacktCodeSD; Code[20])<br/>        {<br/>            DataClassification = CustomerContent;<br/>            Caption = 'Packt Subscription Code';<br/>        }<br/>        modify("Net Change")<br/>        {<br/>            BlankZero = true;<br/>        }<br/>    }<br/><br/>    keys<br/>    {<br/>       key(PacktKey; PacktCodeSD,PacktEnabledSD)<br/>       {<br/>           <br/>       }<br/>    }<br/>}</pre>
<div class="packt_infobox">You cannot create a key based on a new field or a standard field, and you cannot alter an existing key in an extended table.</div>
<p>Here, we have defined a secondary key called <kbd>PacktKey</kbd> i<span>n the</span><span> </span><kbd>Customer</kbd> <span>table, which consists of </span><span>two custom fields</span> (<kbd>PacktCodeSD</kbd> <span>and</span> <kbd>PacktEnabledSD</kbd><span>). Defining secondary keys is extremely useful for increasing the performance of some calculations, sorting records, and reports.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Page extension definition</h1>
                </header>
            
            <article>
                
<p>Exactly like tables, with Dynamics 365 Business Central, you cannot directly modify an existing page; instead, you need to create a page extension (using the <kbd>pageextension</kbd> object in AL).</p>
<p>A <kbd>pageextension</kbd> object can be defined by using the <kbd>tpageext</kbd> snippet:</p>
<pre>pageextension Id MyExtension extends MyTargetPage<br/>{<br/>    layout<br/>    {<br/>        // Add changes to page layout here<br/>    }<br/>   <br/>    actions<br/>    {<br/>        // Add changes to page actions here<br/>    }<br/>   <br/>    var<br/>        myInt: Integer;<br/>}</pre>
<p>A <kbd>pageextension</kbd> object is defined by an <em>ID</em> and a <em>name</em> (which must be unique) and by the page that must be extended. A <kbd>pageextension</kbd> object contains a <kbd>layout</kbd> block (where you can add changes to the standard page layout, such as adding new fields or new sections or changing standard fields) and an <kbd>actions</kbd> block (where you can add your new actions).</p>
<p>The following is an example of a <kbd>pageextension</kbd> object in which we have added a new field to the <kbd>Customer Card</kbd> page (the field is added at the end of the <kbd>General</kbd> tab) and we have modified the <kbd>Style</kbd> property of an existing field (the <kbd>Name</kbd> field):</p>
<pre>pageextension 50100 CustomerCardExtSD extends "Customer Card"<br/>{<br/>    layout<br/>    {<br/>        addlast(General)<br/>        {<br/>            field(PacktEnabledSD; PacktEnabledSD)<br/>            {<br/>                ApplicationArea = All;               <br/>            }<br/>        }<br/><br/>        modify(Name)<br/>        {<br/>            Style = Strong;<br/>        }<br/>    }       <br/>}</pre>
<p>As you can see, we have added a field to the page and modified the <kbd>Style</kbd> property of the <kbd>Name</kbd> field so that it is in bold. Remember that not all the available field properties can be modified via a <kbd>pageextension</kbd> object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Codeunit definition</h1>
                </header>
            
            <article>
                
<p>A codeunit is a container of AL code, and this code can be triggered by directly executing the codeunit (with the <kbd>OnRun</kbd> trigger) or by calling the functions defined in the codeunit itself.</p>
<p class="mce-root"/>
<p>We can define a codeunit in AL by using the <kbd>tcodeunit</kbd> snippet:</p>
<pre>codeunit Id MyCodeunit<br/>{<br/>    trigger OnRun()<br/>    begin<br/>       <br/>    end;<br/>   <br/>    var<br/>        myInt: Integer;<br/>}</pre>
<p>A codeunit is defined by an <em>ID</em> and a <em>name</em> (which must be unique inside your application). By default, the codeunit skeleton only contains the <kbd>OnRun</kbd> trigger definition, and inside this trigger, you can write the code that you want to execute when calling the <kbd>Codeunit.RUN</kbd> method.</p>
<p>A codeunit has its own properties that you can set:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2de302f6-93b0-4dcb-b29d-3de9bfa8e97d.png" style="width:31.17em;height:19.58em;"/></p>
<p>In a codeunit, you can define procedures (functions) that can be local to the codeunit or global (that is, publicly exposed to objects that instantiate the codeunit).</p>
<p>A procedure can be defined by using the <kbd>tprocedure</kbd> snippet:</p>
<pre>local procedure MyProcedure()<br/>   var<br/>        myInt: Integer;<br/>    begin<br/>       <br/>    end;</pre>
<p class="mce-root"/>
<p>By default, this snippet creates a local procedure without parameters and without a return value. You can change the scope from local (the default value, meaning that it is visible only inside the object that declares the procedure) to global (so that it is <span>also </span>visible outside the object) by removing the <kbd>local</kbd> <span>keyword</span>.</p>
<p>As an example, this is a global procedure with parameters and a return value:</p>
<pre>procedure CheckIfPacktCustomerIsEnabled(CustomerNo: Code[20]): Boolean<br/>    var<br/>     //Local variables here <br/>    begin<br/>      //Method code here <br/>    end;</pre>
<p>A codeunit can have more than one procedure (local or global) defined.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Event definitions</h1>
                </header>
            
            <article>
                
<p>As we mentioned previously, events are fundamental building blocks when it comes to developing extensions for Dynamics 365 Business Central. When working with events, we have two main entities: the event <em>publisher</em> and the event <em>subscriber</em>.</p>
<p>An <strong>event publisher</strong> (an event that's raised by the application) can be defined in AL by using the <strong>teventbus</strong> (for a business event) or <strong>teventint</strong> (for an integration event) snippets:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c67bafb2-7efd-40a4-b321-8c1667fdd4d8.png" style="width:42.92em;height:8.50em;"/></p>
<p>A <strong>business event</strong> has the following schema:</p>
<pre>[BusinessEvent(IncludeSender)]<br/>    local procedure MyProcedure()<br/>    begin<br/><br/>    end;</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Here, <kbd>IncludeSender</kbd> is a Boolean value that specifies whether the global methods defined in the object that contain the event publisher method will be visible to the event subscriber methods that will subscribe to this event (this is <kbd>true</kbd> if the global methods must be visible and <kbd>false</kbd> (the default value) if not).</p>
<p>When the <kbd>IncludeSender</kbd> argument is set to <kbd>true</kbd>, the signature of the event subscriber methods that will subscribe to this published event will automatically include a <kbd>VAR</kbd> parameter (a reference value) for the published event object.</p>
<p>An <strong>integration event</strong> has the following schema:</p>
<pre>[IntegrationEvent(IncludeSender,GlobalVarAccess)]<br/>    local procedure MyProcedure()<br/>    begin<br/><br/>    end;</pre>
<p>Here, the <kbd>IncludeSender</kbd> Boolean parameter has the same meaning as we described previously.</p>
<p><kbd>GlobalVarAccess</kbd> is a Boolean parameter that specifies whether the global variables defined in the object, which contains the event publisher method, are accessible to the event subscriber methods that subscribe to this published event (this is <kbd>true</kbd> if they must be exposed and <kbd>false</kbd> <span>– </span>which is the default value <span>– </span>if not).</p>
<p>When the <kbd>GlobalVarAccess</kbd> argument is set to <kbd>true</kbd>, all the event subscriber methods that subscribe to this event will be able to access the global variables in the object where the event publisher method is declared. You have to manually add the variable parameters to the event subscriber methods, and you need to use a name and a type that match the variable declaration in the event publisher object.</p>
<p>After an event has been published by an event publisher (your previously defined method), you need to raise that event in your code where needed (event subscribers will not react to the event until it's raised in your application code).</p>
<p>As an example, the following is a codeunit with a public method that raises a business event and an integration event:</p>
<pre>codeunit 50100 MyCodeunit<br/>{<br/>    procedure CheckIfPacktCustomerIsEnabled(CustomerNo: Code[20]): Boolean<br/>    begin<br/>        //Raising a business event<br/>        MyBusinessEvent('XXX');<br/>       <br/>        //Other code here...<br/><br/>        //Raising an integration event<br/>        MyIntegrationEvent('YYY'); <br/>    end;<br/><br/>    [BusinessEvent(true)]<br/>    local procedure MyBusinessEvent(ID: Code[20])<br/>    begin<br/>    end;<br/><br/>    [IntegrationEvent(true,true)]<br/>    local procedure MyIntegrationEvent(ID: Code[20])<br/>    begin<br/>    end;      <br/><br/>    //Global variables<br/>    var<br/>        myInt: Integer;<br/>        Customer: record Customer;<br/>}</pre>
<p>An <strong>event subscriber</strong> (a function that handles a raised event in the application) can be declared using the <kbd>teventsub</kbd> snippet:</p>
<pre>[EventSubscriber(ObjectType::ObjectType, ObjectID, 'OnSomeEvent', 'ElementName', SkipOnMissingLicense, SkipOnMissingPermission)]<br/>local procedure MyProcedure()    <br/>begin<br/>      <br/>end;</pre>
<p>From the preceding code, we can see the following:</p>
<ul>
<li><kbd>ObjectType</kbd> is an enumeration that identifies the object type that publishes the event to subscribe to (the object that contains the event publisher method) or that raises the trigger event to subscribe to.</li>
<li><kbd>ObjectId</kbd> is an integer value that specifies the ID of the object that publishes the event to subscribe to (when declaring it, don't use the ID; use the <kbd>ObjectType::Name</kbd> <span>syntax</span>).</li>
<li><kbd>OnSomeEvent</kbd> is a text parameter that specifies the name of the method that publishes the event in the object identified by the <kbd>ObjectId</kbd> parameter.</li>
<li><kbd>ElementName</kbd> is a text parameter that's used for database trigger events. It specifies the table field that the trigger event pertains to.</li>
<li><kbd>SkipOnMissingLicense</kbd> is a Boolean parameter that specifies what happens to the event subscriber method when the Dynamics 365 Business Central license of the user account that runs the current session does not include the permissions on the object that contains the subscriber method (<kbd>true</kbd><em> </em>if the method call must be ignored and <kbd>false</kbd> if an error must be thrown and the code's execution must be stopped).</li>
<li><kbd>SkipOnMissingPermission</kbd> is a Boolean parameter that specifies what happens to the subscriber method when the user account that runs the current session does not have permission on the object that contains the event subscriber method (<kbd>true</kbd> if the method call must be ignored and <kbd>false</kbd> (the default value)<em> </em><span>if an error must be thrown and the code execution must be stopped</span>).</li>
</ul>
<p>As an example, this is a codeunit with two event subscribers for the business and integration events we defined in the previous example:</p>
<pre>codeunit 50101 MySubscriberCodeunit<br/>{<br/>    [EventSubscriber(ObjectType::Codeunit, Codeunit::MyCodeunit, 'MyBusinessEvent', '', false, false)]<br/>    local procedure MyBusinessEventSubscriber(ID: Code[20])<br/>    begin<br/>       <br/>    end;<br/><br/>    [EventSubscriber(ObjectType::Codeunit, Codeunit::MyCodeunit, 'MyIntegrationEvent', '', false, false)]<br/>    local procedure MyIntegrationEventSubscriber(ID: Code[20])<br/>    begin<br/>        <br/>    end;   <br/>}</pre>
<p class="CDPAlignLeft CDPAlign">When defining the event subscriber, if you press <em>Ctrl</em> + spacebar on the event parameters, you will see a list of the objects that the event can interact with (exposed by the publisher). In our example, the business event subscriber can see the event parameter and the sender object (because we've declared the event publisher with <kbd>IncludeSender</kbd> set to <kbd>true</kbd>), as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a671131f-dfce-4ad3-8021-cb37b4518ff2.png" style="width:32.75em;height:8.50em;"/></p>
<p>The integration event subscriber can see the event parameter, the sender object (because we've declared the event publisher with <kbd>IncludeSender</kbd> set to <kbd>true</kbd>), and the global variables of the sender object (because we've declared the event publisher with <kbd>GlobalVarAccess = true</kbd>):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d0630f16-21ce-4050-99eb-556b165df950.png" style="width:50.83em;height:11.42em;"/></p>
<p>When using events, always remember the following:</p>
<ul>
<li>When the code that calls the event publisher method is run, all the event subscriber methods that subscribe to the event are run.</li>
<li>If there are multiple subscribers, the subscriber methods are run one at a time in a random order (there's no way to specify the order in which the subscriber methods are called).</li>
<li>If there are no subscribers to the published event, then the line of code that calls the event publisher method is ignored and not executed.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">XMLport definition</h1>
                </header>
            
            <article>
                
<p><strong>XMLports</strong> are objects that are used for importing and exporting XML or text-based data between an external source and Dynamics 365 Business Central.</p>
<p>An XMLport can be defined in AL by using the <kbd>txmlport</kbd> snippet:</p>
<pre>xmlport Id MyXmlport<br/>{<br/>    schema<br/>    {<br/>        textelement(NodeName1)<br/>        {<br/>            tableelement(NodeName2; SourceTableName)<br/>            {<br/>                fieldattribute(NodeName3; NodeName2.SourceFieldName)<br/>                {<br/>                   <br/>                }<br/>            }<br/>        }<br/>    }<br/>   <br/>    requestpage<br/>    {<br/>        layout<br/>        {<br/>            area(content)<br/>            {<br/>                group(GroupName)<br/>                {<br/>                    field(Name; SourceExpression)<br/>                    {<br/>                       <br/>                    }<br/>                }<br/>            }<br/>        }<br/>   <br/>        actions<br/>        {<br/>            area(processing)<br/>            {<br/>                action(ActionName)<br/>                {<br/>                   <br/>                }<br/>            }<br/>        }<br/>    }<br/>   <br/>    var<br/>        myInt: Integer;<br/>}</pre>
<p>As an example, this is a simple XMLport definition for importing some customer data (the <kbd>No.</kbd> and <kbd>Name</kbd> fields):</p>
<pre>xmlport 50100 MyXmlportImportCustomer<br/>{<br/>    Direction = Import;<br/>    schema<br/>    {<br/>        textelement(NodeName1)<br/>        {<br/>            tableelement(Customer; Customer)<br/>            {<br/>                fieldattribute(No; Customer."No.")<br/>                {<br/>                   <br/>                }<br/>                fieldattribute(Name; Customer.Name)<br/>                {<br/>                   <br/>                }<br/>            }<br/>        }<br/>    }  <br/>}</pre>
<p>The <kbd>xmlport</kbd> object has the <kbd>Direction</kbd> property set to <kbd>Import</kbd> (only used for importing data to Dynamics 365 Business Central) and reads the <kbd>No</kbd> and <kbd>Name</kbd> fields from an XML object called <kbd>Customer</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining query objects</h1>
                </header>
            
            <article>
                
<p>A <kbd>query</kbd> object allows you to define an object that can be used to retrieve data from a single table or from multiple tables by applying filters and joins between tables. The returned result is a single dataset.</p>
<p>You can create a query in AL by using the <kbd>tquery</kbd> snippet:</p>
<pre>query Id MyQuery<br/>{<br/>    QueryType = Normal;<br/>   <br/>    elements<br/>    {<br/>        dataitem(DataItemName; SourceTableName)<br/>        {<br/>            column(ColumnName; SourceFieldName)<br/>            {<br/>               <br/>            }<br/>            filter(FilterName; SourceFieldName)<br/>            {<br/>               <br/>            }<br/>        }<br/>    }<br/>   <br/>    var<br/>        myInt: Integer;<br/>   <br/>    trigger OnBeforeOpen()<br/>    begin<br/>       <br/>    end;<br/>}</pre>
<p>As you can see, a <kbd>query</kbd> object has an <kbd>elements</kbd> section, and inside that section, you define a <kbd>dataitem</kbd> and its <kbd>column</kbd> elements that must be retrieved (the table fields to be included in the resulting dataset).</p>
<p>You can also create links between <kbd>dataitems</kbd> to retrieve data from more than one table.</p>
<p class="mce-root"/>
<p>As an example, the following is a <kbd>query</kbd> object that's been defined in AL so that it retrieves a list of customers, along with their sales and profit data:</p>
<pre>query 50100 "Customer Overview"<br/>{<br/>    Caption = 'Customer Overview';<br/>    elements<br/>    {<br/>        dataitem(Customer; Customer)<br/>        {<br/>            column(Name; Name)<br/>            {<br/>            }<br/>            column(No; "No.")<br/>            {<br/>            }<br/>            column(Sales_LCY; "Sales (LCY)")<br/>            {<br/>            }<br/>            column(Profit_LCY; "Profit (LCY)")<br/>            {<br/>            }<br/>            column(Country_Region_Code; "Country/Region Code")<br/>            {<br/>            }<br/>            column(City; City)<br/>            {<br/>            }          <br/>            column(Salesperson_Code; "Salesperson Code")<br/>            {<br/>            }<br/><br/>            dataitem(Salesperson_Purchaser; "Salesperson/Purchaser")<br/>            {<br/>                DataItemLink = Code = Customer."Salesperson Code";<br/>                column(SalesPersonName; Name)<br/>                {<br/>                }<br/>                dataitem(Country_Region; "Country/Region")<br/>                {<br/>                    DataItemLink = Code = Customer."Country/Region Code";<br/>                    column(CountryRegionName; Name)<br/>                    {<br/>                    }<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p><span>The query loops through the <kbd>Customer</kbd> table and then (for every customer) retrieves data from the other tables specified in the </span><kbd>DataItemLink</kbd><span> property.</span></p>
<p>Query objects are extremely useful and powerful for retrieving records in your code. The first basic problem that you can solve with query objects is to avoid using nested loops when retrieving data from linked tables (joins). If you have <kbd>Table1</kbd> linked through a foreign key to <kbd>Table2</kbd>, instead of looping through <kbd>Table1</kbd> and, for every record of this table, going to <kbd>Table2</kbd> to retrieve the related data, you can use a query object and apply the pattern described in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bf854d9f-10d7-46ff-9419-915f201d56d0.png" style="width:42.42em;height:30.08em;"/></p>
<p>Here, you can define a query that returns the full filtered join of the two tables and then you can loop through the record set that's returned by the query object (this requires only one loop).</p>
<p>If (as an example) we want to use our previously defined <kbd>Customer Overview</kbd> query in our code, this is what we have to do in AL:</p>
<pre>procedure UseCustomerOverviewQuery()<br/>    var<br/>        CustomerOverview: Query "Customer Overview";<br/>    begin<br/>        if not CustomerOverview.Open() then<br/>            exit;<br/>        while CustomerOverview.Read() do<br/>        begin<br/>            //Here we have all joined records to loop<br/>        end;<br/>    end;</pre>
<p>Here, we execute the query object by calling the <kbd>Open</kbd> method, and then we loop through the returned dataset by using the <kbd>Read</kbd> method. Inside the loop, you have the complete record being returned by the query (the master table and the joined tables) and you can work on this data as needed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extending the options – enums</h1>
                </header>
            
            <article>
                
<p>A field of the <strong>option</strong> type is used in Dynamics 365 Business Central to define a field that provides a fixed and predefined list of values.</p>
<p>When you define an option field, you define the admitted values for that field in the following way:</p>
<pre>field(5; LicenseType; Option)<br/>{            <br/>    OptionMembers = " ","Full","Limited";<br/>    OptionCaption = ' ,Full,Limited';<br/>    Caption = 'License Type';<br/>    DataClassification = CustomerContent;<br/>}</pre>
<p>In the preceding code, we can see that the <kbd>OptionMembers</kbd> property contains the predefined value for the field. Here, the License Type field contains three values (blank, Full, Limited), and blank (the first value) is the default one.</p>
<p>But what if you want to extend these options, for example, by adding a new license type called <em>Teams</em>? This isn't possible! Option fields cannot be extended.</p>
<p class="mce-root"/>
<p>To create an extendable option field, AL introduced the <kbd>enum</kbd> object. An e<em>num</em> is a type that consists of a set of named constants, and it can be extended from other extensions if you set the <kbd>Extensible</kbd> property to <kbd>true</kbd>, as shown here:</p>
<pre>enum 50100 LicenseType<br/>{<br/>  Extensible = true;<br/>  value(0; None) { }<br/>  value(1; Full) { }<br/>  value(2; Limited) { }  <br/>}</pre>
<p>You can define a field so that it has the <kbd>enum</kbd> type in the following way:</p>
<pre>field(50100; LicenseType; enum LicenseType)<span>     <br/></span>{<br/>    Caption = 'License Type';<br/>    DataClassification = CustomerContent;<br/>}</pre>
<p>This allows you to define a field that has the same behavior as an option: when a user clicks on that field, Dynamics 365 Business Central presents a list of possible values to choose from.</p>
<p>To extend the <kbd>enum</kbd> field from another extension and add a new possible value called <kbd>Team</kbd>, you need to create an <kbd>enumextension</kbd> object, as follows:</p>
<pre>enumextension 50110 LicenseTypeEnumExt extends LicenseType<br/>{<br/>  value(50110; Team)<br/>  {<br/>    Caption = 'Team License';<br/>  }<br/>}</pre>
<p>After that, your <kbd>License Type</kbd> field will have one more option value to choose from.</p>
<p>You can also use an <kbd>enum</kbd> object directly from AL code (as a variable):</p>
<pre>var<br/>    LicenseType: enum LicenseType;<br/>begin<br/>    case LicenseType of<br/>        LicenseType::Full:<br/>              //Write your code here…</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>You can also extend the <kbd>TableRelation</kbd> property of an <kbd>enum</kbd> value. For example, imagine you have the following table:</p>
<pre>table 50120 LicenseDetail<br/>{<br/>  fields<br/>  {<br/>     field(1; Id; Integer) { }<br/>     field(2; LicenseType; enum LicenseType) { }<br/>     field(3; LicenseDetail; Code[20])<br/>     {<br/>        TableRelation =<br/>        if (LicenseType = const (Full)) FullLicenseTable<br/>        else if (LicenseType = const (Limited)) LimitedLicenseTable;<br/>    }<br/>  }<br/>}</pre>
<p>In this table, we have a field called <kbd>LicenseType</kbd> (which is an <kbd>enum</kbd>) and a field called <kbd>LicenseDetail</kbd>, which has a <kbd>tablerelation</kbd> property (to the <kbd>FullLicenseTable</kbd> and <kbd>LimitedLIcenseTable</kbd> <span>tables</span>) based on the value of the <kbd>enum</kbd> field.</p>
<p>Another app could extend both the <kbd>enum</kbd> field and the table relation so that it can<span> </span>handle the new extended enum. Here's an example:</p>
<pre>enumextension 50110 LicenseTypeEnumExt extends LicenseType<br/>{<br/>  value(50110; Team)<br/>  {<br/>    Caption = 'Team License';<br/>  }<br/>}<br/><br/>tableextension 50110 LicenseDetailExt extends LicenseDetail<br/>{<br/>  fields<br/>  {<br/>    modify(LicenseDetail)<br/>    {<br/>      TableRelation = if (LicenseType = const (Team)) TeamLicenseTable;<br/>    }<br/>  }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>Here, the new app creates the <kbd>LicenseType</kbd> enum extension (as we described <span>previously</span>) and creates a new <kbd>tableextension</kbd> object, where it modifies the <kbd>TableRelation</kbd> property of the <kbd>LicenseDetail</kbd> field by adding a new relationship to a <kbd>TeamLicenseTable</kbd> if the enum has the value of <kbd>Team</kbd>.</p>
<div class="packt_infobox">The combined <kbd>TableRelation</kbd> is always evaluated from the top down, so the first unconditional relationship will prevail. This means that you cannot change an existing <kbd>TableRelation</kbd> from table A to table B if the original field has a relationship with table A.</div>
<p>By using <kbd>enums</kbd>, you can extend all your option's values. We recommend using this new approach in your extensions if you want extensibility.</p>
<p>In this section, you've had a complete overview of the available objects in the AL Language extension. In the next section, we'll learn about some of the best practices when it comes to creating and handling an AL project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a profile object</h1>
                </header>
            
            <article>
                
<p>A <kbd>profile</kbd> object allows you to define the user experience (main page) of a particular user profile. You can create a <kbd>profile</kbd> object with the AL Language extension by using the <kbd>tprofile</kbd> snippet.</p>
<p>A profile object is defined as in the following example:</p>
<pre>profile "SALES MANAGER"<br/>{<br/>  Caption = 'Sales Manager';<br/>  ProfileDescription = 'Functionality for sales managers';<br/>  RoleCenter = 9005;<br/>  Enabled = false;<br/>}</pre>
<p>Here, we have defined a profile called <strong>Sales Manager</strong>, which uses the <kbd>RoleCenter</kbd> page with <kbd>ID = 9005</kbd> (standard Sales Manager role center object in Dynamics 365 Business Central).</p>
<p>To deploy a <kbd>profile</kbd> object from your extension, I recommend creating a <kbd>Profile</kbd> folder in your AL project and, inside that folder, placing all the <kbd>.al</kbd> files that define your profiles.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding AL project structure best practices</h1>
                </header>
            
            <article>
                
<p>As we mentioned previously, an AL project is file-based. You have all your <kbd>.al</kbd> files inside a project folder. The main problem that you encounter when you start working with a complex project is how to structure the project. How do we organize the objects and the <kbd>.al</kbd> files?</p>
<p>There's no written rule for this topic. What we wholeheartedly suggest is to avoid having all the objects (<kbd>.al</kbd> files) at the project root level, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e9f8cf4b-750b-4f97-8368-cf847df4c532.png" style="width:24.42em;height:25.33em;"/></p>
<p>Here, none of the objects are organized, and if you have a large number of objects, your object list will grow a lot, causing difficulties with handling and retrieving files.</p>
<p class="mce-root"/>
<p>The most sought-after way of structuring your project could be to organize your files by object type, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b7304209-a466-48b0-bcac-edf3fc7d38b8.png" style="width:30.83em;height:38.00em;"/></p>
<p>Here, all the extension's code is inside the <kbd>SRC</kbd> folder. Then, all the objects are organized per type, according to the objects that we have defined (there's a subfolder for every object type that we have in our solution). It's easier to find an object with this organization (just go to the object type folder), but this project structure has a drawback: it's not easy to recognize the objects that we need in order to implement a particular business functionality in our extension project.</p>
<p class="mce-root"/>
<p>Our suggestion is to try to organize your project tree first by functionality and then by object type, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/99fc5863-4178-4171-aa26-d395a490171d.png" style="width:28.75em;height:44.83em;"/></p>
<p class="mce-root"/>
<p>Here, in the SRC folder, there are two subfolders: <kbd>Functionality1</kbd> and <kbd>Functionality2</kbd>. In these folders, objects are organized by type. This is our recommended way of working, and this structure helps us find objects by functionality.</p>
<p>In the next section, we'll learn how to name objects in AL and how to use object ranges.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Naming guidelines and AL object ranges</h1>
                </header>
            
            <article>
                
<p>When creating extensions for Dynamics 365 Business Central, you need to assign a numerical ID to your objects. The rules for assigning object IDs are as follows:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Range</strong></p>
</td>
<td>
<p><strong>Purpose</strong></p>
</td>
</tr>
<tr>
<td>
<p>0 – 49,999</p>
</td>
<td>
<p>Business Central base application. It cannot be used by partners.</p>
</td>
</tr>
<tr>
<td>
<p>5,0000 – 99,999</p>
</td>
<td>
<p>Per-tenant extensions (resellers who want to customize the delivered solution to the individual needs of a customer).</p>
</td>
</tr>
<tr>
<td>
<p>80,000 – 99,999</p>
</td>
<td>
<p>Extended objects that you have to modify the permissions of in your development license.</p>
</td>
</tr>
<tr>
<td>
<p>100,000 – 999,999</p>
</td>
<td>
<p>Reserved for localizing Dynamics 365 Business Central for a specific country or region. It cannot be used by partners.</p>
</td>
</tr>
<tr>
<td>
<p>1,000,000 – 69,999,999</p>
</td>
<td>
<p><strong>Registered Solution Program</strong> (<strong>RSP</strong>) range.</p>
</td>
</tr>
<tr>
<td>
<p>70,000,000 – 74,999,999</p>
</td>
<td>
<p>Business Central SaaS apps (AppSource).</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Regarding file naming, each <kbd>.al</kbd> filename must start with the corresponding object type prefix and object ID and must be written only with characters [<kbd>A-Za-z0-9</kbd>]. The file naming notation (which is mandatory for <kbd>AppSource</kbd>) should be as follows:</p>
<ul>
<li>Full objects: <kbd>&lt;ObjectNameExcludingPrefix&gt;.&lt;FullTypeName&gt;.al</kbd></li>
<li>Extension objects: <kbd>&lt;ObjectNameExcludingPrefix&gt;.&lt;FullTypeName&gt;Ext.al</kbd></li>
</ul>
<p class="mce-root"/>
<p>For each object type, you can use the following abbreviation (prefixes):</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<thead>
<tr>
<td>
<p><strong>Object Type</strong></p>
</td>
<td>
<p><strong>Abbreviation (prefix)</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
<p>Page</p>
</td>
<td>
<p><kbd>Page</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Page Extension</p>
</td>
<td>
<p><kbd>PageExt</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Page Customization</p>
</td>
<td>
<p><kbd>PageCust</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Codeunit</p>
</td>
<td>
<p><kbd>Codeunit</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Table</p>
</td>
<td>
<p><kbd>Table</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Table Extension</p>
</td>
<td>
<p><kbd>TableExt</kbd></p>
</td>
</tr>
<tr>
<td>
<p>XML Port</p>
</td>
<td>
<p><kbd>Xmlport</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Report</p>
</td>
<td>
<p><kbd>Report</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Query</p>
</td>
<td>
<p><kbd>Query</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Enum</p>
</td>
<td>
<p><kbd>Enum</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Enum Extension</p>
</td>
<td>
<p><kbd>EnumExt</kbd></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>As an example, here are some AL objects and their corresponding filenames:</p>
<ul>
<li>Table 50100 <em>Book</em> should be called <kbd>Book.Table.al</kbd></li>
<li>Page 50100 <em>Book Card</em> should be called <kbd>BookCard.Page.al</kbd></li>
<li>Codeunit 50110 <em>Book Management</em> should be called <kbd>BookManagement.Codeunit.al</kbd></li>
<li>Pageextension 50101 <kbd>MyCustomerCardExt</kbd>, which extends <kbd>Customer Card</kbd>, should be called <kbd>CustomerCard.PageExt.al</kbd></li>
</ul>
<p>You should also use a prefix/suffix to target your objects (reserved for you by Microsoft, as we'll explain later). This allows you to have objects that are named in a unique way between extensions, which avoids naming conflicts.</p>
<p>The rules for using the prefix/suffix are as follows:</p>
<ul>
<li>The prefix/suffix must be at least three characters long.</li>
<li>The object/field name must start or end with the prefix/suffix.</li>
<li>When you modify a core Dynamics 365 object using a table extension or a page extension, the prefix/suffix must be defined at the control/field/action/group level.</li>
<li>Use a caption to handle the label that you want in the UI.</li>
</ul>
<p>For example, if you have reserved the <kbd>PACKT</kbd> prefix and you want to create a field called <kbd>CustomerCategory</kbd>, the valid field names that you can use are as follows:</p>
<ul>
<li><kbd>PACKTCustomerCategory</kbd></li>
<li><kbd>CustomerCategoryPACKT</kbd></li>
<li><kbd>CustomerCategory_PACKT</kbd></li>
<li><kbd>CustomerCategory PACKT</kbd></li>
</ul>
<p>If you want to create the <em>Customer Category</em> table, the valid names for the table object are as follows:</p>
<ul>
<li>table 70000000 <kbd>PACKT Customer Category</kbd></li>
<li>table 70000000 <kbd>Customer Category PACKT</kbd></li>
<li>table 70000000 <kbd>Customer Category_PACKT</kbd></li>
</ul>
<p>Using the reserved name as a prefix or a suffix is absolutely your choice. We prefer to use it as a suffix because it's more natural to find the field with Visual Studio IntelliSense (if the field that appears to you in the UI is Customer Category, typing these words will present the real field name, along with its suffix).</p>
<p>These guidelines are mandatory for AppSource, but are not mandatory for your per-tenant extensions. Our suggestion is to always follow these guidelines.</p>
<p>To register a prefix/suffix for your objects, you need to send an email to <kbd>d365val@microsoft.com</kbd> specifying the name you want to reserve for your app. Remember that the prefix/suffix should be app-based and not company-based.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working on AL coding guidelines</h1>
                </header>
            
            <article>
                
<p>When creating your AL project (and your <kbd>.al</kbd> files), remember to always follow these main guidelines.</p>
<p>Inside a <kbd>.al</kbd> code file, the structure for all your objects must follow this sequence:</p>
<ul>
<li>Properties</li>
<li>Object-specific constructs:
<ul>
<li>Table fields</li>
<li>Page layout</li>
<li>Actions</li>
</ul>
</li>
<li>Global variables:
<ul>
<li>Labels (old text constants)</li>
<li>Global variables</li>
</ul>
</li>
<li>Methods</li>
</ul>
<p>Remember to always reference the AL objects by their object name and not by their ID. So, for example, this is how you reference a <kbd>Record</kbd> variable or a <kbd>Page</kbd> variable:</p>
<pre>Vendor: Record <strong>Vendor</strong>;<br/>Page.RunModal(<strong>Page::"Customer Card"</strong>, ...);</pre>
<p>In an event subscriber object, this is how you should reference the publisher object:</p>
<pre>[EventSubscriber(ObjectType::Codeunit, <strong>Codeunit</strong><strong>::MyCodeunit</strong>, 'MyIntegrationEvent', '', false, false)]<br/>local procedure MyIntegrationEventSubscriber()<br/>begin<br/>end;</pre>
<p>So, let's sum this up:</p>
<ul>
<li><strong>Format your AL code</strong>: Take care of indentation and spacing (it keeps the code more readable). You can use <em>Alt</em> + <em>Shift</em> + <em>F</em> to auto-format your code.</li>
<li><strong>Keep your .al files clean</strong>: <span>When using snippets, they automatically create an object skeleton with methods, properties, variables, triggers, or sections that you might not be using. Please remove all the code that isn't being used. A typical example is triggers definitions on tables (which you can remove if you're not handling them) or global variables inside objects (if you don't remove them, your app will be full of myInt: integer variables).</span></li>
<li><strong>Method declarations</strong><span>: Be as local as possible. Only use global methods if you need to expose them to other objects.</span></li>
<li><strong>Use events to trigger business logic, but</strong> <strong>do not code in these triggers</strong>: <span>Putting a lot of code inside triggered events is just like putting a lot of code into field validation triggers. Identify your methods instead and call them from the triggered events.</span></li>
</ul>
<p>For complex code, you can start using the <em>Generic Method</em> pattern:</p>
<ul>
<li>Declare each method on its class (table).</li>
<li>Each method is a codeunit on its own (encapsulation).</li>
<li>Invoke a method only from its class (table/codeunit).</li>
<li>Each method's codeunit only has one global function.</li>
<li>Local functions include the following categories (in this order):
<ol>
<li>Main (one function; a method header in the form of a readable flowchart)</li>
<li>Main business process (multiple functions)</li>
<li>UI wrapper (two functions)</li>
<li>Business extension (one or more functions to provide extensibility)</li>
<li>Event wrapper (two functions)</li>
</ol>
</li>
</ul>
<p>This is an example of some AL code that's been organized according to this pattern:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a7f27459-d4c4-42bf-bc77-8f6805fc6b2d.png"/></p>
<div class="packt_infobox">You can find more information regarding other coding rules to follow at <a href="https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/compliance/apptest-bestpracticesforalcode">https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/compliance/apptest-bestpracticesforalcode</a>.</div>
<p>Respecting coding rules and guidelines is extremely important for increasing code readability, and many of these rules are mandatory for AppSource.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked at the fundamentals of extension development with the AL Language, along with an overview of the main objects for creating applications (tables, pages, codeunits, and so on) and how to create them in Visual Studio Code. Then, we had an overview of the best practices for handling an AL project (project organization, object IDs, naming conventions) and guidelines for writing better code by focusing on the extensibility aspect of our extensions.</p>
<p>We learned how to create objects, how to create an AL project, how to handle its structure, and how to stick to naming conventions with objects.</p>
<p>In the next chapter, we'll implement a real-word extension for Dynamics 365 Business Central by applying all these rules and best practices.</p>


            </article>

            
        </section>
    </body></html>