<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Installing and Upgrading Extensions</h1>
                </header>
            
            <article>
                
<p>Acquiring the Installed status for an extension is a four-step procedure: publish, synchronize, upgrade (if and where needed), and install. In this chapter, we will cover each of these steps <span>in detail</span>.</p>
<p>Installing a simple or even a complex extension with the most exotic code artifacts might turn out to be an easy task compared to its maintenance. The maintenance of an extension is done through the upgrade process of the extension. An upgrade may be needed because of the <span>introduction of a </span>new feature, bug fixes or, quite frequently with SaaS, because of dependency changes from the base app.</p>
<p>Throughout this chapter, we will explore both basic extension installation and complex dependency upgrade<span>s</span> in order to help AL developers have a better understanding of how to review their <kbd>SaaSified</kbd> private IPs.</p>
<p>With a continuous upgrade process that happens roughly every month, Dynamics 365 Business Central online is an ever-changing and evolutionary product. Therefore, partners and customers should be ready to upgrade their extensions to cope with the monthly update releases of both platforms and applications. </p>
<p>In this chapter, you will learn how to do the following:</p>
<ul>
<li>Deploy extensions in an online sandbox and production environment</li>
<li>Check the status for published, synchronized, and installed extensions</li>
<li>Handle install codeunits</li>
<li>Handle breaking changes through upgrade codeunits</li>
<li>Define app dependencies</li>
<li>Work with a simple upgrade scenario</li>
<li>Upgrade extensions with dependencies</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying extensions</h1>
                </header>
            
            <article>
                
<p>Like in any other programming language, the terminology is very important. It is vital to clearly understand and distinguish the different deployment phases and statuses for the extension in order to target the appropriate troubleshooting, where necessary.</p>
<p>Depending on the development life cycle and deployment, extensions fall into two categories:</p>
<ul>
<li><strong>Per tenant extensions (PTE)</strong>: This resembles the old-school development, tailored per customer. Development is typically performed per tenant in a sandbox that contains a copy of the production configuration and data. The CSP partner and/or its reseller, together with the customer, manage the development and deployment the life cycle.<br/>
Despite the fact that this is, historically, the most common scenario for on-premises ERP development, partners are encouraged to create their own standard extension to be deployed and/or sold through the Dynamics 365 Business Central Marketplace.</li>
<li><strong>AppSource extensions</strong>: These are published on AppSource and their destiny is to be consumed by any/all tenants on a given system, acquired via the official Dynamics Marketplace. AppSource extensions follow a very strict process of technical and marketing validation before being approved and pushed as being worldwide (globally) available for production tenant deployments.<br/>
Different from PTEs, AppSource-credited extensions are already published by Microsoft in every application database, ready to be installed per tenant on demand. This makes the extension deployment process faster, more reliable, and more professional.</li>
</ul>
<p>PTEs can be deployed in two ways:</p>
<ul>
<li>Automatically</li>
<li>Manually</li>
</ul>
<p>Let's take a look at both of these deployments here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Automatically</h1>
                </header>
            
            <article>
                
<p>In Visual Studio Code, you have to set up <kbd>launch.json</kbd> to work against a specific target sandbox tenant environment (<kbd>"tenant": ""</kbd>) and provide the appropriate credentials to establish a connection.</p>
<p>Since you may have several sandboxes within the same environment, you can also specify which tenant you want to connect to download symbols and/or publish the extension (<kbd>"sandboxName": ""</kbd>).</p>
<div class="packt_infobox"><span>This is not possible in online production environments, only in sandboxes. </span><span>This is only possible for PTEs. PTEs that are deployed in this way are often called developer extensions, since they can only target developer sandboxes.</span></div>
<p>By default, the deployment is executed by applying a synchronization to the existing schema (<kbd>"schemaUpdateMode": "Synchronize"</kbd>). The default option, then, is useful for preserving the data, just in case the developer has made some changes that do not involve any breaking changes. It is, however, possible to completely clean up any previous extension deployment and deploy it from scratch (<kbd>"schemaUpdateMode": "Recreate"</kbd>) or even force the synchronization (<kbd>"schemaUpdateMode": "ForceSync"</kbd>) to guarantee fast deployment and further tests to the extension.</p>
<div class="packt_infobox">ForceSync has to be used with caution and should be avoided as much as possible. Even if we speed up deployment and tests, it will not work in a production environment where an upgrade codeunit job is required. Sometimes, lazy developers might use ForceSync and forget to handle the appropriate upgrade and synchronization in production.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Manually</h1>
                </header>
            
            <article>
                
<p>The typical production deployment is done manually. It is also possible in online sandboxes since the April 2019 update, as follows:</p>
<ol>
<li>Connect to your production or sandbox tenant.</li>
<li>Search (<em>Alt</em> + <em>Q</em>) for the <span class="packt_screen">Extension Management</span> page.</li>
</ol>
<ol start="3">
<li>In the <span class="packt_screen">Extension Management</span> page, click on the <span class="packt_screen">Manage</span> action group (you could pin it if you wanted to), choose <span class="packt_screen">Upload Extension</span>, and pick up the extension (<kbd>.app</kbd>) you developed. The following screenshot shows the u<span>pload and deploy</span> <span>page</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ad01b062-d2fc-46f5-9da7-79dd59bc2b4c.png" style="width:32.58em;height:19.50em;"/></p>
<p>In the screenshot, we see that the <span class="packt_screen">Deploy to</span> parameter is very important, because it triggers when the extension has to be deployed by the platform.</p>
<p>By specifying <span class="packt_screen">Current version</span>, the deployment is performed immediately and the extension attempts to be synchronized. Developers can check whether the task has completed successfully, or if there have been failure errors in the <span class="packt_screen">Deployment status</span> page.</p>
<p>Selecting <span class="packt_screen">Next Minor Version</span> or <span class="packt_screen">Next Major Version</span> defers the deployment to when the next minor or major update would happen.</p>
<div class="packt_infobox">To find out more about this topic, visit <a href="https://demiliani.com/2019/04/29/dynamics-365-business-central-and-per-tenant-extensions-check-page-control-names-between-platform-upgrades/">https://demiliani.com/2019/04/29/dynamics-365-business-central-and-per-tenant-extensions-check-page-control-names-between-platform-upgrades/</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Some deployment tips</h1>
                </header>
            
            <article>
                
<p>Developers must have it etched on their mind that Dynamics 365 Business Central is a multitenant environment that declares the following paradigms:</p>
<ul>
<li>Applications and data are decoupled and stored in different databases.</li>
<li>A single application database, bound to an application service, could serve hundreds of tenants (customer data databases). This is the pillar of the one-to-many concept of multitenancy.</li>
<li>In the application, the database is stored as the extension manifests (records that store the definition of the extension as it appears in the <kbd>app.json</kbd> file).</li>
<li>Mounting and synchronizing tenants in a service bound to an application database would expose these extensions to the tenants.</li>
<li>Tenant extensions could then be chosen for installation by users.</li>
</ul>
<p>Whenever a minor update (typically monthly) or major update (typically every six months) happens, the extensions will be uninstalled. Subsequently, the tenant will be dismounted from the old application service and mounted to another application service that is bound to the new application version.</p>
<p>Even if the new application service has not published the PTE, the tenant structure and its data will be totally preserved.</p>
<p>Whenever this operation happens, developers <span>just</span><span> </span><span>have to publish and install the extension once again, to resynchronize everything. This is valid, as mentioned, for all online sandboxes.</span></p>
<p>PTEs that are deployed in the production environment have a more global scope, and extensions are automatically ported into the new application service. Within this context, if an extension is chosen to be deployed with the next minor/major version, when the upgrade happens, the new extension will be triggered for installation.</p>
<p>To get a deeper overview of this topic, visit <a href="https://demiliani.com/2019/01/24/dynamics-365-business-central-tenant-upgrade-extensions-disappeared-in-sandbox-environment/">https://demiliani.com/2019/01/24/dynamics-365-business-central-tenant-upgrade-extensions-disappeared-in-sandbox-environment/</a>.</p>
<p>PTEs must maintain their uniqueness across the ecosystem, and developers should not violate this principle. The uniqueness of a PTE, or any extension in general, is defined by the composition of the following values in the <kbd>app.json</kbd> file:</p>
<ul>
<li><strong>Package ID</strong>: A new GUID assigned to the .app file every time the extension is built (<em>Ctrl</em> + <em>Shift</em> + <em>B</em>).</li>
<li><strong>Application ID</strong>: The unique GUID that defines the extension.</li>
<li><strong>Name</strong></li>
<li><strong>Publisher</strong></li>
<li><strong>Version</strong>: (in the form of <kbd>x.x.x.x</kbd>).</li>
</ul>
<p>Whenever one of these values is changed, <span>the extension is considered to be a new extension</span>. If a developer is considering reusing a PTE for another customer tenant, then they have to deal with this uniqueness paradigm.</p>
<p>Trying to deploy the very same PTE in another tenant, or even redeploying the same after rebuilding the package, might lead to a failure with an error like the one shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5565a9cc-79bb-479d-b704-8e23db0c0674.png" style="width:29.75em;height:11.08em;"/></p>
<p>In this case, it might be necessary to simply increase (bump) the application version to make the deployment work smoothly.</p>
<p>If this happens in the tenant in which the PTE has never been installed before, then the root cause might be <span><span>a duplicate within the same application service</span></span>. To resolve the issue, the developer has to change the application ID and the name, and redeploy it in order to install the PTE successfully.</p>
<p>For a deeper overview of this issue, visit <a href="https://demiliani.com/2019/03/14/dynamics-365-business-central-online-sandbox-makes-you-crazy-maybe-remember-these-points/">https://demiliani.com/2019/03/14/dynamics-365-business-central-online-sandbox-makes-you-crazy-maybe-remember-these-points/</a>.</p>
<div>
<p>There are another two error messages that might typically arise when deploying extensions. These are:</p>
<ul>
<li>
<p>Cannot install the extension <kbd>&lt;name&gt;</kbd> by <kbd>&lt;publisher&gt;</kbd> because the tenant <kbd>&lt;Tenant</kbd> Id&gt; already uses a different version of it.</p>
</li>
<li>
<p>The application extension with app id <kbd>'&lt;Extension Id&gt;'</kbd> is already configured for use by the global tenant. </p>
</li>
</ul>
<p>The first error occurs because it has tried to publish a Per tenant extension with the same Application Id and Version parameters as another Per tenant extension which is present on the system, but with potentially different contents. The easiest solution to this error is to increase the version of the extension.</p>
<p>The second error occurs because it has tried to upload a Per tenant extension using the same Id as one assigned to an AppSource Extension or a standard Microsoft owned extension. In this case, the solution is quite straightforward: change the extension Id and republish. </p>
</div>
<p>In the next section, we'll see what happens under the hood when you deploy an extension.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deployment under the hood</h1>
                </header>
            
            <article>
                
<p><span>Deploying any type of extension in an online sandbox</span> <span>means the following:</span></p>
<ul>
<li><span>The extension is published in a specific application service with a specific application version.</span></li>
<li><span><span>The same extension</span> is <span>synchronized (the Azure SQL database structure matches the object metadata definition) and installed in the sandbox tenant.</span></span></li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Extension deployment can be summarized in four phases:</p>
<ul>
<li><strong>P<span>ublish</span></strong>: The extension is uploaded into the application database onto which the reference tenant is mounted during the publishing process. There are no changes in the physical structure of the tables in the tenant database.<br/>
Publishing means a declaration of the object contents (metadata) and the database structure changes that need to be applied on demand by a specific tenant. These contents and relative changes are defined by the AL objects (such as tables, pages, and page extensions).</li>
<li><strong>Synchronize</strong>: The contents that are published might be transferred to the tenant as is (such as pages or codeunits) or they might require an extra action to be taken against the tenant data structure (such as a table or a table extension). The most important step in the synchronization process is to apply changes to the underlying database, typically a table structure as defined in the AL objects. This is the step where tables are created or new fields are added or modified inside the tenant database.</li>
<li><strong>Data Upgrade</strong>: If there are changes in the application version, then, after the synchronization, it must follow a data upgrade. When running the data upgrade, the application will search for upgrade codeunits and run the code inside them.<br/>
A data upgrade is typically necessary when you have to handle breaking changes, such as changing a data type for a field, or when you are enhancing existing extension features that are already deployed.</li>
<li><strong>Install</strong>: When both metadata changes and data upgrades are performed successfully, everything is ready in the tenant to provide all the functionality to the users. This last operation changes the status of the extension to Installed, and the application is extended and is ready to be used with the new functionalities.</li>
</ul>
<p>To demonstrate these phases in a prototype real-life development scenario, let's create a simple extension and double-check what's happening behind the scenes using a Docker-contained environment.</p>
<div class="packt_infobox">At the time we are writing, Dynamics 365 Business Central Spring 2019 release is the latest version available, hence, what will follow is based on that major release. </div>
<p>We have a PowerShell script that will perform the following activities:</p>
<ul>
<li>Install or update the <kbd>NavContainerHelper</kbd> library to the latest version.</li>
<li>Prompt you to provide a name <span>and password </span>for a user to be used inside the container.</li>
<li>Generate a Docker-contained sandbox using the latest Dynamics 365 Business Central version and update.</li>
<li>Create a folder in the desktop with the same name as the container and move all the relevant shortcuts created by the <kbd>New-NAVContainer</kbd> cmdlet <span>in to there.</span></li>
</ul>
<p>The script can be seen in the following code:</p>
<pre>#Set local variables<br/>####################<br/>$imageName = "mcr.microsoft.com/businesscentral/sandbox:1904" <br/>$containerName = "BC14MTW1" <br/>$createDirectory = $true #move shortcuts into a directory<br/>$checkHelper = $true #install navcontainerhelper<br/>#Install or update NavContainerHelper<br/>#####################################<br/>Clear-Host<br/>if ($checkHelper)<br/>{<br/>Write-Host 'Installing navcontainerhelper module, please wait...'<br/>install-module navcontainerhelper -force<br/>      Write-Host 'Checking navcontainerhelper module updates, please wait...'<br/>   update-module navcontainerhelper -force<br/>   Get-InstalledModule navcontainerhelper | Format-List -Property name, version   <br/>}<br/>#Create a new container  <br/>#######################<br/>New-NavContainer -accept_eula `<br/>           -containerName $containerName `<br/>           -useBestContainerOS `<br/>           -imageName $imageName `<br/>           -auth NavUserPassword `<br/>           -alwaysPull `<br/>           -updateHosts `<br/>           -licenseFile $mylicense `<br/>           -assignPremiumPlan `<br/>           -doNotExportObjectsToText `<br/>           -multitenant `<br/>           -includeCSide<br/>#Create a desktop directory and move all the shortcuts  <br/>######################################################<br/>if ($createDirectory)<br/>{<br/>    $desktop = [System.Environment]::GetFolderPath('Desktop')<br/>    New-Item -Path $desktop -Name $containerName -ItemType 'directory' -Force<br/>    Get-ChildItem $desktop -Filter "$containerName*" -File | Move-Item -Destination "$desktop\$containerName"<br/>    $code = @'<br/>[System.Runtime.InteropServices.DllImport("Shell32.dll")]<br/>private static extern int SHChangeNotify(int eventId, int flags, IntPtr item1, IntPtr item2);<br/>public static void Refresh()  {<br/> SHChangeNotify(0x8000000, 0x1000, IntPtr.Zero, IntPtr.Zero);   <br/>}<br/>'@<br/>    Add-Type -MemberDefinition $code -Namespace WinAPI -Name Explorer<br/>    [WinAPI.Explorer]::Refresh()<br/>}</pre>
<p>After running the script, there should be a new directory in the desktop named <kbd>BC14MTW1</kbd>, with six shortcuts inside, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/27b28765-fc3d-42f9-aaa0-7e0cccb6d01e.png" style="width:16.50em;height:12.75em;"/></p>
<p>By running SQL Server Management Studio (SSMS – see <a href="https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017">https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017</a>), we can connect to the <span class="packt_screen">BC14MTW1\SQLEXPRESS</span> server inside the container using SQL Server authentication. The following screenshot shows a <span>list of the databases in the</span> <span class="packt_screen">BC14MTW1\SQLEXPRESS</span> <span>instance</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f9d5cb4e-d7dd-4a63-9677-0207445a61c7.png" style="width:26.42em;height:9.75em;"/></p>
<p>It's worth noticing that there are three databases allocated with a multitenancy Docker-contained environment:</p>
<ul>
<li><span class="packt_screen">CRONUS</span>: This is an application database. It contains all the system tables that are needed to manage the application objects (such as objects and object metadata) that are shared through customer tenants.</li>
<li><span class="packt_screen">default</span> and <span class="packt_screen">tenant</span>: <span class="packt_screen">default</span> is the sandbox that is mounted against the <span class="packt_screen">CRONUS</span> application. <span class="packt_screen">tenant</span> is just a dismounted copy of default.</li>
</ul>
<p>In this environment, we will now focus on the following deployments:</p>
<ul>
<li>The main extension, which contains a new table and a table extension</li>
<li>The second extension, which depends on the main extension</li>
<li>A new version of the main extension that contains a breaking change (a change that impacts the schema synchronization)</li>
<li>A new version of the second extension to cope with the main extension breaking change</li>
</ul>
<p>Understanding how to perform the aforementioned deployments is vital in order to master both simple and complex extension deployments.</p>
<p>To download symbols from this multitenant, on-premises, Docker-contained environment, we will use the following <kbd>launch.json</kbd> file parameters:</p>
<pre>{<br/> "version": "0.2.0",<br/> "configurations": [<br/> {<br/> "type": "al",<br/> "request": "launch",<br/> "name": "Your own server",<br/> "server": "http://BC14MTW1",<br/> "serverInstance": "NAV",<br/> "authentication": "UserPassword",<br/> "tenant": "default"<br/> }<br/> ]<br/>}</pre>
<p><span>Using this very simple script, we have created our own Docker-contained multitenant environment to mimic a sandbox SaaS deployment. We are now ready to start our extension deployment journey, and analyze what is happening at the database level and in the application.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying the main extension</h1>
                </header>
            
            <article>
                
<p>To make it very simple, we will create a brand new table (<kbd>Tab50105.NewTable.al</kbd>) with a few fields in it: </p>
<pre>table 50105 "NewTable"<br/>{<br/>    DataClassification = ToBeClassified;<br/>   fields<br/>     {<br/>        field(1;"Entry No."; Integer)<br/>        {<br/>          DataClassification = ToBeClassified;<br/>        }<br/>        field(2;"Description"; Text [30] )<br/>        {<br/>           DataClassification = ToBeClassified;<br/>        }<br/>        field(3; "Posting Date"; Date) <br/>        {<br/>           DataClassification = ToBeClassified;  <br/>        }<br/>        field(4; "Open"; Boolean)<br/>        {<br/>          DataClassification = ToBeClassified;  <br/>        }<br/>     }<br/>      keys<br/>      {<br/>         key(PK; "Entry No.")<br/>          { <br/>             Clustered = true;<br/>          }<br/>      }<br/>}</pre>
<p><span>Then, we create a table extension (</span><kbd>Tab-Ext50105.NewTableExtension.al</kbd><span>) that extends the standard</span> <kbd>Item</kbd> <span>table with a new field called</span> <kbd>Catalogue No<strong><em>.</em></strong></kbd><span>:</span></p>
<pre>tableextension 50105 "New Table Extension" extends Item<br/>{<br/>   fields<br/>      {<br/>       field(50105;"Catalogue No.";Integer)<br/>          {<br/>             DataClassification = ToBeClassified;  <br/>          }<br/>      }<br/>}</pre>
<p>This will be the very first version of the extension, with the following parameters in the manifest file (<kbd>app.json</kbd>), which define the extension:</p>
<pre>  "id": "15ecd2e5-b7a8-4612-ae6f-d722af29c0c0",<br/>  "name": "MainExtension",<br/>  "publisher": "DTacconi Inc.",<br/>  "version": "1.0.0.0",</pre>
<p>Typically (but it's not mandatory), extensions use a special codeunit called the installation codeunit. The installation codeunit is defined with <kbd>Subtype = Install</kbd>, and its execution is triggered every time the extension is installed. Its main purpose is to configure the extension during the installation by creating a record in a setup table, or by populating the table with default values.</p>
<p>In the following code example, we will design an installation codeunit <span>(</span><kbd>Cod50100.MainExtensionInstall.al</kbd><span>):</span></p>
<ol>
<li>We begin by creating a record in the new table:</li>
</ol>
<pre style="padding-left: 60px">codeunit 50100 "MainExtensionInstall"<br/>{<br/>    Subtype = Install;<br/><br/>    trigger OnInstallAppPerCompany();<br/>    var<br/>        NewTable : Record NewTable;<br/>    begin       <br/>        if NewTable.IsEmpty() then<br/>          InsertDefaultValues();<br/>    end;<br/><br/>    local procedure InsertDefaultValues();<br/>    begin<br/>        InsertValue(1,'Activity Start',TODAY,false);<br/>        InsertValue(2,'First Activity',TODAY,false);<br/>        InsertValue(3,'Second Activity',TODAY,false);<br/>    end;<br/><br/>    local procedure InsertValue(EntryNo : Integer; Desc : Text[30]; PostingDate : <br/>    Date; isOpen : Boolean);<br/>    var<br/>        NewTable : Record NewTable;<br/>    begin<br/>        NewTable.Init();<br/>        NewTable."Entry No." := EntryNo;<br/>        NewTable.Description := Desc;<br/>        NewTable."Posting Date" := PostingDate;<br/>        NewTable.Open := isOpen;<br/>        NewTable.Insert();<br/>    end;<br/>}</pre>
<p style="padding-left: 60px">Since you can install and uninstall the extension at will, and however many times you want, the key point here is to check whether <kbd>NewTable.IsEmpty()</kbd> performs the activity exactly in the first installation. That code snippet will make sure to populate the table with some default values, but only if it is needed.</p>
<div class="packt_tip">Uninstalling an extension with Dynamics 365 Business Central SaaS will always be performed while preserving the data. They are not cleaned up, but are simply made not visible as the extension uninstalls. Re-installing the extension will bring the old saved data back again. The cloud paradigm is to be conservative in all shapes, and no data will ever be deleted behind the scenes.</div>
<ol start="2">
<li>After building the extension (<em>Ctrl</em> + <em>Shift</em> + <em>B</em>), we are ready to deploy the app file using the following sequence of PowerShell cmdlets, which are contained in the <kbd>NavContainerHelper</kbd> PowerShell library:
<ul>
<li><kbd>Publish-BCContainerApp</kbd></li>
<li><kbd>Sync-BCContainerApp</kbd></li>
<li><kbd>Start-BCContainerAppDataUpgrade</kbd></li>
<li><kbd>Install-BCContainerApp</kbd></li>
</ul>
</li>
<li>After the execution of each PowerShell cmdlet, we will check the content of the relevant system tables that are involved in the extension deployment, synchronization, and upgrade mechanism. We will use the following simple T-SQL script by swapping <kbd>[Name]</kbd> and <kbd>[Version Major]</kbd> in the <kbd>DECLARE</kbd> sections with the appropriate extension name and major version:</li>
</ol>
<pre style="padding-left: 60px">-- Application database<br/>USE "CRONUS"<br/>GO<br/><br/>DECLARE @PackageID uniqueidentifier<br/>SELECT @PackageID = NavApp.[Package ID]<br/>FROM [CRONUS].[dbo].[NAV App] NavApp<br/>WHERE (([Name] = 'MainExtension') and ([Version Major] = 1))<br/><br/>SELECT * FROM [NAV App] WHERE [Package ID] = @PackageID<br/>SELECT * FROM [NAV App Dependencies] WHERE [Package ID] = @PackageID<br/>SELECT * FROM [NAV App Object Metadata] WHERE [App Package ID] = @PackageID<br/>SELECT * FROM [NAV App Object Prerequisites] WHERE [Package ID] = @PackageID <br/>SELECT * FROM [NAV App Publish Reference] WHERE [App Package ID] = @PackageID<br/>SELECT * FROM [NAV App Resource] WHERE [Package ID] = @PackageID<br/>SELECT * FROM [NAV App Tenant App] WHERE [App Package ID] = @PackageID<br/><br/>-- Tenant database<br/>USE "default"<br/>GO<br/><br/>DECLARE @AppID uniqueidentifier<br/>DECLARE @PackageID uniqueidentifier<br/>SELECT @AppID = NavApp.ID, @PackageID = NavApp.[Package ID]<br/>FROM [CRONUS].[dbo].[NAV App] NavApp<br/>WHERE (([Name] = 'MainExtension') and ([Version Major] = 1))<br/><br/>SELECT * FROM [$ndo$navappschemasnapshot] WHERE appid = @AppID<br/>SELECT * FROM [$ndo$navappschematracking] WHERE appid = @AppID<br/>SELECT * FROM [$ndo$navappuninstalledapp] WHERE appid = @AppID<br/>SELECT * FROM [NAV App Data Archive] WHERE [App ID] = @AppID<br/>SELECT * FROM [NAV App Installed App] WHERE ([App ID] = @AppID) and ([Package ID] = @PackageID)<br/>SELECT * FROM [NAV App Published App] WHERE ([App ID] = @AppID) and ([Package ID] = @PackageID)<br/>SELECT * FROM [NAV App Setting] WHERE [App ID] = @AppID<br/>SELECT * FROM [NAV App Tenant Add-In] WHERE [App ID] = @AppID</pre>
<ol start="4">
<li>Next, you will observe in the following code that the publish action will declare the extension manifest in the <kbd>[NAV App]</kbd> table with a specific package ID, and its application ID in the application database (which is called <kbd>CRONUS</kbd>):</li>
</ol>
<pre style="padding-left: 60px">Publish-BCContainerApp -containerName 'BC14MTW1' `<br/>    -appFile 'C:\TEMP\UPGRADE\MainExtension\DTacconi Inc._MainExtension_1.0.0.0.app' `<br/>    -skipVerification</pre>
<div class="packt_infobox"><span>The source code for the <kbd>Publish-BCContainerApp</kbd> script is available here: </span><a href="https://github.com/Microsoft/navcontainerhelper/blob/master/AppHandling/Publish-NavContainerApp.ps1">https://github.com/Microsoft/navcontainerhelper/blob/master/AppHandling/Publish-NavContainerApp.ps1</a></div>
<p style="padding-left: 60px">Then, the object that is contained in the extension is extracted and populates <kbd>[NAV App Object Metadata]</kbd>, the table in the application database.</p>
<p style="padding-left: 60px">A <span>metadata </span><span>record is also created in the</span> <kbd>[NAV App Resource]</kbd> <span>table, and contains the permission object.</span></p>
<p style="padding-left: 60px">No action is performed in the tenant database (named <kbd>default</kbd>) at this stage. The following screenshot shows the relevant query result snippet after the main extension has been published:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0357f059-0bc9-4095-8ca5-505aaacefe07.png" style="width:61.92em;height:13.25em;"/></p>
<ol start="5">
<li>After publishing the main extension, we need to synchronize its content and apply metadata changes to the database structure, if and where needed. <span>Consider the following code:</span></li>
</ol>
<pre style="padding-left: 60px">Sync-BCContainerApp -containerName 'BC14MTW1' `<br/>    -tenant 'default' `<br/>    -appName 'MainExtension' `<br/>    -Mode Add</pre>
<div class="packt_infobox">The source code of the <kbd>Sync.BCContainerApp</kbd> script is available here: <a href="https://github.com/microsoft/navcontainerhelper/blob/master/AppHandling/Sync-NavContainerApp.ps1">https://github.com/microsoft/navcontainerhelper/blob/master/AppHandling/Sync-NavContainerApp.ps1</a>.<a href="https://github.com/microsoft/navcontainerhelper/blob/master/AppHandling/Sync-NavContainerApp.ps1"/></div>
<p style="padding-left: 60px">This action will synchronize the extension metadata content of the main extension in the application database (in this example, CRONUS) against a specific mounted tenant (in this example, default). Practically, it will create records in the tenant <kbd>[$ndo$navappschemasnapshot]</kbd> table for every object that has an impact on schema changes at the database level, such as tables and/or table extensions.</p>
<ol start="6">
<li>One record is also created in the <kbd>[$ndo$navappschematracking]</kbd> table to correlate the objects in the snapshot table with the extension ID, name, publisher, and version. The following screenshot shows the relevant query result snippet after the main app synchronizes:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/550eb0d7-c281-4855-976c-a5f9e207c8d4.png" style="width:60.92em;height:8.67em;"/></p>
<p style="padding-left: 60px">When the extension is synchronized, the next step is to perform a data upgrade, if and where needed. Consider the following code:</p>
<pre style="padding-left: 60px">Start-BCContainerAppDataUpgrade -containerName 'BC14MTW1' `<br/>    -tenant 'default' `<br/>    -appName 'MainExtension' `<br/>    -appVersion '1.0.0.0'</pre>
<div class="packt_infobox">The s<span>ource code for the <kbd>Start-BCContainerAppDataUpgrade</kbd> script is available here: </span><a href="https://github.com/microsoft/navcontainerhelper/blob/master/AppHandling/Start-NavContainerAppDataUpgrade.ps1">https://github.com/microsoft/navcontainerhelper/blob/master/AppHandling/Start-NavContainerAppDataUpgrade.ps1</a>.</div>
<ol start="7">
<li>If you run the data upgrade now, this has no effect, since there is no previous extension from which to upgrade. The PowerShell cmdlet will return an error as shown here:</li>
</ol>
<pre style="padding-left: 60px"><strong>"Cannot upgrade the extension 'MainExtension by DTacconi Inc. 1.0.0.0' because no previous version was found."</strong></pre>
<ol start="8">
<li>The last step is installing the extension:</li>
</ol>
<pre style="padding-left: 60px">Install-BCContainerApp -containerName 'BC14MTW1' `<br/>-tenant 'default' `<br/>-appName 'MainExtension' `<br/>-appVersion '1.0.0.0'</pre>
<div class="packt_infobox"><span>The source code for the <kbd>Install-BCContainerApp</kbd> script is available here:</span> <a href="https://github.com/microsoft/navcontainerhelper/blob/master/AppHandling/Install-NavContainerApp.ps1">https://github.com/microsoft/navcontainerhelper/blob/master/AppHandling/Install-NavContainerApp.ps1</a>.</div>
<p>During the installation task, one record is inserted in the application database <kbd>[NAV App Tenant App]</kbd> table in order to report and link the tenant ID (in this case, <kbd>default</kbd>) and the app package ID. The same is reflected in the tenant database where a record is inserted in the <kbd>[NAV App Installed App]</kbd> table, reporting the package ID and the app ID.</p>
<p>At this stage, the synchronization mechanism between the application database and the tenant database is completed and the metadata structure changes are also applied to the SQL Server database structure.</p>
<p>In this example, you will find the following in the tenant database:</p>
<ul>
<li>A new table called <kbd>$item$&lt;appID&gt;</kbd> that contains the new field, <kbd>Catalogue No.</kbd>.</li>
<li>A new table called <kbd>$NewTable$&lt;appID&gt;</kbd> that contains all the relevant fields that have been defined for that table in the AL table object.</li>
</ul>
<p>The following screenshot shows the overview of the two new tables that were created during the installation process:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4247e96f-a255-4f6f-96b8-721662c94f9b.png" style="width:27.08em;height:19.67em;"/></p>
<p>The installation process also executes the code that is contained in the installation codeunit and, in this example, populates <kbd>New Table</kbd> with three records. You can easily inspect the table's content by running the following code:</p>
<pre>SELECT * FROM [My Company$NewTable$15ecd2e5-b7a8-4612-ae6f-d722af29c0c0]</pre>
<p>The output for this is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b87595a9-ee44-4545-984b-6372029bb363.png" style="width:36.83em;height:5.58em;"/></p>
<p><span>Now that the main extension has been installed, let's move forward in our example, by creating and deploying another extension that has a dependency on the objects declared by the main extension.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying a dependent extension</h1>
                </header>
            
            <article>
                
<p>The dependency to the main extension is declared in the <kbd>app.json</kbd> file:</p>
<pre>"id": "6d527590-711f-410c-b233-d267d192b13b",<br/>"name": "SecondExtension",<br/>"publisher": "DTacconi Inc.",<br/>"version": "1.0.0.0",<br/>"dependencies": [<br/>    {<br/>    "appId": "15ecd2e5-b7a8-4612-ae6f-d722af29c0c0",<br/>    "name": "MainExtension",<br/>    "publisher": "DTacconi Inc.",<br/>    "version": "1.0.0.0"<br/>    }<br/>],</pre>
<p>In the preceding code, we can see that the dependency must define four parameters: the application ID, name, publisher, and version. These are mandatory if we want to define a unique extension target.</p>
<div class="packt_infobox">Once the dependency in the <kbd>app.json</kbd> file is defined, it is mandatory to download the appropriate symbols from the tenant. To perform this action, just run the command palette (<em>Ctrl</em> + <em>Shift</em> + <em>P</em>) and choose <span class="packt_screen">AL: Download symbols</span>.</div>
<p>To make it very simple, we will create a second extension as follows:</p>
<ol>
<li>The second extension will be with just a page extension object that is based on the table extension field implemented with the main extension <span>(</span><kbd>Pag-Ext50115.NewTablePageExtension.al</kbd>). Hence, the second extension must declare a dependency on the main extension. Consider the following code:</li>
</ol>
<pre style="padding-left: 60px">pageextension 50115 "New Table Page Extension" extends "Item Card"<br/>{<br/>    layout<br/>    {<br/>        addafter(Description)<br/>        {<br/>            field("Catalogue No.";"Catalogue No.")<br/>            {<br/>                ApplicationArea = All;<br/>            }<br/>        }<br/>    }   <br/>}</pre>
<ol start="2">
<li>
<p>We are now ready to publish the second extension using the following PowerShell snippet:</p>
</li>
</ol>
<pre style="padding-left: 60px">Publish-BCContainerApp -containerName 'BC14MTW1' `<br/>    -appFile 'C:\TEMP\UPGRADE\SecondExtension\DTacconi Inc._SecondExtension_1.0.0.0.app' `<br/>    -skipVerification</pre>
<ol start="3">
<li>Like in the main extension, the publish action will declare the extension manifest in the <kbd>[NAV App]</kbd> table and the object contained in the extension is extracted into the <kbd>[NAV App Object Metadata]</kbd> table in the application database.</li>
<li>A record is also created in the <kbd>[NAV App Resource]</kbd> <span>table of type metadata.</span></li>
<li>The significant change, compared to the previous extension, is a new record in the <kbd>[NAV App Dependencies]</kbd> <span>table that links the second extension package ID with the main extension application ID, name, publisher, and version. The following screenshot shows the </span><span>relevant query result snippet, after the dependent app is published:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fdbf554a-0837-4132-90b2-4ec81068db66.png" style="width:58.50em;height:18.83em;"/></p>
<p style="padding-left: 60px">No action is performed; hence, there are no changes in the tenant database.</p>
<ol start="6">
<li>After publishing, we need to synchronize the second extension:</li>
</ol>
<pre style="padding-left: 60px">Sync-BCContainerApp -containerName 'BC14MTW1' `<br/>    -tenant 'default' `<br/>    -appName 'SecondExtension' `<br/>    -Mode Add</pre>
<p style="padding-left: 60px">This action will synchronize the extension metadata content of the second extension in the application database against a specific mounted tenant. In this case, since we have a page object in the extension and nothing more, no records will be created in the nav app schema snapshot table in the tenant database.</p>
<p style="padding-left: 60px">However, one record will be created in the <kbd>[$ndo$navappschematracking]</kbd> table, just to correlate the extension objects in the snapshot table with the extension ID, name, publisher, and version, no matter whether <span>or not </span>there are objects that need to be tracked. The following screenshot shows the relevant query result snippet after the main app has been synchronized:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ab203fad-3665-4ef8-aaac-8fb39338e4ed.png" style="width:43.17em;height:3.25em;"/></p>
<ol start="7">
<li>After synchronizing the second extension, we could check whether there is some data that needs to be upgraded. We could then use the following PowerShell script:</li>
</ol>
<pre style="padding-left: 60px">Start-BCContainerAppDataUpgrade -containerName 'BC14MTW1' `<br/>    -tenant 'default' `<br/>    -appName 'SecondExtension' `<br/>    -appVersion '1.0.0.0'</pre>
<p style="padding-left: 60px">As with the main extension, an error will be thrown, stating that there is nothing to upgrade.</p>
<ol start="8">
<li>The last step is to install the second extension:</li>
</ol>
<pre style="padding-left: 60px">Install-BCContainerApp -containerName 'BC14MTW1' `<br/>-tenant 'default' `<br/>-appName 'SecondExtension' `<br/>-appVersion '1.0.0.0'</pre>
<p>In this case, it will be a super-fast task, because we do not have any objects that will cause a schema change (we only have a page extension in the second extension).</p>
<p>One record is inserted in the application database's <kbd>[NAV App Tenant App]</kbd> table to report and link the tenant ID and the app package ID, and the same record is inserted in the tenant database's <kbd>[NAV App Installed App]</kbd> table, reporting the package ID and the app ID.</p>
<p>Everything is now ready to work in our solution (that is, a combination of two dependent extensions) and, in the <kbd>BC14MTW1</kbd> folder, just run the <kbd>BC14MTW1 Web Client</kbd> shortcut.</p>
<p>After providing access credentials and creating a 30-day trial version, go to the <span class="packt_screen">Item</span> list and create three items called <span class="packt_screen">ITEM1</span>, <span class="packt_screen">ITEM2</span>, and <span class="packt_screen">ITEM3</span>, or whatever you like, and assign them <span class="packt_screen">Catalogue No.</span> <kbd>111</kbd>, <kbd>222</kbd>, and <kbd>333</kbd>, respectively. The following screenshot shows the <span><span class="packt_screen">Item</span> card</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/33276a9b-e5c5-42af-acb3-83645258cd4f.png" style="width:25.50em;height:11.25em;"/></p>
<p>This will make sure that we <span>now </span>have some data to upgrade, as required in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying a new version of the main extension</h1>
                </header>
            
            <article>
                
<p>Again, in order to make it very simple, we will create a second version of the main extension where one field, <kbd>Catalogue No.</kbd>, will change its data type from integer to <kbd>text 30</kbd>. This is a data type conversion that constitutes a breaking change in the data schema. The second version of the extension must then cope with the following:</p>
<ul>
<li><strong>Increase (bump) the extension version</strong>: Change the <kbd>app.json</kbd> file version field as follows:</li>
</ul>
<pre>     "version": "2.0.0.0",</pre>
<ul>
<li><strong>Table or table extension object changes</strong>: We should declare the original <kbd>Catalogue No.</kbd> field with the <kbd>ObsoleteState</kbd> <span>property set to</span> <kbd>Removed</kbd> (for a <span>definition of </span><kbd>ObsoleteState</kbd> and an overview of how it is used, please visit <a href="https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/properties/devenv-obsoletestate-property">https://docs.microsoft.com/en-us/dyn</a><a href="https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/properties/devenv-obsoletestate-property">amics365/business-central/dev-itpro/developer/properties/devenv-obsoletestate-propert</a><em><span><em><a href="https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/properties/devenv-obsoletestate-property">y</a></em></span></em><span>)</span><span>.</span> <span>We should also declare a brand new field with the</span> <kbd>text 30</kbd> data type, <span>and with</span> <span>the same</span> <kbd>Caption</kbd> <span>as the</span> <kbd>Catalogue No.</kbd> field, <span>in order to make these changes with a smooth transition. The following code shows this:</span><strong><em><br/></em></strong></li>
</ul>
<pre style="padding-left: 60px">tableextension 50105 "New Table Extension" extends Item<br/>{<br/>    fields<br/>    {<br/>        field(50105;"Catalogue No.";Integer)<br/>        {<br/>            DataClassification = ToBeClassified; <br/>            ObsoleteState = Removed;<br/>        }<br/>        field(50106;NewCatalogueNo;Text[30])<br/>        {<br/>            CaptionML=ENU='Catalogue No. 2';<br/>            DataClassification = ToBeClassified; <br/>        }<br/>    }<br/>}</pre>
<ul>
<li><strong>Installation codeunit changes</strong>: If there will be some code referencing the <kbd>Catalogue No.</kbd> and pre-populated values during the initial installation phase, these need to be changed according to the new data type in the installation codeunit. We do not have such cases in our example, but it might happen in real-life scenarios.</li>
<li><strong>Upgrade codeunit</strong>: The code changes that are declared in the table or table extension objects might involve data handling. A brand new codeunit with the <kbd>Subtype</kbd> <span>property set to </span><kbd>Upgrade</kbd> <span>is now needed to handle this data transit from the old field to the new one.</span></li>
</ul>
<p><span>To find out more about upgrade codeunits, check out the online documentation at </span><a href="https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/devenv-upgrading-extensions">https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/devenv-upgrading-extensions</a>.</p>
<p>Within this codeunit and in a specific function, it is possible to write the upgrade code and check whether a specific version of an extension has been installed and performs actionable tasks based on this information. All of this information is retrieved in an upgrade codeunit using a combination of the <kbd>NavApp</kbd> and <kbd>ModuleInfo</kbd> data types.</p>
<p>This would make an upgrade codeunit very powerful and flexible.</p>
<p>In our case, we will retrieve the information of the currently installed version (<kbd>NavApp.GetCurrentModuleInfo(Module)</kbd>), and transform the existing integer value for the <kbd>Catalogue No.</kbd> field into text with the <kbd>C</kbd> as a prefix. Consider the following code:</p>
<pre>codeunit 50105 "Upgrade Catalogue No."<br/>{<br/>    Subtype = Upgrade;<br/><br/><br/>    trigger OnUpgradePerCompany();<br/>    var<br/>        ItemRec : Record Item;<br/>        Module : ModuleInfo;<br/>    begin<br/><br/><br/>        NavApp.GetCurrentModuleInfo(Module);<br/><br/><br/>        if (Module.DataVersion.Major = 1) then begin<br/>            ItemRec.Reset();<br/>            IF ItemRec.FindSet(true,false) then repeat<br/>              if (ItemRec."Catalogue No." &gt; 0) THEN begin<br/>                ItemRec.NewCatalogueNo := 'C' +<br/>                  FORMAT(ItemRec."Catalogue No.");<br/>                ItemRec.Modify(true);<br/>              end;<br/>            until ItemRec.Next() = 0;           <br/>        end;<br/>    end;<br/>}</pre>
<p><span>We are now able to publish the new version of the main extension:</span></p>
<pre>Publish-BCContainerApp -containerName 'BC14MTW1' `<br/>-appFile 'C:\TEMP\UPGRADE\MainExtensionV2\DTacconi Inc._MainExtension_2.0.0.0.app' `<br/>-skipVerification</pre>
<p>The extension manifest for version 2 will be loaded in the <kbd>[NAV App]</kbd> table, and the object that is contained in the extension is extracted into the <kbd>[NAV App Object Metadata]</kbd> table in the application database. A <span>metadata </span>record is also created in the <kbd>[NAV App Resource]</kbd> table. The following screenshot shows <span>the relevant query result snippet after the new version of the main extension has been published:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1accb7d9-9fd1-4291-bf79-001ed1b6af81.png" style="width:58.08em;height:15.00em;"/></p>
<p>No action is performed in the tenant database.</p>
<p>Let's synchronize the new version of the main extension with the following PowerShell snippet:</p>
<pre>Sync-BCContainerApp -containerName 'BC14MTW1' `<br/>-tenant 'default' `<br/>-appName 'MainExtension' `<br/>-appVersion '2.0.0.0' `<br/>-Mode Add</pre>
<p>Records will be created in the tenant's <kbd>[$ndo$navappschemasnapshot]</kbd> table for every object that has an impact on schema changes at the database level.</p>
<p>The record that is created in the <kbd>[$ndo$navappschematracking]</kbd> table has been updated to correlate the objects in the snapshot table with the extension ID, name, publisher, and the new version. The record updates the <kbd>version</kbd> field to 2.0.0.0 and changes the <kbd>baselineversion</kbd> field to <kbd>1.0.0.0</kbd>.</p>
<p>This is also the crucial stage at which metadata changes are applied. Let's run a simple query from SSMS as follows:</p>
<pre>SELECT * FROM [default].[dbo].[My Company$Item$15ecd2e5-b7a8-4612-ae6f-d722af29c0c0]</pre>
<p>The preceding query will show that the new <kbd>NewCatalogueNo</kbd> <span>field </span>has been created. The following screenshot shows the <span>result of the query in the extended item table</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/42fc3d5c-b7b1-4b12-93e5-938d2d49b991.png" style="width:26.92em;height:5.83em;"/></p>
<p>It is worth noticing that users are still able to work seamlessly and without any problems, continuing to assign values to the old <kbd>Catalogue No.</kbd> field.</p>
<p>The next step in the deployment of version 2.x of the main extension is to perform the data upgrade:</p>
<pre>Start-BCContainerAppDataUpgrade -containerName 'BC14MTW1' `<br/>    -tenant 'default' `<br/>    -appName 'MainExtension' `<br/>    -appVersion '2.0.0.0'</pre>
<p>The previous step synchronized the metadata structure at the database level and created the new field, leaving the old field with its values untouched.</p>
<p>It is in this step where all the upgrade magic happens and the data is moved into the new field. Run the following query again:</p>
<pre>SELECT * FROM [default].[dbo].[My Company$Item$15ecd2e5-b7a8-4612-ae6f-d722af29c0c0]</pre>
<p>You will notice that the values in <kbd>NewCatalogueNo</kbd> have been updated according to the upgrade codeunit code. The following screenshot shows the r<span>esult of the query in the extended item table</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8937767a-8937-4820-9cb0-424c59f272a3.png" style="width:28.42em;height:6.17em;"/></p>
<p>The record in the application database's <kbd>[NAV App Tenant App]</kbd> table that linked the tenant ID and the app package ID is also updated with the version 2 package ID. This is also reflected in the tenant database by updating the relevant record in the <kbd>[NAV App Installed App]</kbd> table with the new package ID from version 2.</p>
<p>The dependent extension is, then, broken at this stage, because it is bound to a field that is effectively marked as removed; hence, the page text box control related to the old <kbd>Catalogue No.</kbd> field will not be shown in the client <span>anymore</span><span>. The following screenshot shows a </span><span>snippet of the <span class="packt_screen">Item</span> card after upgrading to the new </span><span>version of the </span><span>main extension:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1b7b929e-91d5-47e2-bf25-3040d3be4bdf.png" style="width:23.67em;height:10.33em;"/></p>
<p>The last step to check is whether there are changes when installing the extension using the following PowerShell statement:</p>
<pre>Install-BCContainerApp -containerName 'BC14MTW1' `<br/>-tenant 'default' `<br/>-appName 'MainExtension' `<br/>-appVersion '2.0.0.0'</pre>
<p>In this case, no action is performed, because the extension was already installed, and it has just been upgraded to another version.</p>
<p>We should, then, receive the following message when running the PowerShell cmdlet:</p>
<pre>"<strong>WARNING: Cannot install extension MainExtension by DTacconi Inc. 2.0.0.0 for the tenant default because</strong><strong> it is already installed.</strong>"</pre>
<p>After this, let's see how we can deploy to a new independent version.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying a new version of the dependent extension</h1>
                </header>
            
            <article>
                
<p>After performing the data upgrade of the main extension to a new version, we saw that the dependent extension has been broken. It is crucial at this stage to let the user read or update the new <kbd>NewCatalogueNo.</kbd> <span>field </span>from the client.</p>
<p>First things first. We must bump the <kbd>app.json</kbd> version of the dependent extension to 2.0.0.0, and also update the dependency to the appropriate version of the main extension. See the following updated snippet:</p>
<pre>"version": "2.0.0.0",<br/>"dependencies": [<br/>    {<br/>        "appId": "15ecd2e5-b7a8-4612-ae6f-d722af29c0c0",<br/>        "name": "MainExtension",<br/>        "publisher": "DTacconi Inc.",<br/>        "version": "2.0.0.0"<br/>    }<br/>],</pre>
<p>When the <kbd>app.json</kbd> file is updated, we must download the new symbols from our multitenant environment in order to have them <span>set </span>appropriately. The results of the <kbd>.alpackages</kbd> directory content, right after the downloading symbols, are shown in the following screenshot. This shows a <span>list of symbols that are needed to build the new version for the dependent extension</span>: </p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0170bbb2-8f04-4903-bc7f-8961fdc39217.png" style="width:21.58em;height:7.42em;"/></p>
<p>The updated page extension object will then have the appropriate reference to the new <kbd>NewCatalogueNo</kbd> <span>field</span>:</p>
<pre>pageextension 50115 "New Table Page Extension" extends "Item Card"<br/>{<br/>    layout<br/>    {<br/>        addafter(Description)<br/>        {<br/>            field(NewCatalogueNo;NewCatalogueNo)<br/>            {<br/>                ApplicationArea = All;<br/>            }<br/>        }<br/>    }   <br/>}</pre>
<p>We could then publish the new version of the second extension using the following script:</p>
<pre>Publish-BCContainerApp -containerName 'BC14MTW1' `<br/>-appFile 'C:\TEMP\UPGRADE\DependentExtensionV2\DTacconi Inc._SecondExtension_2.0.0.0.app' `<br/>-skipVerification</pre>
<p>As in <span>version 2 of the </span>main extension, the manifest will be loaded in the <kbd>[NAV App]</kbd> table, and the object contained in the extension is extracted into the <kbd>[NAV App Object Metadata]</kbd> table in the application database. A <span>metadata </span>record is also created in the <kbd>[NAV App Resource]</kbd> table, and also in the <kbd>[NAV App Dependency]</kbd> table, reflecting the dependency of the second extension version 2 on main extension version 2.</p>
<p>No action is performed in the tenant database.</p>
<p>We should, then, synchronize the app in the tenant using the following PowerShell script:</p>
<pre>Sync-BCContainerApp -containerName 'BC14MTW1' `<br/>    -tenant 'default' `<br/>    -appName 'SecondExtension' `<br/>    -appVersion '2.0.0.0' `<br/>    -Mode Add</pre>
<p>Once you run the synchronization, the original record that was created in the <kbd>[$ndo$navappschematracking]</kbd> table will be updated in order to correlate the objects in the snapshot table with the extension ID, name, publisher, and the new version.</p>
<p>The <kbd>version</kbd> field for the dependent extension will be <kbd>2.0.0.0</kbd>, while the <kbd>baselineversion</kbd> field remains <kbd>1.0.0.0</kbd>. The following screenshot shows the query result after the new version of the dependent extension has been synchronized:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d9b829ea-63c9-4425-88b1-7dff1e8f7106.png" style="width:46.17em;height:4.08em;"/></p>
<p>If we stop now, we have a hybrid half-deployment state, where schema synchronization is <span>now </span>enabled for the new version, but the installed version is still the old one. </p>
<p>It is now time to start the data upgrade for the second extension. See the following simple script: </p>
<pre>Start-BCContainerAppDataUpgrade -containerName 'BC14MTW1' `<br/>    -tenant 'default' `<br/>    -appName 'SecondExtension' `<br/>    -appVersion '2.0.0.0'</pre>
<p>The record in the application database's <kbd>[NAV App Tenant App]</kbd> table that linked the tenant ID and the app package ID is updated with the new version's package ID. The same thing happened in the tenant database by updating the relevant record in the <kbd>[NAV App Installed App]</kbd> table with the new version's package ID.</p>
<p>The dependent extension is, then, consistent at this stage and the new page extension is used to read and update the <kbd>NewCatalogueNo</kbd> field. The following screenshot shows the <span><span class="packt_screen">Item</span> card after upgrading to the new version of the dependent extension:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9bca6c89-e81a-4cb3-834a-522deab1414b.png" style="width:21.83em;height:11.58em;"/></p>
<p>Just to be consistent in following the four deployment phases, we could also execute the installation statement:</p>
<pre>Install-BCContainerApp -containerName 'BC14MTW1' `<br/>-tenant 'default' `<br/>-appName 'SecondExtension' `<br/>-appVersion '2.0.0.0'</pre>
<p>It is trivial to say that we will receive the following message:</p>
<pre>"<strong>WARNING: Cannot install extension SecondExtension by DTacconi Inc. 2.0.0.0 for the tenant default because it is already installed.</strong>"</pre>
<p><span>This concludes the life cycle of our simple extension that covers complex upgrade scenarios. It is left to you, as an exercise, to deploy all four extensions manually in an online Dynamics 365 Business Central production environment, and see whether there are any differences. </span></p>
<p>In the end, you could filter the extension that is deployed online, and you might notice that you will find all of them in the extension management list: two installed (version 2) and two not installed (version 1). The following screenshot explains the situation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e3b2cd07-fc73-4a74-bfdb-d7fa2bc8d5ff.png" style="width:60.67em;height:15.17em;"/></p>
<p>Handling installation and upgrade operations are two important steps that you need to handle with your applications. Upgrading in particular is mandatory if you want to upgrade an extension without data loss.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we took a close look at the various options for deploying an extension targeted at Dynamics 365 Business Central sandbox or production. We have also covered all four stages of extension deployment <span>in detail</span>: publish, synchronize, data upgrade, and installation. </p>
<p>This chapter closes the development section, and now you're ready to start working with extensions on real-world projects (you know how to create extensions, how to deploy them, and how to extend them).</p>
<p>In the next chapter, we'll begin a brand new section that looks at debugging and testing extensions. The final chapter relates to source code management and its life cycle.</p>


            </article>

            
        </section>
    </body></html>