<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Debugging</h1>
                </header>
            
            <article>
                
<p>Dynamics 365 Business Central AL Language extension provides a debugger to help developers check, correct, or modify code so that custom extensions can build successfully, deploy smoothly, and act as expected.</p>
<p>Another way to track potential logical errors is to write test codeunits, but this will be a topic for another chapter. For now, we will see how to debug an extension and create tests for reports with ease.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>Running the AL Language extension in debug mode</li>
<li>Defining specific non-debuggable functions or variables</li>
<li>Mastering debugger and code editor issues (<em>debugging the debugger</em>)</li>
<li>Working with code analyzers</li>
<li>Using Event Recorder to track information about event availability</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running in debug mode</h1>
                </header>
            
            <article>
                
<p>The basic concept behind debugging is the<span> </span><em>breakpoint</em>, which is a mark that you can set on a statement. When the program flow hits the statement, the debugger is kicked in and suspends execution (technically, it breaks) until instructed to continue. Without any breakpoints, the code would run just fine as long as the debugger is active.</p>
<p>The debugger will automatically stop the execution of the code <span>only</span><span> </span><span>when it encounters an error, or if it has been instructed in the</span> <kbd>launch.json</kbd> <span>file to break on record changes.</span></p>
<p>A developer could also use the debugger to find potential logic errors since the debugger enables them to execute AL code syntax, one statement at a time, while inspecting the contents of variables at each runtime step. In this way, the developer can check and match what is expected when they have designed the application extension.</p>
<p>You can run the debugger from Visual Studio Code in three ways:</p>
<ul>
<li>Click <span class="packt_screen">Debug | Start Debugging</span>.</li>
<li>Press the <em>F5</em> shortcut key.</li>
<li>Go to DEBUG view (<em>Ctrl</em> + <em>Shift</em> + <em>D</em>) and press the green right arrow in the top bar. The top bar also shows the debugger session name specified in the <kbd>launch.json</kbd> file. It will open that file if you <span>press the gear icon</span>. The last icon on the right enables and shows the debug console, which typically shows contextual debugging information. The following screenshot depicts the d<span>ebugger top bar</span>:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="assets/54b917df-9f4b-4362-adb7-1a008613f6aa.png" style="width:28.83em;height:2.67em;"/></p>
<p>These actions will result in building your extension (equivalent to <em>Ctrl</em> + <em>Shift</em> + <em>B</em>), if this has not already been done, and then publishing the extension in the target online sandbox tenant.</p>
<p>Since the release of Dynamics 365 Business Central Spring 2019, it is now possible to run a debugger session without the need to build and publish the extension over and over again. This helps reduce the debug cycle and increases development productivity. To try this, in <span><span>Visual Studio Code just hit</span></span> <em>Ctrl</em> + <em>Shift</em> + <em>F5</em>, <span><span>or run the Command Palette (</span></span><em>Ctrl</em> + <em>P</em><span><span>) and search for</span></span> <kbd>AL: Debug without publishing</kbd><span><span>.</span></span></p>
<p>The <kbd>launch.json</kbd> file contains some elements that influence the debugging behavior and its target. The following is a list of them and what they do:</p>
<ul>
<li><kbd>BreakOnError</kbd>: Specifies whether the debugger should stop when it hits an error.</li>
<li><kbd>BreakOnRecordWrite</kbd>: Specifies whether the debugger should stop on record changes (typically record create or update).</li>
<li><kbd>Tenant</kbd>: Specifies the <strong>Azure Active Directory</strong> (<strong>AAD</strong>) tenant in which to create the debugger session.</li>
<li><kbd>SandboxName</kbd>: With the April 2019 update, it is possible to have multiple sandbox tenants. This parameter will let the developer specify the name of the sandbox to which to connect the debugger session.</li>
</ul>
<p>Also, the <kbd>app.json</kbd> file contains a parameter that is vital for the debugger to work against specific extension code: <kbd>ShowMyCode</kbd>.</p>
<p>If you publish and debug the extension as-is, it does not need to have this value set: it would work as implicitly set to <kbd>true</kbd>.</p>
<p>Nevertheless, if the code needs to be debugged from other extensions (and different Visual Studio Code sessions), since the default value for <kbd>ShowMyCode</kbd> is <kbd>false</kbd>, this parameter must be explicitly declared and set to <kbd>true</kbd>.</p>
<div class="packt_infobox">Be careful when handling the <kbd>ShowMyCode</kbd> parameter, since it <span>not only lets you debug code, but also enables users to download the source code for the extension. This parameter enables or disables the</span> <span class="packt_screen">download source code</span> <span>action from the <span class="packt_screen">Extension management</span> menu in the client.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visual Studio Code debugger sections</h1>
                </header>
            
            <article>
                
<p>The <span class="packt_screen">DEBUG</span> view provides several sections and output windows to inspect, step by step, what's currently executing, the variable assignment status, and the code process flow. Additionally, since the release of Dynamics 365 Business Central Spring 2019, it is also possible to have some insight into code performance by gathering the longest-running database queries.</p>
<p>Consider the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a8e50ef0-1f0a-4c49-a6ac-2e7994681090.png" style="width:53.50em;height:33.00em;"/></p>
<p>The debugger is basically divided into four sections: sidebar, toolbar, editor, and output windows. The editor window will highlight where the code is currently stopped. This is typically marked in yellow. The debug console, in the output window section, will show debugging information.</p>
<p>Let's examine each of these areas in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Debugger sidebar</h1>
                </header>
            
            <article>
                
<p>The sidebar is enabled by default and is located on the left side of the debugger. It is possible to switch the position with the editor (right-click in one of the sections and select <span class="packt_screen">Move SideBar Right</span>), hide it (<em>Ctrl</em> + <em>B</em>), or even just hide some of the sections (right-click in one of the sections and uncheck the section(s) that you need to keep hidden).</p>
<p>The sidebar is divided into four sections, <span>which </span>are used to provide information related to the current code flow. Let's go through them here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Variables</h1>
                </header>
            
            <article>
                
<p>The <span class="packt_screen">VARIABLES</span> section provides an overview of global and local variable assignments: </p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/91ea222a-a993-4d38-b643-9b6804d2a07d.png" style="width:16.50em;height:13.17em;"/></p>
<p>In the <span class="packt_screen">Locals</span> section, it is also possible to check performance counters that are related to code execution:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1f8b0dd5-b2cc-4e09-a7ff-63187e90ba23.png" style="width:55.17em;height:39.33em;"/></p>
<p>In particular, it is possible to measure the following:</p>
<ul>
<li>Current SQL latency (ms): When the debugger hits a breakpoint, the Dynamics 365 Business Central Server service will send a probing SQL statement to the Azure SQL database and keep track of how long it takes to receive an answer. This information is helpful if the sandbox node for the tenant has <span>healthy </span>latency or there are infrastructure issues.</li>
<li>Number of SQL executes: The total number of SQL statements executed in the session since the debugger was started.</li>
<li>Number of SQL row reads: The total number of database rows read since the debugger was started.</li>
<li>Top-10 long-running queries: Expanding the Last Executed SQL Statements section, you might observe up to 10 SQL Server statement entries (numbered from 0 to 9). The statements represent the 10 least performant queries, in terms of duration, that have been executed since the session started up, to the first breakpoint hit. These are defined by the following elements:
<ul>
<li><strong>Statement</strong><em>:</em> The T-SQL statement executed.</li>
<li><strong>Execution time (UTC)</strong>: A timestamp defining when the SQL statement was executed.</li>
<li><strong>Duration (ms)</strong>: The duration of the total execution time of the SQL statement. It's useful to analyze this if there are some missing indexes when developing extensions.</li>
<li><strong>Rows read</strong>: Shows the approximate number of rows read by the SQL statement. It might be useful <span>when looking for </span>missing filters when developing extensions.</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Watch</h1>
                </header>
            
            <article>
                
<p>The <em>Watch</em> section is used to monitor variables of particular interest while debugging. It is possible to right-click on the name of the variable that you want to watch from the <kbd>Variables</kbd> window or in the code editor while debugging: this will display the value of the watched variable. In this window, you can also insert the names of the variables <span>that </span>you want to monitor <span>into the watch list</span><span> </span>while debugging.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Callstack</h1>
                </header>
            
            <article>
                
<p>Variable values and expression evaluations are relative to the selected stack frame. This will report a cascade/stack of objects in descending execution order.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Breakpoints</h1>
                </header>
            
            <article>
                
<p>This shows a list of available breakpoints that could be enabled, disabled, or reapplied at will. Breakpoints can be toggled in the Visual Studio Code editor window by clicking in the left margin or by pressing <em>F9</em> in a selected line. Breakpoints that are displayed in the editor margin are shown as red-filled circles. Disabled breakpoints have a filled gray circle.</p>
<div class="packt_infobox">Breakpoints that cannot be assigned to any code in the debugger session are shown with a gray hollow circle.<strong><br/></strong></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Debugger toolbar</h1>
                </header>
            
            <article>
                
<p>The toolbar contains commands that pause, stop, restart, or control the debugging process. The following screenshot shows a debugger toolbar:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e4f72b51-8679-412c-97c7-88bca06c68dc.png" style="width:17.25em;height:2.50em;"/></p>
<p>Possible actions are as follows:</p>
<ul>
<li>Continue (<em>F5</em>).</li>
<li>Pause (<em>F6</em>).</li>
<li>Restart (<em>Shift</em> + <em>F11</em>): Depicted by the green circular arrow in.</li>
<li>Stop (<em>Shift</em> + <em>F5</em>): Depicted by the red square: The debugger toolbar commands <span>allow you to continue (</span><em>F5</em><span>) the process until it comes to an end. In this way, developers can continue with their iterative process and start the operation again without running a new web client session in debug mode. The process could also be paused</span> <span>(</span><em>F6</em><span>)—the debugger session is still alive; restarted (<em>S</em></span><em>hift</em> <span>+ <em>F11</em>)—it will create a new debugger session; or definitively stopped (<em>S</em></span><em>hift</em> + <span><span><em>F5</em>)—the debugger session is closed.</span></span></li>
<li>Step Over (<em>F10</em>): All statements are executed one at a time. If this command is used, when a function call is reached, the function is executed without the debugger stepping through the function instructions. If there is a breakpoint in one of the functions that it has been instructed to step over, the debugger will break at that breakpoint in any case.</li>
<li>Step Into (<em>F11</em>): All statements are executed one at a time. If this command is used, when a function call is reached, the debugger will step through all the function's instructions.</li>
</ul>
<ul>
<li>Step Out (<em>Shift</em> + <em>F11</em>): It will skip the current function and jump into the next one<span>.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Debugging in attach mode</h1>
                </header>
            
            <article>
                
<p>With the Dynamics 365 Business Central October 2019 update, the ability to debug, not only by launching a new debug session, but also by attaching the debugger to the next new session that is created by the application) has been introduced.</p>
<p>This capability currently has some limitations, and the following table explains its support scenario:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<thead>
<tr>
<td>
<p><strong>Deployment type</strong></p>
</td>
<td>
<p><strong>Web client</strong></p>
</td>
<td>
<p><strong>Web service</strong></p>
</td>
<td>
<p><strong>Background session</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
<p>On-premises</p>
</td>
<td>
<p>Supported</p>
</td>
<td>
<p>Supported</p>
</td>
<td>
<p>Supported</p>
</td>
</tr>
<tr>
<td>
<p>Online sandbox</p>
</td>
<td>
<p>Not supported</p>
</td>
<td>
<p>Supported</p>
</td>
<td>
<p>Not supported</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>To enable the attach process, it is mandatory to add a new configuration parameter set to the extensions <kbd>launch.json</kbd> file.</p>
<p>The key parameters that need to be specified are as follows:</p>
<ul>
<li><kbd>"request": "attach"</kbd>: In a typical debugging scenario, this parameter is set to default its value: <kbd>launch</kbd>.</li>
<li><kbd>"breakOnNext" : "WebServiceClient"</kbd> : With online sandboxes, the only option allowed is <kbd>"WebServiceClient"</kbd>, while with on-premise and Docker-based sandboxes, it is also possible to attach the debugger to the <kbd>"WebClient"</kbd> or <kbd>"Background"</kbd> sessions.</li>
</ul>
<p>To find out more about how to attach the debugger, visit <a href="https://demiliani.com/2019/10/25/dynamics-365-business-central-debugging-the-base-application/">https://demiliani.com/2019/10/25/dynamics-365-business-central-debugging-the-base-application/</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Non-debuggable items</h1>
                </header>
            
            <article>
                
<p><span><span>Typically, developers</span> <span>would like to have a full debugging experience on every extension line of code. There are some circumstances where a specific variable or function should not show its current value. These circumstances are typically related to variables that store private information, or functions that return private values (such as user passwords or license checks).</span></span></p>
<p><span><span>When developing extensions, there is a special attribute that can be used with functions and/or variables that stop them from being processed (the debugger cannot step into them) or visible (variables and/or function output values are not shown) within the debugger. </span></span>Writing the <kbd>[NonDebuggable]</kbd> statement before the declaration of a function or a variable would mean that they are not inspectable, and no breakpoints could be set against them.</p>
<p>In <kbd>Report 50111 Item Ledger Entry Analysis</kbd>, created in <a href="81958c15-06a3-4a59-ae0c-0afa9413d6f9.xhtml">Chapter 7</a>, <em>Report Development with AL</em>, add a breakpoint in the <kbd>OnPreReport</kbd> trigger in the very first statement, <kbd>if includeLogo then begin</kbd>, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/46f91056-50f9-49e5-bc4a-a24dbc5670b1.png" style="width:37.75em;height:5.58em;"/></p>
<p>And after that, just publish the extension (<em>F5</em>).</p>
<p>When the client loads, search for <kbd>packt report</kbd>, and when the <kbd>Item Ledger Entry Analysis</kbd> report record is shown, click on it, choose to include the logo in the request page, and click <span class="packt_screen">Preview</span>.</p>
<p>The debugger will stop precisely in the <kbd>OnPreReport</kbd> breakpoint that was just added.</p>
<p>Now, press <em>F11</em> twice to move the code execution down to run the <kbd>Get</kbd> statement in the <kbd>Company Information</kbd> table:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e115d75c-4504-4b5a-bb12-c1b7d840a928.png" style="width:34.17em;height:9.00em;"/></p>
<p>If you expand the <span class="packt_screen">VARIABLES</span> section in the debugger activity pane, you might notice that the <kbd>Company Information</kbd> (named <kbd>CompanyInfo</kbd>) record can be expanded, and you can see all its values:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e74f8ff3-d1a1-4e21-8547-a143ed003e54.png" style="width:22.67em;height:19.00em;"/></p>
<p>Stop the debugger (S<em>hift </em>+ <em>F5</em>) and add the non-debuggable attribute before the <kbd>Company Information</kbd> global variable, as follows:</p>
<pre>...<br/>  var
        <strong>[NonDebuggable]</strong><br/>        CompanyInfo: Record "Company Information";<br/>        includeLogo: Boolean;<br/>...</pre>
<p>Publish the extension (<em>F5</em>) again.</p>
<p>When the client loads, search for <kbd>packt report</kbd> and perform the same action as before to preview the report: the debugger will stop once again in the same place.</p>
<p>Press <em>F11</em> twice to move the code execution down to run the <kbd>Get</kbd> statement in the <kbd>Company Information</kbd> table and retrieve the record data. Now, if you expand the <span class="packt_screen">VARIABLES</span> section, you might notice that the <kbd>Company Information</kbd> record is not even shown:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e06564fd-9917-40f8-b45a-99c2c2515a99.png" style="width:14.25em;height:11.50em;"/></p>
<p>Hovering the mouse in any <kbd>CompanyInfo</kbd> statement in the code editor will result in an <kbd>&lt;Out of Scope&gt;</kbd> message, due to the presence of the <kbd>[NonDebuggable]</kbd> attribute in the runtime action.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mastering debugger issues</h1>
                </header>
            
            <article>
                
<p>I<span><span>n some real-world scenarios, it might be that, for some reason, the debugger will not start and it will report an unhandled error message in the output window; or you might simply need to keep track of the debugger service process. In other words, you might need to debug the debugger. After all, the debugger is just another software artifact.</span></span></p>
<p>To gain more insight and verbose diagnostics, there is an undocumented feature that you need to enable by entering a specific parameter in the <kbd>settings.json</kbd> file in order to use:</p>
<pre>"al.editorServicesLogLevel": "Debug".</pre>
<p>Once it's enabled, you need to restart Visual Studio Code to make the changes effective across the application.</p>
<p>This parameter will instruct the AL Language extension to create a verbose logging activity for the code editor (<kbd>EditorServices.log</kbd>), and the debugger (<kbd>DebuggerServices.log</kbd>) in the following <kbd>C:\Users\&lt;USER&gt;\.vscode\extensions\ms-dynamics-smb.al-3.0.121490\bin</kbd> <span>directory.</span></p>
<div class="packt_infobox"><kbd>ms-dynamics-smb.al-3.0.121490</kbd> represents the AL Language extension name and version that are registered in the current Visual Studio Code session. </div>
<p>The following is a snippet of the logged activity for the debugger service showing its processing:</p>
<pre>...<br/><strong>04/19/2019 16:53:15 [/6] Process:<br/></strong><strong> </strong><strong>launch<br/></strong><strong>04/19/2019 16:53:24 [/14] Process:<br/></strong><strong> </strong><strong>setBreakpoints<br/></strong><strong>04/19/2019 16:53:24 [/14] Parsing Report 50111 "Item Ledger Entry Analysis".<br/></strong><strong>04/19/2019 16:53:25 [/14] Parsing Codeunit 50100 "Customer Category Mgt_PKT".<br/></strong><strong>04/19/2019 16:53:25 [/14] Parsing Page 50100 "Customer Category List_PKT".<br/></strong>...</pre>
<p>In the next section, we'll see how you can use code analyzers when developing with AL.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding code analyzers</h1>
                </header>
            
            <article>
                
<p>The AL language proactive debugging experience is greatly enhanced by code analyzers. Code analyzers are part of the standard AL Language extension, and are a set of contextual rules that are applied to extension development. These rules can generate an error or a warning when you're developing an extension.</p>
<p>Code analyzers can be enabled and disabled at will, both per workspace and globally.</p>
<p>To enable code analyzers, perform the following steps:</p>
<p>Go to <span class="packt_screen">File | Preferences | Settings (Workspace settings) | Extension | AL language extension</span> and choose to edit the <kbd>settings.json</kbd> file.</p>
<div class="packt_infobox">You could also choose to edit the <kbd>settings.json</kbd> file by choosing user settings. However, since you might develop per-tenant extensions and also AppSource apps in the same environment, it would make more sense to have these enabled per workspace instead of per user settings. </div>
<p>In the <kbd>settings.json</kbd> file, it is possible to specify the following parameters:</p>
<pre><strong>al.enableCodeAnalysis</strong> (default: false)</pre>
<p>Changing this parameter to <kbd>true</kbd> enables the analyzers that are specified in the JSON array parameter, <kbd>al.codeAnalyzers</kbd>. If no analyzers are specified, or there is no <kbd>al.codeAnalyzers</kbd> entry, it is assumed that all analyzers are enabled.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">al.codeAnalyzers[]</h1>
                </header>
            
            <article>
                
<p>The <kbd>al.codeAnalyzers[]</kbd> parameter represents an array of code analyzers. Currently, the supported values and the official links to the appropriate rules, ordered by ID, are as follows:</p>
<ul>
<li><kbd>"${AppSourceCop}"</kbd>: This must be enabled when developing apps targeted for the AppSource marketplace. To find out more, visit <a href="https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/analyzers/appsourcecop">https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/analyzers/appsourcecop</a>.</li>
<li><kbd>"${CodeCop}"</kbd>: This strengthens the standard AL Language development guidelines, and it is recommended that it is enabled for every kind of development target. <span>To find out more, visit</span> <a href="https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/analyzers/codecop">https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/analyzers/codecop</a>.</li>
<li><kbd>"${PerTenantExtensionCop}"</kbd>: Together with <kbd>CodeCop</kbd>, it should be enabled on every online development target, except when developing extensions for the AppSource marketplace, where <kbd>AppSourceCop</kbd> should be used. <span>To find out more, visit</span> <a href="https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/analyzers/pertenantextensioncop">https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/analyzers/pertenantextensioncop</a>.</li>
<li><kbd>"${UICop}"</kbd>: This is the last addition to the code analyzers, and it checks that the code matches the features that are supported by modern clients, and avoids hitting user interface limitations. <span>To find out more, visit</span> <a href="https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/analyzers/uicop">https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/analyzers/uicop</a>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">al.ruleSetPath </h1>
                </header>
            
            <article>
                
<p>This is the path for a ruleset file that contains changes to the rules that are provided through standard code analyzers.</p>
<p>A ruleset file is written in JSON notation, and has a reference to an existing ruleset item ID that is implemented in the standard AL Language extension. This file is typically edited to redefine the importance of the rules within a specific extension project or workspace.</p>
<p>If we implement code analyzers in the demo extension project that we have created, it will help us to find out more info about our code style, and whether there are improvements to be applied. Let's enable the relevant analyzers for our extension project by changing the <kbd>settings.json</kbd> file in our <kbd>workspace</kbd> settings as follows:</p>
<pre>{<br/>    "al.enableCodeAnalysis": true,<br/>    "al.codeAnalyzers": [<br/>        "${CodeCop}",<br/>        "${PerTenantExtensionCop}",<br/>        "${UICop}"<br/>    ]<br/>}</pre>
<p>In the <span><span class="packt_screen">PROBLEMS</span></span> window, there might <span>now </span>be a bunch of records with errors, warnings, and information. Considering only those that are related to <kbd>Report 50111 ItemLedgerEntryAnalysis.al</kbd>, there should be one error, two warnings, and one piece of useful information. Take a look at the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/935a4681-d1ca-4945-b66a-a48ff80cca5d.png" style="width:64.58em;height:10.50em;"/></p>
<p>Looking at the error, this is pretty clear: the <kbd>includeLogo</kbd> column definition does not have its <kbd>ApplicationArea</kbd> property defined. For this reason, it will not be visible within the application, because the <kbd>ApplicationArea</kbd> property must be explicitly declared.</p>
<p>Just click on the error line in the <span class="packt_screen">PROBLEM</span> window, the one marked by ID AL(PTE0008). This action will result in placing the focus of the cursor in the <kbd>includeLogo</kbd> field definition within the code editor.</p>
<p>Add the <kbd>ApplicationArea</kbd> property for the <kbd>includelogo</kbd> column in the request page as follows:</p>
<pre>field(includeLogo;includeLogo)<br/>{<br/>Caption = 'Include company logo';<br/>ApplicationArea = All;<br/>}</pre>
<p>You might notice that the error in the <span class="packt_screen">PROBLEMS</span> window <span>suddenly</span><span> </span><span>disappears. Moreover, the report is moved down in the object stack in the <span><span class="packt_screen">PROBLEMS</span> </span>window:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/10314588-5cd4-4dd4-bece-4a88cc48c8b3.png" style="width:61.00em;height:21.00em;"/></p>
<p>This happened because the problems record stack is ordered by descending priority, hence <kbd>Table 50103 Packt Extension Setup</kbd>, which contains an error, is moved to the top of the object list to be reviewed first, before warnings and info.</p>
<p><span><span>A rule's importance value</span></span> can be changed at will by creating a JSON file that contains the IDs of the rules that need to be changed and how they have to be set according to your company's development rules.</p>
<p>Let's create a directory in the extension's main folder called <kbd>.ruleset</kbd>, and create a file called <kbd>demo.ruleset.json</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/80f5e91e-008c-465b-94e5-1f8937111c47.png" style="width:13.67em;height:6.83em;"/></p>
<p>Open <kbd>demo.ruleset.json</kbd>, and invoke the <kbd>truleset</kbd> standard snippet to write the following:</p>
<pre>{<br/>    "name": "PacktDemoExtensionRuleSet",<br/>    "description": "Rule Set for Packt Demo Extension (PTE)",<br/>    "rules": [<br/>        {<br/>            "id": "AA0008",<br/>            "action": "Hidden",<br/>            "justification": "Open and Close parenthesis warning is kept hidden"<br/>        }<br/>    ]<br/>}</pre>
<p>In this way, we would like to instruct the AL Language code analyzer to avoid adding a warning record in the problems window for the rule whose ID is <kbd>AA008</kbd>. Word for word, the<span><span> rule is <q>"Function calls should have parentheses even if they do not have any parameters."</q></span></span></p>
<p>The last step to make it work is to assign the <kbd>.alRuleSetPath</kbd> parameter to point to the newly created file:</p>
<pre>{<br/>  "al.enableCodeAnalysis": true,
    "al.codeAnalyzers": [<br/>        "${CodeCop}",<br/>        "${PerTenantExtensionCop}",<br/>       "${UICop}"<br/>    ],<br/>   "al.ruleSetPath": "./.ruleset/demo.ruleset.json"<br/>}</pre>
<div class="packt_infobox">When you assign the path to a ruleset file, it is recommended that you save all files and close and reopen Visual Studio Code, in order to be sure that there are no permission errors, and access the ruleset file by the current process.</div>
<p>Once the ruleset file is in place, there should not be any warnings in the <span class="packt_screen">PROBLEMS</span> window related to opened and closed parentheses, and the number of records shown in the problems should be reduced. This can be seen in the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/36eb13e7-90db-4386-bc24-cb81c95ebab7.png" style="width:51.08em;height:19.08em;"/></p>
<p>There are still 19 elements that need to be evaluated in order to be compliant with the AL best coding practice. Takeaways at this stage are that they should make good use of these rules in their own company and discuss what needs to be promoted higher, maintained as-is, or be completely turned off.</p>
<div class="packt_infobox">Be careful when enabling code analyzers, since they might increase memory consumption (RAM) in the development machine.</div>
<p>We saw here how to improve the quality of your code by activating AL code analyzers. In the next section, we'll see how you can use <em>Event Recorder</em> when developing extensions with Dynamics 365 Business Central.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding Event Recorder</h1>
                </header>
            
            <article>
                
<p>We all know that Dynamics 365 Business Central online development can only be done through extensions. Accessing code base extensibility is guaranteed by subscribing to standard event publishers.</p>
<p>Considering that there are several thousands of standard event publishers all over the application and the number is growing with every online update, finding the right spot to hook up a standard publisher is sometimes as hard as trying to find the proverbial needle in the haystack.</p>
<p>The recommended way to find out the appropriate entry point at which to subscribe is to use the <span><span>Event Recorder</span></span>.</p>
<p>This application feature is a must if you do not know what standard objects are, or you do not have access to the third-party source code in order to look at publisher definitions (in the event the code you subscribe to is part of a third-party extension or a private IP).</p>
<p>There are two ways to enable this feature:</p>
<ul>
<li>From Visual Studio Code: Open an extension source code project that defines a suitable sandbox connection in the <kbd>launch.json</kbd> <span>file. Run the Command Palette (</span><em>Ctrl</em> + <em>Shift</em> + <em>P</em><span>) and then select</span> <span class="packt_screen">AL: Open Events Recorder</span>.</li>
</ul>
<ul>
<li>Connect to your production or sandbox tenant and search for <kbd>Event Recorder</kbd>: The Event Recorder page offers a very simple action menu called <strong>Record Events</strong> <span>with a <span class="packt_screen">Start</span> and <span class="packt_screen">Stop</span></span> button.</li>
</ul>
<p>By simply pressing <span class="packt_screen">Start</span>, the Event Recorder is activated and is ready to track the code processing flow.</p>
<p>It is crucial to understand that the Event Recorder session will capture absolutely everything that the code is executing; therefore it is recommended you opt for one of the following actions:</p>
<ul>
<li>Go to the Event Recorder page in one browser tab (let's call it TAB 1) and then create a new tab (TAB 2) where you browse to the page where you would like to start recording events. Then, start the Event Recorder in TAB 1 and start performing the actions that are needed to track the business process flow in TAB 2. When finished, go back to TAB 1 and stop the Event Recorder.</li>
<li>Browse to the page where you would like to start recording events (TAB 1,) and in a new tab (TAB 2) go to the Event Recorder page and start it. Back in TAB 1, perform the actions that are needed to track the process and, when you're finished, stop event recording in TAB 2.</li>
</ul>
<p>The page will refresh and display the records inserted in a temporary table in <span>order of </span>code execution, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/72dfcdbb-a870-449c-b523-6b2e82a7139e.png" style="width:52.25em;height:25.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Event Recorder in action</span></div>
<p>Since these <span>are records stored in a temporary table,</span> they <span>are volatile in memory and are not stored in the database. You now have the full list of events that were triggered during your business process, and from here you can find the right entry points to use for your customizations.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have learned how to run the debugger and master its interface. We have also seen how to pin non-debuggable functions and variables in order to avoid showing private data when needed. We also inspected cool standard features that make our debugging and development life easier: code analyzers and Event Recorder. </p>
<p>Now you're ready to debug extensions, to inspect events, and to analyze your AL code.</p>
<p><span><span>I</span><span>n this chapter, we have also shown how to catch runtime errors while inspecting code flow.</span></span> In the next chapter, we will master how to detect logic issues (bugs) in application code through the development of automated tests.</p>


            </article>

            
        </section>
    </body></html>