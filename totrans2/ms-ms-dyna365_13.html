<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Automated Test Development with AL</h1>
                </header>
            
            <article>
                
<p class="CDPAlignLeft CDPAlign">In the previous chapter, we saw how to debug AL extensions with Visual Studio Code.</p>
<p>In this chapter, we will have a look at how to write automated tests for an extension in AL. We need to do this in order to have a modern development life cycle, and it's mandatory if you want to publish your extensions on AppSource.</p>
<p>Using the demo extension that was developed in <a href="d8553d40-bf59-4aef-983c-89519ef30e29.xhtml">Chapter 5</a>, <em>Developing a Customized Solution for Dynamics 365 Business Central</em>, we will cover the following topics:</p>
<ul>
<li>Designing tests using the Acceptance Test-Driven Development pattern</li>
<li>Setting up a test extension</li>
<li>The technique behind testing code</li>
<li class="mce-root">Implementing test code</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test automation and testing design principles</h1>
                </header>
            
            <article>
                
<p>Application testing is not rocket science. Neither is automated application testing. It's just another learnable skill. From a developer's perspective, however, you need a change of mindset to write code with a totally different purpose than you're used to do. It's common knowledge that developers should never test their own code, as they, consciously or unconsciously, know how to use the software and how to evade issues. They write code to make something work.</p>
<p>Testing, however, is not about <em>how to make it</em>; rather, it's about <em>how to break it</em>. But this knowledge applies to manual, exploratory testing, where tests are executed based on knowledge and experience, not to scripts. And <span>automatic tests are scripts</span>.</p>
<p>To code these scripts into automated tests, we'll need developers. And more often than not, it will be the same developer that did the application coding.</p>
<p>In order for developers to code automated tests, they need to be provided with well-defined scripts. If there is <strong>no design</strong>, there will be <strong>no test</strong>. And that's the approach we will take in this chapter—we will first design tests and then show you how to code them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing tests with ATDD</h1>
                </header>
            
            <article>
                
<p>In his book, <em>Automated Testing in Microsoft Dynamics 365 Business Central</em>, Luc van Vugt delves into how to design and implement <span>your tests</span><span>. Based on the so-called</span> <strong>Acceptance Test-Driven Development</strong> <span>(</span><strong>ATDD</strong><span>) methodology, he shows how to write your requirements like a test design using the</span> ATDD <span>pattern. This pattern introduces five tags:</span></p>
<ul>
<li>FEATURE: Defines what feature(s) the test or collection of test cases is testing.</li>
<li>SCENARIO: Defines the scenario being tested for a single test.</li>
<li>GIVEN: Defines what data setup is needed; a test case can have multiple GIVEN tags when the data setup is more complex.</li>
<li>WHEN: Defines the action under test; each test case should have only one WHEN tag.</li>
<li>THEN: Defines the result of the action, or more specifically, the verification of the result. If multiple results apply, multiple THEN tags will be needed.</li>
</ul>
<p>The following is what a ATDD scenario would look like for our customer category feature:</p>
<ul>
<li><strong>[FEATURE]</strong> Customer Category</li>
<li><strong>[SCENARIO #0002]</strong> Assign blocked customer category to customer</li>
<li><strong>[GIVEN]</strong> A blocked customer category</li>
<li><strong>[GIVEN]</strong> A customer</li>
<li><strong>[WHEN]</strong> Set customer category on customer</li>
<li><strong>[THEN]</strong> Blocked category error thrown</li>
</ul>
<div class="packt_tip">You can acquire Luc's book at<br/>
<a href="https://www.packtpub.com/automated-testing-in-microsoft-dynamics-365-business-central">https://www.packtpub.com/automated-testing-in-microsoft-dynamics-365-business-central</a>.</div>
<p>After learning how to design, we will now look at how to prepare the environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing the environment</h1>
                </header>
            
            <article>
                
<p>In order to start writing automated tests on your AL extension, you need to import <em>Microsoft Test Framework</em> into your Dynamics 365 Business Central environment. If you're working with Dynamics 365 Business Central on-premise (standalone installation), <span>you can import it from the product DVD. If you are using a Docker-based development sandbox,</span> <span>you can import the Test Toolkit automatically </span><span>with</span><span> the</span><span> </span><kbd>navcontainerhelper</kbd> <span>module </span><span>by adding the</span> <kbd>-includeTestToolkit</kbd> <span>switch parameter to the</span> <kbd>New-BcContainer</kbd> <span>cmdlet.</span></p>
<p>If you have an already-running Docker container with Dynamics 365 Business Central, you can import the Test Toolkit by using the following cmdlets:</p>
<pre>Import-TestToolkitToBcContainer -containerName d365bcdev
Generate-SymbolsInNavContainer -containerName d365bcdev</pre>
<p>The Test Toolkit Test Libraries consist of<span> the following five</span> apps (included in the latest Docker images in the <kbd>C:\Applications folder</kbd>):</p>
<ul>
<li><kbd>Microsoft_Any.app</kbd></li>
<li><kbd>Microsoft_Library Assert.app</kbd></li>
<li><kbd>Microsoft_System Application Test Library.app</kbd></li>
<li><kbd>Microsoft_Tests-TestLibraries.app</kbd></li>
<li><kbd>Microsoft_Test Runner.app</kbd></li>
</ul>
<p>Your environment now contains all that you need to write and execute automatic tests. In the next section, we'll see how to set up tests for your extensions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up test development for extensions</h1>
                </header>
            
            <article>
                
<div>
<p>If we take the most restrictive requirement for extensions (the requirement that Microsoft considers mandatory for approving your extension for release to AppSource), app and test code should be placed in separate extensions. As such, the test extension should have a dependency on the app extension.</p>
<p>This separation, however, might restrict the parallel development of the app and test code, since any change to an app extension results in its redeployment. This potentially also results in an update and redeployment of the test extension.</p>
<p>Before you realize it, you are continuously juggling your extensions, thereby reducing the productivity of the development team. The best course of action, while developing, is to have the app and test code placed in the same extension. Once it's ready, you can split up the code and create the two mandatory extensions by means of an automated build script or a specific merging strategy.</p>
<p>If your extension is not to be put on AppSource, I still strongly advise you not to release the test code in the app extension, in order to prevent automated tests from being run in a production environment.</p>
<p>In the specific case of our demo extension, where the app code is already completed, we can set up our test in a separate, dependent extension. In the next section, we'll see how to do that in practice.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up our Visual Studio Code test project</h1>
                </header>
            
            <article>
                
<div>
<p>To set up a new project for our test automation, perform the operation we carried out in <a href="d8553d40-bf59-4aef-983c-89519ef30e29.xhtml">Chapter 5</a>, <em>Developing a Customized Solution for Dynamics 365 Business Central</em>, when we started our demo extension. Make sure that the <kbd>app.json</kbd> of our new test project is updated as follows:</p>
<div>
<pre><span>{<br/></span><span>  </span><span>"id"</span><span>: </span><span>"7737ab78-c872-4bca-b9f8-2de788818c21"</span><span>,<br/></span><span>  </span><span>"name"</span><span>: </span><span>"TestPacktDemoExtension"</span><span>,<br/></span><span>  </span><span>"publisher"</span><span>: </span><span>"fluxxus.nl"</span><span>,<br/></span><span>  </span><span>"brief"</span><span>: </span><span>"Tests for Customer Category, Gift Campaigns and Vendor Quality Management"</span><span>,<br/></span><span>  </span><span>"description"</span><span>: </span><span>"Tests for Customer Category, Gift Campaigns and Vendor Quality Management"</span><span>,<br/></span><span>  </span><span>"version"</span><span>: </span><span>"1.0.0.0"</span><span>,<br/></span><span>  </span><span>"privacyStatement"</span><span>: </span><span>""</span><span>,<br/></span><span>  </span><span>"EULA"</span><span>: </span><span>""</span><span>,<br/></span><span>  </span><span>"help"</span><span>: </span><span>"https://www.packtpub.com/business/automated-testing-microsoft-dynamics-365-business-central"</span><span>,<br/></span><span>  </span><span>"url"</span><span>: </span><span>"http://www.fluxxus.nl"</span><span>,<br/></span><span>  </span><span>"logo"</span><span>: </span><span>"./Logo/ExtLogo.png"</span><span>,<br/></span><span>  </span><span>"dependencies"</span><span>: [<br/></span><span>    {<br/></span><span>      </span><span>"appId"</span><span>: </span><span>"63ca2fa4-4f03-4f2b-a480-172fef340d3f"</span><span>,</span><span><br/></span><span>      </span><span>"publisher"</span><span>: </span><span>"Microsoft"</span><span>,<br/></span><span>      </span><span>"name"</span><span>: </span><span>"System Application"</span><span>,<br/></span><span>      </span><span>"version"</span><span>: </span><span>"1.0.0.0"<br/></span><span>    },<br/></span><span>    {<br/></span><span>      </span><span>"appId"</span><span>: </span><span>"437dbf0e-84ff-417a-965d-ed2bb9650972"</span><span>,<br/></span><span>      </span><span>"publisher"</span><span>: </span><span>"Microsoft"</span><span>,<br/></span><span>      </span><span>"name"</span><span>: </span><span>"Base Application"</span><span>,<br/></span><span>      </span><span>"version"</span><span>: </span><span>"15.0.0.0"<br/></span><span>    },<br/></span><span>    {<br/></span><span>      </span><span>"appId"</span><span>: </span><span>"dd03d28e-4dfe-48d9-9520-c875595362b6"</span><span>,<br/></span><span>      </span><span>"name"</span><span>: </span><span>"PacktDemoExtension"</span><span>,<br/></span><span>      </span><span>"publisher"</span><span>: </span><span>"SD"</span><span>,<br/></span><span>      </span><span>"version"</span><span>: </span><span>"1.0.0.0"<br/></span><span>    },<br/></span><span>    {<br/></span><span>      </span><span>"appId"</span><span>: </span><span>"dd0be2ea-f733-4d65-bb34-a28f4624fb14"</span><span>,<br/></span><span>      </span><span>"publisher"</span><span>: </span><span>"Microsoft"</span><span>,<br/></span><span>      </span><span>"name"</span><span>: </span><span>"Library Assert"</span><span>,<br/></span><span>      </span><span>"version"</span><span>: </span><span>"15.0.36560.0"<br/></span><span>    },<br/></span><span>    {<br/></span><span>      </span><span>"appId"</span><span>: </span><span>"e7320ebb-08b3-4406-b1ec-b4927d3e280b"</span><span>,<br/></span><span>      </span><span>"publisher"</span><span>: </span><span>"Microsoft"</span><span>,<br/></span><span>      </span><span>"name"</span><span>: </span><span>"Any"</span><span>,<br/></span><span>      </span><span>"version"</span><span>: </span><span>"15.0.36560.0"<br/></span><span>    },<br/></span><span>    {<br/></span><span>      </span><span>"appId"</span><span>: </span><span>"9856ae4f-d1a7-46ef-89bb-6ef056398228"</span><span>,<br/></span><span>      </span><span>"publisher"</span><span>: </span><span>"Microsoft"</span><span>,<br/></span><span>      </span><span>"name"</span><span>: </span><span>"System Application Test Library"</span><span>,<br/></span><span>      </span><span>"version"</span><span>: </span><span>"15.0.36560.0"<br/></span><span>    },<br/></span><span>    {<br/></span><span>      </span><span>"appId"</span><span>: </span><span>"5d86850b-0d76-4eca-bd7b-951ad998e997"</span><span>,<br/></span><span>      </span><span>"publisher"</span><span>: </span><span>"Microsoft"</span><span>,<br/></span><span>       </span><span>"name"</span><span>: </span><span>"Tests-TestLibraries"</span><span>,<br/></span><span>       </span><span>"version"</span><span>: </span><span>"15.0.36560.0"<br/></span><span>    }<br/></span><span>  ],<br/></span><span>  </span><span>"screenshots"</span><span>: [],<br/></span><span>  </span><span>"platform"</span><span>: </span><span>"15.0.0.0"</span><span>,<br/></span><span>  </span><span>"idRanges"</span><span>: [<br/></span><span>  {<br/></span><span>    </span><span>"from"</span><span>: </span><span>60100</span><span>,<br/></span><span>    </span><span>"to"</span><span>: </span><span>60150<br/></span><span>  }],<br/></span><span>  </span><span>"runtime"</span><span>:</span><span>"4.0"</span><span>,<br/></span><span>  </span><span>"showMyCode"</span><span>: </span><span>true<br/></span><span>}</span></pre></div>
</div>
<div>
<p>As you can see, we have added the dependencies from the extension to the test, and from all the <em>Test Toolkit Libraries</em> apps that are needed for testing.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning about the technique behind test code</h1>
                </header>
            
            <article>
                
<p>Before we start coding tests, we need to learn a couple of things about the technique behind test code, the so-called <strong>testability framework</strong>.</p>
<p>Since NAV 2009 Service Pack 1, Microsoft has allowed the platform to let you build test suites by means of <em>test functions</em> in <em>test codeunits</em>. When executing a test codeunit, the platform will do the following:</p>
<ul>
<li>Run the <kbd>OnRun</kbd> trigger and each test function that resides in the test codeunit, from top to bottom</li>
<li>Record the result of each test function</li>
</ul>
<p>This is what Luc van Vugt calls the <strong>first pillar</strong> of the testability framework. Our first test example will implement this.</p>
<p>The <strong>second pillar</strong> allows you to create so-called <em>positive–negative</em>, or <em>rainy-path</em>, tests, in which we test the circumstances that led to failure. To achieve this, we use the <span>AL</span><span> </span><kbd>asserterror</kbd> <span>keyword, which should be applied in front of the calling statement to catch the error and let the test pass:</span></p>
<pre>asserterror &lt;calling statement&gt;</pre>
<p>Our second scenario, which was used in a previous example, will make use of this testability feature.</p>
<p>In various parts of our code, we will interact with the user, asking them, for example, to confirm a certain action, or by simply displaying a message. When automating tests, we need to be able to handle these user interactions.</p>
<p>For this, the <strong>third pillar</strong>, the <strong>user interface</strong> (<strong>UI</strong>) <em>handler functions</em>, has been conceived. <em>Handler functions</em> are a special type of function that can only be created in test codeunits, and aim to handle UI interactions that exist in the code under test. They enable us to fully automate tests without the need for a real user to interact with them. Our third test example will show us how to do this.</p>
<p>The <strong>fourth pillar</strong> is the <em>test runner</em>. This is a specific codeunit that can do the following:</p>
<ul>
<li>Run tests that are stored in multiple codeunits, control their execution, and collect and secure the results</li>
<li>Do this run in isolation so that write transactions, in the end, do not alter the database that we run the test on, and so that each rerun of a test is done using the same initial data setup</li>
</ul>
<p>When running the test that we are going to build, we will make use of the standard test runner that resides in Dynamics 365 Business Central.</p>
<p>The initial trigger for adding the testability framework to the platform was implemented to get away from testing the business logic through the UI. As such, the testability framework is enabled headless, and thus there is faster testing of the business logic and it is not possible to test the UI.</p>
<p>Moving ahead, it became clear that sole headless tests excluded too much. How do we test business logic that typically resides on pages, such as a product configurator, in which options are displayed or hidden depending on the values entered by the user? So, later, Microsoft added a <strong>fifth pillar</strong> to the testability framework: the <em>test page</em>.</p>
<p>A test page is a logical representation of a page and is strictly handled in memory, displaying no UI. It adds methods that allow you to code the behavior of the user when accessing a page and its subparts, reading and changing data on it, and performing its actions. The fourth test example (in the <em>UI handlers – test example 4</em> section) will include a test page. So, let's see how we go about testing.</p>
<div class="packt_tip">Find out more details of the five pillars of the testability framework in Luc's book at <a href="https://www.packtpub.com/business/automated-testing-microsoft-dynamics-365-business-central">https://www.packtpub.com/business/automated-testing-microsoft-dynamics-365-business-central</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing our test scenarios</h1>
                </header>
            
            <article>
                
<p>As we've already mentioned, we will illustrate four of the five pillars of testability in a test example:</p>
<ul>
<li>Test codeunit and test function</li>
<li><kbd>asserterror</kbd></li>
<li>Test page</li>
<li>UI handlers</li>
</ul>
<p>We need to have designed each scenario to enable us to code a test efficiently and effectively. This is what we will do first in the following section.</p>
<div class="packt_infobox">In his book, Luc shows extensively how to get from requirements to an automated test, or as he calls it <em>From customer wish to test automation</em>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test codeunit and test function – Test
example 1</h1>
                </header>
            
            <article>
                
<p>As test codeunits and test functions are the basis of test coding in AL, we could take any scenario as an example. But let's keep it simple and start with the basic requirement of our demo extension: t<span>he company wants to classify customers based on custom categories that they can define over time, and that can change in the future.</span></p>
<p>This has been implemented by adding a new table called <em>Customer Category</em> with a related page, and a new field in the <em>Customer</em> table called <em>Customer Category Code</em>.</p>
<p>A first test scenario when testing a basic part of this requirement would be as follows:</p>
<ul>
<li><strong>[FEATURE]</strong> Customer Category</li>
<li><strong>[SCENARIO #0001]</strong> Assign non-blocked customer category to customer</li>
<li><strong>[GIVEN]</strong> A non-blocked customer category</li>
<li><strong>[GIVEN]</strong> A customer</li>
<li><strong>[WHEN]</strong> Set customer category on customer</li>
<li><strong>[THEN]</strong> Customer has customer category code field populated</li>
</ul>
<p>As each scenario should be self-explanatory, we are not going to elaborate on each of the tags.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">asserterror – Test example 2</h1>
                </header>
            
            <article>
                
<p>We can easily illustrate the usage of the asserterror keyword with the scenario discussed previously:</p>
<ul>
<li><strong>[FEATURE]</strong> Customer Category</li>
<li><strong>[SCENARIO #0002]</strong> Assign blocked customer category to customer</li>
<li><strong>[GIVEN]</strong> A blocked customer category</li>
<li><strong>[GIVEN]</strong> A customer</li>
<li><strong>[WHEN]</strong> Set customer category on customer</li>
<li><strong>[THEN]</strong> Blocked category error thrown</li>
</ul>
<p>This tests the same feature that was defined by the requirement to classify customers. However, even though the blocked pattern that was applied to the <em>Customer Category</em> was not mentioned in the requirements, it has been implemented in the extension, throwing an error when assigning a blocked customer category to a customer, and therefore it needs to be tested.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test page – Test example 3</h1>
                </header>
            
            <article>
                
<p>According to the business requirements described in <a href="d8553d40-bf59-4aef-983c-89519ef30e29.xhtml">Chapter 5</a>, <em>Developing a Customized Solution for Dynamics 365 Business Central</em>, the user must be <q>"able to create a default customer category and assign this default value to a customer automatically."</q></p>
<p>This perfectly illustrates the use of a test page using the following scenario:</p>
<ul>
<li class="mce-root"><strong>[FEATURE]</strong> Customer Category UI</li>
<li class="mce-root"><strong>[SCENARIO #0007]</strong> Assign default category to customer from customer card</li>
<li class="mce-root"><strong>[GIVEN]</strong> A non-blocked default customer category</li>
<li class="mce-root"><strong>[GIVEN]</strong> A customer with customer category not equal to default customer category</li>
<li class="mce-root"><strong>[WHEN]</strong> Select <span class="packt_screen">Assign Default Category</span> action on customer card</li>
<li class="mce-root"><strong>[THEN]</strong> Customer has default customer category</li>
</ul>
<p>It should be noted that we have <em>UI</em> in the <kbd>[FEATURE]</kbd> tag, which denotes that the feature is tested by making use of the UI. Preferably, test automation is about creating so-called <em>headless</em> tests; that is, tests that do not make use of the UI, as UI tests are 5 to 10 times slower than headless tests and non-UI tests. This is demonstrated by Luc in his book with the following screenshot, which compares a similar headless test and a UI test:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9b5eca60-a41e-4254-b7d5-52ab7b14b0b3.png" style="width:45.58em;height:28.83em;"/></p>
<p class="NormalPACKT"><span>The average execution duration for UI tests is 1.35 s, while the headless average is almost seven times faster: 0.20 s.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">UI handlers – Test example 4</h1>
                </header>
            
            <article>
                
<p>You might have already inspected all the application code of our demo extension on GitHub, and as such you might have seen that few UI elements triggered by code need a handler function. Actually, there is only one to be found in the <kbd>DoGiftCheck</kbd> function of the <kbd>50101 GiftManagement_PKT</kbd><em> </em><span>codeunit</span><span>:</span></p>
<pre>if (SalesLine.Quantity &lt; GiftCampaign.MinimumOrderQuantity) and<br/>    (GiftCampaign.MinimumOrderQuantity - SalesLine.Quantity &lt;=<br/>        PacktSetup."Gift Tolerance Qty")<br/>then<br/>    Message(<br/>        GiftAlert, SalesLine."No.",<br/>        Format(GiftCampaign.MinimumOrderQuantity),<br/>        Format(GiftCampaign.GiftQuantity));</pre>
<p>Getting it triggered is not as simple as the other examples, as a lot of conditions need to be met. For that reason, it appears here the fourth, and last, example.</p>
<p>As you can see, the scenario is <span>indeed</span><span> </span><span>somewhat more extensive:</span></p>
<ul>
<li><strong>[Feature]</strong> Gifts</li>
<li><strong>[Scenario #0010]</strong> Assign quantity on sales line to trigger active<strong> </strong>promotion message</li>
<li><strong>[Given]</strong> Packt setup with <span class="packt_screen">Gift Tolerance Qty</span> set</li>
<li><strong>[Given]</strong> Customer with non-blocked customer category with <span class="packt_screen">Free Gifts Available</span></li>
<li><strong>[Given]</strong> Item</li>
<li><strong>[Given]</strong> Gift campaign for item and customer category with <span class="packt_screen">Minimum Order Quantity</span> set</li>
<li><strong>[Given]</strong> Sales invoice for customer with line for item</li>
<li><strong>[When]</strong> Set quantity on invoice line smaller than <span class="packt_screen">Minimum Order Quantity</span> and within <span class="packt_screen">Gift Tolerance Qty</span></li>
<li><strong>[Then]</strong> Active promotion message is displayed</li>
</ul>
<p>Here, we have designed our required test scenarios. In the next section, we'll see how to implement them effectively.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing our test scenarios</h1>
                </header>
            
            <article>
                
<p>Given an ATDD scenario, we can effectively implement test code using the following four steps:</p>
<ol>
<li>Create a test codeunit with a name based on the <kbd>[FEATURE]</kbd> tag.</li>
<li>Embed the requirement into a test function with a name based on the <kbd>[SCENARIO]</kbd> tag.</li>
<li>Write the test story based on the <kbd>[GIVEN]</kbd>, <kbd>[WHEN]</kbd>, and <kbd>[THEN]</kbd> tags.</li>
<li>Construct the real code.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test codeunit and test function – Test
example 1</h1>
                </header>
            
            <article>
                
<p>Let's perform this four-step recipe for our first test example with the following ATDD scenario:</p>
<ul>
<li><strong>[FEATURE]</strong> Customer Category</li>
<li><strong>[SCENARIO #0001]</strong> Assign non-blocked customer category to customer</li>
<li><strong>[GIVEN]</strong> A non-blocked customer category</li>
<li><strong>[GIVEN]</strong> A customer</li>
<li><strong>[WHEN]</strong> Set customer category on customer</li>
<li><strong>[THEN]</strong> Customer has customer category code field populated</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Create a test codeunit</h1>
                </header>
            
            <article>
                
<p>Using the <kbd>[FEATURE]</kbd> tag and applying the unique suffix for our extension is the basic structure of our codeunit, and will look as follows:</p>
<pre>codeunit 60100 "Customer Category PKT"<br/>{<br/>    // [FEATURE] Customer Category<br/>    SubType = Test;<br/>}</pre>
<p>As you can see, a test codeunit is defined by setting its <kbd>SubType</kbd> to <kbd>Test</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Embed the requirement</h1>
                </header>
            
            <article>
                
<p>Now, we create a test function with a name based on the SCENARIO description and embed the scenario, the <kbd>GIVEN-WHEN-THEN</kbd> part, in this function. I call this embedding <kbd>green</kbd><span>,</span> as it's the commented-out <kbd>GIVEN-WHEN-THEN</kbd> sentences, before you start programming the black part (the <kbd>.al</kbd> test code).</p>
<p>Look at what the codeunit has now become:</p>
<pre>codeunit 60100 "Customer Category PKT"<br/>{<br/>    // [FEATURE] Customer Category<br/>    SubType = Test;<br/>    [Test]<br/>    procedure AssignNonBlockedCustomerCategoryToCustomer()<br/>    // [FEATURE] Customer Category<br/>    begin<br/>        // [SCENARIO #0001] Assign non-blocked customer category<br/>         //                  to customer<br/>        // [GIVEN] A non-blocked customer category<br/>        // [GIVEN] A customer<br/>        // [WHEN] Set customer category on customer<br/>        // [THEN] Customer has customer category code field<br/>         //        populated<br/>    end;<br/>}</pre>
<p>A test function is denoted by the <kbd>[Test]</kbd><strong> </strong><span>tag</span><span>. If you forget to add this tag to a function, it will be a normal function.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing the test story</h1>
                </header>
            
            <article>
                
<p>Writing the first <kbd>black</kbd> parts is about writing pseudo-English, defining what needs to be achieved with a test. It makes a test readable by any non-technical peer in the project, and in the event their support is needed, the threshold for them to read the test is substantially lower than if the code had been written as technical code. And, maybe an even stronger argument is that the code will be embedded in reusable helper functions.</p>
<p class="mce-root"/>
<p>So, here we go; let's write the <kbd>black</kbd> parts:</p>
<pre>codeunit 60100 "Customer Category PKT"<br/>{<br/>    // [FEATURE] Customer Category<br/>    SubType = Test;<br/>    [Test]<br/>    procedure AssignNonBlockedCustomerCategoryToCustomer()<br/>    begin<br/>        // [SCENARIO #0001] Assign non-blocked customer category<br/>         //                  to customer<br/>        // [GIVEN] A non-blocked customer category<br/>        CreateNonBlockedCustomerCategory();<br/>        // [GIVEN] A customer<br/>        CreateCustomer();<br/>        // [WHEN] Set customer category on customer<br/>        SetCustomerCategoryOnCustomer();<br/>        // [THEN] Customer category on customer<br/>        VerifyCustomerCategoryOnCustomer();<br/>    end;<br/>}</pre>
<p>This <kbd>story</kbd> sets up four helper functions in which the content will be constructed in the next step. Note how close the names of the helper functions are to the descriptions of the tags that they belong to, and that no arguments or return values have been defined yet.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Constructing the real code</h1>
                </header>
            
            <article>
                
<p>Writing the test story showed us that we need four helper functions, as follows:</p>
<ul>
<li><kbd>CreateNonBlockedCustomerCategory</kbd></li>
<li><kbd>CreateCustomer</kbd></li>
<li><kbd>SetCustomerCategoryOnCustomer</kbd></li>
<li><kbd>VerifyCustomerCategoryOnCustomer</kbd></li>
</ul>
<p>Let's construct and discuss them.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CreateNonBlockedCustomerCategory</h1>
                </header>
            
            <article>
                
<p><kbd>CreateNonBlockedCustomerCategory</kbd> is a manifold reusable helper function that creates a pseudo-random <kbd>Customer Category</kbd> record. At a later stage, we could promote this to become a library codeunit. The implementation is as follows:</p>
<pre>local procedure CreateNonBlockedCustomerCategory(): Code[20]<br/>var<br/>    CustomerCategory: Record "Customer Category_PKT";<br/>begin<br/>    with CustomerCategory do begin<br/>        Init();<br/>        Validate(<br/>            Code,<br/>            LibraryUtility.GenerateRandomCode(FIELDNO(Code),<br/>            Database::"Customer Category_PKT"));<br/>        Validate(Description, Code);<br/>        Insert();<br/>        exit(Code);<br/>    end;<br/>end;</pre>
<p>To populate the primary key field, we make use of the <kbd>GenerateRandomCode</kbd> function from the standard test library's <kbd>LibraryUtility</kbd> codeunit (<kbd>131000</kbd>). The <kbd>LibraryUtility</kbd> <span>variable </span>is declared globally as Microsoft does in their test codeunits, making it reusable in other helper functions.</p>
<p>We can observe the following from the preceding code:</p>
<ul>
<li>Pseudo-random means that whenever our test is executed in the same context, the <kbd>GenerateRandomCode</kbd> function will yield the same value, contributing to a reproducible test.</li>
<li>The <kbd>Description</kbd> field is populated by the same value as the <kbd>Code</kbd> field, as the specific value of <kbd>Description</kbd> has no meaning, and this way it's most effective.</li>
<li>Using the <kbd>with-do</kbd> construct in helper functions allows easy reuse of the code for similar purposes, but is applied to other tables as it only needs a change in the record variable (and the table it is referencing).</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CreateCustomer</h1>
                </header>
            
            <article>
                
<p>Using the <kbd>CreateCustomer</kbd> function in the standard library's <kbd>LibrarySales</kbd> codeunit (<kbd>130509</kbd>), our <kbd>CreateCustomer</kbd> creates a useable customer record and makes this helper function a straightforward exercise. Have a look at the following code:</p>
<pre>local procedure CreateCustomer(var Customer: record Customer)<br/>begin<br/>    LibrarySales.CreateCustomer(Customer);<br/>end;</pre>
<p>As with the <kbd>LibraryUtility</kbd> variable, we will declare the <kbd>LibrarySales</kbd> variable globally.</p>
<p>You might wonder why we create a helper function that only has one statement line. As we've already mentioned, using helper functions makes the test readable for non-technical peers, and makes it reusable. What we haven't mentioned is that it also makes it more maintainable/extendable. If we need to update the customer record created by the <kbd>CreateCustomer</kbd> function in the <kbd>Library - Sales</kbd> codeunit, we only need to add that to our local <kbd>CreateCustomer</kbd> function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SetCustomerCategoryOnCustomer</h1>
                </header>
            
            <article>
                
<p>Have a look at the implementation of <kbd>SetLookupValueOnCustomer</kbd>:</p>
<pre>local procedure SetCustomerCategoryOnCustomer(<br/>         var Customer: record Customer;<br/>         CustomerCategoryCode: Code[10])<br/>begin<br/>    with Customer do begin<br/>        Validate(<br/>            "Customer Category Code_PKT",<br/>            CustomerCategoryCode);<br/>        Modify();<br/>    end;<br/>end;</pre>
<p>Calling <kbd>Validate</kbd> is essential here. <kbd>SetLookupValueOnCustomer</kbd> is not just about assigning a value to the <kbd>Customer Category Code_PKT</kbd> field, but also about making sure it is validated against existing values in the <kbd>Customer Category</kbd> table. Note that the <kbd>OnValidate</kbd> trigger of the <kbd>Customer Category Code_PKT</kbd> field does not contain code.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">VerifyCustomerCategoryOnCustomer</h1>
                </header>
            
            <article>
                
<p>Each test needs to verify its outcome. Put bluntly, a test without verification is not a test. And for the current test, we need to verify that the customer category code that is assigned to the <kbd>Customer Category Code_PKT</kbd> field of the customer record is indeed the value that was created in the <kbd>Customer Category</kbd> table. We therefore retrieve the record from the database and verify the content of the <kbd>Customer Category Code_PKT</kbd> field as follows:</p>
<pre>local procedure VerifyCustomerCategoryOnCustomer(<br/>        CustomerNo: Code[20]; CustomerCategoryCode: Code[20])<br/>var<br/>    Customer: Record Customer;<br/>    FieldOnTableTxt: Label '%1 on %2';<br/>begin<br/>    with Customer do begin<br/>        Get(CustomerNo);<br/>        Assert.AreEqual(<br/>            CustomerCategoryCode,<br/>            "Customer Category Code_PKT",<br/>            StrSubstNo(<br/>                FieldOnTableTxt,<br/>                FieldCaption("Customer Category Code_PKT"),<br/>                TableCaption())<br/>        );<br/>    end;<br/>end;<br/><br/></pre>
<p>To verify that the expected value (first argument) and the actual value (second argument) are equal, we make use of the <kbd>AreEqual</kbd> function in the standard library <kbd>Assert</kbd> codeunit (<kbd>130000</kbd>). Of course, we could build our own verification logic using the error system function, and that's what <kbd>AreEqual</kbd> is doing too. Have a look at the following code:</p>
<pre>[External] procedure AreEqual(Expected: Variant;<br/>     Actual: Variant;Msg: Text)<br/> begin<br/>     if not Equal(Expected,Actual) then<br/>         Error(<br/>             AreEqualFailedMsg,<br/>             Expected,<br/>             TypeNameOf(Expected),<br/>             Actual,<br/>             TypeNameOf(Actual),<br/>             Msg)<br/> end;</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>By using the <kbd>AreEqual</kbd> function, however, we ensure that we get a standardized error message in case the expected and actual values are not equal. Over time, when reading the error of any failing test, you will be able to <span>easily </span>recognize the kind of error that occurred, given that your verification helper functions make use of the <kbd>Assert</kbd> library.</p>
<p>The completed test function would look like the following code, which is ready for execution:</p>
<pre>[Test]<br/>procedure AssignNonBlockedCustomerCategoryToCustomer()<br/>// [FEATURE] Customer Category<br/>var<br/>    Customer: Record Customer;<br/>    CustomerCategoryCode: Code[20];<br/>begin<br/>    // [SCENARIO #0001] Assign non-blocked customer category to<br/>    //                  customer<br/>    // [GIVEN] A non-blocked customer category<br/>    CustomerCategoryCode := CreateNonBlockedCustomerCategory();<br/>    // [GIVEN] A customer<br/>    CreateCustomer(Customer);<br/>    // [WHEN] Set customer category on customer<br/>    SetCustomerCategoryOnCustomer(Customer, CustomerCategoryCode);<br/>    // [THEN] Customer has customer category code field populated<br/>    VerifyCustomerCategoryOnCustomer(<br/>        Customer."No.",<br/>        CustomerCategoryCode);<br/>end;</pre>
<p>Notice the variables and arguments that have been added to the test codeunit and functions.</p>
<div class="packt_infobox">Go to the GitHub repository for this book to have a look at the full implementation of the test codeunit: <a href="https://github.com/PacktPublishing/Mastering-Microsoft-Dynamics-365-Business-Central">https://github.com/PacktPublishing/Mastering-Microsoft-Dynamics-365-Business-Central</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the test</h1>
                </header>
            
            <article>
                
<p>The proof of the <span>pudding </span>is in the eating, as they say, so let's run our test. The easiest and most instructive way to do this is by making use of the <strong>Test Tool</strong> in the application. You can easily access the Test Tool using the <span class="packt_screen">Tell Me...</span> feature in Dynamics 365 Business Central:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/03f6cd3b-2ed6-4ba4-91fe-88bc0d30214d.png" style="width:63.50em;height:29.92em;"/></p>
<p><span>When in a clean database, or at least a database or company where the <span class="packt_screen">Test Tool</span> has not been used yet, this is what the Test Tool looks like, a suite called</span> <span class="packt_screen">DEFAULT</span> <span>with no records in it, as shown here:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ec02762c-bcdd-443f-93cd-27ba2253551b.png" style="width:64.25em;height:30.42em;"/></p>
<p>To add our test to the suite, follow these steps:</p>
<ol>
<li>Select the <span class="packt_screen"><strong>Get Test Codeunits</strong></span> action.</li>
<li>In the dialog that opens, you have two options:
<ol>
<li><strong><span class="packt_screen">Select Test Codeunits</span></strong>:<strong> </strong>This will open a page with a list showing all test codeunits that are present in the database, from which you can select specific test codeunits; once you have selected them and clicked <span class="packt_screen">OK</span>, these codeunits will be added to the suite.</li>
<li><strong><span class="packt_screen">All Test Codeunits</span></strong>:<strong> </strong>This will add all test codeunits that exist in the database to the test suite.</li>
</ol>
</li>
</ol>
<p style="padding-left: 60px">Let's select the first option, <strong><span class="packt_screen">Select Test Codeunits</span></strong>. This will open the <span class="packt_screen">CAL TEST GET C<span>ODEUNITS</span></span> page. It shows the test codeunit that we have just created and a bunch of tests that reside in the database, mainly due to standard extensions:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9570ab20-81c7-40ef-9bc4-36bd225e9750.png" style="width:60.83em;height:28.58em;"/></p>
<ol start="3">
<li>Select the test codeunit and click <strong><span class="packt_screen">OK</span></strong>. The suite now shows for each test codeunit, a line with <kbd>Codeunit</kbd> <span>in the </span>Line Type column, and linked to this line (and indented), all its test functions (with <kbd>Function</kbd> in the Line Type column).</li>
</ol>
<p> </p>
<ol start="4">
<li>To run the tests, select the <strong><span class="packt_screen">Run</span></strong> action in the dialog that opens, with the <span class="packt_screen">Active Codeunit</span> and <span class="packt_screen">All</span><strong> </strong><span>options</span>. Since we have only one codeunit in the <kbd>DEFAULT</kbd> test suite, it does not matter which option we choose, so click <strong><span class="packt_screen">OK</span></strong>. Now our test codeunit will be run, and each test will yield a <kbd>Success</kbd><em> </em>result:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ec4ddf14-ff08-48fc-a3c1-b4744d5c92af.png" style="width:64.25em;height:30.42em;"/></p>
<p>Had we selected the <strong><span class="packt_screen">Active Codeunit</span> </strong><span>option</span><span>, only the selected codeunit would have been executed.</span></p>
<p>For each failure, the <span class="packt_screen">First Error</span> field will display the error that caused the failure. As you can see, <span class="packt_screen">First Error</span> is <kbd>FlowField</kbd>. If you drill down into it, the <span class="packt_screen">CAL Test Result</span> window opens. This displays the whole test run history for a specific test.</p>
<p>Running the test by clicking on <strong><span class="packt_screen">Run</span></strong> will call the standard test runner codeunit, <span class="packt_screen">CAL Test Runner (130400)</span>, and will make sure that tests run from the Test Tool will be run in isolation, and the results of each test function will be logged.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">asserterror – Test example 2</h1>
                </header>
            
            <article>
                
<p>As mentioned earlier, we will illustrate the use of <em>asserterror</em> with scenario #0002:</p>
<ul>
<li><strong>[FEATURE]</strong> Customer Category</li>
<li><strong>[SCENARIO #0002]</strong> Assign blocked customer category to customer</li>
<li><strong>[GIVEN]</strong> A blocked customer category</li>
<li><strong>[GIVEN]</strong> A customer</li>
<li><strong>[WHEN]</strong> Set customer category on customer</li>
<li><strong>[THEN]</strong> Blocked category error thrown</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a test codeunit</h1>
                </header>
            
            <article>
                
<p>Sharing the same <kbd>[FEATURE]</kbd> tag value as test example 1, our new test case will also share the same test codeunit, that is, <kbd>60100 Customer Category PKT</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Embedding the requirement</h1>
                </header>
            
            <article>
                
<p>According to the previous requirements, we need to create the following new test function in the <kbd>60100</kbd> codeunit:</p>
<pre>procedure AssignBlockedCustomerCategoryToCustomer()<br/>// [FEATURE] Customer Category<br/>begin<br/>    // [SCENARIO #0002] Assign blocked customer category to<br/>    //                  customer<br/>    // [GIVEN] A blocked customer category<br/>    // [GIVEN] A customer<br/>    // [WHEN] Set customer category on customer<br/>    // [THEN] Blocked category error thrown<br/>end;</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing the test story</h1>
                </header>
            
            <article>
                
<p>Given test example 1, writing the test story isn't a difficult exercise. Have a look at the following code:</p>
<pre>procedure AssignBlockedCustomerCategoryToCustomer()<br/>// [FEATURE] Customer Category<br/>var<br/>    Customer: Record Customer;<br/>    CustomerCategoryCode: Code[20];<br/>begin<br/>    // [SCENARIO #0002] Assign blocked customer category to<br/>    //                  customer<br/>    // [GIVEN] A blocked customer category<br/>    CustomerCategoryCode := CreateBlockedCustomerCategory();<br/>    // [GIVEN] A customer<br/>    Creat<span>eCustomer(Customer);<br/></span>    // [WHEN] Set customer category on customer<br/>    asserterror SetCustomerCategoryOnCustomer(<br/>                    Customer,<br/>                    CustomerCategoryCode);<br/>    // [THEN] Blocked category error thrown<br/>    VerifyBlockedCategoryErrorThrown();<br/>end;</pre>
<p>First of all, note how <kbd>asserterror</kbd> has been applied – in front of the call to the <kbd>SetCustomerCategoryOnCustomer</kbd> helper function. This ensures that the platform will expect <kbd>SetCustomerCategoryOnCustomer</kbd> to throw an error. <kbd>asserterror</kbd> enables the test to continue with the next statement and it will not check the error, as such. So, it is up to us to verify that the expected did occur. If there is no verification of the specific error following <kbd>asserterror</kbd>, any error will make your test pass.</p>
<p class="mce-root"/>
<p>Next, note that, based on test example 1, the required variables have already been provided.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Constructing the real code</h1>
                </header>
            
            <article>
                
<p>If we reuse the <kbd>CreateCustomer</kbd> and <kbd>SetCustomerCategoryOnCustomer</kbd> functions from test example 1, we only need to create two new helper functions:</p>
<ul>
<li><kbd>CreateBlockedCustomerCategory</kbd></li>
<li><kbd>VerifyBlockedCategoryErrorThrown</kbd></li>
</ul>
<p>Let's learn more about them both next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CreateBlockedCustomerCategory</h1>
                </header>
            
            <article>
                
<p>With the goal of <kbd>CreateBlockedCustomerCategory</kbd> being very similar to the <kbd>CreateNonBlockedCustomerCategory</kbd> helper function from test example 1, its construction is as simple, as follows:</p>
<pre>local procedure CreateBlockedCustomerCategory(): Code[20]<br/>var<br/>    CustomerCategory: Record "Customer Category_PKT";<br/>begin<br/>    with CustomerCategory do begin<br/>           Get(CreateNonBlockedCustomerCategory());<br/>           Blocked := true;<br/>           Modify();<br/>           exit(Code);<br/>    end;<br/>end;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">VerifyBlockedCategoryErrorThrown</h1>
                </header>
            
            <article>
                
<p>Earlier, it was noted that, when <kbd>asserterror</kbd> enables the test to continue with the next statement, it will not check the error as such. And that is what this helper function needs to do, as shown in the following code:</p>
<pre>local procedure VerifyBlockedCategoryErrorThrown()<br/>var<br/>    CategoryIsBlockedTxt: Label 'This category is blocked.';<br/>begin<br/>    Assert.ExpectedError(CategoryIsBlockedTxt);<br/>end;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the test</h1>
                </header>
            
            <article>
                
<p>Let's redeploy our extension and add the second test to the Test Tool by selecting <strong><span class="packt_screen">Actions | Functions | Get Test Methods</span></strong>. <span class="packt_screen">Get Test Methods</span> will update the selected test codeunit by adding all current test functions in the codeunit as lines in the Test Tool. Note that the <span class="packt_screen">RESULT</span> column will be cleared. Now, run the test codeunit and see that both tests are successful.</p>
<p>Consider the next screenshot, which shows the results of the tests:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/57d7de52-64a5-4f13-bb78-aafe526453f5.png" style="width:66.83em;height:31.67em;"/></p>
<p><span>Running the test codeunit will show that both tests have been executed successfully.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing the test</h1>
                </header>
            
            <article>
                
<p>How do we verify that success is a real success? We can do this in a simple way – by providing a different expected value to the verification function of our test case. So let's do it:</p>
<pre>Assert.ExpectedError('Testing the test.');</pre>
<p>Running our second test will now yield a failure with the next error text:</p>
<pre><em>Assert.ExpectedError failed. Expected: Testing the test. Actual: This category is blocked.</em></pre>
<p>The <em>actual error</em>, indeed, is the one that should occur. After this, we move on to test example 3.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test page – Test example 3</h1>
                </header>
            
            <article>
                
<p>We'll illustrate the usage of a test page in the next scenario:</p>
<ul>
<li><strong>[FEATURE]</strong> Customer Category</li>
<li><strong>[SCENARIO #0007]</strong> Assign default category to customer from customer card</li>
<li><strong>[GIVEN]</strong> A non-blocked default customer category</li>
<li><strong>[GIVEN]</strong> A customer with customer category not equal to default customer category</li>
<li><strong>[WHEN]</strong> Select <span class="packt_screen">Assign Default Category</span> action on customer card</li>
<li><strong>[THEN]</strong> Customer has default customer category</li>
</ul>
<p>As you should now know the first steps in the four-step recipe, let's go faster and <em>create</em>, <em>embed</em>, and <em>write</em> in one fell swoop.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a test codeunit</h1>
                </header>
            
            <article>
                
<p>Sharing the same <kbd>[FEATURE]</kbd> tag value as test examples 1 and 2, our new test case will share the same test codeunit, which is <kbd>60100 Customer Category PKT</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Embedding and writing</h1>
                </header>
            
            <article>
                
<p>In the already-existing <kbd>60100 Customer Category PKT</kbd> codeunit, we embed the requirements and write the test story, which leads us to the following test function:</p>
<pre>[Test]<br/>procedure AssignDefaultCategoryToCustomerFromCustomerCard()<br/>// [FEATURE] Customer Category UI<br/>var<br/>    Customer: Record Customer;<br/>    CustomerCategoryCode: Code[20];<br/><br/><br/>begin<br/>    // [SCENARIO #0007] Assign default category to customer from<br/>    //                  customer card<br/>    // [GIVEN] A non-blocked default customer category<br/>    CustomerCategoryCode :=<br/>        CreateNonBlockedDefaultCustomerCategory();<br/>    // [GIVEN] A customer with customer category not equal to<br/>    //         default customer category<br/>    CreateCustomerWithCustomerCategoryNotEqualToDefault(Customer);<br/>    // [WHEN] Select "Assign Default Category" action on customer<br/>    //        card<br/>    SelectAssignDefaultCategoryActionOnCustomerCard(<br/>        Customer."No.");<br/>    // [THEN] Customer has default customer category<br/>    VerifyCustomerHasDefaultCustomerCategory(<br/>        Customer."No.",<br/> CustomerCategoryCode);<br/>end;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Constructing the real code</h1>
                </header>
            
            <article>
                
<p>In order to have the <kbd>#0007</kbd> scenario working properly, we need to create these four helper functions:</p>
<ul>
<li><kbd>CreateNonBlockedDefaultCustomerCategory</kbd></li>
<li><kbd>CreateCustomerWithCustomerCategoryNotEqualToDefault</kbd></li>
<li><kbd>SelectAssignDefaultCategoryActionOnCustomerCard</kbd></li>
<li><kbd>VerifyCustomerHasDefaultCustomerCategory</kbd></li>
</ul>
<p>But, as you will see, and as you will also experience when writing more tests, the majority of these helper functions are easy to construct by making use of previously developed helper functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CreateNonBlockedDefaultCustomerCategory</h1>
                </header>
            
            <article>
                
<p><kbd>CreateNonBlockedDefaultCustomerCategory</kbd> resembles the <kbd>CreateBlockedCustomerCategory</kbd> <span>helper function that was</span> created for test example 2. We can use the same approach that was used there. Have a look at the following code:</p>
<pre>local procedure<br/>    CreateNonBlockedDefaultCustomerCategory(): Code[20]<br/>var<br/>    CustomerCategory: Record "Customer Category_PKT";<br/>begin<br/>    with CustomerCategory do begin<br/>           SetRange(Default, true);<br/>           if not FindFirst() then begin<br/>            Get(CreateNonBlockedCustomerCategory());<br/>            Default := true;<br/>            Modify();<br/>        end;<br/>        exit(Code);<br/>    end;<br/>end;</pre>
<p>Note that the <kbd>FindFirst</kbd> construction has been added to guarantee that only one default customer category will be added.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CreateCustomerWithCustomerCategoryNotEqualToDefault</h1>
                </header>
            
            <article>
                
<p>Calling the <kbd>CreateCustomer</kbd> helper function suffices as the customer record that is <span>created</span><span> </span><span>will have an empty</span> <kbd>Customer Category Code</kbd> <span>field. This makes the construction of this helper function a very easy exercise, as you can see in the following code:</span></p>
<pre>local procedure<br/>    CreateCustomerWithCustomerCategoryNotEqualToDefault(<br/>         var Customer: Record Customer)<br/>begin<br/>    CreateCustomer(Customer);<br/>end;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SelectAssignDefaultCategoryActionOnCustomerCard</h1>
                </header>
            
            <article>
                
<p>With the helper function, we touch on the core of this test example – making use of a test page to achieve <kbd>#0007</kbd>, that is, testing that the user can assign a default customer category to a specific customer. The following is what the helper function looks like:</p>
<pre>local procedure<br/>    SelectAssignDefaultCategoryActionOnCustomerCard(<br/>        CustomerNo: Code[20])<br/>var<br/>    CustomerCard: TestPage "Customer Card";<br/>begin<br/>    CustomerCard.OpenView();<br/>    CustomerCard.GoToKey(CustomerNo);<br/>    CustomerCard."Assign default category".Invoke();<br/>end;</pre>
<p>Note that I did not use a <kbd>with-do</kbd> construct to unambiguously show that the three statements in the function are referencing methods that you will only find on test page objects, and not on <span class="packt_screen">normal</span> pages:</p>
<ul>
<li><kbd>OpenView</kbd>: Opens the test page in view mode</li>
<li><kbd>GoToKey</kbd>: Finds the row in a dataset that is identified by the specified values</li>
<li><kbd>Invoke</kbd>: Invokes an action on a test page</li>
</ul>
<p>For a complete listing of all test page methods, take a look at the following URLs:</p>
<ul>
<li><kbd>TestPage</kbd>: <a href="https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testpage/testpage-data-type">https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testpage/testpage-data-type</a></li>
<li><kbd>TestField</kbd>: <a href="https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testfield/testfield-data-type">https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testfield/testfield-data-type</a></li>
<li><kbd>TestAction</kbd>: <a href="https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testaction/testaction-data-type">https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/methods-auto/testaction/testaction-data-type</a></li>
</ul>
<div class="packt_tip">You can find more details on test pages in Luc's book at <a href="https://www.packtpub.com/business/automated-testing-microsoft-dynamics-365-business-central">https://www.packtpub.com/business/automated-testing-microsoft-dynamics-365-business-central</a>.<a href="https://www.packtpub.com/business/automated-testing-microsoft-dynamics-365-business-central"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">VerifyCustomerHasDefaultCustomerCategory</h1>
                </header>
            
            <article>
                
<p>As the code for the default customer category is stored in the local <kbd>CustomerCategoryCode</kbd> variable in test example 4, verifying that the <kbd>CustomerCategoryCode</kbd> field on the customer record has indeed been populated with the default customer category is just a case of calling the already-existing <kbd>VerifyCustomerCategoryOnCustomer</kbd> <span>helper function, </span><span>as shown in the following code:</span></p>
<pre>local procedure<br/>    VerifyCustomerHasDefaultCustomerCategory(<br/>        CustomerNo: Code[20];<br/>        DefaultCustomerCategoryCode: Code[20])<br/>begin<br/>    VerifyCustomerCategoryOnCustomer(<br/>        CustomerNo,<br/>        DefaultCustomerCategoryCode)<br/>end;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the test</h1>
                </header>
            
            <article>
                
<p>Running both test codeunits will show that all tests are executed successfully.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">More examples for the Customer Category feature</h1>
                </header>
            
            <article>
                
<p>In the GitHub repository for this book, you will find an extra number of test scenarios regarding the Customer Category feature. Go there and study them, and see how various helper functions have to be reused, showing that building up a bigger test suite often involves the reuse of existing elements. You might have wondered why the test examples weren't consecutively numbered. Inspecting the other scenarios on GitHub will show you why.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">UI handler – Test example 4</h1>
                </header>
            
            <article>
                
<p>In order to show you how to implement a <kbd>UI handler</kbd> function, we are going to have a go at the following scenario:</p>
<ul>
<li><strong>[Feature]</strong> Gifts</li>
<li><strong>[Scenario #0010]</strong> Assign quantity on sales line to trigger active promotion message</li>
<li><strong>[Given]</strong> Packt setup with <span class="packt_screen">Gift Tolerance Qty</span> set</li>
<li><strong>[Given]</strong> Customer with non-blocked customer category with <span class="packt_screen">Free Gifts Available</span></li>
<li><strong>[Given]</strong> Item</li>
<li><strong>[Given]</strong> Gift campaign for item and customer category with <span class="packt_screen">Minimum Order Quantity</span> set</li>
<li><strong>[Given]</strong> Sales invoice for customer with line for item</li>
<li><strong>[When]</strong> Set quantity on invoice line smaller than <span class="packt_screen">Minimum Order Quantity</span> and within <span class="packt_screen">Gift Tolerance Qty</span></li>
<li><strong>[Then]</strong> Active promotion message is displayed</li>
</ul>
<p>As this is quite an extensive scenario, you will also explore and learn from a somewhat more complex test code sample.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a test codeunit</h1>
                </header>
            
            <article>
                
<p>Typically, a test codeunit can be viewed as a test suite that tests a feature. As this feature, <kbd>Gifts</kbd>, is different from the one addressed in the previous test examples, we should contain this test in a new test codeunit, as follows:</p>
<pre>codeunit 60101 "Gifts PKT"<br/>{<br/>    // [FEATURE] Gifts<br/>    SubType = Test;<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Embedding and writing</h1>
                </header>
            
            <article>
                
<p>Embedding and writing would now lead to a test function with the following pseudo-code:</p>
<pre>codeunit 60101 "Gifts PKT"<br/>{<br/>    // [FEATURE] Gifts<br/>    SubType = Test;<br/><br/>    [Test]<br/>    procedure AssignQuantityOnSalesLineToTriggerActive<br/>            PromotionMessage()<br/>    // [FEATURE] Gifts<br/>    begin<br/>        // [SCENARIO #0010] Assign quantity on sales line<br/>        //[GIVEN] Packt setup with "Gift Tolerance Qty" set<br/>        CreatePacktSetupWithGiftToleranceQty();<br/>        // [GIVEN] Customer with non-blocked customer category<br/>        //         with "Free Gifts Available"<br/>        CreateCustomerWithNonBlockedCustomerCategoryWith<br/>            FreeGiftsAvailable();<br/>        // [GIVEN] Item<br/>        CreateItem();<br/>        // [GIVEN] Gift campaign for item and customer category<br/>        //          with "Minimum Order Quantity" set<br/>        CreateGiftCampaignForItemAndCustomerCategory<br/>            WithMinimumOrderQuantity();<br/>        // [GIVEN] Sales invoice for customer with line for item<br/>        CreateSalesInvoiceForCustomerWithLineForItem();<br/>        // [WHEN] Set quantity on invoice line smaller than<br/>        //        "Minimum Order Quantity" and within<br/>        //        "Gift Tolerance Qty"<br/>        SetQuantityOnInvoiceLineSmallerThanMinimumOrderQuantity<br/>            AndWithinGiftToleranceQty();<br/>        // [THEN] Active promotion message is displayed<br/>        VerifyActivePromotionMessageIsDisplayed(); <br/> end;<br/>}</pre>
<p>This is the pseudo-code that describes the process for assigning gifts. In the next section, we'll see the real implementation.</p>
<div class="mce-root packt_tip">Note that, due to their length, some function names have been cut into two and spread over two lines.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Constructing the real code</h1>
                </header>
            
            <article>
                
<p>Given the <em>written story</em> (in the previous section), we now need to create the following seven helper functions in order to implement real test code effectively:</p>
<ul>
<li><kbd>CreatePacktSetupWithGiftToleranceQty</kbd></li>
<li><kbd>CreateCustomerWithNonBlockedCustomerCategoryWith</kbd><br/>
<kbd>FreeGiftsAvailable</kbd></li>
<li><kbd><kbd><kbd>CreateItem</kbd></kbd></kbd></li>
<li><kbd>CreateGiftCampaignForItemAndCustomerCategory</kbd><br/>
<kbd><kbd><kbd>WithMinimumOrderQuantity</kbd></kbd></kbd></li>
<li><kbd><kbd>CreateSalesInvoiceForCustomerWithLineForItem</kbd></kbd></li>
<li><kbd>AssignQuantityOnInvoiceLineSmallerThanMinimumOrderQuantity</kbd><br/>
<kbd>AndWithinGiftToleranceQty</kbd></li>
<li><kbd>VerifyActivePromotionMessageIsDisplayed</kbd></li>
</ul>
<p>Let's jump through the <em>real code</em> and take a look at a couple of specifics.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CreatePacktSetupWithGiftToleranceQty</h1>
                </header>
            
            <article>
                
<p>The <kbd>CreatePacktSetupWithGiftToleranceQty</kbd> helper function's main purpose is to set <kbd>GiftToleranceQty</kbd> on the extension setup, and is given by the following code:</p>
<pre>local procedure<br/>    CreatePacktSetupWithGiftToleranceQty(<br/>        GiftToleranceQtySet: Decimal)<br/>var<br/>    PacktExtensionSetup: Record "Packt Extension Setup";<br/>begin<br/>    with PacktExtensionSetup do begin<br/>        if not Get() then<br/>            Insert();<br/>        Validate("Gift Tolerance Qty", GiftToleranceQtySet);<br/>        Modify();<br/>    end;<br/>end;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The CreateCustomerWithNonBlockedCustomerCategoryWithFreeGiftsAvailable helper function</h1>
                </header>
            
            <article>
                
<p><kbd>CreateCustomerWithNonBlockedCustomerCategoryWithFreeGiftsAvailable</kbd> is a helper function that creates a customer with a non-blocking customer category set, and it's implemented as follows:</p>
<pre>local procedure<br/>    CreateCustomerWithNonBlockedCustomerCategory<br/>        WithFreeGiftsAvailable(var Customer: record Customer)<br/>begin<br/>    LibrarySales.CreateCustomer(Customer);<br/>    with Customer do begin<br/>        Validate(<br/>            "Customer Category Code_PKT",<br/>            CreateNonBlockedCustomerCategory<br/>                WithFreeGiftsAvailable());<br/>        Modify();<br/>    end;<br/>end;</pre>
<p>Note that, like our previous helper function, <kbd>CreateCustomer</kbd> (see test examples 1 and 2), this test function also makes use of the standard <kbd>CreateCustomer</kbd> function in the standard library <kbd>LibrarySales</kbd> codeunit (<kbd>130509</kbd>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CreateItem</h1>
                </header>
            
            <article>
                
<p><kbd>CreateItem</kbd> is a similar construction to the <kbd>CreateCustomer</kbd> function, as it makes use of the <kbd>CreateItem</kbd> function in the standard library <kbd>LibraryInventory</kbd> codeunit (<kbd>132201</kbd>). As a matter of fact, it's just a wrapper around it, as seen in the following code:</p>
<pre>local procedure CreateItem(var Item: Record Item)<br/>begin<br/>    LibraryInventory.CreateItem(Item);<br/>end;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CreateGiftCampaignForItemAndCustomerCategoryWithMinimumOrderQuantity</h1>
                </header>
            
            <article>
                
<p><kbd>CreateGiftCampaignForItemAndCustomerCategoryWithMinimumOrderQuantity</kbd> has to create a gift campaign record that combines the item that has just been created and the customer category that is linked to the newly created customer, and defines the period of time within the campaign will be valid and active. Have a look at what the functions look like:</p>
<pre>local procedure CreateGiftCampaignForItemAndCustomerCategoryWith<br/>    MinimumOrderQuantity(<br/>        NewItemNo: Code[20]; NewCustomerCategoryCode: code[20];<br/>        NewMinimumOrderQuantity: Decimal; NewGiftQuantity: Decimal)<br/>var<br/>    GiftCampaign: Record GiftCampaign_PKT;<br/>begin<br/>    with GiftCampaign do begin<br/>        Init();<br/>        Validate(CustomerCategoryCode, NewCustomerCategoryCode);<br/>        Validate(ItemNo, NewItemNo);<br/>        Validate(MinimumOrderQuantity, NewMinimumOrderQuantity);<br/>        Validate(EndingDate, DMY2Date(31, 12, 9999));<br/>        Validate(GiftQuantity, NewGiftQuantity);<br/>        Insert();<br/>    end;<br/>end;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CreateSalesInvoiceForCustomerWithLineForItem</h1>
                </header>
            
            <article>
                
<p>When provided with the numbers of our item and customer, the <kbd>CreateSalesInvoiceForCustomerWithLineForItem</kbd> <span>helper function </span><span>has to create a new sales invoice with one line, making use of the</span> <kbd>CreateSalesDocumentWithItem</kbd> <span>helper</span> <span>function from the standard library</span> <kbd>Library - Sales</kbd> <span>codeunit (<kbd>130509</kbd>). The following is what its implementation looks like:</span></p>
<pre>local procedure CreateSalesInvoiceForCustomerWithLineForItem(<br/>        CustomerNo: Code[20]; ItemNo: Code[20]): Code[20]<br/>var<br/>    SalesHeader: Record "Sales Header";<br/>    SalesLine: Record "Sales Line";<br/>begin<br/>    with SalesHeader do begin<br/>        LibrarySales.CreateSalesDocumentWithItem(<br/>            SalesHeader,<br/>            SalesLine,<br/>            "Document Type"::Invoice,<br/>            CustomerNo,<br/>            ItemNo,<br/>            0,<br/>            '',<br/>            0D);<br/>        exit("No.");<br/>    end;<br/>end;</pre>
<p>Note that no quantity is yet set on the line, as per the sixth parameter in the call to <kbd>CreateSalesDocumentWithItem</kbd>. The last two parameters of <kbd>CreateSalesDocumentWithItem</kbd> denote an undefined location and shipment date.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SetQuantityOnInvoiceLineSmallerThanMinimumOrderQuantityAndWithinGiftToleranceQty</h1>
                </header>
            
            <article>
                
<p>The main purpose of this helper function is to set and validate the quantity on the sales invoice line, so that, when it is smaller than the minimum order quantity on the gift campaign and everything is within the gift tolerance as defined in the setup, calling <kbd>Validate</kbd> will trigger the message.</p>
<p>Have a look at the following code:</p>
<pre>local procedure<br/>    SetQuantityOnInvoiceLineSmallerThanMinimumOrderQuantity<br/>        AndWithinGiftToleranceQty(<br/>            SalesInvoiceNo: Code[20]; NewQuantity: Decimal)<br/>var<br/>    SalesLine: Record "Sales Line";<br/>begin<br/>    with SalesLine do begin<br/>        SetRange("Document Type", "Document Type"::Invoice);<br/>        SetRange("Document No.", SalesInvoiceNo);<br/>        if FindFirst() then begin<br/>            Validate(Quantity, NewQuantity);<br/>            Modify();<br/>        end;<br/>    end;<br/>end;</pre>
<p>A very useful exercise before coding the <kbd>[THEN]</kbd> part is to run the test. In the case of this test, it will show us something that's very relevant. But before we do, we need to update the last details in our test function, as we haven't specified the various parameters when calling the helper functions. So, the following is what the new test codeunit has become:</p>
<pre>codeunit 60101 "Gifts PKT"<br/>{<br/>    // [FEATURE] Gifts<br/>    SubType = Test;<br/><br/>    [Test]<br/>    procedure AssignQuantityOnSalesLineToTriggerActive<br/>            PromotionMessage()<br/>    // [FEATURE] Gifts<br/>    var<br/>        Customer: Record Customer;<br/>        Item: Record Item;<br/>        SalesInvoiceNo: Code[20];<br/>    begin<br/>        // [SCENARIO #0010] Assign quantity on sales line<br/>        // [GIVEN] Packt setup with "Gift Tolerance Qty" set<br/>        CreatePacktSetupWithGiftToleranceQty(6);<br/>        // [GIVEN] Customer with non-blocked customer category<br/>        //         with "Free Gifts Available"<br/>        CreateCustomerWithNonBlockedCustomerCategoryWith<br/>            FreeGiftsAvailable(Customer);<br/>        // [GIVEN] Item<br/>        CreateItem(Item);<br/>        // [GIVEN] Gift campaign for item and customer category<br/>        /          with "Minimum Order Quantity" set<br/>        CreateGiftCampaignForItemAndCustomerCategory<br/>            WithMinimumOrderQuantity (<br/>                Item."No.", Customer."Customer Category Code_PKT",<br/>                10, 3);<br/>        // [GIVEN] Sales invoice for customer with line for item<br/>        SalesInvoiceNo :=<br/>            CreateSalesInvoiceForCustomerWithLineForItem(<br/>                Customer."No.", Item."No.");<br/>        // [WHEN] Set quantity on invoice line smaller than<br/>        //        "Minimum Order Quantity" and within<br/>        //        "Gift Tolerance Qty"<br/>        SetQuantityOnInvoiceLineSmallerThanMinimumOrderQuantity<br/>            AndWithinGiftToleranceQty(SalesInvoiceNo, 5);<br/>        // [THEN] Active promotion message is displayed<br/>        //VerifyActivePromotionMessageIsDisplayed();<br/>    end;<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the test</h1>
                </header>
            
            <article>
                
<p>So, let's run the test, even though it's not ready <span>yet</span><span>. As the screenshot demonstrates, there is an</span> <kbd>unhandled UI</kbd> <span>element,</span> <kbd>Message</kbd><span>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/23f13168-714a-49b0-afd0-2a71883895dd.png" style="width:63.92em;height:30.33em;"/></p>
<p>If we read the error message more closely, we see that it's the message that we wanted to evoke:</p>
<pre><em>Attention: there is an active promotion for item GL00000001. if you buy 10 you can have a gift of 3</em></pre>
<p>This shows us two things:</p>
<ul>
<li>We have successfully evoked the message.</li>
<li>We need to implement a so-called <kbd>MessageHandler</kbd> function.</li>
</ul>
<p>The following is what the simplest <kbd>MessageHandler</kbd> function looks like:</p>
<pre>[MessageHandler]<br/>procedure MessageHandler(Msg: Text[1024])<br/>begin<br/>end;</pre>
<p>This will handle the message; that is, it will mimic a user pressing the <strong><span class="packt_screen">OK</span></strong> button on the message dialog. Note that the name of this function doesn't need to be <kbd>MessageHandler</kbd>.</p>
<p>Having a <kbd>MessageHandler</kbd> function is not sufficient. It also needs to be bound to the test function that is triggering the message. This is done by setting the <kbd>HandlerFunctions</kbd> property of the test function as follows:</p>
<pre>    [Test]<br/>    [HandlerFunctions('MessageHandler')]<br/>    procedure AssignQuantityOnSalesLineToTriggerActive<br/>            PromotionMessage()<br/>    // [FEATURE] Gifts</pre>
<p>Running the test again demonstrates that it is successful now, but remember: <em>a test with no verification is no test</em>. The <kbd>MessageHandler</kbd> function could be triggered by any message. The last helper function we have to tackle, <kbd>VerifyActivePromotionMessageIsDisplayed</kbd>, needs to verify that our test did indeed evoke the right message.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">VerifyActivePromotionMessageIsDisplayed</h1>
                </header>
            
            <article>
                
<p>Let's leave something for you to discover. Go to GitHub and have a look at how this is implemented.</p>
<p><span>In this section, we have learned how to create automatic tests for your extensions according to your business scenarios. Automatic testing is absolutely a must-have with Dynamics 365 Business Central (it's mandatory for AppSource apps, but it's also a best practice to follow in general).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have discussed the basics of how to create automated tests in Dynamics 365 Business Central.</p>
<p>We utilized the ATDD test case pattern in order to design each test, and then used it as a base structure in our four-step recipe to create a test codeunit, embed the customer choice into a test, write a test story, and finally construct your real code. You should now be comfortable with writing tests for your extensions according to your business needs.</p>
<p>In the next chapter, we'll explore another important aspect to master when developing solutions for Dynamics 365 Business Central: source code management and DevOps practices.</p>


            </article>

            
        </section>
    </body></html>