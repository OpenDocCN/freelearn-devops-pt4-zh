<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Source Control Management and DevOps with Business Central</h1>
                </header>
            
            <article>
                
<p><span>Developing applications without using source code management is like driving without wearing a seat belt. Creating an app that must be supported for years and will be extended and modified to fit new requirements without knowing who wrote which code and why it was written is like going to the wilderness without a map and compass. Maybe you will manage to get through one day, but there will be nobody left with you.</span></p>
<p><span>By using Visual Studio Code to develop our app, we have all of the tools we need. </span>The tools are <strong>Git</strong> for source code management and <strong>Azure DevOps</strong> for managing your app development, which will tighten cooperation between development and operation.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Understanding Azure DevOps and what it offers</li>
<li>Managing tasks, sprints, and boards in Azure DevOps</li>
<li>Creating a repository for your code</li>
<li>Managing repositories</li>
<li><span>Branching policies</span></li>
<li>Branching strategies</li>
<li>Understanding Git merge strategies</li>
<li>Exploring Git with Visual Studio Code</li>
<li>Understanding Azure DevOps Pipelines</li>
<li>Understanding the YAML pipeline</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding Azure DevOps and what it offers</h1>
                </header>
            
            <article>
                
<p>Perhaps you have heard terms such as <em>Team Foundation Server</em>, <em>Team Foundation Service</em>, <em>TFS</em>, or <em>Visual Studio Team Services—</em>all of this is now <strong>Azure DevO</strong><strong>ps</strong>. You can find all that you need to develop your software in a team in Azure DevOps, such as the following:</p>
<ul>
<li><strong>Azure Pipelines</strong>: This provides CI/CD for any language, platform, and cloud. It looks like this:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"> <img src="assets/4c0dc6df-2476-4bf5-a532-a357452a50de.png"/></p>
<ul>
<li><strong>Azure Boards</strong>: This is the area where you can track your project activities by using Kanban boards, backlogs, team dashboards, and reporting. <span>It looks like this:</span></li>
</ul>
<p class="CDPAlignCenter CDPAlign"> <img src="assets/19644b93-c057-463d-94c1-ded0d05af54b.png"/></p>
<ul>
<li><strong>Azure Artifacts</strong>: This is a tool for saving and distributing packages. <span>It looks like this:</span></li>
</ul>
<p class="CDPAlignCenter CDPAlign"> <img src="assets/8901dfeb-f1cc-4fb2-9f1c-1f03436a718b.png"/></p>
<ul>
<li><strong>Azure Repos</strong>: This has cloud-hosted private and public Git repositories. <span><span>It looks like this:</span></span></li>
</ul>
<p class="CDPAlignCenter CDPAlign"> <img src="assets/126f9e00-6804-4ef0-acd4-8a7693966586.png"/></p>
<ul>
<li><strong>Azure Test Plans</strong>: This has tools for planned and exploratory testing. <span>It looks like this:</span></li>
</ul>
<p class="CDPAlignCenter CDPAlign"> <img src="assets/7124f58a-d242-47d1-862c-876767520493.png"/></p>
<p>Of course, you do not need to use all of the available tools. You can begin with Azure Repos, then add Azure Pipelines and connect all of this to Azure Boards.</p>
<p>Since you get five users for free, there is no cost associated with using these tools. And if your developers have MSDN subscriptions, they already have the license for Azure DevOps included. If this is not enough for you, you can buy additional licenses (from $6 per user per month—see <a href="https://azure.microsoft.com/en-us/pricing/details/devops/">https://azure.microsoft.com/en-us/pricing/details/devops/</a>).</p>
<p>If your company domain is connected to <strong>Azure Active Directory</strong> (<strong>AAD</strong>), you can manage access to Azure DevOps by using these accounts and groups. It means your users do not need another account just to work with all of this.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an Azure DevOps account and project</h1>
                </header>
            
            <article>
                
<p>On <strong>Azure DevOps</strong>, you can have multiple accounts. On each account, you can have multiple projects. When you create a new project with Azure DevOps, the resulting project URL will look like the following:</p>
<p><a href="https://dev.azure.com/myaccount/myproject">https://dev.azure.com/myaccount/myproject</a></p>
<p>Let's begin by creating a new account on Azure DevOps. You can choose whether you will use Microsoft accounts to access Azure DevOps or use your company's AAD accounts.</p>
<p class="mce-root"/>
<div class="packt_tip">If you use a personal account to create the Azure DevOps, you can transfer ownership to the company account later.</div>
<p>To create a new Azure DevOps account, follow these steps:</p>
<ol>
<li>Go to <a href="https://go.microsoft.com/fwlink/?LinkId=307137">https://go.microsoft.com/fwlink/?LinkId=307137</a> and sign in with your Microsoft or AAD account.</li>
<li>Read through and accept the Terms of Service, Privacy Statement, and Code of Conduct. Click <span class="packt_screen">Continue</span>.</li>
<li>If you have already used your account with Azure DevOps, you can create a new organization with the <span class="packt_screen">New Organization</span> button.</li>
<li>Enter the name of your organization and select the location to host your projects.</li>
<li>Now, you can create your first project. Select if it will be <span class="packt_screen">Public</span> (accessible by anyone) or <span class="packt_screen">Private</span> (accessible only by users you give access to).</li>
<li>You are now the owner of a new Azure DevOps account and project; congratulations! The following screenshot shows this:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/88cfb5c0-5638-49ae-a5e8-10e5142558bf.png"/></p>
<p class="mce-root"/>
<p>If you have access to multiple Azure DevOps accounts, you can freely switch between them and create projects in them, if you have permission.</p>
<p>By default, the new project will be using a <strong>Git</strong> repository and an <strong>Agile</strong> work item process template. You can change the process to <strong>Scrum</strong> if you prefer product backlog items to user stories and impediments to issues (among other differences, which are described at <a href="https://docs.microsoft.com/en-us/azure/devops/boards/work-items/guidance/choose-process">https://docs.microsoft.com/en-us/azure/devops/boards/work-items/guidance/choose-process</a>).</p>
<p>You can create a project per product/customer, or you can use one project for everything and use other tools to group things together per product/customer. It depends on whether there are separate groups working on the projects or you are sharing resources between projects.</p>
<p>I recommend starting with one project where you have one backlog (queue) for prioritizing the work for the team. If you have two queues or two separate teams, you can use separate projects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing tasks, sprints, and boards in Azure DevOps</h1>
                </header>
            
            <article>
                
<p><strong>Azure DevOps</strong> is an essential tool for managing Dynamics 365 Business Central projects, starting from the very early stages of the project. By using the <span class="packt_screen">Boards</span> feature, you can start managing your project's tasks, features, bugs, and general activities in a centralized way.</p>
<p>In your Azure DevOps project, if you click on <span class="packt_screen">Boards</span>,<span class="packt_screen"> </span>you get the following options:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f8c68a95-9e84-465f-922e-7d7dd8f77087.png" style="width:7.08em;height:16.33em;"/></p>
<p class="mce-root"/>
<p>Here is a brief description of the available options (we'll see them in detail later):</p>
<ul>
<li><span class="packt_screen">Work Items</span>: Here, you can manage the list of your activities (activities that are assigned to you or that you follow, or your team's activities).</li>
<li><span class="packt_screen">Boards</span>: <span>Here,</span> you can access your Board view.</li>
<li><span class="packt_screen">Backlogs</span>: <span>Here,</span> you can access your product backlogs are a list of work items that a project team plans to develop and deliver.</li>
<li><span class="packt_screen">Sprints</span>: <span>Here,</span> you can manage your project's iterations (in Scrum methodology, a sprint is normally defined as a period of not more than three weeks where tasks are grouped and must be completed).</li>
<li><span class="packt_screen">Queries</span>: This is an area where you can set up your queries to find and list work items.</li>
</ul>
<p>As a project manager, the first thing you can do is to select <span class="packt_screen">Backlogs</span> and create a product backlog for your project (a product backlog corresponds to your project plan—the roadmap that your team plans to deliver).</p>
<p>Here, you can create phases and work items (tasks, bugs, and so on) and assign tasks to your team's users. The following screenshot shows this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/86129be1-7047-440e-882d-bfcbdd7e4da1.png"/></p>
<p class="mce-root"/>
<p>In the following screenshot, we have defined some work items whose type is <span class="packt_screen">Product Backlog Item</span>. These items correspond to a group of activities. Under each of these <span class="packt_screen">Product Backlog Items</span>, we have the corresponding tasks. Each task has its own <strong>state</strong> (<span class="packt_screen">To Do</span>, <span class="packt_screen">In Progress</span>, or <span class="packt_screen">Done</span>), a description, and an associated priority:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f2a7e0a7-95b9-46ff-a7df-8a8619c51ec5.png"/></p>
<p>On the right-hand side of the <span class="packt_screen">Backlog </span>page, you have the <span class="packt_screen">Sprint</span> panel.</p>
<p>According to the Scrum methodology, teams plan and track work at regular time intervals, referred to as a <em>sprint cadence</em>. You can define sprints to correspond to the cadence your team uses for your project.</p>
<p>In Azure DevOps, you can select a <strong>sprint</strong>, define the start and end date, and then assign activities from <span class="packt_screen">Backlog</span> to a specific sprint by dragging the activities (in the preceding screenshot, for example, I assigned the <span class="packt_screen">Customer Category Development</span> activity to <span class="packt_screen">Sprint 2</span>).</p>
<p class="mce-root"/>
<p>After scheduling activities and sprints for your project, there are also some other interesting views available. If you click on <span class="packt_screen">Work Items</span>, you can see the work items status (such as the work items assigned to you, all work items, and recently created work items):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/efae64a6-c3a1-48c8-b80d-f7b81b2a601e.png"/></p>
<p>If you click on <span class="packt_screen">Boards</span>, you can have a board of your project (a view of your project's tasks as a card ordered by status; you can <span>drag and drop </span>tasks to change their status):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3b0c73ab-5195-4a68-a99f-32ad3e2efa9a.png"/></p>
<p>If you select <span class="packt_screen">Sprints</span>, you can see details of every sprint (iteration path) defined in your project. Here, you can have a <span class="packt_screen">Taskboard</span> view and you can see the sprint backlog and capacity:</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0fc64d6c-0f37-47fa-a716-87938d2acfcc.png"/></p>
<p>From here, you can monitor the progress of every sprint and the activities associated with every task.</p>
<p>On the <span class="packt_screen">Queries</span> page, you can define custom queries to retrieve work items. Here, I've defined a query to immediately see all tasks declared as completed in my project:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a7596d60-4315-4f5f-9dcd-4505404f28b1.png"/></p>
<p>When executed, the query returns the desired results (which can be viewed in different formats):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/603b2c19-214c-42ef-9b15-b1234644edb2.png"/></p>
<p class="mce-root"/>
<p>Another interesting feature is what is called the <span class="packt_screen">Delivery Plans</span>. <span class="packt_screen">Delivery Plans</span> display work items as cards along with a timeline or calendar view. It is very useful to see expected release dates or delivery dates for your team's activities. </p>
<p><span class="packt_screen">Delivery Plans</span> is not a standard feature, and to get it, you need to download and install an Azure DevOps extension from the Marketplace (click on the bag icon in the top-right corner of your page). The extension is shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0d76ccf7-8f5c-4c73-8dd7-225c0fea6de7.png"/></p>
<p>When it's installed, you have a new menu called <span class="packt_screen">Plans </span>on the left and, if you click on it, you can see your project delivery plan in a timeline:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/59b981a6-ebf3-412f-a7ff-8ded0a0051e5.png"/></p>
<p>The coolest part is that all of these project management features are available in a single tool and are totally integrated with the development tools you use every day (such as Visual Studio Code). In Visual Studio Code you can, for example, commit your code and attach the commit to a task assigned to you. In this way, you have a complete product life cycle and a project manager can check what code modifications have been made to develop or solve a particular task or problem.</p>
<p>For example, if we select the <span>completed </span><span class="packt_screen">Customer Category development</span> task and click on <span class="packt_screen">Links</span>, we can see all of the task's details. In particular, with the <span class="packt_screen">History</span> link, we can see the entire history of the tasks:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0b41e438-b7fb-433f-9cc2-40fd6fb9563e.png"/></p>
<p class="mce-root"/>
<p>If we click on <span class="packt_screen">Links</span>, we can see all of the commits related to this task. Here, we can see that, for this task, we have three commits and a pull request:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fa66cca1-43e4-4913-9544-ca854510d65c.png"/></p>
<p class="NormalPACKT"><span>If you select a particular commit, you can see the details of the code modifications:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f61199ab-c56a-4928-bd3d-e58c76430ff7.png"/></p>
<p class="NormalPACKT"><span>As you can see, you have complete control over all of the aspects of your project from a single portal and a unified interface.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a repository for your code</h1>
                </header>
            
            <article>
                
<p>Repositories are there to keep your source code safe, secure, and available when needed. Azure DevOps offers unlimited repositories. Having this secure store with unlimited space for free is a great way to calm your nerves if a <span>notebook is </span>stolen or hardware breaks. And you can access it from everywhere; no is VPN needed. Additionally, you can easily connect the changes to requirements (work items) to find out why something was done and by whom.</p>
<p>To create a new repository, follow these steps:</p>
<ol>
<li>Go to the <span class="packt_screen">Repos</span> section of Azure DevOps.</li>
<li>Expand the repository selection at the top (you can manage existing repositories, import repositories, or create a new one).</li>
<li>Select <span class="packt_screen">New Repository</span>.</li>
<li>Enter a name.</li>
<li>Click <span class="packt_screen">Create</span>.</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="NormalPACKT"><span>In a while, your new repository is available, and the main page gives you all of the information you need to fill the repository with your code. The following screenshot shows this:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d0a773c5-6c39-4108-a6ea-566773002e17.png"/></p>
<p class="NormalPACKT"><span>In the main page of the repository we've just created, you have links for the following features:</span></p>
<ul>
<li>Clone to your computer: You can use the project's URL with Git to clone the repository, or click <span class="packt_screen">Clone in VS Code</span> to open Visual Studio Code (or some other supported development tool), select the target folder, and let Visual Studio Code clone the repository to your local disk. Then, you can fill it with your source code as you wish.</li>
<li>Push an existing repository from the command line: Copy the commands, go to your local repository, and run the commands, and your local repository will be connected to this new Azure DevOps repository and will be pushed into it.</li>
<li>Import a repository: If you have a Git repository somewhere else and you want to import it, just enter the URL and the current state will be imported.</li>
<li>Initialize with <kbd>README</kbd> or <kbd>gitignore</kbd>: If you want, just create <kbd>README</kbd> with a project description or just a <kbd>.gitignore</kbd> file and you will fill the repository later with something else. </li>
</ul>
<p>Next, let's see how to manage repositories.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing repositories</h1>
                </header>
            
            <article>
                
<p>In each repository you create, you can set multiple settings. We will go through the most interesting ones. You can manage repositories by clicking on <span class="packt_screen">Project Settings | Repos | Repositories</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6382c3b3-9f58-4a62-9003-3a4764483e66.png"/></p>
<p>On the repository's settings page, we can manage the main settings, which we'll see in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Security</h1>
                </header>
            
            <article>
                
<p>You can assign groups and set permissions for all repositories and refine them for each repository and even per branch or tag as needed. I recommend to check which users can do the following:</p>
<ul>
<li>Delete the repository</li>
<li>Force push (this could rewrite the history in the repository)</li>
<li>Create a repository</li>
<li>Bypass policies</li>
</ul>
<p>If you set the right settings, you can prevent the loss of your code.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Options</h1>
                </header>
            
            <article>
                
<p>On all Git repositories and each separate repository, you can set the following things:</p>
<ul>
<li><strong>Cross-platform compatibility</strong>: This ensures that the settings are set to prevent problems with file/folder names that differ only by case. Git is case-sensitive and will allow the developer to add <kbd>File.txt</kbd> and <kbd>file.txt</kbd> as two separate files. But Windows and iOS are case-insensitive and will have problems in this regard. A best practice is to be consistent in naming and not to create such a file. Enabling the options in the repository will force developers to keep the names unique. And because even tags and branches are files internally in Git, the conflict could exist even in tag and branch names.</li>
<li><strong>Forks</strong>: If you do not want to allow users to create forks from the repository, you can disable this function. A fork is a copy of the repository that maintains a connection to the original repository. A developer can create a pull request to transfer changes from one repository to another, using forks. It is using the fact that Git is a distributed system and one repository can exist in multiple places (multiple servers or multiple repositories on one server<span>—</span>it doesn't matter).</li>
<li><strong>Work item management (per repository)</strong>: Keep this enabled to be able to connect your commit to existing work items. In this way, you will have information about what was done for each requirement, and you will <span>even </span>be able to say which changes are part of each build or release of your application. This could help you to create a change log for each version.</li>
<li><strong>Code search branches (per repository)</strong>: You can select up to five branches per repository to be indexed for code search. The files from these branches will be searchable by the search function of Azure DevOps. Just enter the text you want to search for and Azure DevOps will quickly find it in all your repositories. It's a very handy tool.</li>
<li><strong>Branching Policies (per branch)</strong>: See the <em>Branching policies</em><strong> </strong><span>section.</span></li>
</ul>
<p>Let's see these branching policies in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Branching policies</h1>
                </header>
            
            <article>
                
<p>To maintain the quality of your app, you can define policies that must be met before changes from the developer can be integrated into the selected branch.</p>
<p class="mce-root"/>
<p>Mostly, the policy is defined on the <em>master</em> branch, but it could be any branch you want to keep healthy. If you define the policy for a branch, changes cannot be pushed into this branch directly, but only through Pull Requests (PRs). See the <em>Pull request</em> section for more details. In this way, each change is checked and tested, and if the policy is not met, the change will not make it into the branch. You can define the following in the policy:</p>
<ul>
<li><strong>The minimum number of reviewers</strong>: This is how many reviewers must approve the PR to be accepted.</li>
<li><strong>Check for linked work items</strong>: This forces developers to associate the PR with work items to have links between requirements and changes.</li>
<li><strong>Check for comment resolution</strong>: If the reviewer wrote some comment, the comment must be resolved before the PR is accepted.</li>
<li><strong>Enforce a merge strategy</strong>: You can prohibit a fast-forward merge (you lose some detail but gain simplicity) or enforce a squash merge, which will condense all commits from the developer into one new commit on the target branch.</li>
<li><strong>Build validation</strong>: You can define a build pipeline that will be used to build and test the changes. If the build succeeds, the PR could be accepted. Failing the build may prevent the PR from being accepted (optional behavior). In this way, you can keep the branch healthy.</li>
<li><strong>Automatically include code reviewers</strong>: This defines user groups or users that will be used as reviewers by default. Reviewers could be chosen by specific changes, for example, when a script file or the settings of the app are changed, the responsible person will be added as a reviewer automatically.</li>
</ul>
<p>Some developers tend to view branching policies as just additional hurdles in their way, but it is a great opportunity to grow your team and improve the quality through the reviews. It gives the team a chance to learn from each other and teach themselves new things. And additional eyes on the code are always good.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Branching strategies</h1>
                </header>
            
            <article>
                
<p>We have set the policies for branches to make rules and technical checks, but the question is, how swap use branches in Git to support your work? Which strategy should you use? When should you create a new branch? When should you merge <span>branches?</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>There are plenty of strategies you can use, and there is no silver-bullet solution. The best strategy for your team could be different for another team, or you may have one strategy for your <strong>AppSource</strong> app and another for your <strong>PerTenant</strong> app.</p>
<p>Before you decide which way you will go, think about the <strong>KISS principle</strong> (<strong>Keep It Simple, Stupid</strong>).</p>
<p>In all of the examples in this chapter, we will consider the master branch the most stable one, the one that represents the app as it is released to production. You can decide to name this branch differently and it has no impact on the strategies themselves. You just need to define the name and make it consistent through the team. Let's go through the branches in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Only a master branch</h1>
                </header>
            
            <article>
                
<p>Having one branch is the simplest strategy you can use. If you have only one developer working on the app, there is no need to create a branch. Even when there are more developers, they could still work on one branch, merging their changes into it each time they conflict. But it is hard to keep the product stable because half-done changes could be pushed into the branch:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/43a2e748-3e32-44c1-aa9f-6e2fbc307f27.png"/></p>
<p><span>To stabilize the app, you will need to pause development. Still, you can change the strategy to something else later, when you see the need for it.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Feature/developer branches</h1>
                </header>
            
            <article>
                
<p>To isolate changes for one feature or one developer, you can create a branch for each feature or developer. In this way, the developers are working on their own branches, with no conflicts with others until they hit a point when their work is done, and they then integrate the changes back into the master branch.</p>
<p>After the feature is finished and integrated back to the master branch, the feature branch can be deleted. If the branch is per developer, you can expect that the branch will live a long time. This could be a problem from a long-term point of view. The following diagram depicts this:</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="assets/02a47d18-3809-46fb-817d-b3e2ffa3cd49.png" style="width:41.33em;height:14.50em;"/></p>
<p>Using one branch per developer will mix different changes for different features together, and it could be a problem to release only selected features later in the process.</p>
<p>Using branches per feature gives you the possibility to release only selected features or cancel feature development for no cost (before it is integrated back into the master branch).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Release branching</h1>
                </header>
            
            <article>
                
<p>The next strategy is to create a branch for each release you are preparing. It gives you the ability to stabilize the product before release and isolate it from ongoing development:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0789341c-9221-44af-8b5a-c0b63ae86a39.png" style="width:39.08em;height:10.75em;"/></p>
<p><span>As we can see in the preceding diagram, it is good for apps going to AppSource because you can fix issues based on the AppSource validation procedure and the app will not be affected by new development in between. The fixes could be integrated back to the master branch at any time. </span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other strategies</h1>
                </header>
            
            <article>
                
<p>You can create a new branch even for servicing (if support for the released version is done by another team and is long-term, for example, when creating service packs), or per hotfix, when creating the hotfix takes a long time and you need to isolate it from the release and development.</p>
<p>As you can see, the only purpose of the branch is to isolate changes in it from other changes done for a different purpose in case you need to keep it isolated for a long time.</p>
<p>Every strategy can be combined with the others, and in this way, you can create your own strategies based on your needs. One of these combinations is named <kbd>Git flow</kbd>, and we will explore it next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Git flow</h1>
                </header>
            
            <article>
                
<p><strong>Git flow</strong> is a workflow that uses feature branching together with bug and release branching. It is widely used, and you can <span>even </span>find tools that support this flow by automating different parts of it. In Git flow, the master branch represents the released versions, that is, each commit in it represents a released version of the product.</p>
<p>The second branch is the development branch, and it serves as the integration branch for feature branches that are created from it for each feature that is developed.</p>
<p>When a new release is prepared, a new release branch is created from the development branch. On the release branch, stabilization and fine-tuning is done until the version is ready for release. The release is finished by merging the release branch with the master branch.</p>
<p>If there is a bug in the released version, a new bug fix branch is created from the master branch. All fixes are made in this branch, and it is then integrated back into the master branch (creating a new fixed version of the app) and into the development branch (to keep the bug fix for the next releases).</p>
<p class="mce-root"/>
<p>The following diagram depicts this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/31223925-853c-4063-bd72-d21e5f33da78.png" style="width:34.33em;height:19.33em;"/></p>
<p><span>This flow is suitable for developing apps for AppSource because the release can be isolated and you can support multiple versions of the app easily.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GitHub flow</h1>
                </header>
            
            <article>
                
<p>GitHub flow is a workflow used for development on GitHub. It is based on two rules:</p>
<ul>
<li>Everything in the master branch is releasable at any time.</li>
<li>Release could be done at any time, even multiple times per day.</li>
</ul>
<p class="mce-root"/>
<p>It is basically feature branching. Bug fixing is done like with the development of <span>any other </span>feature:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f0b511d3-3aff-40bc-8e02-0a6e3e287d87.png" style="width:34.08em;height:11.58em;"/></p>
<p class="mce-root"/>
<p><span>As we can see in the preceding diagram, it requires an automated release of the product, and hence, it could be applicable only for </span>PerTenant <span>or </span>OnPrem <span>apps in Business Central. AppSource has a long release time, and hence the flow is not suitable for it. It even assumes that only one version of the product is released, which is not true in the case of AppSource.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Branching considerations</h1>
                </header>
            
            <article>
                
<p class="NormalPACKT"><span>You can use multiple branching strategies in your company because each one is suitable for a different situation. But do not forget KISS! Having a complicated strategy that brings nothing to the team only leads to shortcuts and teams not sticking to the rules. Having one branch is a strategy too. Start with it and add other branches as needed. The strategy can grow with your team.</span></p>
<p class="NormalPACKT"><span>For AppSource development, you can use any strategy, but the most suitable is Git flow because it allows you to separate each release and support multiple versions. Do not forget that apps on customer tenants are only automatically updated on major releases or when needed because of the presence of a critical bug (this occurs after a partner's request). It means multiple versions can live in the cloud together.</span></p>
<p class="NormalPACKT"><span>For</span> PerTenant <span>app development, because in this case, you have only one version of the product released to the customer tenant, you can use any strategy, including GitHub flow.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding Git merge strategies</h1>
                </header>
            
            <article>
                
<p>We will not go deep into all of the possibilities of the <kbd>git merge</kbd> command, but we will explain some of the terms used in connection with Git and merging.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fast-forward merge</h1>
                </header>
            
            <article>
                
<p>When you merge two branches in Git, and one branch is a subset of the commits of the other, the result will be a <strong>fast-forward merge</strong>, where no merge is done at all. Consider the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1a9295f0-78d7-45af-8afc-c27bf79fe0e4.png" style="width:35.17em;height:32.25em;"/></p>
<p><span>The branch will reset to a new position.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Squash commit</h1>
                </header>
            
            <article>
                
<p>Using <strong>squash commit</strong> can help you to keep the branch clean and simple. When you want to merge one branch to another, by using squash commit, you can join the commits in the branch into new one commit, with a new commit message, and connect this new commit to the target branch. The following diagram shows this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7d852665-29fe-4e46-a8e0-9be0ffb4eff6.png" style="width:33.33em;height:25.67em;"/></p>
<p><span>There will be no real merge between the branches. You just throw away the old branch because all changes are now committed to the target. You will lose detail but gain simplicity. It depends on what your priority is.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rebase</h1>
                </header>
            
            <article>
                
<p>Instead of <kbd>merge</kbd>, you can use the <kbd>rebase</kbd> command. As the name suggests, you take the branch, cut it from the tree, and rebase it on another commit. In this way, you can base your changes on the new version without merging. <span>The following diagram shows this:</span></p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7094ca8b-0b60-422f-a36d-122fbcb520fb.png" style="width:42.08em;height:28.00em;"/></p>
<p><span>All of the commits between the original base and the branch head (the starting point of a branch) will be taken and reapplied to the new base. Again, you gain simplicity, but you lose reality because you are influencing the history.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Git merge considerations</h1>
                </header>
            
            <article>
                
<p class="NormalPACKT"><span>When you need to integrate the changes back to the target branch, you can choose whether you will use fast-forward merges, merge or rebase, or use squash commit. By combining the techniques, you can have a simple history in Git, but you can lose the required detail. But again, do not be afraid of having choices. Just start with the simplest way, and you can change the rules later if you think that it will help.</span></p>
<p>Next, let's move on to see how we can use Git from Visual Studio Code.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring Git with Visual Studio Code</h1>
                </header>
            
            <article>
                
<p><strong>Git</strong> is the default SCM system for Visual Studio Code, and you can execute the basic Git tasks (such as push, pull, fetch, and clone) from the <span>Visual Studio Code</span> GUI. You can also benefit from installing extensions that will enrich the integration.</p>
<p>I recommend these extensions:</p>
<ul>
<li><strong>Azure Repos</strong>: Connects to the Azure DevOps repository, including work items and build pipelines</li>
<li><strong>GitLens</strong>: Adds different views to Git history, such as blame functionality</li>
</ul>
<p>Let's see what Git has to offer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visual Studio Code GUI for Git</h1>
                </header>
            
            <article>
                
<p>Visual Studio Code offers a totally integrated experience with Git and SCM. Here's the <span>Visual Studio Code interface:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3c2eaefc-b74d-4d66-998f-5f162ce5d1ff.png" style="width:47.33em;height:30.58em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The numbers on the left-hand side<span> of the screenshot represent the following details:</span></p>
<ol>
<li class="NormalPACKT"><span>Current branch: If you click on this, you can create a new branch or check out another existing branch.</span></li>
<li class="NormalPACKT">Status of the repository: We are in sync with the remote repository. If not, you can see the number of incoming and outgoing commits of the current branch. By clicking on them, you will perform synchronization, that is, fetch and merge with the remote repository.</li>
<li class="NormalPACKT">The name of the project in Azure DevOps (Azure Repo extension): Clicking this will open the Azure DevOps portal.</li>
<li class="NormalPACKT">The number of pull requests (Azure Repo extension): Clicking on this allows you to select and browse pull requests.</li>
<li class="NormalPACKT">Last build status (Azure Repo extension): Clicking on this opens the last build for the repository.</li>
<li class="NormalPACKT">The number of work items (Azure Repo extensions): Clicking on this allows you to browse the work items and open them in the web portal.</li>
<li class="NormalPACKT">Source control activity bar: You can see the number of changed files. You can switch the activity to source control, where you can commit the changes.</li>
<li class="NormalPACKT">Commit message textbox: Enter the commit message before you commit the changes.</li>
<li class="NormalPACKT">List of changes: You can select which changes you want to undo or stage for committing. If you double-click on this, you can open the diff window, which shows you the differences between the current and the last committed state.</li>
<li class="NormalPACKT"><span class="packt_screen">Source Control</span> menu: You will find more commands regarding source control here.</li>
</ol>
<p>After this, let's explore the Git/Visual Studio Code workflow.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Workflow with Git</h1>
                </header>
            
            <article>
                
<p>When working with Visual Studio Code and Git, this is the common workflow you have:</p>
<ol>
<li>The first step is to get the repository in which you want to work into your local system.</li>
<li>If you want to work on existing code, you need to have the URL of the remote repository. Then, you can use the <kbd>Git: Clone</kbd> command, enter the URL, and select the folder where the repository will be cloned (it will be cloned into a subfolder with the name of the repository).</li>
<li>If you are creating a new app, you can first create the folder, open it in Visual Studio Code, create the basic structure (using <kbd>AL: GO!</kbd> or another command), and then use <kbd>Git: Initialize Repository</kbd> to make the folder into a Git repository. Later, you can connect the local repository to some new remote one by using Command Prompt. See the <em>How to create a repository for your code </em><span>section</span>.</li>
<li>Check out existing branches or create a new branch on which you want to do your development. You can do this by clicking the branch button at the bottom. Do not forget to check that you are working on the correct branch.</li>
<li>After you make some changes, go to the <strong>Source Control Activity Bar</strong> (press <em>Ctrl</em> + <em>Shift</em> + <em>G</em> for Git), write a meaningful message (such as <kbd>My first commit</kbd>), and commit the changes (click on the checkmark over the message or press <em>Ctrl</em> + <em>Enter</em>). If you haven't staged some changes (selected a changed file in the changes list and moved it into staged changes), Visual Studio Code will ask you whether you want to commit all changes instead. I recommend going through the changes and manually checking and staging them, because fixing something that has already been committed is not simple or nice. By staging changes, you can select a subset of all of the modifications that will be committed. You can stage/unstage even on the line level if you open the diff window, right-click on the lines, and select <span class="packt_screen">Stage/Unstage Selected Ranges</span>. In this way, you can split your changes to separate commits if they, for example, are related to different requirements.</li>
</ol>
<p> </p>
<ol start="6">
<li>If you want to undo the changes, just click <span class="packt_screen">Discard Changes</span> in the changed line.</li>
<li>After you have committed the changes and you want to make them available for others, you can click on the <strong>Synchronize</strong> button at the bottom of the window and it will push the commit to the remote repository (and pull changes from the remote repository if there are any). This is what the button looks like:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/599ef93d-f14b-4edd-a9aa-0cef589b2d06.png"/></p>
<ol start="8">
<li>If you want to merge your changes into the development branch (or any other branch you are not responsible for), create a pull request in the Azure DevOps portal. You can go there through the <span class="packt_screen">Browse your pull request</span> option when you click on the <span class="packt_screen">Pull Request</span> button in the status bar (number 4 in the <em>Visual Studio Code GUI for Git</em> section). If you need to fix something, for example, because there is conflict during the pull request, just make the change, commit, and push, and the pull request will be updated with the new commit automatically.</li>
<li>If everything is in the remote repository and a change is merged, you can just delete the folder on your disk if you do not need it anymore.</li>
</ol>
<p>It is a good practice to make some rules about what the commit message should look like, to be consistent through the company. Mastering the skill of writing good commit messages should be part of every developer's continuous improvement. You can refer to work items by writing <kbd>#1234</kbd>, where 1234 is the ID of the work item. You can find some examples and rules on the internet about how to write good Git commit messages. Here's an example:</p>
<div>
<pre>Fix error "Value is incorrect" in Sales posting<br/>Error text was changed to give more context to user and<br/>in some cases, solved by finding correct value automatically.<br/>Fix bug #1234<br/>Related to #1258</pre></div>
<p>You can create a new branch directly from a work item in Azure DevOps by clicking on <span class="packt_screen">Create a new branch</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/683cb346-cd35-4fb0-b3a8-02857d2a12cb.png"/></p>
<p><span>In this way, the branch will be connected to the work item and everybody will know where the changes are developed. It is good when you are using the feature branching strategy.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Merges</h1>
                </header>
            
            <article>
                
<p class="NormalPACKT"><span>In some cases, you will need to merge changes from the remote repository with your local changes. In this case, after you sync your repository, you will have </span><span>a new section named <span class="packt_screen">MERGE CHANGES</span> </span><span>in the Source Control section (during normal development work there are <span class="packt_screen">CHANGES</span> and <span class="packt_screen">STAGED CHANGES</span> sections).</span></p>
<p class="NormalPACKT"><span>When you click on each line/file, Visual Studio Code will open an editor window with the changes, and you can accept the changes or manually correct them. After all of the conflicts are resolved, stage the changes and commit them into a new merge commit and synchronize (push) the changes to the remote repository.</span></p>
<p>After learning about Git, let's see how Azure DevOps Pipelines work.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding Azure DevOps Pipelines</h1>
                </header>
            
            <article>
                
<p>Because the life cycle of business case apps is short and the cadence with which you are deploying new versions should be much higher than in the past (before the AL era), you cannot build, test, and deploy the app manually.</p>
<p>To automate this part of the life cycle, you can use Azure DevOps Pipelines, which will build, test, and deploy for you. You feed the pipeline on one side with the source code you are producing, and at the other end, you have a tested application, which can be even automatically delivered or deployed. Right now, there are two <span>types of </span>pipeline:</p>
<ul>
<li><strong>Build</strong> pipeline: The input is the source code, and the output is the application and other artifacts.</li>
<li><strong>Release</strong> pipeline: The input is the output produced by the build pipeline, and the output is a tested application delivered or deployed to selected places.</li>
</ul>
<p>The plan is that there will be one multi-stage pipeline instead that will cover the whole process. Consider the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d881b4bc-688a-4335-89dd-6a1332749368.png" style="width:49.25em;height:27.42em;"/></p>
<p>During the build stage, you are working with the source code and producing the product/application and testing it. In general, running tests on an application doesn't require the application to be deployed somewhere. For Dynamics 365 Business Central, it differs, and you need to deploy the app to a server to be able to test it—whether you use containers for this or not doesn't matter.</p>
<p>In the release pipeline, you are trying to deliver or deploy the application to different environments (the current version, the next version, different localizations, a new environment, or an environment with the previous version to test upgrades of the data, for example), test it in the environment, and carry out other steps that you need to deliver/deploy the app. This allows you to be able to deliver or deploy the application any time you want with as little manual input as possible.</p>
<p><span>Everything related to the work items</span> you put into your commits or pull requests is transferred through the pipelines and, on each release, you can see all of the work items related to the release. This helps you to identify and describe the changes that are part of the specific version of your application, and the list could be automatically delivered with the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Agents</h1>
                </header>
            
            <article>
                
<p>Pipelines that you create must be executed somewhere. Execution is done by an application called an <strong>agent</strong>.</p>
<p>You can use hosted agents, which are maintained by Microsoft in Azure and run on different operating systems with different additional software (such as macOS, Ubuntu, and Windows 2019 with Visual Studio 2019). For these hosted agents, you have some free minutes that you can use for your Azure DevOps organization (you can see the amount in the <span class="packt_screen">Organization Settings</span> in the <span class="packt_screen">Billing </span><span>section</span>). But the use of these hosted agents is limited because you cannot install additional software.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>You can use your own agents if you want. This means that you can install and configure a small application somewhere on your own server. This application will connect through a RESTful API to Azure DevOps and will execute the tasks from the pipelines on your server. How to install the agent is described on the web portal when you click on the <span class="packt_screen">Download the agent</span> <span>button </span>in the <span class="packt_screen">Agent Pool</span> section in <span class="packt_screen">Settings</span>, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/395ca764-7b4d-45d7-b89a-c71ad7eb8a81.png" style="width:38.92em;height:42.92em;"/></p>
<p class="mce-root"/>
<p class="NormalPACKT"><span>Details on how to configure the agent and get the access token needed to authenticate the agent can be found if you click on</span> <span class="packt_screen">Detailed instructions</span><span> on the</span> <span class="packt_screen">Download agent</span> <span>page (<a href="http://go.microsoft.com/fwlink/?LinkID=825113">http://go.microsoft.com/fwlink/?LinkID=825113</a> ). Do not forget to run the agent as an administrator to be able to do what is needed when running tasks for Dynamics 365 Business Central.</span></p>
<p class="NormalPACKT"><span>Which agent will be used for executing the pipeline is determined by the Agent's capabilities (which you can set in the Agent Pools section) and by the required agent task capabilities (that you can set later on the agent tasks in the pipeline definition). It means that each run of the pipeline can be processed by another agent if there are multiple agents available with the same capabilities. After this, let's see how to create a build pipeline.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a build pipeline</h1>
                </header>
            
            <article>
                
<p>To create your first build pipeline, open the <span class="packt_screen">Pipelines</span> section of your Azure DevOps portal and click <span class="packt_screen">New pipeline</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/86796189-bebe-4763-bca1-57eccb12279a.png"/></p>
<p class="mce-root"/>
<p class="NormalPACKT"><span>Now you can choose the source of your code to build. To start with, we will use the</span> <strong>Classic Editor</strong><span>, which means we will create the pipeline manually, just to look at the different parts of the pipeline settings. Later, we will use <strong>Azure Repos Git</strong> to create the whole pipeline in one step from a YAML file.</span></p>
<p class="NormalPACKT"><span>After you click <span class="packt_screen">Use the classic editor</span>, you can select the source of the code (select</span> <span class="packt_screen">Azure Repos Git |</span> <span class="packt_screen">Team project</span><span>, then select the </span><span class="packt_screen">Repository</span><span> for the source code and the</span> <span class="packt_screen">branch</span> <span>from the repository itself). Select the correct values and click</span> <span class="packt_screen">Continue</span><span>.</span></p>
<p class="NormalPACKT"><span>Because there are no predefined pipeline templates for Dynamics 365 Business Central, we need to start with an empty job:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/85b9eaa7-02fb-416f-9a6e-8bd8afb3dcb7.png"/></p>
<p>Now you are in the pipeline editor, where you can add pipeline agent jobs, which represent separate steps of the pipeline you need to execute to build and test the application. On the right, you can see the parameters of the actual steps you select on the left.</p>
<p>In the parameters, you can use variables, which can be defined in the <span class="packt_screen">Variables</span> tab or can be defined by the system. You can find a detailed explanation of the variables in the documentation for Azure DevOps.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>To use a variable in the parameters of the task, use the <kbd>$(variablename)</kbd> syntax. To use it inside your PowerShell script, use the <kbd>$env:VARIABLENAME</kbd> syntax. <span>All of the variables that are accessible as environment variables are in uppercase</span>, with dots replaced with underscores.</p>
<div class="packt_infobox">Note the <span class="packt_screen">View YAML</span> <span>button</span>. It will be handy when we investigate YAML build pipelines.</div>
<p>When building applications for Business Central, you will mostly use the PowerShell task that can run existing scripts (for example, if they are part of the source code) or run inline defined scripts.</p>
<p>After you have defined all of the tasks you need, you can define the triggers for your new build pipeline. You can choose from the following:</p>
<ul>
<li><strong>Continuous integration</strong>: This will run each time a new commit is pushed to the server. Check the branch filter to only run the build for branches where you want to save computing time. You can even specify a filter for paths inside the repository, which must be changed to trigger your pipeline (for example, to not trigger it when <kbd>readme.md</kbd> is changed).</li>
<li><strong>Scheduled</strong>: The pipeline will be triggered automatically at a set time. You can choose to trigger it only when something changed from last time.</li>
<li><strong>Build completion</strong>: This triggers the pipeline when another pipeline completes. It can be handy when you have dependencies between apps to run builds of the app when the dependency was built.</li>
</ul>
<p>When all is ready and set, save the pipeline and try to run it. In most cases, you will need multiple runs and modifications before you get your first successful build.</p>
<p>Common build tasks will have these steps:</p>
<ol>
<li>Prepare the build environment (install scripts, download tools, create a Docker container, and so on).</li>
<li>Compile the app (download symbols, use <kbd>ALC.exe</kbd> to compile the app, and so on).</li>
<li>Install the app (publish and install it into the Docker container).</li>
<li>Run tests for the app and download the results.</li>
<li>Publish the test results (should be done even when the tests fail).</li>
</ol>
<p> </p>
<ol start="6">
<li>Publish the artifacts (push the app to the Azure DevOps store or a shared folder).</li>
<li>Clean up the environment (drop the Docker container, for example; this should be done regardless of whether failing steps exist in the pipeline).</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Variable groups and secure files</h1>
                </header>
            
            <article>
                
<p>When creating your pipelines, you mostly need to define values that are shared between builds (such as usernames, passwords, keys, and so on). For this, you can create <strong>Variable group</strong>. To define a new <span class="packt_screen">Variable group</span>, open the <span class="packt_screen">Library</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b0d8ecaa-8bb6-45a6-8c71-a673d91d5326.png"/></p>
<p>When creating the variable group, define the name and description. For better security, you can store your variables in an Azure key vault if you want, or you can just create variable name/value pairs and, on the password, just use the lock icon to hide the value. Additionally, you can define security for each variable group.</p>
<p>To be able to use the variables from a variable group, you need to link the group to your pipeline. Just open the editor, go to the <span class="packt_screen">Variables</span> tab and select variable groups, and use the <span class="packt_screen">Link variable group</span> button. After the group is linked, you can use the variables in your tasks.</p>
<p>If you need to use a certificate or another file in your build pipeline, you can store it in the library as a secure file. You can download such a file using the <span class="packt_screen">Download Secure File</span> task in your pipeline. In this way, the users do not need to have access to the file and the file does not need to be able to access network resources to be used. The process will download the file from Azure DevOps storage where it is secured.</p>
<p>Next, let's see what the YAML pipeline is.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the YAML pipeline</h1>
                </header>
            
            <article>
                
<p>In the previous section, we used the classic editor to create a pipeline to show you the different parts of the pipeline and to give you an idea of what the pipeline is. But creating a pipeline in the editor is not very convenient, and you cannot version the definition. This is why <strong>YAML pipelines</strong> exist. They have the same properties and parts as the classic pipelines but are defined by a YAML file as part of your source code. This means you can define <em>Pipelines as Code</em> (you can directly code a pipeline) and you can use all of the tools you are using to work with your code.</p>
<p>First, here's some information about <strong>YAML</strong>. YAML is a file syntax like XML and JSON, but it is primarily focused to be read by humans (XML and JSON are defined to be read by computers). This means that the syntax is easily understandable. Instead of artificial marks to give meaning, it uses indentation and symbols such as <kbd>-</kbd> for list items and <kbd>:</kbd> to separate names and values:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1232ddc2-0626-4411-bbda-f69d07ae40f3.png" style="width:21.00em;height:24.33em;"/></p>
<p>If you look at the example, you should be able to recognize the properties (the format is <kbd>name: value</kbd>), objects with properties (for example, <kbd>customer</kbd> in the preceding screenshot), and lists (<kbd>items</kbd> in the preceding screenshot) with objects.</p>
<p>By using YAML, you can define all of the parts of the pipeline you saw in the pipeline editor:</p>
<ul>
<li>Jobs and tasks with parameters and properties</li>
<li>Variables, including variable groups</li>
<li>Triggers</li>
</ul>
<p>If you created some pipeline in the editor, you can use the <span class="packt_screen">View YAML</span> button in the editor to see the YAML that defines the same thing as you have in the editor. In this way, you can start creating your YAML pipeline. Just create an <kbd>azure-pipelines.yaml</kbd> <span>file </span>in your project, put the pipeline description into it, and commit the file into your repository.</p>
<p>When you want to change something in the pipeline, change the YAML file, commit, and push. The pipeline will change automatically.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a YAML pipeline</h1>
                </header>
            
            <article>
                
<p>To create a pipeline based on a YAML file, go to the <span class="packt_screen">Pipelines | Builds</span> section and do the following:</p>
<ol>
<li>Click on <span class="packt_screen">New Pipeline</span>.</li>
<li>Select <span class="packt_screen">Azure Repos Git (YAML)</span>.</li>
<li>Select the repository.</li>
<li>Azure DevOps will autodetect the YAML pipeline file in the repository and open it.</li>
<li>Click on <span class="packt_screen">Run</span>.</li>
</ol>
<p>You are done. Your new pipeline was created! Wasn't it easy?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">YAML pipeline templates</h1>
                </header>
            
            <article>
                
<p>To make it more generic, you can use templates in your YAML pipeline. This means that you store the YAML file definitions for each task as separate files in a repository and you can refer to these templates from your YAML pipeline. The definitions are shared with all of the apps using them in their YAML pipeline, and if you need to fix something in the definition, you will fix it in one place. Of course, in this way, you can screw up all of your pipelines from one place. Be warned!</p>
<p>This is how you create the pipeline:</p>
<ol>
<li>Create a new repository for your templates.</li>
<li>Put the YAML files with the definitions of the tasks into it:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cf999ca4-f727-4216-8a41-8a8cda080e61.png"/></p>
<ol start="3">
<li>Add a reference to the repository to the YAML pipeline file:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/66d66345-fecc-46ad-8554-8b999bc4eca1.png"/></p>
<p style="padding-left: 60px">The reference parameters are as follows:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li><strong>Repository</strong>: The name as it is used in the YAML pipeline file</li>
<li><strong>Type</strong>: The source repository type</li>
<li><strong>Name</strong>: The repository name</li>
<li><strong>Ref</strong>: The branch or a reference to the version of templates to be used</li>
<li><strong>Endpoint</strong><span><span>: The name of the endpoint defined in the Azure DevOps Service connections section</span></span></li>
</ul>
</li>
</ul>
<ol start="4">
<li>Add a service connection with the same name as your repository into Azure DevOps <span class="packt_screen">Service connections</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5d5dae3c-a9d6-4dba-be2a-de857338314a.png"/></p>
<ol start="5">
<li>Change the YAML file to reference these templates as the steps:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2ff68881-0438-42ca-87ee-4b4c4131a258.png" style="width:36.58em;height:7.25em;"/></p>
<p>In the YAML file, we have these references:</p>
<ul>
<li><strong>Template</strong>: The path and name of the file in the <kbd>@MSDYN365BC_Yaml</kbd> repository</li>
<li><strong>Parameters</strong>: The parameter values for the task</li>
</ul>
<p>All repository-specific settings should stay in your YAML pipeline file. All shared things such as step definitions should be in the template repository.</p>
<p>You can find the example for the template and pipeline file at <a href="https://github.com/kine/MSDYN365BC_Yaml">https://github.com/kine/MSDYN365BC_Yaml</a>.</p>
<p>To swap a new app using this template, you can clone the app as a template at <a href="https://github.com/kine/MSDyn365BC_AppTemplate">https://github.com/kine/MSDyn365BC_AppTemplate</a>.</p>
<p>Just for future reference, as a generic YAML pipeline for Dynamics 365 Business Central, you can also refer to the following YAML definition:</p>
<pre>variables:<br/> build.clean: all<br/> platform: x64<br/><br/>trigger: none<br/><br/>steps:<br/>- task: PowerShell@2<br/>  displayName: 'Install NAVContainerHelper module'<br/>  inputs:<br/>    targetType: filePath<br/>    filePath: 'BuildScripts\InstallNAVContainerHelper.ps1'<br/><br/>- task: PowerShell@2<br/>  displayName: 'Create a Docker Container for the build'<br/>  inputs:<br/>     targetType: filePath<br/>     filePath: 'BuildScripts\CreateDockerContainer.ps1'<br/>     arguments: '-credential ([PSCredential]::new("$(DockerContainerUsername)", (ConvertTo-SecureString -String "$(DockerContainerPassword)" -AsPlainText -Force)))'<br/><br/>- task: PowerShell@2<br/>  displayName: 'Copy Files to Docker Container'<br/>  inputs:<br/>    targetType: filePath<br/>    filePath: 'BuildScripts\CopyFilesToDockerContainer.ps1'<br/> <br/>- task: PowerShell@2<br/>  displayName: 'Compile extension stored in the repository'<br/>  inputs:<br/>    targetType: filePath<br/>    filePath: 'BuildScripts\CompileApp.ps1'<br/>    arguments: '-Credential ([PSCredential]::new("$(DockerContainerUsername)", (ConvertTo-SecureString -String "$(DockerContainerPassword)" -AsPlainText -Force))) -BuildFolder "$(Build.Repository.LocalPath)" -BuildArtifactFolder "$(Build.ArtifactStagingDirectory)"'<br/> failOnStderr: true<br/> <br/>- task: PowerShell@2<br/>  displayName: 'Publish extension'<br/>  inputs:<br/>     targetType: filePath<br/>     filePath: 'BuildScripts\PublishApp.ps1'<br/>     arguments: '-Credential ([PSCredential]::new("$(DockerContainerUsername)", (ConvertTo-SecureString -String "$(DockerContainerPassword)" -AsPlainText -Force))) -BuildArtifactFolder "$(Build.ArtifactStagingDirectory)"'<br/>    failOnStderr: true<br/><br/>- task: PublishBuildArtifacts@1<br/>  displayName: 'Publish Artifacts'<br/>  inputs:<br/>     PathtoPublish: '$(Build.ArtifactStagingDirectory)'<br/>     ArtifactName: FinalApp</pre>
<p><span>This pipeline model uses a set of PowerShell scripts that you can store in your repository  in a folder called </span><kbd>BuildScripts</kbd><span>. This can be stored together with your extension's files, as shown in the following screenshot:</span></p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e2ec1949-4356-4c78-9755-8f44a207ae71.png" style="width:73.42em;height:56.58em;"/></p>
<p class="mce-root"><span>If successfully executed, this pipeline publishes the final</span> <kbd>.app</kbd> <span>file for your Dynamics 365 Business Central extension as an</span> <span class="packt_screen">Artifact</span> <span>(output of the pipeline), which you can download from the build summary page.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Release pipeline</h1>
                </header>
            
            <article>
                
<p>After the <strong>build</strong> pipeline finishes, you can use the <strong>release</strong> pipeline to deliver or deploy the build artifacts or do other actions that you want. To create a new release pipeline, go to the <span class="packt_screen">Release</span> section and click on <span class="packt_screen">New Release pipeline</span>. Because there is no template for Business Central release pipelines, begin with an empty job.</p>
<p>Each release pipeline is created with the following:</p>
<ul>
<li><strong>Artifacts</strong>: This could be the output of the build pipeline, an Azure DevOps Git repository, a GitHub repository, a TFVC repository, an Azure artifact, an Azure container, a Docker Hub repository, or a Jenkins job.</li>
<li><strong>Stages</strong>: Each stage is a separate process that can be executed on different agents and can be triggered by different events.</li>
<li><strong>Variables</strong>: These are the same as in build pipelines.</li>
</ul>
<p>For each <strong>artifact</strong><em>,</em> you can define triggers to start the pipeline. It could be each time the artifact is updated (continuous deployment) or on a given schedule (such as nightly releases).</p>
<p>At each stage, you can set pre-deployment conditions and post-deployment conditions:</p>
<ul>
<li>Pre-deployment conditions: These include the following:
<ul>
<li>After release: This triggers when the selected artifact is deployed or on a given schedule.</li>
<li>After stage: This triggers when another stage is finished.</li>
<li>Manual only: Someone must trigger the deployment in the portal.</li>
<li>Pre-deployment approvals: Selected users must approve the deployment to this stage.</li>
<li>Gates: These are automated processes that can approve the deployment according to certain conditions (for example, when there are no errors after release to the previous stage).</li>
</ul>
</li>
<li>Post-deployment conditions: <span>These include the following:</span>
<ul>
<li>Post-deployment approvals: Selected users must approve that the release stage succeeded and that the release can continue.</li>
<li>Gates: Automated processes can approve the stage release.</li>
<li>Auto-redeploy trigger: You can trigger redeployment when needed; for example, after the stage fails, you can redeploy the last successful deployment. This could be useful for restoring to the last known working version.</li>
</ul>
</li>
</ul>
<p>Here's an example of a <strong>release pipeline</strong> for Dynamics 365 Business Central:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2c11b674-a11b-4702-bf75-4c4275ed8a3e.png"/></p>
<p>Each stage is deploying the app (and running tests) to a different version of the Business Central sandbox (the current version, the future version, and the master version). If everything is OK, the app is deployed to the QA environment for user testing. If the tests succeed, the app is signed by a certificate and stored on the server for later use (to be sent to AppSource) or is deployed to the target environment (a per-tenant app). This is what the YAML pipeline is about.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned what Azure DevOps is and what it provides, then created our account on Azure DevOps. We looked at how to manage and plan our work using Azure DevOps. We created a repository for our code and learned what we can set up to support our development cycle.</p>
<p>In the <em>Branching strategies</em> <span>section, </span>we learned how to use branches in our project to make the development stable and traceable. In the <em>Git merge strategies</em> and <em>Git in Visual Studio Code</em> sections, we looked at some specific aspects related to Git source control and how to use Git SCM from Visual Studio Code to keep our code safe.</p>
<p>We learned about Azure DevOps Pipelines, how to use them, and how to create them through the classic designer. In the last section, we looked at YAML files and how to use them to define our pipeline as part of our code.</p>
<p>In the next chapter, we'll go in depth into Dynamics 365 Business Central APIs and we'll explore how to create new APIs and use existing APIs to perform integrations.</p>


            </article>

            
        </section>
    </body></html>