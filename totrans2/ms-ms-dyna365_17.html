<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Serverless Business Processes with Business Central and Azure</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>In</span> <a href="2df1402e-b606-4d66-8ae6-13b8aa0fcb3e.xhtml"><span>Chapte</span><span>r 12</span></a><em><span>, Dynamics 365</span></em> <span><em>Business Central APIs</em>, we looked at an overview of the various APIs that are exposed by Dynamics 365 Business Central. We learned how to use them in our applications, as well as how to create our custom APIs.</span></p>
<p>In this chapter, we'll cover an important concept that arises when we architect business applications in a cloud environment: <em>serverless processing</em>. As you already know, with SaaS, you cannot use all the functionalities that are available in an on-premise environment (such as files and .NET DLLs), and, in a cloud environment, you need to rethink about these functionalities by using services that are provided by the cloud infrastructure.</p>
<p>In this chapter, we will learn about the following topics:</p>
<ul>
<li>An overview of the serverless functionalities offered by the Azure platform</li>
<li>Using Azure Functions with Dynamics 365 Business Central</li>
<li>Serverless processing scenarios with Dynamics 365 Business Central in real-world applications</li>
</ul>
<p>By the end of this chapter, you will have a clear understanding of how you can implement serverless processes with Dynamics 365 Business Central by using Azure Functions.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>In order to follow this chapter, you'll need the following:</p>
<ul>
<li>A valid Azure subscription (a paid subscription, or a trial subscription that you can activate for free at <a href="https://azure.microsoft.com/free/">https://azure.microsoft.com/free/</a>)</li>
<li>Visual Studio or Visual Studio Code</li>
<li>The Azure Functions extensions for Visual Studio or Visual Studio Code</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overview of Microsoft Azure serverless services</h1>
                </header>
            
            <article>
                
<p>Serverless technologies are key in the cloud world. They allow you to focus on your business application and your code instead of taking care of provisioning and managing resources, scaling, and, more generally speaking, handling the underlying infrastructure that's needed to run your apps.</p>
<p>Azure offers a full suite of managed serverless services that you can use as building blocks of your applications, and these services include compute resources, database, storage, orchestration, monitoring, intelligence, and analytics.</p>
<p>The Azure serverless offering can be grouped into the following categories:</p>
<ul>
<li>Compute:
<ul>
<li>Serverless functions (Azure Functions)</li>
<li>Serverless application environments (Azure App Service)</li>
<li>Serverless Kubernetes (Azure Kubernetes Service)</li>
</ul>
</li>
<li>Storage:
<ul>
<li>Azure serverless storage (Blob Storage)</li>
</ul>
</li>
<li>Database</li>
<li>Workflow and integration:
<ul>
<li>Azure Logic Apps</li>
<li>Azure API Management</li>
<li>Azure Event Grid</li>
</ul>
</li>
<li>Monitoring:
<ul>
<li>Azure Monitor</li>
</ul>
</li>
<li>Analytics:
<ul>
<li>Azure Stream Analytics</li>
</ul>
</li>
<li>AI and machine learning:
<ul>
<li>Azure Cognitive Services</li>
<li>Azure Machine Learning Service</li>
<li>Azure Bot Service</li>
</ul>
</li>
<li>DevOps:
<ul>
<li>Azure DevOps</li>
</ul>
</li>
</ul>
<p><span>The infrastructure that's </span><span>needed</span><span> </span><span>to handle your service is fully managed by Microsoft in its data centers around the globe. </span><span>You have these main three advantages when you use serverless processing in your applications with Azure:</span></p>
<ul>
<li><strong>You can scale your service as needed</strong>: You can scale a service in/out (add more instances or reduce the number of instances) or you can scale up/down a service (increase/decrease resources).</li>
<li><strong>Pay per use</strong>: You only pay for the time your code is running or for the resources you use when executing your code.</li>
<li><strong>Integrated security and monitoring</strong> features managed by the Azure platform.</li>
</ul>
<div class="packt_infobox">More information about the serverless offering provided by Azure can be found at <a href="https://azure.microsoft.com/en-us/solutions/serverless/">https://azure.microsoft.com/en-us/solutions/serverless/</a>.</div>
<p>Now that we've had an overview of Microsoft Azure Serverless services, let's look at an overview of Azure Functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting an overview of Azure Functions</h1>
                </header>
            
            <article>
                
<p><strong>Azure Functions</strong> is a service offered by Azure that provides functions as a service. You write code (in different languages) without worrying about the infrastructure, and your code executes in the cloud. With Azure Functions, you can run your code on demand (after a request to the function), on schedule, or automatically in response to different events.</p>
<p class="mce-root"/>
<p>You can write an Azure function directly via the Azure portal or you can develop it locally on your development machine. You can also debug and test an Azure function locally before deploying it to the cloud.</p>
<p>Azure Functions has the following key features:</p>
<ul>
<li>Develop in the language you are most familiar with or reuse your existing code in the cloud</li>
<li>Integrated security; you can specify what security you want to have and the platform will handle it</li>
<li>Scalability management; you can have service tiers according to your loads and usage</li>
<li>Pay-per-use pricing model</li>
</ul>
<p>At the time of writing, the following Azure function types are available:</p>
<ul>
<li><strong>HTTPTrigger</strong>: This is the classical function, where your code execution is triggered using an HTTP request.</li>
<li><strong>TimerTrigger</strong>: Your code is executed on a predefined schedule.</li>
<li><strong>BlobTrigger</strong>: Your code is executed when a blob is added to an Azure Blob Storage container.</li>
<li><strong>QueueTrigger</strong>: Your code is executed when a message arrives in an Azure Storage queue.</li>
<li><strong>EventGridTrigger</strong>: Your code is executed when events are delivered to a subscription in Azure Event Grid (event-based architectures).</li>
<li><strong>EventHubTrigger</strong>: Your code is executed when events are delivered to an Azure Event Hub (frequently used in IoT scenarios).</li>
<li><strong>ServiceBusQueueTrigger</strong>: Your code is executed when a message arrives in an Azure Service Bus queue.</li>
<li><strong>ServiceBusTopicTrigger</strong>: Your code is executed when a message for a subscribed topic arrives at the Azure Service Bus.</li>
<li><strong>CosmosDBTrigger</strong>: Your code is executed when documents are added or updated in a document collection stored in Azure Cosmos DB.</li>
</ul>
<p>Azure Functions has the following pricing plans:</p>
<ul>
<li><strong>Consumption plan</strong>: You pay for how long your code is being executed for in the cloud.</li>
<li><strong>App Service plan</strong>: You pay for the hosting plan, just like a normal web app. You can run different functions on the same app service plan.</li>
</ul>
<p class="mce-root"/>
<p>As we mentioned previously, direct usage of .NET DLLs (.NET variables in AL) is not available on the SaaS environment. Azure Functions is the recommended way to use .NET code with Dynamics 365 Business Central in a SaaS environment.</p>
<p>In the following sections, we'll look at the implementation of an Azure function that validates email addresses. We'll use this function to validate the email address associated with a customer record in Dynamics 365 Business Central. This function will be developed using Visual Studio and then Visual Studio Code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing an Azure function with Visual Studio</h1>
                </header>
            
            <article>
                
<p>To create an Azure function with Visual Studio, you need to have the Azure SDK tools installed. These tools can be installed directly when installing Visual Studio or later, by going to <a href="https://azure.microsoft.com/en-us/downloads/">https://azure.microsoft.com/en-us/downloads/</a>.</p>
<p>Now, follow these steps to learn how to develop an Azure function:</p>
<ol>
<li>With Visual Studio (I'm using the 2019 version), create a new project and select the <span class="packt_screen">Azure Functions</span> template:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4840e6bd-9ad4-481d-bccf-a66d5b29956f.png"/></p>
<p class="mce-root"/>
<ol start="2">
<li>Choose a name for your project (here, I'm using <span class="packt_screen">EmailValidator</span>), choose a location to save the project files in, and click <span class="packt_screen">Create</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e7543e69-8394-42ec-953a-29aa1c5b9d62.png"/></p>
<ol start="3">
<li>Next, you have to select the runtime version of your Azure function:
<ul>
<li><span class="packt_screen">Azure Functions v2 (.NET Standard)</span>: Based on .NET Core (cross-platform), this is the new available runtime.</li>
<li><span class="packt_screen">Azure Functions v1 (.NET Framework)</span>: Based on .NET Framework, this only supports development and hosting in the Azure portal or on Windows computers.</li>
</ul>
</li>
</ol>
<p style="padding-left: 60px">Here, I've selected Azure Functions v2 (.NET Core).</p>
<ol start="4">
<li>Then, you have to select the Azure function type (I selected <span class="packt_screen">Http trigger</span> because I want a function that can be called via HTTP) and for simplicity, I have selected <em>Anonymous</em> as the Access rights for our function (no authentication and everyone can use it; we'll talk about this in the <em>Managing Azure function keys</em> section of this chapter).</li>
<li>Now, click <span class="packt_screen">OK</span> to create the solution. This is the project tree that you will see in Visual Studio:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1cb717dc-d7aa-45b8-9ee8-49b957b989ff.png" style="width:24.17em;height:18.92em;"/></p>
<p>Here, you have the following files:</p>
<ul>
<li><kbd>host.json</kbd>: This file contains global configuration options that affect all the functions in your project. In our project, we have the runtime version (2.0).</li>
<li><kbd>local.settings.json</kbd>: This file contains the settings of your project.</li>
<li><kbd>EmailValidator.cs</kbd>: This is your function's source code (C#).</li>
</ul>
<p>Our function's implementation is quite simple. It receives an <kbd>email</kbd> parameter as input (via a GET or POST request), it validates the email address, and it returns a JSON response stating whether the address is valid or not (this is a custom object called <kbd>EmailValidationResult</kbd>).</p>
<p>The function code is defined as follows:</p>
<pre>[FunctionName("EmailValidator")]<br/>public static async Task&lt;IActionResult&gt; Run(<br/>    [HttpTrigger(AuthorizationLevel.Anonymous, "get", "post", Route = null)] HttpRequest req,<br/>     ILogger log)<br/>{<br/>     log.LogInformation("C# HTTP trigger function processed a request.");<br/>     string email = req.Query["email"];<br/>     string requestBody = await new StreamReader(req.Body).ReadToEndAsync();<br/>     dynamic data = JsonConvert.DeserializeObject(requestBody);<br/>     email = email ?? data?.email;<br/><br/>     //Validating the email address<br/>     EmailValidationResult jsonResponse = new EmailValidationResult();<br/>     jsonResponse.Email = email;<br/>     jsonResponse.Valid = IsEmailValid(email);<br/>     string json = JsonConvert.SerializeObject(jsonResponse);<br/><br/>     return email != null<br/>           ? (ActionResult)new OkObjectResult($"{json}")<br/>           : new BadRequestObjectResult("Please pass a email parameter on the query string or in the request body");<br/>}</pre>
<p>This function retrieves the <kbd>email</kbd> parameter from the input and calls the <kbd>IsEmailValid</kbd> function.</p>
<p>This function validates an email address by using the <kbd>System.Net.Mail.MailAddress</kbd> class, as follows:</p>
<pre>static bool IsEmailValid(string emailaddress)<br/>{<br/>    try<br/>    {<br/>        System.Net.Mail.MailAddress m = new System.Net.Mail.MailAddress(emailaddress);<br/>        return true;<br/>    }<br/>    catch (FormatException)<br/>    {<br/>        return false;<br/>    }<br/>}</pre>
<p>After email validation, the function creates an <kbd>EmailValidationResult</kbd> object with the response values, serializes it, and returns the JSON response. This <kbd>EmailValidationResult</kbd> object is defined as follows:</p>
<pre>public class EmailValidationResult<br/>{<br/>    public string Email { get; set; }<br/>    public bool Valid { get; set; }<br/>}</pre>
<p>Now that we've tested the function, it's time to publish it locally.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing the Azure function locally</h1>
                </header>
            
            <article>
                
<p>Visual Studio provides an emulator that we can use to test and debug our Azure function before deploying it to Azure. If you run the project, the emulator starts and you have a local URL to use for testing your function:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ed490f89-9772-48fb-b4f7-b06d4913814c.png"/></p>
<p>We can test our function by opening a browser and calling a URL, such as <a href="http://localhost:7071/api/EmailValidator?email=masteringd365bc@packt.com">http://localhost:7071/api/EmailValidator?email=masteringd365bc@packt.com</a>.</p>
<p class="mce-root"/>
<p>When invoked, the emulator shows the request details:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/83106311-74da-4e77-aca9-d2dfcc928a6d.png"/></p>
<p>We can see the JSON response in the browser. The previous call gives us the following response object:</p>
<pre>{"Email":"masteringd365bc@packt.com","Valid":true}</pre>
<p>If we call the function with a bad email address, such as <kbd>http://localhost:7071/api/EmailValidator?email=masteringd365bc</kbd>, we get the following response object:</p>
<pre>{"Email":"masteringd365bc","Valid":false}</pre>
<p>Our function is working correctly.</p>
<p>Now that we've tested the Azure function, we are ready to deploy it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying the function to Azure</h1>
                </header>
            
            <article>
                
<p>Now, we need to deploy our function to Azure. We can do this directly from Visual Studio, as follows:</p>
<ol>
<li>Begin by right-clicking on the project and selecting <span class="packt_screen">Publish...</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5beab55b-38ea-427e-bbdd-8c9166a9d486.png" style="width:25.92em;height:27.17em;"/></p>
<ol start="2">
<li>We need to choose an <span class="packt_screen">Azure App Service</span> to deploy the function to. To do this, we can select an existing one or create a new one. Here, I have created a new <span class="packt_screen">Azure App Service</span> instance for this function:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/765bb82d-5cee-4334-8032-598f93a7f1c8.png" style="width:41.75em;height:16.50em;"/></p>
<p class="mce-root"/>
<p style="padding-left: 60px">Click on <span class="packt_screen">Publish</span>. </p>
<ol start="3">
<li>After this, we select the <span class="packt_screen">Subscription</span>, a <span class="packt_screen">Resource Group</span> (create a new one or use an existing one), a <span class="packt_screen">Hosting Plan</span>, and a storage account to use for the deployment:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f058c639-82d9-422e-a27e-fbd2c1d555a3.png"/></p>
<p style="padding-left: 60px">Now, click <span class="packt_screen">Create</span> <span>– </span>our function (and all the associated resources) will be deployed to Azure.</p>
<ol start="4">
<li>Now, our function has been published on the Azure data centers and we have a public URL so that we can use it, as shown in the following screenshot:</li>
</ol>
<ul>
<li>
<p class="mceNonEditable CDPAlignCenter CDPAlign"><img style="font-size: 1em;text-align: center;color: #333333;" src="assets/9e48115e-fee4-4718-a23c-e575f6c64045.png"/></p>
</li>
</ul>
<p style="padding-left: 60px">In my example, the public URL is <a href="https://emailvalidator20190603055323.azurewebsites.net">https://emailvalidator20190603055323.azurewebsites.net</a> (you can customize it).</p>
<p>To test your function, use the following URL: <kbd>https://emailvalidator20190603055323.azurewebsites.net/<strong>api/EmailValidator?email=masteringd365bc</strong><strong>@packt.com</strong></kbd><strong>.</strong></p>
<p>The function now runs in the Azure cloud and you're ready to use it.</p>
<p><span>There is an alternative way of developing an Azure function that's extremely important for any Dynamics 365 Business Central developer. We'll take a look at this in the next section.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing an Azure function with Visual Studio Code</h1>
                </header>
            
            <article>
                
<p>To start developing Azure functions with Visual Studio Code, you need to install the following extensions:</p>
<ul>
<li><span class="packt_screen">Azure Account</span>, which you can download from <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.azure-account">https://marketplace.visualstudio.com/items?itemName=ms-vscode.azure-account</a>.</li>
<li><span class="packt_screen">Azure Functions</span>, which you can download from <a href="https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azurefunctions">https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azurefunctions</a>.</li>
</ul>
<p>You also need to install <span class="packt_screen">Azure Functions Core Tools</span>, a set of tools that allow you to develop and test your functions on your local machine.</p>
<div class="packt_infobox">You need to install the version that supports the Azure Functions runtime you're using. You can install this at <a href="https://github.com/Azure/azure-functions-core-tools">https://github.com/Azure/azure-functions-core-tools</a>.</div>
<p>To develop Azure functions with Visual Studio Code, follow these steps:</p>
<ol>
<li>The first thing you need to do is log into your Azure subscription by using the <span class="packt_screen">Azure: Sign In</span> command from the Visual Studio Code Command Palette:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1ec18be7-968c-4595-9c2f-af123e6c6cdf.png" style="width:37.08em;height:15.42em;"/></p>
<p style="padding-left: 60px">After entering your credentials, you will see <span>the account connected to your subscription </span>at the <span>bottom bar of </span>Visual Studio Code.</p>
<ol start="2">
<li>Now, on the Visual Studio Code sidebar, select the Azure Functions extension and click on the <span class="packt_screen">Create New Project</span> button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0d2e84b2-407e-4ef6-b2eb-3bb9572f2ee5.png" style="width:29.83em;height:34.33em;"/></p>
<p style="padding-left: 60px">Select a folder that you want to place your Azure Functions project in.</p>
<ol start="3">
<li>Then, you will be prompted to choose a language to develop your function in. From the list of supported languages, I've selected C#, as shown here:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9c3ee88c-e9ab-4521-bbfc-e45e78b492f8.png" style="width:55.33em;height:21.67em;"/></p>
<ol start="4">
<li>Next, you have to select either of the following runtime versions for your Azure function:
<ul>
<li><span class="packt_screen">Azure Functions v2 (.NET Standard)</span>: Based on .NET Core (cross-platform), this is the new available runtime.</li>
<li><strong>A</strong><span class="packt_screen">zure Functions v1 (.NET Framework)</span>: Based on .NET Framework, this only supports development and hosting in the Azure portal or on Windows computers.</li>
</ul>
</li>
</ol>
<p style="padding-left: 60px">Here, I've selected <span class="packt_screen">Azure Functions v2 (.NET Standard)</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/34fb3c07-942c-4653-b110-d12729c20e95.png"/></p>
<p class="mce-root"/>
<ol start="5">
<li>Now, set a name for your Azure Functions project (here, I've named it <kbd>EmailValidatorCore</kbd>):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/558b7f94-7f61-4c2d-b12e-e6676028c982.png"/></p>
<ol start="6">
<li>After naming the project, provide a namespace:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cb46ae58-b5a9-4b9e-955b-e3fba0dddad0.png"/></p>
<ol start="7">
<li>Now, you need to select the authentication type for your function. For simplicity, I've selected <span class="packt_screen">Anonymous</span> (everyone can call our function):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/33c9710b-dc04-4072-8c75-8d34eb61917f.png"/></p>
<ol start="8">
<li>Now, choose where to open the project that will be created (<span class="packt_screen">Current window</span>, <span class="packt_screen">New window</span>, and <span class="packt_screen">Add to workspace</span> are the available options).</li>
</ol>
<p class="mce-root"/>
<p>Visual Studio Code will start downloading the required packages for your Azure Functions project, and, when it's finished, a set of files will be created. The following is the template of your Azure function:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0c3edb55-182d-47a9-b2f1-66b9a9a1fd32.png"/></p>
<p>Here, you have the following files:</p>
<ul>
<li><kbd>host.json</kbd>: This file contains the global configuration options that affect all the functions in your project. In our project, we have the runtime version (2.0).</li>
<li><kbd>local.settings.json</kbd>: This file contains the settings of your project.</li>
<li><kbd>EmailValidatorCore.cs</kbd>: This is your function's source code (C#).</li>
</ul>
<p>Please note that you may have some temporary errors in your code (missing references). This occurs when Visual Studio Code needs to download all the .NET Core packages. To get the correct references, you need to execute the <span class="packt_screen">.NET: Restore Project</span> command from the Command Palette, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/17c61411-bb61-40a8-bcc5-0607d8ac99a5.png" style="width:34.58em;height:6.25em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Select the proposed option and click <span class="packt_screen">OK</span>, <span>as follows</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1ad494d1-b0a7-4f97-a16b-9b0b84b1e244.png"/></p>
<p>Your project's references are now fixed and you can start coding your function.</p>
<p>As in the previous example, we want to create a function for validating email addresses, and we can reuse the same C# code to do so. Here, you've seen how to start creating an Azure Functions project by using Visual Studio Code directly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing your Azure function locally</h1>
                </header>
            
            <article>
                
<p><span><span>T</span></span>o test your function locally, you need to install the <span class="packt_screen">Azure Functions Core Tools</span>. This can be installed using the following command on the Command Prompt (or from the Visual Studio Code Terminal):</p>
<pre><strong>npm i -g azure-functions-core-tools --unsafe-perm true</strong></pre>
<p class="mce-root">To use npm with Visual Studio Code, you need to have Node.js installed on your machine. You can install it from <a href="https://nodejs.org/en/">https://nodejs.org/en/</a>.</p>
<p>When you run the <kbd>npm</kbd> command, some packages will be downloaded and installed on your local machine:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6e231f0f-1b58-48a5-8a23-e0b6cfe57bbd.png"/></p>
<p class="mce-root"/>
<p>After installing the tools, you need to restart Visual Studio Code in order for this to take effect.</p>
<p>To start testing your function locally, you can press <em>F5</em> directly in Visual Studio Code. The local Azure Function Host environment will start and Visual Studio Code will give you a local URL so that you can call your function:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a78c85f8-0b31-4c91-8d9f-472a7d11516a.png"/></p>
<p>Now, we can test the function by passing the email parameter via a URL in a browser (like we did in the <em>Deploying the function to Azure</em> section).</p>
<p class="mce-root"/>
<p>Along with this, we can debug the code directly from Visual Studio Code by placing breakpoints, moving step by step, checking variables and outputs, and so on, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fd3f6abe-1786-4d91-b3f4-2ea341081d7b.png"/></p>
<p>Now, you've debugged and tested your Azure function in your local environment. In the next section, we'll learn how to publish the function to the Azure cloud.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Publishing your function to Azure</h1>
                </header>
            
            <article>
                
<p>To deploy your Azure function to Azure, follow these simple steps:</p>
<ol>
<li>Click on the Azure Functions icon in the Visual Studio Code sidebar and click on the blue arrow icon called <span class="packt_screen">Deploy to Function App</span>, as shown here:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/660d64e1-7c5d-4d0f-85cf-0022fe6d2f65.png" style="width:25.33em;height:30.58em;"/></p>
<ol start="2">
<li>Visual Studio Code will ask you to choose an Azure subscription as the location to deploy your function to from the list of the available subscriptions for your account, <span>as shown here</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d2a27f5d-0ec7-4894-a38a-cbe6ff47f4bc.png" style="width:34.42em;height:6.08em;"/></p>
<p class="mce-root"/>
<ol start="3">
<li>Now, select <span class="packt_screen">Create New Function App in Azure</span> and give it a globally unique name:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0f86ea16-c64a-43a9-969b-701b643a5ee0.png" style="width:18.83em;height:4.25em;"/></p>
<p style="padding-left: 60px"><span>I've called it </span><kbd>SDEmailValidatorCore</kbd><em>.</em></p>
<ol start="4">
<li>From here, you can create a new resource group and a new storage account. Choose the region where you want to deploy your function. Then, resource deployment will start.</li>
<li>When the deployment process is finished, Visual Studio Code will show you a confirmation message in the bottom-right corner. You can see the deployed function in the subscription tree view on the left:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4d737d43-2329-48eb-b2a2-04fc0d429d09.png"/></p>
<p>Now, your Azure function is running on an Azure data center and you can start using it with AL code. We will look at this in more detail in the next section.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Calling an Azure function from AL</h1>
                </header>
            
            <article>
                
<p>Now that we have deployed our function to Azure, we can use it from the AL code in our extensions.</p>
<p>As we explained in <a href="512b0690-f392-4f82-b006-cacdeec1bacc.xhtml">Chapter 6</a>, <em>Advanced AL Development</em>, in the <em>Consuming web services and APIs from AL</em> section, we can call an Azure function with AL by using the <kbd>HttpClient</kbd> data type, which provides a data type for sending HTTP requests and receiving HTTP responses from a resource that's been identified by a URI.</p>
<p>To test our Azure function, we will create a simple extension (a new project with <strong>AL:Go!</strong>) that allows us to validate an email address associated with a customer record. Our <kbd>CustomerEmailValidation</kbd> extension is made up of a single codeunit object where we define an event subscriber to the <kbd>OnAfterValidate</kbd> event of the <span class="packt_screen">E-Mail</span> field in the <kbd>Customer</kbd> table. In this <kbd>EventSubscriber</kbd> procedure (called <kbd>ValidateCustomerEmail</kbd>), we do the following:</p>
<ul>
<li>Call the Azure function using the <kbd>HttpClient</kbd> object.</li>
<li>Read the response from the Azure function using the <kbd>HttpResponse</kbd> object.</li>
<li>Parse the JSON response in order to extract the <kbd>Valid</kbd> token.</li>
<li>Throw an error if <kbd>Valid = false</kbd>.</li>
</ul>
<p>The code for this is as follows:</p>
<pre>codeunit 50100 EmailValidation_PKT<br/>{<br/>    [EventSubscriber(ObjectType::table, Database::Customer, 'OnAfterValidateEvent', 'E-Mail', false, false)]<br/>    local procedure ValidateCustomerEmail(var Rec: Record Customer)<br/>    var<br/>        httpClient: HttpClient;<br/>        httpResponse: HttpResponseMessage;<br/>        jsonText: Text;<br/>        jsonObj: JsonObject;<br/>        funcUrl: Label 'https://sdemailvalidatorcore.azurewebsites.net/api/emailvalidatorcore?email=';<br/>        InvalidEmailError: Label 'Invalid email address.';<br/>        InvalidJonError: Label 'Invalid JSON response.';<br/>        validationResult: Boolean;<br/>    begin<br/>        if rec."E-Mail" &lt;&gt; '' then begin<br/>            httpClient.Get(funcUrl + rec."E-Mail", httpResponse);<br/>            httpResponse.Content().ReadAs(jsonText);<br/>            //Response JSON format: {"Email":"test@packt.com","Valid":true}<br/>            if not jsonObj.ReadFrom(jsonText) then<br/>                Error(InvalidJonError);<br/>            //Read the Valid token from the response<br/>            validationResult := GetJsonToken(jsonObj, 'Valid').AsValue().AsBoolean();<br/>           if not validationResult then<br/>                Error(InvalidEmailError);<br/>        end;<br/>    end;<br/><br/>    local procedure GetJsonToken(jsonObject: JsonObject; token: Text) jsonToken: JsonToken<br/>    var<br/>        TokenNotFoundErr: Label 'Token %1 not found.';<br/>    begin<br/>        if not jsonObject.Get(token, jsonToken) then<br/>            Error(TokenNotFoundErr, token);<br/>    end;<br/>}</pre>
<p>Press <em>F5</em> and deploy your extension.</p>
<p>If you open a customer card, go to the <span class="packt_screen">Address &amp; Contact</span> tab and insert a value into the <span class="packt_screen">Email</span> field. You will receive the following message:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/46ab5b45-695c-4291-9316-3eccc92eb978.png"/></p>
<p class="mce-root"/>
<p>This happens the first time you do this because outbound HTTP calls are blocked by default in a sandbox environment. Select <span class="packt_screen">Allow Once</span> and click <span class="packt_screen">OK</span>.</p>
<p>Then, our Azure function is called, the JSON response is retrieved and parsed, and the validation occurs. If you insert a valid email address, the value is correctly inserted into the <span class="packt_screen">Email</span> field; otherwise, you will receive an error, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e660b2dd-634a-4961-a65e-05c19a4acfdf.png"/></p>
<p>To allow external calls in a sandbox environment automatically, in the <kbd>NAV App Settings</kbd> table, there is a Boolean field called <kbd>Allow HttpClient Requests</kbd>, and, when the user selects one of the <span class="packt_screen">Always</span> options (<span class="packt_screen">Allow Always</span> or <span class="packt_screen">Block Always</span>), then a record is inserted into this table with the field set to <kbd>true</kbd> or <kbd>false</kbd>.</p>
<p class="mce-root"/>
<p>You can also control this setting programmatically in your AL code. In our extension, we have added the following procedure:</p>
<pre>local procedure EnableExternalCallsInSandbox()<br/>    var<br/>        NAVAppSetting: Record "NAV App Setting";<br/>        EnvironmentInformation: Codeunit "Environment Information";<br/>        ModInfo: ModuleInfo;<br/>    begin<br/>        NavApp.GetCurrentModuleInfo(ModInfo);<br/>        if EnvironmentInformation.IsSandbox() then begin<br/>            NAVAppSetting."App ID" := ModInfo.Id();<br/>            NAVAppSetting."Allow HttpClient Requests" := true;<br/>            if not NAVAppSetting.Insert() then<br/>                NAVAppSetting.Modify();<br/>        end;<br/>    end;</pre>
<p>The preceding code retrieves the information about the current extension (<kbd>ModuleInfo</kbd>) and then checks whether the extension is running in a sandbox environment. If so, it sets the <kbd>Allow HttpClient Requests</kbd> field to <kbd>true</kbd>.</p>
<p>In our previous event subscriber (<kbd>ValidateCustomerEmail</kbd> procedure), we enable the external calls when needed by calling the <kbd>EnableExternalCallsInSandbox</kbd> procedure, as follows:</p>
<pre>begin<br/>    if rec."E-Mail" &lt;&gt; '' then begin<br/>        EnableExternalCallsInSandbox();<br/>        httpClient.Get(funcUrl + rec."E-Mail", httpResponse);</pre>
<p>This allows you to avoid seeing the confirmation request on every external HTTP call.</p>
<p>In the next section, we'll learn how to use Azure Functions and Azure Blob Storage to handle files in the cloud.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interacting with Azure Blob Storage to handle files in the cloud</h1>
                </header>
            
            <article>
                
<p>One of the main problems we have in the cloud environment with Dynamics 365 Business Central is related to saving files. As we mentioned previously, in the cloud environment, you don't have a filesystem and you cannot access local resources such as network shares or local disks.</p>
<p class="mce-root"/>
<p>If you want to save files with Dynamics 365 Business Central SaaS, the solution is to call an Azure function and store the file in cloud-based storage. You can create a function that saves a file in Azure Blob Storage, and from here you can share Azure Storage as a network drive. This is the scenario that we will cover in this section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an Azure Blob Storage account</h1>
                </header>
            
            <article>
                
<p>As the first step in implementing our solution, we need to have a storage account on Azure and we need to create a Blob container inside that storage account.</p>
<p>To manually create an Azure Storage account (called <kbd>d365bcfilestorage</kbd>, in this case), follow these steps:</p>
<ol>
<li>Select <span class="packt_screen">Storage Accounts</span> from the Azure portal, click <span class="packt_screen">Create</span>, and follow the instructions on the screen. To create a Blob container inside this storage account, select <span class="packt_screen">Blobs</span> from the <span class="packt_screen">Services</span> section:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d3c3a374-0559-48a9-ad6c-9172a194b8ab.png"/></p>
<ol start="2">
<li>Then, click on <span class="packt_screen">Container</span>, give it a name (here, I've chosen <span class="packt_screen">d365bcfiles</span>), select the public access level (by default, container data is private to the account owner), and click <span class="packt_screen">OK</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8c6c7a05-854a-40cc-9aaa-6bdd7febf6a6.png"/></p>
<p>Now, the Blob container has been created in your Azure Storage account.</p>
<p>The connection string for accessing your Azure Storage account (which must be used in your Azure functions) can be retrieved by selecting the storage account and clicking on <span class="packt_screen">Access keys</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/402218f9-682b-42f4-beef-412953308047.png"/></p>
<p>Here, we'll embed this connection string inside the function project, but, in a production environment, you can store it in an Azure Key Vault and retrieve it from there for better security.</p>
<p class="mce-root"/>
<p>In our Blob container, I've manually uploaded a file (PNG image) in order to store a file:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/24789192-0a65-4d50-93ab-4d94eb33b680.png"/></p>
<p>Now, we have created a Blob container on Azure Storage so that we can host our files. In the next section, we'll create an Azure function for saving and retrieving files from this Blob storage.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating Azure functions with Visual Studio</h1>
                </header>
            
            <article>
                
<p>Open Visual Studio and create a new Azure Functions project by selecting the <span class="packt_screen">HttpTrigger</span> template. Name your function <kbd>SaaSFileMgt</kbd>.</p>
<p>In our project, we want to create the following functions:</p>
<ul>
<li><kbd>UploadFile</kbd>: This function will receive an object with binary data (file content) and some metadata (file details) via an HTTP POST request. It will store the file in a container in an Azure Blob Storage account.</li>
<li><kbd>DownloadFile</kbd>: This function will receive an object with the URI of the file to download and its details (via an HTTP POST request) and returns the binary of the file stored in the Azure Blob Storage container.</li>
<li><kbd>ListFiles</kbd>: This function will retrieve (via an HTTP GET request) a list of all the URIs of the files stored in the Azure Blob Storage container. These files will be explained in the upcoming sections.</li>
</ul>
<p>The functions to upload/download a file must only support the <span>HTTP</span><span> </span><span>POST method, so, in the</span> <kbd>HttpTrigger</kbd> <span>definition template, we have removed the <kbd>get</kbd> parameter. The signatures of these functions are as follows:</span></p>
<pre>[FunctionName("UploadFile")]<br/>public static async Task&lt;IActionResult&gt; Upload(<br/>   [HttpTrigger(AuthorizationLevel.Function, "post", Route = null)] HttpRequest req, ILogger    <br/>   log)<br/><br/>[FunctionName("DownloadFile")]<br/>public static async Task&lt;IActionResult&gt; Download(<br/>    [HttpTrigger(AuthorizationLevel.Function, "post", Route = null)] HttpRequest req, ILogger <br/>    log)</pre>
<p>The function to list files in Blob storage must only support the GET method, and the signature is as follows:</p>
<pre>[FunctionName("ListFiles")]<br/>public static async Task&lt;IActionResult&gt; Dir(<br/>    [HttpTrigger(AuthorizationLevel.Function, "get", Route = null)] HttpRequest req,<br/> ILogger log)</pre>
<p>Let's explore each of these functions. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The UploadFile function</h1>
                </header>
            
            <article>
                
<p>The <kbd>UploadFile</kbd> function receives a JSON object in the body via an <span>HTTP </span>POST request, as follows:</p>
<pre>{<br/>    "base64": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACVCAYAAAC3i3MLAA",<br/>    "fileName": "MyFile.png",<br/>    "fileType": "image/png",<br/>    "fileExt": "png"<br/>}</pre>
<p>The <kbd>UploadFile</kbd> function parses the JSON in the request body and then calls the <kbd>UploadBlobAsync</kbd> function. In this function, we upload the file to the Azure <span>Blob</span><span> </span><span>Storage container and we return the URI of the uploaded file.</span></p>
<p>The <kbd>UploadFile</kbd> function's code is as follows:</p>
<pre>[FunctionName("UploadFile")]<br/>public static async Task&lt;IActionResult&gt; Upload(                <br/>    [HttpTrigger(AuthorizationLevel.Function, "post", Route = null)] HttpRequest req,<br/>    ILogger log)<br/>    {<br/>        log.LogInformation("C# HTTP trigger function processed a request.");<br/>        string requestBody = await new StreamReader(req.Body).ReadToEndAsync();<br/>        dynamic data = JsonConvert.DeserializeObject(requestBody);<br/>        string base64String = data.base64;<br/>        string fileName = data.fileName;<br/>        string fileType = data.fileType;<br/>        string fileExt = data.fileExt;<br/>        Uri uri = await UploadBlobAsync(base64String, fileName, fileType,     <br/>                    fileExt);           <br/>        return fileName != null<br/>            ? (ActionResult)new OkObjectResult($"File {fileName} stored. URI = {uri}")<br/>            : new BadRequestObjectResult("Error on input parameter (object)");<br/>}</pre>
<p><kbd>UploadBlobAsync</kbd> is a function that performs the Blob upload to the <kbd>d365bcfiles</kbd> container in the Azure Storage account. Its code is as follows:</p>
<pre>public static async Task&lt;Uri&gt; UploadBlobAsync(string base64String, string fileName, string fileType, string fileExtension)<br/>{<br/>    string contentType = fileType;           <br/>    byte[] fileBytes = Convert.FromBase64String(base64String);<br/>    CloudStorageAccount storageAccount =     <br/>        CloudStorageAccount.Parse(BLOBStorageConnectionString);<br/>    CloudBlobClient client = storageAccount.CreateCloudBlobClient();<br/>    CloudBlobContainer container = client.GetContainerReference("d365bcfiles");<br/>    await container.CreateIfNotExistsAsync(<br/>        BlobContainerPublicAccessType.Blob,<br/>        new BlobRequestOptions(),<br/>        new OperationContext());<br/>    CloudBlockBlob blob = container.GetBlockBlobReference(fileName);<br/>    blob.Properties.ContentType = contentType;<br/>    using (Stream stream = new MemoryStream(fileBytes, 0, fileBytes.Length))<br/>    {<br/>        await blob.UploadFromStreamAsync(stream).ConfigureAwait(false);<br/>    }<br/>    return blob.Uri;<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The DownloadFile function</h1>
                </header>
            
            <article>
                
<p>The <kbd>DownloadFile</kbd> function receives a JSON object in the body via an HTTP<span> </span>POST request,<span> as follows</span>:</p>
<pre>{<br/>    "url": "https://d365bcfilestorage.blob.core.windows.net/d365bcfiles/MasteringD365BC.png",<br/>    "fileType": "image/png",<br/>    "fileName": "MasteringD365BC.png"<br/>}</pre>
<p>This function retrieves the details of the file to download from the request body and calls the <kbd>DownloadBlobAsync</kbd> function. Then, it returns the content of the downloaded file (<kbd>Base64-encoded</kbd> string):</p>
<pre>[FunctionName("DownloadFile")]<br/>public static async Task&lt;IActionResult&gt; Download(<br/>    [HttpTrigger(AuthorizationLevel.Function, "post", Route = null)] HttpRequest req,<br/>    ILogger log)<br/>{<br/>    log.LogInformation("C# HTTP trigger function processed a request.");<br/>    try<br/>    {<br/>        string requestBody = await new StreamReader(req.Body).ReadToEndAsync();<br/>        dynamic data = JsonConvert.DeserializeObject(requestBody);<br/>        string url = data.url;<br/>        string contentType = data.fileType;<br/>        string fileName = data.fileName;<br/>        byte[] x = await DownloadBlobAsync(url, fileName);<br/>        //Returns the Base64 string of the retrieved file<br/>        return (ActionResult)new OkObjectResult($"{Convert.ToBase64String(x)}");            <br/>    }<br/>    catch(Exception ex)<br/>    {<br/>        log.LogInformation("Bad input request: " + ex.Message);<br/>        return new BadRequestObjectResult("Error on input parameter (object): " + <br/>            ex.Message);<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p><kbd>DownloadBlobAsync</kbd> is the function that connects to the Azure Storage Blob container, checks for the file, and (if it is found) returns the byte array (stream) of this file:</p>
<pre>public static async Task&lt;byte[]&gt; DownloadBlobAsync(string url, string fileName)<br/>{<br/>    CloudStorageAccount storageAccount =<br/>        CloudStorageAccount.Parse(BLOBStorageConnectionString);<br/>    CloudBlobClient client = storageAccount.CreateCloudBlobClient();<br/>    CloudBlobContainer container = client.GetContainerReference("d365bcfiles"); <br/>    CloudBlockBlob blob = container.GetBlockBlobReference(fileName);<br/>    await blob.FetchAttributesAsync();<br/>    long fileByteLength = blob.Properties.Length;<br/>    byte[] fileContent = new byte[fileByteLength];<br/>    for (int i = 0; i &lt; fileByteLength; i++)<br/>    {<br/>        fileContent[i] = 0x20;<br/>    }<br/>    await blob.DownloadToByteArrayAsync(fileContent, 0);<br/>    return fileContent;<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The ListFiles function</h1>
                </header>
            
            <article>
                
<p>The <kbd>ListFiles</kbd> function is called via an <span>HTTP</span><span> </span><span>GET request (no parameters). It calls the</span> <kbd>ListBlobAsync</kbd> <span>function and then returns the list of the URI of the files in the blob container (JSON format).</span></p>
<p>Its code is defined as follows:</p>
<pre>[FunctionName("ListFiles")]<br/>        public static async Task&lt;IActionResult&gt; Dir(<br/>            [HttpTrigger(AuthorizationLevel.Function, "get", Route = null)] HttpRequest req,<br/>            ILogger log)<br/>        {<br/>            log.LogInformation("C# HTTP trigger function processed a request.");<br/>            string requestBody = await new StreamReader(req.Body).ReadToEndAsync();<br/>            dynamic data = JsonConvert.DeserializeObject(requestBody);<br/>            var URIfileList = await ListBlobAsync();<br/>            string json = JsonConvert.SerializeObject(URIfileList);<br/>            return URIfileList != null<br/>                ? (ActionResult)new OkObjectResult($"{json}")<br/>               : new BadRequestObjectResult("Bad request.");<br/>       }</pre>
<p>The <kbd>ListBlobAsync</kbd> function connects to the Azure Storage container and retrieves the list of blob files stored on it by using the <kbd>ListBlobsSegmentedAsync</kbd> method.</p>
<p>This method returns the list of files in segments by using a <kbd>BlobContinuationToken</kbd>. When this token is <kbd>null</kbd>, all the files are retrieved:</p>
<pre>public static async Task&lt;List&lt;Uri&gt;&gt; ListBlobAsync()<br/>{<br/>    CloudStorageAccount storageAccount = <br/>        CloudStorageAccount.Parse(BLOBStorageConnectionString);<br/>    CloudBlobClient client = storageAccount.CreateCloudBlobClient();<br/>    CloudBlobContainer container = client.GetContainerReference("d365bcfiles");<br/>    List&lt;Uri&gt; URIFileList = new List&lt;Uri&gt;();<br/>    BlobContinuationToken blobContinuationToken = null;<br/>    do<br/>    {<br/>        var resultSegment = await container.ListBlobsSegmentedAsync(prefix: null,<br/>                                           useFlatBlobListing: true,<br/>                                           blobListingDetails: BlobListingDetails.None,<br/>                                           maxResults: null,<br/>                                           currentToken: blobContinuationToken,<br/>                                           options: null,<br/>                                           operationContext: null);<br/>        // Get the value of the continuation token returned by the listing call.<br/>        blobContinuationToken = resultSegment.ContinuationToken;<br/>        foreach (IListBlobItem item in resultSegment.Results)<br/>        {<br/>            URIFileList.Add(item.Uri);<br/>        }<br/>    } while (blobContinuationToken != null); //Loop while the continuation token is not null.<br/><br/>    return URIFileList;<br/>}</pre>
<p>Now, that we've created our Azure functions, it's time to deploy them. We'll learn how to do this in the next section.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying the Azure functions</h1>
                </header>
            
            <article>
                
<p>Our Azure functions can be deployed to our Azure subscription directly from Visual Studio. To deploy these functions to Azure, you need to create a new <span class="packt_screen">Azure App Service</span> instance, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/292d5a02-7c3e-406f-b1c1-2eccca5cc001.png"/></p>
<p>After that, publish your functions to this Azure App Service:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e786f1bc-3529-4e23-9ff8-e4e001f556f4.png"/></p>
<p class="mce-root"/>
<p>If you go to the Azure portal, you will see that the functions have been published and that you now have a public URL to test them:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/70efcc40-93fa-4736-883a-6b578331ae11.png"/></p>
<p>Now, the functions run on an Azure data center. In the next section, we'll learn how we can manage the access keys of our deployed functions (authorization).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing Azure Functions keys</h1>
                </header>
            
            <article>
                
<p>Azure Functions uses authorization keys to protect access to your HTTP-triggered functions. When you deploy a function, you can choose between the following authorization levels:</p>
<ul>
<li><span class="packt_screen">Anonymous</span>: No access key is required.</li>
<li><span class="packt_screen">Function</span>: A specific access key is required in order to access the function.</li>
<li><span class="packt_screen">Admin</span>: A master host key is required.</li>
</ul>
<p class="mce-root"/>
<p>You can manage these access keys directly from the Azure portal by selecting your function and clicking on <span class="packt_screen">Manage</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f41732fd-9acb-4a01-8baa-3ea5357fb8ba.png"/></p>
<p>You can also use the <span class="packt_screen">Key Management API</span> (<a href="https://github.com/Azure/azure-functions-host/wiki/Key-management-API">https://github.com/Azure/azure-functions-host/wiki/Key-management-API</a>) if you want to manage keys programmatically.</p>
<div class="packt_infobox">More information on how you can manage the authorization keys for your Azure Functions can be found here: <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-http-webhook#authorization-keys">https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-http-webhook#authorization-keys</a>.</div>
<p>In this section, you've learned how to handle access keys for our Azure function. In the next section, we'll learn how to test our previously deployed Azure function (uploading and downloading files from Blob storage).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing the Azure functions</h1>
                </header>
            
            <article>
                
<p>In our scenario, the Azure functions have been deployed with the <span class="packt_screen">Function</span> authorization level, so we need to call the desired function by passing a <kbd>code</kbd> parameter with the function key (which we can obtain from the portal). For example, to test the <kbd>ListFiles</kbd> function, we need to call the following URL: <a href="https://saasfilemgt.azurewebsites.net/api/ListFiles?code=FUNCTIONKEY">https://saasfilemgt.azurewebsites.net/api/ListFiles?code=FUNCTIONKEY</a>.</p>
<p>This is the response we get (a list of our Blob files' URIs):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2db0a962-b694-4ef5-848f-0bb31af85d01.png"/></p>
<p>To test the <kbd>DownloadFile</kbd> function, we need to send a POST request to the function's URL by passing a JSON object with the following parameters (which identify the file to retrieve):</p>
<pre>{<br/>    "url": "https://d365bcfilestorage.blob.core.windows.net/d365bcfiles/MasteringD365BC.png",<br/>    "fileType": "image/png",<br/>    "fileName": "MasteringD365BC.png"<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Launching the HTTP request from Visual Studio Code gives us the following response:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bd884e9c-701c-4d9c-bee9-063b5dd6bdbb.png"/></p>
<p>As you can see, the function downloads the requested file from Azure Blob Storage (the function returns the Base64 string).</p>
<p>In the next section, we'll learn how to call our Azure function from an AL extension in Dynamics 365 Business Central.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing the Dynamics 365 Business Central extension</h1>
                </header>
            
            <article>
                
<p>The extension we want to create here is a simple application that adds two actions to the <em>Item List</em> page for uploading and downloading files to/from Azure Blob Storage.</p>
<p>This AL extension will define two objects:</p>
<ul>
<li>A <kbd>codeunit</kbd> object with the logic to call our Azure functions that handle the files with Azure Blob Storage</li>
<li>A <kbd>pageextension</kbd> object that adds the actions on the <span class="packt_screen">Item List</span> page and calls the relative procedures defined in our codeunit</li>
</ul>
<p>Let's look at these in more detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Codeunit definition</h1>
                </header>
            
            <article>
                
<p>The codeunit is called <kbd>SaaSFileMgt</kbd> and contains two procedures:</p>
<ul>
<li><kbd>UploadFile</kbd>: This function will handle the file upload to Azure Blob Storage.</li>
<li><kbd>DownloadFile</kbd>: This function will handle the file download from Azure Blob Storage.</li>
</ul>
<p>In the codeunit, we have two global variables, both of which contain the URLs of the Azure functions to call:</p>
<pre>var<br/>        BaseUrlUploadFunction: Label 'https://saasfilemgt.azurewebsites.net/api/UploadFile?code=YOURFUNCTIONKEY';<br/>        BaseUrlDownloadFunction: Label <br/>                'https://saasfilemgt.azurewebsites.net/api/DownloadFile?code=YOURFUNCTIONKEY';</pre>
<p>Here, <kbd>YOURFUNCTIONKEY</kbd> is the key we use to access the Azure function (retrieved from the Azure portal by selecting the function and clicking on <span class="packt_screen">Manage</span>).</p>
<p>The <kbd>UploadFile</kbd> procedure is defined as follows:</p>
<pre>    procedure UploadFile()<br/>    var<br/>      fileMgt: Codeunit "File Management";<br/>      selectedFile: Text;<br/>      httpClient: HttpClient;<br/>      httpContent: HttpContent;<br/>      jsonBody: text;<br/>      httpResponse: HttpResponseMessage;<br/>      httpHeader: HttpHeaders;<br/>      fileName: Text;<br/>      fileExt: Text;<br/>      base64Convert: Codeunit "Base64 Convert";<br/>      instr: InStream;<br/>    begin<br/>        UploadIntoStream('Select a file to upload','','',selectedFile,instr);<br/>        fileName := delchr(fileMgt.GetFileName(selectedFile), '=', '.' + <br/>                fileMgt.GetExtension(selectedFile));<br/>        fileExt := fileMgt.GetExtension(selectedFile);<br/>        jsonBody := ' {"base64":"' + tempblob.ToBase64String() +<br/>                '","fileName":"' + fileName + '.' + fileExt +<br/>                '","fileType":"' + GetMimeType(selectedFile) + '", "fileExt":"' + <br/>                 fileMgt.GetExtension(selectedFile) + '"}';<br/>        httpContent.WriteFrom(jsonBody);<br/>        httpContent.GetHeaders(httpHeader);<br/>        httpHeader.Remove('Content-Type');<br/>        httpHeader.Add('Content-Type', 'application/json');<br/>        httpClient.Post(BaseUrlUploadFunction, httpContent, httpResponse);<br/>        //Here we should read the response to retrieve the URI<br/>        message('File uploaded.');<br/>    end;</pre>
<p>From the preceding code, we can see the following:</p>
<ol>
<li>We ask for a file to upload.</li>
<li>We read the file into a <kbd>Stream</kbd> object.</li>
<li>We retrieve some parameters related to the file (name and extension).</li>
<li>We create a JSON message, as requested by the function (as we described previously).</li>
<li>Then, we send an HTTP POST request to our Azure function (by using the <kbd>HttpClient</kbd> object), passing the JSON in the body.</li>
</ol>
<p>The <kbd>DownloadFile</kbd> procedure is defined as follows:</p>
<pre>    procedure DownloadFile(fileName: Text; blobUrl: Text)<br/>    var<br/>        tempblob: Codeunit "Temp Blob";<br/>        httpClient: HttpClient;<br/>        httpContent: HttpContent;<br/>        jsonBody: text;<br/>        httpResponse: HttpResponseMessage;<br/>        httpHeader: HttpHeaders;<br/>        base64: Text;<br/>        fileType: Text;<br/>        fileStream: InStream;<br/>        base64Convert: Codeunit "Base64 Convert";<br/>        outstr: OutStream;<br/>    begin<br/>        fileType := GetMimeType(fileName);<br/>        jsonBody := ' {"url":"' + blobUrl + '","fileName":"' + fileName + '", "fileType":"' + <br/>                    fileType + '"}';<br/>        httpContent.WriteFrom(jsonBody);<br/>        httpContent.GetHeaders(httpHeader);<br/>        httpHeader.Remove('Content-Type');<br/>        httpHeader.Add('Content-Type', 'application/json');<br/>        httpClient.Post(BaseUrlDownloadFunction, httpContent, httpResponse);<br/>        httpResponse.Content.ReadAs(base64);<br/>        base64 := DelChr(base64, '=', '"');<br/>        base64Convert.FromBase64(base64);<br/>        tempblob.CreateOutStream(outstr);<br/>        outstr.WriteText(base64);<br/>        tempblob.CreateInStream(fileStream);<br/>        DownloadFromStream(fileStream, 'Download file from Azure Storage', '', '', fileName);<br/>    end;</pre>
<p>This procedure receives the name of the file to retrieve as input. This is how it works:</p>
<ol>
<li>It calls a custom function (<kbd>GetMimeType</kbd>) that returns the content type of this file, and then we compose the JSON message for the request.</li>
<li>Then, we send an HTTP POST request to our Azure function (by using the <kbd>HttpClient</kbd> <span>object), passing the JSON in the body.</span></li>
<li><span>We read the</span> <kbd>HttpResponse</kbd> <span>object (Base64 of the retrieved file) and download it to the client-side by using an</span> <kbd>InStream</kbd> <span>object and calling the</span> <kbd>DownloadFromStream</kbd> <span>method.</span></li>
</ol>
<p>The <kbd>GetMimeType</kbd> utility is defined as follows:</p>
<div>
<pre><span>local</span><span> </span><span>procedure</span><span> GetMimeType</span><span>(</span><span>selectedFile: </span><span>Text)</span><span>: </span><span>Text<br/></span><span>var<br/></span><span>    fileMgt: </span><span>Codeunit</span><span> "File Management";<br/></span><span>    mimeType: </span><span>Text</span><span>;<br/></span><span>begin<br/></span><span>    case</span><span> lowercase</span><span>(</span><span>fileMgt</span><span>.</span><span>GetExtension</span><span>(</span><span>selectedFile</span><span>)) of<br/></span><span>        'pdf'</span><span>:<br/></span><span>            mimeType</span><span> := </span><span>'application/pdf'</span><span>;<br/></span><span>        'txt'</span><span>:<br/></span><span>            mimeType</span><span> := </span><span>'text/plain'</span><span>;<br/></span><span>        'csv'</span><span>:<br/></span><span>            mimeType</span><span> := </span><span>'text/csv'</span><span>;<br/></span><span>        'png'</span><span>:<br/></span><span>            mimeType</span><span> := </span><span>'image/png'</span><span>;<br/></span><span>        'jpg'</span><span>:<br/></span><span>            mimeType</span><span> := </span><span>'image/jpg'</span><span>;<br/></span><span>        'bmp'</span><span>:<br/></span><span>            mimeType</span><span> := </span><span>'image/bmp'</span><span>;<br/></span><span>        'gif'</span><span>:<br/></span><span>            mimeType</span><span> := </span><span>'image/gif'</span><span>;<br/></span><span>        else<br/></span><span>            Error</span><span>(</span><span>'File Format not supported!'</span><span>)</span><span>;<br/></span><span>    end</span><span>;<br/></span><span>    EXIT(</span><span>mimeType</span><span>)</span><span>;<br/></span><span>end</span><span>;</span></pre></div>
<p>This simply receives a filename as input, retrieves the file extension, and then returns the MIME type associated with the file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The pageextension definition</h1>
                </header>
            
            <article>
                
<p>The <kbd>pageextension</kbd> object extends the <span class="packt_screen">Item List</span> page by adding the two actions we described previously. The object definition is as follows:</p>
<pre>pageextension 50103 ItemListExt extends "Item List"<br/>{<br/>    actions<br/>    {<br/>        addlast(Creation)<br/>        {<br/>            Action(Upload)<br/>            {<br/>                ApplicationArea = All;<br/>                Caption = 'Upload file to Azure Blob Storage';<br/>                Image = Add;<br/>                Promoted = true;<br/>                trigger OnAction();<br/>                var<br/>                    SaaSFileMgt: Codeunit SaaSFileMgt;<br/>                begin<br/>                    SaaSFileMgt.UploadFile();<br/>                end;<br/>            }<br/><br/>            Action(Download)<br/>            {<br/>                ApplicationArea = All;<br/>                Caption = 'Download file from Azure Blob Storage';<br/>                Image = MoveDown;<br/>                Promoted = true;<br/>                trigger OnAction();<br/>                var<br/>                    SaaSFileMgt: Codeunit SaaSFileMgt;<br/>                begin<br/>                    SaaSFileMgt.DownloadFile('TEST.txt', 'https://d365bcfilestorage.blob.core.windows.net/d365bcfiles/TEST.txt');<br/>                end;<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>These two actions simply call the methods defined in our codeunit by passing the required parameters.</p>
<p>In the next section, we'll test the integrated solution (an Azure function being called by Dynamics 365 Business Central).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing our application</h1>
                </header>
            
            <article>
                
<p>Now, it's time to test our application and see how it works. When published, our extension adds two functions to the <em><span class="packt_screen">Item List</span></em> page for uploading/downloading files:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/603088b6-2b73-4541-bd2a-f47057f92fd9.png"/></p>
<p class="mce-root"/>
<p>If you click the <span class="packt_screen">Upload file to Azure Blob Storage</span> action, you can select a file from your local machine:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e21b0c5b-f7ce-4a8c-bc58-b905753d9c2d.png"/></p>
<p>This file will be uploaded to the Azure <span>Blob </span>Storage container via an <span>HTTP</span><span> </span><span>POST request to our Azure function. We can debug the</span> <kbd>httpResponse</kbd> <span>object and see that it returns</span> <kbd>HttpStatusCode = 200 (success)</kbd><span>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d315bb5a-8ebf-449e-b794-29c16b150cf2.png"/></p>
<p class="mce-root"/>
<p>We will receive a message that tells us that the file has been uploaded to Azure Blob Storage, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/234275d8-b469-407b-ab85-bc5ba1908627.png"/></p>
<p>If we check the blob container in our Azure Storage account, we will see that the file has been uploaded into the blob storage correctly:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2f4d69e6-1705-4465-8f16-30013b6a7718.png"/></p>
<p>When you click on the <span class="packt_screen">Download file from Azure Blob Storage</span> action, an <span>HTTP</span><span> </span><span>POST request to the</span> <kbd>DownloadFile</kbd> <span>Azure function is performed (by passing a JSON body, as we described <span>previously</span>) and the</span> <kbd>httpResponse</kbd> <span>object returns</span> <kbd>HttpStatusCode = 200 (success)</kbd><span>.</span></p>
<p class="mce-root"/>
<p>The <kbd>httpResponse</kbd> object is a Base64 encoding of the retrieved file. Here, the Base64 string is decoded and the file is downloaded to the client-side by using an <kbd>InStream</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5295bfba-9cdf-4ee7-9aec-83f649c36721.png"/></p>
<p>As you can see, the file is retrieved from the stream and the browser prompts the user to download it locally.</p>
<p>Now, you can handle files in a cloud environment (upload and download). Azure also allows us to map the Blob storage to our on-premise network so that we can have a serverless filesystem that's totally transparent for the end user.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked at what Azure functions are and how we can use them in our Dynamics 365 Business Central extensions to execute .NET code on a cloud environment and to implement serverless processes.</p>
<p>We learned how to create a simple Azure function using Visual Studio and Visual Studio Code and how to use Azure Functions with other Azure services (in particular, how to use Azure Functions and Azure Blob Storage to implement a filesystem in the cloud with Dynamics 365 Business Central).</p>
<p class="mce-root"/>
<p>After reading this chapter, you should understand how to develop, deploy, and use Azure functions to implement business tasks in the cloud in a totally serverless way. In a modern cloud-based ERP, this is a really important feature to master in order to extend the platform's functionalities and to embrace other cloud services.</p>
<p>In the next chapter, we'll learn how to monitor and scale our functions in the cloud and how to apply DevOps techniques (continuous integration and continuous deployment) to our Azure Functions projects by using Azure DevOps.</p>


            </article>

            
        </section>
    </body></html>