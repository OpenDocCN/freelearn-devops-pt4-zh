<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Monitoring, Scaling, and CI/CD with Azure Functions</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>In the previous chapter, we learned how to create Azure F</span>unctions <span>with Visual Studio and Visual Studio Code, how to publish a function on Azure, and how to call an Azure function from a Dynamics 365 Business Central extension.</span></p>
<p>We also learned <span>how to use Azure Functions to implement serverless processes on Azure and execute .NET code in the cloud by looking at a real-life example of how to handle files in a SaaS environment. These topics are extremely important to understand so that you can execute custom code in a cloud environment and interact with external services in a serverless way.</span></p>
<p>In this chapter, we'll explore other important aspects related to Azure Functions, including the following:</p>
<ul>
<li>Monitoring a function published in the Azure cloud</li>
<li>Scaling an Azure function</li>
<li>Applying DevOps and CI/CD to Azure Functions</li>
</ul>
<p>By the end of this chapter, you will have had a complete and in-depth overview of the Azure Functions service and you will be confident with using this service on your Microsoft Dynamics 365 Business Central projects to execute complex code and serverless tasks from a cloud tenant.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To follow the content in this chapter, you need to have the following:</p>
<ul>
<li>A valid Azure subscription (a paid or a trial subscription that you can activate for free at <a href="https://azure.microsoft.com/free/">https://azure.microsoft.com/free/</a>)</li>
<li><span>A valid </span>account in Azure DevOps (<a href="https://azure.microsoft.com/en-in/services/devops/">https://azure.microsoft.com/en-in/services/devops/</a>)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Monitoring Azure Functions</h1>
                </header>
            
            <article>
                
<p>Monitoring Azure Functions is an important task when you're managing your serverless services on Azure. If you want to have a reliable service that always works, you need to have a policy for checking incoming calls on a function, errors, the need for scalability of particular functions, and so on.</p>
<p>From the Azure portal, select your Azure function. By clicking on <em>Monitor</em>, you will be able to see the logged requests (success and errors). The following screenshot shows this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/05cf0678-fe0a-471d-81ca-605064a20eb0.png"/></p>
<p class="mce-root"/>
<p>If you select a single request, you can see its <span class="packt_screen">Invocation Details</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cfe06eb5-689d-4c93-be0b-e6d64b083079.png"/></p>
<p>For more advanced logging, you can click on <span class="packt_screen">Run</span> in <span class="packt_screen">Application Insights</span> (this must be activated from the portal):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e90a8e1c-5570-4f66-8d7a-dc1f7d341447.png"/></p>
<p>Here, you can also perform custom queries inside the function's telemetry. For example, this is a query on the telemetry log that displays the number of requests per worker role (function) over the last 20 minutes:</p>
<pre>requests<br/>| where timestamp &gt; ago(20m)<br/>| summarize count() by cloud_RoleInstance, bin(timestamp, 1m)<br/>| render timechart</pre>
<p>The following is the output of this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/426a22b2-7716-4468-94bf-3d8182ea2ce0.png"/></p>
<p>The following is a useful query that you can perform on <span class="packt_screen">Application Insights</span> to retrieve errors in your function:</p>
<pre>traces <br/>| where customDimensions.LogLevel == "Error"</pre>
<p>When <span class="packt_screen">Application Insights</span> is configured, you'll have a nice panel where you can immediately see everything that occurs in your function (failed requests, server response time, number of server requests, availability, and so on):</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="assets/65e8297b-ea3f-47a4-942a-455b2aaca8bb.png"/></p>
<p><span><span class="packt_screen">Application Insights</span></span> is an important section to check if you wish to discover failures and discover whether the function is performing well or needs to be scaled. The following screenshot shows this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5f4040ef-a8e4-4faf-94b2-d52e0905ada0.png"/></p>
<p class="mce-root"/>
<div class="packt_infobox">More information about working <span>efficiently </span>with <span class="packt_screen">Application Insights</span> can be found at <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-monitoring">https://docs.microsoft.com/en-us/azure/azure-functions/functions-monitoring</a>.</div>
<p>As you can see, <span class="packt_screen">Application Insights</span> is an extremely powerful tool for monitoring your live services and managing your function's logs. I recommend that you always activate it in order to keep your serverless platform on Azure under control. Next, let's learn how Azure Functions work.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scaling Azure Functions</h1>
                </header>
            
            <article>
                
<p>When using Azure Functions in a production environment, scalability is an important aspect to check because it allows you to tune up your service and avoid bottlenecks or resource deficits.</p>
<p>Azure Functions are executed on two different plans:</p>
<ul>
<li><strong>Consumption plan</strong>: You pay for what you consume. Your app is scaled up or down according to your power requirements. Your billing depends on the number of executions, the execution time, and the memory that the app is using.</li>
<li><strong>Premium plan</strong>: This is quite similar to the consumption plan (scaling up and down is handled automatically according to the requested power). Your billing depends on the amount of core per second and the GB of memory per second that's used across all of your instances. The Premium plan adds the following features:
<ul>
<li>Always warm instances to avoid cold starts</li>
<li>VNet connectivity</li>
<li>Unlimited execution duration</li>
<li>Premium instance sizes (one core, two core, and four core instances)</li>
<li>Predictable pricing options</li>
<li>High-density app allocation for plans with multiple function apps</li>
</ul>
</li>
</ul>
<p class="mce-root"/>
<p>You can check the hosting plan that's used by your function via the <span class="packt_screen">Overview</span> tab in the Azure portal:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/539465e5-4323-412e-8b44-6f82e1b1b25c.png"/></p>
<p>Your Azure function can also run on the same dedicated environment as other cloud applications (App Service apps). This is called an <span class="packt_screen">App Service plan</span>, and you pay the same quota for all the functions in the same <span class="packt_screen">App Service plan</span>. When you use an <span class="packt_screen">App Service plan</span>, you can handle scaling manually (by adding, for example, more VM instances) or automatically (by enabling autoscale). </p>
<div class="packt_infobox">For more information about this plan, see <a href="https://docs.microsoft.com/en-us/azure/app-service/overview-hosting-plans">https://docs.microsoft.com/en-us/azure/app-service/overview-hosting-plans</a>.</div>
<p>Now, you have a clear overview of the scaling and related billing options that you have when you deploy your functions on Azure. You should select the plan you wish to use according to your business needs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Azure Functions and DevOps</h1>
                </header>
            
            <article>
                
<p>In this section, we will discuss DevOps techniques and, in particular, how you can create a CI/CD process for your Azure Functions with Azure DevOps.</p>
<p class="mce-root"/>
<p>First, to have source code management, your function's code must be hosted on a Git repository. Here, we're using Azure DevOps as a repository for our CI/CD process:</p>
<ol>
<li>To start, create a new project in Azure DevOps. This project will contain a Git repository for your source code. By clicking on the <strong>Repos</strong> menu on the left, you will see the URL of this repository. Clone it into your local folder with the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>Git clone https://demiliani@dev.azure.com/demiliani/AzureFunctionDevOps/_git/AzureFunctionDevOps</strong></pre>
<ol start="2">
<li>In this local repository, I've placed all the project files for our <kbd>EmailValidator</kbd> Azure function that we previously developed with Visual Studio and committed. Then, we pushed all the files to our online Azure DevOps repository, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/510e9c6b-92f9-46be-bf4c-65550dc199af.png"/></p>
<p style="padding-left: 60px">Our code is now on Azure DevOps.</p>
<p class="mce-root"/>
<ol start="3">
<li>Now, we want to create a build pipeline for our Azure Functions project. From the <span class="packt_screen">Azure DevOps</span> project page, select <span class="packt_screen">Pipelines | Builds</span> and click on <span class="packt_screen">New Pipeline</span>. On the <span class="packt_screen">Where is your code?</span> page, click on <span class="packt_screen">Use the classic editor</span> to create a pipeline without YAML:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4c015536-f3ca-48db-b124-c5ba489eb1a4.png"/></p>
<p class="mce-root"/>
<ol start="4">
<li>Now, you have to choose where your code is going to be hosted. Select <span class="packt_screen">Azure Repos Git</span> and select a repository from the list (you should have only one repository for the selected project) and a branch to use:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/78fa0141-cdf0-43c1-92c5-99c9452dbfd6.png"/></p>
<p class="mce-root"/>
<ol start="5">
<li>Click on <span class="packt_screen">Continue</span>. On the <span class="packt_screen">Choose a template</span> page, you need to select a template for your build pipeline. Scroll down the list, select <span class="packt_screen">Azure Functions for .NET</span>, and click <span class="packt_screen">Apply</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8262bb1f-f426-4f7e-9ab9-edc8e9d2ca0b.png"/></p>
<p class="mce-root"/>
<p style="padding-left: 60px">Your build pipeline will be created according to the template you've selected.</p>
<ol start="6">
<li>Click on <span class="packt_screen">Save &amp; queue</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5f44f182-2778-4be5-82d9-512eaee995d0.png"/></p>
<p class="mce-root"/>
<ol start="7">
<li>Now, a new <span class="packt_screen">Save build pipeline and queue</span> window will appear. Here, click on <span class="packt_screen">Save &amp; queue</span> again:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/86bd862d-5525-4d64-a006-024611c2b8ef.png"/></p>
<ol start="8">
<li>Now, your build pipeline has been queued. At the top of your screen, you should see something similar to the following message:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8f045fcb-9b3b-449a-baa0-f25b537d1fa8.png" style="width:33.00em;height:8.08em;"/></p>
<ol start="9">
<li>If you click on the build number, you will see the build steps that have been performed:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a50767a0-6580-4480-961e-63e6de95b50f.png" style="width:36.92em;height:33.67em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The build process is working, and the nice thing is that you also receive an email, notifying you about the build result.</p>
<p>We have triggered the build manually, but a good developer is often a lazy developer, and so we want to trigger the build automatically on every commit on the repository in the master branch. Let's take a look at how to do this:</p>
<ol>
<li>To define a build trigger, select the build pipeline and click <strong><span class="packt_screen">Edit</span></strong>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/26bdbf70-93fd-4f86-a15c-6eb79f8c6be1.png"/></p>
<ol start="2">
<li>Here, select <span class="packt_screen">Triggers</span> and click on <span class="packt_screen">Enable continuous integration</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ce5f709d-86c3-44e5-a945-7c173bdef3fa.png"/></p>
<ol start="3">
<li>Click on <span class="packt_screen">Save &amp; queue</span> and select the <span class="packt_screen">Save</span> option.</li>
</ol>
<p>Now, when you push a new code modification to your code repository, the build is automatically triggered.</p>
<p class="mce-root"/>
<p>If we <span>want to</span> <span>have</span><span> </span><span>an automatic deployment to Azure for our function project upon every commit, we have to create a release pipeline. Let's learn how to do this:</span></p>
<ol>
<li>To create a release pipeline on Azure DevOps, select <span class="packt_screen">Pipelines | Releases</span> and click on <span class="packt_screen">New Pipeline</span>. Then, select <span class="packt_screen">Azure App Service deployment</span> and click <span class="packt_screen">Apply</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9fd56cd9-0493-4def-a520-fbd0a9c18a52.png"/></p>
<ol start="2">
<li>On the next screen, click on <span class="packt_screen">Add</span> in the <span class="packt_screen">Artifacts</span> section on the left:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/efdfe0a3-255c-4239-9c5c-d5e120124e6d.png"/></p>
<p class="mce-root"/>
<ol start="3">
<li>On the <span class="packt_screen">Add an Artifact</span> page, select <span class="packt_screen">Build</span> as the <span class="packt_screen">Source Type</span>. Then, select your build pipeline and click on <span class="packt_screen">Add</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bdc7ef01-e083-4fee-8237-2e8c873eb9fd.png" style="width:48.58em;height:54.75em;"/></p>
<ol start="4">
<li>Now, click the red exclamation mark on <span class="packt_screen">Stage 1</span> to view the build tasks:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/850c9514-bfcf-4da5-a768-43c4ba892840.png" style="width:45.58em;height:30.17em;"/></p>
<p style="padding-left: 60px">Here, you have to select an Azure subscription and set <span class="packt_screen">App Type</span> to <span class="packt_screen">Function App on Windows</span>.</p>
<p class="mce-root"/>
<ol start="5">
<li>To use the Azure subscription, you need to click the <span class="packt_screen">Authorize</span> button after you've made your selection (you need to disable your popup blocker if it's active):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f2b82741-dbbe-4f74-83b8-3f5ba500e3f7.png" style="width:53.00em;height:34.17em;"/></p>
<p class="mce-root"/>
<ol start="6">
<li>When your subscription has been authorized, select the <span class="packt_screen">App Service name</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2dcb5795-76f4-4a74-8029-91846229016c.png" style="width:38.25em;height:26.33em;"/></p>
<ol start="7">
<li>Then, click on <span class="packt_screen">Save</span>. By doing this, your release pipeline will be saved and ready:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f05f2be8-b987-436b-b273-fb56d7244b8a.png"/></p>
<p class="mce-root"/>
<ol start="8">
<li>To create a new release manually on Azure DevOps, select <span class="packt_screen">Pipelines | Releases</span> and click on <span class="packt_screen">Create a release</span>. On the <span class="packt_screen">Create a new release</span> page, don't change anything and just click on <span class="packt_screen">Create</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bf9f40d2-cdf9-4abb-8a15-210764fd97ec.png"/></p>
<ol start="9">
<li>A new release will be queued:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d7779664-3140-49db-8af5-b1a02d12555d.png" style="width:51.08em;height:18.58em;"/></p>
<p class="mce-root"/>
<ol start="10">
<li>If you click the release name, you will be redirected to the release progress page:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/323cb420-ff21-4c63-8e11-dd605d5616a0.png"/></p>
<ol start="11">
<li>If your release pipeline succeeds, your function will be automatically deployed to the Azure App Service:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e0e1c441-86e5-463b-884c-ef8874152766.png"/></p>
<ol start="12">
<li>Finally, to fully enable a continuous deployment process, we need to edit the release pipeline again and click on the continuous deployment icon:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6918920a-68b2-414f-8975-747f8f3d0068.png" style="width:46.00em;height:38.17em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="13">
<li>Here, we need to enable the <span class="packt_screen">Continuous deployment trigger</span> option:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/decfb771-3ffd-4fbe-b0de-46b96bdb210c.png"/></p>
<p>That's it! We have a CI/CD process in place for our Azure function.</p>
<p>With this process, and by using Azure DevOps, you can automatically build and release (deploy) an Azure function onto your cloud environment, all from a managed platform.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned how to monitor an Azure function, how to monitor incoming calls and logs, and how to use Application Insights for advanced analysis.</p>
<p>In all, we learned how to select the best service plan for the functions that we'll be deploying in the cloud, and then we learned how to implement CI/CD techniques to create a smart deployment process of our functions in the cloud.</p>
<p>Now, you have a clear overview of the options that are <span>available </span>for deploying and monitoring services on Azure and for selecting the best deployment model for your business case. You've also learned how you can activate a CI/CD process on your development pipeline so that you can build and deploy functions on Azure.</p>
<p><span>In the next chapter, we'll talk about how to integrate Dynamics 365 Business Central with the <em>Microsoft Power Platform</em> and, in particular, how to use <em>Flow</em> and <em>PowerApps</em> with Dynamics 365 Business Central to implement "zero-coding" business processes.</span></p>


            </article>

            
        </section>
    </body></html>