<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Sharing Terraform Configuration with Modules
                </header>
            
            <article>
                
<p class="mce-root"><span>The real challenge for developers and software factories in recent years has been to stop writing the portions of code that are repeated between applications and even between teams. Hence the emergence of language, framework, and software packages that are easily reusable in several applications and that can be shared between several teams (such as NuGet, NPM, Bower, PyPI, RubyGems, and many others). In <strong>Infrastructure as Code</strong> (<strong>IaC</strong>) in general, we also encounter the same problems of code structure, its homogenization, and its sharing in the company.</span></p>
<p class="mce-root">We learned in the <em>Provisioning infrastructure in multiple environments</em> <span>recipe </span>of <a href="3099c9ac-8c38-4e7d-8146-411fac26a2b7.xhtml">Chapter 2</a>, <em>Writing Terraform Configuration</em>, some topologies of the structure of the Terraform configuration, that gave us a partial answer to the question of how to structure a Terraform configuration well. But that doesn't stop there—Terraform also allows you to create modules with which you can share Terraform configuration between several applications and several teams.</p>
<p class="mce-root">In this chapter, we will study the main stages of the modules, which are: the creation, use, and publishing of Terraform modules. We will learn about the creation of a Terraform module and its local use, as well as the rapid bootstrapping of the code of a module. We will also study the use of Terraform modules using the public registry or a Git repository. Finally, we will study how to test a module as well as an example of a CI/CD pipeline of a Terraform module in Azure Pipelines and GitHub Actions.</p>
<p><span>In this chapter, we cover the following recipes:</span></p>
<ul>
<li>Creating a Terraform module and using it locally</li>
<li>Using modules from the public registry</li>
<li>Sharing a Terraform module using GitHub</li>
<li>Using another file inside a custom module</li>
<li>Using the Terraform module generator</li>
</ul>
<ul>
<li>Generating module documentation</li>
<li>Using a private Git repository for sharing Terraform modules</li>
<li>Applying a Terrafile pattern for using modules</li>
<li>Testing Terraform module code with Terratest</li>
<li>Building CI/CD for Terraform modules in Azure Pipelines</li>
<li>Building a workflow for Terraform modules using GitHub Actions</li>
</ul>
<h1 id="uuid-c6957ad6-2685-4809-be2b-586eb3dd115a" class="mce-root">Technical requirements</h1>
<p>In this chapter, for some recipes, we will need certain prerequisites, which are as follows:</p>
<ul>
<li><strong>To have Node.js and NPM installed on your computer</strong>: The download website is here: <a href="https://nodejs.org/en/">https://nodejs.org/en/</a>.</li>
<li><strong>To have a GitHub account</strong>: If you don't have one, the creation of the account is free and can be done here: <a href="https://github.com/">https://github.com/</a>.</li>
<li><strong>To have an Azure DevOps organization</strong>: You can create one with a Live or GitHub account here: <a href="https://azure.microsoft.com/en-in/services/devops/">https://azure.microsoft.com/en-in/services/devops/</a>.</li>
<li><strong>To have a basic knowledge of Git commands and workflow</strong>: The documentation is available here: <a href="https://git-scm.com/doc">https://git-scm.com/doc</a>.</li>
<li><strong>To know about Docker</strong>: The documentation is here: <a href="https://docs.docker.com/">https://docs.docker.com/</a>.</li>
<li><strong>To install Golang on our workstation</strong>: The documentation is here: <a href="https://golang.org/doc/install">https://golang.org/doc/install</a>. We will see the main steps of its installation in the <em>Testing a Terraform module using Terratest</em> <span>recipe</span>.</li>
</ul>
<p class="mce-root">The complete source code for this chapter is available on GitHub at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05</a>.</p>
<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3ibKgH2">https://bit.ly/3ibKgH2</a></p>
<h1 id="uuid-1a3194c6-5dcb-4afc-906f-287c30902ee1">Creating a Terraform module and using it locally</h1>
<p>A Terraform module is a Terraform configuration that contains one or more Terraform resource. Once created, this module can be used in several Terraform configuration files either locally or even remotely.</p>
<p class="mce-root">In this recipe, we will look at the basics of a Terraform module with the steps involved in creating a module and using it locally.</p>
<h2 id="uuid-22da4f6b-038a-4eb3-8298-aa8a1fa3a1a5">Getting ready</h2>
<p>To start this recipe, we will use the Terraform configuration that we have already written in the <em>Provisioning infrastructure in multiple environments</em> <span>recipe </span>in <a href="3099c9ac-8c38-4e7d-8146-411fac26a2b7.xhtml">Chapter 2</a>, <em>Writing Terraform Configuration</em>, and whose sources can be found at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/sample-app">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/sample-app</a>.</p>
<p class="mce-root">The module we will create in this recipe will be in charge of providing a Service Plan, one App Service, and an Application Insights resource in Azure. Its source code is available here: <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/moduledemo/Modules/webapp">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/moduledemo/Modules/webapp</a>. Then, we will write a Terraform configuration that uses this module and the code is here: <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/moduledemo/MyApp">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/moduledemo/MyApp</a>.</p>
<h2 id="uuid-bc106c95-c363-4502-b346-8b590b45ba1e">How to do it…</h2>
<p>To create the module, perform the following steps:</p>
<ol>
<li>In a new folder called <kbd>moduledemo</kbd>, create the <kbd>Modules</kbd> and <kbd>webapp</kbd> folders.</li>
</ol>
<ol start="2">
<li>In the <kbd>webapp</kbd> folder, create a new <kbd>variables.tf</kbd> file with the following code:</li>
</ol>
<pre style="padding-left: 60px"><span>variable </span><span>"resource_group_name" </span>{<br/>  <span>description </span>= <span>"Resource group name"<br/></span>}<br/><br/><span>variable </span><span>"location" </span>{<br/>  <span>description </span>= <span>"Location of Azure resource"<br/></span><span>  </span><span>default     </span>= <span>"West Europe"<br/></span>}<br/><br/><span>variable </span><span>"service_plan_name" </span>{<br/>  <span>description </span>= <span>"Service plan name"<br/></span>}<br/><br/><span>variable </span><span>"app_name" </span>{<br/>  <span>description </span>= <span>"Name of application"<br/></span>}</pre>
<p class="mce-root"/>
<ol start="3">
<li>Then, create the <kbd>main.tf</kbd> file with the following code:</li>
</ol>
<pre style="padding-left: 60px"><span>resource </span><span>"azurerm_app_service_plan" </span><span>"plan-app" </span>{<br/>  <span>name                </span>= var.<span>service_plan_name<br/></span><span>  location            </span>= var.<span>location<br/></span><span>  resource_group_name </span>= var.<span>resource_group_name<br/></span><span>  </span><span>sku </span>{<br/>    <span>tier </span>= <span>"Standard"<br/></span><span>    </span><span>size </span>= <span>"S1"<br/></span><span>  </span>}<br/>}<br/><br/><span>resource </span><span>"azurerm_app_service" </span><span>"app" </span>{<br/>  <span>name                </span>= var.<span>app_name<br/></span><span>  location            </span>= var.<span>location<br/></span><span>  resource_group_name </span>= var.<span>resource_group_name<br/></span><span>  app_service_plan_id </span>= <span>azurerm_app_service_plan</span>.plan-app.<span>id<br/></span><span>  app_settings </span>= {<br/>    <span>"INSTRUMENTATIONKEY" </span>= <span>azurerm_application_insights</span>.appinsight-app.<span>instrumentation_key<br/></span><span>  </span>}<br/>}<br/><br/><span>resource </span><span>"azurerm_application_insights" </span><span>"appinsight-app" </span>{<br/>  <span>name                </span>= var.<span>app_name<br/></span><span>  location            </span>= var.<span>location<br/></span><span>  resource_group_name </span>= var.<span>resource_group_name<br/></span><span>  application_type    </span>= <span>"web"<br/></span>}</pre>
<ol start="4">
<li>Finally, create the <kbd>output.tf</kbd> file with the following code:</li>
</ol>
<pre style="padding-left: 60px"><span>output </span><span>"webapp_id" </span>{<br/>  <span>value </span>= <span>azurerm_app_service</span>.app.<span>id<br/></span>}<br/><br/><span>output </span><span>"webapp_url" </span>{<br/>  <span>value </span>= <span>azurerm_app_service</span>.app.<span>default_site_hostname<br/></span>}</pre>
<ol start="5">
<li>Inside the <kbd>moduledemo</kbd> folder, create a subfolder called <kbd>MyApp</kbd>.</li>
</ol>
<ol start="6">
<li>Inside the <kbd>MyApp</kbd> folder, create a <kbd>main.tf</kbd> file with the following code:</li>
</ol>
<pre style="padding-left: 60px"><span>resource </span><span>"azurerm_resource_group" </span><span>"rg-app" </span>{<br/>  <span>name     </span>= <span>"RG_MyAPP_demo"<br/></span><span>  </span><span>location </span>= <span>"West Europe"<br/></span>}<br/><br/><span>module </span><span>"webapp" </span>{<br/>  <span>source </span>= <span>"../Modules/webapp"<br/></span><span>  </span><span>service_plan_name </span>= <span>"spmyapp"<br/></span><span>  </span><span>app_name </span>= <span>"myappdemo"<br/></span><span>  </span><span>location </span>= <span>azurerm_resource_group</span>.rg-app.<span>location<br/></span><span>  resource_group_name </span>= <span>azurerm_resource_group</span>.rg-app.<span>name<br/></span>}<br/><span><br/>output </span><span>"webapp_url" </span>{<br/>  <span>value </span>= module.<span>webapp</span>.<span>webapp_url<br/></span>}</pre>
<h2 id="uuid-b0a7cb98-ef54-4e27-a799-50170f015419">How it works…</h2>
<p>In <em>step 1</em>, we create the <kbd>moduledemo</kbd> directory, which will contain the code for all modules with one subdirectory per module. So, we create a <span><kbd>WebApp</kbd> </span>subdirectory<span> for our recipe,</span> which will contain the Terraform configuration of the <kbd>webapp</kbd> module. Then in <em>steps 2</em>, <em>3</em>, and <em>4</em>, we create the module code, which is the standard Terraform configuration and contains the following files:</p>
<ul>
<li><kbd>main.tf</kbd>: This file contains the code of the resources that will be provided by the module.</li>
<li><kbd>variables.tf</kbd>: <span>This file contains</span> the input variables needed by the module.</li>
<li><kbd>outputs.tf</kbd>: <span>This file contains</span> the outputs of the module that can be used in the main Terraform configuration.</li>
</ul>
<p class="mce-root">In <em>step 5</em>, we created the directory that will contain the Terraform configuration of our application. Finally, in <em>step 6</em>, we created the Terraform configuration of our application with the <kbd>main.tf</kbd> file.</p>
<p class="mce-root">In the code of this file, we have three Terraform elements:</p>
<ul>
<li class="mce-root">There is the Terraform <span><kbd>azurerm_resource_group</kbd> </span>resource, which provides a Resource Group.</li>
<li class="mce-root"><span>The Terraform configuration that uses the module we created, using the <kbd>module "&lt;module name&gt;"</kbd> expression</span>. <span>In this module type block, we used the source properties whose value is the relative path of the directory that contains the <kbd>webapp</kbd> module.</span></li>
</ul>
<div class="mce-root packt_infobox">Note that if some variables of the module are defined with default values, then in some cases, it will not be necessary to instantiate them when calling the module.</div>
<ul>
<li class="mce-root">We also have the Terraform output, <kbd>webapp_url</kbd>, which gets the output of the module to use it as output for our main Terraform configuration.</li>
</ul>
<h2 id="uuid-114ed009-7cb0-4ae3-acc1-579d77869a4e">There's more…</h2>
<p>At the end of all of these steps, we obtain the following directory tree:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6e656a99-2a8a-4950-8783-897189d53e81.png" style="width:21.17em;height:14.33em;"/></p>
<p class="mce-root">To apply this Terraform configuration, you have to navigate in a command terminal to the <kbd>MyApp</kbd> folder containing the Terraform configuration and then execute the following Terraform workflow commands:</p>
<pre class="mce-root"><strong>terraform init</strong><br/><strong>terraform plan -out=app.tfplan</strong><br/><strong>terraform apply app.tfplan<br/></strong></pre>
<p class="mce-root">When executing the <kbd>terraform init</kbd> command, Terraform will get the module's code and hence integrate its configuration with that of the application, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6f9e7a26-66eb-4026-bbc8-6fab3039e54f.png" style="width:56.50em;height:14.92em;"/></p>
<p class="mce-root">Finally, at the end of the execution of the <kbd>terraform apply</kbd> command, the value of the output is displayed in the terminal, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6523c357-2ea2-4570-b671-ffe78fda2790.png" style="width:32.08em;height:4.83em;"/></p>
<p class="mce-root">Our Terraform configuration has therefore retrieved the output of the module and used it as the output of our main code.</p>
<p class="mce-root">In this recipe, we have shown the basics of the creation of a Terraform module and its local use. In this chapter, we will see how to generate the structure of a module <span>and how to use remote modules</span> in the <em>Using the Terraform module generator</em> <span>recipe</span>.</p>
<h2 id="uuid-270ab74c-cb56-4e35-905e-3caa758acf8d">See also</h2>
<ul>
<li>The documentation on module creation is available at <a href="https://www.terraform.io/docs/modules/index.html">https://www.terraform.io/docs/modules/index.html</a></li>
<li class="mce-root">General documentation on the modules is available at <a href="https://www.terraform.io/docs/configuration/modules.html">https://www.terraform.io/docs/configuration/modules.html</a></li>
<li class="mce-root">Terraform's learning lab on module creation is available at <a href="https://learn.hashicorp.com/terraform/modules/creating-modules">https://learn.hashicorp.com/terraform/modules/creating-modules</a></li>
</ul>
<h1 id="uuid-649677cc-f1fd-483b-b41d-8f8d8cf35107">Using modules from the public registry</h1>
<p>In the previous recipe, we studied how to create a module and how to write a Terraform configuration that uses this module locally.</p>
<p class="mce-root">To facilitate the development of Terraform configuration, HashiCorp has set up a public Terraform module registry.</p>
<p>This re<span>gistry actually solves several problems, such as the following:</span></p>
<ul>
<li><span>Discoverability with search and filter<br/></span></li>
<li><span>The quality provided via a partner verification process<br/></span></li>
<li><span>Clear and efficient versioning strategy, which is otherwise impossible to solve universally across other existing module sources (HTTP, S3, and Git)</span></li>
</ul>
<p class="mce-root">These public modules published in this registry are developed by cloud providers, publishers, communities, or even individual users who wish to share their modules publicly. In this recipe, we will see how to access this registry and how to use a module that has been published in this public registry.</p>
<h2 id="uuid-801e6ea4-154f-4335-bab7-3ac5edac5501">Getting ready</h2>
<p>In this recipe, we will write a Terraform code <span>from scratch </span>that does not require any special prerequisite.</p>
<p class="mce-root">The purpose of this recipe is to provision a Resource Group and network resources in Azure, which are a Virtual Network and Subnet. We will see the public module call but we won't look at the Terraform configuration of the module in detail.</p>
<p>The code source of this recipe is available here: <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/publicmodule">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/publicmodule</a>.</p>
<h2 id="uuid-b9529f83-26c9-427c-978b-1a9eaad8309c">How to do it…</h2>
<p>To use the Terraform module from a public registry, perform the following steps:</p>
<ol>
<li>In a web browser, go to the URL: <a href="https://registry.terraform.io/browse/modules">https://registry.terraform.io/browse/modules</a>.</li>
</ol>
<ol start="2">
<li class="CDPAlignLeft CDPAlign">On this page, in the <span class="packt_screen">FILTERS</span> list in the left panel, choose <span class="packt_screen">azurerm</span>:<span class="packt_screen"><br/></span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7c860d58-f9aa-4f31-b1ef-def165da076b.png" style="width:69.00em;height:38.33em;"/></p>
<ol start="3">
<li>In the results list, click on the first result, that is, the <span><span class="packt_screen">Azure / network</span> </span>module:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b621e18d-f5a1-4e7c-a355-a86af97eb9b2.png" style="width:36.75em;height:11.25em;"/></p>
<ol start="4">
<li>Then, on the <span class="packt_screen">Details </span><span>page</span> of this module, copy the code from the <span class="packt_screen">Usage</span> section:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/eea095d2-77ae-4687-bf7b-84f079b8ce08.png" style="width:34.67em;height:28.83em;"/></p>
<ol start="5">
<li>Finally, in your workstation, create a new file, <kbd>main.tf</kbd>, then paste the preceding code and update it as follows:</li>
</ol>
<pre style="padding-left: 60px"><span>resource </span><span>"azurerm_resource_group" </span><span>"rg" </span>{<br/>  <span>name     </span>= <span>"my-rg"<br/></span><span>  </span><span>location </span>= <span>"West Europe"<br/></span>}<br/><br/><span>module </span><span>"network" </span>{<br/>  <span>source              </span>= <span>"Azure/network/azurerm"<br/></span><span>  </span><span>resource_group_name </span>= <span>azurerm_resource_group</span>.rg.<span>name<br/></span><span>  vnet_name           </span>= <span>"vnetdemo"<br/></span><span>  </span><span>address_space       </span>= <span>"10.0.0.0/16"<br/></span><span>  </span><span>subnet_prefixes     </span>= [<span>"10.0.1.0/24"</span>]<br/>  <span>subnet_names        </span>= [<span>"subnetdemo"</span>]<br/>}</pre>
<p class="mce-root"/>
<h2 id="uuid-f7c5ac4c-db11-4d5b-9903-7749672fa35f">How it works…</h2>
<p>In <em>steps 1</em> to <em>2</em>, we explored Terraform's public registry to look for a module that allows the provisioning of resources for Azure (using the <kbd>azurerm</kbd> filter).</p>
<p class="mce-root">Then, in <em>steps 3</em> and <em>4</em>, we accessed the <span class="packt_screen">Details</span> page of the <span class="packt_screen">Network</span> module published by the Azure team.</p>
<p class="mce-root">In <em>step 5</em>, we used this module by specifying these necessary input variables with the <kbd>source</kbd> property, which is worth of a public module-specific alias, <span><kbd>Azure/network/azurerm</kbd>, </span>provided by the registry.</p>
<h2 id="uuid-fd856a60-bff1-4210-93c8-c74459ee194d">There's more…</h2>
<p>We have seen in this recipe that using a module from the public registry saves development time. Here, in our recipe, we used a verified module but you can perfectly use the other community modules.</p>
<p class="mce-root">It is possible to use the versioning of these modules by choosing the desired version of the module in the version drop-down list:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/57fa38f5-1215-4c2c-9c70-6193c50246ee.png" style="width:44.17em;height:18.00em;"/></p>
<p class="mce-root">And so in the module call, use the <kbd>Version</kbd> property with the chosen version number.</p>
<p class="mce-root">Note that, like all modules or community packages, you must check that their code is clean and secure before using them by <span>manually </span>reviewing the code inside their GitHub repository. Indeed, in each of these modules, there is a link to the GitHub repository, which contains the sources.</p>
<div class="mce-root packt_infobox">In the <em>Sharing a Terraform module using GitHub</em> recipe of this chapter, we will see how to publish a module in the public registry.</div>
<p class="mce-root">Also, before using a module in a company project, you must take into account that in case of a request for correction or evolution of a module, you need to create an issue or make a pull request in the GitHub repository of this module. This requires waiting for a period of time (validation waiting time and merge of the pull request) before it can be used with the fixed or the requested evolution.</p>
<p class="mce-root">However, it's worth using these modules daily, as they are very handy and save a lot of time for demonstrations, labs, and sandbox projects.</p>
<div class="mce-root packt_infobox">We have seen the use of the public registry in this recipe; we will study in <a href="7a338622-bf1e-4c4b-9c08-88eb36f079da.xhtml">Chapter 8</a>, <em>Using Terraform Cloud to Improve Collaboration</em>, how to use a private registry of modules in Terraform.</div>
<h2 id="uuid-cf8a62c4-a0c3-4638-8a60-fd42155ce907">See also</h2>
<p>The documentation on the Terraform module registry is available at <a href="https://www.terraform.io/docs/registry/">https://www.terraform.io/docs/registry/</a>.</p>
<h1 id="uuid-7de4c811-21d5-49e5-bcdd-dc4d11f8bbd2">Sharing a Terraform module using GitHub</h1>
<p>In the <em>Creating a Terraform module and using it locally</em> <span>recipe </span>of this chapter, we studied how to create a module and in the previous recipe, <em>Using a module from the public registry</em>, of this chapter, how to use a module from the public registry.</p>
<p class="mce-root">In this recipe, we'll see how to publish a module in the public registry by storing its code on GitHub.</p>
<h2 id="uuid-a33d3cb4-6485-42c9-8268-491b5bfdef54">Getting ready</h2>
<p>To apply this recipe, we need to have a GitHub account (which is currently the only Git provider available for publishing public modules) that you can create here: <a href="https://github.com/join">https://github.com/join</a>. Also, you'll need to know the basics of Git commands and workflow (<a href="https://www.hostinger.com/tutorials/basic-git-commands">https://www.hostinger.com/tutorials/basic-git-commands</a>).</p>
<p class="mce-root">Concerning the code of the module we are going to publish, we will use the code of the module we created in the first recipe of this chapter, the sources of which are available at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/moduledemo/Modules/webapp">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/moduledemo/Modules/webapp</a>.</p>
<h2 id="uuid-a914a3fb-eae1-4351-81cd-ce5798c8311f">How to do it…</h2>
<p>To share our custom module in the public registry, perform the following steps:</p>
<ol>
<li>In our GitHub account, create a new repository named <kbd>terraform-azurerm-webapp</kbd> with basic configuration, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b3a6fec8-43ca-4401-a3ff-e70af59eedb1.png" style="width:47.50em;height:39.83em;"/></p>
<ol start="2">
<li>In the local workstation, execute the Git command to clone this repository:</li>
</ol>
<pre style="padding-left: 60px"><strong>git clone https://github.com/mikaelkrief/terraform-azurerm-webapp.git</strong></pre>
<ol start="3">
<li>Copy the sources code from <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/moduledemo/Modules/webapp">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/moduledemo/Modules/webapp</a> and paste it inside the<span> new folder created by the <kbd>git clone</kbd> command.</span></li>
<li>Update the content of the <kbd>Readme.md</kbd> file with more description of the module role.</li>
<li>Commit and push all files in this folder; to perform this action, you can use Visual Studio Code or Git commands (<kbd>commit</kbd> and <kbd>push</kbd>)</li>
<li>Add and push a Git tag on this commit with the name <kbd>v0.0.1</kbd>, by executing this command:</li>
</ol>
<pre style="padding-left: 60px"><strong>git tag v1.0.0</strong><br/><strong>git push origin v1.0.0</strong> </pre>
<ol start="7">
<li>In a web browser, go to the URL <a href="https://registry.terraform.io/">https://registry.terraform.io/</a>.</li>
<li>On this page, click on the <span class="packt_screen">Sign-in</span> link on the top menu:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5634bdda-72b1-4500-8c03-bfe84d503226.png" style="width:63.25em;height:4.17em;"/></p>
<ol start="9">
<li>On the newly opened window, click on the <span class="packt_screen">Sign in with GitHub</span> button, and if prompted, authorize HashiCorp to read your repositories:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f29e1357-63dd-40f0-aac8-e7aaa4d98800.png" style="width:21.25em;height:16.33em;"/></p>
<ol start="10">
<li>Once authenticated, click on the <span class="packt_screen">Publish</span> link on the top menu:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ce25e395-258e-4263-a602-4f7bfe13370b.png" style="width:52.75em;height:4.25em;"/></p>
<ol start="11">
<li>On the next page, select the <span class="packt_screen">mikaelkrief/terraform-azurerm-webapp</span> <span>repository, </span>which contains the code of the module to publish, and check the <span class="packt_screen">I agree to the Terms of Use</span> checkbox:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7bd318aa-446e-4c20-81f8-af18d58b2b99.png" style="width:35.83em;height:22.50em;"/></p>
<ol start="12">
<li>Click on the <span class="packt_screen">PUBLISH MODULE</span> button and wait for the module page to load.</li>
</ol>
<h2 id="uuid-e258b8bb-58e7-4916-9417-45f8182dc1d3">How it works…</h2>
<p>In <em>steps 1</em> and <em>2</em>, we created a Git repository in GitHub and cloned it locally, and in <em>steps 3</em> to <em>6</em>, we wrote the Terraform configuration for the module (using an existing code). We also edited the <kbd>Readme.md</kbd> file that will be used as documentation to use the module.</p>
<p>Then, we made a commit and pushed this code in the remote Git repository, and we added a tag that will be in the form <kbd>vX.X.X</kbd> and will be used to version the module.</p>
<p>Finally, in <em>steps 7</em> to <em>12</em>, we published this module in the public registry, by logging in with our GitHub credentials in the registry and then selecting the repository that contains the module code.</p>
<p class="mce-root">The registry automatically detects the version of the module in relation to the Git tag that was pushed (in <em>step 6</em>).</p>
<p class="mce-root">After all of these steps, the module is available in Terraform's public registry, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/25926ff4-cb3c-49ce-935d-100cdec2f059.png" style="width:59.92em;height:15.83em;"/></p>
<p class="mce-root">The module is publicly accessible; the instructions for use are displayed in the right panel and the <kbd>Readme.md</kbd> text is displayed as documentation in the content of the page.</p>
<h2 id="uuid-dc4ee64a-9a3e-4026-a890-822fdc77e746">There's more…</h2>
<p>Concerning the name of the repository that will contain the module code, it must be composed as follows:</p>
<pre>terraform-&lt;provider&gt;-&lt;name&gt;</pre>
<p>Similarly, for the Git tag, it must be in the form <kbd>vX.X.X</kbd> to be integrated into the registry. To learn more about module resumes, see the documentation: <a href="https://www.terraform.io/docs/registry/modules/publish.html#requirements">https://www.terraform.io/docs/registry/modules/publish.html#requirements</a>.</p>
<p class="mce-root">Once published, it is possible to delete a module by choosing <span class="packt_screen">Delete module</span> from the <span class="packt_screen">Manage Module</span> drop-down list:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ead4f621-5465-4017-b9f3-12edecb517c4.png" style="width:51.00em;height:19.67em;"/></p>
<p class="mce-root">Be careful: after deleting it from the registry, the module becomes unusable.</p>
<h2 id="uuid-912522a7-ba44-4d12-b1ef-4dc2ca401f37">See also</h2>
<ul>
<li>Module publishing documentation is available here: <a href="https://www.terraform.io/docs/registry/modules/publish.html">https://www.terraform.io/docs/registry/modules/publish.html</a>.</li>
<li class="mce-root">Documentation on the Registry APIs is available here: <a href="https://www.terraform.io/docs/registry/api.html">https://www.terraform.io/docs/registry/api.html</a>.</li>
</ul>
<h1 id="uuid-99801621-3089-4f8a-8428-2d945c9c1778">Using another file inside a custom module</h1>
<p>In the <em>Creating Terraform module and using it locally</em> recipe of this chapter, we studied the steps to create a basic Terraform module.</p>
<p class="mce-root">We can have scenarios where we need to use another file <span>in the module </span>that <span>doesn't describe the infrastructure via Terraform </span>(<kbd>.tf</kbd> extension), for example, in the case where the module needs to execute a script locally for operating an internal program.</p>
<p class="mce-root">In this recipe, we will study how to use another file in a Terraform module.</p>
<h2 id="uuid-fca13578-65af-4cf2-8eec-b032b3f46056">Getting ready</h2>
<p>For this recipe, we don't need any prerequisites; we will write the Terraform configuration for the module from scratch.</p>
<p class="mce-root">The goal of this recipe is to create a Terraform module that will execute a Bash script that will perform actions on the local computer (for this recipe, a <kbd>hello world</kbd> display will suffice).</p>
<p class="mce-root">Since we will be running a Bash script as an example, we will run Terraform under a Linux system.</p>
<div class="packt_infobox"><span>It is important to keep in mind that provisioners such as this reduce the reusability of your configuration by assuming that the system where Terraform runs has Bash installed. This is otherwise usually not a limiting factor in Terraform as it offers builds for different OSes and architectures and runs cross-platform.</span></div>
<p>The source code of the created module in this recipe is available here: <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/moduledemo/Modules/execscript">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/moduledemo/Modules/execscript</a>.</p>
<h2 id="uuid-1f42f9dd-0f2f-4576-baa3-30a077782514">How to do it…</h2>
<p>Perform the following steps to use the file inside the module:</p>
<ol>
<li>In a new folder called <kbd>execscript</kbd> (inside the <kbd>Modules</kbd> folder) that will contain the code of the module, we create a new file, <kbd>script.sh</kbd>, with the following content:</li>
</ol>
<pre style="padding-left: 60px"><span>echo </span><span>"Hello world"</span></pre>
<ol start="2">
<li>Create a <kbd>main.tf</kbd> file in this module and write the following code inside it:</li>
</ol>
<pre style="padding-left: 60px"><span>resource </span><span>"null_resource" </span><span>"execfile" </span>{<br/>  <span>provisioner </span><span>"local-exec" </span>{<br/>    <span>command </span>= <span>"${</span><strong><span>path.</span><span>module</span></strong><span>}/script.sh"<br/></span><span>    </span><span>interpreter </span>= [<span>"/bin/bash"</span>]<br/>  }<br/>}</pre>
<ol start="3">
<li>Then, in the Terraform configuration, call this module using the following code:</li>
</ol>
<pre style="padding-left: 60px"><span>module </span><span>"execfile" </span>{<br/>  <span>source </span>= <span>"../Modules/execscript"<br/></span>}</pre>
<ol start="4">
<li>Finally, in a command-line terminal, navigate to the folder of the Terraform configuration and execute the basic Terraform workflow with the following commands:</li>
</ol>
<pre style="padding-left: 60px"><strong>terraform init</strong><br/><strong>terraform plan -out="app.tfplan"</strong><br/><strong>terraform apply app.tfplan</strong></pre>
<h2 id="uuid-478188b0-2c6e-4fc8-93c6-06eeaf26958f">How it works…</h2>
<p>In <em>steps 1</em> and <em>2</em>, we created a module that executes a script locally using the resource, <kbd>local_exec</kbd> (<a href="https://www.terraform.io/docs/provisioners/local-exec.html">https://www.terraform.io/docs/provisioners/local-exec.html</a>).</p>
<p><kbd>local_exec</kbd> executes a script that is in a <kbd>script.sh</kbd> file that is stored inside the module. To configure the path relative to this <kbd>script.sh</kbd> file, which can be used during the execution of Terraform, we used the <span><kbd>path.module</kbd> </span>expression, which returns the complete path relative to the module.</p>
<p class="mce-root">Then, in <em>step 3</em>, we wrote the Terraform configuration that calls this module. Finally, in <em>step 4</em>, we run Terraform on this code and we get the following result:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1a6cc0f5-b01a-4979-b71b-1c0babb545a8.png" style="width:41.42em;height:22.00em;"/></p>
<p class="mce-root">You can see that the script executed successfully and it displays <kbd>Hello World</kbd> in the console.</p>
<h2 id="uuid-d12539cb-d17d-45cb-8a6b-49a69444235f">There's more…</h2>
<p>Let's see what would happen if we hadn't used the <span><kbd>path.module</kbd> </span>expression in the code of this module and we had written the module code in the following way:</p>
<pre><span>resource </span><span>"null_resource" </span><span>"execfile" </span>{<br/>  <span>provisioner </span><span>"local-exec" </span>{<br/>    <span>command </span>= <span>"</span><span>script.sh"<br/></span><span>    </span><span>interpreter </span>= [<span>"/bin/bash"</span>]<br/>  }<br/>}</pre>
<p class="mce-root">When executing the <kbd><span>apply</span></kbd> command, the following error would have occurred:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6d27804a-779a-47c3-bc2f-f5cd0bffb60d.png" style="width:41.75em;height:6.67em;"/></p>
<p class="mce-root">This is because Terraform runs in the <kbd>main.tf</kbd> file, which does not have access to the <kbd>relatif</kbd> path of the <kbd>script.sh</kbd> file in the module directory.</p>
<h2 id="uuid-5e89298e-ea2c-4e83-9c14-69d2b0d2c853">See also</h2>
<p>Documentation on the <kbd>Path.Module</kbd> <span>expression </span><span>is available here: </span><a href="https://www.terraform.io/docs/configuration/expressions.html#references-to-named-values">https://www.terraform.io/docs/configuration/expressions.html#references-to-named-values</a><span>.</span></p>
<h1 id="uuid-f42c282b-40d4-400b-8869-bdca859cf64c">Using the Terraform module generator</h1>
<p><span>We learned how to create, use, and share a Terraform module and we studied</span> the module's <span>files structure </span>good practices, which consists of having a main file, another for variables, and another that contains the outputs of the module. In the <em>Sharing a Terraform module using GitHub</em> <span>recipe, we also discussed </span>that we could document the use of the module with a <kbd>Readme.md</kbd> file.</p>
<p class="mce-root">Apart from these standard files for the operation of the module, we can also add scripts, tests (which we will see in the <em>Testing Terraform module code with Terratest </em><span>recipe</span>), and other files.</p>
<p class="mce-root">For company projects with large infrastructures and a lot of resources to be provided with Terraform, we will need to create a lot of Terraform modules.</p>
<p class="mce-root">To facilitate the creation of the structure of the modules, Microsoft has published a tool that allows us to generate the basic structure (also called a <strong>template</strong>) of a Terraform module.</p>
<p class="mce-root">In this recipe, we will see how to create the base of a module using the module generator.</p>
<h2 id="uuid-d484be23-9d9f-4878-be52-efa95ee17409">Getting ready</h2>
<p>The software prerequisites to use this module generator are in the following order:</p>
<ol>
<li>Install Node.js (6.0+) locally; its download documentation is available at <a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a>.</li>
<li>Then install the <kbd>npm</kbd> package, Yeoman (<a href="https://www.npmjs.com/package/yo">https://www.npmjs.com/package/yo</a>), by executing the following command:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>npm install -g yo<br/></strong></pre>
<p class="mce-root">To illustrate this recipe, we will use this generator to create the structure of a module that will be in charge of provisioning a Resource Group.</p>
<p>A sample of the generated module from this recipe is available at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/generatedmodule">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/generatedmodule</a>.</p>
<h2 id="uuid-43cef891-2a1d-475e-8c72-2ab7f84a655e">How to do it…</h2>
<p>To generate a structure for a Terraform module perform the following steps:</p>
<ol>
<li>In a command-line terminal, execute the command:</li>
</ol>
<pre style="padding-left: 60px"><strong>npm install -g generator-az-terra-module</strong></pre>
<ol start="2">
<li>Create a new folder with the name of the module as <kbd>terraform-azurerm-rg</kbd>.</li>
<li> Then, in this folder, in the command-line terminal, execute this command:</li>
</ol>
<pre style="padding-left: 60px"><strong>yo az-terra-module</strong></pre>
<ol start="4">
<li>Finally, the generator will ask some questions; type the responses like this following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8b5e3dd2-1dbb-4b0c-bac8-461c44db7382.png" style="width:34.58em;height:9.92em;"/></p>
<h2 id="uuid-aebd4335-fbea-4122-9f80-66a282f420ca">How it works…</h2>
<p>In <em>step 1</em>, we installed the module generator, which is an <kbd>npm</kbd> package called <kbd>generator-az-terra-module</kbd>. So we used the classical <kbd>npm</kbd> command line, which installs a package globally, that is to say, for the whole machine.</p>
<p class="mce-root">In <em>step 2</em>, we created the folder that will contain the code of the module; for our recipe, we used the nomenclature required by the Terraform registry.</p>
<p class="mce-root">In <em>steps 3 and 4</em>, we executed the <kbd>az-terra-module</kbd> generator. During its execution, this generator asks the user questions that will allow the customization of the module template that will be generated. The first question concerns the name of the module. The second one concerns the existence of the module in <kbd>npm</kbd>; we answered <kbd>No</kbd>. Then, the next three questions concern the module metadata. Finally, the last question is to know whether we want to add to the module code a Dockerfile that will be used to run the tests on the module—we answer <kbd>Yes</kbd>.</p>
<p class="mce-root">At the end of all of these questions, the generator copies all of the files necessary for the module in our directory:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8f924608-681f-47a0-92fa-5941ad9149e3.png" style="width:36.58em;height:36.75em;"/></p>
<p class="mce-root">As you can see in this screen, the generator displays in the terminal the list of folders and files that have been created.</p>
<p class="mce-root">Finally, in our file explorer, we can actually see all of these files:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fccd8fd0-fd81-42d0-86d1-1e11a14e4b99.png" style="width:10.08em;height:32.67em;"/></p>
<p class="mce-root">The basic structure of our Terraform module is well generated.</p>
<h2 id="uuid-f1d7dda0-d115-4d4f-a10c-4014117d5b34">There's more…</h2>
<p>In this recipe, we have seen that it is possible to generate the file structure of a Terraform module. At the end of the execution of this generator, the directory of the created module contains the Terraform files of the module, which will be edited afterward with the code of the module. This folder will also contain other test files and a Dockerfile whose usefulness we will see in the <em>Testing a Terraform module with Terratest</em> <span>recipe </span>of this chapter.</p>
<p class="mce-root">Also, although this generator is published by Microsoft, it can be used to generate the structure of any Terraform modules you need to create even if it does not provide anything in Azure.</p>
<h2 id="uuid-4b65ed29-2196-4649-b026-682705255230">See also</h2>
<ul>
<li>The source code for the module generator is available on GitHub at <a href="https://github.com/Azure/generator-az-terra-module">https://github.com/Azure/generator-az-terra-module</a>.</li>
<li class="mce-root">Documentation on the use of the generator is available at <a href="https://docs.microsoft.com/en-us/azure/developer/terraform/create-a-base-template-using-yeoman">https://docs.microsoft.com/en-us/azure/developer/terraform/create-a-base-template-using-yeoman</a>.</li>
<li class="mce-root">Yeoman documentation is available at <a href="https://yeoman.io/">https://yeoman.io/</a>.</li>
<li class="mce-root">The <kbd>npm</kbd> package of the generator is available at <a href="https://www.npmjs.com/package/generator-az-terra-module">https://www.npmjs.com/package/generator-az-terra-module</a>.</li>
</ul>
<h1 id="uuid-b541e779-a6b1-4f72-aca1-19ad91c9df32">Generating module documentation</h1>
<p>We have learned from the previous recipes that in the composition of a Terraform module we have input variables, as well as outputs.</p>
<p class="mce-root">As with all packages that are made available to other teams or even publicly, it is very important to document your Terraform module.</p>
<p class="mce-root">The problem with this documentation is that it is tedious to update the document with each change and therefore quickly becomes obsolete.</p>
<p class="mce-root">Among all of the tools in the Terraform toolbox, there is <kbd>terraform-docs</kbd>, an open source, cross-platform tool that allows the documentation of a Terraform module to be generated automatically.</p>
<p class="mce-root">We will discuss in this recipe how to automatically <span>generate</span> the markdown documentation of a module with <kbd>terraform-docs</kbd>.</p>
<h2 id="uuid-6ef21fa1-77da-4e82-91b3-2c02451ede4e">Getting ready</h2>
<p>For this recipe, we are going to generate the documentation of the module we created in the <em>Creating a Terraform module and using it locally</em> recipe of this chapter, which allowed us to create a web app in Azure, the sources of which are here: <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/moduledemo/Modules/webapp">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/moduledemo/Modules/webapp</a>.</p>
<p class="mce-root">If you are working on a Windows OS, you will need to install <strong>Chocolatey</strong> by following this documentation: <a href="https://chocolatey.org/install">https://chocolatey.org/install</a>. The documentation we will generate for the <kbd>webapp</kbd> module is available at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP05/moduledemo/Modules/webapp/Readme.md">https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP05/moduledemo/Modules/webapp/Readme.md</a>.</p>
<h2 id="uuid-066e4ab4-5db0-421f-9ec3-c13d50a148fe">How to do it…</h2>
<p>Perform the following steps to generate the module documentation:</p>
<ol>
<li>If you work on a Linux OS, execute the following script in a command-line terminal:</li>
</ol>
<pre style="padding-left: 60px"><strong>curl -L https://github.com/segmentio/terraform-docs/releases/download/v0.9.1/terraform-docs-v0.9.1-linux-amd64 -o terraform-docs-v0.9.1-linux-amd64</strong><br/><strong>tar -xf terraform-docs-v0.9.1-linux-amd64</strong><br/><strong>chmod u+x terraform-docs-v0.9.1-linux-amd64</strong><br/><strong>sudo mv terraform-docs-v0.9.1-linux-amd64 /usr/local/bin/terraform-docs</strong></pre>
<p style="padding-left: 60px">If you work on a Windows OS, execute the following script:</p>
<pre style="padding-left: 60px"><strong>choco install terraform-docs -y</strong></pre>
<ol start="2">
<li>Execute the following script to test the installation:</li>
</ol>
<pre style="padding-left: 60px"><strong>terraform-docs --version</strong></pre>
<ol start="3">
<li>In a command-line terminal, navigate inside the <kbd>moduledemo</kbd> folder and execute the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>terraform-docs markdown Modules/webapp/ &gt; Modules/webapp/Readme.md</strong></pre>
<h2 id="uuid-b9a3a6b9-1b4b-4ebc-a175-74016b91bd02">How it works…</h2>
<p>In <em>step 1</em>, we install <kbd>terraform-docs</kbd> according to the operating system. For Linux, the provided script downloads the <kbd>terraform-docs</kbd> package from GitHub, decompresses it with the TAR tool, gives it execution rights with <kbd>chmod</kbd>, and finally copies it to the local directory, <kbd>/usr/bin/local</kbd> (which is already configured in the <kbd>PATH</kbd> environment variable).</p>
<p class="mce-root"/>
<p>The following screenshot shows the <span>installation in </span>Linux:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8f3b3fb7-3a62-47eb-97af-c58b812637ad.png"/></p>
<p class="mce-root">For Windows, the script uses the <kbd>choco install</kbd> command from <strong>Chocolatey</strong> to download the <kbd>terraform-docs</kbd> package.</p>
<p><span>The following screenshot shows the installation in Windows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5df811ca-9c44-4cec-9e0a-5fa57040dd0e.png"/></p>
<p class="mce-root">Then, in <em>step 2</em>, we check its installation by running <kbd>terraform-docs</kbd> and adding the <kbd>--version</kbd> option. This command displays the installed version of <kbd>terraform-docs</kbd>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a070d16a-6475-47ba-9c1c-396cb914f9ce.png"/></p>
<p class="mce-root">Finally, in <em>step 3</em>, we execute <kbd>terraform-docs</kbd> specifying in the first argument the type of format of the documentation. In our case, we want it in <kbd>markdown</kbd> format. Then, in the second argument, we specify the path of the <kbd>modules</kbd> directory. At this stage, we could execute the command this way and during its execution, the documentation is displayed in the console, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9e7a2608-68cd-49f2-a879-69582c8389f8.png"/></p>
<p class="mce-root">But to go further, we added the <kbd>&gt; Modules/webapp/Readme.md</kbd> command, which indicates that the content of the generated documentation will be written in the <kbd>Readme.md</kbd> file that will be created in the module directory.</p>
<p class="mce-root">At the end of the execution of this command, a new <kbd>Readme.md</kbd> file can be seen inside the module folder that contains the module documentation. The generated documentation is composed of the providers used in the module, the input variables, and the outputs.</p>
<h2 id="uuid-dc489c88-763f-4ed2-9734-e7912bcf120a">There's more…</h2>
<p>In our recipe, we chose to generate markdown documentation, but it is also possible to generate it in JSON, XML, YAML, or text (pretty) format. To do so, you have to add the format option to the <kbd>terraform-docs</kbd> command. To know more about the available generation formats, read the documentation here: <a href="https://github.com/segmentio/terraform-docs/blob/master/docs/FORMATS_GUIDE.md">https://github.com/segmentio/terraform-docs/blob/master/docs/FORMATS_GUIDE.md</a>.</p>
<p class="mce-root">You can also improve your processes by automating the generation of documentation by triggering the execution of <kbd>terraform-docs</kbd> every time you commit code in Git. For this, you can use a pre-commit Git Hook, as explained in the documentation here: <a href="https://github.com/segmentio/terraform-docs/blob/master/docs/USER_GUIDE.md#integrating-with-your-terraform-repository">https://github.com/segmentio/terraform-docs/blob/master/docs/USER_GUIDE.md#integrating-with-your-terraform-repository</a>.</p>
<p>Also, to get the latest version of <kbd>terraform-docs</kbd>, follow the release here: <a href="https://github.com/segmentio/terraform-docs/releases">https://github.com/segmentio/terraform-docs/releases</a>, as well as <kbd>CHANGELOG</kbd> here: <a href="https://github.com/segmentio/terraform-docs/blob/master/CHANGELOG.md">https://github.com/segmentio/terraform-docs/blob/master/CHANGELOG.md</a>, to see the changes.</p>
<div class="mce-root packt_infobox">If you want to publish your module in the Terraform registry as we have seen in the <em>Sharing a Terraform module using GitHub</em> <span>recipe </span>in this chapter, you do not need to generate this documentation because it is already included in the registry's functionalities.</div>
<h2 id="uuid-16c42246-415a-4db3-8bfa-61b7b9f46328">See also</h2>
<ul>
<li>Source code for <kbd>terraform-docs</kbd> is available here: <a href="https://github.com/segmentio/terraform-docs">https://github.com/segmentio/terraform-docs</a>.</li>
<li class="mce-root">The Chocolatey <kbd>terraform-docs</kbd> package page is available here: <a href="https://chocolatey.org/packages/Terraform-Docs">https://chocolatey.org/packages/Terraform-Docs</a>.</li>
</ul>
<h1 id="uuid-8bcb2e55-473f-411d-8ab1-65ea3b9530fe">Using a private Git repository for sharing a Terraform module</h1>
<p class="mce-root">In this chapter dedicated to Terraform modules, we have seen that it is possible to put the code of a module in a GitHub repository to publish it in the Terraform public registry.</p>
<p class="mce-root">However, in enterprises, there is a need to create modules without exposing the code of these modules publicly by archiving them in GitHub repositories, which are public, that is, accessible by everyone.</p>
<p class="mce-root">What you need to know is that there are several types of Terraform module sources, as indicated in this documentation: <a href="https://www.terraform.io/docs/modules/sources.html">https://www.terraform.io/docs/modules/sources.html</a>.</p>
<p class="mce-root">In this recipe, we will study how to expose a Terraform module through a private Git repository. That is to say, either this Git is installed internally (so-called on-premises) or in cloud mode, SaaS, but requires authentication.</p>
<h2 id="uuid-d45fca1b-23a2-457a-a12b-8670479d6a78">Getting ready</h2>
<p>For this recipe, we will use a Git repository in <strong>Azure Repos </strong>(Azure DevOps), which is free and requires authentication to access it. For more information and how to create a <span>free</span><span> </span><span>Azure DevOps account, go to</span> <a href="https://azure.microsoft.com/en-us/services/devops/">https://azure.microsoft.com/en-us/services/devops/</a><span>.</span></p>
<p>As a prerequisite, we need a project that has already been created; it can be named, for example, <kbd>Terraform-modules</kbd>, and it will contain the Git repository of all of the modules.</p>
<p class="mce-root">The next screenshot shows the form to create this Azure DevOps project:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f1b7b966-5572-46a0-94b1-3ababfa7a565.png" style="width:39.08em;height:33.42em;"/></p>
<div class="mce-root packt_infobox">The purpose of this recipe is not to focus on the use of Azure DevOps; we will use it just to have an example of a private repository.</div>
<p class="mce-root">You will also need to know the basics of the commands and workflow of Git: <a href="https://www.hostinger.com/tutorials/basic-git-commands">https://www.hostinger.com/tutorials/basic-git-commands</a>.</p>
<p class="mce-root">Concerning the code of the module that we are going to put in Azure Repos, we are going to use the code of the module that we created in the first recipe of this chapter, the source code for which is available here: <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/moduledemo/Modules/webapp">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/moduledemo/Modules/webapp</a>.</p>
<h2 id="uuid-4f69172f-561d-4f0e-aa20-f89baf1edbfc">How to do it…</h2>
<p>To use a private module repository, we need to perform the following steps:</p>
<ol>
<li>In the Azure DevOps project, <kbd>Terraform-modules</kbd>, create a new Git repository named <kbd>terraform-azurerm-webapp</kbd> with basic configuration, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bf2184cd-59b0-44b5-b8bd-ce42afa205e8.png" style="width:53.83em;height:25.67em;"/></p>
<ol start="2">
<li>In a local workstation, execute the Git command for cloning this repository:</li>
</ol>
<pre style="padding-left: 60px"><strong>git clone https://dev.azure.com/&lt;account&gt;/Terraform-modules/_git/terraform-azurerm-webapp</strong></pre>
<ol start="3">
<li>During the first operation, you will have to enter your Azure DevOps login and password for identification.</li>
</ol>
<ol start="4">
<li>Copy the source code from <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/moduledemo/Modules/webapp">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/moduledemo/Modules/webapp</a> and paste it the new folder created by the Git clone.</li>
<li>Update the content of the <kbd>Readme.md</kbd> file with more of a description of the module role.</li>
<li class="mce-root"><span>Commit and push all files in this folder; to perform this action, you can use VS Code or Git commands:</span></li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>git add .<br/>git commit -m "add code"</strong><br/><strong>git push origin master</strong></pre>
<ol start="7">
<li>Add and push a Git tag on this commit with the name, <kbd>v0.0.1</kbd>, by executing this command:</li>
</ol>
<pre style="padding-left: 60px"><strong>git tag v1.0.0</strong><br/><strong>git push origin v1.0.0</strong> </pre>
<div class="packt_infobox">This operation can also be done via the web interface of Azure Repos, in the <span class="packt_screen">Tags</span> tab of the repository.</div>
<ol start="8">
<li>Finally, in the Terraform <kbd>main.tf</kbd> file, the following code is written that uses the module:</li>
</ol>
<pre style="padding-left: 60px"><span>resource </span><span>"azurerm_resource_group" </span><span>"rg-app" </span>{<br/>  <span>name     </span>= <span>"RG_MyAPP_Demo2"<br/></span><span>  </span><span>location </span>= <span>"West Europe"<br/></span>}<br/><br/><span>module </span><span>"webapp" </span>{<br/>  <strong><span>source               </span>= </strong><span><strong>"git::https://dev.azure.com/BookLabs/Terraform-modules/_git/terraform-azurerm-webapp?ref=v1.0.0"</strong><br/></span><span>  </span><span>service_plan_name    </span>= <span>"spmyapp2"<br/></span><span>  </span><span>app_name             </span>= <span>"myappdemobook2"<br/></span><span>  </span><span>location             </span>= <span>azurerm_resource_group</span>.rg-app.<span>location<br/></span><span>  resource_group_name </span>= <span>azurerm_resource_group</span>.rg-app.<span>name<br/></span>}<br/><span>output </span><span>"webapp_url" </span>{<br/>  <span>value </span>= module.<span>webapp</span>.<span>webapp_url<br/></span>}</pre>
<h2 id="uuid-3ff8e723-1645-497f-b1aa-aaeca43b5d0d">How it works…</h2>
<p>In <em>steps 1</em> and <em>2</em>, we created a Git repository in Azure Repos and cloned it locally. Then, in <em>steps 3</em> to <em>7</em>, we wrote the Terraform configuration for the module (using an already existing code). We also edited the <kbd>Readme.md</kbd> file that will be used as a documentation for the use of the module. Then, we made a commit and pushed this code into the remote Git Azure repository. The following screenshot shows the remote repository in Azure Repos:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4805b372-65d4-4fbb-b6bf-0e44050f51fb.png"/></p>
<p class="mce-root">And finally, we added a Git tag, which will be in the form <kbd>vX.X.X</kbd> and which will be used to version the module.</p>
<p class="mce-root">Finally, in <em>step 8</em>, we wrote the Terraform configuration, which remotely uses this module with a Git type source. For this, we specified the <kbd>source</kbd> property of the module with the Git URL of the repository. In addition to this URL, we added the <kbd>ref</kbd> parameter to which we give as a value the Git tag we created.</p>
<p class="mce-root">It will be during the execution of the <kbd>terraform init</kbd> command that Terraform will clone the repository locally:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4e78e09e-fbd3-4fb6-ba58-74239f1689b1.png"/></p>
<p class="mce-root">The module code will be cloned into the Terraform context directory, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/794c0775-d955-42ae-8377-cf3219380985.png" style="width:17.58em;height:20.50em;"/></p>
<p>The <kbd>webapp</kbd> module is downloaded inside the <kbd>.terraform</kbd> folder.</p>
<h2 id="uuid-a48d51df-d016-406b-9a81-09734b51260f">There's more…</h2>
<p>In this recipe, the majority of the steps are identical to the ones already studied in the <em>Sharing a Terraform module using GitHub</em> recipe in which we stored the module code in GitHub and shared it in the public registry. The difference is that, in <em>step 8</em> of this recipe, we filled the value of the <kbd>source</kbd> property with the Git repository URL.</p>
<p class="mce-root">The advantages of using a private Git repository are, on the one hand, that it's only accessible by people who have permissions for that repository. On the other hand, in the <kbd>ref</kbd> parameter that we put in the module call URL, we used a specific version of the module using a Git tag. We can also perfectly name a specific Git branch, which is very useful when we want to evolve the module without impacting the master branch.</p>
<p class="mce-root">We could also very well store the module's code in a GitHub repository and fill the <kbd>source</kbd> properties with the GitHub repository URL, as shown in this documentation: <a href="https://www.terraform.io/docs/modules/sources.html#github">https://www.terraform.io/docs/modules/sources.html#github</a>.</p>
<p class="mce-root">In this recipe, we took a Git repository in Azure DevOps as an example, but it works very well with other Git repository providers such as Bitbucket (<a href="https://www.terraform.io/docs/modules/sources.html#bitbucket">https://www.terraform.io/docs/modules/sources.html#bitbucket</a>).</p>
<p class="mce-root">Regarding Git repository authentication, you can check out this documentation at <a href="https://www.terraform.io/docs/modules/sources.html#generic-git-repository">https://www.terraform.io/docs/modules/sources.html#generic-git-repository</a>, for information on access to and authentication of the Git repository in HTTPS or SSH.</p>
<h2 id="uuid-2bb5dc96-6d85-4fda-a979-1064ca1a39b3">See also</h2>
<p>The module source documentation is available here: <a href="https://www.terraform.io/docs/modules/sources.html">https://www.terraform.io/docs/modules/sources.html</a>.</p>
<h1 id="uuid-d65899e3-da92-47a5-8cbe-a961d0134833">Applying a Terrafile pattern for using modules</h1>
<p class="mce-root">We have seen throughout this chapter's recipes how to create Terraform modules and how to use them either locally or remotely with the public registry or Git repositories.</p>
<p class="mce-root">However, when you have a Terraform configuration that uses many modules, managing these modules can become complicated. This is indeed the case when the versions of these modules change; it is necessary to browse through all of the Terraform configurations to make version changes. Moreover, we do not have global visibility on all of the modules called in this Terraform configuration as well as their versions.</p>
<p class="mce-root">Analogous to the classic package managers (NPM and NuGet), a pattern has been exposed by several people that allows users to gather the configuration of the Terraform modules used in a Terraform configuration in a centralized file called a <strong>Terrafile</strong>.</p>
<p class="mce-root">In this recipe, we will study how to use the Terrafile pattern to manage the sources of the Terraform modules.</p>
<h2 id="uuid-7256d853-b62a-438a-91d6-b50c8887d31a">Getting ready</h2>
<p>For this recipe, we will use the Terraform source code that is already written and available here: <a href="https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP05/terrafile/initial/main.tf">https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP05/terrafile/initial/main.tf</a>. This Terraform configuration is at first classically configured—it calls several modules and in each of the calls to these modules, we use the source property with the GitHub repositories' URLs.</p>
<p class="mce-root">Moreover, we will execute a code written in Ruby with Rake (<a href="https://github.com/ruby/rake">https://github.com/ruby/rake</a>). For this, we need to have Ruby installed on our computer. The installation documentation is available here: <a href="https://www.ruby-lang.org/en/documentation/installation/">https://www.ruby-lang.org/en/documentation/installation/</a>. However, no prior Ruby knowledge is required; the complete script is provided in the source code of this recipe.</p>
<p class="mce-root">The goal of this recipe will be to integrate the Terrafile pattern in this code by centralizing the management of the modules to be used. The code source of this recipe is available at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/terrafile">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/terrafile</a>.</p>
<h2 id="uuid-a0334a76-7b69-448d-9723-3a660e074634">How to do it…</h2>
<p>Perform the following steps to use the Terrafile pattern:</p>
<ol>
<li>Copy the content of <kbd>main.tf</kbd> available at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP05/terrafile/initial/main.tf">https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP05/terrafile/initial/main.tf</a> inside a new folder<span>.</span></li>
<li>In this new folder<span>, create a new file called</span> <kbd>Terrafile</kbd> <span>(without an extension) with the following content:</span></li>
</ol>
<pre style="padding-left: 60px"><span>rg-master</span>:<br/>  <span>source</span>:  <span>"https://github.com/mikaelkrief/terraform-azurerm-resource-group.git"<br/></span><span>  </span><span>version</span>: <span>"master"<br/></span><span>webapp-1.0.0</span>:<br/>  <span>source</span>:  <span>"https://github.com/mikaelkrief/terraform-azurerm-webapp.git"<br/></span><span>  </span><span>version</span>: <span>"v1.0.0"<br/></span><span>network-3.0.1</span>:<br/>  <span>source</span>:  <span>"https://github.com/Azure/terraform-azurerm-network.git"<br/></span><span>  </span><span>version</span>: <span>"v3.0.1"<br/></span></pre>
<ol start="3">
<li>Create another new file, <kbd>Rakefile</kbd> (without an extension), with the following content (the complete source code is at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP05/terrafile/new/Rakefile">https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP05/terrafile/new/Rakefile</a>):</li>
</ol>
<pre style="padding-left: 60px">.....<br/>desc 'Fetch the Terraform modules listed in the Terrafile'<br/>task :get_modules do<br/>  terrafile = read_terrafile<br/>  create_modules_directory<br/>  delete_cached_terraform_modules<br/>  terrafile.each do |module_name, repository_details|<br/>    source  = repository_details['source']<br/>    version = repository_details['version']<br/>    puts "[*] Checking out #{version} of #{source} ...".colorize(:green)<br/>    Dir.mkdir(modules_path) unless Dir.exist?(modules_path)<br/>    Dir.chdir(modules_path) do<br/>       #puts "git clone -b #{version} #{source} #{module_name} &amp;&gt; /dev/null".colorize(:green)<br/>     <strong> 'git clone -q -b #{version} #{source} #{module_name}'</strong><br/>    end<br/>  end<br/>end</pre>
<ol start="4">
<li>In <kbd>main.tf</kbd>, update all source module properties with the following content:</li>
</ol>
<pre style="padding-left: 60px"><span>module </span><span>"resourcegroup" </span>{<br/>  <span>source </span>= <span>"./modules/rg-master"<br/></span><span> ...</span><span><br/></span>}<br/><br/><span>module </span><span>"webapp" </span>{<br/>  <span>source </span>= <span>"./modules/webapp-1.0.0"<br/></span><span>...<br/></span>}<br/><br/><span>module </span><span>"network" </span>{<br/>  <span>source </span>= <span>"./modules/network-3.0.1"<br/></span>...<br/>}</pre>
<ol start="5">
<li>In a command-line terminal, inside this folder, execute the following script:</li>
</ol>
<pre style="padding-left: 60px"><strong>bundle install</strong><br/><strong>rake get_modules<br/></strong></pre>
<h2 id="uuid-c8ff5167-2a74-493e-8da2-48c57d76c75c">How it works…</h2>
<p>The mechanism of the Terrafile pattern is that instead of using the Git sources directly in module calls, we reference them in a file in Terrafile YAML format. In the Terraform configuration, in the module call, we instead <span>use</span><span> </span><span>a local path relative to the</span> <kbd>modules</kbd> <span>folder. Finally, before executing the Terraform workflow, we execute a script that runs through this</span> <kbd>Terrafile</kbd> <span>file and will locally clone each of these modules referenced in its specific folder (which is in the module call).</span></p>
<p class="mce-root">In <em>step 1</em>, we created the <kbd>Terrafile</kbd> file, which is in YAML format and contains the repository of the modules we are going to use in the Terraform configuration. For each of the modules, we indicate the following:</p>
<ul>
<li class="mce-root">The name of the folder where the module will be copied</li>
<li class="mce-root">The URL of the Git repository of the module</li>
<li class="mce-root">Its version, which is the Git tag or its branch</li>
</ul>
<p class="mce-root">In <em>step 2</em>, we wrote the Ruby Rake script called Rakefile, which, when executed, will browse the Terrafile and will execute the <kbd>git clone</kbd> command on all modules into the specified folder.</p>
<p class="mce-root">Then, in <em>step 3</em>, we modify the Terraform configuration to call the modules, no longer with the Git URL but earlier with the relative path of their specified folder in the Terrafile.</p>
<p class="mce-root">Finally, in <em>step 4</em>, we execute the Rakefile script by calling the <kbd>get_modules</kbd> function of this script, which will make a Git clone of all of these modules in their folders.</p>
<p class="mce-root">Once these steps are done, we can execute the classic Terraform workflow commands with <kbd>init</kbd>, <kbd>plan</kbd>, and <kbd>apply</kbd>.</p>
<h2 id="uuid-b007b677-198d-40c1-b561-5112bb44a150">There's more…</h2>
<p>As we have learned in this recipe, we have created a <kbd>Terrafile</kbd> file that serves as a repository for the modules we will use in our Terraform configuration. It allows for better management and maintenance of the modules and versions to be used.</p>
<p class="mce-root"/>
<p class="mce-root">In this Terrafile, for each module, we have specified its destination folder, and as you can see, we have added the version number in the folder name. Hence, the name of the folder is unique and will allow us to use several versions of the same module in the Terraform configuration. The following code shows an extract of a Terrafile with two different versions of the same module:</p>
<pre><span>network-3.0.1</span>:<br/>  <span>source</span>:  <span>"https://github.com/Azure/terraform-azurerm-network.git"<br/></span><span>  </span><span>version</span>: <span>"v3.0.1"<br/></span><span>network-2.0.0</span>:<br/>  <span>source</span>:  <span>"https://github.com/Azure/terraform-azurerm-network.git"<br/></span><span>  </span><span>version</span>: <span>"v2.0.0"</span></pre>
<p class="mce-root">Also, it allows you to specify, if necessary, the authorized Git credentials to clone the module code. Be careful, however, not to write passwords in this file, which will be archived in a Git repository.</p>
<p class="mce-root">In this recipe, the Rakefile script was provided and is available in the original article of the Terrafile pattern (<a href="https://bensnape.com/2016/01/14/terraform-design-patterns-the-terrafile/">https://bensnape.com/2016/01/14/terraform-design-patterns-the-terrafile/</a>). You are free to adapt it according to your needs.</p>
<p class="mce-root">Finally, the essentials of the Terrafile pattern is not the script, the language, or the format used but, rather, its working principle. There are <span>alternative</span><span> </span><span>scripts and tools to th</span>is Rakefile with<span>, for example, a Python script available at </span><a href="https://github.com/claranet/python-terrafile">https://github.com/claranet/python-terrafile</a>, <span>or a tool written in Go available at </span><a href="https://github.com/coretech/terrafile">https://github.com/coretech/terrafile</a><span>.</span></p>
<h2 id="uuid-c74fca18-f2d9-419c-ab35-48288b26b509">See also</h2>
<ul>
<li>The main reference article on the Terrafile pattern is available here: <a href="https://bensnape.com/2016/01/14/terraform-design-patterns-the-terrafile/">https://bensnape.com/2016/01/14/terraform-design-patterns-the-terrafile/</a>.</li>
<li class="mce-root">The Python Terrafile package is available here: <a href="https://pypi.org/project/terrafile/">https://pypi.org/project/terrafile/</a> <a href="https://pypi.org/project/terrafile/">and its use is described here</a> <a href="https://github.com/claranet/python-terrafile">https://github.com/claranet/python-terrafile</a>.</li>
<li class="mce-root">The Terrafile tool written in Go is available here: <a href="https://github.com/coretech/terrafile">https://github.com/coretech/terrafile</a>.</li>
</ul>
<h1 id="uuid-e258952d-c4ee-4de4-a2d2-3a093d826fa4">Testing Terraform module code with Terratest</h1>
<p>When developing a Terraform module that will be used in multiple Terraform configurations and shared with other teams, there is one step that is often neglected and that is the testing of the module.</p>
<p class="mce-root">Among the Terraform framework and testing tools is the <strong>Terratest</strong> framework, created by the <em>Gruntwork</em> community (<a href="https://gruntwork.io/static/">https://gruntwork.io/static/</a>), which is popular and allows testing on code written in the Go language.</p>
<p class="mce-root">In this recipe, we will study how to use Terratest to write and run integration tests on Terraform configuration and modules in particular.</p>
<h2 id="uuid-8b96647d-20ab-4204-b23a-93ab0e1b67cf">Getting ready</h2>
<p>The <strong>Terratest</strong> test framework is written in Golang (Go language) and the tests run on the Go runtime. That's why, as a prerequisite, we need to install Go by going to <a href="https://golang.org/">https://golang.org/</a>.</p>
<div class="packt_infobox">The minimum Go version required for Terratest is specified here: <a href="https://terratest.gruntwork.io/docs/getting-started/quick-start/#requirements">https://terratest.gruntwork.io/docs/getting-started/quick-start/#requirements</a>.</div>
<p>Here are some important steps to install Go: for the Windows OS, you can install the Golang package using Chocolatey (<a href="https://chocolatey.org/packages/golang">https://chocolatey.org/packages/golang</a>) by executing this command:</p>
<pre><strong>choco install golang -y</strong></pre>
<p class="mce-root">For the Linux OS, run the following script:</p>
<pre><strong>GOLANG_VERSION=<span>"1.14.6"<br/></span>GOLANG_OS_ARCH=linux-amd64</strong><br/><br/><strong><span>mkdir </span><span>"</span>$HOME<span>/go"<br/></span><span>mkdir </span><span>"</span>$HOME<span>/go/bin"<br/></span><span>mkdir </span><span>"</span>$HOME<span>/go/src"<br/></span><span><br/></span><span>curl </span>-Os https://storage.googleapis.com/golang/go<span>$</span>{GOLANG_VERSION}.<span>$</span>{GOLANG_OS_ARCH}.tar.gz <span>&gt;</span>/dev/null <span>2</span>&gt;&amp;<span>1 </span><span>&amp;&amp;<br/></span><span> </span><span>tar </span>-zxvf go<span>$</span>{GOLANG_VERSION}.<span>$</span>{GOLANG_OS_ARCH}.tar.gz -C /usr/local/ <span>&gt;</span>/dev/null</strong><br/><br/><span># Refresh Go environment.<br/></span><strong><span>export </span>GOPATH=<span>"</span>$HOME<span>/go"<br/></span><span>export </span>PATH=<span>"/usr/local/go/bin:</span>$GOPATH<span>/bin:</span>$PATH</strong><span><strong>"</strong></span><span><br/></span></pre>
<p class="mce-root">The preceding script creates the workspace directories of Go (<kbd>bin</kbd> and <kbd>src</kbd>), then downloads the Go SDK, and sets the environment variables, <kbd>GOPATH</kbd> and <kbd>PATH</kbd>. </p>
<div class="mce-root packt_infobox">If you are on Linux, you will also need the <kbd>gcc</kbd> package that you can install by running the <kbd>apt install gcc</kbd> command.</div>
<p class="mce-root">The goal of this recipe is to write the integration tests for a very simple module that we will also write in this recipe to serve as a demonstration.</p>
<p class="mce-root">The source code of this chapter with the module and its test is available here: <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/testing-terratest">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/testing-terratest</a>.</p>
<h2 id="uuid-9254746a-da0d-4ece-a9e9-2d1e7e10e2f0">How to do it…</h2>
<p>This recipe is in two parts. The first part concerns the writing of the module and its tests and the second part concerns the execution of the tests.</p>
<p class="mce-root">To write the module and its tests, we perform the following steps:</p>
<ol>
<li class="mce-root">We create a new <kbd>module</kbd> folder that will contain the Terraform configuration of the module.</li>
<li class="mce-root"><span>In this</span> <kbd>module</kbd> <span>folder, we create a</span> <kbd>main.tf</kbd> <span>file, which contains the following code:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">variable "string1" {}<br/><br/>variable "string2" {}<br/><br/>## PUT YOUR MODULE CODE<br/>##_____________________<br/><br/></pre>
<pre style="color: black;padding-left: 60px">output "stringfct" {<br/>  value = format("This is test of %s with %s", var.string1, upper(var.string2))<br/>}</pre>
<ol start="3">
<li class="mce-root">In this <kbd>module</kbd> folder, we create the <kbd>fixture</kbd> folder inside a <kbd>test</kbd> folder.</li>
<li class="mce-root"><span>Then, in this</span> <kbd>fixture</kbd> <span>folder, we create a</span> <kbd>main.tf</kbd> <span>file, which contains the following Terraform configuration:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">module "demo" {<br/>  source  = "../../"<br/>  string1 = "module"<br/>  string2 = "terratest"<br/>}<br/><br/>output "outmodule" {<br/>  value = module.demo.stringfct<br/>}</pre>
<ol start="5">
<li>In the test folder, we create a <kbd>test_module.go</kbd> file, which contains the following code:</li>
</ol>
<pre style="padding-left: 60px"><span>package </span>test<br/><br/><span>import </span>(<br/>   <span>"</span>testing<span>"<br/></span><span>   "</span>github.com/gruntwork-io/terratest/modules/terraform<span>"<br/></span><span>   "</span>github.com/stretchr/testify/assert<span>"<br/></span>)<br/><br/><span>func</span> TestTerraformModule(t <span>*</span>testing.T) {<br/>   terraformOptions <span>:= &amp;</span>terraform.Options{<br/>      <span>// path to the terraform configuration<br/></span>      TerraformDir: <span>"./fixture"</span>,<br/>   }<br/><br/>   <span>// lean up resources with "terraform destroy" at the end of the test.<br/></span><span>   </span><span>defer</span> terraform.Destroy(t, terraformOptions)<br/><br/>   <span>// Run "terraform init" and "terraform apply". Fail the test if there are any errors.<br/></span>   terraform.InitAndApply(t, terraformOptions)<br/><br/>   <span>// Run `terraform output` to get the values of output variables and check they have the expected values.<br/></span><span>   </span>output <span>:=</span> terraform.Output(t, terraformOptions, <span>"outmodule"</span>)<br/>   assert.Equal(t, <span>"This is test of module with TERRATEST"</span>, output)<br/>}</pre>
<p class="mce-root">To execute the tests, we perform the following steps:</p>
<ol>
<li class="mce-root"><span>The first step is to download the</span> <kbd>terratest</kbd> <span>Go package by executing the following command:</span></li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>go get github.com/gruntwork-io/terratest/modules/terraform</strong></pre>
<ol start="2">
<li>Then, in the directory that contains the <span><kbd>test_module.go</kbd> file</span>, we execute this command:</li>
</ol>
<pre style="padding-left: 60px"><strong>go test -v</strong></pre>
<h2 id="uuid-0522e87b-e75e-40c5-8b7d-13f8564af465">How it works…</h2>
<p>In the first part of this recipe, we worked on the development of the module and its tests with the Terratest framework. In <em>step 2</em>, we wrote the module's code, which is extremely simple and focuses on the module's output. In <em>step 3</em>, in the <kbd>fixture</kbd> folder, we wrote a Terraform configuration that uses the module locally and that we will use to test it. What is important in this configuration is to have an output in the module. Indeed, in Terratest, we will use the outputs to test that the module correctly returns the correct expected value.</p>
<p class="mce-root">In <em>step 4</em>, we write the module tests in a file written in Golang. The code is composed as follows: in the first lines of this code, we import the libraries needed to run the tests, including the <kbd>terratest</kbd> and <kbd>assert</kbd> libraries. Then, we create a <kbd>TestTerraformModule</kbd> function, which takes <kbd>testing.T</kbd> <span>as</span><span> a </span><span>parameter, which</span><span> is a Go pointer that indicates that it is a test code.</span></p>
<p class="mce-root">Following are the details of the code of this function, which is composed of five lines of code.</p>
<p><span>In the first line, we define the test options with the folder containing the Terraform configuration that will be executed during the tests:</span></p>
<pre>terraformOptions <span>:= &amp;</span>terraform.Options{<br/>   <span>// path to the terraform configuration<br/></span>   TerraformDir: <span>"./fixture"</span>,<br/>}</pre>
<p class="mce-root">Then, we define the <kbd>terrafom.Destroy</kbd> <span>function, which </span>allows us to execute the <kbd>terraform destroy</kbd> command at the end of the tests, as described in the following code:</p>
<pre><span>defer</span> terraform.Destroy(t, terraformOptions)</pre>
<p class="mce-root">Then, we call the <kbd>terraform.InitAndApply</kbd> <span>function, </span>which allows us to execute the <kbd>terraform init</kbd> and <kbd>apply</kbd><span> </span><span>commands</span><span>, as described in the following code:</span></p>
<pre>terraform.InitAndApply(t, terraformOptions)</pre>
<p class="mce-root">After executing the <kbd>apply</kbd> command, we will retrieve the value of the output, which is called <kbd>outmodule</kbd>:</p>
<pre>output <span>:=</span> terraform.Output(t, terraformOptions, <span>"outmodule"</span>)</pre>
<p class="mce-root">Finally, we use <kbd>assert</kbd>, testing the previously recovered value of the output with the value we expect:</p>
<pre>assert.Equal(t, <span>"This is test of module with TERRATEST"</span>, output)</pre>
<p>Then, in the second part of this recipe, we work on the execution of the tests. The first step is to download the Terratest Go package with the <kbd>go get &lt;package source&gt;</kbd> command.</p>
<div class="packt_infobox">We can also run the <kbd>go get -v -t -d ./...</kbd> <span>command </span>to get all required package dependencies.</div>
<p>Then, inside the <kbd>test</kbd> folder, we run the tests by executing this command:</p>
<pre><strong>go test -v</strong></pre>
<p class="mce-root">During this execution, Terratest will carry out the following actions in order:</p>
<ol>
<li class="mce-root">Execute the <kbd>terraform init</kbd> and <kbd>terraform apply</kbd> commands on the Terraform test code located in the fixture folder.</li>
<li class="mce-root">Get the value of the <kbd>outmodule</kbd> output.</li>
<li class="mce-root">Compare this value with the expected value.</li>
<li class="mce-root">Execute the <kbd><span>terraform destroy</span></kbd> command.</li>
<li class="mce-root">Display the test results.</li>
</ol>
<p class="mce-root">The next screenshot shows the execution of the tests on our module:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/580cf530-5ff2-420e-8361-1c013229ffb5.png"/></p>
<p class="mce-root">You can see, in this screenshot, the different operations that have been executed by the <kbd>go test -v</kbd><span> </span><span>command</span><span> as well as the result of the tests.</span></p>
<h2 id="uuid-c40a2843-04c8-4ad9-9b5e-cac0538e2f70">There's more…</h2>
<p>Terratest allows you to execute integration tests on Terraform configuration with a powerful routine that allows you to provision resources, execute the tests, and finally destroy the resources.</p>
<p class="mce-root">We have seen in the prerequisites of this recipe that the setup of the Golang development environment requires actions that can vary from one operating system to another. To facilitate this task, you can execute your Terratest tests in a Docker container that already has an environment configured. The Dockerfile corresponding to this container is available here: <a href="https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP05/testing-terratest/Dockerfile">https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP05/testing-terratest/Dockerfile</a>.</p>
<div class="mce-root packt_infobox">If Terraform modules provide resources in cloud providers, the authentication parameters must be set before running tests.</div>
<p class="mce-root">Finally, as said in the introduction of this recipe, Terratest is not limited to Terraform—it also allows testing on Packer, Docker, and Kubernetes code. But it goes further by also doing tests on cloud providers such as AWS, Azure, and GCP.</p>
<p class="mce-root">The following code snippet shows how to test the existence of the VM in Azure based on Terraform's output:</p>
<pre>azureVmName <span>:=</span> terraform.Output(t, terraformOptions, <span>"vm_name"</span>)<br/>resourceGroupName <span>:=</span> terraform.Output(t, terraformOptions, <span>"rg_name"</span>)<br/>   <br/>actualVMSize <span>:=</span> azure.GetSizeOfVirtualMachine(t, vmName, resourceGroupName, <span>""</span>)<br/>expectedVMSize <span>:=</span> compute.VirtualMachineSizeTypes(<span>"Standard_DS2_v2"</span>)</pre>
<p class="mce-root">In the next recipes, we will study its integration in a CI/CD pipeline in Azure Pipelines and then in GitHub with GitHub Actions.</p>
<h2 id="uuid-1e7c98ec-0b68-468d-a39d-fa5188661db9">See also</h2>
<ul>
<li>Terratest's official website is available here: <a href="https://terratest.gruntwork.io/">https://terratest.gruntwork.io/</a>.</li>
<li class="mce-root">Terratest's documentation is available here: <a href="https://terratest.gruntwork.io/docs/">https://terratest.gruntwork.io/docs/</a>.</li>
<li class="mce-root">Sample Terratest code is available here: <a href="https://github.com/gruntwork-io/terratest/tree/master/examples">https://github.com/gruntwork-io/terratest/tree/master/examples</a>.</li>
<li>Read this great article about Terratest: <a href="https://blog.octo.com/en/test-your-infrastructure-code-with-terratest/">https://blog.octo.com/en/test-your-infrastructure-code-with-terratest/</a>.</li>
</ul>
<h1 id="uuid-e08576eb-e8a3-4bdd-8cb7-a8c22f9800a9">Building CI/CD for Terraform modules in Azure Pipelines</h1>
<p>Throughout this chapter, we have studied recipes for creating, using, and testing Terraform modules. On the other hand, in the <em>Using a private Git repository for sharing a Terraform module</em> <span>recipe </span>in this chapter, we discussed the possibility of using a private Git repository, such as Azure DevOps, to store and version your Terraform modules.</p>
<p class="mce-root">In a DevOps context, when the module is created and the tests have been written, we need to create a DevOps CI/CD pipeline that will automate all of the steps we discussed for the execution of the tests that we performed manually.</p>
<p class="mce-root">There are many CI/CD pipeline platforms; in this recipe, we will see the implementation of a CI/CD pipeline to automate the tests and the publication of a Terraform module in Azure Pipelines.</p>
<h2 id="uuid-2d8847ca-a2ce-451c-943a-82f843a5c4e9">Getting ready</h2>
<p>To start this recipe, we must first create a Terraform module and tests with Terratest. For this, we will use the same module and its tests that we created in the previous recipe, the source code for which is available from <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/testing-terratest/module">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/testing-terratest/module</a>.</p>
<p class="mce-root">Also, as far as the Azure Pipeline is concerned, you will assume that we have already archived the module code in Azure Repos as we saw in the <em>Using a private Git repository for sharing a Terraform module</em> <span>recipe </span>of this chapter.</p>
<p class="mce-root">To avoid having to install the tools needed to run tests in an Azure Pipelines agent, we will use a Docker image. You should, therefore, have a basic knowledge of Docker and the Docker Hub by referring to the documentation here: <a href="https://docs.docker.com/">https://docs.docker.com/</a>.</p>
<p class="mce-root">Finally, in Azure Pipelines, we will use the YAML pipelines, which allows us to have <span>pipelines </span>as code, the documentation for which is here: <a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devops&amp;tabs=schema%2Cparameter-schema">https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devops&amp;tabs=schema%2Cparameter-schema</a>.</p>
<h2 id="uuid-7e8763e4-9494-4d04-a55b-79f96cfc9b17">How to do it…</h2>
<p>Perform the following steps to create a pipeline for the module in Azure Pipelines:</p>
<ol>
<li>In the <kbd>module</kbd> directory, we will create a Dockerfile with the following content:</li>
</ol>
<pre style="padding-left: 60px"><span>FROM </span>mikaelkrief<span>/</span>go-terraform:<span>0.12.25<br/></span><span><br/></span><span>ARG </span><span>ARG_MODULE_NAME</span>=<span>"module-test"<br/></span><span>ENV </span><span>MODULE_NAME</span>=${<span>ARG_MODULE_NAME</span>}<br/><br/><span># Set work directory.<br/></span><span>RUN </span>mkdir <span>/</span>go<span>/</span>src<span>/</span>${<span>MODULE_NAME</span>}<br/><span>COPY </span>.<span>/</span>module <span>/</span>go<span>/</span>src<span>/</span>${<span>MODULE_NAME</span>}<br/><span>WORKDIR /</span>go<span>/</span>src<span>/</span>${<span>MODULE_NAME</span>}<br/><br/><span>RUN </span>chmod <span>+</span>x runtests.sh<br/><span>ENTRYPOINT </span>[ <span>"./runtests.sh" </span>]</pre>
<ol start="2">
<li>In this same directory, we create a <kbd>runtests.sh</kbd> file with the following content:</li>
</ol>
<pre style="padding-left: 60px"><span>#!/bin/bash<br/></span><span>echo </span><span>"==&gt; Get Terratest modules"<br/></span>go get github.com/gruntwork-io/terratest/modules/terraform<br/><span>echo </span><span>"==&gt; go test"<br/></span><span>go test </span>-v ./tests/ -timeout 30m</pre>
<ol start="3">
<li>Then, we create an <kbd>azure-pipeline.yaml</kbd> file with the following extract YAML code:</li>
</ol>
<pre style="padding-left: 60px">- <span>script</span>: |<br/>    docker build -t module-test:$(tag) .<br/>  <span>workingDirectory</span>: <span>"$(Build.SourcesDirectory)/CHAP05/testing-terratest/"<br/></span><span>  </span><span>displayName</span>: <span>"Docker build"<br/></span>- <span>script</span>: |<br/>    docker run module-test:$(tag)<br/>  <span>workingDirectory</span>: <span>"$(Build.SourcesDirectory)/CHAP05/testing-terratest/"<br/></span><span>  </span><span>displayName</span>: <span>"Docker run"<br/></span>- <span>task</span>: PowerShell@2<br/>  <span>displayName</span>: <span>"Tag code"<br/></span><span>  </span><span>inputs</span>:<br/>    <span>targetType</span>: <span>'inline'<br/></span><span>    </span><span>script</span>: |<br/>      $env:GIT_REDIRECT_STDERR` = '2&gt;&amp;1'<br/>      $tag = "v$(Build.BuildNumber)"<br/>      git tag $tag<br/>      Write-Host "Successfully created tag $tag"<br/>      git push --tags<br/>      Write-Host "Successfully pushed tag $tag"<br/>    <span>failOnStderr</span>: false</pre>
<div class="packt_infobox">The complete code source of this file is available here: <a href="https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP05/testing-terratest/azure-pipeline.yaml">https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP05/testing-terratest/azure-pipeline.yaml</a>.</div>
<ol start="4">
<li>We <kbd>commit</kbd> and <kbd>push</kbd> these three files to the Azure Repos of the Terraform module.</li>
</ol>
<ol start="5">
<li>In Azure Pipelines, in the <span><span class="packt_screen">Pipelines </span></span>section, we click on the <span class="packt_screen">Create Pipeline</span> button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0e60774e-1885-4fa2-930d-a62f4e4f0261.png"/></p>
<ol start="6">
<li>Then, we choose the repository in Azure Repos that contains the code of the module:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c73e23c2-eab4-4e07-aa68-b54bf04aa41e.png" style="width:44.17em;height:20.42em;"/></p>
<ol start="7">
<li>Then, select the <span class="packt_screen">Existing Azure Pipelines YAML file</span> option in the pipeline configuration window:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4315e680-1548-4068-a2c9-9903d46c08b8.png" style="width:42.83em;height:23.67em;"/></p>
<ol start="8">
<li>In the layout that opens on the right, we choose the <kbd>azure-pipeline.yaml</kbd> file that we wrote in <em>step 3</em>, then we validate it by clicking on the <span class="packt_screen">Continue</span> button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ecce28a1-00e5-4681-bd0c-72b658de6e82.png" style="width:26.83em;height:21.50em;"/></p>
<p class="mce-root"/>
<ol start="9">
<li>Finally, the next page displays the contents of the YAML file of the pipeline we have selected. To trigger the pipeline, we click on the <span class="packt_screen">Run</span> button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d742f325-ca0f-4805-9d76-3ab44854de6b.png"/></p>
<h2 id="uuid-ddc9d163-b9c5-4a19-b474-da0c1cfb8955">How it works…</h2>
<p>In <em>step 1</em>, we wrote the Dockerfile that will run the Terratest tests—this Docker image is based on an image called <kbd>go-terraform</kbd> that I created and already contains Terraform and the Go SDK.</p>
<div class="packt_infobox">This <span><kbd>go-terraform</kbd> </span>image is publicly available in Docker Hub (<a href="https://hub.docker.com/repository/docker/mikaelkrief/go-terraform">https://hub.docker.com/repository/docker/mikaelkrief/go-terraform</a>) and the source code is available at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP05/testing-terratest/Dockerfile-go-terraform">https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP05/testing-terratest/Dockerfile-go-terraform</a>.</div>
<p>The following code is the <kbd>FROM</kbd> instruction of the Dockerfile:</p>
<pre><span>FROM </span>mikaelkrief<span>/</span>go-terraform:<span>0.12.25<br/></span></pre>
<p class="mce-root">Then, in this Dockerfile, we create the <kbd>src</kbd> folder and copy the module sources into this <kbd>src</kbd> directory, as shown in the following code:</p>
<pre><span>RUN </span>mkdir <span>/</span>go<span>/</span>src<span>/</span>${<span>MODULE_NAME</span>}<br/><span>COPY </span>.<span>/</span>module <span>/</span>go<span>/</span>src<span>/</span>${<span>MODULE_NAME</span>}<br/><span>WORKDIR /</span>go<span>/</span>src<span>/</span>${<span>MODULE_NAME</span>}</pre>
<p class="mce-root">Finally, we give the execution rights to the <kbd>runtest.sh</kbd> script, and we define <kbd>entrypoint</kbd> on this script, as shown in the following code:</p>
<pre><span>RUN </span>chmod <span>+</span>x runtests.sh<br/><span>ENTRYPOINT </span>[ <span>"./runtests.sh" </span>]</pre>
<p class="mce-root">In <em>step 2</em>, we write the code of the shell script, <kbd>runtest.sh</kbd>, which will be in charge of executing the Terratest tests using the <kbd>dep ensure</kbd><span> and </span><kbd>go test -v</kbd> commands as we learned in the <em>Testing a Terraform module with Terratest</em> <span>recipe </span>in this chapter.</p>
<p class="mce-root">In <em>step 3</em>, we write the YAML code of the Azure DevOps pipeline, which consists of three steps:</p>
<ul>
<li class="mce-root">Build the Docker image using the <kbd>docker build</kbd> command.</li>
<li class="mce-root">Instantiate a new container with this image using the <kbd>docker run</kbd> command, which will run the tests.</li>
<li class="mce-root">Version-control the module code by adding a tag to the module code.</li>
</ul>
<p class="mce-root">Then, we <kbd>commit</kbd> and push these files to the Azure Repos repository of the module.</p>
<p class="mce-root">Finally, in <em>steps 5</em> to <em>8</em>, we create a new pipeline in Azure Pipelines by choosing the module repository and the YAML file that contains the pipeline definition.</p>
<p class="mce-root">In <em>step 9</em>, we execute the pipeline and wait for the end of its execution. As soon as the pipeline ends, you can see that all of the steps have been executed successfully, as shown in the following screenshot:</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b6adf142-c0a0-469c-80c7-319344ea67b1.png" style="width:62.42em;height:32.83em;"/></p>
<p class="mce-root">And the new tag version is applied to the code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fc65aecd-2165-4599-ab34-6d2214e2fc51.png" style="width:29.17em;height:26.58em;"/></p>
<p class="mce-root">This added tag will be used to version the Terraform module so that it can be used when calling the module.</p>
<p class="mce-root">Hence, with this implementation, when calling the module, we will use a version of the module that has been automatically tested by the pipeline.</p>
<h2 id="uuid-54ebe2ea-2b4a-4a47-a3c8-ad1af7c9a1e5">There's more…</h2>
<p>In this recipe, we have studied the basic steps of the YAML pipeline installation in Azure Pipelines. It is possible to go further by additionally using the reporting of the tests in the pipeline. To learn more, read this blog post: <a href="https://blog.jcorioland.io/archives/2019/09/25/terraform-microsoft-azure-ci-docker-azure-pipeline.html">https://blog.jcorioland.io/archives/2019/09/25/terraform-microsoft-azure-ci-docker-azure-pipeline.html</a>.</p>
<p class="mce-root">In the next recipe, we will see the same pipeline process but for a Terraform module that is stored in GitHub and that we want to publish in the Terraform public registry.</p>
<h2 id="uuid-c5f781cd-6a9f-4199-86d7-e0393b6b42a5">See also</h2>
<p>Documentation for Azure Pipelines is available here: <a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/?view=azure-devops">https://docs.microsoft.com/en-us/azure/devops/pipelines/?view=azure-devops</a><a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/?view=azure-devops">.</a></p>
<h1 id="uuid-44c390f6-eddd-41c3-8d70-c4df3e1c41f8">Building a workflow for Terraform modules using GitHub Actions</h1>
<p>In the <em>Sharing a Terraform module using GitHub</em> <span>recipe</span><span> </span><span>of this chapter, we studied how to publish a Terraform module in the Terraform public registry by putting its code on GitHub. Then, we learned in the </span><em>Testing a Terraform module with Terratest</em><span> recipe how</span><span> to write and run module tests using Terratest.</span></p>
<p class="mce-root">We will go further in this recipe by studying the implementation of an automated module publishing workflow using GitHub Actions.</p>
<h2 id="uuid-a17935c3-20db-46d6-b1a6-a4c80d2fb23c">Getting ready</h2>
<p>To start this recipe, you must have assimilated the two recipes, <em>Sharing a Terraform module using GitHub</em> and <em>Testing a Terraform module with Terratest</em>, which include all of the bases and artifacts necessary for this recipe.</p>
<p class="mce-root">In this recipe, we will use the module code we wrote in the <em>Testing Terraform module code with Terratest</em> recipe, the source code for which is available here: <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/testing-terratest/module">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/testing-terratest/module</a>.</p>
<p class="mce-root">Also, we will be using GitHub Actions, which is a free service for public GitHub repositories, the documentation for which is available here: <a href="https://github.com/features/actions">https://github.com/features/actions</a>.</p>
<p class="mce-root">The source code for this recipe is available here: <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/githubaction">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/githubaction</a>.</p>
<h2 id="uuid-08159df8-1cdb-4d40-968f-dbc4d4dee659">How to do it…</h2>
<p> Perform the following steps to use GitHub Actions on our Terraform module:</p>
<ol>
<li>In the root of the GitHub repository that contains the module code, we create, via the GitHub web interface, a new file called <kbd>integration-test.yaml</kbd> in the <kbd>.github</kbd> | <kbd>workflows</kbd> folder:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a69394c7-e2bd-4c99-b1f3-2da0f24ad09c.png"/></p>
<ol start="2">
<li class="mce-root">In this file, we write the following extract YAML code (the complete code is here: <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/githubaction">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP05/githubaction</a>):</li>
</ol>
<pre style="padding-left: 60px">...<br/>    <span>steps</span>:<br/>      - <span>name</span>: Check out code<br/>        <span>uses</span>: actions/checkout@v1<br/>      - <span>name</span>: Set up Go 1.14<br/>        <span>uses</span>: actions/setup-go@v1<br/>        <span>with</span>:<br/>          <span>go-version</span>: 1.14<br/>        <span>id</span>: go<br/>      - <span>name</span>: Get Go dependencies<br/>        <span>run</span>: go get -v -t -d ./...<br/>      - <span>name</span>: Run Tests<br/>        <span>working-directory</span>: <span>"CHAP05/testing-terratest/module/tests/"<br/></span><span>        </span><span>run</span>: |<br/>          go test -v -timeout 30m<br/>      - <span>name</span>: Bump version and push tag<br/>        <span>uses</span>: mathieudutour/github-tag-action@v4<br/>        <span>with</span>:<br/>          <span>github_token</span>: ${{ secrets.GITHUB_TOKEN }}</pre>
<ol start="3">
<li class="mce-root">Then, we validate the page by clicking on the <span class="packt_screen">Commit new file</span> button at the bottom of the page:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f97fe323-4ae4-4293-9d5b-7f3c199b170f.png" style="width:48.33em;height:23.58em;"/></p>
<ol start="4">
<li class="mce-root">Finally, we click on the <span class="packt_screen">Actions</span> tab of our repository and we can see the workflow that has been triggered:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9db2b775-91d7-40d9-a241-c040af9ac966.png"/></p>
<h2 id="uuid-0d9fc6e5-630a-4465-a9b8-9c979cba40a5">How it works…</h2>
<p>To create the workflow in GitHub Actions, we have created a new YAML file in the repository that contains the module code, in the specific <kbd>.github</kbd> | <kbd>workflows</kbd> folder that contains the steps that the GitHub Action agent will perform.</p>
<p class="mce-root">The steps of our workflow are as follows:</p>
<ol>
<li>The first step is to do a checkout to retrieve the repository code:</li>
</ol>
<pre style="padding-left: 60px">- <span>name</span>: Check out code<br/>  <span>uses</span>: actions/checkout@v1</pre>
<ol start="2">
<li>Then, we install the SDK for Go with the following code:</li>
</ol>
<pre style="padding-left: 60px">- <span>name</span>: Set up Go 1.14<br/>  <span>uses</span>: actions/setup-go@v1<br/>  <span>with</span>:<br/>    <span>go-version</span>: 1.14  #need to be &gt;=1.13<br/>  <span>id</span>: go</pre>
<div class="packt_infobox">For more information about the minimum Go version, read the documentation here: <a href="https://terratest.gruntwork.io/docs/getting-started/quick-start/#requirements">https://terratest.gruntwork.io/docs/getting-started/quick-start/#requirements</a>. </div>
<ol start="3">
<li>Then, we download the dependencies with this code:</li>
</ol>
<pre style="padding-left: 60px">- <span>name</span>: Get Go dependencies<br/>  <span>run</span>: go get -v -t -d ./...</pre>
<ol start="4">
<li class="mce-root">We run the Terratest tests with the following code:</li>
</ol>
<pre style="padding-left: 60px">- <span>name</span>: Run Tests<br/>  <span>working-directory</span>: <span>"CHAP05/testing-terratest/module/tests/"<br/></span><span>  </span><span>run</span>: |<br/>    go test -v -timeout 30m</pre>
<ol start="5">
<li class="mce-root">Finally, the last step is to add a tag to the code. To do this, we use the <kbd>Github-tag</kbd> action provided by the <kbd>mathieudutour/github-tag-action@v4</kbd> repository and we use the built-in <kbd>GITHUB_TOKEN</kbd> variable that allows the agent to authenticate itself to perform Git commands on the repository:</li>
</ol>
<pre style="padding-left: 60px">- <span>name</span>: Bump version and push tag<br/>  <span>uses</span>: mathieudutour/github-tag-action@v4<br/>  <span>with</span>:<br/>    <span>github_token</span>: ${{ secrets.GITHUB_TOKEN }}</pre>
<p class="mce-root">At the end of the execution of the workflow, you can see the results, as in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/82012d6b-a8f5-4f26-8cb3-450772e3dc20.png" style="width:47.83em;height:25.42em;"/></p>
<p class="mce-root">If the workflow runs correctly, a new tag will be added to the code, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/818b1ad7-1ace-4d61-9b27-e9116f3339b7.png" style="width:34.08em;height:21.67em;"/></p>
<p class="mce-root">And if this module is published in the public registry, a new version of this module will be available.</p>
<h2 id="uuid-cc83ac88-97e1-496b-b732-03da898d2deb">There's more…</h2>
<p>The incrementing of the tag in the repository (major, minor, or patch) is done automatically and will depend on the content of the commit description that triggered the action. For more information, read the documentation at <a href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines">https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines</a>.</p>
<h2 id="uuid-a96fb7df-a4a2-462c-a66f-b703e8d759a3">See also</h2>
<ul>
<li>Documentation on the GitHub-Tag action is available here: <a href="https://github.com/marketplace/actions/github-tag">https://github.com/marketplace/actions/github-tag</a>.</li>
<li>Read this blog post about Terratest and GitHub Actions, provided by HashiCorp: <a href="https://www.hashicorp.com/blog/continuous-integration-for-terraform-modules-with-github-actions/">https://www.hashicorp.com/blog/continuous-integration-for-terraform-modules-with-github-actions/</a><a href="https://github.com/marketplace/actions/github-tag">.</a></li>
</ul>


            </article>

            
        </section>
    </body></html>