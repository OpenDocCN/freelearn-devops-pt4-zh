<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Provisioning Azure Infrastructure with Terraform
                </header>
            
            <article>
                
<p class="mce-root">Terraform contains a multitude of providers that enable the provisioning of various types of infrastructure, whether in the cloud or on-premise.</p>
<p class="mce-root">In the previous chapters of this book, we have studied the basic concepts of the Terraform language, as well as the main Terraform commands line and we have seen the sharing of Terraform configuration using modules. In addition, all the recipes we have seen in the previous chapters are generic and can be used by all Terraform providers.</p>
<p class="mce-root">In this chapter, we will focus on using Terraform to provision a cloud infrastructure in Azure. We will start with its integration into Azure Cloud Shell, its secure authentication, and the protection of the Terraform state file in an Azure storage. You will learn how to run ARM templates and Azure CLI scripts with Terraform and how to retrieve the Azure resource list with Terraform. Then we'll look at how to protect sensitive data in Azure Key Vault using Terraform. We will write two case studies in Azure, with the first showing the provisioning and configuration of an IaaS infrastructure consisting of VMs, and the second showing the provisioning of a PaaS infrastructure in Azure. Finally, we will go further with the generation of Terraform configuration from an already existing infrastructure.</p>
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Using Terraform in Azure Cloud Shell</li>
<li>Protecting the Azure credential provider</li>
<li>Protecting the state file in the Azure remote backend</li>
<li>Executing ARM templates in Terraform</li>
<li>Executing Azure CLI commands in Terraform</li>
<li>Using Azure Key Vault with Terraform to protect secrets</li>
<li>Getting a list of Azure resources in Terraform</li>
<li>Provisioning and configuring an Azure VM with Terraform</li>
</ul>
<ul>
<li>Building Azure serverless infrastructure with Terraform</li>
<li>Generating a Terraform configuration for existing Azure infrastructure</li>
</ul>
<h1 id="uuid-7125469c-a14f-41c6-abb8-e4930ed2fa48">Technical requirements</h1>
<p>To apply the recipes in this chapter, you must have an Azure subscription. If you don't have one, you can create an Azure account for free at this site: <a href="https://azure.microsoft.com/en-us/free/">https://azure.microsoft.com/en-us/free/</a></p>
<p>The complete source code for this chapter is available here: <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06</a></p>
<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/2ZmEcnJ">https://bit.ly/2ZmEcnJ</a></p>
<h1 id="uuid-e0b9a592-b21d-4ad3-95cf-41b8f1d3faa0">Using Terraform in Azure Cloud Shell</h1>
<p>In <a href="027d2973-b820-4fba-b43e-ee2747a97e6a.xhtml">Chapter 1</a>, <em>Setting Up the Terraform Environment</em>, of this book, we studied the steps involved in installing Terraform on a local machine.</p>
<p class="mce-root">In the Azure Shell console, known as <strong>Azure Cloud Shell</strong>, Microsoft has integrated Terraform in the list of tools that are installed by default.</p>
<p class="mce-root">In this recipe, we will see how to write a Terraform configuration and use Terraform in Azure Cloud Shell.</p>
<h2 id="uuid-8c954710-9cfe-4bc7-8acf-e5819c4fc83b">Getting ready</h2>
<p>The prerequisite for this recipe is to have an Azure subscription and to be connected to this subscription via the Azure portal, which is accessible here: <a href="https://portal.azure.com/">https://portal.azure.com/</a></p>
<div class="mce-root packt_infobox">Note that this prerequisite applies to all recipes in this chapter.</div>
<p class="mce-root">In addition, you need to associate your Cloud Shell with an existing Azure Storage Account or create a new one, as explained in the following documentation: <a href="https://docs.microsoft.com/en-us/azure/cloud-shell/persisting-shell-storage">https://docs.microsoft.com/en-us/azure/cloud-shell/persisting-shell-storage</a>.</p>
<h2 id="uuid-dbb4956f-51f2-4fb7-9657-207e4b861171">How to do it…</h2>
<p>In order to use Terraform in Azure Cloud Shell, perform the following steps:</p>
<ol>
<li>In the Azure portal, open Azure Cloud Shell by clicking the Cloud Shell button in the top menu, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0655579d-36a8-4450-b465-49cbe7de0ad9.png"/></p>
<ol start="2">
<li>Inside the Cloud Shell panel, in the top menu, in the dropdown, choose <span class="packt_screen">Bash</span> mode:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/901451f8-5167-4550-8189-fdb7dded47de.png"/></p>
<ol start="3">
<li>In the Cloud Shell terminal, create a new folder, <kbd>demotf</kbd>, inside the default <kbd>clouddrive</kbd> folder by executing the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>mkdir clouddrive/demotf</strong></pre>
<p style="padding-left: 60px">Inside this new folder, enter the <kbd>cd clouddrive/demotf</kbd> command.</p>
<ol start="4">
<li>To write a Terraform configuration inside an integrated Visual Studio Code instance, execute the <kbd>code</kbd> <span>command.</span></li>
</ol>
<ol start="5">
<li>In the editor, in the opened blank page, write the Terraform configuration with the following sample code:</li>
</ol>
<pre style="padding-left: 60px"><span>terraform </span>{<br/>  <span>required_version </span>= <span>"&gt;= 0.12"<br/></span>}<br/><br/><span>provider </span><span>"azurerm" </span>{<br/>  <span>features </span>{}<br/>}<br/><br/><span>resource </span><span>"azurerm_resource_group" </span><span>"rg-app" </span>{<br/>  <span>name     </span>= <span>"RG-TEST-DEMO"<br/></span><span>  </span><span>location </span>= <span>"westeurope"<br/></span>}</pre>
<ol start="6">
<li>Save this file by using the <em>Ctrl</em> + <em>S</em> shortcut and name this file <kbd>main.tf</kbd>.</li>
<li><span>Finally, to apply this Terraform configuration to </span>the Cloud Shell terminal, execute the classical Terraform workflow as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; terraform init</strong><br/><strong>&gt; </strong><strong>terraform plan -out=app.tfplan</strong><br/><strong>&gt; terraform apply app.tfplan</strong></pre>
<h2 id="uuid-50c008e4-62ad-41c7-951e-0fd16ccedb59">How it works…</h2>
<p>In this recipe, we used the integrated environment of Azure Cloud Shell, which consists of a command-line terminal that we chose to use in Bash mode. In addition, in <em>steps 5</em> and <em>6</em>, we used the built-in Visual Studio Code editor, using the <kbd>code</kbd> <span>command, </span>to write a Terraform configuration, which also has syntax highlighting for Terraform files. And finally, in <em>step 7</em>, we used the Terraform client, which is already installed in this Cloud Shell environment to provision our infrastructure with the execution of the Terraform workflow commands.</p>
<p>The following screenshot shows Azure Cloud Shell with Terraform execution:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/780438d1-4ed3-4ea2-9053-e52b8de19f69.png"/></p>
<p>We can see in the preceding screenshot the top panel with the integrated Visual Studio Code editor, and, in the bottom panel, the command line with the execution of the Terraform command.</p>
<h2 id="uuid-3ce479bd-32f2-4dbd-a2b1-b820baac2a43">There's more…</h2>
<p>For this recipe, we chose the option to edit the Terraform files directly in Visual Studio Code, which is in Cloud Shell, but the following alternative options are available:</p>
<ul>
<li class="mce-root">The Terraform files could be <span>created and edited </span>using the <strong>Vim</strong> tool (Linux editor: <a href="https://www.linux.com/training-tutorials/vim-101-beginners-guide-vim/">https://www.linux.com/training-tutorials/vim-101-beginners-guide-vim/</a>), which is built into Cloud Shell.</li>
<li class="mce-root">We could also have edited the Terraform files locally on our machine and then copied them to the Azure Storage service that is connected to Azure Cloud Shell.</li>
<li class="mce-root">If the files are stored in a Git repository, we could also have cloned the repository directly into the Cloud Shell storage by running a <kbd>git clone</kbd> command in the Cloud Shell command-line terminal.</li>
</ul>
<p class="mce-root">Also, regarding Terraform's authentication to perform actions in Azure, we did not take any action because Azure Cloud Shell allows direct authentication to our Azure subscriptions and Terraform, which is in Cloud Shell, automatically inherits that authentication.</p>
<p class="mce-root">On the other hand, if you have several subscriptions, prior to executing the Terraform workflow, you have to choose the subscription target by executing the following command:</p>
<pre class="mce-root"><strong>az account set -s &lt;subscription _id&gt;</strong></pre>
<p class="mce-root">This chosen subscription then becomes the subscription by default during execution. Refer to the documentation at <a href="https://docs.microsoft.com/en-us/cli/azure/account?view=azure-cli-latest#az-account-set">https://docs.microsoft.com/en-us/cli/azure/account?view=azure-cli-latest#az-account-set</a>.</p>
<p class="mce-root">Regarding the version of Terraform that is installed on the Cloud Shell, in general, it is the latest public version, which you can check by running the <kbd>terraform --version</kbd> <span>command. </span>You need to check that your Terraform configuration is compatible with this version before executing.</p>
<p class="mce-root">Finally, as regards the recommended use of Azure Cloud Shell for Terraform, it can only be used for development and testing. It cannot be integrated into a CI/CD pipeline and uses your personal permissions on Azure to provision resources. For this reason, in the next recipe, we will look at how to securely authenticate Terraform to Azure.</p>
<h2 id="uuid-a48544d5-d6bf-43c8-922d-39c1b567b421">See also</h2>
<ul>
<li>Refer to this blog post, which also shows the use of Terraform in Azure Cloud Shell: <a href="https://cloudskills.io/blog/terraform-azure-01">https://cloudskills.io/blog/terraform-azure-01</a></li>
<li class="mce-root">Documentation that explains the use of Azure Cloud Shell: <a href="https://docs.microsoft.com/en-us/azure/cloud-shell/using-cloud-shell-editor">https://docs.microsoft.com/en-us/azure/cloud-shell/using-cloud-shell-editor</a></li>
<li class="mce-root">A tutorial that shows how to use and configure locally installed Visual Studio Code to execute a Terraform configuration in Azure Cloud Shell: <a href="https://docs.microsoft.com/en-us/azure/developer/terraform/configure-vs-code-extension-for-terraform">https://docs.microsoft.com/en-us/azure/developer/terraform/configure-vs-code-extension-for-terraform</a></li>
</ul>
<h1 id="uuid-0aa8c3ff-85e2-4319-87e6-f614748c2a17">Protecting the Azure credential provider</h1>
<p>In order for the Terraform Azure provider to provision and manipulate resources in Azure, the provider must authenticate in Azure using an Azure account and that account must have the correct authorizations.</p>
<p class="mce-root">In the previous recipe, we studied how to <span>automatically authenticate the Terraform context in</span> Azure Cloud Shell with our personal account and permissions. However, in corporate projects, as well as in production, it is very bad practice to use your personal account as this could expire, be deleted, or, even worse, be misused.</p>
<p class="mce-root">This is why one of the options we have when running Terraform in Azure is to use an <strong>App Registration</strong> account (also known as <strong>Service Principal</strong>) that is not linked to a physical person.</p>
<p class="mce-root">In this recipe, we will first study the creation of this Service Principal and then we will see how to use it securely in order to run a Terraform configuration.</p>
<h2 id="uuid-b9c80c64-4bf5-4899-83fc-aeb821c325e0">Getting ready</h2>
<p>To apply the first part of this recipe, you must have user account creation permissions in Azure Active Directory. Moreover, to create this <span>Service Principal</span><span>,</span> we will do it using the command line with the <strong>az cli</strong> tool, documentation relating to which is available at <a href="https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest">https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest</a>.</p>
<p>In addition, we need to retrieve our ID of the subscription in which resources will be provisioned. For this, we can get it in Azure Cloud Shell by running the <kbd>az account list</kbd> <span>command </span>to display our subscription details:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b642bbcf-10b9-4f1e-8c64-b0e301684ec4.png" style="width:62.67em;height:24.33em;"/></p>
<p>Also, get the <kbd>id</kbd> property of the subscription <span>concerned</span>.</p>
<h2 id="uuid-c8c72011-4f83-4fbf-bfc0-d05f8e2606bf">How to do it…</h2>
<p>This recipe comprises two parts, which are as follows: the creation of the Service Principal<span>,</span> and the configuration of Terraform authentication using this Service Principal.</p>
<p>To create this Service Principal<span>,</span> perform the following steps:</p>
<ol>
<li>Open Azure Cloud Shell and execute the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>az ad sp create-for-rbac --name="BookDemoTerraform" --role="Contributor" --scopes="/subscriptions/&lt;Subscription Id&gt;"</strong></pre>
<ol start="2">
<li>Retrieve all the identification information provided in the output of the previous command by making a note (because we won't be able to retrieve the password after closing this console) of <kbd>appId</kbd>, <kbd>password</kbd>, and <kbd>tenant</kbd>, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/21a5185e-24d7-4e3f-a2ab-aa4e1bc04029.png"/></p>
<p>Now that the Service Principal is created, we can use it to provision Azure infrastructure with Terraform by performing the following steps:</p>
<ol>
<li>In the command-line terminal, set four new variable environments as follows:</li>
</ol>
<pre style="padding-left: 60px">export ARM_SUBSCRIPTION_ID =&lt;subscription_id&gt;<br/><strong>export ARM_CLIENT_ID=&lt;appId&gt;</strong><br/><strong>export ARM_CLIENT_SECRET=&lt;password&gt;</strong><br/><strong>export ARM_TENANT_ID=&lt;tenant id&gt;</strong></pre>
<ol start="2">
<li>Then, we can apply the Terraform configuration by executing the following Terraform workflow:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; terraform init</strong><br/><strong>&gt; </strong><strong>terraform plan -out=app.tfplan</strong><br/><strong>&gt; terraform apply app.tfplan</strong></pre>
<h2 id="uuid-9e762130-5cfc-46ad-a813-f25def01400d">How it works…</h2>
<p>In the first part of this recipe, we created a Service Principal and gave it its permissions on a subscription, using the command line <kbd>az ad sp</kbd>. To this command, we added the following arguments:</p>
<ul>
<li><kbd>name</kbd>, which is the name of the Service Principal we're going to create.</li>
<li><kbd>role</kbd>, which is the role that the Service Principal will have on the subscription; here, we specify <kbd>Contributor</kbd>.</li>
<li><kbd>scopes</kbd>, where we specify the Azure ID of the resource on which the Service Principal will have contributor permissions. In our case, this is the subscription ID in which the resources will be provisioned by Terraform.</li>
</ul>
<p class="mce-root">This command will therefore create the Service Principal with a generated password and will give it the <kbd>Contributor</kbd> role on the <span>specified </span>subscription.</p>
<p class="mce-root">At the end of its execution, this command displays the information of the Service Principal<span>,</span> including <kbd>AppId</kbd>, <kbd>password</kbd>, and <kbd>tenant</kbd>. As explained in <em>step 2</em>, we need to retrieve this information and store it in a safe place because this password cannot be retrieved later. Then, we check that the Service Principal has the permissions on subscription, as you can see in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ea215dd2-f679-4882-93d0-75a9f0f85818.png"/></p>
<p class="mce-root">In the second part of this recipe, we used this Service Principal to authenticate the Terraform Azure provider. For this, there are several solutions, the most secure one being to use <span>specific Azure provider </span>environment variables because these environment variables will not be visible in code and will only be persistent during the execution session. So, we have set four environment variables, which are as follows:</p>
<ul>
<li class="mce-root"><kbd>ARM_SUBSCRIPTION_ID</kbd>: This contains the Azure subscription ID.</li>
<li class="mce-root"><kbd>ARM_CLIENT_ID</kbd>: This contains the Service Principal ID, called <kbd>AppId</kbd>.</li>
<li class="mce-root"><kbd>ARM_CLIENT_SECRET</kbd>: This contains the password of the Service Principal.</li>
<li class="mce-root"><kbd>ARM_TENANT_ID</kbd>: This contains the ID of the Azure Active Directory tenant.</li>
</ul>
<div class="mce-root packt_infobox">In the recipe, we used the export command of the Linux system. On Windows PowerShell, we can use the <kbd>$env</kbd> command. In addition, in all the recipes in this chapter, we will use these environment variables before executing Terraform.</div>
<p class="mce-root">Then, once these environment variables are set, we can execute the basic Terraform workflow.</p>
<h2 id="uuid-ef10f3e1-8fb6-4da6-9e59-61cede1058a7">There's more...</h2>
<p>Regarding the creation of the Service Principal, we made the choice to use the Azure CLI tool, but we could also have done it directly via the Azure portal, as detailed in the following documentation available at <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-create-service-principal-portal">https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-create-service-principal-portal</a>, or we could have used the Azure PowerShell commands (<a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-authenticate-service-principal-powershell">https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-authenticate-service-principal-powershell</a>).</p>
<p class="mce-root">In addition, as regards the configuration of the Terraform Azure provider, we have used environment variables, but we can also put this information directly into the Terraform configuration, as shown in the following code snippet:</p>
<pre><span>provider </span><span>"azurerm" </span>{<br/>   ...<br/>  <span>subscription_id </span>= <span>"&lt;Subscription ID&gt;"<br/></span><span>  </span><span>client_id       </span>= <span>"&lt;Client ID&gt;"<br/></span><span>  </span><span>client_secret   </span>= <span>"&lt;Client Secret&gt;"<br/></span><span>  </span><span>tenant_id       </span>= <span>"&lt;Tenant ID&gt;"<br/></span>}</pre>
<p class="mce-root">This solution does not require an extra step (the set of environment variables) to be implemented prior to executing the Terraform configuration, but it leaves identification information in clear text in the code, <span>and hardcoding credentials in code is generally considered a bad practice from the security perspective, since the leakage of code also leaks credentials and makes it impossible to share the code with anyone without exposing the credentials</span>. And in the case where the Terraform configuration provides resources for several environments that are in different subscriptions, Terraform variables will have to be added, which can add complexity to the code.</p>
<p class="mce-root">Finally, the use of environment variables offers the advantage of being easily integrated into a CI/CD pipeline while preserving the security of the authentication data.</p>
<h2 id="uuid-52aaa106-237a-4cea-a467-1f96f0b8068d">See also</h2>
<ul>
<li>The Azure documentation and Terraform configuration is available here: <a href="https://docs.microsoft.com/en-us/azure/developer/terraform/install-configure">https://docs.microsoft.com/en-us/azure/developer/terraform/install-configure</a></li>
<li class="mce-root">Documentation on the configuration of the Azure provider, along with the other authentication options, is available here: <a href="https://www.terraform.io/docs/providers/azurerm/index.html">https://www.terraform.io/docs/providers/azurerm/index.html</a></li>
</ul>
<h1 id="uuid-c9e1a181-c3e2-4202-9fd9-c13f3d87c7b5">Protecting the state file in the Azure remote backend</h1>
<p>When executing the Terraform workflow commands, which are mainly <kbd>terraform plan</kbd>, <kbd>terraform apply</kbd>, and <kbd>terraform destroy</kbd>, Terraform has a mechanism that allows it to identify which resources need to be updated, added, or deleted. To perform this mechanism, Terraform maintains a file called a Terraform state file that contains all the details of the resources provisioned by Terraform. This Terraform state file is created the first time the <kbd>terraform plan</kbd> command is run and is updated with each action (<kbd>apply</kbd> or <kbd>destroy</kbd>).</p>
<p>In a enterprise, this file contains certain interesting aspects, which are as follows:</p>
<ul>
<li>Sensitive information on the provisioned resources is mentioned in clear text.</li>
<li>If several people are working together, this file must be shared by everyone or, by default, this file is created on the local workstation or on the workstation that contains the Terraform binary.</li>
</ul>
<ul>
<li>Even if it is archived in a Git source code manager, once it is retrieved on the local workstation, it does not allow several people to work on the same file.</li>
<li>With this locally stored file, managing multi-environments can quickly become complicated and risky.</li>
<li>Any deletion of this local file or poor manual editing can affect the execution of Terraform configuration.</li>
</ul>
<p>A solution to all these problems is the use of a remote backend, which consists of storing this file in a remote, shared, and secure store.</p>
<p>In the use of Terraform, there are several types of remote backends, such as S3, <kbd>azurerm</kbd>, Artifactory, and many others, which are listed in the menu on the following page: <a href="https://www.terraform.io/docs/backends/types/index.html">https://www.terraform.io/docs/backends/types/index.html</a></p>
<p>In this recipe, we will study the use of a remote backend, <kbd>azurerm</kbd>, in Azure by storing this Terraform state file in an Azure Storage Account.</p>
<h2 id="uuid-0b533228-e0b7-46e7-8c74-1df337318b82">Getting ready</h2>
<p>For this recipe, we will use Azure Cloud Shell and Azure CLI commands to create the Storage Account.</p>
<p>The source code for this recipe and the script used are available at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/remotebackend">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/remotebackend</a>.</p>
<h2 id="uuid-a67f7446-d856-47cc-8375-799a7e590024">How to do it…</h2>
<p>This recipe consists of two parts. In the first part, we will create the Storage Account, and in the second part, we will configure Terraform to use the <kbd>azurerm</kbd> remote backend:</p>
<ol>
<li>In Azure Cloud Shell, execute the following Azure CLI script (available at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/remotebackend/create-backend.sh">https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/remotebackend/create-backend.sh</a>) to create the Storage Account with a blob container in the Resource Group:</li>
</ol>
<pre style="padding-left: 60px"><span># 1- Create Resource Group<br/></span><span>az </span>group create --name <span>"RG-TFBACKEND" </span>--location westeurope<br/><br/><span># 2- Create storage account<br/></span><span>az </span>storage account create --resource-group <span>"RG-TFBACKEND" </span>--name <span>"storagetfbackend" </span>--sku Standard_LRS --encryption-services blob<br/><br/><span># 3- Create blob container<br/></span><span>az </span>storage container create --name <span>"tfstate" </span>--account-name <span>"storagetfbackend"<br/></span><span><br/></span><span># 4- Get storage account key<br/></span>ACCOUNT_KEY=<span>$</span><span>(az </span>storage account keys list --resource-group <span>"RG-TFBACKEND" </span>--account-name <span>"storagetfbackend" </span>--query [<span>0</span>].value -o tsv<span>)<br/></span><span><br/></span><span>echo </span>$ACCOUNT_KEY</pre>
<ol start="2">
<li>Then, we configure the Terraform state backend by adding the following code to the <kbd>main.tf</kbd> file:</li>
</ol>
<pre style="padding-left: 60px"><span>terraform </span>{<span><br/></span><span>  </span><span>backend </span><span>"azurerm" </span>{<br/>    <span>resource_group_name  </span>= <span>"RG-TFBACKEND"<br/></span><span>    </span><span>storage_account_name </span>= <span>"storagetfbackend"<br/></span><span>    </span><span>container_name       </span>= <span>"tfstate"<br/></span><span>    </span><span>key                  </span>= <span>"myapp.tfstate"<br/></span><span>  </span>}<br/>}</pre>
<ol start="3">
<li>Finally, to execute the Terraform configuration, we set a new environment variable, <kbd>ARM_ACCESS_KEY</kbd>, with the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>export ARM_ACCESS_KEY = &lt;access key&gt;</strong></pre>
<p style="padding-left: 60px" class="mce-root">Then, we execute the basic commands of the Terraform workflow.</p>
<h2 id="uuid-2a0f7c90-37ae-4c71-81a9-7eb6d7c2e0be">How it works…</h2>
<p>In the first step, we used a script that performs the following actions in sequence:</p>
<ol>
<li>It creates a Resource Group called <kbd>RG-TFBACKEND</kbd>.</li>
<li>In this Resource Group, we use the <kbd>az storage account create</kbd> command to create a Storage Account named <kbd>storagetfbackend</kbd>.</li>
<li>Then, this script creates a blob container in this Storage Account with the <kbd>az storage container create</kbd> <span>command. </span></li>
<li>Finally, we retrieve the account key of the Storage Account created and display its value.</li>
</ol>
<p class="mce-root">Then, in <em>step 2</em>, we configure Terraform to use this Storage Account as a remote backend to store the Terraform state file. In this configuration, which is located in a <kbd>backend "azurerm"</kbd> <span>block, </span>we indicate, on the one hand, the Storage Account <span>information, </span>and, on the other, the blob with the properties:</p>
<ul>
<li><kbd>resource_group_name</kbd>: This is the name of the Resource Group that contains the Storage Account.</li>
<li><kbd>storage_account_name</kbd>: This is the name of the Storage Account.</li>
<li><kbd>container_name</kbd>: This is the name of the blob container.</li>
<li><kbd>key</kbd>: This is the name of the Terraform state file.</li>
</ul>
<p class="mce-root">Finally, we define a new environment variable, <kbd>ARM_ACCESS_KEY</kbd>, that contains the account key for the Storage Account we retrieved from the script we ran in <em>step 1</em>. This variable is used to authenticate the Storage Account. Then, we execute the <kbd>init</kbd>, <kbd>plan</kbd>, and <kbd>apply</kbd> commands of Terraform.</p>
<p class="mce-root">Based on what we studied in the previous recipe, <em>Protecting the Azure credential provider</em>, here is the complete script for executing this Terraform script in Azure:</p>
<pre>export ARM_SUBSCIPTION_ID =&lt;subscription_id&gt;<br/>export ARM_CLIENT_ID=&lt;appId&gt;<br/>export ARM_CLIENT_SECRET=&lt;password&gt;<br/>export ARM_TENANT_ID=&lt;tenant id&gt;<br/>export ARM_ACCESS_KEY=&lt;account key&gt;<br/><br/>&gt; terraform init<br/>&gt; terraform plan -out=app.tfplan<br/>&gt; terraform apply app.tfplan</pre>
<p class="mce-root">So, we used the four authentication environment variables, as well as the <kbd>ARM_ACCESS_KEY</kbd> environment variable, for authentication to the Storage Account and we executed the Terraform commands.</p>
<h2 id="uuid-8a848166-0850-4667-8664-2b85a6162929">There's more…</h2>
<p>In this recipe, we used an environment variable to specify the value of the access key to protect this sensitive data. We could have specified it in the remote backend configuration, using the <kbd>access_key</kbd> property, as in the following example (but as mentioned in the <em>Protecting the Azure credential provider</em> recipe of this chapter, it isn't good practice to leave sensitive keys as plain text):</p>
<pre><span>terraform </span>{<span><br/></span><span>  </span><span>backend </span><span>"azurerm" </span>{<br/>    <span>resource_group_name  </span>= <span>"RG-TFBACKEND"<br/></span><span>    </span><span>storage_account_name </span>= <span>"storagetfbackend"<br/></span><span>    </span><span>container_name       </span>= <span>"tfstate"<br/></span><span>    </span><span>key                  </span>= <span>"myapp.tfstate"<br/>    <strong>access_key           = xxxxxx-xxxxx-xxx-xxxxx</strong><br/></span><span>  </span>}<br/>}</pre>
<p class="mce-root">Moreover, if our Terraform configuration is designed to be deployed on multiple environments, we can create <em>N</em> configurations of the <kbd>azurerm</kbd> backend with the following steps:</p>
<ol>
<li class="mce-root">The <kbd>main.tf</kbd> file contains the following code with the <kbd>backend "azurerm"</kbd> block empty:</li>
</ol>
<pre style="padding-left: 60px"><span>terraform </span>{<br/>  <span>required_version </span>= <span>"&gt;= 0.12"<br/></span><span>  </span><span>backend </span><span>"azurerm" </span>{<span><br/></span><span>  </span>}<br/>}</pre>
<ol start="2">
<li>We create one <kbd>backend.tfvars</kbd> file per environment (in a specific folder for this environment) with the following code:</li>
</ol>
<pre style="padding-left: 60px"><span>resource_group_name  </span>= <span>"RG-TFBACKEND"<br/></span><span>storage_account_name </span>= <span>"storagetfbackend"<br/></span><span>container_name       </span>= <span>"tfstate"<br/></span><span>key                  </span>= <span>"myapp.tfstate"</span></pre>
<ol start="3">
<li>Finally, in the execution of the <kbd>init</kbd> command, we specify the <kbd>backend.tfvars</kbd> <span>file </span>to be used with the following command, a<span>s specified in the </span><kbd>init</kbd><span> command documentation, which is available at </span><a href="https://www.terraform.io/docs/backends/config.html#partial-configuration">https://www.terraform.io/docs/backends/config.html#partial-configuration</a>:</li>
</ol>
<pre style="padding-left: 60px"><strong>terraform init -backend-config="&lt;path&gt;/backend.tfvars"</strong></pre>
<p class="mce-root">Finally, if the Service Principal that was used to authenticate with Terraform has permissions on this Storage Account, then this environment variable is not mandatory.</p>
<h2 id="uuid-817fac20-df34-476d-a8ba-7fd7d35287fe">See also</h2>
<ul>
<li><span>D</span>ocumentation relating to the <kbd>azurerm</kbd> remote backend is available here: <a href="https://www.terraform.io/docs/backends/types/azurerm.html">https://www.terraform.io/docs/backends/types/azurerm.html</a></li>
<li class="mce-root">Terraform's learning module with the <kbd>azurerm</kbd> remote backend is available here: <a href="https://learn.hashicorp.com/terraform/azure/remote_az#azurerm">https://learn.hashicorp.com/terraform/azure/remote_az#azurerm</a></li>
<li class="mce-root">Azure documentation relating to the Terraform remote backend is available here: <a href="https://docs.microsoft.com/en-us/azure/developer/terraform/store-state-in-azure-storage">https://docs.microsoft.com/en-us/azure/developer/terraform/store-state-in-azure-storage</a></li>
</ul>
<h1 id="uuid-e62c9335-8fab-410e-9b44-f90c553ddb99">Executing ARM templates in Terraform</h1>
<p>Among all the <strong>Infrastructure as Code</strong> (<strong>IaC</strong>) tools and languages, there is one provided by Azure called <strong>Azure Resource Manager</strong> (<strong>ARM</strong>), based on JSON format files, that contains the description of the resources to be provisioned.</p>
<div class="mce-root packt_infobox">To learn more about ARM templates, read the following documentation: <a href="https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/overview">https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/overview</a></div>
<p class="mce-root">When using Terraform to provision resources in Azure, you may need to use resources that are not yet available in the Terraform <kbd>azurerm</kbd> provider. Indeed, the <kbd>azurerm</kbd> provider is open source and community-based on GitHub, and has a large community of contributors, but this is not enough to keep up with all the changes in Azure's functionalities in real time. This is due to several reasons:</p>
<ul>
<li class="mce-root">New releases of Azure resources are very frequent.</li>
<li class="mce-root">The Terraform <kbd>azurerm</kbd> provider is highly dependent on the Azure Go SDK (<a href="https://github.com/Azure/azure-sdk-for-go">https://github.com/Azure/azure-sdk-for-go</a>), which does not contain real-time Azure updates on new features or even on features that are still in preview.</li>
</ul>
<p class="mce-root">To partially solve this problem, and for organizations that wish to remain in full Terraform, there is a Terraform <kbd>azurerm_template_deployment</kbd> resource that allows you to execute ARM code using Terraform.</p>
<p class="mce-root">In this recipe, we will discuss the execution of ARM code with Terraform.</p>
<h2 id="uuid-a6b706d6-c916-44e9-b4ac-70c559ba9bff">Getting ready</h2>
<p>The Terraform configuration of this recipe will provision an Azure App Service that includes an extension. Since the extension App Service resource is not available in the <kbd>azurerm</kbd> provider at the time of writing this book, the Azure App Service code will be written in <strong>HashiCorp Configuration Language</strong> (<strong>HCL</strong>), and its extension will be provisioned using an ARM template that will be executed with Terraform.</p>
<div class="mce-root packt_infobox">The purpose of the recipe is not to detail the code of the ARM template of the extension but to study its execution with Terraform.</div>
<p class="mce-root">In this recipe, we will present only the key code extracts. The complete source code for this chapter is available at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/arm-template">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/arm-template.</a></p>
<h2 id="uuid-3d304082-2e6d-48a8-891f-76a610348bf8">How to do it…</h2>
<p>To execute the ARM template with Terraform, perform the following steps:</p>
<ol>
<li>Inside the folder that will contain the Terraform configuration, create a new file called <kbd>ARM_siteExtension.json</kbd>, which contains the following extract ARM JSON template:</li>
</ol>
<pre style="padding-left: 60px">{<br/><span>...<br/></span><span>  </span><span>"parameters"</span><span>: </span>{<br/>    <span>"appserviceName"</span><span>: </span>{ ... }<span>,<br/></span><span>    </span><span>"extensionName"</span><span>: </span>{ ... }<span>,<br/></span><span>    </span><span>"extensionVersion"</span><span>: </span>{ ... }<br/>  }<span>,<br/></span><span>  </span><span>"resources"</span><span>: </span>[<br/>    {<br/>      <span>"type"</span><span>: </span><span>"Microsoft.Web/sites/siteextensions"</span><span>,<br/></span><span>      </span><span>"name"</span><span>: </span><span>"[concat(parameters('appserviceName'), '/', parameters('extensionName'))]"</span><span>,</span><span><br/></span><span>      ...</span><span><br/></span><span>      </span><span>"properties"</span><span>: </span>{<br/>        <span>"version"</span><span>: </span><span>"[parameters('extensionVersion')]"<br/></span><span>      </span>}<br/>    }<br/>  ]<br/>}</pre>
<p style="padding-left: 60px">The complete source code of this file is available here: <a href="https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/arm-template/ARM_siteExtension.json">https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/arm-template/ARM_siteExtension.json</a></p>
<ol start="2">
<li>In the <kbd>main.tf</kbd> file, add the following Terraform extract code:</li>
</ol>
<pre style="padding-left: 60px"><span>resource </span><span>"azurerm_template_deployment" </span><span>"extension" </span>{<br/>  <span>name                </span>= <span>"extension"<br/></span><span>  </span><span>resource_group_name </span>= <span>azurerm_resource_group</span>.rg-app.<span>name<br/></span><span>  template_body       </span>= file(<span>"ARM_siteExtension.json"</span>)<br/><br/>  <span>parameters </span>= {<br/>    <span>appserviceName   </span>= <span>azurerm_app_service</span>.app.<span>name<br/></span><span>    extensionName    </span>= <span>"AspNetCoreRuntime.2.2.x64"<br/></span><span>    </span><span>extensionVersion </span>= <span>"2.2.0-preview3-35497"<br/></span><span>  </span>}<br/><br/>  <span>deployment_mode </span>= <span>"Incremental"<br/></span>}</pre>
<p style="padding-left: 60px">The complete source code of this file is available here: <a href="https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/arm-template/main.tf">https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/arm-template/main.tf</a></p>
<ol start="3">
<li>Then, we can execute the basic Terraform workflow with the following:
<ol start="4"/>
<ul>
<li style="font-weight: 400">Authentication with four Azure variable environments, as discussed in the <em>Protecting the Azure credential provider</em><span> recipe </span>of this chapter</li>
<li style="font-weight: 400">The execution of the<span> </span><kbd>init</kbd>,<span> </span><kbd>plan</kbd><span> </span>and<span> </span><kbd>apply</kbd><span> </span>commands, <span>as mentioned previously and in earlier chapters</span></li>
</ul>
</li>
</ol>
<h2 id="uuid-51990ff5-1b1b-41c0-b85c-14646d4801a2">How it works…</h2>
<p>In <em>step 1</em>, in the directory that contains the Terraform configuration, <span>we</span> created a JSON file that contains the ARM code for creating an extension for a App Service. In this ARM file, we have the following three input parameters:</p>
<ul>
<li><kbd>appserviceName</kbd>: This corresponds to the name of the App Service.</li>
</ul>
<ul>
<li><kbd>extensionName</kbd>: This corresponds to the name of the extension to be added (from the extension catalog).</li>
</ul>
<ul>
<li><kbd>extensionVersion</kbd>: This corresponds to the version of the extension to be added.</li>
</ul>
<p>Then, the rest of this file describes the site extension resource to be added in Azure using the three parameters.</p>
<p class="mce-root">Then, in <em>step 2</em>, in the Terraform configuration, we used the Terraform resource <kbd>azurerm_template_deployment</kbd>, which allows execution of an ARM template with the following properties:</p>
<ul>
<li class="mce-root"><kbd>template_body</kbd>: This is the ARM code in JSON format. Here, in our example, we used the file function to indicate that it is a file.</li>
<li class="mce-root"><kbd>parameters</kbd>: In this block, we fill in the input properties of the ARM template, which are <kbd>appserviceName</kbd>, <kbd>extensionName</kbd>, and <kbd>extensionVersion</kbd>. In our recipe, we install the <kbd>AspNetCoreRuntime.2.2.x64</kbd> extension of version <kbd>2.2.0-preview3-35497</kbd>.</li>
</ul>
<p class="mce-root">Finally, to provision this Azure App Service and its extension, the Terraform workflow commands are executed.</p>
<p>The following screenshot shows the result in the Azure portal:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c70f15ab-b3f2-483c-b3cf-e2d03f368600.png"/></p>
<p>We can see the extension provisioned inside the App Service.</p>
<h2 id="uuid-42a9044d-052e-406e-9a43-118cf3a3456e">There's more…</h2>
<p>In this recipe, we have studied the possibility of running an ARM template with Terraform. This method allows you to provision elements in Azure that are not available in the <kbd>azurerm</kbd> provider, but it is important to know that Terraform knows the resources described in this ARM template when it is executed.</p>
<p>That is to say that these resources (here, in our resource, it is the extension) do not follow the life cycle of the Terraform workflow and are not registered in the Terraform state file. The only thing that is written in the Terraform state file is the configuration of the resource, <kbd>azurerm_template_deployment</kbd>, and, as a consequence, for example, if you run the <kbd>terraform destroy</kbd> command on the Terraform configuration, these resources provided by the ARM template will not be destroyed. Instead, only the <kbd>azurerm_template_deployment</kbd> <span>resource </span>will be removed from Terraform state file. For this reason, it is advisable that you use this type of deployment only to complete resources that have been provisioned with Terraform HCL code.</p>
<p class="mce-root">This indeed was our case, since the extension is an integrated complement to the App Service, and if we run <kbd>terraform destroy</kbd>, the App Service will be destroyed as well as all its extensions that are integrated in it.</p>
<div class="mce-root packt_infobox">We have seen the impact on the <kbd>destroy</kbd> command, but it is the same problem on other commands, such as the <kbd>plan</kbd>, <kbd>import</kbd>, or <kbd>refresh</kbd> commands. The resources provided by the ARM template are not known by Terraform.</div>
<p class="mce-root">In addition, the use of an ARM template in Terraform is only effective for a complete ARM resource, as is the case here with an extension, which can be executed as is with the ARM scripts provided by Azure.</p>
<p class="mce-root">In the next recipe, we will stay on the same topic, but instead of using an ARM template, we will see how to use Azure CLI commands with Terraform.</p>
<h2 id="uuid-128339f9-8e00-462a-bde5-f25d95656011">See also</h2>
<ul>
<li>Documentation pertaining to the <kbd>azurerm_template_deployment</kbd> resource of the <kbd>azurerm</kbd> <span>provider </span>is available here: <a href="https://www.terraform.io/docs/providers/azurerm/r/template_deployment.html">https://www.terraform.io/docs/providers/azurerm/r/template_deployment.html</a></li>
<li class="mce-root">A blog article that also explains how to get the JSON code of the ARM template is available at <a href="https://www.phillipsj.net/posts/applying-azure-app-service-extensions-with-arm/">https://www.phillipsj.net/posts/applying-azure-app-service-extensions-with-arm/</a>.<a href="https://www.phillipsj.net/posts/applying-azure-app-service-extensions-with-arm/"/></li>
</ul>
<h1 id="uuid-1a317451-a65e-48b5-ae0d-c7abbb96b45c">Executing Azure CLI commands in Terraform</h1>
<p>In the previous recipe, we studied how to run ARM templates with Terraform in a situation where the provisioned resource is not yet available in the <kbd>azurerm</kbd> provider.</p>
<p class="mce-root">However, there are cases where the use of an ARM template is not possible, such as the following:</p>
<ul>
<li>We want to fill in one or more properties of a resource, which are not autonomous in an ARM template.</li>
<li>The ARM template is not available for the resource to be provisioned.</li>
</ul>
<p>For these situations, there is another solution that entails executing Azure CLI commands with Terraform.</p>
<p class="mce-root">This recipe is a practical application of the <em>Executing local programs with Terraform</em> <span>recipe </span>from <a href="3099c9ac-8c38-4e7d-8146-411fac26a2b7.xhtml">Chapter 2</a>, <em>Writing Terraform Configuration</em>. We will study the Terraform configuration and its execution to integrate Azure CLI commands with Terraform.</p>
<h2 id="uuid-810f733c-179a-4607-8d4b-b2f7abde718b">Getting ready</h2>
<p>For this recipe, it is necessary to have read beforehand the <em>Executing local programs with Terraform</em><span> recipe from <a href="3099c9ac-8c38-4e7d-8146-411fac26a2b7.xhtml"/><a href="3099c9ac-8c38-4e7d-8146-411fac26a2b7.xhtml">Chapter 2</a>, <em>Writing Terraform Configuration</em>,</span> which provides the basis of the Terraform configuration we are going to write.</p>
<p class="mce-root">Moreover, it will also be necessary to have already installed the Azure CLI tool, documentation pertaining to which is available here: <a href="https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest">https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest</a></p>
<p class="mce-root">To demonstrate the use of the Azure CLI command in Terraform, <span>in this recipe, </span>we will set up an Azure Storage Account by configuring the properties of a static website feature on it.</p>
<div class="mce-root packt_infobox">As with the previous recipe, the purpose of this recipe is to show how to use Azure CLI commands with Terraform, but we will not focus on the Azure CLI command used because, since version 2.0.0 of the <kbd>azurerm</kbd> <span>provider, </span>the properties of a static website have been added to the Terraform resource (<a href="https://github.com/terraform-providers/terraform-provider-azurerm/blob/master/CHANGELOG-v2.md#200-february-24-2020">https://github.com/terraform-providers/terraform-provider-azurerm/blob/master/CHANGELOG-v2.md#200-february-24-2020</a>).</div>
<p class="mce-root">The source code for this recipe is available at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/az%20cli">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/az%20cli</a>.</p>
<h2 id="uuid-28ca3d69-4d71-49a8-8bab-41e98d7e3fd4">How to do it…</h2>
<p>Perform the following steps to execute Azure CLI commands with Terraform:</p>
<ol>
<li>In the <kbd>main.tf</kbd> <span>file </span>that contains the Terraform <span>code, </span>write the following configuration for provision to the Storage Account:</li>
</ol>
<pre style="padding-left: 60px"><span>resource </span><span>"azurerm_storage_account" </span><span>"sa" </span>{<br/>  <span>name                     </span>= <span>"saazclidemo"<br/></span><span>  </span><span>resource_group_name      </span>= <span>azurerm_resource_group</span>.rg.<span>name<br/></span><span>  location                 </span>= <span>"westeurope"<br/></span><span>  </span><span>account_tier             </span>= <span>"Standard"<br/></span><span>  </span><span>account_kind             </span>= <span>"StorageV2"<br/></span><span>  </span><span>account_replication_type </span>= <span>"GRS"<br/></span>}</pre>
<ol start="2">
<li> In the same Terraform configuration, add the code to configure the static website using the Azure CLI command:</li>
</ol>
<pre style="padding-left: 60px"><span>resource </span><span>"null_resource" </span><span>"webapp_static_website" </span>{<br/>  <span>triggers </span>= {<br/>    <span>account </span>= <span>azurerm_storage_account</span>.sa.<span>name<br/></span><span>  </span>}<br/><br/>  <span>provisioner </span><span>"local-exec"</span><span> </span>{<br/>    <span>command </span>= <span>"az storage blob service-properties update --account-name ${</span><span>azurerm_storage_account</span><span>.sa.</span><span>name</span><span>} --static-website true --index-document index.html --404-document 404.html"<br/></span><span>  </span>}<br/>}</pre>
<ol start="3">
<li>Then, in our command-line terminal, we log in to Azure by executing the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>az login --service-principal --username APP_ID --password PASSWORD --tenant TENANT_ID</strong></pre>
<ol start="4">
<li>Finally, we can execute the basic Terraform workflow with the following:
<ul>
<li>Authentication with four Azure variable environments, as discussed in the <em>Protecting the Azure credential provider</em> recipe of this chapter</li>
<li>The execution of the <kbd>init</kbd>, <kbd>plan</kbd>, and <kbd>apply</kbd> commands<span>, </span><span>as mentioned previously and in earlier chapters</span></li>
</ul>
</li>
</ol>
<h2 id="uuid-0178f50f-5a47-4f3c-b639-e72c20c33e60">How it works…</h2>
<p>In <em>step 1</em>, there is nothing special. We just wrote the Terraform configuration to provision a <kbd>StorageV2</kbd> Storage Account, which is required to activate the static website feature.</p>
<p class="mce-root">In <em>step 2</em>, we completed this code by adding <kbd>null_resource</kbd> that contains a <kbd>local-exec</kbd> provisioner. In the command property of <kbd>local-exec</kbd>, we put the command Azure CLI that must be executed to activate and configure the static website functionality on the Storage Account we wrote in <em>step 1</em>.</p>
<div class="mce-root packt_infobox">We added the trigger block with the name of the storage as an argument, so that if the name of the storage changes, then provisioning will be re-executed.</div>
<p class="mce-root">Then, in <em>step 3</em>, we executed the <kbd>az login</kbd> command to authenticate the context of the Azure CLI. On this command, we added the authentication parameters with a Service Principal (see the <em>Protecting the Azure credential provider </em>recipe in this chapter), as documented here: <a href="https://docs.microsoft.com/en-us/cli/azure/create-an-azure-service-principal-azure-cli?view=azure-cli-latest#sign-in-using-a-service-principal">https://docs.microsoft.com/en-us/cli/azure/create-an-azure-service-principal-azure-cli?view=azure-cli-latest#sign-in-using-a-service-principal</a>.</p>
<h2 id="uuid-aa959daf-042d-40a4-8f78-820c4d03826f">There's more…</h2>
<p>In the implementation of this recipe, there are two important points:</p>
<ul>
<li class="mce-root">The first point is that we used <kbd>null_resource</kbd> with the <kbd>local-exec</kbd> provisioner that we had already studied in detail in the <em>Executing local programs with Terraform</em><span> recipe from<a href="3099c9ac-8c38-4e7d-8146-411fac26a2b7.xhtml"> Chapter 2</a>, <em>Writing Terraform Configuration</em></span>. The only novelty brought here is the fact that the executed command is an Azure CLI command. It could also be a file that contains a script with several Azure CLI commands.</li>
<li class="mce-root">The second point is that Terraform's authentication for Azure with the four environment variables does not allow authentication of the Azure CLI context that will be executed by Terraform. This is why, in <em>step 3</em>, we also had to authenticate the Azure CLI context with the <kbd>az login</kbd> command by passing the credentials of the Service Principal as parameters.</li>
</ul>
<p class="mce-root">The advantage of executing Azure CLI commands in this way is that we can integrate the variables and expressions of the Terraform language into them, just as we did when we passed the name of the Storage Account as a parameter.</p>
<div class="packt_infobox"><span>Note that, as with any local provisioner, this restricts where the configuration can be applied as it assumes existence of the Azure CLI (the Azure CLI becomes a hidden dependency).</span></div>
<p class="mce-root">As with the ARM templates, we learned in the previous recipe, <em>Executing ARM templates in Terraform</em>, that Terraform does not know the resources manipulated in the Azure CLI command or script. These resources do not follow the Terraform life cycle and are not registered in the Terraform state file. On the other hand, in the <kbd>local-exec</kbd> provisioner of <kbd>null_resource</kbd>, we can specify a command to be executed in the case of execution of the <kbd>terraform destroy</kbd> command.</p>
<p class="mce-root">The following is an example of the configuration that I used to create a CosmosDB database (before the <kbd>azurerm</kbd> <span>provider </span>supported it) that demonstrates the following:</p>
<pre><span>resource </span><span>"null_resource" </span><span>"cosmosdb_database" </span>{<br/>  <span>provisioner </span><span>"local-exec" </span>{<br/>    <span>command </span>= <span>"az cosmosdb database create --name ${var.</span><span>cosmosdb_name</span><span>} --db-name ${var.</span><span>app_name</span><span>}   --resource-group ${var.</span><span>cosmosdb_rg</span><span>} --throughput ${var.</span><span>cosmosdb_throughput</span><span>}"<br/></span><span>  </span>}<br/><br/>  <span>provisioner </span><span>"local-exec" </span>{<br/>   <strong> <span>when    </span>= </strong><span><strong>"destroy"</strong><br/></span><span>    </span><span>command </span>= <span>"az cosmosdb database delete --name ${var.</span><span>cosmosdb_name</span><span>} --db-name ${var.</span><span>app_name</span><span>}   --resource-group ${var.</span><span>cosmosdb_rg</span><span>}"<br/></span><span>  </span>}<br/>}</pre>
<p class="mce-root">In this example, in the provisioner, we used the <kbd>When=destroy</kbd> property to specify that the Azure CLI <span>command, </span><kbd>az cosmosdb database delete</kbd>, will be executed to delete the CosmosDB database in the case of <kbd>terraform destroy</kbd>.</p>
<h2 id="uuid-808ffc9f-d242-493b-8b85-2b21f6562dcd">See also</h2>
<ul>
<li>Documentation pertaining to the <kbd>az login</kbd> command and its parameters is available here: <a href="https://docs.microsoft.com/en-us/cli/azure/authenticate-azure-cli?view=azure-cli-latest">https://docs.microsoft.com/en-us/cli/azure/authenticate-azure-cli?view=azure-cli-latest</a></li>
<li class="mce-root">Documentation pertaining to the Terraform <kbd>provisioner</kbd> is available here: <a href="https://www.terraform.io/docs/provisioners/index.html">https://www.terraform.io/docs/provisioners/index.html</a></li>
<li class="mce-root">Documentation pertaining to the <kbd>when</kbd> property of <kbd>provisioner</kbd> is available here: <a href="https://www.terraform.io/docs/provisioners/index.html#destroy-time-provisioners">https://www.terraform.io/docs/provisioners/index.html#destroy-time-provisioners</a></li>
</ul>
<h1 id="uuid-acbc9d8c-8535-4e88-9e07-dfc1365e3bd5">Using Azure Key Vault with Terraform to protect secrets</h1>
<p>One of the challenges of IaC is the protection of sensitive information that is part of the infrastructure.</p>
<p>Indeed, one of the advantages of IaC is the possibility to version the code in a Git repository and so this code benefits from the Git workflow of versioning and validation of the code. However, with this approach, we tend to write <em>everything</em> in this code, sometimes forgetting that some data that is sensitive, such as passwords or login strings, can be misused if they end up in the wrong hands.</p>
<p class="mce-root">In this recipe, we will study how to protect this sensitive data by storing it in Azure's secret manager, which is Azure Key Vault, and then using it in the Terraform configuration.</p>
<h2 id="uuid-231a7802-ea6e-46e1-86f9-fa701fdfa58c">Getting ready</h2>
<p>For this recipe, we assume the use of Azure Key Vault. For more information, you can refer to the following documentation available at <a href="https://docs.microsoft.com/en-us/azure/key-vault/">https://docs.microsoft.com/en-us/azure/key-vault/</a>.</p>
<p class="mce-root">In an Azure Key Vault that we have created in Azure, as regards the application of this recipe, we store a secret that protects the connection string of the SQL Server database of our application hosted in an Azure web application.</p>
<p class="mce-root">This connection string is as follows:</p>
<pre class="mce-root">Data Source=mysever.com;initial catalog=databasedemo;User ID=useradmin;Password=demobook</pre>
<p class="mce-root">Here is the output of the Azure CLI <span>command,</span> <kbd>az keyvault secret show</kbd>, which shows its storage and properties in Azure Key Vault:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/258b1b3b-f223-4e5f-a3c8-df790a793bb5.png"/></p>
<p class="mce-root">In the preceding screenshot, we can see the connection string of the database stored in the <kbd>value</kbd> property of the <kbd>secret</kbd> object.</p>
<p class="mce-root">The goal of this recipe is to write the Terraform configuration that requests the value of this secret to use it in the properties of an Azure App Service.</p>
<p class="mce-root">The source code for this recipe is available here: <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/keyvault">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/keyvault</a></p>
<h2 id="uuid-0d6d2a59-b0ee-40eb-a59c-3b96a89f021f">How to do it…</h2>
<p>To get and use an Azure Key Vault secret in Terraform, perform the following steps:</p>
<ol>
<li>In Azure Key Vault, we add access policy properties by granting the Service Principal that will be used by Terraform for Azure to have permission to get and list secrets:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e317dc9a-9653-4b99-a7a2-aa0dddc28884.png" style="width:40.75em;height:37.92em;"/></p>
<ol start="2">
<li>In the <kbd>main.tf</kbd> file, we add the following code to get the Key Vault secret:</li>
</ol>
<pre style="padding-left: 60px"><span>data </span><span>"azurerm_key_vault" </span><span>"keyvault" </span>{<br/>  <span>name                </span>= <span>"keyvdemobook"<br/></span><span>  </span><span>resource_group_name </span>= <span>"rg_keyvault"<br/></span>}<br/><br/><span>data </span><span>"azurerm_key_vault_secret" </span><span>"app-connectionstring" </span>{<br/>  <span>name         </span>= <span>"ConnectionStringApp"<br/></span><span>  </span><span>key_vault_id </span>= data.<span>azurerm_key_vault</span>.<span>keyvault</span>.<span>id<br/></span>}</pre>
<ol start="3">
<li>Then, in the Terraform configuration of the App Service resource, in the <kbd>main.tf</kbd> file, we add the following code:</li>
</ol>
<pre style="padding-left: 60px"><span>resource </span><span>"azurerm_app_service" </span><span>"app" </span>{<br/>  <span>name                </span>= <span>"demovaultbook"<br/></span><span>  </span><span>location            </span>= <span>azurerm_resource_group</span>.rg-app.<span>location<br/></span><span>  resource_group_name </span>= <span>azurerm_resource_group</span>.rg-app.<span>name<br/></span><span>  app_service_plan_id </span>= <span>azurerm_app_service_plan</span>.plan-app.<span>id<br/></span><span><br/></span><span>  </span><span>connection_string </span>{<br/>    <span>name  </span>= <span>"Database"<br/></span><span>    </span><span>type  </span>= <span>"SQLServer"<br/></span><span>    </span><span>value </span>= <strong>data.<span>azurerm_key_vault_secret</span>.<span>app-connectionstring</span>.</strong><span><strong>value</strong><br/></span><span>  </span>}<br/>}</pre>
<ol start="4">
<li>Finally, we run the basic Terraform workflow for Azure with set variable environments and execute <kbd>init</kbd>, <kbd>plan</kbd>, and <kbd>apply</kbd>, <span>as mentioned previously and in earlier chapters.</span></li>
</ol>
<h2 id="uuid-84f3d98d-5667-4c8e-a5ff-9d1dc06f9c8e">How it works…</h2>
<p>In <em>step 1</em>, we gave permission to the Service Principal used by Terraform to read and list the secrets of Azure Key Vault.</p>
<div class="packt_infobox">We can do this either via the Azure portal or on the command line with the Azure CLI, as explained in the following documentation: <a href="https://docs.microsoft.com/en-us/cli/azure/keyvault?view=azure-cli-latest#az-keyvault-set-policy">https://docs.microsoft.com/en-us/cli/azure/keyvault?view=azure-cli-latest#az-keyvault-set-policy</a></div>
<p>If we had not carried out this step, we would have obtained the following error when executing the <kbd>terraform plan</kbd> command:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/caeee7cf-93b8-4b4d-856c-c52fcae7cd0e.png"/></p>
<p class="mce-root">Then, in <em>step 2</em>, we wrote the Terraform configuration, which contains two data sources:</p>
<ul>
<li class="mce-root">The first data source, <span><kbd>azurerm_key_vault</kbd>, </span>enables retrieval of the Azure ID of the Azure Key Vault resource.</li>
<li class="mce-root">The second data source, <kbd><span>azurerm_key_vault_secret</span></kbd>, is used to retrieve the secret that contains the database connection string as a value.</li>
</ul>
<div class="mce-root packt_infobox">For more information about Terraform block data, read the <em>Using external resources with a data block</em> recipe from <a href="3099c9ac-8c38-4e7d-8146-411fac26a2b7.xhtml">Chapter 2</a>, <em>Writing Terraform Configuration</em>.</div>
<p class="mce-root">In <em>step 3</em>, we continue with the writing of the Terraform configuration, putting in the property value of the <kbd>connection_string</kbd> <span>block </span>of the App Service with the expression <kbd>data.azurerm_key_vault_secret.app-connectionstring.value</kbd>, which is the value obtained from the block data, <kbd><span>azurerm_key_vault_secret</span></kbd>, written in <em>step 2</em>.</p>
<p class="mce-root">Finally, in the last step, we execute this Terraform configuration. During this operation, Terraform will first retrieve the values requested in the block data (Key Vault, and then the Key Vault secret) and will then inject the value obtained from the secret into the configuration of the App Service.</p>
<p class="mce-root">This result is obtained in Azure and shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7bc29f65-1ee9-42a8-8e90-40c052927723.png"/></p>
<p class="mce-root">We can see that the connection string is well filled in the App Service configuration.</p>
<h2 id="uuid-4b79f033-85c0-42eb-b7e8-5d733eb19559">There's more…</h2>
<p>We have learned in this recipe that the connection string, which is sensitive data, has been stored in Azure Key Vault and will be used automatically when Terraform is run. So, thanks to Azure Key Vault, we didn't need to put the sensitive data in clear text in the Terraform configuration.</p>
<p class="mce-root">However, care should still be taken. Although this data is not written in plain text in the Terraform configuration, it will be written in plain text in the Terraform state file, as can be seen in this extract of the <span>Terraform state file </span>content from this recipe:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/da59826f-3dd9-46fa-819a-195eeed80248.png"/></p>
<p>That is why, if we need to inspect the contents of this file, it is recommended to use the <kbd>terraform state show</kbd> or <kbd>terraform show</kbd> <span>commands, which </span>protect the displaying of sensitive data, as can be seen in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4526cc47-cc0b-41b0-a4a6-c809d60a189a.png"/></p>
<p class="mce-root">This is one of the reasons why it is necessary to protect this <kbd>tfstate</kbd> file by storing it in a secure remote backend, as we have seen in the <em>Protecting the state file in the Azure remote backend</em> <span>recipe </span>of this chapter, and which is explained in the following documentation: <a href="https://www.terraform.io/docs/state/sensitive-data.html">https://www.terraform.io/docs/state/sensitive-data.html</a></p>
<p class="mce-root">Also in this recipe, although we stored the sensitive data in Azure Key Vault, we can also store it in a HashiCorp Vault instance that integrates very well with Terraform. For this, it is advisable that you read the vault provider <span>documentation </span>here: <a href="https://www.terraform.io/docs/providers/vault/index.html">https://www.terraform.io/docs/providers/vault/index.html</a></p>
<p class="mce-root">Finally, as a prerequisite for this recipe, we manually created the secret of the connection string in Azure Key Vault. This could have been done either with Terraform, as documented here (<a href="https://www.terraform.io/docs/providers/azurerm/r/key_vault_secret.html">https://www.terraform.io/docs/providers/azurerm/r/key_vault_secret.html</a>), or with the Azure CLI commands, as documented here (<a href="https://docs.microsoft.com/en-us/cli/azure/keyvault/secret?view=azure-cli-latest#az-keyvault-secret-set">https://docs.microsoft.com/en-us/cli/azure/keyvault/secret?view=azure-cli-latest#az-keyvault-secret-set</a>). On the other hand, in this case, since the data will be written in clear text in the code, it will be necessary to secure it well by giving read and write permissions only to authorized persons.</p>
<h2 id="uuid-330ab32a-7ff8-424f-b83e-f2f96d3c461d">See also</h2>
<ul>
<li>Documentation on the block data, <kbd><span>azurerm_key_vault_secret</span></kbd>, is available here: <a href="https://www.terraform.io/docs/providers/azurerm/d/key_vault_secret.html">https://www.terraform.io/docs/providers/azurerm/d/key_vault_secret.html</a></li>
</ul>
<h1 id="uuid-86d48515-b3ed-4d13-9e54-3970e9271cad">Getting a list of Azure resources in Terraform</h1>
<p>In the previous recipe, we learned the practical case of using a <kbd>data</kbd> block to obtain the properties of an Azure resource.</p>
<p class="mce-root">We will look in this recipe at a data source in the <kbd>azurerm</kbd> provider that is generic and allows you to get information about any provisioned resource in Azure.</p>
<h2 id="uuid-023ee551-e3d3-447a-b03d-0623adae4e95">Getting ready</h2>
<p>In this recipe, we will write a Terraform configuration that adds security rules to several Azure <strong>Network Security Groups</strong> (<strong>NSGs</strong>) already provisioned (manually or by Terraform). Its purpose is to add these rules to all NSGs that have the tag <kbd>DEFAULTRULES=TRUE</kbd>.</p>
<p class="mce-root">In addition, we have already created three NSGs in the Resource Group called <kbd>RG-DEMO</kbd>. Among these NSGs, only NSG1 and NSG2 have the tag <kbd>DEFAULTRULES=TRUE</kbd>.</p>
<p>The source code for this recipe is available here: <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/listresources">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/listresources</a></p>
<h2 id="uuid-84b37a10-636c-4bd5-8e0f-d2e24e76791a">How to do it…</h2>
<p>Perform the following steps in order to get Azure resources:</p>
<ol>
<li>In the <kbd>main.tf</kbd> file that contains the Terraform configuration, add the following code to get provisioned NSGs:</li>
</ol>
<pre style="padding-left: 60px"><span>data </span><span>"<strong>azurerm_resources</strong>" </span><span>"nsg" </span>{<br/>  <span>type                </span>= <span>"Microsoft.Network/networkSecurityGroups"<br/></span><span>  </span><span>resource_group_name </span>= <span>"RG-DEMO"<br/></span><span>  </span><span>required_tags </span>= {<br/>    <span>DEFAULTRULES </span>= <span>"TRUE"<br/></span><span>  </span>}<br/>}</pre>
<ol start="2">
<li>Then, in the same file, add the following code to create rules:</li>
</ol>
<pre style="padding-left: 60px"><span>resource </span><span>"azurerm_network_security_rule" </span><span>"default-rules" </span>{<br/>  <strong><span>for_each                    </span>= { for n in  <br/>                                  data.<span>azurerm_resources</span>.<span>nsg</span>.<span>resources <br/></span>                                  : <span>n</span>.name =&gt; n }</strong><br/>  <span>name                        </span>= <span>"${</span><strong><span>each</span></strong><span><strong>.key</strong></span><span>}-SSH"<br/></span><span>  </span><span>priority                    </span>= <span>100<br/></span><span>  </span><span>direction                   </span>= <span>"InBound"<br/></span><span>  </span><span>access                      </span>= <span>"Allow"<br/></span><span>  </span><span>protocol                    </span>= <span>"Tcp"<br/></span><span>  </span><span>source_port_range           </span>= <span>"*"<br/></span><span>  </span><span>destination_port_range      </span>= <span>"22"<br/></span><span>  </span><span>source_address_prefix       </span>= <span>"*"<br/></span><span>  </span><span>destination_address_prefix  </span>= <span>"*"<br/></span><span>  </span><span>resource_group_name         </span>= <span>"RG-DEMO"<br/></span><span>  </span><span>network_security_group_name </span>= <strong><span>each</span>.key</strong><br/>}</pre>
<ol start="3">
<li>Finally, we run the basic Terraform workflow for Azure with set variable environments and execute<span> </span><kbd>init</kbd>,<span> </span><kbd>plan</kbd><span>,</span><span> </span>and<span> </span><kbd>apply</kbd><span>, as mentioned previously and in earlier chapters.</span></li>
</ol>
<h2 id="uuid-923a9118-2ecd-40ca-a7a5-80555e2ba0e7">How it works…</h2>
<p>In <em>step 1</em>, we used the <kbd>azurerm_resources</kbd> <span>data </span>object, which allows you to obtain the basic properties of any already provisioned Azure resource. To this object, we configured the following properties:</p>
<ul>
<li><kbd>type</kbd>: This is the type of resource to request. The list of types is documented here: <a href="https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-services-resource-providers">https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-services-resource-providers</a>. Here, we filled in the value <kbd>Microsoft.Network/networkSecurityGroups</kbd>.</li>
<li><kbd>resource_group_name</kbd>: This is the name of the Resource Group in which the NSGs have been provisioned.</li>
<li><kbd>required_tag</kbd>: This is the list of tags on which we want to filter NSGs.</li>
</ul>
<p>Then, in <em>step 2</em>, we completed this Terraform configuration by adding the <kbd>azurerm_network_security_rule</kbd> resource, which enables the provision of rules in already existing NSGs. In this resource, we first added the expression <kbd>for_each</kbd>, which facilitates a loop on all NSGs that are returned from the previously instantiated data block. In the construction of this loop, we used the expression <kbd>data.azurerm_resources.nsg.resources</kbd>, which contains a list of NSGs retrieved from the <kbd>data</kbd> block. Moreover, in the <kbd>name</kbd> property, we add a prefix, which is the name of the NSG, using the expression <kbd>each.key</kbd>. Finally, in the <kbd>network_security_group_name</kbd> property, we also use <kbd>each.key</kbd> as the name of each NSG iterated in the loop.</p>
<p class="mce-root">For more information on the <kbd>for_each</kbd> <span>expression </span>and loops in Terraform, refer to the recipes in <a href="d019fed0-6c22-4da8-9796-58d45feafa2c.xhtml">Chapter 3</a>, <em>Building Dynamic Environments with Terraform</em>.</p>
<p class="mce-root">Finally, in <em>step 3</em>, we execute the Terraform workflow commands to apply this Terraform configuration.</p>
<h2 id="uuid-2ce7c0f5-541e-4b07-ba46-8c91fff42833">There's more…</h2>
<p>We have learned in this recipe that by using <kbd><span>azurerm_resources</span></kbd><span>, </span>in Terraform, <span>we can use </span>any Azure resource that is already provisioned.</p>
<p>In the Terraform configuration, we can also add the following <kbd>output</kbd> variable, which allows a visualization of the resources returned by the <kbd>azurerm_resource</kbd> <span>data block:</span></p>
<pre><span>output </span><span>"nsg" </span>{<br/>  <span>value </span>= { for n in data.<span>azurerm_resources</span>.<span>nsg</span>.<span>resources </span>: <span>n</span>.name =&gt; n }<br/>}</pre>
<p class="mce-root">The following screenshot shows the result of this output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c68faccb-d32d-4c8b-87fc-76a42d1695e8.png"/></p>
<p class="mce-root">We can see in this output result that the <kbd>data</kbd> block has recovered the two NSGs that are provisioned and has the tag <kbd>DEFAULTRULEs=TRUE</kbd>. Moreover, you can also see the properties of each resource that it is possible to exploit in the rest of the Terraform configuration.</p>
<p>However, it must be ensured that these resources are provisioned in the same subscription as defined in the environment variable, <kbd>ARM_SUBSCRIPTION_ID</kbd>, which is set before executing the Terraform commands, as we have seen in the <em>Protecting the Azure credential provider</em> recipe of this chapter.</p>
<h2 id="uuid-07d1e3a3-4986-4bab-af83-b2b86c609c45" class="">See also</h2>
<ul>
<li>Documentation pertaining to the <kbd>azurerm_resources</kbd> <span>object data </span>of Terraform is available here: <a href="https://www.terraform.io/docs/providers/azurerm/d/resources.html">https://www.terraform.io/docs/providers/azurerm/d/resources.html</a></li>
</ul>
<h1 id="uuid-8adeca93-cef6-4303-89d4-fd0608e56ed6">Provisioning and configuring an Azure VM with Terraform</h1>
<p>In this recipe, we will study a typical use case of Terraform in Azure in which we will provision and configure a VM in Azure using Terraform.</p>
<h2 id="uuid-bbc405b9-1979-46e8-bd50-0f80e817c8a1">Getting ready</h2>
<p>For this recipe, we don't need any special prerequisites. We will start the Terraform configuration from scratch. This recipe will only involve writing the Terraform configuration. In its stages of realization, we will study the writing of this code. As for the architecture in Azure, we have already built a network beforehand, which will contain this VM and which is made up of the following resources:</p>
<ul>
<li>A <strong>virtual network</strong> (<strong>VNet</strong>) called <kbd>VNET-DEMO</kbd>.</li>
<li>Inside this VNet, a Subnet named <kbd>Subnet1</kbd> is registered.</li>
</ul>
<p class="mce-root">In addition, the VM that will be provisioned will have a public IP address so that it can be accessed publicly.</p>
<p>Finally, in keeping the VM's password secret in the code, we protect it in an Azure Key Vault, as studied in the <em>Using Azure Key Vault with Terraform to protect secrets</em> <span>recipe </span>of this chapter.</p>
<p class="mce-root">The source code for this chapter is available here: <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/vm">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/vm</a></p>
<h2 id="uuid-ac9f4511-4a09-4784-bdbf-8062f63b7c50">How to do it…</h2>
<p>Write the following Terraform configuration to provision a VM with Terraform:</p>
<ol>
<li>The first resource to build is the Resource Group, with the help of the following code:</li>
</ol>
<pre style="padding-left: 60px"><span>resource </span><span>"azurerm_resource_group" </span><span>"rg" </span>{<br/>  <span>name     </span>= <span>"RG-VM"<br/></span><span>  </span><span>location </span>= <span>"West Europe"<br/></span>}</pre>
<ol start="2">
<li>Then, we write the following code to provision the public IP:</li>
</ol>
<pre style="padding-left: 60px"><span>resource </span><span>"azurerm_public_ip" </span><span>"ip" </span>{<br/>  <span>name                </span>= <span>"vmdemo-pip"<br/></span><span>  </span><span>resource_group_name </span>= <span>azurerm_resource_group</span>.rg.<span>name<br/></span><span>  location            </span>= <span>azurerm_resource_group</span>.rg.<span>location<br/></span><span>  allocation_method   </span>= <span>"Dynamic"<br/></span>}</pre>
<ol start="3">
<li>We continue by writing the code for the Network Interface:</li>
</ol>
<pre style="padding-left: 60px"><span>data </span><span>"azurerm_subnet" </span><span>"subnet"</span>{<br/>  <span>name </span>= <span>"Default1"<br/></span><span>  </span><span>resource_group_name </span>= <span>"RG_NETWORK"<br/></span><span>  </span><span>virtual_network_name </span>= <span>"VNET-DEMO"<br/></span>}<br/><br/><span>resource </span><span>"azurerm_network_interface" </span><span>"nic" </span>{<br/>  <span>name                </span>= <span>"vmdemo-nic"<br/></span><span>  </span><span>resource_group_name </span>= <span>azurerm_resource_group</span>.rg.<span>name<br/></span><span>  location            </span>= <span>azurerm_resource_group</span>.rg.<span>location<br/></span><span><br/></span><span>  </span><span>ip_configuration </span>{<br/>    <span>name                          </span>= <span>"vmipconf"<br/></span><span>    </span><span>subnet_id                     </span>= data.<span>azurerm_subnet</span>.<span>subnet</span>.<span>id<br/></span><span>    private_ip_address_allocation </span>= <span>"Dynamic"<br/></span><span>    </span><span>public_ip_address_id          </span>= <span>azurerm_public_ip</span>.ip.<span>id<br/></span><span>  </span>}<br/>}</pre>
<ol start="4">
<li>We get the VM password by using the <kbd>keyvault</kbd> data block:</li>
</ol>
<pre style="padding-left: 60px"><span>data </span><span>"azurerm_key_vault" </span><span>"keyvault" </span>{<br/>  <span>name                </span>= <span>"keyvdemobook"<br/></span><span>  </span><span>resource_group_name </span>= <span>"rg_keyvault"<br/></span>}<br/><br/><span>data </span><span>"azurerm_key_vault_secret" </span><span>"vm-password" </span>{<br/>  <span>name         </span>= <span>"vmdemoaccess"<br/></span><span>  </span><span>key_vault_id </span>= data.<span>azurerm_key_vault</span>.<span>keyvault</span>.<span>id<br/></span>}</pre>
<ol start="5">
<li>Finally, we write the code for the VM resource, as follows:</li>
</ol>
<pre style="padding-left: 60px"><span>resource </span><span>"azurerm_linux_virtual_machine" </span><span>"vm" </span>{<br/>  <span>name                            </span>= <span>"myvmdemo"<br/></span><span>...<br/></span><span>  </span><span>admin_username                  </span>= <span>"adminuser"<br/></span><span>  </span><span>admin_password                  </span>= data.<span>azurerm_key_vault_secret</span>.<span>vm-password</span>.<span>value</span><span><br/></span><span>  </span><span>network_interface_ids </span>= [<span>azurerm_network_interface</span>.nic.<span>id</span>]<br/><br/>  <span>source_image_reference </span>{<br/>    <span>publisher </span>= <span>"Canonical"<br/></span><span>    </span><span>offer     </span>= <span>"UbuntuServer"<br/></span><span>    </span><span>sku       </span>= <span>"18.04-LTS"<br/></span><span>    </span><span>version   </span>= <span>"latest"<br/></span><span>  </span>}<br/>...<br/><br/>  <span>provisioner </span><span>"remote-exec" </span>{<br/>    <span>inline </span>= [<br/>      <span>"apt update"</span><span>,<br/></span><span>    </span>]<br/>    <span>connection </span>{<br/>      <span>host     </span>= self.<span>public_ip_address<br/></span><span>      user     </span>= self.<span>admin_username<br/></span><span>      password </span>= self.<span>admin_password<br/></span><span>    </span>}<br/>  }<br/>}</pre>
<p>The complete source code for these VM resources is available at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/vm/main.tf">https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/vm/main.tf</a>.</p>
<h2 id="uuid-524e058c-9a80-4f43-b529-65c0a5cc55d9">How it works…</h2>
<p>In <em>step 1</em>, we wrote the Terraform configuration that will create the Resource Group containing the VM. This step is optional because you can provision the VM in an existing Resource Group, and in this case you can use the <kbd>azurerm_resource_group</kbd> <span>block data, </span>whose documentation is available here: <a href="https://www.terraform.io/docs/providers/azurerm/d/resource_group.html">https://www.terraform.io/docs/providers/azurerm/d/resource_group.html</a></p>
<p class="mce-root">Then, in <em>steps 2</em> and <em>3</em>, we wrote the Terraform configuration that provides the following:</p>
<ul>
<li class="mce-root">A public IP of the dynamic type, so that we don't have to set the IP address (this IP address will be the first free address of the subnet).</li>
<li class="mce-root">The Network Interface of the VM that uses this IP address, and which will register in the Subnet that has already been created. To retrieve the subnet ID, we used an <kbd>azurerm_subnet</kbd> data source.</li>
</ul>
<p class="mce-root">In <em>step 4</em>, we use the <kbd><span>azurerm_key_vault_secret</span></kbd> <span>data source </span>to get the password of the VM (refer to the <em>Using Azure Key Vault with Terraform</em> <em>to protect secrets</em> recipe for more details).</p>
<p class="mce-root">Finally, in <em>step 5</em>, we write the code that will provision the VM. In this code, we have defined the following properties of the VM:</p>
<ul>
<li class="mce-root">Its name and size (which includes its RAM and CPU)</li>
<li class="mce-root">The basic image used, which is an Ubuntu image</li>
<li class="mce-root">Authentication information for the VM with a login and a password (an SSH key can also be used)</li>
</ul>
<p class="mce-root">In this resource, we also added a <kbd>remote-exec</kbd> provisioner, which allows you to <span>remotely </span>execute commands or scripts directly on the VM that will be provisioned. The use of this provisioner will allow you to configure the VM for administration, security, or even middleware installation tasks.</p>
<h2 id="uuid-b334320d-79d3-4094-9ad6-f75ecc0f10d9">There's more…</h2>
<p>The interesting and new aspect of this recipe is the addition of the <kbd>remote-exec</kbd> provisioner, which enables configuration of the VM using commands or scripts. This method can be useful in performing the first steps of VM administration, such as opening firewall ports, creating users, and other basic tasks. Here in our recipe, we used it to update the packages with the execution of the <kbd>apt update</kbd> command. However, this method requires that this VM is accessible from the computer running Terraform because it connects to the VM (SSH or WinRM) and executes the commands.</p>
<p class="mce-root">If you want to keep a real IaC, it is preferable to use an as-code configuration tool, such as Ansible, Puppet, Chef, or PowerShell DSC. And so, in the case of using Ansible to configure a Windows VM, the <kbd>remote-exec</kbd> provisioner can perfectly serve to authorize the WinRM SSL protocol on my VM because this port is the port used by Ansible to configure Windows machines.</p>
<p><span>Moreover, in Azure, you can also use a custom script VM extension, which is another alternative to configuring VMs using a script. </span><span>In this case, you can provision this VM extension with Terraform using the </span><kbd>azurerm_virtual_machine_extension</kbd><span> resource, as explained in the following documentation: </span><a href="https://www.terraform.io/docs/providers/azurerm/r/virtual_machine_extension.html">https://www.terraform.io/docs/providers/azurerm/r/virtual_machine_extension.html</a></p>
<div class="mce-root packt_infobox"><br/>
<span class="packt_screen">Warning</span>: There can only be one custom script extension per VM. Therefore, you have to put all the configuration operations in a single script.</div>
<p class="mce-root">Apart from providing <kbd>remote-exec</kbd> and the VM extension, another solution is to use the <kbd>custom_data</kbd> property of the Terraform resource, <kbd>azurerm_virtual_machine</kbd>. Documentation pertaining to the <kbd>custom_data</kbd> property is available at <a href="https://www.terraform.io/docs/providers/azurerm/r/linux_virtual_machine.html#custom_data">https://www.terraform.io/docs/providers/azurerm/r/linux_virtual_machine.html#custom_data</a>, and a complete code sample is available at <a href="https://github.com/terraform-providers/terraform-provider-azurerm/blob/master/examples/virtual-machines/linux/custom-data/main.tf">https://github.com/terraform-providers/terraform-provider-azurerm/blob/master/examples/virtual-machines/linux/custom-data/main.tf</a>.</p>
<p>Finally, by way of another alternative for VM configuration, we can also preconfigure the VM image with all the necessary software using <strong>Packer</strong>, which is another open source tool from HashiCorp and allows you to create your own VM image using JSON or HCL2 (as documented at <a href="https://www.packer.io/guides/hcl">https://www.packer.io/guides/hcl</a>). Once this image is created, in the Terraform VM configuration, we will set the name of the image created by Packer instead of the image provided by the Marketplace (Azure or other cloud providers). For more information about Packer, read the following documentation: <a href="https://www.packer.io/">https://www.packer.io/</a></p>
<h2 id="uuid-3e9450af-6a15-4bed-8e53-19e56c3dc5d8">See also</h2>
<p>Various tutorials and guides are available in the Azure documentation available here: <a href="https://docs.microsoft.com/en-us/azure/developer/terraform/create-linux-virtual-machine-with-infrastructure">https://docs.microsoft.com/en-us/azure/developer/terraform/create-linux-virtual-machine-with-infrastructure</a></p>
<h1 id="uuid-0f7b4900-8505-4613-9f7b-8bc047cbcd9f">Building Azure serverless infrastructure with Terraform</h1>
<p>In the previous recipe, we studied the implementation of the Terraform configuration that allows the provisioning of an IaaS (that is, a VM) infrastructure in Azure.</p>
<p class="mce-root">In this recipe, we will stay in the same realm as the previous recipe, but this time we will focus on writing the Terraform configuration that is used to provision a PaaS serverless infrastructure with the provisioning of an Azure App Service.</p>
<h2 id="uuid-3d15d789-02f6-4535-a6a4-ab59b22f7642">Getting ready</h2>
<p>The purpose of this recipe is to provision and configure an Azure App Service of the Web App type. In addition to provisioning, we will deploy an application in this Web App at the same time as it is being provisioned using Terraform.</p>
<p class="mce-root">Most of the Terraform configuration needed for this recipe has already been studied in several recipes in this book. We will just study the Terraform configuration needed to deploy the application in this Web App.</p>
<p class="mce-root">Regarding the application, it must be packaged in a ZIP file that is in the format <kbd>&lt;appname&gt;_&lt;version&gt;.zip</kbd>, such as, for example, <kbd>myapp_v0.1.1.zip</kbd>, and then we will upload this ZIP file in an Azure blob storage. This ZIP file can be uploaded either via the command line Azure CLI, as indicated in this documentation, <a href="https://docs.microsoft.com/en-us/cli/azure/storage/blob?view=azure-cli-latest#az-storage-blob-upload">https://docs.microsoft.com/en-us/cli/azure/storage/blob?view=azure-cli-latest#az-storage-blob-upload</a>, or via Terraform using the <kbd>azurerm_storage_blob</kbd> <span>resource, </span>whose documentation is available here: <a href="https://www.terraform.io/docs/providers/azurerm/r/storage_blob.html">https://www.terraform.io/docs/providers/azurerm/r/storage_blob.html</a></p>
<p class="mce-root">The Terraform configuration we will write in this recipe will use this ZIP file in a secure way. The source code for this recipe is available at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/webapp">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/webapp.</a></p>
<h2 id="uuid-6cbef455-0e0d-4610-ad7d-a98325c32c18">How to do it…</h2>
<p>Perform the following steps to provision a Web App with Terraform:</p>
<ol>
<li>Copy and paste, in a new Terraform file, the Web App Terraform from <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/sample-app">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP06/sample-app</a>.</li>
<li>Inside this Terraform file, we add a new <kbd>azurerm_storage_account</kbd> <span>data block </span>with the following code:</li>
</ol>
<pre style="padding-left: 60px"><span>data </span><span>"azurerm_storage_account" </span><span>"storagezip" </span>{<br/>  <span>name                </span>= <span>"storappdemo"<br/></span><span>  </span><span>resource_group_name </span>= <span>"RG-storageApp"<br/></span>}</pre>
<ol start="3">
<li>Then, we add another <kbd>azurerm_storage_account_sas</kbd> <span>data block </span>to get a security token with the following extract code:</li>
</ol>
<pre style="padding-left: 60px"><span>data </span><span>"azurerm_storage_account_sas" </span><span>"storage_sas" </span>{<br/>  <span>connection_string </span>= data.<span>azurerm_storage_account</span>.<span>storagezip</span>.<span>primary_connection_string<br/></span><span>...</span><br/>  <span>services </span>{<br/>    <span>blob  </span>= <span>true<br/></span><span>...<br/></span><span>  </span>}<br/>  <span>start  </span>= <span>"2020–06–15"<br/></span><span>  </span><span>expiry </span>= <span>"2021–03–21"<br/></span><span>  </span><span>permissions </span>{<br/>    <span>read    </span>= <span>true<br/></span><span>    </span><span>write   </span>= <span>false<br/></span><span>   ...</span><span><br/></span><span>  </span>}<br/>}</pre>
<p style="padding-left: 60px">The complete code of this block is available at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/webapp/main.tf">https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/webapp/main.tf</a>.<a href="https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP06/webapp/main.tf"/></p>
<ol start="4">
<li>Finally, we update the code of the Azure Web App in <kbd>azurerm_app_resource</kbd> by adding the following code:</li>
</ol>
<pre style="padding-left: 60px"><span>resource </span><span>"azurerm_app_service" </span><span>"app" </span>{<span><br/></span><span>...<br/></span><span>  app_settings </span>= {<br/>    <span>"WEBSITE_RUN_FROM_PACKAGE" </span>= <span>"https://${data.</span><span>azurerm_storage_account</span><span>.</span><span>storagezip</span><span>.</span><span>name</span><span>}.blob.core.windows.net/app/myapp_v1.0.0/zip${data.</span><span>azurerm_storage_account_sas</span><span>.</span><span>storage_sas</span><span>.</span><span>sas</span><span>}"<br/></span><span>  </span>}<br/>}</pre>
<h2 id="uuid-0c99b607-5ebd-4bef-abf5-6e834237387c">How it works…</h2>
<p>In <em>step 1</em>, we retrieved the Terraform configuration that allows a Web App <span>to be provisioned</span>. In the following steps of the recipe, we will complete it in order to be able to deploy a web application directly in this Web App, with Terraform, at the same time as its provisioning.</p>
<p>Then, in <em>step 2</em>, we add the <kbd>azurerm_storage_account</kbd> <span>data block, </span>which will allow us to retrieve properties from the Storage Account that contains the ZIP file of the application. In <em>step 3</em>, we add the <kbd>azurerm_storage_account_sas</kbd> <span>data block, w</span>hich will return a security token to the blob.</p>
<p>In this token, we indicate that the access will be read-only, and that we only give access to the blob service.</p>
<p class="mce-root">Finally, in <em>step 4</em>, we complete the resource <kbd>azurerm_app_service</kbd> by adding in the application settings of the <kbd>WEBSITE_RUN_FROM_PACKAGE</kbd> <span>key, </span>which contains, by way of a value, the complete URL of the ZIP file and in which we concatenated the token key returned in the block.</p>
<h2 id="uuid-44b17dcf-1273-4d75-b2a4-c9c75618b7e4">There's more…</h2>
<p>In this recipe, we have studied the possibility of provisioning an Azure Web App and deploying it with Terraform. There are, however, several other ways to deploy this application in the Web App, as explained in the documentation available at <a href="https://docs.microsoft.com/en-us/azure/app-service/deploy-zip">https://docs.microsoft.com/en-us/azure/app-service/deploy-zip</a>.</p>
<p class="mce-root">We will learn in the <em>Building CI/CD pipelines for Terraform configuration in Azure pipelines</em> <span>recipe </span>in <a href="905f7886-2827-44fe-af8c-4f9f3e3a9cef.xhtml">Chapter 7</a>, <em>Terraform Deep Dive,</em> how to automate this deployment in a CI/CD pipeline in Azure Pipelines.</p>
<h2 id="uuid-18250f7c-89ba-469f-8e74-4469e9b8e673">See also</h2>
<ul>
<li>Documentation pertaining to the <kbd>WEBSITE_RUN_FROM_PACKAGE</kbd> app setting of a Web App is available here: <a href="https://docs.microsoft.com/en-us/azure/app-service/deploy-run-package">https://docs.microsoft.com/en-us/azure/app-service/deploy-run-package</a></li>
<li class="mce-root">Documentation pertaining to the <kbd>azurerm_storage_account_sas</kbd> <span>block data </span>is available here: <a href="https://www.terraform.io/docs/providers/azurerm/d/storage_account_sas.html">https://www.terraform.io/docs/providers/azurerm/d/storage_account_sas.html</a></li>
<li class="mce-root">Documentation pertaining to the Terraform resource, <kbd>azurerm_app_service</kbd>, is available here: <a href="https://www.terraform.io/docs/providers/azurerm/r/app_service.html">https://www.terraform.io/docs/providers/azurerm/r/app_service.html</a></li>
</ul>
<p><a href="https://github.com/mikaelkrief/terraform-wrapper/"/></p>
<h1 id="uuid-ebbe38eb-c0f8-4d15-8d0c-203d270fe517">Generating a Terraform configuration for existing Azure infrastructure</h1>
<p>When enterprises want to automate their processes and adopt IaC<span> </span>practices (for example, with Terraform), they face the challenge of how to generate code for an infrastructure that is already provisioned.</p>
<p class="mce-root">Indeed, for new infrastructures, it is sufficient to write the corresponding Terraform configuration and then execute it in order to provision it. On the other hand, for resources that are already provisioned, depending on their number and configuration, it can be long and tedious to write all the Terraform configuration and then execute it to also have the corresponding Terraform state file. In addition, this execution of the Terraform configuration can have side effects on these resources, which may already be being faced in production.</p>
<p class="mce-root">As a partial answer to this problem, we have seen in the <em>Importing existing resources</em> <span>recipe </span>from <a href="fc591e87-b893-40fa-9021-7827bffcc094.xhtml">Chapter 4</a>, <em>Using the Terraform CLI</em>, that we can use the <kbd>terraform import</kbd> command to import the configuration of already provisioned resources into the Terraform state file. However, this command requires that, on the one hand, the corresponding Terraform configuration is already written, because this command only updates the Terraform state file, and on the other, this command must be executed in order for each resource to be imported.</p>
<p class="mce-root">With this in mind, and having already had this request from many clients, I asked myself the question: Are there tools or scripts that can be used to generate Terraform configuration and its Terraform state file for resources already provisioned in Azure?</p>
<p class="mce-root">In this recipe, I'm going to share the results of my investigation with you using one of the Terraform configuration generation tools, called <strong>Terraformer</strong>, which is hosted in the GitHub repo of Google Cloud Platform, at <a href="https://github.com/GoogleCloudPlatform/terraformer">https://github.com/GoogleCloudPlatform/terraformer</a>.</p>
<h2 id="uuid-006812aa-bedb-474f-874c-a203162ff5ea">Getting ready</h2>
<p>To use <strong>Terraformer</strong>, you must first download the version corresponding to the Terraform provider whose code you wish to generate. In our case, we want to generate the Terraform configuration for an Azure infrastructure, so we run the following Linux script:</p>
<pre><strong><span>curl </span>-LO https://github.com/GoogleCloudPlatform/terraformer/releases/download/<span>$</span><span>(curl </span>-s https://api.github.com/repos/GoogleCloudPlatform/terraformer/releases/latest | <span>grep </span>tag_name | <span>cut </span>-d <span>'"' </span>-f <span>4</span><span>)</span>/terraformer-azure-linux-amd64</strong><br/><strong><span><br/>chmod </span>+x terraformer-azure-linux-amd64</strong><br/><strong><span><br/>sudo </span>mv terraformer-azure-linux-amd64 /usr/local/bin/terraformer</strong></pre>
<p class="mce-root">This script downloads the <strong>Terraformer</strong> ZIP package. Unzip it and then copy it inside the <kbd>/usr/local/bin</kbd> local folder.</p>
<div class="mce-root packt_infobox">For this recipe, we will work on a Linux Terminal, but Terraformer works the same way for Windows, as described in the following documentation: <a href="https://github.com/GoogleCloudPlatform/terraformer#installation">https://github.com/GoogleCloudPlatform/terraformer#installation</a></div>
<p class="mce-root">Once installed, its installation can be checked by executing the <kbd>terrafor</kbd><kbd>mer --help</kbd> command, <span>and th</span>e list of Terraformer comman<span>ds is displayed:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fa822e2d-fc51-4ff0-b7a9-5695eb231507.png" style="width:37.83em;height:16.08em;"/></p>
<p class="mce-root">The purpose of this recipe is to generate the Terraform configuration and the Terraform state file of an Azure infrastructure, which is composed of several Resource Groups, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/42b86fd9-38f5-47aa-a800-208b8d579817.png" style="width:30.50em;height:27.00em;"/></p>
<div class="mce-root packt_infobox">For the purpose of this recipe, we will limit the generation of the Terraform configuration just to these R<span>esource </span>Groups and not to their contents.</div>
<h2 id="uuid-4363eb0e-1bb5-440a-881f-4d272075ed89">How to do it…</h2>
<p>To generate a Terraform configuration using <strong>Terraformer</strong>, perform the following steps:</p>
<ol>
<li>In the folder that will contain the generated code, we create a <kbd>provider.tf</kbd> file with the code of the Terraform provider declared as following:</li>
</ol>
<pre style="padding-left: 60px"><span>provider </span><span>"azurerm" </span>{<br/>  <span>features </span>{}<br/>}</pre>
<ol start="2">
<li>In the command-line terminal, in this folder, we need to download the <kbd>azurerm</kbd> provider by running the <kbd>terraform init</kbd> command.</li>
<li>We then set the four Azure environment variables for Terraform authentication:</li>
</ol>
<pre style="padding-left: 60px">export ARM_SUBSCRIPTION_ID="xxxxxx-xxx-xxxxx-xxxx"<br/>export ARM_CLIENT_ID="xxxxx-xxxx-xxxx-xxxxx"<br/>export ARM_CLIENT_SECRET="xxxx-xxxxxx-xxxxxx-xxxxx"<br/>export ARM_TENANT_ID="xxxxx-xxxxxx-xxxxx-xxxxx"</pre>
<ol start="4">
<li>Then, we generate the Terraform configuration by executing the following <strong>Terraformer</strong> command:</li>
</ol>
<pre style="padding-left: 60px"><strong>terraformer import azure --resources=resource_group  --compact --path-pattern {output}/{provider}/</strong></pre>
<ol start="5">
<li>Once the Terraform configuration and Terraform state file are generated, we will navigate the generated code in the <kbd>generate/azurerm</kbd> folder and add the <kbd>features {}</kbd> <span>expression </span>to the <kbd>provider.tf</kbd> file as follows:</li>
</ol>
<pre style="padding-left: 60px"><span>provider </span><span>"azurerm" </span>{<br/>  <span>version </span>= <span>"~&gt;v2.14.0"<br/></span><span>  </span><span>features </span>{}<br/>}</pre>
<ol start="6">
<li>Finally, in this folder, we will test the configuration <span>generated </span>by running the basic Terraform workflow with the <kbd>terraform init</kbd> and <kbd>terraform plan</kbd> <span>commands:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/223a55d4-3543-49fd-a920-4ee53017076c.png"/></p>
<p>If the output is generated successfully, we should see that the configuration&amp; <span>generated</span> doesn't apply any changes. It corresponds to our infrastructure <span>exactly</span>.</p>
<h2 id="uuid-843dcda9-71b1-48dc-8683-5e6346b7ca96">How it works…</h2>
<p>In <em>step 1</em>, we created a file that contains the provider declaration to download. Then, we downloaded it with the <kbd>terraform init</kbd> command we execute in the second step.</p>
<p class="mce-root"><em>Step 3</em> corresponds to the set of environment variables for Azure authentication that we detailed in the <em>Protecting the Azure credential provider</em> recipe of this chapter. Then, in <em>step 4</em>, we used Terraformer to generate the Terraform configuration and Terraform state files for the provisioned Azure group resources and, in the command line used, we specified the following options:</p>
<ul>
<li class="mce-root"><kbd>resources</kbd>: This is the list of Azure resources for which Terraform configuration must be generated.</li>
<li class="mce-root"><kbd>compact</kbd>: This enables specification of the fact that all the Terraform configurations will be generated in a single file.</li>
<li class="mce-root"><kbd>path-pattern</kbd>: This specifies the pattern of the folder that will contain the generated code.</li>
</ul>
<p class="mce-root">The following screenshot shows the execution of Terraformer:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9ab5f06d-5afa-489d-b72d-85cabb7863ef.png"/></p>
<p class="mce-root">The <kbd>generated/azurerm</kbd> <span>folder </span>is created with the Terraform files, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/675ba3c8-a9c2-4fd7-94c1-c93a6fa1ef60.png" style="width:37.92em;height:9.25em;"/></p>
<p class="mce-root">In this folder, we see the following generated files:</p>
<ul>
<li class="mce-root">The Terraform configuration <kbd>.tf</kbd> files – <kbd>resources.tf</kbd>, <kbd>provider.tf</kbd>, <kbd>outputs.tf</kbd>, and <kbd>variables.tf</kbd></li>
<li class="mce-root">The <kbd>tfstate</kbd> file – <kbd>terraform.tfstate</kbd></li>
</ul>
<p class="mce-root">In <em>step 5</em>, we added the <kbd>features {}</kbd> <span>expression </span>to the provider declaration that was generated in the <kbd>generated/azurerm</kbd> folder.</p>
<p class="mce-root">Finally, in <em>step 6</em>, we verified that the generated code is the infrastructure code by executing a preview of the changes with the execution of the <kbd>terraform plan</kbd> command. During its execution, no changes will be applied. The Terraform configuration is well in line with our infrastructure.</p>
<h2 id="uuid-c4c3e896-2d4d-4098-a619-a1d506da3fae">There's more…</h2>
<p>Terraformer also contains an option that allows a dry run to preview the code that will be generated.</p>
<p>To do this, we will execute the following command that generates a <kbd>plan.json</kbd> file, along with a description of the resources that will be generated:</p>
<pre><strong>terraformer plan azure --resources=resource_group --compact --path-pattern {output}/{provider}/</strong> </pre>
<p>We visualize the content of this created JSON file to check its conformity and then, in order to carry out the generation, we execute the following command:</p>
<pre class="mce-root"><strong>terraformer import plan generated/azurerm/plan.json</strong></pre>
<p class="mce-root">Moreover, before using Terraformer, it is necessary to check that the resources to be generated are well supported. For example, in the case of Azure, the list of resources is available here: <a href="https://github.com/GoogleCloudPlatform/terraformer#use-with-azure">https://github.com/GoogleCloudPlatform/terraformer#use-with-azure</a>.</p>
<p class="mce-root">Finally, among the other Terraform configuration generation tools, there is a very good tool called <strong>az2tf</strong> (<a href="https://github.com/andyt530/py-az2tf">https://github.com/andyt530/py-az2tf</a>) that used to work on the same Terraformer principle, but unfortunately, this tool is no longer maintained. There is also <strong>TerraCognita</strong> (<a href="https://github.com/cycloidio/terracognita/">https://github.com/cycloidio/terracognita/</a>), which still integrates a number of resources for Azure, and <strong>Terraforming</strong> (<a href="https://github.com/dtan4/terraforming">https://github.com/dtan4/terraforming</a>), which is only operational for AWS. The problem with all these tools is that they have to follow the evolution of the Terraform language and also the evolution of different providers, which requires a lot of development and maintenance time.</p>
<h2 id="uuid-d9894bf3-2280-41da-a3c9-00b83579e7e4">See also</h2>
<p>The source code and the documentation for Terraformer is available here: <a href="https://github.com/GoogleCloudPlatform/terraformer">https://github.com/GoogleCloudPlatform/terraformer</a>.</p>


            </article>

            
        </section>
    </body></html>