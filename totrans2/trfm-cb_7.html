<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Deep Diving into Terraform
                </header>
            
            <article>
                
<p class="mce-root">In this book, we started with recipes for Terraform that concern its installation, the writing of the Terraform configuration, as well as the use of the Terraform CLI commands. Then we studied the sharing of the Terraform configuration by using modules. Finally, we focused on the use of Terraform to build an Azure infrastructure.</p>
<p class="mce-root">Now, in this chapter, we will discuss recipes that allow us to go further in our usage of Terraform. We will learn how to use the templates in Terraform via the generation of an inventory for Ansible using Terraform, and will test the Terraform configuration using the <kbd>kitchen-terraform</kbd> plugin. We will discuss how to prevent the destruction of resources, how to implement a zero-downtime deployment technique with Terraform, and how to detect the deletion of resources when Terraform applies changes.</p>
<p class="mce-root">Then we will discuss the use of <strong>Terragrunt</strong> to manage the Terraform configuration dependency and its use as a wrapper for the Terraform CLI. Finally, we will study the integration of the Terraform runtime as well as the management of workspaces in a CI/CD pipeline.</p>
<p>In this chapter, we cover the following recipes:</p>
<ul>
<li>Creating an Ansible inventory with Terraform</li>
<li>Testing the Terraform configuration with kitchen-terraform</li>
<li>Preventing resources from getting destroyed</li>
<li>Zero-downtime deployment with Terraform</li>
<li>Detecting resources <span>deleted</span> by the plan command</li>
<li>Managing Terraform configuration dependencies using Terragrunt</li>
<li>Using Terragrunt as a wrapper for Terraform</li>
<li>Building CI/CD pipelines for Terraform configurations in Azure Pipelines</li>
<li>Working with workspaces in CI/CD</li>
</ul>
<h1 id="uuid-03281a0c-e6ba-4330-8a3f-cc08841f9170">Technical requirements</h1>
<p>For the recipes in this chapter, we will need the following prerequisites:</p>
<ul>
<li>
<p><kbd>kitchen-terraform</kbd>, which is available at <a href="https://github.com/newcontext-oss/kitchen-terraform">https://github.com/newcontext-oss/kitchen-terraform</a>, and also Ruby, available to download from <a href="https://www.ruby-lang.org/en/">https://www.ruby-lang.org/en/</a>.<a href="https://www.ruby-lang.org/en/"/></p>
</li>
<li>
<p>Terragrunt, whose documentation is available at <a href="https://terragrunt.gruntwork.io/">https://terragrunt.gruntwork.io/</a>.</p>
</li>
<li>
<p>In addition, we will also use the <strong>jq</strong> utility for parsing JSON. You can download it from <a href="https://stedolan.github.io/jq/">https://stedolan.github.io/jq/</a>.</p>
</li>
<li>
<p>Finally, when working with CI/CD, we will use Azure Pipelines as our CI/CD platform. Azure Pipelines is a service of Azure DevOps. You can create a free account via <a href="https://azure.microsoft.com/en-us/services/devops/">https://azure.microsoft.com/en-us/services/devops/</a>.</p>
</li>
</ul>
<p>The source code for this chapter is available on the book's GitHub repository, at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07</a>.<a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07"/></p>
<p>Check out the following video to see the Code in Action:</p>
<p>"YouTube Bitly link"</p>
<h1 id="uuid-505cff07-ca07-42fb-988e-9734e8100584">Creating an Ansible inventory with Terraform</h1>
<p>Terraform is a very good <strong>Infrastructure-as-Code</strong> (<strong>IaC</strong>) tool that allows us to build complex infrastructure with code.</p>
<p>As we studied in <a href="d054157b-d534-47c9-8079-3af13107c4ef.xhtml">Chapter 6</a>, <em>Provisioning Azure Infrastructure with Terraform</em>, concerning the construction of virtual machines, on all cloud providers, the common objective of Terraform is to build a VM without configuring it, which includes the installation of its middleware and its administration.</p>
<p class="mce-root">Among the <strong>Configuration-as-Code</strong> (<strong>CaC</strong>) tools that allow us to use Terraform to configure a VM after its creation, there is <strong>Ansible</strong> (<a href="https://www.ansible.com/">https://www.ansible.com/</a>), which is very popular in the open source world (much like Chef and Puppet).</p>
<p class="mce-root">One of the advantages of Ansible is that it's agentless, which means you don't need to install an agent on the VMs you want to configure. Thus, to know which VMs to configure, Ansible uses a file called <kbd>inventory</kbd>, which contains the list of VMs that need configuring.</p>
<p class="mce-root">In this recipe, we will learn how to generate this <kbd>inventory</kbd> file using Terraform's templating features.</p>
<h2 id="uuid-e68c2793-03d2-46f8-a089-2b2301ed5e76">Getting ready</h2>
<p>The purpose of this recipe is not to discuss the installation and use of Ansible but just the automatic creation of its <kbd>inventory</kbd> file.</p>
<div class="packt_infobox">To learn more about Ansible, I invite you to read <em>Chapter 3, Using Ansible for Configuring IaaS Infrastructure</em>, from my book entitled <em>Learning DevOps</em>, also available from Packt at <a href="https://www.packtpub.com/eu/cloud-networking/learning-devops">https://www.packtpub.com/eu/cloud-networking/learning-devops</a>.</div>
<p class="mce-root">The starting point of our recipe is to use Terraform to create VMs in Azure whose private IP addresses are not known before they are created. In this Terraform configuration of VMs, we use the configuration we have already studied in the <em>Provisioning and configuring an Azure VM with Terraform</em> <span>recipe </span>of <a href="d054157b-d534-47c9-8079-3af13107c4ef.xhtml">Chapter 6</a>, <em>Provisioning Azure Infrastructure with Terraform</em>. So, to keep it simple, we use the Terraform modules published in the public registry with the following Terraform configuration:</p>
<ol>
<li>Instantiate a <kbd>vmhosts</kbd> variable that specifies the <span>hostname</span> of the VM we want to create:</li>
</ol>
<pre style="padding-left: 60px"><span>variable </span><span>"vmhosts" </span>{<br/>  <span>type    </span>= list(string)<br/>  <span>default </span>= [<span>"vmwebdemo1"</span><span>, </span><span>"vmwebdemo2"</span>]<br/>}</pre>
<ol start="2">
<li>Then, use the <kbd>network</kbd> module and compute from the public registry to create the VM inside the network:</li>
</ol>
<pre style="padding-left: 60px"><span>module </span><span>"network" </span>{<br/>  <span>source </span>= <span>"Azure/network/azurerm"<br/></span><span>  </span><span>resource_group_name </span>= <span>"rg-demoinventory"<br/></span><span>  </span><span>subnet_prefixes </span>= [<span>"10.0.2.0/24"</span>]<br/>  <span>subnet_names </span>= [<span>"subnet1"</span>]<br/>}<br/><br/><span>module </span><span>"linuxservers" </span>{<br/>  <span>source </span>= <span>"Azure/compute/azurerm"<br/></span><span>  </span><span>resource_group_name </span>= <span>"rg-demoinventory"<br/></span><span>  </span><span>vm_os_simple </span>= <span>"UbuntuServer"<br/></span><span>  </span><span>nb_instances </span>= <span>2<br/></span><span>  </span><span>nb_public_ip </span>= <span>2<br/></span><span>  </span><span>vm_hostname </span>= <span>"vmwebdemo"<br/></span><span>  </span><span>public_ip_dns </span>= var.vmhosts<br/><span>  </span><span>vnet_subnet_id </span>= module.<span>network</span>.<span>vnet_subnets</span>[<span>0</span>]<br/>}</pre>
<p class="mce-root">In the preceding Terraform configuration, we create a Virtual Network and a Subnet and two Linux VMs that will have private IP addresses.</p>
<p class="mce-root">The goal of this recipe is to generate an <kbd>inventory</kbd> text file, in the same Terraform configuration, which will contain the list of hosts (along with their IP addresses) that have been created by Terraform. This inventory file will be in the following form:</p>
<pre><span>[vm-web]</span><br/><span>&lt;host1&gt; </span>ansible_host=1&lt;ip 1&gt;<br/><span>&lt;host2&gt; </span>ansible_host=&lt;ip 2&gt;</pre>
<p class="mce-root">The complete source code for this recipe is available at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/ansible-inventory">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/ansible-inventory</a>.</p>
<h2 id="uuid-faf1cc09-2957-46db-ba7c-396445bf1a7f">How to do it…</h2>
<p>To generate the Ansible inventory with Terraform, perform the following steps:</p>
<ol>
<li>Inside the folder containing the Terraform configuration, we create a new file called <kbd>template-inventory.tpl</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 60px">[vm-web]<br/>%{ for host, dns in vm_dnshost ~}<br/>${host} ansible_host=${dns}<br/>%{ endfor ~}</pre>
<ol start="2">
<li>Then, in the <kbd>main.tf</kbd> file of the Terraform configuration that creates a VM, we add the following code to generate the <kbd>inventory</kbd> file:</li>
</ol>
<pre style="padding-left: 60px"><span>resource </span><span>"local_file" </span><span>"inventory" </span>{<br/>  <span>filename </span>= <span>"inventory"<br/></span><span>  </span><span>content </span>= templatefile(<span>"template-inventory.tpl"</span><span>,<br/></span><span>    </span>{<span><br/>         vm_dnshost = zipmap(var.vmhosts,module.linuxservers.network_interface_private_ip)</span><span><br/></span><span>    </span>})<br/>}</pre>
<ol start="3">
<li>Finally, to create the VMs and generate the <kbd>inventory</kbd> file, we run the basic Terraform <kbd>init</kbd><span>, </span><kbd>plan</kbd><span>, and </span><kbd>apply</kbd> workflow commands<span>.</span></li>
</ol>
<h2 id="uuid-2e12ba9f-ee3a-4fa8-be32-db260699d93f">How it works…</h2>
<p>We first create a <kbd>template-inventory.tpl</kbd> file, which uses Terraform's template format. In this file, we use a <kbd>for</kbd> loop with the syntax <kbd>%{ for host, ip in vm_dnshost ~}</kbd>, which allows us to loop the elements of the <span><kbd>vm_dnshost</kbd> </span>variable. For each VM in this loop, we use the following syntax:</p>
<pre>${host} ansible_host=${ip}</pre>
<p>We end the loop with the <kbd>%{ endfor ~}</kbd> syntax.</p>
<div class="mce-root packt_infobox">For more details on this templating format, read the documentation at <a href="https://www.terraform.io/docs/configuration/expressions.html#string-templates">https://www.terraform.io/docs/configuration/expressions.html#string-templates</a>.</div>
<p class="mce-root">Then in <em>step 2</em>, to the Terraform configuration we add a <kbd>local_file</kbd> resource (which we have already studied in the <em>Manipulating local files with Terraform</em> <span>recipe </span>of <a href="3099c9ac-8c38-4e7d-8146-411fac26a2b7.xhtml">Chapter 2</a>, <em>Writing Terraform Configuration</em>) in which we fill in the following properties:</p>
<ul>
<li class="mce-root"><kbd>filename</kbd>: This contains <kbd>inventory</kbd> <span>as its value, </span>which is the name of the file that will be generated.</li>
</ul>
<div class="mce-root packt_infobox">In this recipe, the file will be generated inside the directory that <span>currently </span>contains this Terraform configuration. You are free to enter another folder for <span>generation and storage</span>.</div>
<ul>
<li class="mce-root"><kbd>content</kbd>: This contains the elements that will fill this file. Here, we use the <kbd>templatefile</kbd> <span>function, passing the following as </span>parameters:<br/>
<ul>
<li>The name of the template file, <kbd>template-inventory.tpl</kbd>, that we created in <em>step 1</em></li>
<li>The <kbd>vm_dnshost</kbd><span> variable that will fill the content of the template file. We use the built-in Terraform</span> <kbd>zipmap</kbd> <span>function</span><span> </span><span>that allows us to build a map from two lists, one being the keys list and the other the values list.</span></li>
</ul>
</li>
</ul>
<div class="packt_infobox">Documentation on the <kbd>zipmap</kbd> function is available at <a href="https://www.terraform.io/docs/configuration/functions/zipmap.html">https://www.terraform.io/docs/configuration/functions/zipmap.html</a>.<a href="https://www.terraform.io/docs/configuration/functions/zipmap.html"/></div>
<ul>
<li class="mce-root"><kbd>depend_on</kbd>: This parameter is part of the Terraform language and indicates a dependency between two or more resources (the documentation on Terraform dependencies can be found at <a href="https://learn.hashicorp.com/terraform/getting-started/dependencies">https://learn.hashicorp.com/terraform/getting-started/dependencies</a>). Here, in our case, we indicate a dependency between this <kbd>local_file</kbd> resource and the VM module so that Terraform only creates the <kbd>inventory</kbd> file after creating the VM.</li>
</ul>
<p class="mce-root">Finally, in the last step, we execute the commands of the Terraform workflow, and at the end of its execution we can see that the <kbd>inventory</kbd> file has indeed been generated with the following content:</p>
<pre>[vm-web]<br/>vmwebdemo1 ansible_host=10.0.2.5<br/>vmwebdemo2 ansible_host=10.0.2.4</pre>
<p class="mce-root">Now, all new VMs added to this Terraform configuration will be added dynamically to this Ansible inventory.</p>
<h2 id="uuid-6d6e2fb6-95c9-46bd-9ce3-d620d6453058">There’s more…</h2>
<p class="mce-root">The primary objective of this recipe is to show the use of templates with Terraform that we applied on an Ansible inventory. There can be several other use cases for these templates, such as using the <kbd>cloud-init</kbd> file to configure a VM, which is explained in the article at <a href="https://grantorchard.com/dynamic-cloudinit-content-with-terraform-file-templates/">https://grantorchard.com/dynamic-cloudinit-content-with-terraform-file-templates/</a>.</p>
<h2 id="uuid-82bf1fe7-42cc-449e-986b-899ab8c222f8">See also</h2>
<ul>
<li>
<p>The documentation on the Terraform <kbd>templatefile</kbd> function is available at <a href="https://www.terraform.io/docs/configuration/functions/templatefile.html">https://www.terraform.io/docs/configuration/functions/templatefile.html</a>.</p>
</li>
<li class="mce-root">
<p>The documentation on the <kbd>local_file</kbd> resource of the <kbd>local</kbd> provider is available at <a href="https://registry.terraform.io/providers/hashicorp/local/latest/docs/resources/file">https://registry.terraform.io/providers/hashicorp/local/latest/docs/resources/file</a>.<a href="https://registry.terraform.io/providers/hashicorp/local/latest/docs/resources/file"/></p>
</li>
</ul>
<ul>
<li class="mce-root">
<p>A list of books on Ansible from Packt is available at <a href="https://subscription.packtpub.com/search?query=ansible">https://subscription.packtpub.com/search?query=ansible</a>.</p>
</li>
<li>
<p>Here is a list of web articles that deal with the same subject of Ansible inventories generated by Terraform by proposing different solutions:</p>
<ul>
<li><a href="https://hooks.technology/2020/02/using-terraform-and-ansible-together/">https://hooks.technology/2020/02/using-terraform-and-ansible-together/</a></li>
<li><a href="https://www.linkbynet.com/produce-an-ansible-inventory-with-terraform">https://www.linkbynet.com/produce-an-ansible-inventory-with-terraform</a></li>
<li><a href="https://gist.github.com/hectorcanto/71f732dc02541e265888e924047d47ed">https://gist.github.com/hectorcanto/71f732dc02541e265888e924047d47ed</a></li>
<li><a href="https://stackoverflow.com/questions/45489534/best-way-currently-to-create-an-ansible-inventory-from-terraform">https://stackoverflow.com/questions/45489534/best-way-currently-to-create-an-ansible-inventory-from-terraform</a></li>
</ul>
</li>
</ul>
<h1 id="uuid-50271763-2c01-49a7-b2c5-684bccb265f4">Testing the Terraform configuration using kitchen-terraform</h1>
<p>We have already studied, in the <em>Testing Terraform module code with Terratest</em> <span>recipe </span>of <a href="ddb13a41-5cdd-4931-b38f-d185d3a10c1e.xhtml">Chapter 5</a>, <em>Sharing Terraform Configuration with Modules</em>, how to test Terraform modules using the Terratest framework.</p>
<p class="mce-root">In this recipe, we will test a Terraform configuration using another tool: <strong>KitchenCI</strong> and its <kbd>kitchen-terraform</kbd> plugin.</p>
<h2 id="uuid-04afa4e1-ce96-489b-aefe-41b017513d19">Getting ready</h2>
<p><kbd>kitchen-terraform</kbd> is written in Ruby and is a plugin for <strong>KitchenCI</strong> (more simply called <strong>Kitchen</strong>), which is an IaC testing tool. In order to apply this recipe properly, you must first understand the principles and workflow of Kitchen, documented at <a href="https://kitchen.ci/index.html">https://kitchen.ci/index.html</a>.</p>
<p class="mce-root">As Kitchen is written in <strong>Ruby</strong>, you will need to install Ruby (available at <a href="https://www.ruby-lang.org/en/">https://www.ruby-lang.org/en/</a> – make sure to use version 2.4 at a <span>minimum</span>) on your computer by following the installation documentation available at <a href="https://www.ruby-lang.org/en/documentation/installation/">https://www.ruby-lang.org/en/documentation/installation/</a>.</p>
<p class="mce-root">In addition to Ruby, we need to install <strong>Bundle</strong>, available from <a href="https://bundler.io/">https://bundler.io/</a>. This is the package dependency for Ruby packages.</p>
<p class="mce-root">We can install <kbd><span>kitchen-terraform</span></kbd> firstly by using RubyGems (which is the Ruby manager package) by running the following command:</p>
<pre class="mce-root"><strong>gem install kitchen-terraform</strong></pre>
<p class="mce-root">Or, secondly, we can use the method recommended by Kitchen using gems and bundles by following this procedure:</p>
<ol>
<li>In the folder that contains the Terraform configuration to be tested, we create a Gemfile that contains the list of packages (here, we specify the <kbd>kitchen-terraform</kbd> package) to install, containing the following:</li>
</ol>
<pre style="padding-left: 60px">source "https://rubygems.org/" do<br/>  gem "kitchen-terraform", "~&gt; 5.4"<br/>end</pre>
<ol start="2">
<li>In a terminal, execute the following command to install the packages referenced in the Gemfile:</li>
</ol>
<pre style="padding-left: 60px"><strong>bundle install</strong></pre>
<p style="padding-left: 60px" class="mce-root">The execution of the preceding command installs all the packages necessary to run <kbd>kitchen-terraform</kbd>.</p>
<p class="mce-root">Finally, concerning the writing of the tests, we will use <strong>Inspec</strong>, which is a test framework based on Rspec. Inspec allows you to test local systems or even infrastructures in the cloud. For more information about Inspec, I suggest you read its documentation at <a href="https://www.inspec.io/">https://www.inspec.io/</a>.</p>
<p class="mce-root">To illustrate the use of <kbd>kitchen-terraform</kbd> in a simple way, we will test the proper functioning of the Terraform configuration in this recipe that generates an Ansible inventory file, which we studied in the previous recipe. The purpose of the tests we will write is to test that the <kbd>inventory</kbd> file has indeed been generated and that it is not empty.</p>
<div class="mce-root packt_infobox">In this recipe, the goal is not to test the creation of the network and the VMs, but only the <kbd>inventory</kbd> file.</div>
<p class="mce-root">Finally, as with all integration testing, it is preferable to have an isolated system or environment to run the tests.</p>
<p class="mce-root">The source code for this recipe is available at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/kitchen">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/kitchen</a>.</p>
<h2 id="uuid-0d3a8cd4-fde7-469e-b129-00772b57cdd4">How to do it…</h2>
<p>To test the Terraform configuration execution with <kbd>kitchen-terraform</kbd>, perform the following steps:</p>
<ol>
<li>Inside the folder containing the Terraform configuration, create the Inspec <kbd>test</kbd> folder with the following tree:</li>
</ol>
<pre style="padding-left: 60px">test &gt; integration &gt; kt_suite</pre>
<ol start="2">
<li>In this <kbd>kt_suite</kbd> folder, add the Inspec profile file named <kbd>inspec.yml</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 60px">---<br/><span>name</span>: default</pre>
<ol start="3">
<li>In the <kbd>kt_suite</kbd> folder, create a new folder called <kbd>controls</kbd> that will contain the Inspec tests. Then, inside the <kbd>controls</kbd> folder, add a new <kbd>inventory.rb</kbd> <span>file </span>with the following content:</li>
</ol>
<pre style="padding-left: 60px">control <span>"check_inventory_file" </span><span>do<br/></span>  describe file(<span>'./inventory'</span>) <span>do<br/></span>    it { should exist }<br/>    its(<span>'size'</span>) { should be <span>&gt; </span><span>0 </span>}<br/>  <span>end<br/></span><span>end</span></pre>
<ol start="4">
<li>At the root of the Terraform configuration folder, we create a Kitchen configuration file called <kbd>kitchen.yml</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 60px">---<br/><span>driver</span>:<br/>  <span>name</span>: terraform<br/><span><br/>provisioner</span>:<br/>  <span>name</span>: terraform<br/><br/><span>verifier</span>:<br/>  <span>name</span>: terraform<br/>  <span>systems</span>:<br/>    - <span>name</span>: basic<br/>      <span>backend</span>: local<br/>      <span>controls</span>:<br/>        - check_inventory_file<br/><span>platforms</span>:<br/>  - <span>name</span>: terraform<br/><span>suites</span>:<br/>  - <span>name</span>: kt_suite</pre>
<ol start="5">
<li>In a terminal (running in the root of the Terraform configuration folder), run the following <kbd>kitchen</kbd> command:</li>
</ol>
<pre style="padding-left: 60px"><strong>kitchen test</strong></pre>
<h2 id="uuid-4bbcf23e-3f61-4ab5-95ec-f3abf5fb1f73">How it works…</h2>
<p>The execution of this recipe takes place over three phases:</p>
<ol>
<li>Writing the inspection tests</li>
<li>Writing the Kitchen configuration</li>
<li>Kitchen execution</li>
</ol>
<p class="mce-root">From <em>steps 1 to 3</em>, we wrote the inspection tests with the following steps:</p>
<ol>
<li class="mce-root">First, we created the folder tree that will contain the profile and the Inspec tests. In the <kbd>kt_suite</kbd> folder, we created the <kbd>inspec.yml</kbd> file, which is the Inspec profile. In our case, this just contains the <kbd>name</kbd> property with the <kbd>default</kbd> value.</li>
</ol>
<div class="mce-root packt_infobox">To learn more about Inspec profiles, refer to the documentation at <a href="https://www.inspec.io/docs/reference/profiles/">https://www.inspec.io/docs/reference/profiles/</a>.</div>
<ol start="2">
<li class="mce-root">Then, in the <kbd>controls &gt; inventory.rb</kbd> <span>file, </span>we wrote the Inspec tests (in Rspec format) by creating a <kbd>control "check_inventory_file" do</kbd> <span>control </span>that will contain the tests. In these tests, we use the resource <kbd>file</kbd> <span>Inspec </span>(see the documentation at <a href="https://www.inspec.io/docs/reference/resources/file/">https://www.inspec.io/docs/reference/resources/file/</a>), which allows us to run tests on files. Here, the property of this resource is <kbd>inventory</kbd>, which is the name of the inventory file generated by Terraform. In this control, we have written two tests:
<ul>
<li class="mce-root"><kbd>it { should exist }</kbd>: This inventory file must exist on disk.</li>
<li class="mce-root"><kbd>its('size') { should be &gt; 0 }</kbd>: The size of this file must be <kbd>&gt; 0</kbd>, so it must contain some content.</li>
</ul>
</li>
</ol>
<p style="padding-left: 60px">Once the writing of the tests is finished, in <em>step 4</em>, we create the <kbd>kitchen.yml</kbd> <span>file, </span>which contains the Kitchen configuration consisting of three parts, the first one being the driver:</p>
<pre style="padding-left: 60px"><span>driver</span>:<br/>  <span>name</span>: terraform</pre>
<p style="padding-left: 60px" class="mce-root">The driver is the platform that is used for testing. Kitchen supports a multitude of virtual and cloud platforms. In our case, we use the <kbd>terraform</kbd> driver provided by the <kbd>kitchen-terraform</kbd> plugin.</p>
<div class="mce-root packt_infobox">Documentation on the drivers supported by Kitchen is available at <a href="https://kitchen.ci/docs/drivers/">https://kitchen.ci/docs/drivers/</a>.</div>
<p style="padding-left: 60px" class="mce-root">The second part of the <kbd>kitchen.yml</kbd> file is the <kbd>provisioner</kbd>:</p>
<pre style="padding-left: 60px"><span>provisioner</span>:<br/>  <span>name</span>: terraform</pre>
<p style="padding-left: 60px" class="mce-root">The <kbd>provisioner</kbd> is the tool that will configure the VMs. It can use scripts, Chef, Ansible, or <strong>Desired State Configuration</strong> (<strong>DSC</strong>). In our case, since in our test we don't provision VMs, we use the <kbd>terraform</kbd> provisioner provided by <kbd>kitchen-terraform</kbd>.</p>
<div class="mce-root packt_infobox">Documentation on Kitchen-supported provisioners is available at <a href="https://kitchen.ci/docs/provisioners/">https://kitchen.ci/docs/provisioners/</a>.</div>
<p style="padding-left: 60px" class="mce-root">The third part is the <kbd>verifier</kbd>:</p>
<pre style="padding-left: 60px"><span>verifier</span>:<br/>  <span>name</span>: terraform<br/>  <span>systems</span>:<br/>    - <span>name</span>: basic<br/>      <span>backend</span>: local<br/>      <span>controls</span>:<br/>        - check_inventory_file<br/><span>platforms</span>:<br/>  - <span>name</span>: terraform<br/><span>suites</span>:<br/>  - <span>name</span>: kt_suite</pre>
<p style="padding-left: 60px" class="mce-root">The <kbd>verifier</kbd> is the system that will test the components applied by the provisioner. We can use Inspec, Chef, shell, or pester as our testing framework. In our case, we configure the verifier on the control and the Inspec test suite we wrote in <em>step 2</em>. In addition, the <kbd>control</kbd> property is optional – it allows us to filter the Inspec controls to be executed during the tests.</p>
<div class="mce-root packt_infobox">Documentation on Kitchen-supported verifiers is available at <a href="https://kitchen.ci/docs/verifiers/">https://kitchen.ci/docs/verifiers/</a>.</div>
<ol start="3">
<li class="mce-root">Finally, in the last step, we perform the tests by executing the <kbd>kitchen test</kbd> <span>command, </span>which, based on the YAML kitchen configuration, will perform the following actions:
<ol>
<li class="mce-root">Execute the <kbd>init</kbd> and <kbd>apply</kbd> commands of the Terraform workflow.</li>
<li class="mce-root">Run <span>the </span>Inspec tests.</li>
<li>Execute the <kbd>destroy</kbd> Terraform command to delete all resources provisioned for the test.</li>
</ol>
</li>
</ol>
<p style="padding-left: 60px" class="mce-root">The result of this execution is shown in the following three screenshots.</p>
<div style="padding-left: 60px" class="mce-root packt_infobox">In reality, this execution takes place in the same console and the same workflow. I've split this into three screenshots for better visibility because you can't see everything with just one screen.</div>
<p>The following screenshot shows the execution of the <kbd>init</kbd> and <kbd>apply</kbd> commands:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cdcd7e5b-c70d-46ee-80bf-a4694c608da3.png"/></p>
<p>The following screenshot shows the execution of Inspec:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4cbf94f6-4c64-42de-b363-05a6060bbf78.png" style="width:65.67em;height:27.67em;"/></p>
<p>This last screenshot shows the <kbd>destroy</kbd> command:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/20ced5e1-e92d-4d2f-8a8d-689c7b42bcd1.png"/></p>
<p class="mce-root">These three screens show the execution of Terraform, then the successful execution of the Inspec tests, which indicates that my <kbd>inventory</kbd> file was indeed generated by Terraform, and finally the destruction of the resources that had been allocated for the tests.</p>
<h2 id="uuid-d3c789b7-2642-43d2-b32e-c8f1690ee731">There’s more…</h2>
<p>To go deeper into the writing of the tests, we could have added the Inspec <kbd>its('content')</kbd> <span>expression, </span>which allows us to test the content of the file, as explained in the Inspec documentation at <a href="https://www.inspec.io/docs/reference/resources/file/">https://www.inspec.io/docs/reference/resources/file/</a>.</p>
<p class="mce-root">Concerning the execution of the tests in this recipe, we have to execute the <kbd>kitchen test</kbd><span> command.</span> In the case of integration tests in which, after executing the tests, we don't want to destroy the resources that have been built with Terraform, we can execute the <kbd>kitchen verify</kbd> <span>command.</span></p>
<p class="mce-root">Finally, as mentioned in the introduction, in this recipe we used <kbd>kitchen-terraform</kbd> to test a Terraform configuration, but we can also use it to test Terraform modules.</p>
<h2 id="uuid-f5def10f-4698-47be-b16b-38f3b15d3da7">See also</h2>
<ul>
<li>KitchenCI documentation is available at <a href="https://kitchen.ci/">https://kitchen.ci/</a>.</li>
<li class="mce-root">The source code of the <kbd>kitchen-terraform</kbd> plugin on GitHub is available at <a href="https://github.com/newcontext-oss/kitchen-terraform">https://github.com/newcontext-oss/kitchen-terraform</a>.<a href="https://github.com/newcontext-oss/kitchen-terraform"/></li>
<li class="mce-root">You can find tutorials on <kbd>kitchen-terraform</kbd> at <a href="https://newcontext-oss.github.io/kitchen-terraform/tutorials/">https://newcontext-oss.github.io/kitchen-terraform/tutorials/</a>.</li>
<li><span>For more information about the </span><kbd>kitchen test</kbd><span> command, see the documentation at </span><a href="https://kitchen.ci/docs/getting-started/running-test/">https://kitchen.ci/docs/getting-started/running-test/</a><span>.</span></li>
</ul>
<h1 id="uuid-94c6b50d-667d-4aa9-997e-5fa1644c1e68">Preventing resources from getting destroyed</h1>
<p>The use of IaC requires attention in some cases. Indeed, when the IaC is integrated into a CI/CD pipeline, resources containing important<span> </span>data can be automatically deleted. This can be done either by changing a property of a Terraform resource, which requires the deletion and recreation of this resource, or by executing the <kbd>terraform destroy</kbd> command. Fortunately, Terraform includes a configuration in its language that prevents the destruction of sensitive resources.</p>
<p class="mce-root">In this recipe, we will see how to prevent the destruction of resources that are managed in a Terraform configuration.</p>
<h2 id="uuid-da8c8ce8-9729-4d7a-b28b-40492bd25db1">Getting ready</h2>
<p>For this recipe, we will use a Terraform configuration, the code for which is available at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/sample-app">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/sample-app</a>. The purpose of this configuration is to manage the following resources in Azure:</p>
<ul>
<li>A Resource Group</li>
<li>A Service Plan</li>
</ul>
<ul>
<li>An Azure App Service (web app) instance</li>
<li>An <span>Azure </span>Application Insights instance</li>
</ul>
<p class="mce-root">The problem that we often encounter in company projects concerns the resources that contain data. In our example, this is the Application Insights instance containing the logs and metrics of our application, which is in the web app and should not be deleted automatically.</p>
<p class="mce-root">Let's take as a scenario a company that has decided to change the nomenclature of their resources, and we need to update the Terraform configuration with the new nomenclature. When running Terraform, we would get the following result from the <kbd>terraform plan</kbd> command:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/44ffd996-a55c-4459-9d13-804cb8d8dc2c.png"/></p>
<p class="mce-root">As you can see, the name change requires the deletion of the A<span>pplication </span>Insights instance that contains important log metrics.</p>
<p class="mce-root">The purpose of this recipe is to change the Terraform configuration so that the Application Insights resource is never deleted.</p>
<p class="mce-root">The source code of this recipe is available at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/preventdestroy">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/preventdestroy</a>.</p>
<h2 id="uuid-a1fb17dd-77cc-4f68-b380-39a5cc326b1d">How to do it…</h2>
<p>To prevent the deletion of a resource by Terraform, perform the following steps:</p>
<ol>
<li>Inside the Terraform configuration of the Application Insights resource, add the following <kbd>lifecycle</kbd> block:</li>
</ol>
<pre style="padding-left: 60px"><span>resource </span><span>"azurerm_application_insights" </span><span>"appinsight-app" </span>{<br/>...<br/>  <span>lifecycle </span>{<br/>    <span>prevent_destroy </span>= <span>true<br/></span><span>  </span>}<br/>}</pre>
<ol start="2">
<li>
<p>In <kbd>variables.tf</kbd>, change the default value of the <kbd>app_name</kbd> variable with another name for the Application Insights such as <kbd>MyApp2-DEV1</kbd>.</p>
</li>
<li>
<p>Execute the Terraform CLI workflow and the result is shown in the following screenshot:</p>
</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/69601017-f88c-4cd7-a70c-bff317398c77.png"/></p>
<h2 id="uuid-364b87d6-9421-45d3-8744-62e24b0f47cb">How it works…</h2>
<p>In this recipe, we have added the Terraform <kbd>lifecycle</kbd> block, which contains the properties that allow interaction with resource management. Here, in our case, we used the <kbd>prevent_destroy</kbd> property, which, as its name indicates, prevents the destruction of the specified resource.</p>
<h2 id="uuid-f329f176-dcca-42d2-bcd1-5333016a19c1">There’s more…</h2>
<p>As we have discussed, the <kbd>prevent_destroy</kbd> property allows you to prohibit the deletion of resources.</p>
<div class="mce-root packt_infobox">Note that in our example with Azure, this property does not prohibit the deletion of resources via the Azure portal or the Azure CLI.</div>
<p class="mce-root">However, it should be noted that if a resource in the Terraform configuration contains this property, and this property must be deleted when executing the <kbd>terraform apply</kbd> command, then this <kbd>prevent_destroy</kbd> property prevents the application from making changes to all the resources described in the Terraform configuration. This blocks us from applying changes to resources. This is one of the reasons why I personally break up the Terraform configuration, putting the configuration of the sensitive resources that mustn't be destroyed in one folder (and thus a separate Terraform state file), and the other resources in another folder. This way, we can apply changes to the resources without being blocked by our resource destruction prevention settings.</p>
<div class="mce-root packt_tip">Here, I'm writing about separating the Terraform configuration and the state files, but it's also necessary to separate the workflows in the CI/CD pipeline, with one pipeline that applies the changes and another that destroys the resources.</div>
<p class="mce-root">In addition, <span>mostly </span>to prevent human mistakes, it isn't possible to add variables to the values of the properties of the <kbd>lifecycle</kbd> block by wanting to make the value of this property dynamic. You might try using a <kbd>bool</kbd> type variable, such as in the following code:</p>
<pre class="mce-root">lifecycle { <br/> prevent_destroy = var.prevent_destroy_ai <br/>}</pre>
<p class="mce-root">However, when executing the <kbd>terraform apply</kbd> <span>command, </span>the following error occurs:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e2f4f17f-c3bf-4865-a566-de5f5165c24d.png" style="width:41.92em;height:16.42em;"/></p>
<p class="mce-root">These errors indicate that a variable is not allowed in the <kbd>lifecycle</kbd> <span>block, </span>so you have to keep true/false values in the code.</p>
<h2 id="uuid-717a42d8-9c11-4dd9-939d-52d273de2cbe">See also</h2>
<ul>
<li>Documentation on the <kbd>prevent_destroy</kbd> property is available at <a href="https://www.terraform.io/docs/configuration/resources.html#prevent_destroy">https://www.terraform.io/docs/configuration/resources.html#prevent_destroy</a>.</li>
<li class="mce-root">An interesting article on the HashiCorp blog about drift management can be found at <a href="https://www.hashicorp.com/blog/detecting-and-managing-drift-with-terraform/">https://www.hashicorp.com/blog/detecting-and-managing-drift-with-terraform/</a>.</li>
<li>Read this article from HashiCorp about feature toggles, blue-green deployments, and canary testing using Terraform, available at <a href="https://www.hashicorp.com/blog/terraform-feature-toggles-blue-green-deployments-canary-test/">https://www.hashicorp.com/blog/terraform-feature-toggles-blue-green-deployments-canary-test/</a>.</li>
</ul>
<h1 id="uuid-f74c6458-5fd7-42da-bc1f-26780a57d4ca">Zero-downtime deployment with Terraform</h1>
<p>As discussed in the previous recipe, changing certain properties on resources described in the Terraform configuration can lead to their destruction and subsequent recreation. Resources are destroyed and recreated in the order in which they are run in Terraform. In other words, the first resource to be run will first be destroyed and then it will be recreated, and in a production context, during this time period, it will lead to downtime, that is, a service interruption. This downtime can be greater or smaller depending on the type of resources that will have to be destroyed and then recreated.</p>
<div class="packt_infobox">For example, in Azure, a VM takes much longer to destroy and rebuild than a web app or a <strong>Network Security Group</strong> (<strong>NSG</strong>) rule.</div>
<p class="mce-root">In Terraform, there is a mechanism that allows for zero downtime and therefore avoids this service interruption when deleting a resource.</p>
<p class="mce-root">In this recipe, we will study how to implement zero downtime on a resource described in a Terraform configuration.</p>
<h2 id="uuid-ac0422dc-da65-4620-8f8a-5360dd66441d">Getting ready</h2>
<p>For this recipe, we will use the Terraform configuration available from <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/sample-app">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/sample-app</a>. The purpose of this configuration is to manage the following resources in Azure:</p>
<ul>
<li>A Resource Group</li>
<li>A Service Plan</li>
<li>An App Service (web app) instance</li>
<li>An <span>Application </span>Insights <span>instance</span></li>
</ul>
<p>In addition, this Terraform configuration has already been applied to the Azure cloud.</p>
<p class="mce-root">For our use case, let's assume that a company has decided to change the resource name and that we need to update the Terraform configuration with the new name. When running Terraform, the following result would be obtained with the <kbd>terraform plan</kbd> command:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7ca19d92-8c6f-447f-8a22-2e0f0b57b010.png"/></p>
<p class="mce-root">As you can see, the name change requires a deletion of the web app that hosts our web application. This deletion will result in the application not being accessible for a small amount of time while it is recreated. The purpose of this recipe is to modify the Terraform configuration so that even when the App Service resource is deleted, the web application will still be available.</p>
<p class="mce-root">The source code of this recipe is available at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/zerodowntime">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/zerodowntime</a>.<a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/zerodowntime"/></p>
<h2 id="uuid-89700ab6-d547-4c15-acbb-289ea25f9768">How to do it…</h2>
<p>To provide zero downtime in a Terraform configuration, perform the following steps:</p>
<ol>
<li>In the Terraform configuration, inside the <kbd>azurerm_app_service</kbd> resource, add the <kbd>lifecycle</kbd> block as shown in the following code:</li>
</ol>
<pre style="padding-left: 60px"><span>resource </span><span>"azurerm_app_service" </span><span>"app" </span>{<br/>  <span>name                </span>= <span>"${var.</span><span>app_name</span><span>}-${var.</span><span>environement</span><span>}"<br/></span><span>...<br/></span><span>  </span><span>lifecycle </span>{<br/>    <span>create_before_destroy </span>= <span>true<br/></span><span>  </span>}<br/>}</pre>
<ol start="2">
<li>Change the <kbd>name</kbd> property of the App Service to apply the new nomenclature.</li>
<li>Execute the Terraform CLI workflow and the <kbd>terraform apply</kbd> result will be shown as in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4d0c99fb-63ad-4621-b9c1-fb6521693be3.png"/></p>
<h2 id="uuid-06b7b838-7d59-4f28-9959-552378ec674c">How it works…</h2>
<p>In <em>step 2</em>, we added the <kbd>lifecycle</kbd> <span>block </span><span>to the </span><kbd>azurerm_app_service</kbd><span> </span><span>resource. I</span>n this block, we added the <kbd><span>create_before_destroy</span></kbd> property with its <span>value set to</span> <kbd>true</kbd><span>.</span> This property makes the <span>regeneration of a resource</span> possible in the event of destruction by indicating to Terraform to first recreate the resource, and only then to delete the original resource.</p>
<h2 id="uuid-5eff1f69-1534-4026-8570-2194443e7369">There’s more…</h2>
<p>As we've seen, by using this property, there is no more interruption of service. As long as the new resource is not created, the old one is not deleted and the application continues to be online.</p>
<p class="mce-root">However, before using <kbd>create_before_destroy</kbd>, there are some things to consider, as follows:</p>
<ul>
<li class="mce-root">The <kbd>create_before_destroy</kbd> property only works when a configuration change requires the deletion and then regeneration of resources. It only works when executing the <kbd>terraform apply</kbd> command; it does not work when executing the <kbd>terraform destroy</kbd> command.</li>
<li class="mce-root">You must be careful that the names of the resources that will be created have different names than the ones that will be destroyed afterward. Otherwise, if the names are identical, the resource may not be created.</li>
</ul>
<p class="mce-root">Moreover, this zero-downtime technique is only really effective if the resource that will be impacted is fully operational at the end of its creation. For example, let's take the case of a VM: although Terraform can quickly create it, it still remains after all its configuration has been carried out (the installation of the middleware and deployment of the application). All this configuration can generate downtime, and in order to <span>be efficient in </span>this case, I advise you to use Packer from HashiCorp (<a href="https://www.packer.io/">https://www.packer.io/</a>), which allows you to create images of VMs that are already fully configured.</p>
<div class="mce-root packt_infobox">To implement zero downtime in Azure with Packer and Terraform, read the tutorial at <a href="https://docs.microsoft.com/en-us/azure/developer/terraform/create-vm-scaleset-network-disks-using-packer-hcl">https://docs.microsoft.com/en-us/azure/developer/terraform/create-vm-scaleset-network-disks-using-packer-hcl</a>.<a href="https://docs.microsoft.com/en-us/azure/developer/terraform/create-vm-scaleset-network-disks-using-packer-hcl"/></div>
<p class="mce-root">Finally, we have seen in this recipe how to implement zero-downtime deployments with Terraform, but according to your provider, there are most likely other practices that are native to them. For example, we can also use load balancers, and for an App Service instance <span>on Azure, </span>we can use slots, as explained in the documentation at <a href="https://docs.microsoft.com/en-us/azure/app-service/deploy-staging-slots">https://docs.microsoft.com/en-us/azure/app-service/deploy-staging-slots</a>.</p>
<h2 id="uuid-996f54eb-c710-4034-80b8-925ac2ce3085">See also</h2>
<ul>
<li>
<p>Read the HashiCorp blog post about the <kbd>create_before_destroy</kbd> property at <a href="https://www.hashicorp.com/blog/zero-downtime-updates-with-terraform/">https://www.hashicorp.com/blog/zero-downtime-updates-with-terraform/</a>.</p>
</li>
<li class="mce-root">
<p>A good article on zero downtime can be found at <a href="https://dzone.com/articles/zero-downtime-deployment">https://dzone.com/articles/zero-downtime-deployment</a>.</p>
</li>
</ul>
<h1 id="uuid-612a7b8f-0f0a-4f99-8c6a-5c56ea609e4c">Detecting resources deleted by the plan command</h1>
<p>One of the key features of Terraform is the possibility to visualize a preview of changes in advance of their application to a given piece of infrastructure with the <kbd>terraform plan</kbd> command.</p>
<p class="mce-root">We have often discussed in this book displaying a visualization of changes in the terminal, but what we see less often is how to automatically evaluate and analyze the results of the <kbd>terraform plan</kbd> command.</p>
<p class="mce-root">In this recipe, we will see how to analyze the results of the <kbd>terraform plan</kbd> command.</p>
<h2 id="uuid-b5e8a0f9-ac8a-48d3-866d-c7c34657d781">Getting ready</h2>
<p>For the application of this recipe, we need to have the <strong>jq</strong> tool installed, available for download for all platforms from <a href="https://stedolan.github.io/jq/">https://stedolan.github.io/jq/</a>.</p>
<p class="mce-root">In this recipe, we will use jq on Windows with PowerShell, but all steps will be identical on other OSes.</p>
<p class="mce-root">The Terraform configuration used is available at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/detectdestroy">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/detectdestroy</a>, and we must run it on our infrastructure beforehand.</p>
<p class="mce-root">The purpose of this recipe is to detect via a script whether the execution of <kbd>terraform plan</kbd> will lead to the destruction of a resource.</p>
<h2 id="uuid-d9547c35-2b7f-4cb9-83d0-e9c63c68f1e7">How to do it…</h2>
<p>Perform the following steps to analyze the results of the <kbd>plan</kbd> command:</p>
<ol>
<li>Inside the Terraform configuration, we change the value of the <kbd>name</kbd> property (by adding the <span>word</span> <kbd>test</kbd>) in the App Service instance, as shown in the following code:</li>
</ol>
<pre style="padding-left: 60px"><span>resource </span><span>"azurerm_app_service" </span><span>"app" </span>{<br/>  <span>name </span>= <span>"${var.</span><span>app_name</span><span>}-test-${var.</span><span>environement</span><span>}"</span><br/>....<br/>}</pre>
<ol start="2">
<li>Then, we execute the <kbd>terraform init</kbd> command, followed by the <kbd>terraform plan</kbd> command:</li>
</ol>
<pre style="padding-left: 60px"><strong>terraform plan -out="tfout.tfplan"</strong></pre>
<ol start="3">
<li>Finally, we execute the following PowerShell script, which analyzes the number of deleted resources:</li>
</ol>
<pre style="padding-left: 60px"><strong>$tfplan = terraform show -json tfout.tfplan</strong><br/><strong>$actions = $tfplan | jq.exe .resource_changes[].change.actions[]</strong><br/><strong>$nbdelete = $actions -match <span>'delete' </span>| Measure-Object | Select-Object Count</strong><br/><strong>Write-Host $nbdelete.Count</strong></pre>
<div class="packt_infobox">This script is also available at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP07/detectdestroy/detectdestroy.ps1">https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP07/detectdestroy/detectdestroy.ps1</a>.</div>
<h2 id="uuid-505e916f-7557-4251-b623-b130c2bcabf2">How it works…</h2>
<p>In <em>step 1</em>, we modify the Terraform configuration by changing the name of the App Service instance, which will lead to the destruction of this resource during the <kbd>apply</kbd> command.</p>
<p class="mce-root">Then, in <em>step 2</em>, we execute the <kbd>terraform plan</kbd> command with the option <kbd>-out="tfout.tfplan"</kbd>, which allows us to get the output of <kbd>plan</kbd> in a file (in binary format).</p>
<p class="mce-root">Finally, in <em>step 3</em>, we write the PowerShell script that analyzes the generated plan for the number of resources that will be destroyed during the application. This script is made up of four lines. Here are the details:</p>
<ol>
<li class="mce-root">
<p>In line 1, we use the <kbd>terraform show</kbd> command on the <kbd>tfout.tfplan</kbd> file that was generated in <em>step 2.</em> To this command we added the <kbd>-json</kbd> option in order to get an output in JSON format.</p>
</li>
<li class="mce-root">
<p>In line 2, we use <strong>jq</strong> on the <span>JSON </span>result obtained from the previous line and filter the list of actions (which will be applied by Terraform) to obtain an array of actions (<kbd>add</kbd>, <kbd>delete</kbd>, and <kbd>no-op</kbd>).</p>
</li>
<li class="mce-root">
<p>In line 3, we filter on this array all <kbd>delete</kbd> actions and get the number of this filtered array using the  <kbd>Count</kbd> PowerShell object.</p>
</li>
<li class="mce-root">
<p>In the last line, we display the count value, which corresponds to the number of deleted resources.</p>
</li>
</ol>
<p>The following screenshot shows the result of this script:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1a286507-440d-4e30-a8cd-10b66c84cd88.png"/></p>
<p><kbd>$nbdelete.Count</kbd> returns <kbd>1</kbd>, which is equal to the number of resources that will be deleted.</p>
<h2 id="uuid-39e59616-2600-48e2-afd6-314c8314515c">There’s more…</h2>
<p>Regarding the language used for the scripting of this recipe, we wrote it in PowerShell, but it can of course be written in any scripting language, such as Bash or Python. We can also put this script into a function that was called just after the <kbd>terraform plan</kbd> command and did not <kbd>apply</kbd> the Terraform configuration if that function returned a positive delete number.</p>
<p class="mce-root">There are also other tools for parsing and processing the plan generated by the <kbd>terraform plan</kbd> command. Among these tools, there are <kbd>npm</kbd> packages such as <kbd>terraform-plan-parser</kbd>, available at <a href="https://github.com/lifeomic/terraform-plan-parser">https://github.com/lifeomic/terraform-plan-parser</a>, or <strong>Open Policy Agent for Terraform</strong> at <a href="https://www.openpolicyagent.org/docs/latest/terraform/">https://www.openpolicyagent.org/docs/latest/terraform/</a>.</p>
<h2 id="uuid-6b8f355b-20b7-4152-8d23-1c5efe6b56c7">See also</h2>
<ul>
<li>
<p>More detailed documentation on the JSON format of the <kbd>terraform plan</kbd> command is available at <a href="https://www.terraform.io/docs/internals/json-format.html">https://www.terraform.io/docs/internals/json-format.html</a>.</p>
</li>
<li class="mce-root">
<p>The <kbd>terraform show</kbd> command documentation is available at <a href="https://www.terraform.io/docs/commands/show.html">https://www.terraform.io/docs/commands/show.html</a>.</p>
</li>
</ul>
<h1 id="uuid-9678c0b3-6759-4405-8c41-ac375bec201f"><span>Managing Terraform configuration dependencies using Terragrunt</span></h1>
<p>In several recipes in this book, we have discussed the organization of the files that contain the Terraform configuration. We examined this more specifically in the <em>Provisioning infrastructure in multiple environments</em> <span>recipe </span>in <a href="3099c9ac-8c38-4e7d-8146-411fac26a2b7.xhtml">Chapter 2</a>, <em>Writing Terraform Configuration</em>, which outlines several architecture solutions.</p>
<p>One of the best practices regarding the structure of the configuration is to separate the Terraform configuration into infrastructure and application components, as explained in the article at <a href="https://www.cloudreach.com/en/resources/blog/how-to-simplify-your-terraform-code-structure/">https://www.cloudreach.com/en/resources/blog/how-to-simplify-your-terraform-code-structure/</a>. The challenge with a structure split into several configurations is the maintenance of dependencies and run schedules between these components.</p>
<p class="mce-root">Among all the third-party tools that revolve around Terraform, there is <strong>Terragrunt</strong> (<a href="https://terragrunt.gruntwork.io/">https://terragrunt.gruntwork.io/</a>), developed by Gruntwork. Terragrunt is open source and offers a lot of additional functionality for the organization and execution of Terraform configurations.</p>
<p class="mce-root">In this recipe, we will learn how you can use Terragrunt to manage the dependencies of different Terraform configurations.</p>
<h2 id="uuid-07ef9848-38f2-4e71-b7d2-e3b8bb9cbdfd">Getting ready</h2>
<p>For this recipe, we must have previously installed the Terragrunt binary on our workstations by following the instructions at <a href="https://terragrunt.gruntwork.io/docs/getting-started/install/#install-terragrunt">https://terragrunt.gruntwork.io/docs/getting-started/install/#install-terragrunt</a>.</p>
<p class="mce-root">In this recipe, we will build an infrastructure consisting of the following elements:</p>
<ul>
<li class="mce-root">A Resource Group</li>
<li class="mce-root">A network with a Virtual Network and a Subnet</li>
<li class="mce-root">A VM</li>
</ul>
<p class="mce-root CDPAlignLeft CDPAlign">The architecture of the folders containing this Terraform configuration is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4f3576d6-6718-43f0-9d97-fb53780172f9.png" style="width:21.75em;height:37.58em;"/></p>
<p class="mce-root">The problem with this architecture is the dependency between configurations, and the fact that they must be executed in a specific order. Indeed, to apply the network, the Resource Group must be applied first, and it's the same for the VM: the network must be created beforehand. With Terraform, in the case of several changes, the Terraform workflow must be executed several times and in the correct order for each of those configurations.</p>
<div class="mce-root packt_infobox">The purpose of this recipe is not to explain all the functionalities of Terragrunt in detail, but to demonstrate one of its features, which is to simplify the execution of Terraform when the Terraform configuration is separated into several folders that are linked by dependencies.</div>
<p>The source <span>code </span>of this recipe is available at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/demogrunt/dev">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/demogrunt/dev</a>.</p>
<h2 id="uuid-3ae831cf-8f9e-4ceb-955f-2ff552bd4244">How to do it…</h2>
<p>Perform the following steps to use Terragrunt with Terraform dependencies:</p>
<ol>
<li>To add the dependency between the <kbd>network</kbd> and <kbd>rg</kbd> configurations, inside the <kbd>network</kbd> folder add a new file called <kbd>terragrunt.hcl</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 60px"><span>dependencies </span>{<br/>  <span>paths </span>= [<span>"../rg"</span>]<br/>}</pre>
<ol start="2">
<li>Inside the <kbd>vm-dev</kbd> folder, add a new file called <kbd>terragrunt.hcl</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 60px"><span>dependencies </span>{<br/>  <span>paths </span>= [<span>"../rg"</span><span>, </span><span>"../network"</span>]<br/>}</pre>
<ol start="3">
<li>In a terminal, inside the <kbd>network</kbd> folder, run the following <kbd>terragrunt</kbd> commands to create the Resource Group and the network:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; terragrunt init</strong><br/><strong>&gt; terragrunt plan-all</strong><br/><strong>&gt; terragrunt apply-all</strong></pre>
<h2 id="uuid-0084eb95-8033-4d82-96a1-9c4bc9794019">How it works…</h2>
<p>The <kbd>terragrunt.hcl</kbd> file we added contains the configuration for Terragrunt.</p>
<p class="mce-root">Here, in the configuration we wrote in <em>step 2</em>, we indicated a dependency between the network configuration and the Resource Group configuration. This is because the Resource Group must be created before executing the network configuration.</p>
<p class="mce-root">In <em>step 3</em>, we then executed the Terragrunt commands (<kbd>terragrunt init</kbd>, <kbd>terragrunt plan-all</kbd>, and <kbd>terragrunt apply-all</kbd>) and when executing them, thanks to the configuration we wrote, Terragrunt will first apply Terraform to the Resource Group and then to the network automatically. This without having to apply the Terraform workflow several times on several Terraform configurations and in the right order.</p>
<h2 id="uuid-32678389-3b90-45a5-b4e4-33c3d6355ad8">There’s more…</h2>
<p>In this recipe, we studied how to improve the dependency between the Terraform configuration using Terragrunt and its configuration. We can go even further with this improvement, by externalizing the configuration (which is redundant between each environment) by reading the documentation available at <a href="https://terragrunt.gruntwork.io/docs/features/execute-terraform-commands-on-multiple-modules-at-once/">https://terragrunt.gruntwork.io/docs/features/execute-terraform-commands-on-multiple-modules-at-once/</a>.</p>
<p class="mce-root">However, since Terragrunt runs the Terraform binary that is installed on your local computer, you should make sure to install a version of Terragrunt that is compatible with the version of the Terraform binary installed.</p>
<p class="mce-root">In the next recipe, we will complete the configuration of Terragrunt to be able to use it as a wrapper for Terraform by simplifying the Terraform command lines.</p>
<h2 id="uuid-0f6bcea6-7915-4a5d-a853-0661292b8961">See also</h2>
<ul>
<li>
<p>The detailed documentation of Terragrunt is available at <a href="https://terragrunt.gruntwork.io/docs/#features">https://terragrunt.gruntwork.io/docs/#features</a>.</p>
</li>
<li class="mce-root">
<p>The source code for Terragrunt is available on GitHub at <a href="https://github.com/gruntwork-io/terragrunt">https://github.com/gruntwork-io/terragrunt</a>.</p>
</li>
<li class="mce-root">
<p>A useful blog article on the architecture of the Terraform configuration can be found at <a href="https://www.hashicorp.com/blog/structuring-hashicorp-terraform-configuration-for-production/">https://www.hashicorp.com/blog/structuring-hashicorp-terraform-configuration-for-production/</a>.</p>
</li>
</ul>
<h1 id="uuid-842fde4e-80be-460d-8b0c-ac2ce13f5872"><span>Using Terragrunt as a wrapper for Terraform</span></h1>
<p>In the many years that I have been working and supporting customers on Terraform, there is a recurring problem that prevents users from making full use of Terraform's functionality. What I have noticed is that these users do not encounter any problems with the language and the writing of the provider's resource configuration, but they do have difficulty with the automation of the Terraform client through the use of command lines for their workflow.</p>
<p class="mce-root">To simplify the automation of the Terraform workflow, whether for use on a local workstation or in a CI/CD pipeline, we can use Terragrunt as Terraform wrapper that integrates the Terraform workflow.</p>
<p class="mce-root">What we will learn in this recipe is how to use Terragrunt (which we have already studied in the previous recipe) as a Terraform wrapper.</p>
<h2 id="uuid-728c7eda-dac4-48fb-a563-228ef2afa9e9">Getting ready</h2>
<p>For this recipe, we must have previously installed the Terragrunt binary on our workstations by following the instructions at <a href="https://terragrunt.gruntwork.io/docs/getting-started/install/#install-terragrunt">https://terragrunt.gruntwork.io/docs/getting-started/install/#install-terragrunt</a>.</p>
<p class="mce-root">The Terraform configuration used in this recipe is available at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/demogrunt-wrapper">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/demogrunt-wrapper</a>. It allows us to build resources in Azure. It uses an <kbd>env-dev.tfvars</kbd> <span>variable file </span>and a remote backend configuration file (<kbd>azurerm</kbd>) in the <kbd>backend.tfvars</kbd> <span>file.</span> To create this infrastructure, the following Terraform commands must be executed:</p>
<pre class="mce-root"><strong>&gt; terraform init -backend-config="backend.tfvars"</strong><br/><strong>&gt; terraform plan -var-file="env-vars.tfvars"</strong><br/><strong>&gt; terraform apply -var-file="env-vars.tfvars"</strong></pre>
<div class="mce-root packt_infobox">The Terraform configuration of this resource creates resources in Azure, but what we will study in this recipe applies to any Terraform configuration.</div>
<p class="mce-root">The purpose of this recipe is to use the Terragrunt configuration to help execute these Terraform commands in an automation context.</p>
<h2 id="uuid-a48156cb-a8e6-4d46-8ef5-d94cc8b2818c">How to do it…</h2>
<p>Perform the following steps to use Terragrunt as a Terraform CLI wrapper:</p>
<ol>
<li>Inside the folder that contains the Terraform configuration, create a new file called <kbd>terragrunt.hcl</kbd>.</li>
<li>In this file, add the following configuration section to configure the <kbd>init</kbd> command:</li>
</ol>
<pre style="padding-left: 60px"><span>extra_arguments </span><span>"custom_backend" </span>{<br/>  <span>commands </span>= [<br/>    <span>"init"<br/></span><span>  </span>]<br/><br/>  <span>arguments </span>= [<br/>    <span>"-backend-config"</span><span>, </span><span>"backend.tfvars"<br/></span><span>  </span>]<br/>}</pre>
<ol start="3">
<li>Add the following code to configure the <kbd>plan</kbd> and <kbd>apply</kbd> commands:</li>
</ol>
<pre style="padding-left: 60px"><span>extra_arguments </span><span>"custom_vars-file" </span>{<br/>  <span>commands </span>= [<br/>    <span>"apply"</span><span>,<br/></span><span>    </span><span>"plan"</span><span>,<br/></span><span>    </span><span>"destroy"</span><span>,<br/></span><span>    </span><span>"refresh"<br/></span><span>  </span>]<br/><br/>  <span>arguments </span>= [<br/>    <span>"-var-file"</span><span>, </span><span>"env-vars.tfvars"<br/></span><span>  </span>]<br/>}</pre>
<ol start="4">
<li>In the command-line terminal, from <span>the folder that contains the Terraform configuration</span>, run the following Terragrunt command to initialize the Terraform context:</li>
</ol>
<pre style="padding-left: 60px"><strong>terragrunt init</strong></pre>
<ol start="5">
<li>Finally, run the following Terragrunt commands to apply the changes we've made:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; terragrunt plan</strong><br/><strong>&gt; terragrunt apply</strong></pre>
<h2 id="uuid-7de11195-a870-4db7-be55-e953eeafec32">How it works…</h2>
<p>In <em>step 1</em>, we created the <kbd>terragrunt.hcl</kbd> <span>file, </span>which will contain the Terragrunt configuration of the Terraform wrapper. In <em>step 2</em>, we described in this file the Terraform execution configuration for the <kbd>init</kbd> command. In the list of commands, we indicate that this configuration applies for the <kbd>init</kbd> command and in the list of arguments we put an entry for the <kbd>--backend-config</kbd> <span>option, </span>which takes as a value the <kbd>backend.tfvars</kbd> <span>file.</span></p>
<p>Then in <em>step 3</em>, we did the same operation for the <kbd>plan</kbd> and <kbd>apply</kbd> commands. In this configuration, we specify the list of commands: <kbd>plan</kbd>, <kbd>apply</kbd>, <kbd>destroy</kbd>, and <kbd>refresh</kbd>. For the arguments, we indicate the <kbd>-var-file="env-vars.tfvars"</kbd> <span>option.</span></p>
<p class="mce-root">Once this configuration file is finished being written, we use it to run Terragrunt. In <em>step 4</em>, we execute the <kbd>terragrunt init</kbd> <span>command, </span>which will use the configuration we wrote and so will execute the following command:</p>
<pre class="mce-root"><strong>terraform init -backend-config="backend.tfvars"</strong></pre>
<p class="mce-root">You can see this in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c5dd8b74-c2f7-46fb-ac66-1736845a1a3d.png"/></p>
<p class="mce-root">Finally, to preview the changes, we execute the <kbd>terragrunt plan</kbd> command, which will use the configuration we wrote and will therefore execute the <span>following </span>command:</p>
<pre class="mce-root"><strong>terraform plan -var-file="env-vars.tfvars"</strong></pre>
<p class="mce-root">You can see this in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f109b541-10f0-4308-b031-ada3242cda89.png"/></p>
<p class="mce-root">If these changes correspond to your expectations, you can use the following Terragrunt command to apply these changes:</p>
<pre class="mce-root"><strong>terragrunt apply</strong></pre>
<h2 id="uuid-12030324-52b8-42c4-829e-a451d8b9e1c6">See also</h2>
<p>Detailed CLI configuration documentation is available at <a href="https://terragrunt.gruntwork.io/docs/features/keep-your-cli-flags-dry/">https://terragrunt.gruntwork.io/docs/features/keep-your-cli-flags-dry/</a>.</p>
<h1 id="uuid-919a1766-da0d-4658-8f9e-6713c6f09b9a">Building CI/CD pipelines for Terraform configurations in Azure Pipelines</h1>
<div>
<p><span>In all of the previous recipes in this book, we've discussed Terraform configuration, CLI execution, and its benefits for IaC. </span></p>
<p><span>Now, in this recipe, we will discuss how we will integrate this Terraform workflow into a CI/CD pipeline in Azure Pipelines using the Terraform extension for Azure DevOps and Pipelines YAML.</span></p>
</div>
<h2 id="uuid-3f89c2f1-8543-48a0-8604-fa34d9110b37">Getting ready</h2>
<p>Before automating Terraform in any CI/CD pipeline, it is recommended to read HashiCorp's <span>automation guides with recommendations for </span>Terraform. These guides are available here:</p>
<ul>
<li><a href="https://learn.hashicorp.com/terraform/development/running-terraform-in-automation">https://learn.hashicorp.com/terraform/development/running-terraform-in-automation</a></li>
<li><a href="https://www.terraform.io/docs/cloud/guides/recommended-practices/part3.html">https://www.terraform.io/docs/cloud/guides/recommended-practices/part3.html</a></li>
</ul>
<p>The purpose of this recipe is not to explain in detail how Azure Pipelines works, but just to focus on the execution of Terraform in Azure Pipelines. To learn more about Azure Pipelines, I suggest you look at the official documentation at <a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/index?view=azure-devops">https://docs.microsoft.com/en-us/azure/devops/pipelines/index?view=azure-devops</a>.</p>
<p>To use Terraform in Azure Pipelines, there are a couple of solutions:</p>
<ul>
<li>
<p>Using custom scripts (PowerShell and Bash) executing the Terraform CLI commands</p>
</li>
<li>
<p>Using Terraform extensions for Azure DevOps</p>
</li>
</ul>
<p class="mce-root">Here in this recipe, we will learn how to use the Terraform extension for Azure DevOps published by Charles Zipp (in the knowledge there are, of course, other extensions available by other publishers).</p>
<p class="mce-root">To install this extension, implement the following steps:</p>
<ol>
<li class="mce-root">
<p>Go to <a href="https://marketplace.visualstudio.com/items?itemName=charleszipp.azure-pipelines-tasks-terraform">https://marketplace.visualstudio.com/items?itemName=charleszipp.azure-pipelines-tasks-terraform</a> in your browser and click on <span class="packt_screen">Terraform Build &amp; Release Tasks</span>.</p>
</li>
<li class="mce-root">
<p>At the top of the page, click on <span class="packt_screen">Get it free</span>.</p>
</li>
<li class="mce-root">
<p>On the installation page, in the <span class="packt_screen">Organization</span> dropdown, choose the organization to which the extension will be installed (<span class="packt_screen">1</span>), then click on the <span class="packt_screen">Install</span> button (<span class="packt_screen">2</span>):</p>
</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/22b2d1d6-ac59-4167-9388-1f4682edd62c.png" style="width:38.75em;height:15.50em;"/></p>
<p class="mce-root">The extension will be installed on your Azure DevOps organization.</p>
<p>Additionally, for the Terraform state file, we will use a remote backend. In order to be able to use it in Azure (Azure Storage, to be precise) with Terraform, we learned in the <em>Protecting the state file in Azure remote backend</em> <span>recipe </span>of <a href="d054157b-d534-47c9-8079-3af13107c4ef.xhtml">Chapter 6</a>, <em>Provisioning Azure Infrastructure with Terraform</em>, that an Azure service principal must be created.</p>
<p>To create this connection with Azure, in Azure Pipelines, we go to set up a service connection with the information from the created Azure service principal. To operate this, in the project settings, we navigate to the <span class="packt_screen">Service connections</span> menu. Then we create a new <span class="packt_screen">Azure RM</span> service connection and configure it with the service properties.</p>
<p class="mce-root">The following screenshot shows the service connection to my <span class="packt_screen">Azure Terraform Demo</span> configuration:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/12d4dda9-ac4b-4212-8a85-653e70ed3930.png" style="width:49.67em;height:41.33em;"/></p>
<p>Finally, the code that contains the Terraform configuration must be stored in a Git repository, such as GitHub or Azure Repos (in this recipe, we will use GitHub).</p>
<p>Note that in this recipe, we will not study the deployed Terraform configuration code, which is very basic (it generates a random string) – its purpose is to demonstrate the implementation of the pipeline.</p>
<p>The Terraform configuration source code that will be used in this recipe is available at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/pipeline">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/pipeline</a>.</p>
<h2 id="uuid-30332d66-0005-4275-9aa9-19046f5d59ff">How to do it…</h2>
<p>To create the pipeline, we performing the following steps:</p>
<ol>
<li class="mce-root">In the Azure Pipelines menu, click <span class="packt_screen">Pipelines</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/63f31f5c-6930-4ac5-abf6-098c5512bbaa.png" style="width:14.17em;height:29.08em;"/></p>
<ol start="2">
<li class="mce-root CDPAlignLeft CDPAlign">Click on the <span class="packt_screen">Create Pipeline</span> button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8e9d534b-4e4a-4fa6-8276-4d19cf374cb8.png" style="width:26.67em;height:16.25em;"/></p>
<ol start="3">
<li class="mce-root">For the code source, select the Git repository that contains the Terraform configuration. For this recipe, we choose our GitHub repository and select the <span class="packt_screen">Starter pipeline</span> option to start with a new pipeline from scratch:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0d40134d-ef1b-4ec1-aee5-c0ff3d1b9328.png" style="width:34.00em;height:15.17em;"/></p>
<ol start="4">
<li>The pipeline editor <span>opens and you can start writing the CI/CD steps directly online.</span> Let's look at the code for this pipeline, which is in YAML format. First, we're going to configure the pipeline options with the following code to use an Ubuntu agent:</li>
</ol>
<div>
<pre style="padding-left: 60px"><span>trigger</span>:<br/>  - master<br/><span>pool</span>:<br/>  <span>vmImage</span>: <span>'ubuntu-latest'</span></pre></div>
<ol start="5">
<li>Then, we tell the pipeline to dow<span>nload the desired version of the Terraform binary by adding this code:</span></li>
</ol>
<div>
<pre style="padding-left: 60px">- <span>task</span>: charleszipp.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-installer.TerraformInstaller@0<br/>  <span>displayName</span>: <span>'Install Terraform 0.12.26'<br/></span><span>  </span><span>inputs</span>:<br/>    <span>terraformVersion</span>: 0.12.26</pre></div>
<div>
<ol start="6">
<li>We continue with the first command<span> of the Terraform workflow and execute the </span><kbd><span>terraform init</span></kbd><span> command:</span></li>
</ol>
<div>
<pre style="padding-left: 60px">- <span>task</span>: charleszipp.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-cli.TerraformCLI@0<br/>  <span>displayName</span>: <span>'terraform init'<br/></span><span>  </span><span>inputs</span>:<br/>    <span>command</span>: init<br/>    <span>workingDirectory</span>: <span>"CHAP07/pipeline/"<br/></span><span>    </span><span>backendType</span>: azurerm<br/>    <span>backendServiceArm</span>: <span>'&lt;Your Service connection name&gt;'<br/></span><span>    </span><span>backendAzureRmResourceGroupName</span>: <span>'RG_BACKEND'<br/></span><span>    </span><span>backendAzureRmStorageAccountName</span>: storagetfbackendbook<br/>    <span>backendAzureRmContainerName</span>: tfstate<br/>    <span>backendAzureRmKey</span>: myappdemo.tfstate</pre></div>
</div>
<div>
<ol start="7">
<li>After the <kbd>init</kbd> step, the pipeline executes the <kbd>terraform plan</kbd> command for preview and displays the changes that the pipeline will apply:</li>
</ol>
</div>
<div>
<pre style="padding-left: 60px">- <span>task</span>: charleszipp.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-cli.TerraformCLI@0<br/>  <span>displayName</span>: <span>'terraform plan'<br/></span><span>  </span><span>inputs</span>:<br/>    <span>command</span>: plan<br/>    <span>workingDirectory</span>: <span>"CHAP07/pipeline/"<br/></span><span>    </span><span>commandOptions</span>: <span>'-out="out.tfplan"'</span></pre></div>
<ol start="8">
<li>And finally, the pipeline runs the <kbd>terraform apply</kbd> command to apply the changes:</li>
</ol>
<div>
<pre style="padding-left: 60px">- <span>task</span>: charleszipp.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-cli.TerraformCLI@0<br/>  <span>displayName</span>: <span>'terraform apply'<br/></span><span>  </span><span>inputs</span>:<br/>    <span>command</span>: apply<br/>    <span>workingDirectory</span>: <span>"CHAP07/pipeline/"<br/></span><span>    </span><span>commandOptions</span>: <span>'out.tfplan'</span></pre></div>
<div>
<div>
<p style="padding-left: 60px"><span>The complete source code of this pipeline in YAML is available at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP07/pipeline/azure-pipelines.yml">https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP07/pipeline/azure-pipelines.yml</a>.</span></p>
</div>
</div>
<ol start="9">
<li>After editing the YAML code of the pipeline, we can test it and trigger the execution of the pipeline by clicking on <span class="packt_screen">Save and run</span> at the top right of the page:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fc7be25f-c673-4008-a1f7-f1312c953c2c.png" style="width:37.92em;height:26.67em;"/></div>
<ol start="10">
<li>When the e<span>xecution of the pipeline is finished, we will be able to see the log results of the execution:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/14c19538-458b-4e02-b20f-054f707033a8.png"/></div>
<h2 id="uuid-89d6a47a-6444-4de0-ada2-41b6d5ff51a9">How it works…</h2>
<p>In <em>steps 1</em> to <em>3</em> of this recipe, we used Azure Pipelines <span>via the web interface </span>to create a new pipeline that we configured on our GitHub repository. Moreover, we made the choice to configure it by starting with a new YAML file.</p>
<p class="mce-root"><em>Step 4</em> was dedicated to writing the YAML code for our pipeline in which we defined the following steps:</p>
<ol>
<li> We downloaded the Terraform binary and specified the version that is compatible with our Terraform configuration.</li>
</ol>
<div class="packt_infobox">Even if you are using an agent hosted by Microsoft that already has Terraform installed, I advise you to download Terraform because the version installed by default may not be compatible with your configuration.</div>
<ol start="2">
<li class="mce-root">Then, using the e<span>xtension installed in the prerequisites,</span> <span>we execute the Terraform workflow with a step for the</span> <kbd>terraform init</kbd> command <span>and the use of the Azure remote backend. We then execute the</span> <kbd>terraform plan</kbd> <span>command with the <kbd>out</kbd> argument, which generates a</span> <kbd>plan</kbd> output f<span>ile. Finally, we apply the changes by executing the</span> <kbd>terraform apply</kbd> <span>command using the generated plan file.</span></li>
</ol>
<div class="packt_infobox">The <kbd>terraform apply</kbd> command used by this last task has the <kbd>-auto-appprove</kbd> option to allow changes to be applied automatically.</div>
<p class="mce-root">Finally, in the last step of the recipe, the pipeline is triggered and it is clear from the output logs that the changes described in the Terraform configuration have been applied.</p>
<h2 id="uuid-70ecb35a-3291-42e2-b62e-8ec693581682">There's more…</h2>
<p>We have seen in this recipe how to create a pipeline for Terraform from an empty YAML file, but you can also create a pipeline using a prewritten YAML file archived in your Git repository.</p>
<div class="packt_infobox"><span>If you want to use Terraform in an Azure DevOps pipeline using the classic mode (that is, in graphical mode without YAML), you can refer to the hands-on labs at </span><a href="https://www.azuredevopslabs.com/labs/vstsextend/terraform/">https://www.azuredevopslabs.com/labs/vstsextend/terraform/</a>.</div>
<p class="mce-root">If your Terraform configuration deploys an infrastructure in Azure, and you want to use a custom script inside the pipeline instead of the Terraform task, then you will have to add,<span> in the </span><span class="packt_screen">Variables</span><span> tab,</span> the four environment variables of the main service used for authentication in Azure (we studied these in the <em>Protecting the Azure Credential Provider</em> <span>recipe </span>of <a href="d054157b-d534-47c9-8079-3af13107c4ef.xhtml">Chapter 6</a>, <em>Provisioning Azure Infrastructure with Terraform</em>), as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8bef1b55-c150-4b7a-b12f-a3152e7a8a06.png" style="width:23.42em;height:20.58em;"/></p>
<p class="mce-root">These four variables will be automatically loaded as environment variables in the pipeline execution session.</p>
<p class="mce-root">Additionally, in this recipe, we used a CI/CD Azure Pipelines platform<span> as an example</span>, but the automation principle remains the same for all DevOps tools, including Jenkins, GitHub Actions, GitLab, and so on.</p>
<h2 id="uuid-bf65544a-7f6c-419e-b928-36c41feecc6b">See also</h2>
<p>The following is a list of links to articles and videos related to this topic:</p>
<ul>
<li>Terraform on Microsoft Azure – <em>Continuous Deployment using Azure Pipelines</em>: <a href="https://blog.jcorioland.io/archives/2019/10/02/terraform-microsoft-azure-pipeline-continuous-deployment.html">https://blog.jcorioland.io/archives/2019/10/02/terraform-microsoft-azure-pipeline-continuous-deployment.html</a></li>
<li>A CI/CD journey with Azure DevOps and Terraform: <a href="https://medium.com/faun/a-ci-cd-journey-with-azure-devops-and-terraform-part-3-8122624efa97">https://medium.com/faun/a-ci-cd-journey-with-azure-devops-and-terraform-part-3-8122624efa97</a> (see part 1 and part 2)</li>
<li>Deploying Terraform Infrastructure using Azure DevOps Pipelines step by step: <a href="https://medium.com/@gmusumeci/deploying-terraform-infrastructure-using-azure-devops-pipelines-step-by-step-d58b68fc666d">https://medium.com/@gmusumeci/deploying-terraform-infrastructure-using-azure-devops-pipelines-step-by-step-d58b68fc666d</a></li>
<li>Terraform deployment with Azure DevOps: <a href="https://www.starwindsoftware.com/blog/azure-devops-terraform-deployment-with-azure-devops-part-1">https://www.starwindsoftware.com/blog/azure-devops-terraform-deployment-with-azure-devops-part-1</a></li>
<li>Infrastructure as Code (IaC) with Terraform and Azure DevOps: <a href="https://itnext.io/infrastructure-as-code-iac-with-terraform-azure-devops-f8cd022a3341">https://itnext.io/infrastructure-as-code-iac-with-terraform-azure-devops-f8cd022a3341</a></li>
<li>Terraform all the Things with VSTS: <a href="https://www.colinsalmcorner.com/terraform-all-the-things-with-vsts/">https://www.colinsalmcorner.com/terraform-all-the-things-with-vsts/</a></li>
<li>Terraform CI/CD with Azure DevOps: <a href="https://www.youtube.com/watch?v=_oMacTRQfyI">https://www.youtube.com/watch?v=_oMacTRQfyI</a></li>
<li>Deploying your Azure Infrastructure with Terraform: <a href="https://www.youtube.com/watch?v=JaesylupZa8">https://www.youtube.com/watch?v=JaesylupZa8</a></li>
<li>Enterprise Deployment to Azure and AWS in Azure DevOps: <a href="https://www.hashicorp.com/resources/enterprise-deployment-to-azure-and-aws-in-azure-devops/">https://www.hashicorp.com/resources/enterprise-deployment-to-azure-and-aws-in-azure-devops/</a></li>
</ul>
<h1 id="uuid-368506eb-5812-4ab1-862a-a0de9ba44fca">Working with workspaces in CI/CD</h1>
<p>In the <em>Using workspaces for managing environments</em> <span>recipe </span>in <a href="fc591e87-b893-40fa-9021-7827bffcc094.xhtml">Chapter 4</a>,<a href="fc591e87-b893-40fa-9021-7827bffcc094.xhtml"/> <em>Using the Terraform CLI</em>, we studied the use of some Terraform commands to manage and create workspaces. In Terraform's vision, workspaces make it possible to manage several environments by creating several Terraform state files for the same Terraform configuration.</p>
<p class="mce-root">In this recipe, we will go further with the use of workspaces by automating their creation in a CI/CD pipeline.</p>
<h2 id="uuid-9de725bd-a8de-41d9-9de5-f4edf69cd1ca">Getting ready</h2>
<p>The prerequisite for this recipe is to know the Terraform command-line options for the workspaces, the documentation for which is available at <a href="https://www.terraform.io/docs/commands/workspace/index.html">https://www.terraform.io/docs/commands/workspace/index.html</a>.</p>
<p class="mce-root">Concerning the CI/CD pipeline, we will implement it in Azure Pipelines, which we have already seen in this chapter, in the <em>Building CI/CD pipelines for Terraform configuration in Azure Pipelines </em><span>recipe</span>.</p>
<p class="mce-root">The purpose of this recipe is to illustrate a scenario I recently implemented, which is the creation of on-demand environments with Terraform. These environments will be used to test the functionalities during the development of an application.</p>
<div class="mce-root packt_infobox">To summarize, we want to deploy the code of a branch of a Git repository in a specific environment that will be used to test this development.</div>
<p class="mce-root">In this recipe, we will use the Terraform configuration at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/workspace-pipeline">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/workspace-pipeline</a> and the YAML pipeline from <a href="https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP07/pipeline/azure-pipelines.yml">https://github.com/PacktPublishing/Terraform-Cookbook/blob/master/CHAP07/pipeline/azure-pipelines.yml</a>. We will just complete it with our workspace management practice. We assume that the name of the workspace we will create will be the name of the Git branch that will be deployed.</p>
<p>The complete source code of this recipe is available at <a href="https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/workspace-pipeline">https://github.com/PacktPublishing/Terraform-Cookbook/tree/master/CHAP07/workspace-pipeline</a>.</p>
<h2 id="uuid-dc69392e-4507-4687-a012-3d7bcc5d6d3e">How to do it…</h2>
<p>To manage workspaces in the YAML <span>pipeline</span>, perform the following steps:</p>
<ol>
<li>Inside the folder that contains the Terraform configuration, add the <kbd>ManageWorkspaces.ps1</kbd> <span>file </span>with the following content:</li>
</ol>
<pre style="padding-left: 60px">$envName=$args[<span>0</span>]<br/>$countws = terraform workspace list -no-color | Select-String $envName -AllMatches<br/><span>if </span>($countws.Matches.Count -eq <span>0</span>) {<br/>    Write-Host <span>"Create new Workspace </span>$envName<span>"<br/></span><span>    </span>terraform workspace new $envName<br/>}<span>else</span>{<br/>    Write-Host <span>"The Workspace </span>$envName<span> already exist and is selected"<br/></span><span>    </span>terraform workspace select $envName<br/>}</pre>
<ol start="2">
<li>Inside the <kbd>azure-pipelines.yaml</kbd> file, add the following code just after the Terraform <kbd>init</kbd> step:</li>
</ol>
<pre style="padding-left: 60px">- <span>task</span>: PowerShell@2<br/>  <span>inputs</span>:<br/>    <span>filePath</span>: <span>'CHAP07/workspace-pipeline/ManageWorkspaces.ps1'<br/></span><span>    </span><span>arguments</span>: <span>'$(Build.SourceBranchName)'<br/></span><span>    </span><span>workingDirectory</span>: <span>"CHAP07/workspace-pipeline/"</span></pre>
<ol start="3">
<li>
<p>Commit and push the PowerShell script that we just created and the YAML pipeline file changes inside your Git repository.</p>
</li>
<li>
<p>In Azure Pipelines, run the pipeline, and during the configuration step, choose the right branch to deploy to from the <span class="packt_screen">Branch/tag</span> drop-down menu:</p>
</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2aced576-143b-410c-b6d5-7f92efc7756e.png" style="width:28.75em;height:32.33em;"/></p>
<p style="padding-left: 60px">Lastly, run the pipeline by clicking on the <span class="packt_screen">Run</span> button.</p>
<h2 id="uuid-82efb56b-5675-4d51-96eb-617a388f749f">How it works…</h2>
<p>In <em>step 1</em>, we create a PowerShell script that takes as an input parameter the name of the environment to create (which corresponds to the name of the branch to deploy). Then, in line 2, this script executes the <kbd>terraform workspace list</kbd> command, which displays the list of workspaces and searches for a workspace with the name of the environment passed as a parameter. If this search does not find a workspace, it executes the <kbd>terraform workspace new</kbd> command to create it. Otherwise, if the workspace exists, this script executes the <kbd>terraform workspace select</kbd> command to select it.</p>
<div class="mce-root packt_infobox">Note that the <kbd>terraform workspace create</kbd> command creates a workspace and selects it as well.</div>
<p class="mce-root">In <em>step 2</em>, we complete the YAML pipeline that we created in the previous recipe by inserting between <kbd>init</kbd> and <kbd>plan</kbd> the execution of this PowerShell script by passing as an argument the name of the branch that we sectioned.</p>
<p class="mce-root">Then, we commit these code changes (the PowerShell script and the pipeline YAML file) to the Git repository.</p>
<p class="mce-root">Finally, in <em>step 4</em>, we execute the pipeline in Azure Pipelines by selecting the branch to be deployed, the name of which will be used as the workspace name.</p>
<p class="mce-root">The following screenshot shows the execution result in the pipeline logs:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e6ac8cfb-5e31-419a-bbba-eb4c351acabb.png"/></p>
<p class="mce-root">And in the end, we can see the Terraform state files that were created automatically:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c89ad528-1f42-4116-a9a6-51c354b7d398.png" style="width:18.75em;height:8.50em;"/></p>
<p class="mce-root">As you can see, the Terraform state files created by the workspaces contain the workspace name at the end.</p>
<h2 id="uuid-da918d38-7da4-4dcc-b8ed-7fe31b597f68">There's more…</h2>
<p>In this recipe, we have managed the workspaces using a PowerShell script, but you are of course free to write it in another scripting language of your choice, such as Bash or Python.</p>
<h2 id="uuid-eb78b1f9-3e8b-4abd-aeb2-e6093e096361">See also</h2>
<ul>
<li>
<p>Before using multiple workspaces, make sure to check their compatibility with the backends by following the instructions at <a href="https://www.terraform.io/docs/state/workspaces.html">https://www.terraform.io/docs/state/workspaces.html</a>.<a href="https://www.terraform.io/docs/state/workspaces.html"/></p>
</li>
<li class="mce-root">
<p>The documentation on CLI commands for workspaces in Terraform is available at <a href="https://www.terraform.io/docs/commands/workspace/index.html">https://www.terraform.io/docs/commands/workspace/index.html</a>.</p>
</li>
</ul>


            </article>

            
        </section>
    </body></html>